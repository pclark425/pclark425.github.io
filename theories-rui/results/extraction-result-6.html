<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-6 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-6</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-6</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-1.html">extraction-schema-1</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of algorithmic and deterministic approaches to protein folding, including physics-based methods, energy minimization algorithms, force field approaches, and rule-based folding methods.</div>
                <p><strong>Paper ID:</strong> paper-5cd68f261e6e3354b07f5615f14d8c2c118010c8</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/5cd68f261e6e3354b07f5615f14d8c2c118010c8" target="_blank">Protofold II: Enhanced Model and Implementation for Kinetostatic Protein Folding</a></p>
                <p><strong>Paper Venue:</strong> arXiv.org</p>
                <p><strong>Paper TL;DR:</strong> This article improves the free energy formulation used in Protofold by including the typically underrated entropic effects, imparted due to differences in hydrophobicity of the chemical groups, which dominate the folding of most water-soluble proteins.</p>
                <p><strong>Paper Abstract:</strong> A reliable prediction of 3D protein structures from sequence data remains a big challenge due to both theoretical and computational difficulties. We have previously shown that our kinetostatic compliance method (KCM) implemented into the Protofold package can overcome some of the key difficulties faced by other de novo structure prediction methods, such as the very small time steps required by the molecular dynamics (MD) approaches or the very large number of samples needed by the Monte Carlo (MC) sampling techniques. In this article, we improve the free energy formulation used in Protofold by including the typically underrated entropic effects, imparted due to differences in hydrophobicity of the chemical groups, which dominate the folding of most water-soluble proteins. In addition to the model enhancement, we revisit the numerical implementation by redesigning the algorithms and introducing efficient data structures that reduce the expected complexity from quadratic to linear. Moreover, we develop and optimize parallel implementations of the algorithms on both central and graphics processing units (CPU/GPU) achieving speed-ups up to two orders of magnitude on the GPU. Our simulations are consistent with the general behavior observed in the folding process in aqueous solvent, confirming the effectiveness of model improvements. We report on the folding process at multiple levels; namely, the formation of secondary structural elements and tertiary interactions between secondary elements or across larger domains. We also observe significant enhancements in running times that make the folding simulation tractable for large molecules.</p>
                <p><strong>Cost:</strong> 0.026</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e6.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e6.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of algorithmic and deterministic approaches to protein folding, including physics-based methods, energy minimization algorithms, force field approaches, and rule-based folding methods.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>KCM / Protofold II</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Kinetostatic Compliance Method as implemented in Protofold II</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A deterministic kinetostatic (1st-order) folding algorithm that models the polypeptide as a reduced-DOF kinematic linkage and advances dihedral angles proportional to joint torques computed from an empirical free-energy-derived force field; implemented in the Protofold II package with algorithmic accelerations and GPU/CPU parallelism.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_name</strong></td>
                            <td>Kinetostatic Compliance Method (KCM) / Protofold II</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_description</strong></td>
                            <td>Model: protein chain is represented as a kinematic linkage (rigid peptide planes + revolute joints at torsion angles, side-chain rotamers). At each iteration: (1) compute rigid-body transforms from dihedral angles (forward kinematics) to get atom coordinates; (2) build proximity data structures (3D spatial hash grid) to identify neighbor sets under cutoffs; (3) compute forces on atoms from electrostatics (modified Coulomb), van der Waals (Lennard-Jones 6-12), and nonpolar solvation (linear SASA model) and aggregate per-link resultant forces/torques; (4) convert link forces/torques to joint torques using manipulator Jacobians and prefix-sum aggregation; (5) update dihedral angles via a kinetostatic stepping rule Δθ_j = κ τ_j / |τ_max| (a steepest-descent-like step along energy gradient); repeat until convergence. Protofold II adds: SASA surface-enumeration for solvation, 3D hash table, bonds tree for interaction classification, surface sampling enumeration (quasi-uniform deterministic sampling), CPU/GPU parallel kernels and prefix-sum based torque aggregation.</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_type</strong></td>
                            <td>constraint-based kinetostatic energy minimization (physics-based / de novo)</td>
                        </tr>
                        <tr>
                            <td><strong>is_deterministic</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>underlying_principles</strong></td>
                            <td>Free-energy minimization (thermodynamic hypothesis), kinetostatic compliance (first-order/steepest-descent-like angle updates), molecular mechanics force-field components (electrostatics, van der Waals, nonpolar solvation via SASA).</td>
                        </tr>
                        <tr>
                            <td><strong>force_field_or_energy_function</strong></td>
                            <td>AMBER-style intramolecular terms (modified Coulomb electrostatics with distance-dependent dielectric; Lennard-Jones 6-12 van der Waals) plus linear implicit nonpolar solvation term G_cav = Σ γ_j A_j^{exp} (SASA-based) with atomic solvation parameters.</td>
                        </tr>
                        <tr>
                            <td><strong>computational_complexity</strong></td>
                            <td>Expected O(n) per KCM cycle for most steps (forward kinematics, neighbor queries with 3D hash, pairwise electrostatic/vdW limited by cutoffs), reduced from O(n^2) in Protofold I; the SASA surface-enumeration is O(n * N) (N = samples per-offset-sphere) worst-case sequentially and is the practical bottleneck, but is data-parallel and accelerated on GPU (up to ~100× speed-ups reported for the SASA enumeration). Specific cutoffs: d_cut_elec = 9.0 Å, d_cut_vdw = 5.0 Å, d_cut_cav ≈ 8.0 Å.</td>
                        </tr>
                        <tr>
                            <td><strong>protein_types_tested</strong></td>
                            <td>Small peptides (10–20 residue polyalanine chains) for folding examples and secondary structure formation; large polypeptides for performance (tests up to 1,200 residues and performance experiments across many chains including 2,000 random polyalanine chains with 10–20 residues).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Qualitative folding outcomes (α-helix formation) and energy changes reported; right-handed 15-residue polyalanine helix energy ~43.8 kcal/mol (vacuum) and ~45.9 kcal/mol (with solvation) lower than left-handed; convergence iteration counts ~150 (without solvation) vs ~300 (with solvation) for the helix examples. Implementation speedups: CPU-parallel (OpenMP) solvation computation up to ~10× on 12 cores; GPU implementation achieved up to two orders of magnitude (≈100×) speed-up for SASA enumeration versus baseline CPU; hashing reduced electrostatic/vdW force computation times (example: up to 4.6× in vacuum for m=60 and 1.5× in water).</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_datasets</strong></td>
                            <td>Synthetic / controlled test sets used in the paper: polyalanine chains (10–20 residues), larger custom polypeptides (e.g., 1,200-residue chain) for performance; 2,000 independent polyalanine chains (lengths 10–20) for statistical exploration. (No CASP or standardized structure prediction benchmarks were used.)</td>
                        </tr>
                        <tr>
                            <td><strong>requires_templates</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>is_interpretable</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>key_assumptions</strong></td>
                            <td>Peptide planes treated as rigid and planar (ω fixed); torsion-angle parameterization provides reduced DOF; inertia and atomic-scale inertial effects are negligible (kinetostatic assumption); use of empirical AMBER-like parameters and distance-dependent dielectric as an approximation to full Poisson–Boltzmann; use of finite cut-offs for interactions; nonpolar solvation approximated by linear SASA model; ZP initialization uses canonical rotamers.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations</strong></td>
                            <td>Steepest-descent-like kinetostatic stepping can converge to local minima and is sensitive to initial conditions (example: handedness of helix depends on initial coil); SASA enumeration is computationally expensive and is the bottleneck if not parallelized; simplified solvent treatment (implicit nonpolar SASA only, no explicit solvent or polar solvation PB solved each cycle) and distance-dependent dielectric approximate solvent polarization; current implementation focuses on monomeric chains and does not yet support multimeric/quaternary assembly or complex cross-chain topologies; the simple KCM stepping could be improved (authors suggest hybrid MC or conjugate-gradients).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other_methods</strong></td>
                            <td>Paper argues KCM avoids very small timesteps required by MD and the large sampling burden of stochastic sampling methods, offering faster and more stable convergence to minima; comparisons are qualitative (KCM converges faster and is numerically more stable than MD for folding-scale steps); no quantitative head-to-head accuracy metrics versus modern ML predictors (e.g., AlphaFold) or standard MD RMSD benchmarks are provided.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Protofold II: Enhanced Model and Implementation for Kinetostatic Protein Folding', 'publication_date_yy_mm': '2015-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e6.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of algorithmic and deterministic approaches to protein folding, including physics-based methods, energy minimization algorithms, force field approaches, and rule-based folding methods.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>SASA Enumeration</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Offset-sphere deterministic surface enumeration for SASA and gradient approximation</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A deterministic surface-sampling algorithm that approximates atomic solvent-accessible surface area (SASA) and its gradient by quasi-uniformly sampling an atom's offset sphere, counting overlap with neighbors, and estimating exposure fractions and finite-difference gradients; designed to trade accuracy vs. compute via sample density and optimized for SIMD/GPU.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_name</strong></td>
                            <td>Offset-sphere surface enumeration (quasi-uniform deterministic sampling) for SASA</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_description</strong></td>
                            <td>For each atom i, construct an offset sphere radius R_i^{off}=R_i+R_H2O; map a precomputed quasi-uniform unit-sphere sampling Q to the atom (N samples per atom). For each sample point q_k test overlap with neighbor offset spheres (from hashed neighbor list); record count C_{i,k} (number of overlapping neighbors). The exposed fraction f_i^{exp} = (#exposed points)/N approximates SASA as A_i^{exp} ≈ f_i^{exp} A_i^{off}. Gradients ∇_{r_j} f_i^{exp} are approximated by finite differences: displace neighbor j by δr along coordinate axes and recompute exposure states for sample points that are potentially affected using an optimized rule based on C_{i,k} values (only exposed or critically overlapped points can change). The formulation yields pairwise-symmetric contributions and allows GPU-parallel per-atom/per-sample processing with atomic updates for shared accumulators.</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_type</strong></td>
                            <td>deterministic numerical approximation (geometry-based solvation computation)</td>
                        </tr>
                        <tr>
                            <td><strong>is_deterministic</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>underlying_principles</strong></td>
                            <td>Geometric surface sampling to approximate continuum SASA; linear implicit solvation free energy G_cav = Σ γ_j A_j^{exp}; finite-difference approximation for gradients; exploit neighbor locality via cutoffs.</td>
                        </tr>
                        <tr>
                            <td><strong>force_field_or_energy_function</strong></td>
                            <td>Nonpolar solvation term: linear SASA model (G_cav = Σ γ_j A_j^{exp}); atomic solvation parameters γ_j adopted from literature (table in paper).</td>
                        </tr>
                        <tr>
                            <td><strong>computational_complexity</strong></td>
                            <td>Sequential worst-case O(n * N) (N samples per atom); expected O(n * N) but with |A_i'| = O(1) neighbor size under spatial assumptions; with GPU data-parallel implementation and sufficient hardware, effective per-iteration cost becomes scalable and can reach near-O(n) behavior in practice; finite-difference gradient naive approach would be O(n * N * |A_i'|) but optimized counting (C_{i,k}) reduces work substantially.</td>
                        </tr>
                        <tr>
                            <td><strong>protein_types_tested</strong></td>
                            <td>Used across polyalanine folding examples and large polypeptides in performance tests (e.g., chains up to 1,200 residues and many-chain experiments).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Enumeration-based SASA gradient evaluation identified as dominant cost (bottleneck) without parallelization; CPU-parallel (OpenMP) solvation speed-up up to ~10× with 12 cores; GPU-parallel implementation achieved up to ~100× speed-up for the SASA enumeration relative to baseline CPU (paper reports up to two orders of magnitude on GPU). Accuracy controlled by sample size N; authors report improved fidelity over probabilistic pairwise approximations (e.g., LCPO/probabilistic methods) with controllable error by increasing N.</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_datasets</strong></td>
                            <td>Applied to synthetic peptides and polypeptides used in the paper (polyalanine chains and mixed residue performance chains).</td>
                        </tr>
                        <tr>
                            <td><strong>requires_templates</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>is_interpretable</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>key_assumptions</strong></td>
                            <td>Quasi-uniform finite sampling on offset sphere approximates continuous SASA well when N large; neighbor sets determined by conservative cutoff (d_cut_cav ≈ 2(R_max + R_H2O) ≈ 8 Å) contain all potentially overlapping spheres; finite-difference δr is small enough to approximate gradients.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations</strong></td>
                            <td>Sampling discretization introduces noise in energy landscapes (authors note some added noise in Ramachandran plots); computational cost scales with chosen sample density (trade-off accuracy vs. performance); gradients obtained by finite differences may require small δr and careful handling; worst-case sequential cost is high without sufficient parallel hardware.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Protofold II: Enhanced Model and Implementation for Kinetostatic Protein Folding', 'publication_date_yy_mm': '2015-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e6.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of algorithmic and deterministic approaches to protein folding, including physics-based methods, energy minimization algorithms, force field approaches, and rule-based folding methods.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>3D Hash Table (Spatial Grid)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Uniform Cartesian 3D grid hash table for neighbor queries</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A deterministic spatial hashing data structure partitioning space into cubic grid cells (buckets) to accelerate neighbor searching under cut-offs and reduce all-pairs O(n^2) checks to expected O(n) time under reasonable packing assumptions.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_name</strong></td>
                            <td>Uniform 3D grid hashing for proximity queries</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_description</strong></td>
                            <td>At each snapshot compute bounding box of atom centers and choose cubic cell size s_c so that number of cells ~ α n, map each atom to a bucket by integer grid index k = floor((r_i - r_min)/s_c). For a given atom and cutoff d_cut, identify neighbor candidate cells within a sphere radius r_c = d_cut + √3 s_c and scan the atoms in those buckets to form neighbor lists A_i'. This produces expected O(1) neighbors per atom and O(n) total neighbor discovery time under packing assumptions.</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_type</strong></td>
                            <td>deterministic geometric acceleration / data structure</td>
                        </tr>
                        <tr>
                            <td><strong>is_deterministic</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>underlying_principles</strong></td>
                            <td>Spatial partitioning / geometric hashing to localize pairwise interaction evaluation.</td>
                        </tr>
                        <tr>
                            <td><strong>force_field_or_energy_function</strong></td>
                            <td>Not an energy function; used to accelerate evaluation of force-field terms.</td>
                        </tr>
                        <tr>
                            <td><strong>computational_complexity</strong></td>
                            <td>Table construction expected O(n) per snapshot; neighbor queries expected O(1) per atom (O(n) total) under Assumption that occupancy per neighborhood is O(1).</td>
                        </tr>
                        <tr>
                            <td><strong>protein_types_tested</strong></td>
                            <td>Used as part of Protofold II experiments on short peptides and large polypeptides (tests up to 1,200 residues shown).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Hashing reduced force computation times; example: for a 60-residue polyalanine chain hashing produced up to ~4.6× speed-up in vacuum and ~1.5× in water (single-CPU baseline).</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_datasets</strong></td>
                            <td>Applied to the paper's synthetic polypeptide test cases.</td>
                        </tr>
                        <tr>
                            <td><strong>requires_templates</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>is_interpretable</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>key_assumptions</strong></td>
                            <td>Protein atoms are reasonably spaced; bounding-box empty volume not overwhelmingly larger than occupied volume (v_BB/v_atom = O(1)); cell size s_c chosen ≈ 1 Å yields O(n) buckets.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations</strong></td>
                            <td>Pathological conformations that create very elongated occupancy in the bounding box may violate assumptions and degrade performance; requires rebuilding per snapshot as atoms move.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Protofold II: Enhanced Model and Implementation for Kinetostatic Protein Folding', 'publication_date_yy_mm': '2015-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e6.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of algorithmic and deterministic approaches to protein folding, including physics-based methods, energy minimization algorithms, force field approaches, and rule-based folding methods.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Bonds Tree / Graph</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Covalent-bond tree data structure for interaction-classification</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A tree/graph representation of the covalent-bond network (rooted at the N-terminus) used to classify atom pairs as 1-2, 1-3, 1-4 or >1-4 interactions quickly during force computation, replacing an O(n^2) interaction type lookup table.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_name</strong></td>
                            <td>Bond-tree traversal for interaction type classification</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_description</strong></td>
                            <td>Construct a tree (or a tree-like rooted graph with one edge removed in rare aromatic loops) where vertices are atoms and edges are covalent bonds. During preprocessing perform a traversal from root storing parent pointer and residue index per atom (O(n) time). At query time classify a pair by comparing residue indices and parent/pointer relationships to determine 1-2/1-3/1-4 or >1-4 in O(1) time; set empirical weight factors w_{i,j}^{elec}, w_{i,j}^{vdw} accordingly.</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_type</strong></td>
                            <td>deterministic topology-based classification</td>
                        </tr>
                        <tr>
                            <td><strong>is_deterministic</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>underlying_principles</strong></td>
                            <td>Graph/tree traversal to deduce shortest path (bond-count) between atoms to apply empirical interaction-scaling rules.</td>
                        </tr>
                        <tr>
                            <td><strong>force_field_or_energy_function</strong></td>
                            <td>Used to select scaling weights w_{i,j} applied to electrostatic and van der Waals pairwise terms (empirical modifications for 1-2/1-3/1-4 interactions).</td>
                        </tr>
                        <tr>
                            <td><strong>computational_complexity</strong></td>
                            <td>Preprocessing O(n) time and space; O(1) query time per pair during iteration.</td>
                        </tr>
                        <tr>
                            <td><strong>protein_types_tested</strong></td>
                            <td>Applied in all Protofold II folding simulations to classify pairwise interactions for the force computations.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Replaces O(n^2) adjacency table of Protofold I, reducing memory and preprocessing cost to O(n).</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_datasets</strong></td>
                            <td>Used across the paper's examples.</td>
                        </tr>
                        <tr>
                            <td><strong>requires_templates</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>is_interpretable</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>key_assumptions</strong></td>
                            <td>Covalent-bond topology is tree-like after removing at most one edge for aromatic loops; residue index proximity is a fast prefilter for most pairs.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations</strong></td>
                            <td>Rare cyclic covalent topologies require a small modification (exclude an edge) to convert to a tree; assumes static bond graph (no bond rearrangement).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Protofold II: Enhanced Model and Implementation for Kinetostatic Protein Folding', 'publication_date_yy_mm': '2015-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e6.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of algorithmic and deterministic approaches to protein folding, including physics-based methods, energy minimization algorithms, force field approaches, and rule-based folding methods.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>AMBER-style force field</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>AMBER empirical molecular mechanics force field (used for intra-molecular electrostatics/van der Waals)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An empirical force-field used to model intramolecular electrostatic interactions (modified Coulomb) and van der Waals interactions (Lennard-Jones 6-12) within Protofold II; originally available in AMBER suite.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_name</strong></td>
                            <td>AMBER-style empirical force field</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_description</strong></td>
                            <td>Electrostatics formulated with modified Coulomb's law q_i q_j /(4π ε_{i,j} d_{ij}) with ε_{i,j} = κ_{i,j} ε_0 and a distance-dependent dielectric approximation; van der Waals formulated with Lennard-Jones 6-12 potential ε_{i,j}[(D_{i,j}/d_{i,j})^{12} - 2 (D_{i,j}/d_{i,j})^6]. Interaction scaling weights applied for 1-2/1-3/1-4 pairs. Solvent effects partly included via an implicit SASA-based nonpolar term; polar solvation approximated conventionally (authors note alternatives like PB or GB but do not solve PB each cycle).</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_type</strong></td>
                            <td>molecular mechanics empirical force field</td>
                        </tr>
                        <tr>
                            <td><strong>is_deterministic</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>underlying_principles</strong></td>
                            <td>Parameterized empirical potentials approximating atomic interactions (electrostatics, dispersion/repulsion) derived from quantum and experimental data; used within energy-minimization / KCM framework.</td>
                        </tr>
                        <tr>
                            <td><strong>force_field_or_energy_function</strong></td>
                            <td>AMBER (electrostatics + Lennard-Jones), with additive nonpolar SASA term in Protofold II.</td>
                        </tr>
                        <tr>
                            <td><strong>computational_complexity</strong></td>
                            <td>Pairwise evaluation within cutoffs; naive all-pairs O(n^2) but reduced to expected O(n) with spatial hashing and cutoffs.</td>
                        </tr>
                        <tr>
                            <td><strong>protein_types_tested</strong></td>
                            <td>Standard small peptides and larger polypeptides in Protofold II experiments; AMBER is a general-purpose force field used across biomolecular modeling.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>No AMBER-specific accuracy benchmarks reported in this paper; used as the intramolecular baseline energy model.</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_datasets</strong></td>
                            <td>Not applicable within paper beyond the test peptides/chains used.</td>
                        </tr>
                        <tr>
                            <td><strong>requires_templates</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>is_interpretable</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>key_assumptions</strong></td>
                            <td>Parameterization accuracy; use of distance-dependent dielectric as approximation to full continuum electrostatics; empirical scaling for bonded-nearby interactions.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations</strong></td>
                            <td>AMBER parameterization may not capture all solvation/polarization effects without explicit solvent or PB/GB corrections; parameter choices affect folding pathways and outcomes.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Protofold II: Enhanced Model and Implementation for Kinetostatic Protein Folding', 'publication_date_yy_mm': '2015-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e6.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of algorithmic and deterministic approaches to protein folding, including physics-based methods, energy minimization algorithms, force field approaches, and rule-based folding methods.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Molecular Dynamics (MD)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Molecular dynamics (Newtonian / Langevin / Brownian variants)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Physics-based time-integration methods that simulate molecular trajectories by integrating Newton's equations (or stochastic variants) to sample folding pathways, but require very small time steps (fs) making long-timescale folding expensive.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_name</strong></td>
                            <td>Molecular Dynamics (Newtonian / Langevin / Brownian)</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_description</strong></td>
                            <td>Integrate Newtonian equations of motion (or stochastic Langevin/Brownian variants) using atomistic force fields; trajectories simulate physical folding pathways over time. Requires very small integration timesteps (order femtoseconds) to maintain numerical stability and accuracy; thermostats/barostats and implicit/explicit solvent models may be coupled.</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_type</strong></td>
                            <td>molecular dynamics (physics-based)</td>
                        </tr>
                        <tr>
                            <td><strong>is_deterministic</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>underlying_principles</strong></td>
                            <td>First-principles Newtonian mechanics (with stochastic forces for Langevin/Brownian), molecular mechanics force fields, time evolution approximates pathways on energy landscape.</td>
                        </tr>
                        <tr>
                            <td><strong>force_field_or_energy_function</strong></td>
                            <td>Typically AMBER/CHARMM/GROMOS parameters; explicit solvent models (SPC, TIP3P, etc.) or implicit solvent (GB/PB) can be used.</td>
                        </tr>
                        <tr>
                            <td><strong>computational_complexity</strong></td>
                            <td>Simulation cost scales with number of atoms and number of time steps; timestep ~1 fs, so reaching biologically relevant folding times (ms) is impractical for typical atomistic MD—computational cost often prohibitive without enhanced sampling.</td>
                        </tr>
                        <tr>
                            <td><strong>protein_types_tested</strong></td>
                            <td>MD is used widely across small molecules and proteins; paper notes MD can simulate small molecules but not typical protein folding timescales.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>No new MD experiments in this paper; referenced as motivating limitation that KCM addresses (small time step requirement).</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_datasets</strong></td>
                            <td>Referenced literature on MD (no specific datasets used here).</td>
                        </tr>
                        <tr>
                            <td><strong>requires_templates</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>is_interpretable</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>key_assumptions</strong></td>
                            <td>All-atom classical mechanics with empirical force fields; stability requires small timesteps; explicit solvent modeling incurs high cost.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations</strong></td>
                            <td>Timescale barrier (cannot reach ms folding times for typical atomistic MD); computationally very expensive due to need for tiny timesteps and many solvent atoms; stochastic MD variants include noise.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Protofold II: Enhanced Model and Implementation for Kinetostatic Protein Folding', 'publication_date_yy_mm': '2015-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6.6">
                <h3 class="extraction-instance">Extracted Data Instance 6 (e6.6)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of algorithmic and deterministic approaches to protein folding, including physics-based methods, energy minimization algorithms, force field approaches, and rule-based folding methods.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Sampling-based methods (SA/MC/Basin/Evolutionary)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Conformational sampling methods (simulated annealing, basin hopping, Monte Carlo, evolutionary algorithms)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A family of stochastic search techniques that explore conformation space by generating many samples and selecting low-energy structures, relying on heuristics to approximate global minima of free-energy landscapes.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_name</strong></td>
                            <td>Sampling-based conformational search (simulated annealing, basin hopping, MC, evolutionary algorithms)</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_description</strong></td>
                            <td>Generate many conformational samples (via Monte Carlo moves, simulated annealing temperature schedules, basin-hopping local minimizations, or population-based evolutionary operations) and evaluate free energy for each; use search heuristics (cooling, acceptance criteria, mutation/crossover, local refinement) to find putative global minima under the thermodynamic hypothesis.</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_type</strong></td>
                            <td>stochastic sampling / global optimization</td>
                        </tr>
                        <tr>
                            <td><strong>is_deterministic</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>underlying_principles</strong></td>
                            <td>Thermodynamic hypothesis: native structure corresponds to global free-energy minimum; stochastic exploration to find that minimum.</td>
                        </tr>
                        <tr>
                            <td><strong>force_field_or_energy_function</strong></td>
                            <td>Any empirical force field / scoring function can be used; authors reference use with AMBER-like energies and SASA approximations in literature.</td>
                        </tr>
                        <tr>
                            <td><strong>computational_complexity</strong></td>
                            <td>Computationally intensive due to need for large number of samples; not guaranteed to find global minimum (depends on sampling density and heuristics).</td>
                        </tr>
                        <tr>
                            <td><strong>protein_types_tested</strong></td>
                            <td>Used broadly in de novo folding contexts; authors note large sample counts required to cover conformation space.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>No direct experiments in this paper; limitations noted: lack of pathway information and no guarantee of finding global minimum with finite sampling.</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_datasets</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>requires_templates</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>is_interpretable</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>key_assumptions</strong></td>
                            <td>Thermodynamic hypothesis; chosen move sets and sampling heuristics adequately explore conformation space.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations</strong></td>
                            <td>Large sample requirement; no mechanistic pathway information; stochastic outcomes depend on sampling budget.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Protofold II: Enhanced Model and Implementation for Kinetostatic Protein Folding', 'publication_date_yy_mm': '2015-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6.7">
                <h3 class="extraction-instance">Extracted Data Instance 7 (e6.7)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of algorithmic and deterministic approaches to protein folding, including physics-based methods, energy minimization algorithms, force field approaches, and rule-based folding methods.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Rotamer / ZP initialization</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Rotamer libraries and Zero-Reference Position Description (ZP) initialization</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Use of canonical rotameric side-chain dihedral angles and a zero-reference planar peptide conformation to initialize reduced-DOF kinematic linkage (ZP: φ=ψ=−180° and rotamer defaults), providing deterministic starting states for KCM.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_name</strong></td>
                            <td>Rotamer-based initialization (ZP method)</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_description</strong></td>
                            <td>Set initial dihedral angles to a zero-reference position: peptide planes coplanar (φ_i^0 = ψ_i^0 = −180°) and side-chain χ dihedrals set to favorable rotamer default values χ_{i,k}^0; convert to θ_j,k shifted variables so θ=0 at ZP. This deterministic start is used as an alternative to random or PDB-based initializations.</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_type</strong></td>
                            <td>rule-based / knowledge-informed initialization</td>
                        </tr>
                        <tr>
                            <td><strong>is_deterministic</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>underlying_principles</strong></td>
                            <td>Empirical rotamer preferences and assumed planar peptide geometry to reduce DOF and give a low-energy reference conformation.</td>
                        </tr>
                        <tr>
                            <td><strong>force_field_or_energy_function</strong></td>
                            <td>Not an energy function—serves as initialization consistent with empirical rotamers used in molecular mechanics.</td>
                        </tr>
                        <tr>
                            <td><strong>computational_complexity</strong></td>
                            <td>Negligible (O(n) to assign per-residue defaults).</td>
                        </tr>
                        <tr>
                            <td><strong>protein_types_tested</strong></td>
                            <td>Used in Protofold II folding simulations as default initial condition (ZP).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Used to produce comparable folding trajectories; authors also allow random or PDB import initializations for alternative experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_datasets</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>requires_templates</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>is_interpretable</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>key_assumptions</strong></td>
                            <td>Peptide planes are exactly planar at initialization; rotamer defaults are representative of low-energy side-chain conformations.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations</strong></td>
                            <td>Initial conditions influence convergence and final local minima; ZP may not represent realistic unfolded ensemble in all contexts.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Protofold II: Enhanced Model and Implementation for Kinetostatic Protein Folding', 'publication_date_yy_mm': '2015-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6.8">
                <h3 class="extraction-instance">Extracted Data Instance 8 (e6.8)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of algorithmic and deterministic approaches to protein folding, including physics-based methods, energy minimization algorithms, force field approaches, and rule-based folding methods.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Steepest-descent / Conjugate-gradients (optimization)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Steepest-descent-like KCM stepping and mention of conjugate-gradients / hybrid Monte Carlo</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>KCM stepping acts like a steepest-descent optimizer updating torsion angles proportional to joint torques; authors note classical deterministic optimizers (conjugate gradients) and stochastic-enhanced schemes (hybrid Monte Carlo) as alternatives to escape local minima.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_name</strong></td>
                            <td>KCM-steepest-descent step; referenced conjugate-gradients / hybrid Monte Carlo</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_description</strong></td>
                            <td>KCM update Δθ_j = κ τ_j / |τ_max| is analogous to a normalized steepest-descent step along the gradient of the free energy with respect to dihedral angles. Paper also mentions that classical optimizers (e.g., conjugate-gradients) and combined schemes (e.g., hybrid Monte Carlo + KCM or conjugate-gradients) could be used for more effective global minimization but these are not implemented in Protofold II.</td>
                        </tr>
                        <tr>
                            <td><strong>algorithm_type</strong></td>
                            <td>deterministic local optimization (steepest-descent); references to classical and stochastic hybrid optimizers</td>
                        </tr>
                        <tr>
                            <td><strong>is_deterministic</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>underlying_principles</strong></td>
                            <td>Gradient-descent energy minimization; potential to combine with stochastic global search (hybrid MC) for escaping local minima.</td>
                        </tr>
                        <tr>
                            <td><strong>force_field_or_energy_function</strong></td>
                            <td>Applied to the free energy defined (AMBER-like + SASA solvation).</td>
                        </tr>
                        <tr>
                            <td><strong>computational_complexity</strong></td>
                            <td>Per-step complexity dictated by force/gradient computation (see KCM entry); conjugate-gradients would have similar per-iteration gradient cost but typically fewer iterations to converge locally.</td>
                        </tr>
                        <tr>
                            <td><strong>protein_types_tested</strong></td>
                            <td>KCM-steepest-descent used on test peptides; conjugate-gradients suggested for future work but not evaluated here.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>KCM-steepest-descent required ~150–300 iterations in helix examples depending on solvation; suggested alternatives not benchmarked in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_datasets</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>requires_templates</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>is_interpretable</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>key_assumptions</strong></td>
                            <td>Gradient information is sufficient to drive convergence; normalization by |τ_max| and choice of κ control step size and stability.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations</strong></td>
                            <td>Steepest-descent can be slow and trapped in local minima; authors note potential benefit from conjugate-gradients or hybrid Monte Carlo to avoid local minima.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Protofold II: Enhanced Model and Implementation for Kinetostatic Protein Folding', 'publication_date_yy_mm': '2015-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <p class="empty-note">No potentially relevant new papers extracted.</p>
        </div>

        </div>

    </div>
</body>
</html>