<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Constraint-Guided Executability Theory - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Theory Details for theory-184</h1>

        <div class="section">
            <h2>Theory (General Information)</h2>
            <div class="info-section">
                <p><strong>ID:</strong> theory-184</p>
                <p><strong>Name:</strong> Constraint-Guided Executability Theory</p>
                <p><strong>Type:</strong> specific</p>
                <p><strong>Theory Query:</strong> Build a theory of how crossover and mutation operations over literature and codeblocks govern the novelty-executability frontier in genetic ideation and discovery diversity, based on the following results.</p>
                <p><strong>Description:</strong> In domains with strict executability requirements (program compilation, circuit synthesis, type safety), the effectiveness of crossover and mutation is determined by their ability to maintain or restore constraint satisfaction. Operators can be classified as: (1) constraint-preserving (always produce valid offspring, e.g., type-aware crossover, grammar-guided mutation), (2) constraint-restoring (may violate constraints but include repair mechanisms, e.g., mutation with post-hoc type inference), or (3) constraint-agnostic (ignore constraints, rely on rejection, e.g., random subtree crossover). Constraint-preserving operators maintain high executability rates but may limit novelty by restricting the reachable space. Constraint-agnostic operators can explore more freely but waste evaluations on invalid offspring. The optimal approach depends on constraint complexity and evaluation cost: for expensive evaluation (e.g., hardware synthesis), constraint-preserving operators are essential; for cheap evaluation (e.g., expression evaluation), constraint-agnostic with rejection may be acceptable. Hybrid approaches that use constraint-preserving operators for structure and constraint-agnostic for parameters can balance novelty and executability. Learned constraint models (from LLMs or other ML systems) can implicitly encode complex constraints without explicit specification.</p>
                <p><strong>Knowledge Cutoff Year:</strong> 2024</p>
                <p><strong>Knowledge Cutoff Month:</strong> 12</p>
            </div>
        </div>

        <div class="section">
            <h2>Theory (Derived From)</h2>
            <p><strong>Derived From:</strong> <span class="empty-note">None</span></p>
            <p><strong>Change Log:</strong> <span class="empty-note">No change log entries.</span></p>
        </div>

        <div class="section">
            <h2>Evaluations of this Theory</h2>
            <p class="empty-note">No evaluations of this theory.</p>
        </div>

        <div class="section">
            <h2>Theory (Details)</h2>

            <h3>Theory Statements</h3>
            <ol>
                <li>Constraint-preserving operators maintain higher executability rates than constraint-agnostic operators, with rates approaching 100% for well-designed systems.</li>
                <li>The value of constraint preservation increases with evaluation cost: for expensive evaluation (hardware synthesis, neural architecture training), constraint preservation is essential; for cheap evaluation (expression evaluation), rejection may be acceptable.</li>
                <li>Constraint-preserving operators may limit novelty by restricting reachable space to constraint-satisfying regions, but this limitation can be mitigated by hybrid approaches.</li>
                <li>Hybrid approaches that preserve structural constraints while allowing parameter variation can balance novelty and executability effectively.</li>
                <li>Learned constraint models (e.g., type systems, grammars, LLM priors) can be more effective than hand-designed constraints by implicitly encoding complex patterns.</li>
                <li>Constraint-restoring operators (repair mechanisms) can enable broader exploration than constraint-preserving operators while maintaining executability.</li>
                <li>The complexity of constraints affects the feasibility of constraint-preserving operators: simple constraints (type safety) are easier to preserve than complex constraints (semantic correctness).</li>
                <li>The cost of constraint checking during operator application must be weighed against the cost of evaluating invalid offspring.</li>
                <li>Constraint preservation at the genotype level (e.g., grammar-guided) can be more efficient than phenotype-level checking (e.g., post-hoc validation).</li>
                <li>Adaptive constraint models that learn from evolution can improve over static hand-designed constraints.</li>
            </ol>
            <h3>Supporting Evidence</h3>
<ol>
    <li>CBGP's Hindley-Milner type inference during compilation ensures type safety, enabling polymorphic program generation with high executability rates and solution rates of 100% on several benchmarks. <a href="../results/extraction-result-1617.html#e1617.0" class="evidence-link">[e1617.0]</a> <a href="../results/extraction-result-1619.html#e1619.0" class="evidence-link">[e1619.0]</a> <a href="../results/extraction-result-1600.html#e1600.0" class="evidence-link">[e1600.0]</a> </li>
    <li>Grammar-Guided GP with genotypic crossover on derivation trees preserves grammatical correctness and dimensional consistency, ensuring offspring remain in admissible language and improving fitness significantly. <a href="../results/extraction-result-1610.html#e1610.1" class="evidence-link">[e1610.1]</a> </li>
    <li>TPOT's strongly-typed tree representation with DEAP operators preserves sklearn pipeline validity through type-aware crossover and mutation, maintaining executability across pipeline evolution. <a href="../results/extraction-result-1615.html#e1615.1" class="evidence-link">[e1615.1]</a> </li>
    <li>Verifiability-driven CGP combined with SAT solving formally verifies candidates meet error bounds within time limits, biasing search toward verifiable solutions and achieving formal guarantees for 32-bit multipliers. <a href="../results/extraction-result-1628.html#e1628.7" class="evidence-link">[e1628.7]</a> </li>
    <li>MCGP's mutation operators respect syntactic/typing constraints to ensure generated code is legal, maintaining executability while synthesizing concurrent algorithms. <a href="../results/extraction-result-1621.html#e1621.0" class="evidence-link">[e1621.0]</a> <a href="../results/extraction-result-1621.html#e1621.1" class="evidence-link">[e1621.1]</a> <a href="../results/extraction-result-1621.html#e1621.2" class="evidence-link">[e1621.2]</a> </li>
    <li>AI Programmer's sandboxed interpreter with instruction-count limits and fitness penalties enforces executability constraints during evolution, preventing infinite loops and ensuring termination. <a href="../results/extraction-result-1593.html#e1593.0" class="evidence-link">[e1593.0]</a> </li>
    <li>FunSearch discards programs that fail to execute within time/memory limits, using rejection to enforce executability while achieving mathematical discoveries. <a href="../results/extraction-result-1627.html#e1627.0" class="evidence-link">[e1627.0]</a> </li>
    <li>LMX produces syntactically valid offspring at high rates (approaching 100% with sufficient parents and larger LLMs) by implicitly learning domain constraints from pre-training. <a href="../results/extraction-result-1741.html#e1741.0" class="evidence-link">[e1741.0]</a> </li>
    <li>G3P's CFG-compliant initialization with dynamic masking ensures uniform sampling of admissible derivations within depth limits, preventing oversize trees. <a href="../results/extraction-result-1610.html#e1610.5" class="evidence-link">[e1610.5]</a> </li>
    <li>ARJA's type-matching strategy synthesizes new ingredient statements by mapping out-of-scope identifiers to in-scope ones, maintaining compilability while expanding search space. <a href="../results/extraction-result-1585.html#e1585.0" class="evidence-link">[e1585.0]</a> </li>
    <li>GP-BT's structural constraints (preventing identical control nodes consecutively, duplicate adjacent conditions, control nodes without children) avoid semantically-irrelevant/invalid trees. <a href="../results/extraction-result-1737.html#e1737.0" class="evidence-link">[e1737.0]</a> </li>
    <li>ABACUS AST-level mutators maintain Verilog validity by applying localized transformations on the abstract syntax tree, ensuring synthesizable output. <a href="../results/extraction-result-1628.html#e1628.4" class="evidence-link">[e1628.4]</a> </li>
    <li>EvoPrompting's compilation checks validate generated architectures by training them, discarding untrainable models and maintaining executability. <a href="../results/extraction-result-1739.html#e1739.0" class="evidence-link">[e1739.0]</a> </li>
    <li>POET-GP's type-aware expression trees built from constants, distance variables, and operators maintain mathematical validity while evolving interatomic potentials. <a href="../results/extraction-result-1571.html#e1571.0" class="evidence-link">[e1571.0]</a> </li>
    <li>ARJA's test filtering, variable+method scope checks, and rule-based filtering dramatically reduce evaluation cost and increase compilation success. <a href="../results/extraction-result-1585.html#e1585.0" class="evidence-link">[e1585.0]</a> </li>
    <li>Markov Senior's structural constraints (max depth, limited children, disallowed nested Markov nodes) assist stability in grammar evolution. <a href="../results/extraction-result-1563.html#e1563.0" class="evidence-link">[e1563.0]</a> </li>
</ol>            <h3>New Predictions (Likely outcome)</h3>
            <ol>
                <li>A genetic programming system that uses constraint-preserving operators for structure and constraint-agnostic operators for parameters will achieve better novelty-executability trade-offs than either alone, particularly in domains with hierarchical constraint structures.</li>
                <li>Learned constraint models (e.g., neural networks trained to predict constraint satisfaction) will enable more effective constraint-guided search than hand-designed constraints in domains with complex, implicit constraints.</li>
                <li>Constraint-restoring operators that use formal methods (SAT, SMT) to repair invalid offspring will outperform rejection-based approaches in domains with expensive evaluation and moderate constraint complexity.</li>
                <li>Adaptive systems that switch between constraint-preserving and constraint-agnostic operators based on population diversity will maintain better exploration-exploitation balance than fixed strategies.</li>
                <li>LLM-based operators will achieve higher executability rates than traditional GP operators in domains where constraints are implicit in natural language descriptions.</li>
                <li>Hybrid constraint approaches that combine grammar-based structural preservation with learned parameter constraints will outperform either approach alone.</li>
            </ol>
            <h3>New Predictions (Unknown outcome/high-entropy)</h3>
            <ol>
                <li>Whether there exists a universal framework for constraint-guided operators that generalizes across constraint types (type systems, grammars, physical laws, etc.) without domain-specific engineering.</li>
                <li>Whether learned constraint models can discover and enforce constraints that are not explicitly specified by humans, enabling discovery of novel constraint types.</li>
                <li>Whether constraint-guided operators can be effectively combined with multi-objective optimization to trade off constraint satisfaction with other objectives without sacrificing either.</li>
                <li>Whether the cost of constraint checking during operator application outweighs the benefits of avoiding invalid offspring in all domains, or if there are domains where rejection is always preferable.</li>
                <li>Whether constraint-preserving operators can maintain sufficient novelty for open-ended evolution in domains with very complex constraint structures.</li>
                <li>Whether learned constraint models can generalize across problem instances within a domain or require retraining for each new problem.</li>
            </ol>
            <h3>Negative Experiments</h3>
            <ol>
                <li>Finding that constraint-agnostic operators with rejection perform as well as constraint-preserving operators in domains with expensive evaluation would challenge the value of constraint preservation.</li>
                <li>Demonstrating that constraint-preserving operators do not limit novelty compared to constraint-agnostic operators would question the novelty-constraint trade-off.</li>
                <li>Showing that learned constraint models do not outperform hand-designed constraints in domains with well-understood constraints would challenge the value of learning.</li>
                <li>Finding that constraint-restoring operators do not outperform rejection in any domain would question the value of repair mechanisms.</li>
                <li>Demonstrating that the cost of constraint checking always exceeds the cost of evaluating invalid offspring would challenge the efficiency argument for constraint preservation.</li>
                <li>Finding that hybrid constraint approaches do not outperform pure approaches would question the value of combining constraint strategies.</li>
            </ol>
            <h3>Unaccounted for Evidence</h3>
<ol>
    <li>How to design constraint-preserving operators for novel constraint types that are not well-understood or cannot be formally specified. </li>
    <li>The interaction between constraint preservation and other operator properties (semantic step size, representation alignment, locality). </li>
    <li>Whether constraint preservation should be enforced at the genotype level, phenotype level, or both, and how this choice affects search efficiency. </li>
    <li>How to balance constraint preservation with the need for constraint-breaking mutations that enable escape from local optima. </li>
    <li>The role of constraint relaxation or soft constraints in enabling broader exploration while maintaining approximate executability. </li>
</ol>            <h3>Existing Theory Comparison</h3>
            <p><strong>Likely Classification:</strong> closely-related-to-existing</p>
            <p><strong>Explanation:</strong> No explanation provided.</p>
            <p><strong>References:</strong> <ul>
    <li>Montana (1995) Strongly Typed Genetic Programming [Type-preserving operators for maintaining type safety]</li>
    <li>Whigham (1995) Grammatically-Based Genetic Programming [Grammar-guided operators for syntactic constraint preservation]</li>
    <li>Ryan et al. (1998) Grammatical Evolution [Grammar-based constraint preservation through genotype-phenotype mapping]</li>
    <li>Koza (1992) Genetic Programming [Closure property for constraint satisfaction in function/terminal sets]</li>
    <li>Poli et al. (2008) A Field Guide to Genetic Programming [Discussion of closure and type constraints in GP]</li>
    <li>Langdon & Poli (2002) Foundations of Genetic Programming [Theoretical foundations of constraint preservation in GP]</li>
</ul>
        </div>

        <div class="section">
            <h2>Theory Components (Debug)</h2>
            <pre><code>{
    "theory_name": "Constraint-Guided Executability Theory",
    "theory_description": "In domains with strict executability requirements (program compilation, circuit synthesis, type safety), the effectiveness of crossover and mutation is determined by their ability to maintain or restore constraint satisfaction. Operators can be classified as: (1) constraint-preserving (always produce valid offspring, e.g., type-aware crossover, grammar-guided mutation), (2) constraint-restoring (may violate constraints but include repair mechanisms, e.g., mutation with post-hoc type inference), or (3) constraint-agnostic (ignore constraints, rely on rejection, e.g., random subtree crossover). Constraint-preserving operators maintain high executability rates but may limit novelty by restricting the reachable space. Constraint-agnostic operators can explore more freely but waste evaluations on invalid offspring. The optimal approach depends on constraint complexity and evaluation cost: for expensive evaluation (e.g., hardware synthesis), constraint-preserving operators are essential; for cheap evaluation (e.g., expression evaluation), constraint-agnostic with rejection may be acceptable. Hybrid approaches that use constraint-preserving operators for structure and constraint-agnostic for parameters can balance novelty and executability. Learned constraint models (from LLMs or other ML systems) can implicitly encode complex constraints without explicit specification.",
    "supporting_evidence": [
        {
            "text": "CBGP's Hindley-Milner type inference during compilation ensures type safety, enabling polymorphic program generation with high executability rates and solution rates of 100% on several benchmarks.",
            "uuids": [
                "e1617.0",
                "e1619.0",
                "e1600.0"
            ]
        },
        {
            "text": "Grammar-Guided GP with genotypic crossover on derivation trees preserves grammatical correctness and dimensional consistency, ensuring offspring remain in admissible language and improving fitness significantly.",
            "uuids": [
                "e1610.1"
            ]
        },
        {
            "text": "TPOT's strongly-typed tree representation with DEAP operators preserves sklearn pipeline validity through type-aware crossover and mutation, maintaining executability across pipeline evolution.",
            "uuids": [
                "e1615.1"
            ]
        },
        {
            "text": "Verifiability-driven CGP combined with SAT solving formally verifies candidates meet error bounds within time limits, biasing search toward verifiable solutions and achieving formal guarantees for 32-bit multipliers.",
            "uuids": [
                "e1628.7"
            ]
        },
        {
            "text": "MCGP's mutation operators respect syntactic/typing constraints to ensure generated code is legal, maintaining executability while synthesizing concurrent algorithms.",
            "uuids": [
                "e1621.0",
                "e1621.1",
                "e1621.2"
            ]
        },
        {
            "text": "AI Programmer's sandboxed interpreter with instruction-count limits and fitness penalties enforces executability constraints during evolution, preventing infinite loops and ensuring termination.",
            "uuids": [
                "e1593.0"
            ]
        },
        {
            "text": "FunSearch discards programs that fail to execute within time/memory limits, using rejection to enforce executability while achieving mathematical discoveries.",
            "uuids": [
                "e1627.0"
            ]
        },
        {
            "text": "LMX produces syntactically valid offspring at high rates (approaching 100% with sufficient parents and larger LLMs) by implicitly learning domain constraints from pre-training.",
            "uuids": [
                "e1741.0"
            ]
        },
        {
            "text": "G3P's CFG-compliant initialization with dynamic masking ensures uniform sampling of admissible derivations within depth limits, preventing oversize trees.",
            "uuids": [
                "e1610.5"
            ]
        },
        {
            "text": "ARJA's type-matching strategy synthesizes new ingredient statements by mapping out-of-scope identifiers to in-scope ones, maintaining compilability while expanding search space.",
            "uuids": [
                "e1585.0"
            ]
        },
        {
            "text": "GP-BT's structural constraints (preventing identical control nodes consecutively, duplicate adjacent conditions, control nodes without children) avoid semantically-irrelevant/invalid trees.",
            "uuids": [
                "e1737.0"
            ]
        },
        {
            "text": "ABACUS AST-level mutators maintain Verilog validity by applying localized transformations on the abstract syntax tree, ensuring synthesizable output.",
            "uuids": [
                "e1628.4"
            ]
        },
        {
            "text": "EvoPrompting's compilation checks validate generated architectures by training them, discarding untrainable models and maintaining executability.",
            "uuids": [
                "e1739.0"
            ]
        },
        {
            "text": "POET-GP's type-aware expression trees built from constants, distance variables, and operators maintain mathematical validity while evolving interatomic potentials.",
            "uuids": [
                "e1571.0"
            ]
        },
        {
            "text": "ARJA's test filtering, variable+method scope checks, and rule-based filtering dramatically reduce evaluation cost and increase compilation success.",
            "uuids": [
                "e1585.0"
            ]
        },
        {
            "text": "Markov Senior's structural constraints (max depth, limited children, disallowed nested Markov nodes) assist stability in grammar evolution.",
            "uuids": [
                "e1563.0"
            ]
        }
    ],
    "theory_statements": [
        "Constraint-preserving operators maintain higher executability rates than constraint-agnostic operators, with rates approaching 100% for well-designed systems.",
        "The value of constraint preservation increases with evaluation cost: for expensive evaluation (hardware synthesis, neural architecture training), constraint preservation is essential; for cheap evaluation (expression evaluation), rejection may be acceptable.",
        "Constraint-preserving operators may limit novelty by restricting reachable space to constraint-satisfying regions, but this limitation can be mitigated by hybrid approaches.",
        "Hybrid approaches that preserve structural constraints while allowing parameter variation can balance novelty and executability effectively.",
        "Learned constraint models (e.g., type systems, grammars, LLM priors) can be more effective than hand-designed constraints by implicitly encoding complex patterns.",
        "Constraint-restoring operators (repair mechanisms) can enable broader exploration than constraint-preserving operators while maintaining executability.",
        "The complexity of constraints affects the feasibility of constraint-preserving operators: simple constraints (type safety) are easier to preserve than complex constraints (semantic correctness).",
        "The cost of constraint checking during operator application must be weighed against the cost of evaluating invalid offspring.",
        "Constraint preservation at the genotype level (e.g., grammar-guided) can be more efficient than phenotype-level checking (e.g., post-hoc validation).",
        "Adaptive constraint models that learn from evolution can improve over static hand-designed constraints."
    ],
    "new_predictions_likely": [
        "A genetic programming system that uses constraint-preserving operators for structure and constraint-agnostic operators for parameters will achieve better novelty-executability trade-offs than either alone, particularly in domains with hierarchical constraint structures.",
        "Learned constraint models (e.g., neural networks trained to predict constraint satisfaction) will enable more effective constraint-guided search than hand-designed constraints in domains with complex, implicit constraints.",
        "Constraint-restoring operators that use formal methods (SAT, SMT) to repair invalid offspring will outperform rejection-based approaches in domains with expensive evaluation and moderate constraint complexity.",
        "Adaptive systems that switch between constraint-preserving and constraint-agnostic operators based on population diversity will maintain better exploration-exploitation balance than fixed strategies.",
        "LLM-based operators will achieve higher executability rates than traditional GP operators in domains where constraints are implicit in natural language descriptions.",
        "Hybrid constraint approaches that combine grammar-based structural preservation with learned parameter constraints will outperform either approach alone."
    ],
    "new_predictions_unknown": [
        "Whether there exists a universal framework for constraint-guided operators that generalizes across constraint types (type systems, grammars, physical laws, etc.) without domain-specific engineering.",
        "Whether learned constraint models can discover and enforce constraints that are not explicitly specified by humans, enabling discovery of novel constraint types.",
        "Whether constraint-guided operators can be effectively combined with multi-objective optimization to trade off constraint satisfaction with other objectives without sacrificing either.",
        "Whether the cost of constraint checking during operator application outweighs the benefits of avoiding invalid offspring in all domains, or if there are domains where rejection is always preferable.",
        "Whether constraint-preserving operators can maintain sufficient novelty for open-ended evolution in domains with very complex constraint structures.",
        "Whether learned constraint models can generalize across problem instances within a domain or require retraining for each new problem."
    ],
    "negative_experiments": [
        "Finding that constraint-agnostic operators with rejection perform as well as constraint-preserving operators in domains with expensive evaluation would challenge the value of constraint preservation.",
        "Demonstrating that constraint-preserving operators do not limit novelty compared to constraint-agnostic operators would question the novelty-constraint trade-off.",
        "Showing that learned constraint models do not outperform hand-designed constraints in domains with well-understood constraints would challenge the value of learning.",
        "Finding that constraint-restoring operators do not outperform rejection in any domain would question the value of repair mechanisms.",
        "Demonstrating that the cost of constraint checking always exceeds the cost of evaluating invalid offspring would challenge the efficiency argument for constraint preservation.",
        "Finding that hybrid constraint approaches do not outperform pure approaches would question the value of combining constraint strategies."
    ],
    "unaccounted_for": [
        {
            "text": "How to design constraint-preserving operators for novel constraint types that are not well-understood or cannot be formally specified.",
            "uuids": []
        },
        {
            "text": "The interaction between constraint preservation and other operator properties (semantic step size, representation alignment, locality).",
            "uuids": []
        },
        {
            "text": "Whether constraint preservation should be enforced at the genotype level, phenotype level, or both, and how this choice affects search efficiency.",
            "uuids": []
        },
        {
            "text": "How to balance constraint preservation with the need for constraint-breaking mutations that enable escape from local optima.",
            "uuids": []
        },
        {
            "text": "The role of constraint relaxation or soft constraints in enabling broader exploration while maintaining approximate executability.",
            "uuids": []
        }
    ],
    "conflicting_evidence": [
        {
            "text": "Some systems with constraint-agnostic operators and rejection (e.g., FunSearch) achieve strong results, suggesting rejection may be acceptable when evaluation is cheap and LLMs provide implicit constraint guidance.",
            "uuids": [
                "e1627.0"
            ]
        },
        {
            "text": "Mutation-only systems without explicit constraint preservation can maintain executability through careful operator design (e.g., HVL-Mutate' in (1+1) GP).",
            "uuids": [
                "e1621.0",
                "e1732.0"
            ]
        },
        {
            "text": "LMX achieves high validity rates without explicit constraint-preserving operators, suggesting learned models can implicitly encode constraints.",
            "uuids": [
                "e1741.0"
            ]
        },
        {
            "text": "Some domains with complex constraints (e.g., program correctness) may make constraint-preserving operators infeasible, requiring rejection-based approaches.",
            "uuids": [
                "e1627.0",
                "e1621.0"
            ]
        }
    ],
    "special_cases": [
        "In domains with very complex constraints (e.g., full program correctness), constraint-preserving operators may be infeasible and rejection may be the only option.",
        "For problems with soft constraints (preferences rather than requirements), constraint-agnostic operators may be more appropriate as they allow exploration of constraint-violating regions.",
        "In domains with evolving constraints (e.g., user preferences, adaptive requirements), adaptive constraint models may be necessary to track changing requirements.",
        "When constraints are learned from data (e.g., LLM priors), the quality of constraint preservation depends on the quality and coverage of training data.",
        "For domains where constraint checking is more expensive than evaluation (e.g., formal verification), constraint-agnostic approaches may be preferable.",
        "In multi-objective optimization with constraint satisfaction as one objective, constraint-agnostic operators may enable better exploration of trade-off spaces.",
        "For domains with hierarchical constraints (structural and parametric), hybrid approaches that preserve structural constraints while relaxing parametric constraints may be optimal."
    ],
    "existing_theory": {
        "likely_classification": "closely-related-to-existing",
        "references": [
            "Montana (1995) Strongly Typed Genetic Programming [Type-preserving operators for maintaining type safety]",
            "Whigham (1995) Grammatically-Based Genetic Programming [Grammar-guided operators for syntactic constraint preservation]",
            "Ryan et al. (1998) Grammatical Evolution [Grammar-based constraint preservation through genotype-phenotype mapping]",
            "Koza (1992) Genetic Programming [Closure property for constraint satisfaction in function/terminal sets]",
            "Poli et al. (2008) A Field Guide to Genetic Programming [Discussion of closure and type constraints in GP]",
            "Langdon & Poli (2002) Foundations of Genetic Programming [Theoretical foundations of constraint preservation in GP]"
        ]
    },
    "theory_type_general_specific": "specific",
    "reflected_from_theory_index": 5,
    "type": "specific"
}</code></pre>
        </div>
    </div>
</body>
</html>