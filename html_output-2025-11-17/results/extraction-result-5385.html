<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-5385 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-5385</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-5385</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-111.html">extraction-schema-111</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for converting graphs into text for language model training, including details of the representation, properties, evaluation tasks, performance, and comparisons to other methods.</div>
                <p><strong>Paper ID:</strong> paper-eecb01418e5ef618fe4d5eb5080de489a1c7cc95</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/eecb01418e5ef618fe4d5eb5080de489a1c7cc95" target="_blank">Neural Pipeline for Zero-Shot Data-to-Text Generation</a></p>
                <p><strong>Paper Venue:</strong> Annual Meeting of the Association for Computational Linguistics</p>
                <p><strong>Paper TL;DR:</strong> This work proposes to generate text by transforming single-item descriptions with a sequence of modules trained on general-domain text-based operations: ordering, aggregation, and paragraph compression on a synthetic corpus WikiFluent which is built from English Wikipedia.</p>
                <p><strong>Paper Abstract:</strong> In data-to-text (D2T) generation, training on in-domain data leads to overfitting to the data representation and repeating training data noise. We examine how to avoid finetuning pretrained language models (PLMs) on D2T generation datasets while still taking advantage of surface realization capabilities of PLMs. Inspired by pipeline approaches, we propose to generate text by transforming single-item descriptions with a sequence of modules trained on general-domain text-based operations: ordering, aggregation, and paragraph compression. We train PLMs for performing these operations on a synthetic corpus WikiFluent which we build from English Wikipedia. Our experiments on two major triple-to-text datasets—WebNLG and E2E—show that our approach enables D2T generation from RDF triples in zero-shot settings.</p>
                <p><strong>Cost:</strong> 0.021</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e5385.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e5385.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for converting graphs into text for language model training, including details of the representation, properties, evaluation tasks, performance, and comparisons to other methods.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Single-triple templates</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Single-triple template linearization</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A simple template-based serialization that maps each RDF triple (subject, predicate, object) into a single natural-language sentence via a hand-crafted template per predicate (e.g. "<s> plays <o>"). Used as the primary graph->text representation in this paper's zero-shot pipeline.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>Template-based linearization</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>For each input triple (s, p, o) the system fills a single predicate-specific template t_p producing a sentence fact f: T(p) : "<s> VERB <o>" (examples in Table 1). The set of facts is then treated as textual input to downstream text modules (ordering, aggregation, paragraph compression).</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>RDF triples / knowledge graph (subject–predicate–object triples)</td>
                        </tr>
                        <tr>
                            <td><strong>representation_properties</strong></td>
                            <td>Interpretable and simple; injects minimal domain knowledge via per-predicate templates; preserves one-triple semantics explicitly in each sentence; can produce surface-level disfluencies (e.g., missing articles) and is not compact (one sentence per triple before aggregation); easy to control and lightweight (no graph encoder needed).</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_task</strong></td>
                            <td>Data-to-text generation (WebNLG, E2E); used as input representation for zero-shot pipeline modules.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Compared baselines include COPY (copying the template outputs) and full pipeline variants; example scores on WebNLG: COPY BLEU = 37.18, 3-STAGE (full pipeline using templates) BLEU = 42.92 (full WikiFluent-trained models). On E2E: COPY BLEU = 24.19, 3-STAGE BLEU = 36.04. Metrics used: BLEU, METEOR, omissions/hallucinations (per-fact and per-example rates).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_representations</strong></td>
                            <td>Outperforms the naive COPY baseline when followed by learned ordering/aggregation/compression; yields competitive results vs. some older supervised systems but underperforms recent structure-aware graph encoders (e.g., Ke et al. 2021). The paper notes template linearization is a minimal, practical representation for zero-shot settings compared to approaches that require graph-aware encoders or task-specific finetuning.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Requires hand-crafted templates for each predicate (scalability issues when predicates are many); templates can introduce grammatical artifacts needing repair by downstream modules; semantic merging errors can arise later (improper fusion of unrelated facts) because templates provide no structural typing that constrains fusion; less expressive than structured graph encoders for capturing relations across triples.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Neural Pipeline for Zero-Shot Data-to-Text Generation', 'publication_date_yy_mm': '2022-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e5385.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e5385.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for converting graphs into text for language model training, including details of the representation, properties, evaluation tasks, performance, and comparisons to other methods.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Textual content plan</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Ordered textual content plan with aggregation markers</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A textual content-plan representation where triples are first converted to template sentences (facts), then an ordering model sorts them and an aggregation model marks sentence boundaries; the paragraph compression model consumes the ordered facts with aggregation delimiters to produce the final text.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>Textual content plan (ordered facts + aggregation markers)</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Representation = sequence F_a = {f_o1, δ_o1, f_o2, ..., δ_o(n-1), f_on}, where f_oi are the template sentences (one per triple) ordered by an ordering model and δ_i∈{0,1} are binary aggregation delimiters indicating whether to merge adjacent facts (δ=0) or keep them separate (δ=1). This textual plan is fed to a generative paragraph-compression PLM that fuses and rephrases into fluent text.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>RDF triples converted to sentence-level textual facts</td>
                        </tr>
                        <tr>
                            <td><strong>representation_properties</strong></td>
                            <td>Interpretable, controllable (explicit order and aggregation markers), modular (separable planning and realization steps), amenable to zero-shot training since planning operates on natural-language facts rather than dataset-specific predicate keys; helps reduce hallucinations/omissions when used properly; can be followed reliably by the paragraph-compression model (95–100% adherence reported).</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_task</strong></td>
                            <td>Content planning and data-to-text generation (evaluated on WebNLG and E2E). Also intrinsic evaluation of planning modules (ordering & aggregation) on WikiFluent and human-generated plans.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Ordering performance on WebNLG vs. human plans: BLEU-2 = 59.10, Accuracy = 0.48 (Table 6). Aggregation accuracy: 0.33 per example and 0.62 per sentence boundary (random baseline 0.23 / 0.50). Paragraph compression adherence to plan: 95% (WebNLG) and 100% (E2E) in manual evaluation. Downstream BLEU/METEOR & omission/hallucination rates reported for full pipelines (see other entries).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_representations</strong></td>
                            <td>Compared against random ordering and prior textual planners: outperforms random and transformer-based planner from Ferreira et al. (2019) but lags behind state-of-the-art supervised planners (Plan-then-generate, PLANENC). The multi-stage pipeline (explicit ORD+AGG+PC) performs better than single-stage variants that must infer order and aggregation implicitly.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Aggregation remains a weak point (incorrect or over-eager merging causes semantic errors); the representation relies on correct templates to inject semantics; merging unrelated predicates (connected to same subject/object) can produce factual inconsistencies—explicit semantic control of fusion is an open challenge.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Neural Pipeline for Zero-Shot Data-to-Text Generation', 'publication_date_yy_mm': '2022-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e5385.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e5385.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for converting graphs into text for language model training, including details of the representation, properties, evaluation tasks, performance, and comparisons to other methods.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>WikiFluent</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>WikiFluent synthetic corpus</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A large synthetic corpus (934k first-paragraph examples from English Wikipedia, filtered to ~714k) of (simple sentence sets -> fluent paragraph) pairs created by splitting complex sentences and replacing coreferent mentions to train ordering, aggregation, and paragraph-compression modules.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>WikiFluent split-and-replace representation</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>For each human-written paragraph, the authors (a) sentence-split the paragraph, (b) run a split-and-rephrase model (trained on WikiSplit) to produce simpler sentences, (c) apply coreference resolution to replace pronouns with antecedents so that each synthesized fact stands alone, and (d) filter examples using an NLI model to remove hallucinations/omissions. The synthesized sentences form the 'input facts' and the original paragraph is the target fluent output.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>Not a graph per se—provides paired data of sets of simple textual facts (simulating triples) to fluent paragraphs; used to train textual modules that convert triple-derived textual facts into fluent descriptions.</td>
                        </tr>
                        <tr>
                            <td><strong>representation_properties</strong></td>
                            <td>Large-scale, cross-domain (Wikipedia), aligns simple factual sentences with fluent paragraph targets, explicit control signals (original paragraph provides ground-truth ordering/aggregation), filtered and unfiltered variants (filtered = ~714k examples) to trade off noise vs. coverage, suitable for training PLMs for ordering/aggregation/PC without in-domain D2T data.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_task</strong></td>
                            <td>Pretraining / training of ordering, aggregation, and paragraph-compression modules; intrinsic evaluation of these modules on WikiFluent test sets and downstream D2T generation on WebNLG and E2E.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Intrinsic results (Table 7) on WikiFluent test: ORD BLEU-2 = 64.8 (full test) / 71.9 (filtered), ORD accuracy = 0.70 / 0.77; AGG accuracy per example = 0.68, per sentence boundary = 0.93; PC BLEU = 90.72 / 91.60, PC METEOR = 63.89 / 65.03. Downstream pipeline models trained on WikiFluent achieved WebNLG BLEU ~42–43 and E2E BLEU ~36 (see pipeline entries).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_representations</strong></td>
                            <td>WikiFluent is proposed as a general-domain training corpus (vs. finetuning on target D2T datasets). Using WikiFluent-trained modules allows zero-shot generation and compares favorably to naive baselines and some older supervised systems, but does not match state-of-the-art supervised graph-aware systems trained on in-domain data.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Synthetic pipeline (split-and-rephrase + coref) may introduce artifacts; filtering reduces size (~75% kept) and can increase omissions in downstream outputs; domain mismatch between Wikipedia paragraphs and target D2T datasets can limit fidelity; relies on quality of split-and-rephrase and coreference models and on NLI filter accuracy.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Neural Pipeline for Zero-Shot Data-to-Text Generation', 'publication_date_yy_mm': '2022-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e5385.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e5385.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for converting graphs into text for language model training, including details of the representation, properties, evaluation tasks, performance, and comparisons to other methods.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>BART+ptr ordering</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>BART-based encoder-decoder with pointer network ordering (Calizzano et al.)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An ordering model that concatenates tokenized facts, encodes them with a pretrained BART encoder, represents each fact by an end-token embedding, and decodes an order autoregressively using a pointer network that selects facts into positions.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Ordering sentences and paragraphs with pretrained encoder-decoder transformers and pointer ensembles</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>Pointer-network-based sentence ordering (BART+pointer)</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Input: concatenated facts with special <s>...</s> fact delimiters. BART encoder produces fact embeddings; decoding is autoregressive: at each step the pointer network (scaled dot-product attention using decoder state as query and encoder fact embeddings as keys) selects the next fact index to produce a permutation of the facts restoring coherent order.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>Sentence-level facts (derived from RDF triples) — not a graph encoder but a planner operating on linearized factual sentences.</td>
                        </tr>
                        <tr>
                            <td><strong>representation_properties</strong></td>
                            <td>Leverages pretrained PLM representations, models global dependencies via pointer decoding, operates directly on natural-language facts (domain-agnostic), trains by shuffling synthesized WikiFluent facts and recovering original order, interpretable (selected permutations).</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_task</strong></td>
                            <td>Sentence ordering / content planning evaluated against human-generated plans (WebNLG) and on WikiFluent intrinsic test; used as the pipeline's content planner for D2T generation.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>On WebNLG human plans (Table 6): BLEU-2 = 59.10, Accuracy = 0.48. Intrinsic on WikiFluent test (Table 7): BLEU-2 = 64.8 (full), Accuracy = 0.70 (full); filtered test BLEU-2 = 71.9, Acc = 0.77. Compared to RANDOM baseline (B-2 47.00, Acc 0.29) and several supervised planners, it outperforms RANDOM and older transformer baseline but underperforms top supervised planners (Plan-then-generate B-2=84.97, Acc=0.72).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_representations</strong></td>
                            <td>Compared to a RANDOM baseline and previous transformer-based planners: better than random and Ferreira et al. (2019) transformer baseline, worse than Plan-then-generate and PLANENC. The paper uses this model as the ORD module in multi-stage pipelines and shows improved downstream fidelity when explicit ordering is used.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Ordering errors still occur (accuracy below supervised SOTA); relies on good synthetic training data; ordering alone cannot prevent improper semantic merges later (aggregation/PC need to be correct); computational cost of pointer decoding on many facts.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Neural Pipeline for Zero-Shot Data-to-Text Generation', 'publication_date_yy_mm': '2022-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e5385.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e5385.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for converting graphs into text for language model training, including details of the representation, properties, evaluation tasks, performance, and comparisons to other methods.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Linearized representations (prior)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Linearization / serialization of graph inputs for PLMs</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A general approach in prior work that serializes graph or table inputs into flat token sequences (e.g., sequences of delexicalized triple strings) so that pretrained language models can be finetuned or prompted for graph-to-text generation.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Investigating Pretrained Language Models for Graph-to-Text Generation</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>Linearization / serialization</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Flatten graph structures into sequences (for example, concatenated tokens like 'subject | predicate | object' or other linear orders) and feed them to sequence models (PLMs) as text input rather than using graph encoders. Often combined with delexicalization and templates.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>Knowledge graphs / RDF triples / tables</td>
                        </tr>
                        <tr>
                            <td><strong>representation_properties</strong></td>
                            <td>Simple and easy to apply; leverages PLM strengths directly; interpretable surface representation; may lose explicit graph topology but captures facts sequentially; works well in many settings without specialized graph encoders.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_task</strong></td>
                            <td>Graph-to-text / data-to-text benchmarks such as WebNLG and other graph-to-text datasets (as reported in referenced works).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_representations</strong></td>
                            <td>Paper notes prior work (Kale & Rastogi 2020b; Ribeiro et al. 2020) found linearization + PLMs can outperform GNN-based encoders on some graph-to-text datasets; later, structure-aware and graph-based models (Ke et al. 2021; Chen et al. 2020a) surpassed those linearized methods.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>May not capture graph structure explicitly (relations across triples), potentially limiting performance on complex relational phenomena; can encourage overreliance on surface patterns unless supplemented with planning/aggregation mechanisms.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Neural Pipeline for Zero-Shot Data-to-Text Generation', 'publication_date_yy_mm': '2022-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e5385.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e5385.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for converting graphs into text for language model training, including details of the representation, properties, evaluation tasks, performance, and comparisons to other methods.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Graph-based encoders (JointGT etc.)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Structure-aware / graph-based encoders for graph-to-text (e.g., JointGT)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Methods that encode graph topology and node/edge attributes with graph neural networks or structure-aware encoders and then decode text, often combined with task-specific pretraining to capture graph–text alignment.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>JointGT: Graph-Text Joint Representation Learning for Text Generation from Knowledge Graphs</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>Graph-based / structure-aware encoders</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Use graph neural networks or structure-aware transformer encoders that take the graph (nodes, edges, relations) as structured input (not flattened), producing representations that reflect graph topology; these representations are used by decoders to generate text that is aware of graph structure.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>Knowledge graphs / RDF triples</td>
                        </tr>
                        <tr>
                            <td><strong>representation_properties</strong></td>
                            <td>Explicitly models graph structure and relational context; generally more expressive for complex relation modeling; often requires task-specific pretraining and finetuning; less interpretable in surface form but captures inter-triple relations.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_task</strong></td>
                            <td>Graph-to-text generation benchmarks (e.g., WebNLG).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Reported in paper: Ke et al. (2021) structure-aware encoder achieved WebNLG BLEU = 66.14 (Table 3), which the present paper lists as state-of-the-art relative to their results.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_representations</strong></td>
                            <td>Described as surpassing linearized PLM methods (which previously could outperform GNNs), providing stronger performance on WebNLG in recent work. Trade-off: usually requires finetuning on in-domain data and more complex modeling.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Typically rely on in-domain finetuning and task-specific pretraining; can be more complex to implement and scale; not directly applicable in zero-shot settings without additional adaptation.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Neural Pipeline for Zero-Shot Data-to-Text Generation', 'publication_date_yy_mm': '2022-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e5385.6">
                <h3 class="extraction-instance">Extracted Data Instance 6 (e5385.6)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for converting graphs into text for language model training, including details of the representation, properties, evaluation tasks, performance, and comparisons to other methods.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Laha2019 zero-shot</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Scalable Micro-planned Generation of Discourse from Structured Data</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A prior zero-shot D2T pipeline that uses semi-automatic template generation and rule-based sentence fusion, applied to graph-to-text tasks without training on target dataset examples.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Scalable Micro-planned Generation of Discourse from Structured Data</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>Semi-automatic template-based pipeline with rule-based fusion</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Templates are generated semi-automatically to convert triples to sentences; sentence fusion is performed with rule-based methods; the approach does not address learned content planning (ordering) as in the present paper.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>RDF triples / knowledge graphs</td>
                        </tr>
                        <tr>
                            <td><strong>representation_properties</strong></td>
                            <td>Less data-hungry (zero-shot), relies on rule-based fusion which is deterministic and interpretable; no learned content planning module.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_task</strong></td>
                            <td>Zero-shot data-to-text on WebNLG (as compared in this paper).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Reported WebNLG BLEU = 24.80 (Table 3) in this paper (quoted from Laha et al.).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_representations</strong></td>
                            <td>Compared in this paper: the authors' COPY baseline (template outputs) achieved BLEU = 37.18, outperforming Laha et al.'s full system (24.80), indicating that a simple hand-crafted template pipeline can already beat that prior zero-shot approach on WebNLG. The present paper's neural pipeline improves further upon COPY.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Rule-based fusion limits flexibility and fluency; no learned content planning implies weaker coherence/aggregation; semi-automatic template generation can be costly and brittle.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Neural Pipeline for Zero-Shot Data-to-Text Generation', 'publication_date_yy_mm': '2022-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e5385.7">
                <h3 class="extraction-instance">Extracted Data Instance 7 (e5385.7)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for converting graphs into text for language model training, including details of the representation, properties, evaluation tasks, performance, and comparisons to other methods.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>KGPT</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>KGPT: Knowledge-Grounded PreTraining for Data-to-Text Generation</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A method that pretrains models with knowledge-grounded objectives to better align graphs and text, improving downstream graph-to-text generation.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>KGPT: Knowledge-Grounded PreTraining for Data-to-Text Generation</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>Knowledge-grounded graph-text pretraining (KGPT)</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Pretraining strategy that jointly learns from graphs and text to produce representations aligned across modalities, enabling better generation from knowledge graphs when finetuned on downstream D2T tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>Knowledge graphs / RDF triples</td>
                        </tr>
                        <tr>
                            <td><strong>representation_properties</strong></td>
                            <td>Structure-aware pretraining improves generation fidelity and fluency; typically requires substantial pretraining resources and finetuning on target tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_task</strong></td>
                            <td>Graph-to-text generation benchmarks such as WebNLG (referenced as part of the literature overview).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_representations</strong></td>
                            <td>Cited as part of graph-based methods that achieve strong supervised performance, in contrast to zero-shot template/textual planning approaches; compared qualitatively in the paper as part of the landscape where graph-aware pretraining and structure-aware encoders achieve better SOTA results.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Needs in-domain finetuning to reach top performance; not a zero-shot recipe by itself without careful adaptation.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Neural Pipeline for Zero-Shot Data-to-Text Generation', 'publication_date_yy_mm': '2022-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Scalable Micro-planned Generation of Discourse from Structured Data <em>(Rating: 2)</em></li>
                <li>Investigating Pretrained Language Models for Graph-to-Text Generation <em>(Rating: 2)</em></li>
                <li>Text-to-Text Pre-Training for Data-to-Text Tasks <em>(Rating: 2)</em></li>
                <li>JointGT: Graph-Text Joint Representation Learning for Text Generation from Knowledge Graphs <em>(Rating: 2)</em></li>
                <li>KGPT: Knowledge-Grounded PreTraining for Data-to-Text Generation <em>(Rating: 2)</em></li>
                <li>GenWiki: A Dataset of 1.3 Million ContentSharing Text and Graphs for Unsupervised Graph-toText Generation <em>(Rating: 2)</em></li>
                <li>Ordering sentences and paragraphs with pretrained encoder-decoder transformers and pointer ensembles <em>(Rating: 2)</em></li>
                <li>Step-by-Step: Separating Planning from Realization in Neural Data-to-Text Generation <em>(Rating: 1)</em></li>
                <li>Plan-then-Generate: Controlled Data-to-Text Generation via Planning <em>(Rating: 1)</em></li>
                <li>The WebNLG Challenge: Generating Text from RDF Data <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-5385",
    "paper_id": "paper-eecb01418e5ef618fe4d5eb5080de489a1c7cc95",
    "extraction_schema_id": "extraction-schema-111",
    "extracted_data": [
        {
            "name_short": "Single-triple templates",
            "name_full": "Single-triple template linearization",
            "brief_description": "A simple template-based serialization that maps each RDF triple (subject, predicate, object) into a single natural-language sentence via a hand-crafted template per predicate (e.g. \"&lt;s&gt; plays &lt;o&gt;\"). Used as the primary graph-&gt;text representation in this paper's zero-shot pipeline.",
            "citation_title": "here",
            "mention_or_use": "use",
            "representation_name": "Template-based linearization",
            "representation_description": "For each input triple (s, p, o) the system fills a single predicate-specific template t_p producing a sentence fact f: T(p) : \"&lt;s&gt; VERB &lt;o&gt;\" (examples in Table 1). The set of facts is then treated as textual input to downstream text modules (ordering, aggregation, paragraph compression).",
            "graph_type": "RDF triples / knowledge graph (subject–predicate–object triples)",
            "representation_properties": "Interpretable and simple; injects minimal domain knowledge via per-predicate templates; preserves one-triple semantics explicitly in each sentence; can produce surface-level disfluencies (e.g., missing articles) and is not compact (one sentence per triple before aggregation); easy to control and lightweight (no graph encoder needed).",
            "evaluation_task": "Data-to-text generation (WebNLG, E2E); used as input representation for zero-shot pipeline modules.",
            "performance_metrics": "Compared baselines include COPY (copying the template outputs) and full pipeline variants; example scores on WebNLG: COPY BLEU = 37.18, 3-STAGE (full pipeline using templates) BLEU = 42.92 (full WikiFluent-trained models). On E2E: COPY BLEU = 24.19, 3-STAGE BLEU = 36.04. Metrics used: BLEU, METEOR, omissions/hallucinations (per-fact and per-example rates).",
            "comparison_to_other_representations": "Outperforms the naive COPY baseline when followed by learned ordering/aggregation/compression; yields competitive results vs. some older supervised systems but underperforms recent structure-aware graph encoders (e.g., Ke et al. 2021). The paper notes template linearization is a minimal, practical representation for zero-shot settings compared to approaches that require graph-aware encoders or task-specific finetuning.",
            "limitations_or_challenges": "Requires hand-crafted templates for each predicate (scalability issues when predicates are many); templates can introduce grammatical artifacts needing repair by downstream modules; semantic merging errors can arise later (improper fusion of unrelated facts) because templates provide no structural typing that constrains fusion; less expressive than structured graph encoders for capturing relations across triples.",
            "uuid": "e5385.0",
            "source_info": {
                "paper_title": "Neural Pipeline for Zero-Shot Data-to-Text Generation",
                "publication_date_yy_mm": "2022-03"
            }
        },
        {
            "name_short": "Textual content plan",
            "name_full": "Ordered textual content plan with aggregation markers",
            "brief_description": "A textual content-plan representation where triples are first converted to template sentences (facts), then an ordering model sorts them and an aggregation model marks sentence boundaries; the paragraph compression model consumes the ordered facts with aggregation delimiters to produce the final text.",
            "citation_title": "here",
            "mention_or_use": "use",
            "representation_name": "Textual content plan (ordered facts + aggregation markers)",
            "representation_description": "Representation = sequence F_a = {f_o1, δ_o1, f_o2, ..., δ_o(n-1), f_on}, where f_oi are the template sentences (one per triple) ordered by an ordering model and δ_i∈{0,1} are binary aggregation delimiters indicating whether to merge adjacent facts (δ=0) or keep them separate (δ=1). This textual plan is fed to a generative paragraph-compression PLM that fuses and rephrases into fluent text.",
            "graph_type": "RDF triples converted to sentence-level textual facts",
            "representation_properties": "Interpretable, controllable (explicit order and aggregation markers), modular (separable planning and realization steps), amenable to zero-shot training since planning operates on natural-language facts rather than dataset-specific predicate keys; helps reduce hallucinations/omissions when used properly; can be followed reliably by the paragraph-compression model (95–100% adherence reported).",
            "evaluation_task": "Content planning and data-to-text generation (evaluated on WebNLG and E2E). Also intrinsic evaluation of planning modules (ordering & aggregation) on WikiFluent and human-generated plans.",
            "performance_metrics": "Ordering performance on WebNLG vs. human plans: BLEU-2 = 59.10, Accuracy = 0.48 (Table 6). Aggregation accuracy: 0.33 per example and 0.62 per sentence boundary (random baseline 0.23 / 0.50). Paragraph compression adherence to plan: 95% (WebNLG) and 100% (E2E) in manual evaluation. Downstream BLEU/METEOR & omission/hallucination rates reported for full pipelines (see other entries).",
            "comparison_to_other_representations": "Compared against random ordering and prior textual planners: outperforms random and transformer-based planner from Ferreira et al. (2019) but lags behind state-of-the-art supervised planners (Plan-then-generate, PLANENC). The multi-stage pipeline (explicit ORD+AGG+PC) performs better than single-stage variants that must infer order and aggregation implicitly.",
            "limitations_or_challenges": "Aggregation remains a weak point (incorrect or over-eager merging causes semantic errors); the representation relies on correct templates to inject semantics; merging unrelated predicates (connected to same subject/object) can produce factual inconsistencies—explicit semantic control of fusion is an open challenge.",
            "uuid": "e5385.1",
            "source_info": {
                "paper_title": "Neural Pipeline for Zero-Shot Data-to-Text Generation",
                "publication_date_yy_mm": "2022-03"
            }
        },
        {
            "name_short": "WikiFluent",
            "name_full": "WikiFluent synthetic corpus",
            "brief_description": "A large synthetic corpus (934k first-paragraph examples from English Wikipedia, filtered to ~714k) of (simple sentence sets -&gt; fluent paragraph) pairs created by splitting complex sentences and replacing coreferent mentions to train ordering, aggregation, and paragraph-compression modules.",
            "citation_title": "here",
            "mention_or_use": "use",
            "representation_name": "WikiFluent split-and-replace representation",
            "representation_description": "For each human-written paragraph, the authors (a) sentence-split the paragraph, (b) run a split-and-rephrase model (trained on WikiSplit) to produce simpler sentences, (c) apply coreference resolution to replace pronouns with antecedents so that each synthesized fact stands alone, and (d) filter examples using an NLI model to remove hallucinations/omissions. The synthesized sentences form the 'input facts' and the original paragraph is the target fluent output.",
            "graph_type": "Not a graph per se—provides paired data of sets of simple textual facts (simulating triples) to fluent paragraphs; used to train textual modules that convert triple-derived textual facts into fluent descriptions.",
            "representation_properties": "Large-scale, cross-domain (Wikipedia), aligns simple factual sentences with fluent paragraph targets, explicit control signals (original paragraph provides ground-truth ordering/aggregation), filtered and unfiltered variants (filtered = ~714k examples) to trade off noise vs. coverage, suitable for training PLMs for ordering/aggregation/PC without in-domain D2T data.",
            "evaluation_task": "Pretraining / training of ordering, aggregation, and paragraph-compression modules; intrinsic evaluation of these modules on WikiFluent test sets and downstream D2T generation on WebNLG and E2E.",
            "performance_metrics": "Intrinsic results (Table 7) on WikiFluent test: ORD BLEU-2 = 64.8 (full test) / 71.9 (filtered), ORD accuracy = 0.70 / 0.77; AGG accuracy per example = 0.68, per sentence boundary = 0.93; PC BLEU = 90.72 / 91.60, PC METEOR = 63.89 / 65.03. Downstream pipeline models trained on WikiFluent achieved WebNLG BLEU ~42–43 and E2E BLEU ~36 (see pipeline entries).",
            "comparison_to_other_representations": "WikiFluent is proposed as a general-domain training corpus (vs. finetuning on target D2T datasets). Using WikiFluent-trained modules allows zero-shot generation and compares favorably to naive baselines and some older supervised systems, but does not match state-of-the-art supervised graph-aware systems trained on in-domain data.",
            "limitations_or_challenges": "Synthetic pipeline (split-and-rephrase + coref) may introduce artifacts; filtering reduces size (~75% kept) and can increase omissions in downstream outputs; domain mismatch between Wikipedia paragraphs and target D2T datasets can limit fidelity; relies on quality of split-and-rephrase and coreference models and on NLI filter accuracy.",
            "uuid": "e5385.2",
            "source_info": {
                "paper_title": "Neural Pipeline for Zero-Shot Data-to-Text Generation",
                "publication_date_yy_mm": "2022-03"
            }
        },
        {
            "name_short": "BART+ptr ordering",
            "name_full": "BART-based encoder-decoder with pointer network ordering (Calizzano et al.)",
            "brief_description": "An ordering model that concatenates tokenized facts, encodes them with a pretrained BART encoder, represents each fact by an end-token embedding, and decodes an order autoregressively using a pointer network that selects facts into positions.",
            "citation_title": "Ordering sentences and paragraphs with pretrained encoder-decoder transformers and pointer ensembles",
            "mention_or_use": "use",
            "representation_name": "Pointer-network-based sentence ordering (BART+pointer)",
            "representation_description": "Input: concatenated facts with special &lt;s&gt;...&lt;/s&gt; fact delimiters. BART encoder produces fact embeddings; decoding is autoregressive: at each step the pointer network (scaled dot-product attention using decoder state as query and encoder fact embeddings as keys) selects the next fact index to produce a permutation of the facts restoring coherent order.",
            "graph_type": "Sentence-level facts (derived from RDF triples) — not a graph encoder but a planner operating on linearized factual sentences.",
            "representation_properties": "Leverages pretrained PLM representations, models global dependencies via pointer decoding, operates directly on natural-language facts (domain-agnostic), trains by shuffling synthesized WikiFluent facts and recovering original order, interpretable (selected permutations).",
            "evaluation_task": "Sentence ordering / content planning evaluated against human-generated plans (WebNLG) and on WikiFluent intrinsic test; used as the pipeline's content planner for D2T generation.",
            "performance_metrics": "On WebNLG human plans (Table 6): BLEU-2 = 59.10, Accuracy = 0.48. Intrinsic on WikiFluent test (Table 7): BLEU-2 = 64.8 (full), Accuracy = 0.70 (full); filtered test BLEU-2 = 71.9, Acc = 0.77. Compared to RANDOM baseline (B-2 47.00, Acc 0.29) and several supervised planners, it outperforms RANDOM and older transformer baseline but underperforms top supervised planners (Plan-then-generate B-2=84.97, Acc=0.72).",
            "comparison_to_other_representations": "Compared to a RANDOM baseline and previous transformer-based planners: better than random and Ferreira et al. (2019) transformer baseline, worse than Plan-then-generate and PLANENC. The paper uses this model as the ORD module in multi-stage pipelines and shows improved downstream fidelity when explicit ordering is used.",
            "limitations_or_challenges": "Ordering errors still occur (accuracy below supervised SOTA); relies on good synthetic training data; ordering alone cannot prevent improper semantic merges later (aggregation/PC need to be correct); computational cost of pointer decoding on many facts.",
            "uuid": "e5385.3",
            "source_info": {
                "paper_title": "Neural Pipeline for Zero-Shot Data-to-Text Generation",
                "publication_date_yy_mm": "2022-03"
            }
        },
        {
            "name_short": "Linearized representations (prior)",
            "name_full": "Linearization / serialization of graph inputs for PLMs",
            "brief_description": "A general approach in prior work that serializes graph or table inputs into flat token sequences (e.g., sequences of delexicalized triple strings) so that pretrained language models can be finetuned or prompted for graph-to-text generation.",
            "citation_title": "Investigating Pretrained Language Models for Graph-to-Text Generation",
            "mention_or_use": "mention",
            "representation_name": "Linearization / serialization",
            "representation_description": "Flatten graph structures into sequences (for example, concatenated tokens like 'subject | predicate | object' or other linear orders) and feed them to sequence models (PLMs) as text input rather than using graph encoders. Often combined with delexicalization and templates.",
            "graph_type": "Knowledge graphs / RDF triples / tables",
            "representation_properties": "Simple and easy to apply; leverages PLM strengths directly; interpretable surface representation; may lose explicit graph topology but captures facts sequentially; works well in many settings without specialized graph encoders.",
            "evaluation_task": "Graph-to-text / data-to-text benchmarks such as WebNLG and other graph-to-text datasets (as reported in referenced works).",
            "performance_metrics": null,
            "comparison_to_other_representations": "Paper notes prior work (Kale & Rastogi 2020b; Ribeiro et al. 2020) found linearization + PLMs can outperform GNN-based encoders on some graph-to-text datasets; later, structure-aware and graph-based models (Ke et al. 2021; Chen et al. 2020a) surpassed those linearized methods.",
            "limitations_or_challenges": "May not capture graph structure explicitly (relations across triples), potentially limiting performance on complex relational phenomena; can encourage overreliance on surface patterns unless supplemented with planning/aggregation mechanisms.",
            "uuid": "e5385.4",
            "source_info": {
                "paper_title": "Neural Pipeline for Zero-Shot Data-to-Text Generation",
                "publication_date_yy_mm": "2022-03"
            }
        },
        {
            "name_short": "Graph-based encoders (JointGT etc.)",
            "name_full": "Structure-aware / graph-based encoders for graph-to-text (e.g., JointGT)",
            "brief_description": "Methods that encode graph topology and node/edge attributes with graph neural networks or structure-aware encoders and then decode text, often combined with task-specific pretraining to capture graph–text alignment.",
            "citation_title": "JointGT: Graph-Text Joint Representation Learning for Text Generation from Knowledge Graphs",
            "mention_or_use": "mention",
            "representation_name": "Graph-based / structure-aware encoders",
            "representation_description": "Use graph neural networks or structure-aware transformer encoders that take the graph (nodes, edges, relations) as structured input (not flattened), producing representations that reflect graph topology; these representations are used by decoders to generate text that is aware of graph structure.",
            "graph_type": "Knowledge graphs / RDF triples",
            "representation_properties": "Explicitly models graph structure and relational context; generally more expressive for complex relation modeling; often requires task-specific pretraining and finetuning; less interpretable in surface form but captures inter-triple relations.",
            "evaluation_task": "Graph-to-text generation benchmarks (e.g., WebNLG).",
            "performance_metrics": "Reported in paper: Ke et al. (2021) structure-aware encoder achieved WebNLG BLEU = 66.14 (Table 3), which the present paper lists as state-of-the-art relative to their results.",
            "comparison_to_other_representations": "Described as surpassing linearized PLM methods (which previously could outperform GNNs), providing stronger performance on WebNLG in recent work. Trade-off: usually requires finetuning on in-domain data and more complex modeling.",
            "limitations_or_challenges": "Typically rely on in-domain finetuning and task-specific pretraining; can be more complex to implement and scale; not directly applicable in zero-shot settings without additional adaptation.",
            "uuid": "e5385.5",
            "source_info": {
                "paper_title": "Neural Pipeline for Zero-Shot Data-to-Text Generation",
                "publication_date_yy_mm": "2022-03"
            }
        },
        {
            "name_short": "Laha2019 zero-shot",
            "name_full": "Scalable Micro-planned Generation of Discourse from Structured Data",
            "brief_description": "A prior zero-shot D2T pipeline that uses semi-automatic template generation and rule-based sentence fusion, applied to graph-to-text tasks without training on target dataset examples.",
            "citation_title": "Scalable Micro-planned Generation of Discourse from Structured Data",
            "mention_or_use": "mention",
            "representation_name": "Semi-automatic template-based pipeline with rule-based fusion",
            "representation_description": "Templates are generated semi-automatically to convert triples to sentences; sentence fusion is performed with rule-based methods; the approach does not address learned content planning (ordering) as in the present paper.",
            "graph_type": "RDF triples / knowledge graphs",
            "representation_properties": "Less data-hungry (zero-shot), relies on rule-based fusion which is deterministic and interpretable; no learned content planning module.",
            "evaluation_task": "Zero-shot data-to-text on WebNLG (as compared in this paper).",
            "performance_metrics": "Reported WebNLG BLEU = 24.80 (Table 3) in this paper (quoted from Laha et al.).",
            "comparison_to_other_representations": "Compared in this paper: the authors' COPY baseline (template outputs) achieved BLEU = 37.18, outperforming Laha et al.'s full system (24.80), indicating that a simple hand-crafted template pipeline can already beat that prior zero-shot approach on WebNLG. The present paper's neural pipeline improves further upon COPY.",
            "limitations_or_challenges": "Rule-based fusion limits flexibility and fluency; no learned content planning implies weaker coherence/aggregation; semi-automatic template generation can be costly and brittle.",
            "uuid": "e5385.6",
            "source_info": {
                "paper_title": "Neural Pipeline for Zero-Shot Data-to-Text Generation",
                "publication_date_yy_mm": "2022-03"
            }
        },
        {
            "name_short": "KGPT",
            "name_full": "KGPT: Knowledge-Grounded PreTraining for Data-to-Text Generation",
            "brief_description": "A method that pretrains models with knowledge-grounded objectives to better align graphs and text, improving downstream graph-to-text generation.",
            "citation_title": "KGPT: Knowledge-Grounded PreTraining for Data-to-Text Generation",
            "mention_or_use": "mention",
            "representation_name": "Knowledge-grounded graph-text pretraining (KGPT)",
            "representation_description": "Pretraining strategy that jointly learns from graphs and text to produce representations aligned across modalities, enabling better generation from knowledge graphs when finetuned on downstream D2T tasks.",
            "graph_type": "Knowledge graphs / RDF triples",
            "representation_properties": "Structure-aware pretraining improves generation fidelity and fluency; typically requires substantial pretraining resources and finetuning on target tasks.",
            "evaluation_task": "Graph-to-text generation benchmarks such as WebNLG (referenced as part of the literature overview).",
            "performance_metrics": null,
            "comparison_to_other_representations": "Cited as part of graph-based methods that achieve strong supervised performance, in contrast to zero-shot template/textual planning approaches; compared qualitatively in the paper as part of the landscape where graph-aware pretraining and structure-aware encoders achieve better SOTA results.",
            "limitations_or_challenges": "Needs in-domain finetuning to reach top performance; not a zero-shot recipe by itself without careful adaptation.",
            "uuid": "e5385.7",
            "source_info": {
                "paper_title": "Neural Pipeline for Zero-Shot Data-to-Text Generation",
                "publication_date_yy_mm": "2022-03"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Scalable Micro-planned Generation of Discourse from Structured Data",
            "rating": 2
        },
        {
            "paper_title": "Investigating Pretrained Language Models for Graph-to-Text Generation",
            "rating": 2
        },
        {
            "paper_title": "Text-to-Text Pre-Training for Data-to-Text Tasks",
            "rating": 2
        },
        {
            "paper_title": "JointGT: Graph-Text Joint Representation Learning for Text Generation from Knowledge Graphs",
            "rating": 2
        },
        {
            "paper_title": "KGPT: Knowledge-Grounded PreTraining for Data-to-Text Generation",
            "rating": 2
        },
        {
            "paper_title": "GenWiki: A Dataset of 1.3 Million ContentSharing Text and Graphs for Unsupervised Graph-toText Generation",
            "rating": 2
        },
        {
            "paper_title": "Ordering sentences and paragraphs with pretrained encoder-decoder transformers and pointer ensembles",
            "rating": 2
        },
        {
            "paper_title": "Step-by-Step: Separating Planning from Realization in Neural Data-to-Text Generation",
            "rating": 1
        },
        {
            "paper_title": "Plan-then-Generate: Controlled Data-to-Text Generation via Planning",
            "rating": 1
        },
        {
            "paper_title": "The WebNLG Challenge: Generating Text from RDF Data",
            "rating": 1
        }
    ],
    "cost": 0.020544999999999997,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Neural Pipeline for Zero-Shot Data-to-Text Generation</h1>
<p>Zdeněk Kasner and Ondřej Dušek<br>Charles University, Faculty of Mathematics and Physics<br>Institute of Formal and Applied Linguistics<br>Prague, Czech Republic<br>{kasner, odusek}@ufal.mff.cuni.cz</p>
<h4>Abstract</h4>
<p>In data-to-text (D2T) generation, training on in-domain data leads to overfitting to the data representation and repeating training data noise. We examine how to avoid finetuning pretrained language models (PLMs) on D2T generation datasets while still taking advantage of surface realization capabilities of PLMs. Inspired by pipeline approaches, we propose to generate text by transforming single-item descriptions with a sequence of modules trained on generaldomain text-based operations: ordering, aggregation, and paragraph compression. We train PLMs for performing these operations on a synthetic corpus WikiFluent which we build from English Wikipedia. Our experiments on two major triple-to-text datasets-WebNLG and E2E-show that our approach enables D2T generation from RDF triples in zero-shot settings. ${ }^{1}$</p>
<h2>1 Introduction</h2>
<p>The aim of data-to-text (D2T) generation is to produce natural language descriptions of structured data (Gatt and Krahmer, 2018; Reiter and Dale, 1997). Although pipelines of rule-based D2T generation modules are still used in practice (Dale, 2020), end-to-end approaches based on PLMs recently showed superior benchmark performance (Ke et al., 2021; Chen et al., 2020a; Ferreira et al., 2020; Kale and Rastogi, 2020b; Ribeiro et al., 2020), surpassing pipeline systems (Ferreira et al., 2019) in both automatic and human evaluation metrics.</p>
<p>Finetuning PLMs on human-written references is widely accepted as a standard approach for adapting PLMs to the D2T generation objective and achieving good performance on a given benchmark (Agarwal et al., 2021; Ke et al., 2021). However, finetuning a model on the domain-specific data leads to overfitting to the particular benchmark, decreasing performance on out-of-domain</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: A scheme of our pipeline for zero-shot data-to-text generation from RDF triples: (1) ordering, (2) aggregation, (3) paragraph compression. Individual pipeline modules are trained on a large general-domain text corpus and operate over text in natural language. In-domain knowledge is included only in the simple hand-crafted templates for each predicate.
data (Laha et al., 2019). Gathering a large set of references for a particular domain is also costly and time-consuming as it usually requires collecting human-written references through crowdsourcing (Dušek et al., 2020). These problems can be partially mitigated using few-shot approaches (Chen et al., 2020b; Ke et al., 2021; Su et al., 2021a), which operate with only several dozens or hundreds of annotated examples, but the robustness of these approaches is questionable-selecting a representative set of examples which would improve performance is difficult (Chang et al., 2021a), and the limited sample is often noisy, increasing the chance of hallucinations and omissions (Dušek et al., 2019; Harkous et al., 2020; Rebuffel et al., 2022).</p>
<p>In this paper, we present a zero-shot alternative to the traditional finetuning paradigm by formulating the D2T generation from RDF triples as a sequence of general-domain operations over text in natural language. We start by transforming individual triples to text using trivial templates, which</p>
<p>we subsequently order, aggregate, and compress on the paragraph level to produce the resulting description of the data. In constrast to traditional pipeline systems, all our pipeline modules are built upon PLMs and operate over sentences in natural language. The modules are trained on our new WIKIFLUENT corpus, which contains 934 k examples of first paragraphs from the English Wikipedia, each supplied with a synthesized set of simple templatelike sentences which together convey the meaning of the original paragraph. Our approach allows generating natural language descriptions from RDF triples with a minimum amount of domain-specific rules or knowledge and without using training data from the D2T datasets. Although our approach is primarily a probe into the territory of zero-shot approaches and cannot yet match the quality of state-of-the-art models, we show that it can yield large improvements upon simple baselines and match older supervised systems on automatic metrics for text fluency. Moreover, the semantic accuracy metrics and our manual error analysis suggest that our approach offers a way to prevent omissions and hallucinations common in few-shot approaches.</p>
<p>Our contributions are the following:
(1) We propose an alternative D2T generation approach based on general-domain text-to-text operations (ordering, aggregation, and paragraph compression).
(2) We introduce a synthetic WikiFluent corpus containing 934k sentences based on English Wikipedia, providing training data for the operations in (1).
(3) We apply our system on two D2T datasets and evaluate its performance both automatically and manually, including the contribution of individual pipeline modules.
(4) We release our code, data, pretrained models, and system outputs to ease future research. ${ }^{1}$</p>
<h2>2 Related Work</h2>
<p>D2T Generation with PLMs Large neural language models pretrained on self-supervised tasks (Lewis et al., 2020; Liu et al., 2019; Devlin et al., 2019) have recently gained a lot of traction in D2T generation research (Ferreira et al., 2020; Kasner and Dušek, 2020b). Following Chen et al. (2020b), other works adopted PLMs for few-shot D2T generation (Chang et al., 2021b; Su et al., 2021a). Kale and Rastogi (2020b) and Ribeiro et al. (2020) showed that PLMs using linearized representations
of data can outperform graph neural networks on graph-to-text datasets, recently surpassed again by graph-based models (Ke et al., 2021; Chen et al., 2020a). Although the models make use of generaldomain pretraining tasks, all of them are eventually finetuned on domain-specific data.</p>
<p>Pipeline-based D2T Generation Until the recent surge of end-to-end approaches (Dušek et al., 2020), using several modules connected in a pipeline was a major approach for D2T generation (Gatt and Krahmer, 2018; Reiter, 2007; Reiter and Dale, 1997). Our approach is inspired by the pipeline approaches, in particular the pipelines utilizing neural modules (Ferreira et al., 2019). In contrast with these approaches, our pipeline works with unstructured data in natural language and it operates in zero-shot setting, i.e. without using any training data from target D2T datasets.</p>
<p>Laha et al. (2019) introduce a three-step pipeline for zero-shot D2T generation similar to ours. Unlike the approach we describe here, they use a semiautomatic template generation system, ${ }^{2}$ their sentence fusion is rule-based, and they do not address content planning.</p>
<p>Content Planning in D2T Generation Content planning, i.e. the task of ordering input facts and aggregating them into individual sentences, is one of the steps of the traditional D2T pipeline (Gatt and Krahmer, 2018). As shown by Moryossef et al. (2019a,b) and confirmed by other works (Puduppully et al., 2019; Zhao et al., 2020; Trisedya et al., 2020; Su et al., 2021b), including a content plan improves the quality of outputs in neural D2T pipelines. Unlike the aforementioned planners, which use predicates or keys from D2T datasets for representing the data items, our planner is trained on ordering sentences in natural language.</p>
<p>Sentence Ordering Sentence ordering is the task of organizing a set of natural language sentences to increase the coherence of a text (Barzilay et al., 2001; Lapata, 2003). Several neural methods for this task were proposed, using either interactions between pairs of sentences (Chen et al., 2016; Li and Jurafsky, 2017), global interactions (Gong et al., 2016; Wang and Wan, 2019), or combination of both (Cui et al., 2020). We base our ordering module (§5.2) on the recent work of Calizzano et al.</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>(2021), who use a pointer network (Wang and Wan, 2019; Vinyals et al., 2015) on top of a PLM.</p>
<p>Aggregating Input into Sentences Typically, multiple pieces of input information need to be merged into a single sentence. Previous works (Wiseman et al., 2018; Shao et al., 2019; Shen et al., 2020; Xu et al., 2021) capture the segments which correspond to individual parts of the input as latent variables. Unlike these works, we adopt a simpler scenario using an already ordered sequence of facts (see §3.1), into which we selectively insert delimiters to mark sentence boundaries.</p>
<p>Paragraph Compression We introduce paragraph compression (PC) as a new task and the final step in our D2T generation pipeline. This task combines several standard natural-language tasks including sentence fusion, rephrasing, and coreference resolution. Unlike text summarization or simplification (Zhang et al., 2020; Jiang et al., 2020), we aim to convey the complete semantics of the text without omitting any facts. In contrast to sentence fusion (Geva et al., 2019; Barzilay and McKeown, 2005) or sentence compression (Filippova and Altun, 2013), we operate in the context of multiple sentences in a paragraph. The task is the central focus of our WikiFluent corpus (§4).</p>
<h2>3 Method</h2>
<p>In this section, we provide the formal description of our proposed approach. We focus on the task of producing a natural language description $Y$ for a set of $n$ RDF triples $X=\left{x_{1}, \ldots, x_{n}\right}$. Each triple $x_{i}=\left{s_{i}, p_{i}, o_{i}\right}$ consists of subject $s_{i}$, predicate $p_{i}$, and object $o_{i}$.</p>
<p>Our pipeline proceeds as follows. Given a set of triples $X$ on the input, we:
(1) transform the triples into facts, which are sentences in natural language,
(2) sort the facts using an ordering module,
(3) insert sentence delimiters between the sorted facts using an aggregation module,
(4) input the ordered sequence of facts with delimiters into a paragraph compression module, which generates the final description $Y$.
The individual steps are described in the following sections: transforming individual triples to text (§3.1), ordering (§3.2), aggregation (§3.3), and paragraph compression (§3.4).</p>
<h3>3.1 Transforming Triples to Facts</h3>
<p>The first step in our pipeline involves transforming each of the input triples $x_{i} \in X$ into a fact $f_{i} \in F$ using a transformation $T: X \rightarrow F$. We define a fact $f_{i}$ as a single sentence in natural language describing $x_{i}$. The transformation serves two purposes: (a) preparing the data for the subsequent text-to-text operations, (b) introducing in-domain knowledge about the semantics of individual predicates. This step can be realized e.g. using a simple template for each predicate (cf. §5.1).</p>
<h3>3.2 Ordering the Facts</h3>
<p>We assume that the default order of triples $X$ is random and the same applies for the respective facts $F$. Note, however, that that $F$ is a indeed set of meaningful sentences. We can use this to our advantage and apply a sentence ordering model to maximize the coherency of the paragraph resulting from their concatenation. An example outcome of such operation may be grouping together facts mentioning birth date and birth place of a person, followed by their occupation (see Figure 1). The ordering module allows downstream modules to only focus on operations over neighboring sentences.</p>
<p>Formally, we apply the ordering model $O(F)$ to get an ordered sequence of facts: $F_{o}=$ $\left{f_{o_{1}}, \ldots, f_{o_{n}}\right}$, where $o_{1: n}$ is a permutation of indices. We describe our ordering model in $\S 5.2$.</p>
<h3>3.3 Aggregating the Facts</h3>
<p>Some facts will be typically mentioned together in a single sentence. Considering the previous example, occupation is likely to be mentioned separately, while birth date and birth place are likely to be mentioned together. Using an ordered sequence of facts as input, we can apply an aggregation model to decide which facts should be merged into a single sentence.</p>
<p>Formally, the aggregation model takes a sequence of ordered facts $F_{o}$ as input and produces a sequence of sentence delimiters $A\left(F_{o}\right)=$ $\left{\delta_{o_{1}}, \delta_{o_{2}}, \ldots, \delta_{o_{n-1}}\right} ; \delta_{i} \in{0,1}$. The output $\delta_{i}=1$ means that the neighboring facts should be mentioned separately, i.e. the neighboring sentences should not be fused. Conversely, $\delta_{i}=0$ means that the facts should be aggregated and their corresponding sentences should be fused. We describe our aggregation model in $\S 5.3$.</p>
<h3>3.4 Paragraph Compression</h3>
<p>The paragraph compression (PC) model is a generative model which outputs the final text description. It has two main objectives: (a) fusing related sentences, i.e., sentences $i$ and $j$ in between which $\delta_{i}=0$, and (b) rephrasing the text to improve its fluency, e.g. fixing disfluencies in the templates, replacing noun phrases with refering expressions, etc. The goal of the task is to preserve the semantics of the text which is an already ordered sequence of sentences, so the edits will typically be minor. Formally, the model takes as input the ordered sequence of facts with delimiters $F_{a}=\left{f_{o_{1}}, \delta_{o_{1}}, f_{o_{2}}, \ldots, \delta_{o_{n-1}}, f_{o_{n}}\right}$ and produces the final text $Y$. We describe our PC model in $\S 5.4$.</p>
<h2>4 WikiFluent Corpus</h2>
<p>Here we descibe the process of building a largescale synthetic corpus WIKIFLUENT. The corpus provides training data for the neural models which we use in our implementation of the ordering, aggregation, and paragraph compression modules (cf. §5).</p>
<p>Our goal is to cover a broad range of domains while capturing the sentence style in D2T generation with respect to both the input facts and the target descriptions. In other words, we aim to build a corpus in which (1) the input is a set of simple, template-like sentences, (2) the output is a fluent text in natural language preserving the semantics of the input. As we describe below in detail, we achieve that by using human-written paragraphs in English Wikipedia and applying split-and-rephrase and coreference resolution models to obtain synthetic source texts. The process is illustrated in Figure 2; corpus statistics are included in Appendix A.</p>
<h3>4.1 Data Source</h3>
<p>For building the WikiFluent corpus, we extracted 934 k first paragraphs of articles from a Wikipedia dump ${ }^{3}$ using WikiExtractor (Attardi, 2015). Wikipedia is commonly used for large-scale pretraining of D2T generation models (Jin et al., 2020; Chen et al., 2020a). Although it is not biasfree, it provides more balanced sample of natural language use than typical D2T generation datasets. We used the first paragraphs of Wikipedia entries, which contain mostly concise, fact-based descriptions. We selected paragraphs with length between</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: The building process of the WIKIFluENT corpus. We apply a split-and-rephrase model on each sentence in the paragraph and resolve coreferences in the split sentences. The result is a set of simple sentences which together convey the same meaning as the original paragraph. The synthesized sentences are used as input into our models, the original human-written texts are used as ground truth.</p>
<p>30-430 characters; filtering out lists, disambiguations, and repeated and malformed paragraphs. To balance the length of inputs, we selected 250k examples each from 4 equally sized length ranges (30-130 characters, etc.).</p>
<h3>4.2 Split-and-Rephrase</h3>
<p>To generate a set of simple sentences, we divide each paragraph into sentences using NLTK (Bird, 2006) and apply a split-and-rephrase model on each sentence. Split-and-rephrase is a task of splitting a complex sentence into a meaning preserving sequence of shorter sentences (Narayan et al., 2017). The process is illustrated in the upper part of Figure 2.</p>
<p>We train our split-and-rephrase model on the large-scale WikiSplit corpus by Botha et al. (2018), containing human-made sentence splits from Wikipedia edit history. Following the same setup as for a paragraph compression model (§3.4), we train BART-base (Lewis et al., 2020) on the WikiSplit dataset in a sequence-to-sequence setting. Next, we apply the trained split-and-rephrase model on each sentence in our Wikipedia-based corpus, uniformly randomly choosing between $0-2$ recursive calls to ensure that the splits are not deterministic. If the sentence cannot be meaningfully split, the model tends to duplicate the sentence on the output; in that case, we use only the original sentence and do not proceed with the splitting.</p>
<h3>4.3 Coreference Replacement</h3>
<p>As the next step, we concatenate the split sentences and apply a coreference resolution model (Gardner et al., 2018; Lee et al., 2018) in order to replace referring expressions with their antencendents (e.g., pronouns with noun phrases). The motivation for this step is to match the style of the facts (see §3.1), which do not use pronouns since each fact describes a single triple only. Note that this procedure replaces the referring expressions only in the synthesized sentences (which are used as input) and keeps them in the original paragraphs (which are used as ground truth). As a consequence, the paragraph compression module is implicitly trained to generate referring expressions in the final description.</p>
<h3>4.4 Filtering</h3>
<p>To ensure that the generated sentences convey the same semantics as the original paragraph, we use a pretrained RoBERTa model ${ }^{4}$ (Liu et al., 2019) trained on the MultiNLI dataset (Williams et al., 2018) for checking the semantic accuracy of the generated text. Following Dušek and Kasner (2020), we test if the original paragraph entails each of the synthesized sentences (checking for omissions), and if the set of concatenated synthesized sentences entails the original paragraph (checking for hallucinations). In a filtered version of the WIKIFLUENT corpus, we include only the examples without omissions or hallucinations (as computed by the model), reducing it to 714 k examples (approximately $75 \%$ of the original size).</p>
<h2>5 Implementation</h2>
<p>In this section, we describe how we implement our pipeline modules (§3) using simple template transformations (§5.1) and neural models trained on the WIKIFLUENT dataset (§5.2-5.4). ${ }^{5}$</p>
<h3>5.1 Templates</h3>
<p>We transform triples into facts (§3.1) using a singletriple template $t_{i}$ for each predicate. For example, if $p_{i}=$ instrument, then $T\left(p_{i}\right)=$ " $s_{i}$ plays $o_{i}$ " (cf. Table 1). We follow previous work in which simple hand-crafted templates have been used as an efficient way of introducing domain knowledge (Kale and Rastogi, 2020a; Kasner and Dušek, 2020a). Compared to more complex rule-based</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup>| dataset | predicate | template |
| :-- | :-- | :-- |
| WebNLG | instrument <br> countryOrigin <br> width | $<s>$ plays $<o>$. <br> $<s>$ comes from $<o>$. <br> $<s>$ is $<o>$ wide. |
| E2E | eatType <br> food <br> area | $<s>$ is a $<o>$. <br> $<s>$ serves $<o>$ food. <br> $<s>$ is in the $<o>$. |</p>
<p>Table 1: Examples of templates for predicates in the WebNLG and E2E datasets with placeholders for the subject $(<s>)$ and the object $(<o>)$.
template generation engines (Laha et al., 2019; Heidari et al., 2021; Mehta et al., 2021), the approach may produce less fluent outputs, but it minimizes manual workload and makes it easier to control the quality of the input for the subsequent steps.</p>
<h3>5.2 Ordering Model</h3>
<p>For our ordering model (§3.2), we use the Simple Pointer model from Calizzano et al. (2021). The model is based on a pretrained BART-base extended with a pointer network from Wang and Wan (2019). We provide a short description of the model here; for details please refer to Calizzano et al. (2021).</p>
<p>In the encoding phase, facts $F$ are concatenated and tokenized. Each fact is surrounded by special tokens denoting the beginning ( $\langle\mathrm{s}\rangle$ ) and the end $(&lt;/ \mathrm{s}\rangle$ ) of the fact. The sequence is processed by the BART encoder, generating a sequence of encoder states $E$ for each end token $&lt;/ \mathrm{s}&gt;$ representing the preceding fact.</p>
<p>The decoding proceeds autoregressively. To bootstrap the decoding process, the pair of tokens $\langle\mathrm{s}\rangle&lt;/ \mathrm{s}\rangle$ is fed into the decoder, producing the decoder state $d_{1}$. The pointer network (attending to $d_{1}$ and $E$ ), selects the first ordered fact $f_{o_{1}}$, which is fed into the decoder in the next step $\left(d_{2}=\langle\mathrm{s}\rangle f_{o_{1}}&lt;/ \mathrm{s}\rangle\right)$. The process is repeated until the all the facts are decoded in a particular order.</p>
<p>The pointer network computes the probability of a fact to be on the $j$-th position, using the encoder output $E$ and the decoder output state $d_{j}$. The network is based on the scaled dot product attention, where $d_{j}$ is the query and encoder outputs $E_{i}$ are the keys:</p>
<p>$$
\begin{gathered}
Q=d_{j} W_{Q} \
K=E W_{K} \
P_{j}=\operatorname{softmax}\left(\frac{Q K^{T}}{\sqrt{b}}\right)
\end{gathered}
$$</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: An example illustrating how the individual modules are trained and subsequently applied as the parts of the pipeline. See $\S 5.2$ for description of the ordering model (ORD), $\S 5.3$ for the aggregation model (AGG), and $\S 5.4$ and $\S 6$ for the paragraph compression model (PC, PC+AGG, PC+ORD+AGG).</p>
<p>Here $W_{Q}$ and $W_{K} \in \mathbb{R}^{b \times b}, b$ is the dimension of BART hidden states, and $P_{j} \in \mathbb{R}^{n+1}$ is the probability distribution for the $j$-th position (i.e., $P_{j i}$ is the probability that fact $f_{i}$ is on the $j$-th position).</p>
<p>We train the model using the synthesized simple sentences in the WIKIFLUENT corpus, randomly shuffling the order of the sentences and training the model to restore their original order.</p>
<h3>5.3 Aggregation Model</h3>
<p>We base our aggregation model (§3.3) on RoBERTa-large (Liu et al., 2019) with a token classification head. ${ }^{6}$ Similarly to the ordering model (§5.2), we input the sequence of (now ordered) facts $F_{o}$ into the model, separating each pair of facts $f_{o_{i}}$ with a special token $\langle/ \mathrm{s}\rangle$ (used by the model as a separator). Subsequently, the token classification layer classifies each separator $\langle/ \mathrm{s}\rangle_{i}$ position into two classes ${0,1}$ corresponding to the delimiter $\delta_{i}$. We ignore the outputs for the nonseparator tokens while computing cross-entropy loss.</p>
<p>We create the training examples using the synthesized sentences in the WiKiFLuent corpus, in which we set $\delta_{i}=0$ for the sentences $i, i+1$ which were originally aggregated (i.e., are the result of splitting a single sentence) and $\delta_{i}=1$ otherwise.</p>
<h3>5.4 Paragraph Compression Model</h3>
<p>We adopt BART-base for our paragraph compression model. We finetune the model on the WiKiFLuent corpus, concatenating the synthesized sentences on the input. We add delimiters between the sentences $i$ and $i+1$ where $\delta_{i}=1$ using a special token <sep>, which we add to the model vocabulary. As shown in Keskar et al. (2019), including control codes for training the model can steer the model towards producing certain outputs. Here we expect that the model will learn to fuse the sentences between which there are no delimiters</p>
<p><sup id="fnref5:0"><a class="footnote-ref" href="#fn:0">1</a></sup>on the input. We evaluate how the model learns to respect the order and aggregation markers in $\S 7.3$.</p>
<h2>6 Experiments</h2>
<p>We train our pipeline modules on the WiKiFLUENT corpus as described in $\S 5$. Next, we use these modules without finetuning for generating descriptions for RDF triples on two English D2T datasets, WebNLG and E2E.</p>
<p>Datasets The datasets differ in domain, size, textual style, and number of predicates (see Appendix A for details):</p>
<ul>
<li>WebNLG (Gardent et al., 2017; Ferreira et al., 2020) contains RDF triples from DBPedia (Auer et al., 2007) and their crowdsourced descriptions. We use version 1.4 of the dataset for comparison to prior work. We hand-crafted templates for all 354 predicates, including unseen predicates in the test set. ${ }^{7}$</li>
<li>E2E (Novikova et al., 2017; Dušek et al., 2020) contains restaurant recommendations in the form of attribute-value pairs. We use the cleaned version of the dataset (Dušek et al., 2019). Following previous work, we transform the attribute-value pairs into RDF triples (using the restaurant name as a subject) and then apply the same setup as for WebNLG. We created a template for each of the 8 attributes manually.</li>
</ul>
<p>Pipeline versions In order to evaluate individual components of our pipeline, we train three versions of the paragraph compression model (see §5.4). The models share the same architecture and targets, but differ in their inputs:</p>
<ul>
<li>PC - the model takes as an input ordered facts with delimiters (as described in §3.4),</li>
<li>PC+AGG - the model takes as an input ordered facts without delimiters (i.e., the aggregation is left implicitly to the model),</li>
<li>PC+ORD+AGG - the model takes as an input facts in random order and without delimiters</li>
</ul>
<p><sup id="fnref:1"><a class="footnote-ref" href="#fn:1">2</a></sup></p>
<p>(i.e., both ordering and aggregation are left implicitly to the model).
Correspondingly, we test three versions of the pipeline in our ablation study (see Figure 3):</p>
<ul>
<li>3-STAGE - a full version of the pipeline consisting of the ordering model (ORD), the aggregation model (AGG) and the PC model (following the full pipeline from §3),</li>
<li>2-STAGE - a pipeline consisting of the ORD model and the PC+AGG model,</li>
<li>1-STAGE - a single stage consisting of the PC+ORD+AGG model.
We evaluate all versions of the pipeline with PC models trained on the full and filtered versions of the WikiFluent dataset (see §4).</li>
</ul>
<h2>7 Evaluation and Discussion</h2>
<p>Our main aim is the evaluation of our pipeline on the downstream task of D2T generation. We evaluate outputs from the ${1,2,3}$-STAGE variants of our pipeline using automatic metrics (§7.1), and we perform a detailed manual error analysis of the model outputs (§7.2). We also evaluate the performance of the content planning modules and the ability of the PC module to follow the content plan (§7.3). In $\S 7.4$, we include an intrinsic evaluation of our modules on the WiKiFluENT test set.</p>
<h3>7.1 Automatic Metrics</h3>
<p>Following prior work, we use BLEU (Papineni et al., 2002) and METEOR (Banerjee and Lavie, 2005) to evaluate the outputs against the human references. ${ }^{8}$ We also evaluate the number of omission and hallucination errors (i.e., facts missing or added, respectively) using a metric from Dušek and Kasner (2020) based on a RoBERTa model (Liu et al., 2019) pretrained on natural language inference (NLI). ${ }^{9}$</p>
<p>We include a diverse set of baselines for comparison. For WebNLG (see Table 3), we compare our systems with the results of:</p>
<ul>
<li>UPF-FORGe and Melbourne - systems (grammar-based and supervised, respectively) from the first run of WebNLG Challenge (Gardent et al., 2017),</li>
<li>Ke et al. (2021) - a state-of-the-art system with</li>
</ul>
<p><sup id="fnref6:0"><a class="footnote-ref" href="#fn:0">1</a></sup>a structure-aware encoder and task-specific pretraining,</p>
<ul>
<li>Laha et al. (2019) - the only other (to our knowledge) zero-shot D2T generation system applied to WebNLG.
For E2E (see Table 4), we compare our systems with the results of:</li>
<li>TGEN (Dušek and Jurčíček, 2015) - the baseline system for the E2E Challenge (Dušek et al., 2020),</li>
<li>Harkous et al. (2020) - a state-of-the-art supervised system on cleaned E2E data.
For both datasets, COPY denotes the baseline of copying the facts without further processing.</li>
</ul>
<p>The automatic evaluation shows that our systems consistently outperform the COPY baseline (e.g., $\sim 12$ BLEU points for E2E), which is already strong thanks to our manually curated set of templates. ${ }^{10}$ Automatic scores also suggest that our systems are comparable with some older supervised systems. Nevertheless, our systems still underperform the state-of-the-art supervised systems. For this reason, we further focus on manual error analysis in $\S 7.2$ to pinpoint the current shortcomings of our approach.</p>
<p>The 2-STAGE system is generally on par with the 3-STAGE system or better, which indicates that explicit aggregation using the AGG model may not be necessary. However, an advantage of having a separate aggregation module is the possibility to control the aggregation step explicitly. The models using the filtered version of the corpus generally produce better results, although they also bring in a larger number of omissions.</p>
<h3>7.2 Manual Error Analysis</h3>
<p>Since automatic performance metrics do not provide insights into specific weaknesses of the system (van Miltenburg et al., 2021), we manually examined 100 outputs of the models. We counted the number of errors: factual (hallucinations, omissions, incorrect fact merging, redundancies) and grammatical. The results are summarized in Table 5.</p>
<p>The 1-STAGE model (which has to order the facts implicitly) tends to repeat the facts in the text (especially in E2E) and produces frequent hallucinations. These problems are largely eliminated with the 2-STAGE and 3-STAGE models, which produce</p>
<p><sup id="fnref2:1"><a class="footnote-ref" href="#fn:1">2</a></sup></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Input</th>
<th style="text-align: left;">(Allen Forrest; background; solo singer), (Allen Forrest; genre; Pop music), (Allen Forrest; birthPlace; <br> Dothan, Alabama)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Templ.</td>
<td style="text-align: left;">Allen Forrest is a solo singer. Allen Forrest performs Pop music. Allen Forrest was born in Dothan, <br> Alabama.</td>
</tr>
<tr>
<td style="text-align: left;">Model</td>
<td style="text-align: left;">Allen Forrest is a solo singer who performs Pop music. He was born in Dothan, Alabama.</td>
</tr>
<tr>
<td style="text-align: left;">Human</td>
<td style="text-align: left;">Born in Dothan, Alabama, Allen Forrest has a background as a solo singer and was a pop artist.</td>
</tr>
<tr>
<td style="text-align: left;">Input</td>
<td style="text-align: left;">name[Wildwood], eatType[restaurant], food[French], area[riverside], near[Raja Indian Cuisine]</td>
</tr>
<tr>
<td style="text-align: left;">Templ.</td>
<td style="text-align: left;">Wildwood is a restaurant. Wildwood serves French food. Wildwood is in the riverside. Wildwood is <br> near Raja Indian Cuisine.</td>
</tr>
<tr>
<td style="text-align: left;">Model</td>
<td style="text-align: left;">Wildwood is a restaurant serving French food. It is in the riverside near Raja Indian Cuisine.</td>
</tr>
<tr>
<td style="text-align: left;">Human</td>
<td style="text-align: left;">A amazing French restaurant is called the Wildwood. The restaurant is near the Raja Indian Cuisine in <br> riverside. They love kids.</td>
</tr>
</tbody>
</table>
<p>Table 2: Example outputs of our model (3-STAGE, filtered). See Appendix E for more examples.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
<th style="text-align: left;">B</th>
<th style="text-align: left;">M</th>
<th style="text-align: left;">O</th>
<th style="text-align: left;">H</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">UPF-FORGe*</td>
<td style="text-align: left;">38.65</td>
<td style="text-align: left;">39.00</td>
<td style="text-align: left;">0.075</td>
<td style="text-align: left;">0.101</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">Melbourne*</td>
<td style="text-align: left;">45.13</td>
<td style="text-align: left;">37.00</td>
<td style="text-align: left;">0.237</td>
<td style="text-align: left;">0.202</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">Ke et al. $(2021)^{\dagger *}$</td>
<td style="text-align: left;">66.14</td>
<td style="text-align: left;">47.25</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">Laha et al. $(2019)^{\dagger}$</td>
<td style="text-align: left;">24.80</td>
<td style="text-align: left;">34.90</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">COPY</td>
<td style="text-align: left;">37.18</td>
<td style="text-align: left;">38.77</td>
<td style="text-align: left;">0.000</td>
<td style="text-align: left;">0.000</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">3-STAGE</td>
<td style="text-align: left;">42.92</td>
<td style="text-align: left;">39.07</td>
<td style="text-align: left;">0.051</td>
<td style="text-align: left;">0.148</td>
</tr>
<tr>
<td style="text-align: left;">full</td>
<td style="text-align: left;">2-STAGE</td>
<td style="text-align: left;">42.90</td>
<td style="text-align: left;">39.28</td>
<td style="text-align: left;">$\mathbf{0 . 0 4 3}$</td>
<td style="text-align: left;">0.125</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">1-STAGE</td>
<td style="text-align: left;">39.08</td>
<td style="text-align: left;">38.94</td>
<td style="text-align: left;">0.071</td>
<td style="text-align: left;">0.204</td>
</tr>
<tr>
<td style="text-align: left;">filtered</td>
<td style="text-align: left;">3-STAGE</td>
<td style="text-align: left;">43.19</td>
<td style="text-align: left;">39.13</td>
<td style="text-align: left;">0.152</td>
<td style="text-align: left;">$\mathbf{0 . 0 7 3}$</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">2-STAGE</td>
<td style="text-align: left;">$\mathbf{4 3 . 4 9}$</td>
<td style="text-align: left;">$\mathbf{3 9 . 3 2}$</td>
<td style="text-align: left;">0.146</td>
<td style="text-align: left;">0.096</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">1-STAGE</td>
<td style="text-align: left;">42.99</td>
<td style="text-align: left;">38.81</td>
<td style="text-align: left;">0.202</td>
<td style="text-align: left;">0.093</td>
</tr>
</tbody>
</table>
<p>Table 3: Automatic metrics on WebNLG. B = BLEU, M $=$ METEOR, $\mathrm{O}=$ omissions / # facts, $\mathrm{H}=$ hallucinations / # examples. The systems marked with asterisk (*) are trained on the WebNLG dataset. Results for the systems marked with $\dagger$ are taken from the respective works.
almost no hallucinations or omissions. However, the outputs on WebNLG for all systems suffer from semantic errors resulting from merging of unrelated facts. This mostly happens with unrelated predicates connected to the same subject/object (e.g. "X was born in Y", "X worked as Z" expressed as "X worked as Z in Y"; see Appendix E for examples). This behavior is the main obstacle to ensure factual consistency of the output. As a possible remedy, we propose explicitly controlling the semantics of sentence fusion (Ben-David et al., 2020), e.g. using a variant of constrained decoding (Balakrishnan et al., 2019; Wang et al., 2021).</p>
<p>On the E2E data, which has a simpler triple structure (all predicates share the same subject), the outputs are generally consistent and the 2-STAGE and 3-STAGE models exhibit almost no semantic errors. Grammar errors and disfluencies stem mainly from over-eager paragraph compression or from artifacts in our templates and are relatively minor (e.g., missing "is" in "serves French food and</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
<th style="text-align: left;">B</th>
<th style="text-align: left;">M</th>
<th style="text-align: left;">O</th>
<th style="text-align: left;">H</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">TGEN*</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">40.73</td>
<td style="text-align: left;">37.76</td>
<td style="text-align: left;">0.016</td>
<td style="text-align: left;">0.083</td>
</tr>
<tr>
<td style="text-align: left;">Harkous et al. (2020)*</td>
<td style="text-align: left;">43.60</td>
<td style="text-align: left;">39.00</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">COPY</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">24.19</td>
<td style="text-align: left;">34.89</td>
<td style="text-align: left;">0.000</td>
<td style="text-align: left;">0.000</td>
</tr>
<tr>
<td style="text-align: left;">full</td>
<td style="text-align: left;">3-STAGE</td>
<td style="text-align: left;">$\mathbf{3 6 . 0 4}$</td>
<td style="text-align: left;">36.95</td>
<td style="text-align: left;">$\mathbf{0 . 0 0 1}$</td>
<td style="text-align: left;">$\mathbf{0 . 0 0 1}$</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">2-STAGE</td>
<td style="text-align: left;">35.84</td>
<td style="text-align: left;">36.91</td>
<td style="text-align: left;">$\mathbf{0 . 0 0 1}$</td>
<td style="text-align: left;">$\mathbf{0 . 0 0 1}$</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">1-STAGE</td>
<td style="text-align: left;">30.81</td>
<td style="text-align: left;">36.01</td>
<td style="text-align: left;">0.009</td>
<td style="text-align: left;">0.122</td>
</tr>
<tr>
<td style="text-align: left;">filtered</td>
<td style="text-align: left;">3-STAGE</td>
<td style="text-align: left;">35.88</td>
<td style="text-align: left;">36.95</td>
<td style="text-align: left;">$\mathbf{0 . 0 0 1}$</td>
<td style="text-align: left;">$\mathbf{0 . 0 0 1}$</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">2-STAGE</td>
<td style="text-align: left;">36.01</td>
<td style="text-align: left;">$\mathbf{3 6 . 9 9}$</td>
<td style="text-align: left;">$\mathbf{0 . 0 0 1}$</td>
<td style="text-align: left;">$\mathbf{0 . 0 0 1}$</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">1-STAGE</td>
<td style="text-align: left;">34.08</td>
<td style="text-align: left;">36.32</td>
<td style="text-align: left;">0.012</td>
<td style="text-align: left;">0.050</td>
</tr>
</tbody>
</table>
<p>Table 4: Automatic metrics on E2E. B = BLEU, M = METEOR, $\mathrm{O}=$ omissions / # facts, $\mathrm{H}=$ hallucinations / # examples. The systems marked with asterisk (*) are trained on the E2E dataset. The results for Harkous et al. (2020) are taken from their work.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">WebNLG</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">E2E</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">H</td>
<td style="text-align: center;">I</td>
<td style="text-align: center;">O</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">G</td>
<td style="text-align: center;">H</td>
<td style="text-align: center;">I</td>
<td style="text-align: center;">O</td>
<td style="text-align: center;">R</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">3-STAGE</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">39</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">16</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">2-STAGE</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">36</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">16</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">1-STAGE</td>
<td style="text-align: center;">28</td>
<td style="text-align: center;">27</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">20</td>
<td style="text-align: center;">17</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">79</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">3-STAGE</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">37</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">15</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">2-STAGE</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">32</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">14</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">1-STAGE</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">40</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">16</td>
<td style="text-align: center;">11</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">41</td>
</tr>
</tbody>
</table>
<p>Table 5: Number of manually annotated errors on 100 examples: $\mathrm{H}=$ hallucinations, $\mathrm{I}=$ incorrect fact merging, $\mathrm{O}=$ omissions, $\mathrm{R}=$ redundancies, $\mathrm{G}=$ grammar errors or disfluencies.
family-friendly").</p>
<h3>7.3 Content Planning</h3>
<p>Following Su et al. (2021b) and Zhao et al. (2020), we report the accuracy and BLEU-2 score of our ordering model on WebNLG against the humangenerated plans from Ferreira et al. (2018). The results are listed in Table 6 and compared against a RANDOM baseline (random ordering) and prior work. The results show that although our approach again lags behind state-of-the-art supervised ap-</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;">B-2</th>
<th style="text-align: left;">Acc</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Transformer (Ferreira et al., 2019) ${ }^{\dagger}$</td>
<td style="text-align: left;">52.20</td>
<td style="text-align: left;">0.35</td>
</tr>
<tr>
<td style="text-align: left;">Step-by-step (Moryossef et al., 2019b) ${ }^{\dagger}$</td>
<td style="text-align: left;">70.80</td>
<td style="text-align: left;">0.47</td>
</tr>
<tr>
<td style="text-align: left;">PLANENC (Zhao et al., 2020) ${ }^{\dagger}$</td>
<td style="text-align: left;">80.10</td>
<td style="text-align: left;">0.62</td>
</tr>
<tr>
<td style="text-align: left;">Plan-then-generate (Su et al., 2021b) ${ }^{\dagger}$</td>
<td style="text-align: left;">84.97</td>
<td style="text-align: left;">0.72</td>
</tr>
<tr>
<td style="text-align: left;">RANDOM</td>
<td style="text-align: left;">47.00</td>
<td style="text-align: left;">0.29</td>
</tr>
<tr>
<td style="text-align: left;">Ours (BART+ptr)</td>
<td style="text-align: left;">59.10</td>
<td style="text-align: left;">0.48</td>
</tr>
</tbody>
</table>
<p>Table 6: Evaluation of our zero-shot ordering model based on Calizzano et al. (2021). B-2 = BLEU-2, Acc $=$ accuracy. The results marked with $\dagger$ are copied from the respective papers.
proaches, it can outperform both the random baseline and the Transformer-based approach from Ferreira et al. (2019) while not using any in-domain examples.</p>
<p>We also evaluate the accuracy of our aggregation model, using triples ordered according to the plans from Ferreira et al. (2018) as input. The accuracy is 0.33 per example and 0.62 per sentence boundary (random baseline is 0.23 and 0.50 , respectively). The results show that although our approach is better than the random baseline, there is still room for improvement.</p>
<p>Finally, we manually evaluate how the PC model follows the content plan (i.e., keeping the predefined order and aggregating the sentences according to the delimiters) using 100 randomly chosen examples with more than 1 triple on WebNLG and E2E. We find that the model follows the content plan in $95 \%$ and $100 \%$ of cases, respectively. The incorrect cases include a fact not properly mentioned or an extra boundary between sentences without a separator. We can thus conclude that the pretraining task successfully teaches the PC model to follow a given content plan.</p>
<h3>7.4 Intrinsic Evaluation</h3>
<p>Aside from the main D2T generation results, we also provide an intrinsic evaluation of our pipeline modules on the WIKIFluENT test sets. We evaluated the ordering, aggregation, and paragraph compression modules trained on the full WIKIFluENT corpus. The results for both full and filtered test sets are summarized in Table 7. The PC model achieves high scores, which follows from the fact that we provide it with ground truth content plans (i.e., the ordering and aggregation plan corresponding to the original paragraph). Accuracy of the ordering and aggregation modules is comparable to their performance on D2T datasets.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">test (full)</th>
<th style="text-align: center;">test (filt.)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">ORD</td>
<td style="text-align: center;">BLEU-2</td>
<td style="text-align: center;">64.8</td>
<td style="text-align: center;">71.9</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Accuracy</td>
<td style="text-align: center;">0.70</td>
<td style="text-align: center;">0.77</td>
</tr>
<tr>
<td style="text-align: center;">AGG</td>
<td style="text-align: center;">Acc. per example</td>
<td style="text-align: center;">0.68</td>
<td style="text-align: center;">0.68</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Acc. per sent. bound.</td>
<td style="text-align: center;">0.93</td>
<td style="text-align: center;">0.93</td>
</tr>
<tr>
<td style="text-align: center;">PC</td>
<td style="text-align: center;">BLEU</td>
<td style="text-align: center;">90.72</td>
<td style="text-align: center;">91.60</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">METEOR</td>
<td style="text-align: center;">63.89</td>
<td style="text-align: center;">65.03</td>
</tr>
</tbody>
</table>
<p>Table 7: Result of individual pipeline modules on the WIKIFluENT test sets (full / filtered). The metrics correspond to the metrics used for evaluating the modules for D2T generation.</p>
<h2>8 Future Work</h2>
<p>Our experiments outline several possible future research directions. Automatic generation of facts without using hand-crafted templates (cf. §5.1) could allow applying zero-shot generation systems to datasets with a large number of predicates, such as ToTTo (Parikh et al., 2020). The task of paragraph compression could be used as a task-specific pretraining (Gururangan et al., 2020) for more efficient finetuning of D2T models, e.g., with a small amount of clean data. Consistency checks may be introduced in the pipeline to control the output from the modules, and individual modules may be improved by using more efficient model architectures.</p>
<p>More research is also needed regarding the main shortcoming of our approach, i.e., the semantic errors stemming from merging of facts in improper ways. As we suggested in $\S 7.2$, explicitly controlling the semantics of sentence fusion could help to mitigate this issue, while still keeping the advantages of a zero-shot approach.</p>
<h2>9 Conclusion</h2>
<p>We presented an approach for zero-shot D2T generation. The approach uses a pipeline of PLMs trained on general-domain lexical operations over natural language. The pipeline builds upon traditional approaches and consists of three interpretable intermediate steps. By avoiding noisy human-written references from the D2T datasets, our models produce more semantically consitent output. We believe that training models for zeroshot D2T generation using large cross-domain corpora will help to build D2T generation systems with good performance across various domains.</p>
<h2>10 Limitations and Broader Impact</h2>
<p>We study zero-shot D2T generation with the focus on generating descriptions for RDF triples. Although the task of D2T generation has numerous applications, using neural models for D2T generation (especially in the zero-shot context) is still limited to experimental settings (Dale, 2020). Similarly to other recent approaches for D2T generation, our approach relies on PLMs, which are known to reflect the biases in their pretraining corpus (Bender et al., 2021; Rogers, 2021). Our system may therefore rely on spurious correlations for verbalizing e.g. gender or occupation of the entities. Since we cannot guarantee the factual correctness of the outputs of our system, the outputs should be used with caution.</p>
<p>On the flip side, our approach helps to reduce the number of omissions and hallucinations stemming from noise in human-written references. Our work thus contributes to the general aim of D2T generation in conveying the data semantics accurately and without relying on implicit world knowledge.</p>
<h2>Acknowledgements</h2>
<p>This research was supported by Charles University projects GAUK 140320, SVV 260575 and PRIMUS/19/SCI/10, an Apple NLU Research Grant for Heriot-Watt University and Charles University, and by the European Research Council (Grant agreement No. 101039303 NG-NLG). It used resources provided by the LINDAT/CLARIAH-CZ Research Infrastructure (Czech Ministry of Education, Youth and Sports project No. LM2018101).</p>
<h2>References</h2>
<p>Oshin Agarwal, Heming Ge, Siamak Shakeri, and Rami Al-Rfou. 2021. Knowledge Graph Based Synthetic Corpus Generation for Knowledge-Enhanced Language Model Pre-training. In Proceedings of the 2021 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, NAACL-HLT 2021, pages 3554-3565, Online.</p>
<p>Giusepppe Attardi. 2015. WikiExtractor. https:// github.com/attardi/wikiextractor.</p>
<p>Sören Auer, Christian Bizer, Georgi Kobilarov, Jens Lehmann, Richard Cyganiak, and Zachary G. Ives. 2007. DBpedia: A Nucleus for a Web of Open Data. In The Semantic Web, 6th International Semantic Web Conference, 2nd Asian Semantic Web Conference,</p>
<p>ISWC 2007 + ASWC 2007, volume 4825 of Lecture Notes in Computer Science, pages 722-735, Busan, Korea.</p>
<p>Anusha Balakrishnan, Jinfeng Rao, Kartikeya Upasani, Michael White, and Rajen Subba. 2019. Constrained Decoding for Neural NLG from Compositional Representations in Task-Oriented Dialogue. In Proceedings of the 57th Conference of the Association for Computational Linguistics, ACL 2019, Volume 1: Long Papers, pages 831-844, Florence, Italy.</p>
<p>Satanjeev Banerjee and Alon Lavie. 2005. METEOR: An Automatic Metric for MT Evaluation with Improved Correlation with Human Judgments. In Proceedings of the Workshop on Intrinsic and Extrinsic Evaluation Measures for Machine Translation and/or Summarization@ACL 2005, pages 65-72, Ann Arbor, MI, USA.</p>
<p>Regina Barzilay, Noémie Elhadad, and Kathleen R. McKeown. 2001. Sentence Ordering in Multidocument Summarization. In Proceedings of the First International Conference on Human Language Technology Research, HLT 2001, San Diego, CA, USA.</p>
<p>Regina Barzilay and Kathleen R. McKeown. 2005. Sentence Fusion for Multidocument News Summarization. Comput. Linguistics, 31(3):297-328.</p>
<p>Eyal Ben-David, Orgad Keller, Eric Malmi, Idan Szpektor, and Roi Reichart. 2020. Semantically Driven Sentence Fusion: Modeling and Evaluation. In Findings of the Association for Computational Linguistics: EMNLP 2020, Findings of ACL, pages 1491-1505, Online.</p>
<p>Emily M. Bender, Timnit Gebru, Angelina McMillanMajor, and Shmargaret Shmitchell. 2021. On the Dangers of Stochastic Parrots: Can Language Models Be Too Big? In FAccT '21: 2021 ACM Conference on Fairness, Accountability, and Transparency, pages 610-623, Online/Toronto, Canada.</p>
<p>Steven Bird. 2006. NLTK: The Natural Language Toolkit. In ACL 2006, 21st International Conference on Computational Linguistics and 44th Annual Meeting of the Association for Computational Linguistics, Proceedings of the Conference, Sydney, Australia.</p>
<p>Jan A. Botha, Manaal Faruqui, John Alex, Jason Baldridge, and Dipanjan Das. 2018. Learning to Split and Rephrase From Wikipedia Edit History. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 732737, Brussels, Belgium.</p>
<p>Rémi Calizzano, Malte Ostendorff, and Georg Rehm. 2021. Ordering sentences and paragraphs with pretrained encoder-decoder transformers and pointer ensembles. In DocEng '21: ACM Symposium on Document Engineering 2021, pages 10:1-10:9, Limerick, Ireland.</p>
<p>Ernie Chang, Xiaoyu Shen, Hui-Syuan Yeh, and Vera Demberg. 2021a. On Training Instance Selection for Few-Shot Neural Text Generation. In Proceedings of the 59th Annual Meeting of the Association for Computational Linguistics and the 11th International Joint Conference on Natural Language Processing, ACL/IJCNLP 2021, (Volume 2: Short Papers), pages $8-13$, Online.</p>
<p>Ernie Chang, Xiaoyu Shen, Dawei Zhu, Vera Demberg, and Hui Su. 2021b. Neural Data-to-Text Generation with LM-based Text Augmentation. In Proceedings of the 16th Conference of the European Chapter of the Association for Computational Linguistics: Main Volume, EACL 2021, pages 758-768, Online.</p>
<p>Wenhu Chen, Yu Su, Xifeng Yan, and William Yang Wang. 2020a. KGPT: Knowledge-Grounded PreTraining for Data-to-Text Generation. In Proceedings of the 2020 Conference on Empirical Methods in Natural Language Processing, EMNLP 2020, pages 8635-8648, Online.</p>
<p>Xinchi Chen, Xipeng Qiu, and Xuanjing Huang. 2016. Neural Sentence Ordering. CoRR, abs/1607.06952.</p>
<p>Zhiyu Chen, Harini Eavani, Wenhu Chen, Yinyin Liu, and William Yang Wang. 2020b. Few-Shot NLG with Pre-Trained Language Model. In Proceedings of the 58th Annual Meeting of the Association for Computational Linguistics, ACL 2020, pages 183190, Online.</p>
<p>Baiyun Cui, Yingming Li, and Zhongfei Zhang. 2020. BERT-enhanced Relational Sentence Ordering Network. In Proceedings of the 2020 Conference on Empirical Methods in Natural Language Processing, EMNLP 2020, pages 6310-6320, Online.</p>
<p>Robert Dale. 2020. Natural language generation: The commercial state of the art in 2020. Nat. Lang. Eng., 26(4):481-487.</p>
<p>Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2019. BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding. In Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, NAACL-HLT 2019, Volume 1 (Long and Short Papers), pages 4171-4186, Minneapolis, MN, USA.</p>
<p>Ondřej Dušek, David M. Howcroft, and Verena Rieser. 2019. Semantic Noise Matters for Neural Natural Language Generation. In Proceedings of the 12th International Conference on Natural Language Generation, INLG 2019, pages 421-426, Tokyo, Japan.</p>
<p>Ondřej Dušek and Filip Jurčíček. 2015. Training a Natural Language Generator From Unaligned Data. In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing of the Asian Federation of Natural</p>
<p>Language Processing, ACL 2015, Volume 1: Long Papers, pages 451-461, Beijing, China.</p>
<p>Ondřej Dušek and Zdeněk Kasner. 2020. Evaluating Semantic Accuracy of Data-to-Text Generation with Natural Language Inference. In Proceedings of the 13th International Conference on Natural Language Generation, INLG 2020, pages 131-137, Dublin, Ireland.</p>
<p>Ondřej Dušek, Jekaterina Novikova, and Verena Rieser. 2020. Evaluating the state-of-the-art of End-to-End Natural Language Generation: The E2E NLG challenge. Comput. Speech Lang., 59:123-156.</p>
<p>William Falcon et al. 2019. Pytorch Lightning. https://github.com/PyTorchLightning/ pytorch-lightning.</p>
<p>Thiago Ferreira, Claire Gardent, Nikolai Ilinykh, Chris van der Lee, Simon Mille, Diego Moussallem, and Anastasia Shimorina. 2020. The 2020 Bilingual, BiDirectional WebNLG+ Shared Task Overview and Evaluation Results (WebNLG+ 2020). In Proceedings of the 3rd International Workshop on Natural Language Generation from the Semantic Web (WebNLG+).</p>
<p>Thiago Castro Ferreira, Diego Moussallem, Emiel Krahmer, and Sander Wubben. 2018. Enriching the WebNLG corpus. In Proceedings of the 11th International Conference on Natural Language Generation, pages 171-176, Tilburg, The Netherlands.</p>
<p>Thiago Castro Ferreira, Chris van der Lee, Emiel van Miltenburg, and Emiel Krahmer. 2019. Neural data-to-text generation: A comparison between pipeline and end-to-end architectures. In Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing and the 9th International Joint Conference on Natural Language Processing, EMNLP-IJCNLP 2019, pages 552-562, Hong Kong.</p>
<p>Katja Filippova and Yasemin Altun. 2013. Overcoming the Lack of Parallel Data in Sentence Compression. In Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing, pages 1481-1491, Seattle, WA, USA.</p>
<p>Claire Gardent, Anastasia Shimorina, Shashi Narayan, and Laura Perez-Beltrachini. 2017. The WebNLG Challenge: Generating Text from RDF Data. In Proceedings of the 10th International Conference on Natural Language Generation, INLG 2017, pages 124-133, Santiago de Compostela, Spain.</p>
<p>Matt Gardner, Joel Grus, Mark Neumann, Oyvind Tafjord, Pradeep Dasigi, Nelson F. Liu, Matthew E. Peters, Michael Schmitz, and Luke Zettlemoyer. 2018. AllenNLP: A Deep Semantic Natural Language Processing Platform. CoRR, abs/1803.07640.</p>
<p>Albert Gatt and Emiel Krahmer. 2018. Survey of the State of the Art in Natural Language Generation: Core tasks, applications and evaluation. J. Artif. Intell. Res., 61:65-170.</p>
<p>Mor Geva, Eric Malmi, Idan Szpektor, and Jonathan Berant. 2019. DiscoFuse: A Large-Scale Dataset for Discourse-Based Sentence Fusion. In Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, NAACL-HLT 2019, Volume 1 (Long and Short Papers), pages 3443-3455, Minneapolis, MN, USA.</p>
<p>Jingjing Gong, Xinchi Chen, Xipeng Qiu, and Xuanjing Huang. 2016. End-to-End Neural Sentence Ordering Using Pointer Network. CoRR, abs/1611.04953.</p>
<p>Suchin Gururangan, Ana Marasović, Swabha Swayamdipta, Kyle Lo, Iz Beltagy, Doug Downey, and Noah A Smith. 2020. Don't Stop Pretraining: Adapt Language Models to Domains and Tasks. In Proceedings of the 58th Annual Meeting of the Association for Computational Linguistics, pages $8342-8360$.</p>
<p>Hamza Harkous, Isabel Groves, and Amir Saffari. 2020. Have Your Text and Use It Too! End-to-End Neural Data-to-Text Generation with Semantic Fidelity. In Proceedings of the 28th International Conference on Computational Linguistics, COLING 2020, pages 2410-2424, Barcelona, Spain (Online).</p>
<p>Peyman Heidari, Arash Einolghozati, Shashank Jain, Soumya Batra, Lee Callender, Ankit Arun, Shawn Mei, Sonal Gupta, Pinar Donmez, Vikas Bhardwaj, Anuj Kumar, and Michael White. 2021. Getting to Production with Few-shot Natural Language Generation Models. In Proceedings of the 22nd Annual Meeting of the Special Interest Group on Discourse and Dialogue, SIGdial 2021, pages 66-76, Singapore/Online.</p>
<p>Chao Jiang, Mounica Maddela, Wuwei Lan, Yang Zhong, and Wei Xu. 2020. Neural CRF Model for Sentence Alignment in Text Simplification. In Proceedings of the 58th Annual Meeting of the Association for Computational Linguistics, ACL 2020, pages 7943-7960, Online.</p>
<p>Zhijing Jin, Qipeng Guo, Xipeng Qiu, and Zheng Zhang. 2020. GenWiki: A Dataset of 1.3 Million ContentSharing Text and Graphs for Unsupervised Graph-toText Generation. In Proceedings of the 28th International Conference on Computational Linguistics, COLING 2020, pages 2398-2409, Barcelona, Spain (Online).</p>
<p>Mihir Kale and Abhinav Rastogi. 2020a. Template Guided Text Generation for Task-Oriented Dialogue. In Proceedings of the 2020 Conference on Empirical Methods in Natural Language Processing, EMNLP 2020, pages 6505-6520, Online.</p>
<p>Mihir Kale and Abhinav Rastogi. 2020b. Text-to-Text Pre-Training for Data-to-Text Tasks. In Proceedings of the 13th International Conference on Natural Language Generation, INLG 2020, pages 97-102, Dublin, Ireland.</p>
<p>Zdeněk Kasner and Ondřej Dušek. 2020a. Data-to-Text Generation with Iterative Text Editing. In Proceedings of the 13th International Conference on Natural Language Generation, INLG 2020, pages 60-67, Dublin, Ireland.</p>
<p>Zdeněk Kasner and Ondřej Dušek. 2020b. Train Hard, Finetune Easy: Multilingual Denoising for RDF-toText Generation. In Proceedings of the 3rd International Workshop on Natural Language Generation from the Semantic Web (WebNLG+), pages 171-176, Online.</p>
<p>Pei Ke, Haozhe Ji, Yu Ran, Xin Cui, Liwei Wang, Linfeng Song, Xiaoyan Zhu, and Minlie Huang. 2021. JointGT: Graph-Text Joint Representation Learning for Text Generation from Knowledge Graphs. In Findings of the Association for Computational Linguistics: ACL/IJCNLP 2021, volume ACL/IJCNLP 2021 of Findings of ACL, pages 2526-2538, Online.</p>
<p>Nitish Shirish Keskar, Bryan McCann, Lav R. Varshney, Caiming Xiong, and Richard Socher. 2019. CTRL: A Conditional Transformer Language Model for Controllable Generation. CoRR, abs/1909.05858.</p>
<p>Diederik P. Kingma and Jimmy Ba. 2015. Adam: A Method for Stochastic Optimization. In 3rd International Conference on Learning Representations, ICLR 2015, San Diego, CA, USA.</p>
<p>Anirban Laha, Parag Jain, Abhijit Mishra, and Karthik Sankaranarayanan. 2019. Scalable Micro-planned Generation of Discourse from Structured Data. Comput. Linguistics, 45(4):737-763.</p>
<p>Mirella Lapata. 2003. Probabilistic Text Structuring: Experiments with Sentence Ordering. In Proceedings of the 41st Annual Meeting of the Association for Computational Linguistics, pages 545-552, Sapporo, Japan.</p>
<p>Kenton Lee, Luheng He, and Luke Zettlemoyer. 2018. Higher-Order Coreference Resolution with Coarse-to-Fine Inference. In Proceedings of the 2018 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, NAACL-HLT, Volume 2 (Short Papers), pages 687-692, New Orleans, LA, USA.</p>
<p>Mike Lewis, Yinhan Liu, Naman Goyal, Marjan Ghazvininejad, Abdelrahman Mohamed, Omer Levy, Veselin Stoyanov, and Luke Zettlemoyer. 2020. BART: Denoising Sequence-to-Sequence Pretraining for Natural Language Generation, Translation, and Comprehension. In Proceedings of the 58th Annual Meeting of the Association for Computational Linguistics, ACL 2020, pages 7871-7880, Online.</p>
<p>Jiwei Li and Dan Jurafsky. 2017. Neural Net Models of Open-domain Discourse Coherence. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, EMNLP 2017, pages 198-209, Copenhagen, Denmark.</p>
<p>Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Danqi Chen, Omer Levy, Mike Lewis, Luke Zettlemoyer, and Veselin Stoyanov. 2019. RoBERTa: A Robustly Optimized BERT Pretraining Approach. CoRR, abs/1907.11692.</p>
<p>Sanket Vaibhav Mehta, Jinfeng Rao, Yi Tay, Mihir Kale, Ankur Parikh, Hongtao Zhong, and Emma Strubell. 2021. Improving Compositional Generalization with Self-Training for Data-to-Text Generation. CoRR, abs/2110.08467.</p>
<p>Amit Moryossef, Yoav Goldberg, and Ido Dagan. 2019a. Improving Quality and Efficiency in Plan-based Neural Data-to-text Generation. In Proceedings of the 12th International Conference on Natural Language Generation, INLG 2019, pages 377-382, Tokyo, Japan.</p>
<p>Amit Moryossef, Yoav Goldberg, and Ido Dagan. 2019b. Step-by-Step: Separating Planning from Realization in Neural Data-to-Text Generation. In Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, NAACL-HLT 2019, Volume 1 (Long and Short Papers), pages 2267-2277, Minneapolis, MN, USA.</p>
<p>Shashi Narayan, Claire Gardent, Shay B. Cohen, and Anastasia Shimorina. 2017. Split and Rephrase. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, EMNLP 2017, pages 606-616, Copenhagen, Denmark.</p>
<p>Jekaterina Novikova, Ondřej Dušek, and Verena Rieser. 2017. The E2E Dataset: New Challenges For End-toEnd Generation. In Proceedings of the 18th Annual SIGdial Meeting on Discourse and Dialogue, pages 201-206, Saarbrücken, Germany.</p>
<p>Kishore Papineni, Salim Roukos, Todd Ward, and WeiJing Zhu. 2002. Bleu: a Method for Automatic Evaluation of Machine Translation. In Proceedings of the 40th Annual Meeting of the Association for Computational Linguistics, July 6-12, 2002, Philadelphia, PA, USA, pages 311-318.</p>
<p>Ankur P. Parikh, Xuezhi Wang, Sebastian Gehrmann, Manaal Faruqui, Bhuwan Dhingra, Diyi Yang, and Dipanjan Das. 2020. ToTTo: A Controlled Table-To-Text Generation Dataset. In Proceedings of the 2020 Conference on Empirical Methods in Natural Language Processing, EMNLP 2020, pages 11731186, Online.</p>
<p>Adam Paszke, Sam Gross, Francisco Massa, Adam Lerer, James Bradbury, Gregory Chanan, Trevor Killeen, Zeming Lin, Natalia Gimelshein, Luca Antiga, Alban Desmaison, Andreas Köpf, Edward Z. Yang, Zachary DeVito, Martin Raison, Alykhan Tejani, Sasank Chilamkurthy, Benoit Steiner, Lu Fang, Junjie Bai, and Soumith Chintala. 2019. PyTorch: An Imperative Style, High-Performance Deep Learning Library. In Advances in Neural Information Processing Systems 32: Annual Conference on Neural</p>
<p>Information Processing Systems 2019, NeurIPS 2019, pages 8024-8035, Vancouver, BC, Canada.</p>
<p>Ratish Puduppully, Li Dong, and Mirella Lapata. 2019. Data-to-Text Generation with Content Selection and Planning. In The Thirty-Third AAAI Conference on Artificial Intelligence, AAAI 2019, The Thirty-First Innovative Applications of Artificial Intelligence Conference, IAAI 2019, The Ninth AAAI Symposium on Educational Advances in Artificial Intelligence, EAAI 2019, pages 6908-6915, Honolulu, HI, USA.</p>
<p>Clément Rebuffel, Marco Roberti, Laure Soulier, Geoffrey Scoutheeten, Rossella Cancelliere, and Patrick Gallinari. 2022. Controlling hallucinations at word level in data-to-text generation. Data Min. Knowl. Discov., 36(1):318-354.</p>
<p>Ehud Reiter. 2007. An Architecture for Data-to-Text Systems. In Proceedings of the Eleventh European Workshop on Natural Language Generation, ENLG 2007, Schloss Dagstuhl, Germany.</p>
<p>Ehud Reiter and Robert Dale. 1997. Building applied natural language generation systems. Nat. Lang. Eng., 3(1):57-87.</p>
<p>Leonardo F. R. Ribeiro, Martin Schmitt, Hinrich Schütze, and Iryna Gurevych. 2020. Investigating Pretrained Language Models for Graph-to-Text Generation. CoRR, abs/2007.08426.</p>
<p>Anna Rogers. 2021. Changing the World by Changing the Data. In Proceedings of the 59th Annual Meeting of the Association for Computational Linguistics and the 11th International Joint Conference on Natural Language Processing, ACL/IJCNLP 2021, (Volume 1: Long Papers), pages 2182-2194, Online.</p>
<p>Zhihong Shao, Minlie Huang, Jiangtao Wen, Wenfei Xu, and Xiaoyan Zhu. 2019. Long and Diverse Text Generation with Planning-based Hierarchical Variational Model. In Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing and the 9th International Joint Conference on Natural Language Processing, EMNLP-IJCNLP 2019, pages 3255-3266, Hong Kong.</p>
<p>Xiaoyu Shen, Ernie Chang, Hui Su, Cheng Niu, and Dietrich Klakow. 2020. Neural Data-to-Text Generation via Jointly Learning the Segmentation and Correspondence. In Proceedings of the 58th Annual Meeting of the Association for Computational Linguistics, ACL 2020, pages 7155-7165, Online.</p>
<p>Yixuan Su, Zaiqiao Meng, Simon Baker, and Nigel Collier. 2021a. Few-Shot Table-to-Text Generation with Prototype Memory. In Findings of the Association for Computational Linguistics: EMNLP 2021, pages 910-917, Online/Punta Cana, Dominican Republic.</p>
<p>Yixuan Su, David Vandyke, Sihui Wang, Yimai Fang, and Nigel Collier. 2021b. Plan-then-Generate: Controlled Data-to-Text Generation via Planning. In Findings of the Association for Computational Linguistics: EMNLP 2021, pages 895-909, Online/Punta Cana, Dominican Republic.</p>
<p>Bayu Distiawan Trisedya, Jianzhong Qi, and Rui Zhang. 2020. Sentence Generation for Entity Description with Content-Plan Attention. In The Thirty-Fourth AAAI Conference on Artificial Intelligence, AAAI 2020, The Thirty-Second Innovative Applications of Artificial Intelligence Conference, IAAI 2020, The Tenth AAAI Symposium on Educational Advances in Artificial Intelligence, EAAI 2020, pages 9057-9064, New York, NY, USA.</p>
<p>Emiel van Miltenburg, Miruna-Adriana Clinciu, Ondřej Dušek, Dimitra Gkatzia, Stephanie Inglis, Leo Leppänen, Saad Mahamood, Emma Manning, Stephanie Schoch, Craig Thomson, and Luou Wen. 2021. Underreporting of errors in NLG output, and what to do about it. In Proceedings of the 14th International Conference on Natural Language Generation, INLG 2021, pages 140-153, Aberdeen, Scotland, UK.</p>
<p>Oriol Vinyals, Meire Fortunato, and Navdeep Jaitly. 2015. Pointer networks. In Advances in Neural Information Processing Systems 28: Annual Conference on Neural Information Processing Systems 2015, pages 2692-2700, Montréal, QC, Canada.</p>
<p>Tianming Wang and Xiaojun Wan. 2019. Hierarchical Attention Networks for Sentence Ordering. In The Thirty-Third AAAI Conference on Artificial Intelligence, AAAI 2019, The Thirty-First Innovative Applications of Artificial Intelligence Conference, IAAI 2019, The Ninth AAAI Symposium on Educational Advances in Artificial Intelligence, EAAI 2019, pages 7184-7191, Honolulu, HI, USA.</p>
<p>Yufei Wang, Ian D. Wood, Stephen Wan, Mark Dras, and Mark Johnson. 2021. Mention Flags (MF): Constraining Transformer-based Text Generators. In Proceedings of the 59th Annual Meeting of the Association for Computational Linguistics and the 11th International Joint Conference on Natural Language Processing, ACL/IJCNLP 2021, (Volume 1: Long Papers), pages 103-113, Online.</p>
<p>Adina Williams, Nikita Nangia, and Samuel R. Bowman. 2018. A Broad-Coverage Challenge Corpus for Sentence Understanding through Inference. In Proceedings of the 2018 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, NAACL-HLT 2018, Volume 1 (Long Papers), pages 1112-1122, New Orleans, LA, USA.</p>
<p>Sam Wiseman, Stuart M. Shieber, and Alexander M. Rush. 2018. Learning Neural Templates for Text Generation. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 3174-3187, Brussels, Belgium.</p>
<p>Thomas Wolf, Lysandre Debut, Victor Sanh, Julien Chaumond, Clement Delangue, Anthony Moi, Pierric Cistac, Tim Rault, Rémi Louf, Morgan Funtowicz, and Jamie Brew. 2019. HuggingFace's Transformers: State-of-the-art Natural Language Processing. CoRR, abs/1910.03771.</p>
<p>Xinnuo Xu, Ondřej Dušek, Verena Rieser, and Ioannis Konstas. 2021. AggGen: Ordering and Aggregating while Generating. In Proceedings of the 59th Annual Meeting of the Association for Computational Linguistics and the 11th International Joint Conference on Natural Language Processing, ACL/IJCNLP 2021, (Volume 1: Long Papers), pages 1419-1434, Online.</p>
<p>Jingqing Zhang, Yao Zhao, Mohammad Saleh, and Peter J. Liu. 2020. PEGASUS: Pre-training with Extracted Gap-sentences for Abstractive Summarization. In Proceedings of the 37th International Conference on Machine Learning, ICML 2020, volume 119 of Proceedings of Machine Learning Research, pages 11328-11339, Online.</p>
<p>Chao Zhao, Marilyn A. Walker, and Snigdha Chaturvedi. 2020. Bridging the Structural Gap Between Encoding and Decoding for Data-To-Text Generation. In Proceedings of the 58th Annual Meeting of the Association for Computational Linguistics, ACL 2020, pages 2481-2491, Online.</p>
<h2>A Data Statistics</h2>
<p>Statistics for the datasets described in the paper are listed in Table 9.</p>
<h2>B Templates</h2>
<p>The templates for our datasets are single-sentence and mostly clear-cut verbalizations of the predicates. The templates were created by one of the authors who had only the input data at their disposal, i.e. without using human references.</p>
<p>We have also considered extracting the templates for WebNLG from the training data by delexicalizing single-triple examples. However, the examples are noisy and such data would not be available in a zero-shot setup, which is why we decided not to use this option.</p>
<p>Although the templates were mostly unambiguous, we had to opt for the most general version in certain cases (e.g., using country $\rightarrow$ "<s> is from $<o>"$, even though " $<s>$ is a food from $<o>$." would be possible in case the object is food).</p>
<p>Filling the templates also often results in minor disfluencies, e.g. nationality $\rightarrow$ "<s> is from <o>" will produce a missing definite article for $<o>$ = "United States" and ungrammatical sentence for $<o>=$ "French people". In principle, the disfluencies may be fixed by rephrasing in the final step of the pipeline.</p>
<p>We provide all the templates we used in our experiments in our repository.</p>
<h2>C Experimental Setup</h2>
<p>We implemented the models for split-and-rephrase, aggregation, and paragraph compression in PyTorch Lightning (Paszke et al., 2019), using the PyTorch (Falcon et al., 2019) version of the BART and RoBERTa models from the Huggingface library (Wolf et al., 2019).</p>
<p>We use the Adam (Kingma and Ba, 2015) optimizer $\left(\beta_{1}=0.9, \beta_{2}=0.997, \varepsilon=1^{-9}\right)$ with learning rate $2^{-5}$, linear scheduling and 0.1 warmup proportion; batches of size 8 and accumulating gradients with factor 4 . We train the models for 1 epoch on a single GeForce RTX 3090 GPU with 24 GB RAM. Training times were approximately 24 hours for the ordering model and 3 hours for the aggregation and paragraph compression models. We use greedy decoding in all our experiments.</p>
<p>For training the ordering model, we used the implementation from Calizzano et al. (2021) ${ }^{11}$ including their training parameters. We will integrate the ordering model into our framework.</p>
<h2>D Additional Results</h2>
<p>We provide evaluation of semantic accuracy on the E2E dataset as evaluated with the slot-error script based on matching regular expressions in Table 8. ${ }^{12}$</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
<th style="text-align: left;">miss</th>
<th style="text-align: left;">add</th>
<th style="text-align: center;">miss+add</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">TGEN</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">0.0060</td>
<td style="text-align: left;">0.0433</td>
<td style="text-align: center;">0.0016</td>
</tr>
<tr>
<td style="text-align: left;">COPY</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">0.0000</td>
<td style="text-align: left;">0.0000</td>
<td style="text-align: center;">0.0000</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">3-STAGE</td>
<td style="text-align: left;">0.0238</td>
<td style="text-align: left;">0.0698</td>
<td style="text-align: center;">0.0060</td>
</tr>
<tr>
<td style="text-align: left;">full</td>
<td style="text-align: left;">2-STAGE</td>
<td style="text-align: left;">0.0054</td>
<td style="text-align: left;">0.0363</td>
<td style="text-align: center;">0.0000</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">1-STAGE</td>
<td style="text-align: left;">0.0043</td>
<td style="text-align: left;">0.0330</td>
<td style="text-align: center;">0.0000</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">3-STAGE</td>
<td style="text-align: left;">0.0444</td>
<td style="text-align: left;">0.0487</td>
<td style="text-align: center;">0.0076</td>
</tr>
<tr>
<td style="text-align: left;">filtered</td>
<td style="text-align: left;">2-STAGE</td>
<td style="text-align: left;">0.0043</td>
<td style="text-align: left;">0.0368</td>
<td style="text-align: center;">0.0000</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">1-STAGE</td>
<td style="text-align: left;">0.0043</td>
<td style="text-align: left;">0.0347</td>
<td style="text-align: center;">0.0000</td>
</tr>
</tbody>
</table>
<p>Table 8: Proportion of output examples with missed only, added only, and both missed and added facts, according to the regex-based E2E slot error script.</p>
<p>However, please note that our manual investigation of a sample of the data shows that the majority of the errors identified in our model outputs are false. For example, the following regular expression used in the slot-error script:</p>
<div class="codehilite"><pre><span></span><code>    prices?(?: range)?(?:w+)0,3 high
</code></pre></div>

<p><sup id="fnref7:0"><a class="footnote-ref" href="#fn:0">1</a></sup>matches "(...) price range and high customer rating (...)", incorrectly classifying the presence of the extra slot priceRange[high]. This problem is magnified by the consistent outputs of our models, which tend to repeat certain patterns. However, we also manually identified several cases in which an error was found correctly, e.g. the model hallucinating "3 out of 4 customer rating" instead of "3 out of 5 customer rating".</p>
<h2>E Example Outputs</h2>
<p>Tables 10, 11, 12, and 13 show examples of behavior of our models on the WebNLG dataset. Tables 14 and 15 show examples of behavior of our models on the E2E dataset.</p>
<p>The green color marks the model outputs which are completely correct, the red color marks the errors. For better readability of the input format, we add numeric order identifiers for the individual facts (bold, in squared brackets). These are subsequently used as references in the Order and Aggregation rows. Note that zero-th input in E2E is used as a subject in the RDF triples.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;">#train</th>
<th style="text-align: left;">#dev</th>
<th style="text-align: left;">#test</th>
<th style="text-align: left;">tok/src</th>
<th style="text-align: left;">tok/tgt</th>
<th style="text-align: left;">sent/src</th>
<th style="text-align: left;">sent/tgt</th>
<th style="text-align: left;">#temp.</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">WebNLG</td>
<td style="text-align: left;">18,102</td>
<td style="text-align: left;">870</td>
<td style="text-align: left;">1,862</td>
<td style="text-align: left;">26.8</td>
<td style="text-align: left;">22.6</td>
<td style="text-align: left;">3.0</td>
<td style="text-align: left;">1.4</td>
<td style="text-align: left;">354</td>
</tr>
<tr>
<td style="text-align: left;">Clean E2E</td>
<td style="text-align: left;">33,236</td>
<td style="text-align: left;">4,299</td>
<td style="text-align: left;">1,847</td>
<td style="text-align: left;">29.2</td>
<td style="text-align: left;">22.3</td>
<td style="text-align: left;">4.2</td>
<td style="text-align: left;">1.5</td>
<td style="text-align: left;">8</td>
</tr>
<tr>
<td style="text-align: left;">WIKIFLUENT-full</td>
<td style="text-align: left;">915,855</td>
<td style="text-align: left;">9,346</td>
<td style="text-align: left;">9,346</td>
<td style="text-align: left;">52.9</td>
<td style="text-align: left;">41.1</td>
<td style="text-align: left;">3.9</td>
<td style="text-align: left;">2.0</td>
<td style="text-align: left;">-</td>
</tr>
<tr>
<td style="text-align: left;">WIKIFLUENT-filtered</td>
<td style="text-align: left;">700,517</td>
<td style="text-align: left;">7,149</td>
<td style="text-align: left;">7,149</td>
<td style="text-align: left;">45.6</td>
<td style="text-align: left;">35.4</td>
<td style="text-align: left;">3.4</td>
<td style="text-align: left;">1.8</td>
<td style="text-align: left;">-</td>
</tr>
</tbody>
</table>
<p>Table 9: Number of examples (train / dev / test), average number of tokens per source and target, average number of sentences per source and target (after filling the templates for the D2T datasets), total number of templates.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Input</th>
<th style="text-align: left;">[1] (Andrews County Airport; elevationAboveTheSeaLevel (in metres); 973.0)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">[2] (Andrews County Airport; runwayLength; 896.0)</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">[3] (Andrews County Airport; location; Texas)</td>
</tr>
<tr>
<td style="text-align: left;">Facts</td>
<td style="text-align: left;">Andrews County Airport is 973.0 metres above the sea level.</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">Andrews County Airport runway is 896.0 m long.</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">Andrews County Airport is located in Texas.</td>
</tr>
<tr>
<td style="text-align: left;">Order</td>
<td style="text-align: left;">321</td>
</tr>
<tr>
<td style="text-align: left;">Aggregation</td>
<td style="text-align: left;">$3&lt;$ sep $&gt;21$</td>
</tr>
<tr>
<td style="text-align: left;">Models (all)</td>
<td style="text-align: left;">Andrews County Airport is located in Andrews County, Texas. Its runway is 896.0 m</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">long and 973.0 metres above the sea level.</td>
</tr>
<tr>
<td style="text-align: left;">Human</td>
<td style="text-align: left;">The runway length of Andrews County Airport (located in Texas and 973.0 above sea</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">level) is 896.</td>
</tr>
</tbody>
</table>
<p>Table 10: Correct behavior of the models on WebNLG. All the models ( ${1,2,3}$-STAGE full/filtered) produce the same output.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Input</th>
<th style="text-align: left;">[1] (Akron, Ohio; country; United States)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">[2] (United States; language; English language)</td>
</tr>
<tr>
<td style="text-align: left;">Facts</td>
<td style="text-align: left;">Akron, Ohio is from United States.</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">English language is spoken in United States.</td>
</tr>
<tr>
<td style="text-align: left;">Order</td>
<td style="text-align: left;">12</td>
</tr>
<tr>
<td style="text-align: left;">Aggregation</td>
<td style="text-align: left;">$1&lt;$ sep $&gt;2$</td>
</tr>
<tr>
<td style="text-align: left;">3-stage full</td>
<td style="text-align: left;">Akron, Ohio is from United States. English language is spoken in Akron, Ohio, United</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">States, which is located in the U.S. state of Ohio.</td>
</tr>
<tr>
<td style="text-align: left;">2-stage full</td>
<td style="text-align: left;">Akron, Ohio is from United States. English language is spoken in Akron, Ohio.</td>
</tr>
<tr>
<td style="text-align: left;">1-stage full</td>
<td style="text-align: left;">English language is spoken in the United States. Akron, Ohio is from the state of Ohio</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">in the U.S. state of Illinois.</td>
</tr>
<tr>
<td style="text-align: left;">3-stage filtered</td>
<td style="text-align: left;">Akron, Ohio is from United States. English language is spoken in the United States of</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">America.</td>
</tr>
<tr>
<td style="text-align: left;">2-stage filtered</td>
<td style="text-align: left;">Akron, Ohio is from United States. English language is spoken in Akron, Ohio.</td>
</tr>
<tr>
<td style="text-align: left;">1-stage filtered</td>
<td style="text-align: left;">English language is spoken in the United States. Akron, Ohio is from the United</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">Kingdom.</td>
</tr>
<tr>
<td style="text-align: left;">Human</td>
<td style="text-align: left;">The country of Akron, Ohio, is United States, where English is the language spoken.</td>
</tr>
</tbody>
</table>
<p>Table 11: Incorrect behavior on WebNLG: besides the minor disfluencies caused by the templates ("Akron, Ohio is from..."), the models (except for 3 -STAGE filtered) tend to hallucinate and merge the facts incorrectly.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Input</th>
<th style="text-align: left;">[1] (Juan Perón; party; Labour Party (Argentina))</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">[2] (Alberto Teisaire; inOfficeWhilePresident; Juan Perón)</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">[3] (Alberto Teisaire; nationality; Argentina)</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">[4] (Argentina; language; Spanish language)</td>
</tr>
<tr>
<td style="text-align: left;">Facts</td>
<td style="text-align: left;">Juan Perón belongs to the Labour Party Argentina.</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">Alberto Teisaire was in office while Juan Perón was a president.</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">Alberto Teisaire is from Argentina.</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">Spanish language is spoken in Argentina.</td>
</tr>
<tr>
<td style="text-align: left;">Order</td>
<td style="text-align: left;">3214</td>
</tr>
<tr>
<td style="text-align: left;">Aggregation</td>
<td style="text-align: left;">$32&lt;$ <sep> $1&lt;$ sep&gt; 4</td>
</tr>
<tr>
<td style="text-align: left;">3-stage full</td>
<td style="text-align: left;">Alberto Teisaire is from Argentina, who was in office while Juan Perón was a president.</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">He belongs to the Labour Party Argentina. Spanish language is spoken in Argentina.</td>
</tr>
<tr>
<td style="text-align: left;">2-stage full</td>
<td style="text-align: left;">Alberto Teisaire is from Argentina. He was in office while Juan Perón was a president.</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">He belongs to the Labour Party Argentina. Spanish language is spoken in Argentina.</td>
</tr>
<tr>
<td style="text-align: left;">1-stage full</td>
<td style="text-align: left;">Alberto Teisaire is from Argentina. He was in office while Juan Perón was a president.</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">Spanish language is spoken in Argentina. Perón belongs to the Labour Party Argentina.</td>
</tr>
<tr>
<td style="text-align: left;">3-stage filtered</td>
<td style="text-align: left;">Alberto Teisaire is from Argentina, in office while Juan Perón was a president. He</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">belongs to the Labour Party Argentina. Spanish language is spoken in Argentina.</td>
</tr>
<tr>
<td style="text-align: left;">2-stage filtered</td>
<td style="text-align: left;">Alberto Teisaire is from Argentina. He was in office while Juan Perón was a president.</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">He belongs to the Labour Party Argentina. Spanish language is spoken in Argentina.</td>
</tr>
<tr>
<td style="text-align: left;">1-stage filtered</td>
<td style="text-align: left;">Alberto Teisaire is from Argentina. He was in office while Juan Perón was a president.</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">Spanish language is spoken in Argentina. Juan belongs to the Labour Party Argentina.</td>
</tr>
<tr>
<td style="text-align: left;">Human</td>
<td style="text-align: left;">Alberto Teisaire, is a national of Argentina, where Spanish is spoken. Alberto Teisaire,</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">was in office while Juan Perón was president. Juan Perón was a member of the Labour</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">Party in Argentina.</td>
</tr>
</tbody>
</table>
<p>Table 12: Incorrect behavior on WebNLG: by using a pronoun "He", the models tend to imply that Alberto Teisaire (instead of Juan Perón) belongs to the Labour Party.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Input</th>
<th style="text-align: left;">[1] (Alfa Romeo 164; relatedMeanOfTransportation; Fiat Croma)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">[2] (Alfa Romeo 164; assembly; Italy)</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">[3] (Italy; capital; Rome)</td>
</tr>
<tr>
<td style="text-align: left;">Facts</td>
<td style="text-align: left;">Alfa Romeo 164 is related to Fiat Croma.</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">Alfa Romeo 164 was assembled in Italy.</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">Italy's capital is Rome.</td>
</tr>
<tr>
<td style="text-align: left;">Order</td>
<td style="text-align: left;">231</td>
</tr>
<tr>
<td style="text-align: left;">Aggregation</td>
<td style="text-align: left;">$23&lt;$ sep $&gt;1$</td>
</tr>
<tr>
<td style="text-align: left;">3-stage full</td>
<td style="text-align: left;">Alfa Romeo 164 was assembled in Italy's capital, Rome. It is related to Fiat Croma.</td>
</tr>
<tr>
<td style="text-align: left;">2-stage full</td>
<td style="text-align: left;">Alfa Romeo 164 was assembled in Italy's capital, Rome. It is related to Fiat Croma.</td>
</tr>
<tr>
<td style="text-align: left;">1-stage full</td>
<td style="text-align: left;">Alfa Romeo 164 was assembled in Italy and related to Fiat Croma. Italy's capital is</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">Rome.</td>
</tr>
<tr>
<td style="text-align: left;">3-stage filtered</td>
<td style="text-align: left;">Alfa Romeo 164 was assembled in Italy's capital, Rome. It is related to Fiat Croma.</td>
</tr>
<tr>
<td style="text-align: left;">2-stage filtered</td>
<td style="text-align: left;">Alfa Romeo 164 was assembled in Italy's capital, Rome. It is related to Fiat Croma.</td>
</tr>
<tr>
<td style="text-align: left;">1-stage filtered</td>
<td style="text-align: left;">Alfa Romeo 164 was assembled in Italy. It is related to Fiat Croma. It was assembled</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">at the Italian capital is Rome.</td>
</tr>
<tr>
<td style="text-align: left;">Human</td>
<td style="text-align: left;">The Fiat Croma and the Alfa Romeo 164 are both cars. The latter was built in Italy</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">where the capital is Rome.</td>
</tr>
</tbody>
</table>
<p>Table 13: Incorrect behavior on WebNLG: the models tend to merge the country of vehicle's assembly and its capital.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Input</th>
<th style="text-align: center;">[0] name[The Cricketers]</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">[1] eatType[restaurant]</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">[2] near[All Bar One]</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">[3] priceRange[cheap]</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">[4] food[Chinese]</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">[5] customerRating[average]</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">[6] familyFriendly[yes]</td>
</tr>
<tr>
<td style="text-align: center;">Facts</td>
<td style="text-align: center;">The Cricketers is a restaurant.</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">The Cricketers is near All Bar One.</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">The Cricketers has cheap price range.</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">The Cricketers serves Chinese food.</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">The Cricketers has average customer rating.</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">The Cricketers is family-friendly.</td>
</tr>
<tr>
<td style="text-align: center;">Order</td>
<td style="text-align: center;">142635</td>
</tr>
<tr>
<td style="text-align: center;">Aggregation</td>
<td style="text-align: center;">$142&lt;$ sep $&gt;635$</td>
</tr>
<tr>
<td style="text-align: center;">3-stage full</td>
<td style="text-align: center;">The Cricketers is a restaurant serving Chinese food near All Bar One. It is family-</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">friendly, has cheap price range and average customer rating.</td>
</tr>
<tr>
<td style="text-align: center;">2-stage full</td>
<td style="text-align: center;">The Cricketers is a restaurant serving Chinese food near All Bar One. It is family-</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">friendly with cheap price range and average customer rating.</td>
</tr>
<tr>
<td style="text-align: center;">1-stage full</td>
<td style="text-align: center;">The Cricketers is a restaurant serving Chinese food. It is family-friendly and has cheap price range. It serves Chinese food near All Bar One. It has average customer rating.</td>
</tr>
<tr>
<td style="text-align: center;">3-stage filtered</td>
<td style="text-align: center;">The Cricketers is a restaurant serving Chinese food near All Bar One. It is family- friendly with cheap price range and average customer rating.</td>
</tr>
<tr>
<td style="text-align: center;">2-stage filtered</td>
<td style="text-align: center;">The Cricketers is a restaurant serving Chinese food near All Bar One. It is family- friendly with cheap price range and average customer rating.</td>
</tr>
<tr>
<td style="text-align: center;">1-stage filtered</td>
<td style="text-align: center;">The Cricketers is a restaurant serving Chinese food. It is family-friendly and has average customer rating. It serves Chinese food near All Bar One. It has cheap price range.</td>
</tr>
<tr>
<td style="text-align: center;">Human</td>
<td style="text-align: center;">For a central family friendly venue serving cheap Chinese food, try The Cricketers restaurant. It has average customer ratings and is near All Bar One.</td>
</tr>
</tbody>
</table>
<p>Table 14: Correct behavior of the models on E2E: the models can deal even with a higher amount of input values.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Input</th>
<th style="text-align: center;">[0] name[The Phoenix]</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">[1] area[riverside]</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">[2] priceRange[cheap]</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">[3] familyFriendly[yes]</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">[4] near[Raja Indian Cuisine]</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">[5] eatType[restaurant]</td>
</tr>
<tr>
<td style="text-align: center;">Facts</td>
<td style="text-align: center;">The Phoenix is in the riverside.</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">The Phoenix has cheap price range.</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">The Phoenix is family-friendly.</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">The Phoenix is near Raja Indian Cuisine.</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">The Phoenix is a restaurant.</td>
</tr>
<tr>
<td style="text-align: center;">Order</td>
<td style="text-align: center;">$514&lt;$ sep $&gt;32$</td>
</tr>
<tr>
<td style="text-align: center;">Aggregation</td>
<td style="text-align: center;">51432</td>
</tr>
<tr>
<td style="text-align: center;">3-stage full</td>
<td style="text-align: center;">The Phoenix is a restaurant in the riverside near Raja Indian Cuisine. It is family-</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">friendly with cheap price range.</td>
</tr>
<tr>
<td style="text-align: center;">2-stage full</td>
<td style="text-align: center;">The Phoenix is a restaurant in the riverside near Raja Indian Cuisine. It is family-</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">friendly with cheap price range.</td>
</tr>
<tr>
<td style="text-align: center;">1-stage full</td>
<td style="text-align: center;">The Phoenix is a restaurant near Raja Indian Cuisine in the riverside. It is family-</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">friendly and has cheap price range. It has cheap food range.</td>
</tr>
<tr>
<td style="text-align: center;">3-stage filtered</td>
<td style="text-align: center;">The Phoenix is a restaurant in the riverside near Raja Indian Cuisine. It is family-</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">friendly with cheap price range.</td>
</tr>
<tr>
<td style="text-align: center;">2-stage filtered</td>
<td style="text-align: center;">The Phoenix is a restaurant in the riverside near Raja Indian Cuisine. It is family-</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">friendly with cheap price range.</td>
</tr>
<tr>
<td style="text-align: center;">1-stage filtered</td>
<td style="text-align: center;">The Phoenix is a restaurant near Raja Indian Cuisine in the riverside. It is family-</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">friendly and has cheap price range. It has cheap food.</td>
</tr>
<tr>
<td style="text-align: center;">Human</td>
<td style="text-align: center;">Cheap food and a family friendly atmosphere at The Phoenix restaurant. Situated riverside near the Raja Indian Cuisine.</td>
</tr>
</tbody>
</table>
<p>Table 15: Incorrect behavior on E2E: the 1-STAGE models add redundant information to the output.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{11}$ https://github.com/airKlizz/
passage-ordering
${ }^{12}$ https://github.com/tuetschek/e2e-cleaning/
blob/master/slot_error.py&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref5:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref6:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref7:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:1">
<p>${ }^{10}$ On WebNLG, our COPY baseline achieves 37.18 BLEU points, compared to 24.80 BLEU points of the full system of Laha et al. (2019), which uses automatic template generation.&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 2 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:1" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>