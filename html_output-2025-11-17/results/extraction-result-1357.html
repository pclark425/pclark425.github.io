<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-1357 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-1357</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-1357</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-28.html">extraction-schema-28</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of navigation in text-based games or text worlds, including graph-topology features of the environments (such as diameter, clustering coefficient, dead-ends, door constraints, connectivity), exploration efficiency metrics, and how these relate to agent performance and policy structure.</div>
                <p><strong>Paper ID:</strong> paper-d37620e6f8fe678a43e12930743281cd8cca6a66</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/d37620e6f8fe678a43e12930743281cd8cca6a66" target="_blank">Hierarchical Deep Reinforcement Learning: Integrating Temporal Abstraction and Intrinsic Motivation</a></p>
                <p><strong>Paper Venue:</strong> Neural Information Processing Systems</p>
                <p><strong>Paper TL;DR:</strong> h-DQN is presented, a framework to integrate hierarchical value functions, operating at different temporal scales, with intrinsically motivated deep reinforcement learning, and allows for flexible goal specifications, such as functions over entities and relations.</p>
                <p><strong>Paper Abstract:</strong> Learning goal-directed behavior in environments with sparse feedback is a major challenge for reinforcement learning algorithms. The primary difficulty arises due to insufficient exploration, resulting in an agent being unable to learn robust value functions. Intrinsically motivated agents can explore new behavior for its own sake rather than to directly solve problems. Such intrinsic behaviors could eventually help the agent solve tasks posed by the environment. We present hierarchical-DQN (h-DQN), a framework to integrate hierarchical value functions, operating at different temporal scales, with intrinsically motivated deep reinforcement learning. A top-level value function learns a policy over intrinsic goals, and a lower-level function learns a policy over atomic actions to satisfy the given goals. h-DQN allows for flexible goal specifications, such as functions over entities and relations. This provides an efficient space for exploration in complicated environments. We demonstrate the strength of our approach on two problems with very sparse, delayed feedback: (1) a complex discrete stochastic decision process, and (2) the classic ATARI game `Montezuma's Revenge'.</p>
                <p><strong>Cost:</strong> 0.011</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e1357.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e1357.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of navigation in text-based games or text worlds, including graph-topology features of the environments (such as diameter, clustering coefficient, dead-ends, door constraints, connectivity), exploration efficiency metrics, and how these relate to agent performance and policy structure.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>6-state MDP</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Discrete stochastic decision process (6-state chain)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A small linear 6-state Markov decision process used to test intrinsic-goal driven exploration: agent starts at s2, terminal state s1, left moves deterministic, right succeeds 50% (otherwise results in left). Reward at s1 is high (1) only if s6 was previously visited; otherwise small (0.01).</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>environment_name</strong></td>
                            <td>Discrete stochastic decision process (6-state chain)</td>
                        </tr>
                        <tr>
                            <td><strong>environment_description</strong></td>
                            <td>Toy linear-chain MDP (states s1..s6). Agent starts at s2; actions move left deterministically, right succeeds 50% of the time and otherwise produces a left move; terminal at s1. Extrinsic reward depends on whether s6 was visited before reaching s1.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_diameter</strong></td>
                            <td>5 steps (distance between s1 and s6)</td>
                        </tr>
                        <tr>
                            <td><strong>clustering_coefficient</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>dead_ends_present</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>dead_ends_count</strong></td>
                            <td>2 nodes (s1 and s6) / 6 total</td>
                        </tr>
                        <tr>
                            <td><strong>door_constraints_present</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>door_constraints_description</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>graph_connectivity</strong></td>
                            <td>Linear chain (sparse, path graph)</td>
                        </tr>
                        <tr>
                            <td><strong>environment_size</strong></td>
                            <td>6 states (nodes); edges: adjacent-state connections (approx. 5 undirected edges in the chain)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>h-DQN (hierarchical Q-estimators) and baseline Q-learning</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>h-DQN: two-level DQN-style hierarchy with a meta-controller that selects goals (states) and a controller that learns goal-conditioned policies; baseline uses tabular Q-learning without intrinsic goals. In the toy experiment the neural networks are not used (hierarchical Q-estimators implemented in tabular form).</td>
                        </tr>
                        <tr>
                            <td><strong>exploration_efficiency_metric</strong></td>
                            <td>Average extrinsic reward per episode; state visit counts (visits to s3..s6 averaged over episodes)</td>
                        </tr>
                        <tr>
                            <td><strong>exploration_efficiency_value</strong></td>
                            <td>h-DQN average extrinsic reward ≈ 0.13 per episode; Q-learning baseline converges to ≈ 0.01</td>
                        </tr>
                        <tr>
                            <td><strong>success_rate</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>optimal_policy_type</strong></td>
                            <td>Hierarchical, goal-conditioned (temporally extended options) policy that sets intermediate state-goals (e.g., choosing s4/s5/s6) to reach distant rewarding states</td>
                        </tr>
                        <tr>
                            <td><strong>topology_performance_relationship</strong></td>
                            <td>The chain topology with a distant contingent reward (reward at s1 contingent on prior visit to s6) penalizes flat, local exploration: local exploration (ε-greedy Q-learning) reaches terminal s1 quickly and obtains low reward; hierarchical goal-setting that explicitly chooses intermediate state goals increases visits to distant state s6 and substantially raises extrinsic reward. Thus, large effective path-length (diameter) and required ordering of visits hurt flat learners but are mitigated by hierarchical goal structure.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_across_topologies</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>topology_comparison_results</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>policy_structure_findings</strong></td>
                            <td>Policies that include temporally-extended goals/options (meta-controller choosing states as goals) perform better in high path-length (high-diameter) linear topologies because they encourage purposeful traversal to distal states; flat reactive policies fail due to insufficient exploration and local optima (immediate but low reward).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Hierarchical Deep Reinforcement Learning: Integrating Temporal Abstraction and Intrinsic Motivation', 'publication_date_yy_mm': '2016-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1357.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e1357.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of navigation in text-based games or text worlds, including graph-topology features of the environments (such as diameter, clustering coefficient, dead-ends, door constraints, connectivity), exploration efficiency metrics, and how these relate to agent performance and policy structure.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Montezuma</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Montezuma's Revenge (Atari 2600)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A sparse-reward platforming Atari environment with rooms, ladders, keys and doors used to evaluate deep RL exploration; success requires long sequences of precise actions (e.g., pick up key then open door) and overcoming bottlenecks.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>environment_name</strong></td>
                            <td>Montezuma's Revenge (Atari 2600)</td>
                        </tr>
                        <tr>
                            <td><strong>environment_description</strong></td>
                            <td>Multi-room platformer (video-game) environment where the agent must navigate an avatar through rooms, climb ladders, avoid hazards, collect keys and open doors to receive sparse, delayed rewards (treasures). Domain: arcade platformer/navigation with object interactions and gated transitions.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_diameter</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>clustering_coefficient</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>dead_ends_present</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>dead_ends_count</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>door_constraints_present</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>door_constraints_description</strong></td>
                            <td>Conditional doors that require possession of a key to open (i.e., access to certain regions is gated on prior collection of key); transitions between rooms involve bottlenecks (doors, ladders).</td>
                        </tr>
                        <tr>
                            <td><strong>graph_connectivity</strong></td>
                            <td>Implicitly sparse with bottlenecks and constrained transitions between rooms (not fully connected); connectivity is structured by rooms, ladders and doors producing narrow passageways/subgoals.</td>
                        </tr>
                        <tr>
                            <td><strong>environment_size</strong></td>
                            <td>Not specified numerically in paper (multiple rooms/levels; exact node/edge counts not provided)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>h-DQN (hierarchical deep Q-networks; meta-controller + controller with convolutional networks)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Hierarchical DQN: meta-controller selects goals parameterized as entity relations (e.g., reach key, reach door), controller is a goal-conditioned convolutional DQN taking stacked frames plus a binary mask for the goal location; internal critic provides intrinsic reward for achieving chosen entity-relation goals.</td>
                        </tr>
                        <tr>
                            <td><strong>exploration_efficiency_metric</strong></td>
                            <td>Extrinsic reward per episode (score); goal success ratio and goal-selection statistics (frequency chosen and empirical success rate of chosen goals)</td>
                        </tr>
                        <tr>
                            <td><strong>exploration_efficiency_value</strong></td>
                            <td>After joint training, agent achieves ≈ +400 extrinsic reward per episode in many episodes (qualitative result shown). Prior flat DQN reported as score 0 and Gorila DQN ≈ 4.16 (reported for comparison).</td>
                        </tr>
                        <tr>
                            <td><strong>success_rate</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>optimal_policy_type</strong></td>
                            <td>Hierarchical goal-conditioned policies that use entity/relation parameterized intrinsic goals (temporally-extended options) are most effective; flat reactive DQN policies fail due to sparse rewards and long action sequences.</td>
                        </tr>
                        <tr>
                            <td><strong>topology_performance_relationship</strong></td>
                            <td>The environment's bottlenecks (doors requiring keys, long sequences of actions across ladders and rooms) create sparse reward exposure and make flat exploration ineffective. Parameterizing intrinsic goals by entities/relations focuses exploration on meaningful subregions (e.g., key, ladders, doors) and substantially improves discovery of reward-bearing states. In short: gated connectivity and high effective distances (long required action chains) degrade flat-agent performance while hierarchical, goal-driven agents overcome these topological challenges.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_across_topologies</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>topology_comparison_results</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>policy_structure_findings</strong></td>
                            <td>Effective policies require temporal abstraction and goal-conditioned controllers (options) that target bottlenecks/subgoals (e.g., keys, ladders); such policies implicitly perform longer-horizon planning and composition of options. The paper also notes remaining limitations (need for object discovery, short-term memory) for even longer-range structured topologies.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Hierarchical Deep Reinforcement Learning: Integrating Temporal Abstraction and Intrinsic Motivation', 'publication_date_yy_mm': '2016-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1357.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e1357.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of navigation in text-based games or text worlds, including graph-topology features of the environments (such as diameter, clustering coefficient, dead-ends, door constraints, connectivity), exploration efficiency metrics, and how these relate to agent performance and policy structure.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Text-based games (ref)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Text-based games / text worlds (referenced literature)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Text-based interactive fiction games and text-world navigation are cited in related work (reference to language-understanding RL for text games), but not experimentally studied in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Language understanding for text-based games using deep reinforcement learning</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>environment_name</strong></td>
                            <td>Text-based games / text worlds (general, cited)</td>
                        </tr>
                        <tr>
                            <td><strong>environment_description</strong></td>
                            <td>Referenced as a domain for RL and language understanding (text-based interactive environments where the agent perceives and acts via text), but no experiments or topology measurements are given in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_diameter</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>clustering_coefficient</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>dead_ends_present</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>dead_ends_count</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>door_constraints_present</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>door_constraints_description</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>graph_connectivity</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>environment_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>exploration_efficiency_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>exploration_efficiency_value</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>success_rate</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>optimal_policy_type</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>topology_performance_relationship</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>comparison_across_topologies</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>topology_comparison_results</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>policy_structure_findings</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Hierarchical Deep Reinforcement Learning: Integrating Temporal Abstraction and Intrinsic Motivation', 'publication_date_yy_mm': '2016-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Language understanding for text-based games using deep reinforcement learning <em>(Rating: 2)</em></li>
                <li>Identifying useful subgoals in reinforcement learning by local graph partitioning <em>(Rating: 2)</em></li>
                <li>Design principles of the hippocampal cognitive map <em>(Rating: 2)</em></li>
                <li>Learning purposeful behaviour in the absence of rewards <em>(Rating: 1)</em></li>
                <li>The successor representation and temporal context <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-1357",
    "paper_id": "paper-d37620e6f8fe678a43e12930743281cd8cca6a66",
    "extraction_schema_id": "extraction-schema-28",
    "extracted_data": [
        {
            "name_short": "6-state MDP",
            "name_full": "Discrete stochastic decision process (6-state chain)",
            "brief_description": "A small linear 6-state Markov decision process used to test intrinsic-goal driven exploration: agent starts at s2, terminal state s1, left moves deterministic, right succeeds 50% (otherwise results in left). Reward at s1 is high (1) only if s6 was previously visited; otherwise small (0.01).",
            "citation_title": "here",
            "mention_or_use": "use",
            "environment_name": "Discrete stochastic decision process (6-state chain)",
            "environment_description": "Toy linear-chain MDP (states s1..s6). Agent starts at s2; actions move left deterministically, right succeeds 50% of the time and otherwise produces a left move; terminal at s1. Extrinsic reward depends on whether s6 was visited before reaching s1.",
            "graph_diameter": "5 steps (distance between s1 and s6)",
            "clustering_coefficient": null,
            "dead_ends_present": true,
            "dead_ends_count": "2 nodes (s1 and s6) / 6 total",
            "door_constraints_present": false,
            "door_constraints_description": "",
            "graph_connectivity": "Linear chain (sparse, path graph)",
            "environment_size": "6 states (nodes); edges: adjacent-state connections (approx. 5 undirected edges in the chain)",
            "agent_name": "h-DQN (hierarchical Q-estimators) and baseline Q-learning",
            "agent_description": "h-DQN: two-level DQN-style hierarchy with a meta-controller that selects goals (states) and a controller that learns goal-conditioned policies; baseline uses tabular Q-learning without intrinsic goals. In the toy experiment the neural networks are not used (hierarchical Q-estimators implemented in tabular form).",
            "exploration_efficiency_metric": "Average extrinsic reward per episode; state visit counts (visits to s3..s6 averaged over episodes)",
            "exploration_efficiency_value": "h-DQN average extrinsic reward ≈ 0.13 per episode; Q-learning baseline converges to ≈ 0.01",
            "success_rate": null,
            "optimal_policy_type": "Hierarchical, goal-conditioned (temporally extended options) policy that sets intermediate state-goals (e.g., choosing s4/s5/s6) to reach distant rewarding states",
            "topology_performance_relationship": "The chain topology with a distant contingent reward (reward at s1 contingent on prior visit to s6) penalizes flat, local exploration: local exploration (ε-greedy Q-learning) reaches terminal s1 quickly and obtains low reward; hierarchical goal-setting that explicitly chooses intermediate state goals increases visits to distant state s6 and substantially raises extrinsic reward. Thus, large effective path-length (diameter) and required ordering of visits hurt flat learners but are mitigated by hierarchical goal structure.",
            "comparison_across_topologies": false,
            "topology_comparison_results": "",
            "policy_structure_findings": "Policies that include temporally-extended goals/options (meta-controller choosing states as goals) perform better in high path-length (high-diameter) linear topologies because they encourage purposeful traversal to distal states; flat reactive policies fail due to insufficient exploration and local optima (immediate but low reward).",
            "uuid": "e1357.0",
            "source_info": {
                "paper_title": "Hierarchical Deep Reinforcement Learning: Integrating Temporal Abstraction and Intrinsic Motivation",
                "publication_date_yy_mm": "2016-04"
            }
        },
        {
            "name_short": "Montezuma",
            "name_full": "Montezuma's Revenge (Atari 2600)",
            "brief_description": "A sparse-reward platforming Atari environment with rooms, ladders, keys and doors used to evaluate deep RL exploration; success requires long sequences of precise actions (e.g., pick up key then open door) and overcoming bottlenecks.",
            "citation_title": "here",
            "mention_or_use": "use",
            "environment_name": "Montezuma's Revenge (Atari 2600)",
            "environment_description": "Multi-room platformer (video-game) environment where the agent must navigate an avatar through rooms, climb ladders, avoid hazards, collect keys and open doors to receive sparse, delayed rewards (treasures). Domain: arcade platformer/navigation with object interactions and gated transitions.",
            "graph_diameter": null,
            "clustering_coefficient": null,
            "dead_ends_present": null,
            "dead_ends_count": null,
            "door_constraints_present": true,
            "door_constraints_description": "Conditional doors that require possession of a key to open (i.e., access to certain regions is gated on prior collection of key); transitions between rooms involve bottlenecks (doors, ladders).",
            "graph_connectivity": "Implicitly sparse with bottlenecks and constrained transitions between rooms (not fully connected); connectivity is structured by rooms, ladders and doors producing narrow passageways/subgoals.",
            "environment_size": "Not specified numerically in paper (multiple rooms/levels; exact node/edge counts not provided)",
            "agent_name": "h-DQN (hierarchical deep Q-networks; meta-controller + controller with convolutional networks)",
            "agent_description": "Hierarchical DQN: meta-controller selects goals parameterized as entity relations (e.g., reach key, reach door), controller is a goal-conditioned convolutional DQN taking stacked frames plus a binary mask for the goal location; internal critic provides intrinsic reward for achieving chosen entity-relation goals.",
            "exploration_efficiency_metric": "Extrinsic reward per episode (score); goal success ratio and goal-selection statistics (frequency chosen and empirical success rate of chosen goals)",
            "exploration_efficiency_value": "After joint training, agent achieves ≈ +400 extrinsic reward per episode in many episodes (qualitative result shown). Prior flat DQN reported as score 0 and Gorila DQN ≈ 4.16 (reported for comparison).",
            "success_rate": null,
            "optimal_policy_type": "Hierarchical goal-conditioned policies that use entity/relation parameterized intrinsic goals (temporally-extended options) are most effective; flat reactive DQN policies fail due to sparse rewards and long action sequences.",
            "topology_performance_relationship": "The environment's bottlenecks (doors requiring keys, long sequences of actions across ladders and rooms) create sparse reward exposure and make flat exploration ineffective. Parameterizing intrinsic goals by entities/relations focuses exploration on meaningful subregions (e.g., key, ladders, doors) and substantially improves discovery of reward-bearing states. In short: gated connectivity and high effective distances (long required action chains) degrade flat-agent performance while hierarchical, goal-driven agents overcome these topological challenges.",
            "comparison_across_topologies": false,
            "topology_comparison_results": "",
            "policy_structure_findings": "Effective policies require temporal abstraction and goal-conditioned controllers (options) that target bottlenecks/subgoals (e.g., keys, ladders); such policies implicitly perform longer-horizon planning and composition of options. The paper also notes remaining limitations (need for object discovery, short-term memory) for even longer-range structured topologies.",
            "uuid": "e1357.1",
            "source_info": {
                "paper_title": "Hierarchical Deep Reinforcement Learning: Integrating Temporal Abstraction and Intrinsic Motivation",
                "publication_date_yy_mm": "2016-04"
            }
        },
        {
            "name_short": "Text-based games (ref)",
            "name_full": "Text-based games / text worlds (referenced literature)",
            "brief_description": "Text-based interactive fiction games and text-world navigation are cited in related work (reference to language-understanding RL for text games), but not experimentally studied in this paper.",
            "citation_title": "Language understanding for text-based games using deep reinforcement learning",
            "mention_or_use": "mention",
            "environment_name": "Text-based games / text worlds (general, cited)",
            "environment_description": "Referenced as a domain for RL and language understanding (text-based interactive environments where the agent perceives and acts via text), but no experiments or topology measurements are given in this paper.",
            "graph_diameter": null,
            "clustering_coefficient": null,
            "dead_ends_present": null,
            "dead_ends_count": null,
            "door_constraints_present": null,
            "door_constraints_description": null,
            "graph_connectivity": null,
            "environment_size": null,
            "agent_name": null,
            "agent_description": null,
            "exploration_efficiency_metric": null,
            "exploration_efficiency_value": null,
            "success_rate": null,
            "optimal_policy_type": null,
            "topology_performance_relationship": null,
            "comparison_across_topologies": null,
            "topology_comparison_results": "",
            "policy_structure_findings": "",
            "uuid": "e1357.2",
            "source_info": {
                "paper_title": "Hierarchical Deep Reinforcement Learning: Integrating Temporal Abstraction and Intrinsic Motivation",
                "publication_date_yy_mm": "2016-04"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Language understanding for text-based games using deep reinforcement learning",
            "rating": 2
        },
        {
            "paper_title": "Identifying useful subgoals in reinforcement learning by local graph partitioning",
            "rating": 2
        },
        {
            "paper_title": "Design principles of the hippocampal cognitive map",
            "rating": 2
        },
        {
            "paper_title": "Learning purposeful behaviour in the absence of rewards",
            "rating": 1
        },
        {
            "paper_title": "The successor representation and temporal context",
            "rating": 1
        }
    ],
    "cost": 0.010989249999999999,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Hierarchical Deep Reinforcement Learning: Integrating Temporal Abstraction and Intrinsic Motivation</h1>
<p>Tejas D. Kulkarni*<br>BCS, MIT<br>tejask@mit.edu</p>
<p>Karthik R. Narasimhan*<br>CSAIL, MIT<br>karthikn@mit.edu</p>
<p>Ardavan Saeedi<br>CSAIL, MIT<br>ardavans@mit.edu</p>
<p>Joshua B. Tenenbaum<br>BCS, MIT<br>jbt@mit.edu</p>
<h4>Abstract</h4>
<p>Learning goal-directed behavior in environments with sparse feedback is a major challenge for reinforcement learning algorithms. The primary difficulty arises due to insufficient exploration, resulting in an agent being unable to learn robust value functions. Intrinsically motivated agents can explore new behavior for its own sake rather than to directly solve problems. Such intrinsic behaviors could eventually help the agent solve tasks posed by the environment. We present hierarchical-DQN (h-DQN), a framework to integrate hierarchical value functions, operating at different temporal scales, with intrinsically motivated deep reinforcement learning. A top-level value function learns a policy over intrinsic goals, and a lower-level function learns a policy over atomic actions to satisfy the given goals. h-DQN allows for flexible goal specifications, such as functions over entities and relations. This provides an efficient space for exploration in complicated environments. We demonstrate the strength of our approach on two problems with very sparse, delayed feedback: (1) a complex discrete stochastic decision process, and (2) the classic ATARI game 'Montezuma's Revenge'.</p>
<h2>1 Introduction</h2>
<p>Learning goal-directed behavior with sparse feedback from complex environments is a fundamental challenge for artificial intelligence. Learning in this setting requires the agent to represent knowledge at multiple levels of spatio-temporal abstractions and to explore the environment efficiently. Recently, non-linear function approximators coupled with reinforcement learning [21, 28, 37] have made it possible to learn abstractions over highdimensional state spaces, but the task of exploration with sparse feedback still remains a major challenge. Existing methods like Boltzmann exploration and Thomson sampling [45, 32] offer significant improvements over $\epsilon$-greedy, but are limited due to the underlying models functioning at the level of basic actions. In this work, we propose a framework that integrates deep reinforcement learning with hierarchical value functions (h-DQN), where the agent is motivated to solve intrinsic goals (via learning options) to aid exploration. These goals provide for efficient exploration and help mitigate the sparse feedback problem. Additionally, we observe that goals defined in the space of entities and relations can help significantly constrain the exploration space for data-efficient learning in complex environments.</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>Reinforcement learning (RL) formalizes control problems as finding a policy $\pi$ that maximizes expected future rewards [46]. Value functions $V(s)$ are central to RL, and they cache the utility of any state $s$ in achieving the agent's overall objective. Recently, value functions have also been generalized as $V(s, g)$ in order to represent the utility of state $s$ for achieving a given goal $g \in G[47,34]$. When the environment provides delayed rewards, we adopt a strategy to first learn ways to achieve intrinsically generated goals, and subsequently learn an optimal policy to chain them together. Each of the value functions $V(s, g)$ can be used to generate a policy that terminates when the agent reaches the goal state $g$. A collection of these policies can be hierarchically arranged with temporal dynamics for learning or planning within the framework of semi-Markov decision processes [48, 49]. In high-dimensional problems, these value functions can be approximated by neural networks as $V(s, g ; \theta)$.</p>
<p>We propose a framework with hierarchically organized deep reinforcement learning modules working at different time-scales. The model takes decisions over two levels of hierarchy (a) the top level module (meta-controller) takes in the state and picks a new goal, (b) the lower-level module (controller) uses both the state and the chosen goal to select actions either until the goal is reached or the episode is terminated. The meta-controller then chooses another goal and steps (a-b) repeat. We train our model using stochastic gradient descent at different temporal scales to optimize expected future intrinsic (controller) and extrinsic rewards (meta-controller). We demonstrate the strength of our approach on problems with long-range delayed feedback: (1) a discrete stochastic decision process with a long chain of states before receiving optimal extrinsic rewards and (2) a classic ATARI game ('Montezuma's Revenge') with even longer-range delayed rewards where most existing state-of-art deep reinforcement learning approaches fail to learn policies in a data-efficient manner.</p>
<h1>2 Literature Review</h1>
<h3>2.1 Reinforcement Learning with Temporal Abstractions</h3>
<p>Learning and operating over different levels of temporal abstraction is a key challenge in tasks involving long-range planning. In the context of reinforcement learning [1], Sutton et al. [48] proposed the options framework, which involves abstractions over the space of actions. At each step, the agent chooses either a one-step "primitive" action or a "multi-step" action policy (option). Each option defines a policy over actions (either primitive or other options) and can be terminated according to a stochastic function $\beta$. Thus, the traditional MDP setting can be extended to a semi-Markov decision process (SMDP) with the use of options. Recently, several methods have been proposed to learn options in real-time by using varying reward functions [49] or by composing existing options [42]. Value functions have also been generalized to consider goals along with states [34]. This universal value function $V(s, g ; \theta)$ provides an universal option that approximately represents optimal behavior towards the goal $g$. Our work is inspired by these papers and builds upon them.</p>
<p>There has also been a lot of work on option discovery in the tabular value function setting [26, 38, 25, 27]. In more recent work, Machado et al. [24] presented an option discovery algorithm where the agent is encouraged to explore regions that were previously out of reach. However, option discovery where non-linear state approximations are required is still an open problem.</p>
<p>Other related work for hierarchical formulations include the model of Dayan and Hinton [6] which consisted of "managers" taking decisions at various levels of granularity, percolating all the way down to atomic actions made by the agent. The MAXQ framework [7] built up on this work to decompose the value function of an MDP into combinations of value functions of smaller constituent MDPs, as did Guestrin et al. [17] in their factored MDP formulation. Hernandez-Gardiol and Mahadevan [19] combined hierarchical RL with a variable length short-term memory of high-level decisions.</p>
<p>In our work, we propose a scheme for temporal abstraction that involves simultaneously learning options and a control policy to compose options in a deep reinforcement learning setting. Our approach does not use separate Q-functions for each option, but instead treats the option as part of the input, similar to [34]. This has two advantages: (1) there is shared</p>
<p>learning between different options, and (2) the model is potentially scalable to a large number of options.</p>
<h1>2.2 Intrinsically motivated RL</h1>
<p>The nature and origin of 'good' intrinsic reward functions is an open question in reinforcement learning. Singh et al. 41 explored agents with intrinsic reward structures in order to learn generic options that can apply to a wide variety of tasks. Using a notion of "salient events" as sub-goals, the agent learns options to get to such events. In another paper, Singh et al. 40 take an evolutionary perspective to optimize over the space of reward functions for the agent, leading to a notion of extrinsically and intrinsically motivated behavior. In the context of hierarchical RL, Goel and Huber [13] discuss a framework for subgoal discovery using the structural aspects of a learned policy model. Şimşek et al. [38] provide a graph partioning approach to subgoal identification.
Schmidhuber [36] provides a coherent formulation of intrinsic motivation, which is measured by the improvements to a predictive world model made by the learning algorithm. Mohamed and Rezende [29] have recently proposed a notion of intrinsically motivated learning within the framework of mutual information maximization. Frank et al. [11] demonstrate the effectiveness of artificial curiosity using information gain maximization in a humanoid robot.</p>
<h3>2.3 Object-based RL</h3>
<p>Object-based representations [8, 4] that can exploit the underlying structure of a problem have been proposed to alleviate the curse of dimensionality in RL. Diuk et al. [8] propose an Object-Oriented MDP, using a representation based on objects and their interactions. Defining each state as a set of value assignments to all possible relations between objects, they introduce an algorithm for solving deterministic object-oriented MDPs. Their representation is similar to that of Guestrin et al. [16], who describe an object-based representation in the context of planning. In contrast to these approaches, our representation does not require explicit encoding for the relations between objects and can be used in stochastic domains.</p>
<h3>2.4 Deep Reinforcement Learning</h3>
<p>Recent advances in function approximation with deep neural networks have shown promise in handling high-dimensional sensory input. Deep Q-Networks and its variants have been successfully applied to various domains including Atari games [28] and Go [37], but still perform poorly on environments with sparse, delayed reward signals. Strategies such as prioritized experience replay [35] and bootstrapping [32] have been proposed to alleviate the problem of learning from sparse rewards. These approaches yield significant improvements over prior work but struggle when the reward signal has a long delayed horizon. This is because the exploration strategy is not sufficient for the agent to obtain the required feedback.</p>
<h3>2.5 Cognitive Science and Neuroscience</h3>
<p>The nature and origin of intrinsic goals in humans is a thorny issue but there are some notable insights from existing literature. There is converging evidence in developmental psychology that human infants, primates, children, and adults in diverse cultures base their core knowledge on certain cognitive systems including - entities, agents and their actions, numerical quantities, space, social-structures and intuitive theories [43, 23]. Even newborns and infants seem to represent the visual world in terms of coherent visual entities, centered around spatio-temporal principles of cohesion, continuity, and contact. They also seem to explicitly represent other agents, with the assumption that an agent's behavior is goal-directed and efficient. Infants can also discriminate relative sizes of objects, relative distances and higher order numerical relations such as the ratio of object sizes. During curiosity-driven activities, toddlers use this knowledge to generate intrinsic goals such as building physically stable block structures. In order to accomplish these goals, toddlers seem to construct sub-goals in the space of their core knowledge, such as - putting a heavier entity on top of (relation) a lighter entity in order to build tall blocks.</p>
<p>Knowledge of space can also be utilized to learn a hierarchical decomposition of spatial environments, where the bottlenecks between different spatial groupings correspond to sub-goals. This has been explored in neuroscience with the successor representation, which represents a value function in terms of the expected future state occupancy. Decomposition of the successor representation yields reasonable sub-goals for spatial navigation problems [5, 12, 44]. Botvinick et al. [3] have written a general overview of hierarchical reinforcement learning in the context of cognitive science and neuroscience.</p>
<h1>3 Model</h1>
<p>Consider a Markov decision process (MDP) represented by states $s \in \mathcal{S}$, actions $a \in \mathcal{A}$, and transition function $\mathcal{T}:(s, a) \rightarrow s^{\prime}$. An agent operating in this framework receives a state $s$ from the external environment and can take an action $a$, which results in a new state $s^{\prime}$. We define the extrinsic reward function as $\mathcal{F}:(s) \rightarrow \mathbb{R}$. The objective of the agent is to maximize this function over long periods of time. For example, this function can take the form of the agent's survival time or score in a game.</p>
<p>Agents Effective exploration in MDPs is a significant challenge in learning good control policies. Methods such as $\epsilon$-greedy are useful for local exploration but fail to provide impetus for the agent to explore different areas of the state space. In order to tackle this, we utilize a notion of goals $g \in \mathcal{G}$, which provide intrinsic motivation for the agent. The agent focuses on setting and achieving sequences of goals in order to maximize cumulative extrinsic reward.
We use the temporal abstraction of options [48] to define policies $\pi_{g}$ for each goal $g$. The agent learns these option policies simultaneously along with learning the optimal sequence of goals to follow. In order to learn each $\pi_{g}$, the agent also has a critic, which provides intrinsic rewards, based on whether the agent is able to achieve its goals (see Figure 1).</p>
<p>Temporal Abstractions As shown in Figure 1, the agent uses a two-stage hierarchy consisting of a controller and a meta-controller. The meta-controller receives state $s_{t}$ and chooses a goal $g_{t} \in \mathcal{G}$, where $\mathcal{G}$ denotes the set of all possible current goals. The controller then selects an action $a_{t}$ using $s_{t}$ and $g_{t}$. The goal $g_{t}$ remains in place for the next few time steps either until it is achieved or a terminal state is reached. The internal critic is responsible for evaluating whether a goal has been reached and providing an appropriate reward $r_{t}(g)$ to the controller. The objective function for the controller is to maximize cumulative intrinsic reward: $R_{t}(g)=\sum_{t^{\prime}=t}^{\infty} \gamma^{t^{\prime}-t} r_{t^{\prime}}(g)$. Similarly, the objective of the meta-controller is to optimize the cumulative extrinsic reward $F_{t}=\sum_{t^{\prime}=t}^{\infty} \gamma^{t^{\prime}-t} f_{t^{\prime}}$, where $f_{t}$ are reward signals received from the environment.</p>
<p>One can also view this setup as similar to optimizing over the space of optimal reward functions to maximize fitness [39]. In our case, the reward functions are dynamic and temporally dependent on the sequential history of goals. Figure 1 provides an illustration of the agent's use of the hierarchy over subsequent time steps.</p>
<h2>Deep Reinforcement Learning with Temporal Abstractions</h2>
<p>We use the Deep Q-Learning framework [28] to learn policies for both the controller and the meta-controller. Specifically, the controller estimates the following Q-value function:</p>
<p>$$
\begin{aligned}
Q_{1}^{<em>}(s, a ; g) &amp; =\max <em a="a" g="g">{\pi</em>\right] \
&amp; =\max }} \mathrm{E}\left[\sum_{t^{\prime}=t}^{\infty} \gamma^{t^{\prime}-t} r_{t^{\prime}} \mid s_{t}=s, a_{t}=a, g_{t}=g, \pi_{a g<em a="a" g="g">{\pi</em>+\gamma \max }} \mathrm{E}\left[r_{t<em t_1="t+1">{a</em>^{}} Q_{1</em>}\left(s_{t+1}, a_{t+1} ; g\right) \mid s_{t}=s, a_{t}=a, g_{t}=g, \pi_{a g}\right]
\end{aligned}
$$</p>
<p>where $g$ is the agent's goal in state $s$ and $\pi_{a g}=P(a \mid s, g)$ is the action policy.
Similarly, for the meta-controller, we have:</p>
<p>$$
Q_{2}^{<em>}(s, g)=\max <em g="g">{\pi</em>+\gamma \max }} \mathrm{E}\left[\sum_{t^{\prime}=t}^{t+N} f_{t^{\prime}<em 2="2">{g^{\prime}} Q</em>^{</em>}\left(s_{t+N}, g^{\prime}\right) \mid s_{t}=s, g_{t}=g, \pi_{g}\right]
$$</p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Overview: The agent produces actions and receives sensory observations. Separate deep-Q networks are used inside the meta-controller and controller. The meta-controller that looks at the raw states and produces a policy over goals by estimating the value function $Q_{2}\left(s_{t}, g_{t} ; \theta_{2}\right)$ (by maximizing expected future extrinsic reward). The controller takes in states and the current goal, and produces a policy over actions by estimating the value function $Q_{2}\left(s_{t}, a_{t} ; \theta_{1}, g_{t}\right)$ to solve the predicted goal (by maximizing expected future intrinsic reward). The internal critic checks if goal is reached and provides an appropriate intrinsic reward to the controller. The controller terminates either when the episode ends or when $g$ is accomplished. The meta-controller then chooses a new $g$ and the process repeats.</p>
<p>where $N$ denotes the number of time steps until the controller halts given the current goal, $g^{\prime}$ is the agent's goal in state $s_{t+N}$, and $\pi_{g}=P(g \mid s)$ is the policy over goals. It is important to note that the transitions $\left(s_{t}, g_{t}, f_{t}, s_{t+N}\right)$ generated by $Q_{2}$ run at a slower time-scale than the transitions $\left(s_{t}, a_{t}, g_{t}, r_{t}, s_{t+1}\right)$ generated by $Q_{1}$.
We can represent $Q^{*}(s, g) \approx Q(s, g ; \theta)$ using a non-linear function approximator with parameters $\theta$, called a deep Q-network (DQN). Each $Q \in\left{Q_{1}, Q_{2}\right}$ can be trained by minimizing corresponding loss functions $-L_{1}\left(\theta_{1}\right)$ and $L_{2}\left(\theta_{2}\right)$. We store experiences $\left(s_{t}, g_{t}, f_{t}, s_{t+N}\right)$ for $Q_{2}$ and $\left(s_{t}, a_{t}, g_{t}, r_{t}, s_{t+1}\right)$ for $Q_{1}$ in disjoint memory spaces $\mathcal{D}<em 2="2">{1}$ and $\mathcal{D}</em>$ can then be stated as:}$ respectively. The loss function for $Q_{1</p>
<p>$$
L_{1}\left(\theta_{1, i}\right)=\mathrm{E}<em 1="1">{\left(s, a, g, r, s^{\prime}\right) \sim D</em>\right]
$$}}\left[\left(y_{1, i}-Q_{1}\left(s, a ; \theta_{1, i}, g\right)\right)^{2</p>
<p>where $i$ denotes the training iteration number and $y_{1, i}=r+\gamma \max <em 1="1">{a^{\prime}} Q</em>, g\right)$.
Following [28], the parameters $\theta_{1, i-1}$ from the previous iteration are held fixed when optimising the loss function. The parameters $\theta_{1}$ can be optimized using the gradient:}\left(s^{\prime}, a^{\prime} ; \theta_{1, i-1</p>
<p>$$
\begin{aligned}
&amp; \nabla_{\theta_{1, i}} L_{1}\left(\theta_{1, i}\right) \
&amp; \quad=\mathrm{E}<em 1="1">{\left(s, a, r, s^{\prime} \sim D</em>\left[\left(r+\gamma \max }\right)<em 1="1">{a^{\prime}} Q</em>, g\right)\right)
\end{aligned}
$$}\left(s^{\prime}, a^{\prime} ; \theta_{1, i-1}, g\right)-Q_{1}\left(s, a ; \theta_{1, i}, g\right)\right) \nabla_{\theta_{1, i}} Q_{1}\left(s, a ; \theta_{1, i</p>
<p>The loss function $L_{2}$ and its gradients can be derived using a similar procedure.
Learning Algorithm We learn the parameters of h-DQN using stochastic gradient descent at different time scales - experiences (or transitions) from the controller are collected at every time step but experiences from meta-controller are only collected when the controller terminates (i.e. when a goal is re-picked or the episode ends). Each new goal $g$ is drawn in an $\epsilon$-greedy fashion (Algorithms $1 \&amp; 2$ ) with the exploration probability $\epsilon_{2}$ annealed as learning proceeds (from a starting value of 1 ).
In the controller, at every time step, an action is drawn with a goal using the exploration probability $\epsilon_{1, g}$ which is dependent on the current empirical success rate of reaching $g$. The model parameters $\left(\theta_{1}, \theta_{2}\right)$ are periodically updated by drawing experiences from replay memories $\mathcal{D}<em 2="2">{1}$ and $\mathcal{D}</em>$ ), respectively (see Algorithm 3).</p>
<h1>4 Experiments</h1>
<p>We perform experiments on two different domains involving delayed rewards. The first is a discrete-state MDP with stochastic transitions, and the second is an ATARI 2600 game called 'Montezuma's Revenge'.</p>
<h3>4.1 Discrete stochastic decision process</h3>
<p>Game Setup We consider a stochastic decision process where the extrinsic reward depends on the history of visited states in addition to the current state. We selected this task in order to demonstrate the importance of intrinsic motivation for exploration in such environments.
There are 6 possible states and the agent always starts at $s_{2}$. The agent moves left
<img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: A stochastic decision process where the reward at the terminal state $s_{1}$ depends on whether $s_{6}$ is visited $(r=1)$ or not $(r=$ $1 / 100)$.
deterministically when it chooses left action; but the action right only succeeds $50 \%$ of the time, resulting in a left move otherwise. The terminal state is $s_{1}$ and the agent receives the reward of 1 when it first visits $s_{6}$ and then $s_{1}$. The reward for going to $s_{1}$ without visiting $s_{6}$ is 0.01 . This is a modified version of the MDP in [32], with the reward structure adding complexity to the task. The process is illustrated in Figure 2.</p>
<div class="codehilite"><pre><span></span><code>Algorithm 1 Learning algorithm for h-DQN
    Initialize experience replay memories \(\left\{\mathcal{D}_{1}, \mathcal{D}_{2}\right\}\) and parameters \(\left\{\theta_{1}, \theta_{2}\right\}\) for the controller
    and meta-controller respectively.
    Initialize exploration probability \(\epsilon_{1, g}=1\) for the controller for all goals \(g\) and \(\epsilon_{2}=1\) for
    the meta-controller.
    for \(i=1\), num_episodes do
        Initialize game and get start state description \(s\)
        \(g \leftarrow \operatorname{EPSGREEDY}\left(s, \mathcal{G}, \epsilon_{2}, Q_{2}\right)\)
        while \(s\) is not terminal do
            \(F \leftarrow 0\)
            \(s_{0} \leftarrow s\)
            while not ( \(s\) is terminal or goal \(g\) reached) do
                \(a \leftarrow \operatorname{EPSGREEDY}\left(\{s, g\}, \mathcal{A}, \epsilon_{1, g}, Q_{1}\right)\)
                Execute \(a\) and obtain next state \(s^{\prime}\) and extrinsic reward \(f\) from environment
                Obtain intrinsic reward \(r\left(s, a, s^{\prime}\right)\) from internal critic
                Store transition \(\left(\{s, g\}, a, r,\left\{s^{\prime}, g\right\}\right)\) in \(\mathcal{D}_{1}\)
                \(\operatorname{UPdAtEParams}\left(\mathcal{L}_{1}\left(\theta_{1, i}\right), \mathcal{D}_{1}\right)\)
                \(\operatorname{UPdAtEParams}\left(\mathcal{L}_{2}\left(\theta_{2, i}\right), \mathcal{D}_{2}\right)\)
                \(F \leftarrow F+f\)
                \(s \leftarrow s^{\prime}\)
            end while
            Store transition \(\left(s_{0}, g, F, s^{\prime}\right)\) in \(\mathcal{D}_{2}\)
            if \(s\) is not terminal then
                \(g \leftarrow \operatorname{EPSGREEDY}\left(s, \mathcal{G}, \epsilon_{2}, Q_{2}\right)\)
            end if
        end while
        Anneal \(\epsilon_{2}\) and adaptively anneal \(\epsilon_{1, g}\) using average success rate of reaching goal \(g\).
end for
</code></pre></div>

<div class="codehilite"><pre><span></span><code>Algorithm 2 : \(\operatorname{EPSGREEDY}(x, \mathcal{B}, \epsilon, Q)\)
    if random( ) \(&lt;\epsilon\) then
        return random element from set \(\mathcal{B}\)
    else
        \(\operatorname{return} \operatorname{argmax}_{m \in \mathcal{B}} Q(x, m)\)
    end if
Algorithm 3 : \(\operatorname{UPdAtEParams}(\mathcal{L}, \mathcal{D})\)
    Randomly sample mini-batches from \(\mathcal{D}\)
    Perform gradient descent on loss \(\mathcal{L}(\theta)\) (cf. (3))
</code></pre></div>

<p>We consider each state as a possible goal for exploration. This encourages the agent to visit state $s_{6}$ (whenever it is chosen as a goal) and hence, learn the optimal policy. For each goal, the agent receives a positive intrinsic reward if and only if it reaches the corresponding state.</p>
<p>Results We compare the performance of our approach (without the deep neural networks) with Q-Learning as a baseline (without intrinsic rewards) in terms of the average extrinsic reward gained in an episode. In our experiments, all $\epsilon$ parameters are annealed from 1 to 0.1 over 50,000 steps. The learning rate is set to 0.00025 . Figure 3 plots the evolution of reward for both methods averaged over 10 different runs. As expected, we see that Q-Learning is unable to find the optimal policy even after 200 epochs, converging to a sub-optimal policy of reaching state $s_{1}$ directly to obtain a reward of 0.01 . In contrast, our approach with hierarchical Q-estimators learns to choose goals $s_{4}, s_{5}$ or $s_{6}$, which statistically lead the agent to visit $s_{6}$ before going back to $s_{1}$. Therefore, the agent obtains a significantly higher average reward of around 0.13 .</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: Average reward for 10 runs of our approach compared to Q-learning.</p>
<p><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 4: Number of visits (for states s<sup>3</sup> to s<sup>6</sup>) averaged over 1000 episodes. The initial state is s<sup>2</sup> and the terminal state is s<sup>1</sup>.</p>
<p>Figure 4 illustrates that the number of visits to states s<sup>3</sup>, s<sup>4</sup>, s<sup>5</sup>, s<sup>6</sup> increases with episodes of training. Each data point shows the average number of visits for each state over the last 1000 episodes. This indicates that our model is choosing goals in a way so that it reaches the critical state s<sup>6</sup> more often.</p>
<h3>4.2 ATARI game with delayed rewards</h3>
<p><strong>Game Description</strong> We consider 'Montezuma's Revenge', an ATARI game with sparse, delayed rewards. The game (Figure 5(a)) requires the player to navigate the explorer (in red) through several rooms while collecting treasures. In order to pass through doors (in the top right and top left corners of the figure), the player has to first pick up the key. The player has to then climb down the ladders on the right and move left towards the key, resulting in a long sequence of actions before receiving a reward (+100) for collecting the key. After this, navigating towards the door and opening it results in another reward (+300).</p>
<p>Existing deep RL approaches fail to learn in this environment since the agent rarely reaches a state with non-zero reward. For instance, the basic DQN [28] achieves a score of 0 while even the best performing system, Gorila DQN [30], manages only 4.16 on average.</p>
<p><strong>Setup</strong> The agent needs intrinsic motivation to explore meaningful parts of the scene before it can learn about the advantage of getting the key for itself. Inspired by the developmental psychology literature [43] and object-oriented MDPs [8], we use entities or objects in the scene to parameterize goals in this environment. Unsupervised detection of objects in visual scenes is an open problem in computer vision, although there has been recent progress in obtaining objects directly from image or motion data [10, 9, 14]. In this work, we built a custom object detector that provides plausible object candidates. The controller and</p>
<p><img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 5: (a) A sample screen from the ATARI 2600 game called 'Montezuma's Revenge'. (b) Architecture: DQN architecture for the controller $\left(Q_{1}\right)$. A similar architecture produces $Q_{2}$ for the meta-controller (without goal as input). In practice, both these networks could share lower level features but we do not enforce this.
meta-controller are convolutional neural networks (see Figure 5(b)) that learn representations from raw pixel data. We use the Arcade Learning Environment [2] to perform experiments.</p>
<p>The internal critic is defined in the space of $\left\langle\right.$ entity $<em 2="2">{1}$, relation, entity $\left.</em>$. For instance, the agent is deemed to have completed a goal (and receives a reward) if the agent entity reaches another entity such as the door. Note that this notion of relational intrinsic rewards can be generalized to other settings. For instance, in the ATARI game 'Asteroids', the agent could be rewarded when the bullet reaches the asteroid or if simply the ship never reaches an asteroid. In the game of 'Pacman', the agent could be rewarded if the pellets on the screen are reached. In the most general case, we can potentially let the model evolve a parameterized intrinsic reward function given entities. We leave this for future work.}\right\rangle$, where relation is a function over configurations of the entities. In our experiments, the agent is free to choose any entity ${ }_{2</p>
<p>Model Architecture and Training As shown in Figure 5b, the model consists of stacked convolutional layers with rectified linear units (ReLU). The input to the meta-controller is a set of four consecutive images of size $84 \times 84$. To encode the goal output from the meta-controller, we append a binary mask of the goal location in image space along with the original 4 consecutive frames. This augmented input is passed to the controller. The experience replay memories $\mathcal{D}<em 2="2">{1}$ and $\mathcal{D}</em>$ of the meta-controller to 1 and train the controller on actions. This effectively leads to pre-training the controller so that it can learn to solve a subset of the goals. (2) In the second phase, we jointly train the controller and meta-controller.}$ were set to be equal to 1 E 6 and 5 E 4 respectively. We set the learning rate to be $2.5 \mathrm{E}-4$, with a discount rate of 0.99 . We follow a two phase training procedure - (1) In the first phase, we set the exploration parameter $\epsilon_{2</p>
<p>Results Figure 6(a) shows reward progress from the joint training phase from which it is evident that the model starts gradually learning to both reach the key and open the door to get a reward of around +400 per episode. As shown in Figure 6(b), the agent learns to choose the key more often as training proceeds and is also successful at reaching it. As training proceeds, we observe that the agent first learns to perform the simpler goals (such as reaching the right door or the middle ladder) and then slowly starts learning the 'harder' goals such as the key and the bottom ladders, which provide a path to higher rewards. Figure 6(c) shows the evolution of the success rate of goals that are picked. At the end of training, we can see that the 'key', 'bottom-left-ladder' and 'bottom-right-ladders' are chosen increasingly more often. In order to scale-up to solve the entire game, several key ingredients are missing such as - automatic discovery of objects from videos to aid goal parametrization we considered, a flexible short-term memory, ability to intermittently terminate ongoing options.</p>
<p><img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>Figure 6: Results on Montezuma's Revenge: These plots depict the joint training phase of the model. As described in Section 4.2, the first training phase pre-trains the lower level controller for about 2.3 million steps. The joint training learns to consistently get high rewards after additional 2 million steps as shown in (a). (b) Goal success ratio: The agent learns to choose the key more often as training proceeds and is successful at achieving it. (c) Goal statistics: During early phases of joint training, all goals are equally preferred due to high exploration but as training proceeds, the agent learns to select appropriate goals such as the key and bottom-left door.</p>
<p>We also show some screen-shots from a test run with our agent (with epsilon set to 0.1) in Figure 7, as well as a sample animation of the run. ${ }^{1}$</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-6.jpeg" src="img-6.jpeg" /></p>
<p>Figure 7: Sample gameplay by our agent on Montezuma's Revenge: The four quadrants are arranged in a temporally coherent manner (top-left, top-right, bottom-left and bottom-right). At the very beginning, the meta-controller chooses key as the goal (illustrated in red). The controller then tries to satisfy this goal by taking a series of low level actions (only a subset shown) but fails due to colliding with the skull (the episode terminates here). The meta-controller then chooses the bottom-right ladder as the next goal and the controller terminates after reaching it. Subsequently, the meta-controller chooses the key and the top-right door and the controller is able to successfully achieve both these goals.</p>
<h1>5 Conclusion</h1>
<p>We have presented h-DQN, a framework consisting of hierarchical value functions operating at different time scales. Temporally decomposing the value function allows the agent to perform intrinsically motivated behavior, which in turn yields efficient exploration in environments with delayed rewards. We also observe that parameterizing intrinsic motivation in the space of entities and relations provides a promising avenue for building agents with temporally extended exploration. We also plan to explore alternative parameterizations of goals with h-DQN in the future.</p>
<p>The current framework has several missing components including automatically disentangling objects from raw pixels and a short-term memory. The state abstractions learnt by vanilla deep-Q-networks are not structured or sufficiently compositional. There has been recent work $[9,14,33,22,50,15,20]$ in using deep generative models to disentangle multiple factors of variations (objects, pose, location, etc) from pixel data. We hope that our work motivates the combination of deep generative models of images with h-DQN. Additionally, in order to handle longer range dependencies, the agent needs to store a history of previous goals, actions and representations. There has been some recent work in using recurrent networks in conjunction with reinforcement learning [18, 31]. In order to scale-up our approach to harder non-Markovian settings, it will be necessary to incorporate a flexible episodic memory module.</p>
<h1>Acknowledgements</h1>
<p>We would like to thank Vaibhav Unhelkar, Ramya Ramakrishnan, Sam Gershman, Michael Littman, Vlad Firoiu, Will Whitney, Max Kleiman-Weiner and Pedro Tsividis for critical feedback and discussions. We are grateful to receive support from the Center for Brain, Machines and Minds (NSF STC award CCF - 1231216) and the MIT OpenMind team.</p>
<h2>References</h2>
<p>[1] A. G. Barto and S. Mahadevan. Recent advances in hierarchical reinforcement learning. Discrete Event Dynamic Systems, 13(4):341-379, 2003.
[2] M. G. Bellemare, Y. Naddaf, J. Veness, and M. Bowling. The arcade learning environment: An evaluation platform for general agents. Journal of Artificial Intelligence Research, 2012.
[3] M. M. Botvinick, Y. Niv, and A. C. Barto. Hierarchically organized behavior and its neural foundations: A reinforcement learning perspective. Cognition, 113(3):262-280, 2009.
[4] L. C. Cobo, C. L. Isbell, and A. L. Thomaz. Object focused q-learning for autonomous agents. In Proceedings of the 2013 international conference on Autonomous agents and multi-agent systems, pages 1061-1068. International Foundation for Autonomous Agents and Multiagent Systems, 2013.
[5] P. Dayan. Improving generalization for temporal difference learning: The successor representation. Neural Computation, 5(4):613-624, 1993.
[6] P. Dayan and G. E. Hinton. Feudal reinforcement learning. In Advances in neural information processing systems, pages 271-271. Morgan Kaufmann Publishers, 1993.
[7] T. G. Dietterich. Hierarchical reinforcement learning with the maxq value function decomposition. J. Artif. Intell. Res.(JAIR), 13:227-303, 2000.
[8] C. Diuk, A. Cohen, and M. L. Littman. An object-oriented representation for efficient reinforcement learning. In Proceedings of the 25th international conference on Machine learning, pages $240-247$. ACM, 2008.
[9] S. Eslami, N. Heess, T. Weber, Y. Tassa, K. Kavukcuoglu, and G. E. Hinton. Attend, infer, repeat: Fast scene understanding with generative models. arXiv preprint arXiv:1603.08575, 2016.
[10] K. Fragkiadaki, P. Arbelaez, P. Felsen, and J. Malik. Learning to segment moving objects in videos. In Computer Vision and Pattern Recognition (CVPR), 2015 IEEE Conference on, pages 4083-4090. IEEE, 2015.
[11] M. Frank, J. Leitner, M. Stollenga, A. Förster, and J. Schmidhuber. Curiosity driven reinforcement learning for motion planning on humanoids. Intrinsic motivations and open-ended development in animals, humans, and robots, page 245, 2015.
[12] S. J. Gershman, C. D. Moore, M. T. Todd, K. A. Norman, and P. B. Sederberg. The successor representation and temporal context. Neural Computation, 24(6):1553-1568, 2012.
[13] S. Goel and M. Huber. Subgoal discovery for hierarchical reinforcement learning using learned policies. In FLAIRS conference, pages 346-350, 2003.
[14] K. Greff, R. K. Srivastava, and J. Schmidhuber. Binding via reconstruction clustering. arXiv preprint arXiv:1511.06418, 2015.
[15] K. Gregor, I. Danihelka, A. Graves, and D. Wierstra. Draw: A recurrent neural network for image generation. arXiv preprint arXiv:1502.04623, 2015.
[16] C. Guestrin, D. Koller, C. Gearhart, and N. Kanodia. Generalizing plans to new environments in relational mdps. In Proceedings of the 18th international joint conference on Artificial intelligence, pages 1003-1010. Morgan Kaufmann Publishers Inc., 2003.
[17] C. Guestrin, D. Koller, R. Parr, and S. Venkataraman. Efficient solution algorithms for factored mdps. Journal of Artificial Intelligence Research, pages 399-468, 2003.
[18] M. Hausknecht and P. Stone. Deep recurrent q-learning for partially observable mdps. arXiv preprint arXiv:1507.06527, 2015.
[19] N. Hernandez-Gardiol and S. Mahadevan. Hierarchical memory-based reinforcement learning. Advances in Neural Information Processing Systems, pages 1047-1053, 2001.
[20] J. Huang and K. Murphy. Efficient inference in occlusion-aware generative models of images. arXiv preprint arXiv:1511.06362, 2015.</p>
<p>[21] J. Koutník, J. Schmidhuber, and F. Gomez. Evolving deep unsupervised convolutional networks for vision-based reinforcement learning. In Proceedings of the 2014 conference on Genetic and evolutionary computation, pages 541-548. ACM, 2014.
[22] T. D. Kulkarni, W. F. Whitney, P. Kohli, and J. Tenenbaum. Deep convolutional inverse graphics network. In Advances in Neural Information Processing Systems, pages 2530-2538, 2015 .
[23] B. M. Lake, T. D. Ullman, J. B. Tenenbaum, and S. J. Gershman. Building machines that learn and think like people. arXiv preprint arXiv:1604.00289, 2016.
[24] M. C. Machado and M. Bowling. Learning purposeful behaviour in the absence of rewards. arXiv preprint arXiv:1605.07700, 2016.
[25] S. Mannor, I. Menache, A. Hoze, and U. Klein. Dynamic abstraction in reinforcement learning via clustering. In Proceedings of the twenty-first international conference on Machine learning, page 71. ACM, 2004.
[26] A. McGovern and A. G. Barto. Automatic discovery of subgoals in reinforcement learning using diverse density. Computer Science Department Faculty Publication Series, page 8, 2001.
[27] I. Menache, S. Mannor, and N. Shimkin. Q-cutdynamic discovery of sub-goals in reinforcement learning. In Machine Learning: ECML 2002, pages 295-306. Springer, 2002.
[28] V. Mnih, K. Kavukcuoglu, D. Silver, A. A. Rusu, J. Veness, M. G. Bellemare, A. Graves, M. Riedmiller, A. K. Fidjeland, G. Ostrovski, et al. Human-level control through deep reinforcement learning. Nature, 518(7540):529-533, 2015.
[29] S. Mohamed and D. J. Rezende. Variational information maximisation for intrinsically motivated reinforcement learning. In Advances in Neural Information Processing Systems, pages 2116-2124, 2015 .
[30] A. Nair, P. Srinivasan, S. Blackwell, C. Alcicek, R. Fearon, A. De Maria, V. Panneershelvam, M. Suleyman, C. Beattie, S. Petersen, et al. Massively parallel methods for deep reinforcement learning. arXiv preprint arXiv:1507.04296, 2015.
[31] K. Narasimhan, T. Kulkarni, and R. Barzilay. Language understanding for text-based games using deep reinforcement learning. arXiv preprint arXiv:1506.08941, 2015.
[32] I. Osband, C. Blundell, A. Pritzel, and B. Van Roy. Deep exploration via bootstrapped dqn. arXiv preprint arXiv:1602.04621, 2016.
[33] D. J. Rezende, S. Mohamed, I. Danihelka, K. Gregor, and D. Wierstra. One-shot generalization in deep generative models. arXiv preprint arXiv:1603.05106, 2016.
[34] T. Schaul, D. Horgan, K. Gregor, and D. Silver. Universal value function approximators. In Proceedings of the 32nd International Conference on Machine Learning (ICML-15), pages $1312-1320,2015$.
[35] T. Schaul, J. Quan, I. Antonoglou, and D. Silver. Prioritized experience replay. arXiv preprint arXiv:1511.05952, 2015.
[36] J. Schmidhuber. Formal theory of creativity, fun, and intrinsic motivation (1990-2010). Autonomous Mental Development, IEEE Transactions on, 2(3):230-247, 2010.
[37] D. Silver, A. Huang, C. J. Maddison, A. Guez, L. Sifre, G. van den Driessche, J. Schrittwieser, I. Antonoglou, V. Panneershelvam, M. Lanctot, et al. Mastering the game of go with deep neural networks and tree search. Nature, 529(7587):484-489, 2016.
[38] Ö. Şimşek, A. Wolfe, and A. Barto. Identifying useful subgoals in reinforcement learning by local graph partitioning. In Proceedings of the International conference on Machine learning, pages $816-823,2005$.
[39] S. Singh, R. L. Lewis, and A. G. Barto. Where do rewards come from. In Proceedings of the annual conference of the cognitive science society, pages 2601-2606, 2009.
[40] S. Singh, R. L. Lewis, A. G. Barto, and J. Sorg. Intrinsically motivated reinforcement learning: An evolutionary perspective. Autonomous Mental Development, IEEE Transactions on, 2(2):70$82,2010$.
[41] S. P. Singh, A. G. Barto, and N. Chentanez. Intrinsically motivated reinforcement learning. In Advances in neural information processing systems, pages 1281-1288, 2004.
[42] J. Sorg and S. Singh. Linear options. In Proceedings of the 9th International Conference on Autonomous Agents and Multiagent Systems: Volume 1 - Volume 1, AAMAS '10, pages 31-38, Richland, SC, 2010. International Foundation for Autonomous Agents and Multiagent Systems.
[43] E. S. Spelke and K. D. Kinzler. Core knowledge. Developmental science, 10(1):89-96, 2007.</p>
<p>[44] K. L. Stachenfeld, M. Botvinick, and S. J. Gershman. Design principles of the hippocampal cognitive map. In Advances in neural information processing systems, pages 2528-2536, 2014.
[45] B. C. Stadie, S. Levine, and P. Abbeel. Incentivizing exploration in reinforcement learning with deep predictive models. arXiv preprint arXiv:1507.00814, 2015.
[46] R. S. Sutton and A. G. Barto. Introduction to reinforcement learning, volume 135. MIT Press Cambridge, 1998.
[47] R. S. Sutton, J. Modayil, M. Delp, T. Degris, P. M. Pilarski, A. White, and D. Precup. Horde: A scalable real-time architecture for learning knowledge from unsupervised sensorimotor interaction. In The 10th International Conference on Autonomous Agents and Multiagent Systems-Volume 2, pages 761-768. International Foundation for Autonomous Agents and Multiagent Systems, 2011.
[48] R. S. Sutton, D. Precup, and S. Singh. Between mdps and semi-mdps: A framework for temporal abstraction in reinforcement learning. Artificial intelligence, 112(1):181-211, 1999.
[49] C. Szepesvari, R. S. Sutton, J. Modayil, S. Bhatnagar, et al. Universal option models. In Advances in Neural Information Processing Systems, pages 990-998, 2014.
[50] W. F. Whitney, M. Chang, T. Kulkarni, and J. B. Tenenbaum. Understanding visual concepts with continuation learning. arXiv preprint arXiv:1602.06822, 2016.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{1}$ Sample trajectory of a run on 'Montezuma's Revenge' - https://goo.gl/3Z64Ji&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>