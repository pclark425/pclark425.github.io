<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-1373 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-1373</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-1373</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-28.html">extraction-schema-28</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of navigation in text-based games or text worlds, including graph-topology features of the environments (such as diameter, clustering coefficient, dead-ends, door constraints, connectivity), exploration efficiency metrics, and how these relate to agent performance and policy structure.</div>
                <p><strong>Paper ID:</strong> paper-0a053f55804eee01f3c8b4138a1d3364d5bc45ac</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/0a053f55804eee01f3c8b4138a1d3364d5bc45ac" target="_blank">M-Walk: Learning to Walk over Graphs using Monte Carlo Tree Search</a></p>
                <p><strong>Paper Venue:</strong> Neural Information Processing Systems</p>
                <p><strong>Paper TL;DR:</strong> Experimental results on several graph-walking benchmarks show that M-Walk is able to learn better policies than other RL-based methods, which are mainly based on policy gradients.</p>
                <p><strong>Paper Abstract:</strong> Learning to walk over a graph towards a target node for a given query and a source node is an important problem in applications such as knowledge base completion (KBC). It can be formulated as a reinforcement learning (RL) problem with a known state transition model. To overcome the challenge of sparse rewards, we develop a graph-walking agent called M-Walk, which consists of a deep recurrent neural network (RNN) and Monte Carlo Tree Search (MCTS). The RNN encodes the state (i.e., history of the walked path) and maps it separately to a policy and Q-values. In order to effectively train the agent from sparse rewards, we combine MCTS with the neural policy to generate trajectories yielding more positive rewards. From these trajectories, the network is improved in an off-policy manner using Q-learning, which modifies the RNN policy via parameter sharing. Our proposed RL algorithm repeatedly applies this policy-improvement step to learn the model. At test time, MCTS is combined with the neural policy to predict the target node. Experimental results on several graph-walking benchmarks show that M-Walk is able to learn better policies than other RL-based methods, which are mainly based on policy gradients. M-Walk also outperforms traditional KBC baselines.</p>
                <p><strong>Cost:</strong> 0.017</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e1373.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e1373.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of navigation in text-based games or text worlds, including graph-topology features of the environments (such as diameter, clustering coefficient, dead-ends, door constraints, connectivity), exploration efficiency metrics, and how these relate to agent performance and policy structure.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Three Glass Puzzle</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Three Glass Puzzle (state-space graph)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A synthetic puzzle formulated as a graph-walking environment where nodes are triplets (a,b,c) of liquid amounts in three containers and edges correspond to actions (fill, empty, pour). Used to study search and exploration in a compact, structured state graph with sparse terminal rewards.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>environment_name</strong></td>
                            <td>Three Glass Puzzle</td>
                        </tr>
                        <tr>
                            <td><strong>environment_description</strong></td>
                            <td>A math-puzzle-style environment: each node encodes the current volumes in three containers (a,b,c); actions are fill, empty, or pour between containers; the query is a target volume q; reward is +1 if any container equals q at termination, otherwise 0.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_diameter</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>clustering_coefficient</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>dead_ends_present</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>dead_ends_count</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>door_constraints_present</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>door_constraints_description</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>graph_connectivity</strong></td>
                            <td>Implicit directed/undirected state graph defined by legal container operations; connectivity depends on capacities (A,B,C); relatively sparse local branching (13 actions in experiments including STOP).</td>
                        </tr>
                        <tr>
                            <td><strong>environment_size</strong></td>
                            <td>Variable per puzzle: state nodes correspond to all possible (a,b,c) with 0..A,0..B,0..C (i.e., up to (A+1)*(B+1)*(C+1)); dataset used: 600 unique puzzles (500 train, 100 test). Exact graph sizes per puzzle not reported.</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>M-Walk (RNN+MCTS)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>GRU-based RNN encoder of trajectory history + action encoders; policy and Q-value share parameters; Monte Carlo Tree Search (PUCT variant) used to generate higher-quality trajectories; Q-learning updates applied off-policy to shared parameters.</td>
                        </tr>
                        <tr>
                            <td><strong>exploration_efficiency_metric</strong></td>
                            <td>Positive reward rate during training (fraction of rollouts producing positive terminal reward), average # steps to reach target, test success rate/accuracy.</td>
                        </tr>
                        <tr>
                            <td><strong>exploration_efficiency_value</strong></td>
                            <td>Positive reward rate: M-Walk produces substantially more positive-reward trajectories than policy-gradient baseline (exact curves in Figure 4 but not tabulated); average # steps to reach target (cheating setup with target revealed): M-Walk 94.9 steps (avg), BFS 264.7, DFS 192.2; max steps: M-Walk 897, BFS 1030, DFS 1453.</td>
                        </tr>
                        <tr>
                            <td><strong>success_rate</strong></td>
                            <td>Test accuracy (best reported): M-Walk (MCTS, large rollouts) up to 99.0% (Table 7, with 400 rollouts); baseline REINFORCE best ~49.0%.</td>
                        </tr>
                        <tr>
                            <td><strong>optimal_policy_type</strong></td>
                            <td>Memory-based + planning: policies that encode trajectory history (RNN) and use planning (MCTS) perform best in this sparse-reward combinatorial graph.</td>
                        </tr>
                        <tr>
                            <td><strong>topology_performance_relationship</strong></td>
                            <td>No explicit numerical diameter/clustering statistics provided; qualitative findings: model-based planning (MCTS) substantially improves exploration efficiency in sparse graphs; M-Walk finds targets in fewer steps than blind search (BFS/DFS) in the cheating setup, indicating learned heuristics + planning exploit graph structure efficiently.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_across_topologies</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>topology_comparison_results</strong></td>
                            <td>Not applicable — the paper varies puzzle instances (capacities) but does not provide a systematic comparison across standard graph-topology measures (diameter, clustering coefficient).</td>
                        </tr>
                        <tr>
                            <td><strong>policy_structure_findings</strong></td>
                            <td>Because the correct next action often depends on full traversal history and the query, RNN (GRU) state encoding is essential; combining this memoryful policy with planning (MCTS) yields much higher positive-reward trajectory rates and final success than reactive policy-gradient alone.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'M-Walk: Learning to Walk over Graphs using Monte Carlo Tree Search', 'publication_date_yy_mm': '2018-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1373.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e1373.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of navigation in text-based games or text worlds, including graph-topology features of the environments (such as diameter, clustering coefficient, dead-ends, door constraints, connectivity), exploration efficiency metrics, and how these relate to agent performance and policy structure.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>NELL-995</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>NELL-995 knowledge graph dataset</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A real-world knowledge graph dataset containing entities and relations (multiple subgraphs per relation) used for knowledge base completion tasks formulated as graph-walking/policy learning problems.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>environment_name</strong></td>
                            <td>NELL-995 knowledge graph</td>
                        </tr>
                        <tr>
                            <td><strong>environment_description</strong></td>
                            <td>Knowledge base graph where nodes are entities and edges are relation triples; per-relation graphs studied for link-prediction (predict target entity given source and relation). Domain: knowledge graph / semantic relation navigation.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_diameter</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>clustering_coefficient</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>dead_ends_present</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>dead_ends_count</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>door_constraints_present</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>door_constraints_description</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>graph_connectivity</strong></td>
                            <td>Sparse knowledge graph: reported average degree 4.07 and median degree 1 (Table 6); topology is sparse and heterogenous with many low-degree nodes.</td>
                        </tr>
                        <tr>
                            <td><strong>environment_size</strong></td>
                            <td>Dataset statistics (Table 6): #Train triples 154,213; #Test 3,992; #Relations 200; #Entities 75,492; avg. degree 4.07; median degree 1.</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>M-Walk (RNN+MCTS); baselines: PG-Walk (policy-gradient with same architecture), Q-Walk (Q-learning only), MINERVA, DeepPath, embedding models (DistMult, ComplEx, ConvE), NeuralLP</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Agent uses GRU-based history encoder and FC action encoders to map state to shared policy and Q-values; PUCT-style MCTS uses the learned policy as a prior; training alternates MCTS trajectory generation and off-policy Q-learning updates (parameters shared with policy).</td>
                        </tr>
                        <tr>
                            <td><strong>exploration_efficiency_metric</strong></td>
                            <td>MAP (mean average precision) for ranking; positive reward rate during training; HITS@K and MRR for evaluation; also 'out-of-candidate-set' proportion (fraction of errors caused by ground truth not being among MCTS candidates).</td>
                        </tr>
                        <tr>
                            <td><strong>exploration_efficiency_value</strong></td>
                            <td>Overall MAP (Table 1): M-Walk 89.9% (overall across 10 relations). HITS@1 (Table 9): 68.4%; HITS@3: 81.0%; MRR: 75.4%. Positive-reward rate during training is higher for M-Walk than PG-Walk/Q-Walk (Figure 4 / Figure 8) but exact numeric curves are in figures, not tabulated.</td>
                        </tr>
                        <tr>
                            <td><strong>success_rate</strong></td>
                            <td>Shown via ranking metrics: MAP 89.9% (overall), HITS@1 68.4%, MRR 75.4% (Table 9).</td>
                        </tr>
                        <tr>
                            <td><strong>optimal_policy_type</strong></td>
                            <td>Memory-based + planning: policies that encode traversal history (RNN) and leverage planning (MCTS) to generate candidate nodes and search trajectories are most effective on sparse, multi-step relational queries.</td>
                        </tr>
                        <tr>
                            <td><strong>topology_performance_relationship</strong></td>
                            <td>Reported relationships: (1) M-Walk outperforms embedding methods (ConvE) on multi-step reasoning (examples with BFS distance 2 or 3) by 4.6–10.9% in HITS@1, indicating that longer path (higher effective distance) cases benefit from walk-based/planning policies; (2) sparse graphs with many low-degree nodes mean candidate coverage matters — out-of-candidate-set errors are the predominant failure mode for M-Walk; (3) average degree (sparsity) implies fewer local actions, making MCTS rollouts and candidate coverage critical.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_across_topologies</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>topology_comparison_results</strong></td>
                            <td>Comparison is limited but informative: (a) stratifying test examples by BFS path length from source to target shows M-Walk yields larger gains on two- and three-step reasoning than on one-step cases; (b) datasets with differing degrees (avg degree) show differences in candidate set sizes and sensitivity — e.g., FB15k-237 is denser (avg degree ~19.7) and M-Walk underperforms strongest embedding methods there.</td>
                        </tr>
                        <tr>
                            <td><strong>policy_structure_findings</strong></td>
                            <td>Policies must be history-aware (RNN) because current node alone is insufficient; combining learned policy with planning increases sample efficiency and positive-reward trajectory rates; shared Q/policy parameters allow off-policy MCTS trajectories to improve the policy via Q-learning; limited candidate coverage (insufficient rollouts) leads to out-of-candidate-set errors, suggesting policy structure must also enable broader candidate generation or more rollouts.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'M-Walk: Learning to Walk over Graphs using Monte Carlo Tree Search', 'publication_date_yy_mm': '2018-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1373.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e1373.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of navigation in text-based games or text worlds, including graph-topology features of the environments (such as diameter, clustering coefficient, dead-ends, door constraints, connectivity), exploration efficiency metrics, and how these relate to agent performance and policy structure.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>WN18RR</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>WN18RR knowledge graph dataset</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A knowledge graph (WordNet-derived) dataset for link prediction with inverse-relation leakage removed, used to evaluate graph-walking agents on reasoning over multi-step relation paths.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>environment_name</strong></td>
                            <td>WN18RR knowledge graph</td>
                        </tr>
                        <tr>
                            <td><strong>environment_description</strong></td>
                            <td>Knowledge graph where nodes are WordNet entities and edges are semantic relations; used for link-prediction/navigation tasks where the agent must find target entities by walking relation-edges from a source given a query relation.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_diameter</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>clustering_coefficient</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>dead_ends_present</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>dead_ends_count</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>door_constraints_present</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>door_constraints_description</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>graph_connectivity</strong></td>
                            <td>Very sparse: reported average degree 2.19 and median degree 2 (Table 6); relatively low branching factor per node.</td>
                        </tr>
                        <tr>
                            <td><strong>environment_size</strong></td>
                            <td>Dataset statistics (Table 6): #Train triples 86,835; #Test 3,134; #Relations 11; #Entities 40,943; avg. degree 2.19; median degree 2.</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>M-Walk (RNN+MCTS) and baselines (PG-Walk, Q-Walk, MINERVA, embedding methods such as ConvE/ComplEx/DistMult, NeuralLP).</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Same architecture as above: GRU encoder for history, FCNs for action encodings, shared policy/Q networks, and PUCT MCTS to generate rollouts used for off-policy Q-learning updates; at test time MCTS + network produce candidate terminal nodes and scores.</td>
                        </tr>
                        <tr>
                            <td><strong>exploration_efficiency_metric</strong></td>
                            <td>HITS@K, MRR, positive reward rate during training, sensitivity to search-horizon and number of MCTS rollouts (ablation). Also test-time time-per-sample and training wall-clock reported.</td>
                        </tr>
                        <tr>
                            <td><strong>exploration_efficiency_value</strong></td>
                            <td>Performance (Table 2): HITS@1 41.4%, HITS@3 44.5%, MRR 43.7% (M-Walk). Sensitivity analysis: model more sensitive to number of MCTS rollouts than to search horizon (Figure 5(a)); concrete rollout settings used: 128 rollouts at test for WN18RR in experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>success_rate</strong></td>
                            <td>Reported via ranking metrics (HITS/MRR) rather than absolute success rate: M-Walk MRR 43.7%, HITS@1 41.4%. Positive-reward trajectory rates during training are higher for M-Walk than baselines (figures).</td>
                        </tr>
                        <tr>
                            <td><strong>optimal_policy_type</strong></td>
                            <td>Memory-based + planning (RNN + MCTS); planning prior (policy used as prior in PUCT) enhances exploration efficiency especially in sparse low-degree graphs.</td>
                        </tr>
                        <tr>
                            <td><strong>topology_performance_relationship</strong></td>
                            <td>Key reported relations: (1) M-Walk provides larger relative improvement for targets requiring multi-step paths (length 2–3) versus single-step targets; (2) the model's performance is more sensitive to the number of MCTS rollouts than the horizon length, implying that breadth of search/coverage (candidate generation) in sparse graphs is more important than deeper lookahead in these datasets.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_across_topologies</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>topology_comparison_results</strong></td>
                            <td>Paper compares performance across path-length categories (BFS distances) and across datasets of differing average degrees; it finds M-Walk advantages increase with required reasoning path length and that denser datasets (higher avg degree) change relative competitiveness versus embedding models.</td>
                        </tr>
                        <tr>
                            <td><strong>policy_structure_findings</strong></td>
                            <td>History encoding via GRU is necessary because local node information is insufficient; using the learned policy as a prior in MCTS (PUCT) yields better rollouts and higher positive-reward trajectory rates; sharing parameters between Q and policy allows off-policy trajectories from MCTS to improve the policy via Q-learning; candidate-set coverage driven by rollout count strongly influences final performance.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'M-Walk: Learning to Walk over Graphs using Monte Carlo Tree Search', 'publication_date_yy_mm': '2018-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1373.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e1373.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of navigation in text-based games or text worlds, including graph-topology features of the environments (such as diameter, clustering coefficient, dead-ends, door constraints, connectivity), exploration efficiency metrics, and how these relate to agent performance and policy structure.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>FB15k-237</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>FB15k-237 knowledge graph dataset</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A denser knowledge graph subset of FB15k with inverse relations removed; used to test scalability and performance of graph-walking agents on denser relational graphs.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>environment_name</strong></td>
                            <td>FB15k-237 knowledge graph</td>
                        </tr>
                        <tr>
                            <td><strong>environment_description</strong></td>
                            <td>Knowledge graph derived from Freebase subset, nodes are entities and edges are relations; denser than WN18RR/NELL995 and commonly used for link-prediction evaluation.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_diameter</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>clustering_coefficient</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>dead_ends_present</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>dead_ends_count</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>door_constraints_present</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>door_constraints_description</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>graph_connectivity</strong></td>
                            <td>Relatively dense compared to other datasets used: reported average degree 19.74 and median degree 14 (Table 6).</td>
                        </tr>
                        <tr>
                            <td><strong>environment_size</strong></td>
                            <td>Dataset statistics (Table 6): #Train triples 272,115; #Test 20,466; #Relations 237; #Entities 14,541; avg. degree 19.74; median degree 14.</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>M-Walk (RNN+MCTS) and baselines (MINERVA, embedding models ConvE/ComplEx/DistMult, NeuralLP).</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Same M-Walk architecture; experiments show M-Walk outperforms other RL-based walk agents but is still behind best embedding-based methods on FB15k-237, suggesting limitations when graphs are denser.</td>
                        </tr>
                        <tr>
                            <td><strong>exploration_efficiency_metric</strong></td>
                            <td>HITS@K, MRR used for evaluation; sensitivity to rollouts/horizon reported qualitatively.</td>
                        </tr>
                        <tr>
                            <td><strong>exploration_efficiency_value</strong></td>
                            <td>Reported results: M-Walk HITS@1 16.5%, HITS@3 24.3%, MRR 23.2% (Table 10) — better than other RL walk baselines but worse than top embedding methods (e.g., ConvE).</td>
                        </tr>
                        <tr>
                            <td><strong>success_rate</strong></td>
                            <td>Expressed via ranking metrics: HITS@1 16.5%, HITS@3 24.3%, MRR 23.2%.</td>
                        </tr>
                        <tr>
                            <td><strong>optimal_policy_type</strong></td>
                            <td>Planning + learned policy still useful, but embedding-based global scoring methods remain competitive or superior on denser graphs where exhaustive candidate ranking is feasible.</td>
                        </tr>
                        <tr>
                            <td><strong>topology_performance_relationship</strong></td>
                            <td>Denser graphs (higher avg degree) reduce the relative advantage of walk-based/planning methods compared to embedding-based methods because embedding approaches can exploit dense global structure; walk-based approaches may struggle to cover candidate space without many rollouts.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_across_topologies</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>topology_comparison_results</strong></td>
                            <td>Across datasets of differing density, M-Walk is relatively stronger on sparser graphs and in multi-step reasoning tasks, while embedding methods outperform on dense graphs where candidate coverage via global scoring is feasible.</td>
                        </tr>
                        <tr>
                            <td><strong>policy_structure_findings</strong></td>
                            <td>In denser graphs, policies must either (a) support much larger candidate coverage (many rollouts) or (b) be combined with global scoring/embedding models; otherwise out-of-candidate-set errors and limited rollout budgets restrict performance.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'M-Walk: Learning to Walk over Graphs using Monte Carlo Tree Search', 'publication_date_yy_mm': '2018-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>DeepPath: A reinforcement learning method for knowledge graph reasoning <em>(Rating: 2)</em></li>
                <li>Go for a walk and arrive at the answer: Reasoning over paths in knowledge bases using reinforcement learning (MINERVA) <em>(Rating: 2)</em></li>
                <li>Mastering the game of Go with deep neural networks and tree search <em>(Rating: 2)</em></li>
                <li>Mastering the game of Go without human knowledge <em>(Rating: 1)</em></li>
                <li>Differentiable learning of logical rules for knowledge base reasoning (NeuralLP) <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-1373",
    "paper_id": "paper-0a053f55804eee01f3c8b4138a1d3364d5bc45ac",
    "extraction_schema_id": "extraction-schema-28",
    "extracted_data": [
        {
            "name_short": "Three Glass Puzzle",
            "name_full": "Three Glass Puzzle (state-space graph)",
            "brief_description": "A synthetic puzzle formulated as a graph-walking environment where nodes are triplets (a,b,c) of liquid amounts in three containers and edges correspond to actions (fill, empty, pour). Used to study search and exploration in a compact, structured state graph with sparse terminal rewards.",
            "citation_title": "here",
            "mention_or_use": "use",
            "environment_name": "Three Glass Puzzle",
            "environment_description": "A math-puzzle-style environment: each node encodes the current volumes in three containers (a,b,c); actions are fill, empty, or pour between containers; the query is a target volume q; reward is +1 if any container equals q at termination, otherwise 0.",
            "graph_diameter": null,
            "clustering_coefficient": null,
            "dead_ends_present": null,
            "dead_ends_count": null,
            "door_constraints_present": false,
            "door_constraints_description": "",
            "graph_connectivity": "Implicit directed/undirected state graph defined by legal container operations; connectivity depends on capacities (A,B,C); relatively sparse local branching (13 actions in experiments including STOP).",
            "environment_size": "Variable per puzzle: state nodes correspond to all possible (a,b,c) with 0..A,0..B,0..C (i.e., up to (A+1)*(B+1)*(C+1)); dataset used: 600 unique puzzles (500 train, 100 test). Exact graph sizes per puzzle not reported.",
            "agent_name": "M-Walk (RNN+MCTS)",
            "agent_description": "GRU-based RNN encoder of trajectory history + action encoders; policy and Q-value share parameters; Monte Carlo Tree Search (PUCT variant) used to generate higher-quality trajectories; Q-learning updates applied off-policy to shared parameters.",
            "exploration_efficiency_metric": "Positive reward rate during training (fraction of rollouts producing positive terminal reward), average # steps to reach target, test success rate/accuracy.",
            "exploration_efficiency_value": "Positive reward rate: M-Walk produces substantially more positive-reward trajectories than policy-gradient baseline (exact curves in Figure 4 but not tabulated); average # steps to reach target (cheating setup with target revealed): M-Walk 94.9 steps (avg), BFS 264.7, DFS 192.2; max steps: M-Walk 897, BFS 1030, DFS 1453.",
            "success_rate": "Test accuracy (best reported): M-Walk (MCTS, large rollouts) up to 99.0% (Table 7, with 400 rollouts); baseline REINFORCE best ~49.0%.",
            "optimal_policy_type": "Memory-based + planning: policies that encode trajectory history (RNN) and use planning (MCTS) perform best in this sparse-reward combinatorial graph.",
            "topology_performance_relationship": "No explicit numerical diameter/clustering statistics provided; qualitative findings: model-based planning (MCTS) substantially improves exploration efficiency in sparse graphs; M-Walk finds targets in fewer steps than blind search (BFS/DFS) in the cheating setup, indicating learned heuristics + planning exploit graph structure efficiently.",
            "comparison_across_topologies": false,
            "topology_comparison_results": "Not applicable — the paper varies puzzle instances (capacities) but does not provide a systematic comparison across standard graph-topology measures (diameter, clustering coefficient).",
            "policy_structure_findings": "Because the correct next action often depends on full traversal history and the query, RNN (GRU) state encoding is essential; combining this memoryful policy with planning (MCTS) yields much higher positive-reward trajectory rates and final success than reactive policy-gradient alone.",
            "uuid": "e1373.0",
            "source_info": {
                "paper_title": "M-Walk: Learning to Walk over Graphs using Monte Carlo Tree Search",
                "publication_date_yy_mm": "2018-02"
            }
        },
        {
            "name_short": "NELL-995",
            "name_full": "NELL-995 knowledge graph dataset",
            "brief_description": "A real-world knowledge graph dataset containing entities and relations (multiple subgraphs per relation) used for knowledge base completion tasks formulated as graph-walking/policy learning problems.",
            "citation_title": "here",
            "mention_or_use": "use",
            "environment_name": "NELL-995 knowledge graph",
            "environment_description": "Knowledge base graph where nodes are entities and edges are relation triples; per-relation graphs studied for link-prediction (predict target entity given source and relation). Domain: knowledge graph / semantic relation navigation.",
            "graph_diameter": null,
            "clustering_coefficient": null,
            "dead_ends_present": null,
            "dead_ends_count": null,
            "door_constraints_present": false,
            "door_constraints_description": "",
            "graph_connectivity": "Sparse knowledge graph: reported average degree 4.07 and median degree 1 (Table 6); topology is sparse and heterogenous with many low-degree nodes.",
            "environment_size": "Dataset statistics (Table 6): #Train triples 154,213; #Test 3,992; #Relations 200; #Entities 75,492; avg. degree 4.07; median degree 1.",
            "agent_name": "M-Walk (RNN+MCTS); baselines: PG-Walk (policy-gradient with same architecture), Q-Walk (Q-learning only), MINERVA, DeepPath, embedding models (DistMult, ComplEx, ConvE), NeuralLP",
            "agent_description": "Agent uses GRU-based history encoder and FC action encoders to map state to shared policy and Q-values; PUCT-style MCTS uses the learned policy as a prior; training alternates MCTS trajectory generation and off-policy Q-learning updates (parameters shared with policy).",
            "exploration_efficiency_metric": "MAP (mean average precision) for ranking; positive reward rate during training; HITS@K and MRR for evaluation; also 'out-of-candidate-set' proportion (fraction of errors caused by ground truth not being among MCTS candidates).",
            "exploration_efficiency_value": "Overall MAP (Table 1): M-Walk 89.9% (overall across 10 relations). HITS@1 (Table 9): 68.4%; HITS@3: 81.0%; MRR: 75.4%. Positive-reward rate during training is higher for M-Walk than PG-Walk/Q-Walk (Figure 4 / Figure 8) but exact numeric curves are in figures, not tabulated.",
            "success_rate": "Shown via ranking metrics: MAP 89.9% (overall), HITS@1 68.4%, MRR 75.4% (Table 9).",
            "optimal_policy_type": "Memory-based + planning: policies that encode traversal history (RNN) and leverage planning (MCTS) to generate candidate nodes and search trajectories are most effective on sparse, multi-step relational queries.",
            "topology_performance_relationship": "Reported relationships: (1) M-Walk outperforms embedding methods (ConvE) on multi-step reasoning (examples with BFS distance 2 or 3) by 4.6–10.9% in HITS@1, indicating that longer path (higher effective distance) cases benefit from walk-based/planning policies; (2) sparse graphs with many low-degree nodes mean candidate coverage matters — out-of-candidate-set errors are the predominant failure mode for M-Walk; (3) average degree (sparsity) implies fewer local actions, making MCTS rollouts and candidate coverage critical.",
            "comparison_across_topologies": true,
            "topology_comparison_results": "Comparison is limited but informative: (a) stratifying test examples by BFS path length from source to target shows M-Walk yields larger gains on two- and three-step reasoning than on one-step cases; (b) datasets with differing degrees (avg degree) show differences in candidate set sizes and sensitivity — e.g., FB15k-237 is denser (avg degree ~19.7) and M-Walk underperforms strongest embedding methods there.",
            "policy_structure_findings": "Policies must be history-aware (RNN) because current node alone is insufficient; combining learned policy with planning increases sample efficiency and positive-reward trajectory rates; shared Q/policy parameters allow off-policy MCTS trajectories to improve the policy via Q-learning; limited candidate coverage (insufficient rollouts) leads to out-of-candidate-set errors, suggesting policy structure must also enable broader candidate generation or more rollouts.",
            "uuid": "e1373.1",
            "source_info": {
                "paper_title": "M-Walk: Learning to Walk over Graphs using Monte Carlo Tree Search",
                "publication_date_yy_mm": "2018-02"
            }
        },
        {
            "name_short": "WN18RR",
            "name_full": "WN18RR knowledge graph dataset",
            "brief_description": "A knowledge graph (WordNet-derived) dataset for link prediction with inverse-relation leakage removed, used to evaluate graph-walking agents on reasoning over multi-step relation paths.",
            "citation_title": "here",
            "mention_or_use": "use",
            "environment_name": "WN18RR knowledge graph",
            "environment_description": "Knowledge graph where nodes are WordNet entities and edges are semantic relations; used for link-prediction/navigation tasks where the agent must find target entities by walking relation-edges from a source given a query relation.",
            "graph_diameter": null,
            "clustering_coefficient": null,
            "dead_ends_present": null,
            "dead_ends_count": null,
            "door_constraints_present": false,
            "door_constraints_description": "",
            "graph_connectivity": "Very sparse: reported average degree 2.19 and median degree 2 (Table 6); relatively low branching factor per node.",
            "environment_size": "Dataset statistics (Table 6): #Train triples 86,835; #Test 3,134; #Relations 11; #Entities 40,943; avg. degree 2.19; median degree 2.",
            "agent_name": "M-Walk (RNN+MCTS) and baselines (PG-Walk, Q-Walk, MINERVA, embedding methods such as ConvE/ComplEx/DistMult, NeuralLP).",
            "agent_description": "Same architecture as above: GRU encoder for history, FCNs for action encodings, shared policy/Q networks, and PUCT MCTS to generate rollouts used for off-policy Q-learning updates; at test time MCTS + network produce candidate terminal nodes and scores.",
            "exploration_efficiency_metric": "HITS@K, MRR, positive reward rate during training, sensitivity to search-horizon and number of MCTS rollouts (ablation). Also test-time time-per-sample and training wall-clock reported.",
            "exploration_efficiency_value": "Performance (Table 2): HITS@1 41.4%, HITS@3 44.5%, MRR 43.7% (M-Walk). Sensitivity analysis: model more sensitive to number of MCTS rollouts than to search horizon (Figure 5(a)); concrete rollout settings used: 128 rollouts at test for WN18RR in experiments.",
            "success_rate": "Reported via ranking metrics (HITS/MRR) rather than absolute success rate: M-Walk MRR 43.7%, HITS@1 41.4%. Positive-reward trajectory rates during training are higher for M-Walk than baselines (figures).",
            "optimal_policy_type": "Memory-based + planning (RNN + MCTS); planning prior (policy used as prior in PUCT) enhances exploration efficiency especially in sparse low-degree graphs.",
            "topology_performance_relationship": "Key reported relations: (1) M-Walk provides larger relative improvement for targets requiring multi-step paths (length 2–3) versus single-step targets; (2) the model's performance is more sensitive to the number of MCTS rollouts than the horizon length, implying that breadth of search/coverage (candidate generation) in sparse graphs is more important than deeper lookahead in these datasets.",
            "comparison_across_topologies": true,
            "topology_comparison_results": "Paper compares performance across path-length categories (BFS distances) and across datasets of differing average degrees; it finds M-Walk advantages increase with required reasoning path length and that denser datasets (higher avg degree) change relative competitiveness versus embedding models.",
            "policy_structure_findings": "History encoding via GRU is necessary because local node information is insufficient; using the learned policy as a prior in MCTS (PUCT) yields better rollouts and higher positive-reward trajectory rates; sharing parameters between Q and policy allows off-policy trajectories from MCTS to improve the policy via Q-learning; candidate-set coverage driven by rollout count strongly influences final performance.",
            "uuid": "e1373.2",
            "source_info": {
                "paper_title": "M-Walk: Learning to Walk over Graphs using Monte Carlo Tree Search",
                "publication_date_yy_mm": "2018-02"
            }
        },
        {
            "name_short": "FB15k-237",
            "name_full": "FB15k-237 knowledge graph dataset",
            "brief_description": "A denser knowledge graph subset of FB15k with inverse relations removed; used to test scalability and performance of graph-walking agents on denser relational graphs.",
            "citation_title": "here",
            "mention_or_use": "use",
            "environment_name": "FB15k-237 knowledge graph",
            "environment_description": "Knowledge graph derived from Freebase subset, nodes are entities and edges are relations; denser than WN18RR/NELL995 and commonly used for link-prediction evaluation.",
            "graph_diameter": null,
            "clustering_coefficient": null,
            "dead_ends_present": null,
            "dead_ends_count": null,
            "door_constraints_present": false,
            "door_constraints_description": "",
            "graph_connectivity": "Relatively dense compared to other datasets used: reported average degree 19.74 and median degree 14 (Table 6).",
            "environment_size": "Dataset statistics (Table 6): #Train triples 272,115; #Test 20,466; #Relations 237; #Entities 14,541; avg. degree 19.74; median degree 14.",
            "agent_name": "M-Walk (RNN+MCTS) and baselines (MINERVA, embedding models ConvE/ComplEx/DistMult, NeuralLP).",
            "agent_description": "Same M-Walk architecture; experiments show M-Walk outperforms other RL-based walk agents but is still behind best embedding-based methods on FB15k-237, suggesting limitations when graphs are denser.",
            "exploration_efficiency_metric": "HITS@K, MRR used for evaluation; sensitivity to rollouts/horizon reported qualitatively.",
            "exploration_efficiency_value": "Reported results: M-Walk HITS@1 16.5%, HITS@3 24.3%, MRR 23.2% (Table 10) — better than other RL walk baselines but worse than top embedding methods (e.g., ConvE).",
            "success_rate": "Expressed via ranking metrics: HITS@1 16.5%, HITS@3 24.3%, MRR 23.2%.",
            "optimal_policy_type": "Planning + learned policy still useful, but embedding-based global scoring methods remain competitive or superior on denser graphs where exhaustive candidate ranking is feasible.",
            "topology_performance_relationship": "Denser graphs (higher avg degree) reduce the relative advantage of walk-based/planning methods compared to embedding-based methods because embedding approaches can exploit dense global structure; walk-based approaches may struggle to cover candidate space without many rollouts.",
            "comparison_across_topologies": true,
            "topology_comparison_results": "Across datasets of differing density, M-Walk is relatively stronger on sparser graphs and in multi-step reasoning tasks, while embedding methods outperform on dense graphs where candidate coverage via global scoring is feasible.",
            "policy_structure_findings": "In denser graphs, policies must either (a) support much larger candidate coverage (many rollouts) or (b) be combined with global scoring/embedding models; otherwise out-of-candidate-set errors and limited rollout budgets restrict performance.",
            "uuid": "e1373.3",
            "source_info": {
                "paper_title": "M-Walk: Learning to Walk over Graphs using Monte Carlo Tree Search",
                "publication_date_yy_mm": "2018-02"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "DeepPath: A reinforcement learning method for knowledge graph reasoning",
            "rating": 2
        },
        {
            "paper_title": "Go for a walk and arrive at the answer: Reasoning over paths in knowledge bases using reinforcement learning (MINERVA)",
            "rating": 2
        },
        {
            "paper_title": "Mastering the game of Go with deep neural networks and tree search",
            "rating": 2
        },
        {
            "paper_title": "Mastering the game of Go without human knowledge",
            "rating": 1
        },
        {
            "paper_title": "Differentiable learning of logical rules for knowledge base reasoning (NeuralLP)",
            "rating": 1
        }
    ],
    "cost": 0.01651175,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>M-Walk: Learning to Walk over Graphs using Monte Carlo Tree Search</h1>
<p>${ }^{<em>}$ Yelong Shen ${ }^{1}$, ${ }^{</em>}$ Jianshu Chen ${ }^{1}$, ${ }^{<em>}$ Po-Sen Huang ${ }^{2 </em>}$, Yuqing Guo ${ }^{2}$, and Jianfeng Gao ${ }^{2}$<br>${ }^{1}$ Tencent AI Lab, Bellevue, WA, USA.<br>{yelongshen, jianshuchen}@tencent.com<br>${ }^{2}$ Microsoft Research, Redmond, WA, USA<br>{yuqguo, jfgao}@microsoft.com</p>
<h4>Abstract</h4>
<p>Learning to walk over a graph towards a target node for a given query and a source node is an important problem in applications such as knowledge base completion (KBC). It can be formulated as a reinforcement learning (RL) problem with a known state transition model. To overcome the challenge of sparse rewards, we develop a graph-walking agent called M-Walk, which consists of a deep recurrent neural network (RNN) and Monte Carlo Tree Search (MCTS). The RNN encodes the state (i.e., history of the walked path) and maps it separately to a policy and Q-values. In order to effectively train the agent from sparse rewards, we combine MCTS with the neural policy to generate trajectories yielding more positive rewards. From these trajectories, the network is improved in an off-policy manner using Q-learning, which modifies the RNN policy via parameter sharing. Our proposed RL algorithm repeatedly applies this policy-improvement step to learn the model. At test time, MCTS is combined with the neural policy to predict the target node. Experimental results on several graph-walking benchmarks show that M-Walk is able to learn better policies than other RL-based methods, which are mainly based on policy gradients. M-Walk also outperforms traditional KBC baselines.</p>
<h2>1 Introduction</h2>
<p>We consider the problem of learning to walk over a graph in order to find a target node for a given source node and a query. Such problems appear in, for example, knowledge base completion (KBC) [38, 16, 31, 19, 7]. A knowledge graph is a structured representation of world knowledge in the form of entities and their relations (e.g., Figure 1(a)), and has a wide range of downstream applications such as question answering. Although a typical knowledge graph may contain millions of entities and billions of relations, it is usually far from complete. KBC aims to predict the missing relations between entities using information from the existing knowledge graph. More formally, let $\mathcal{G}=(\mathcal{N}, \mathcal{E})$ denote a graph, which consists of a set of nodes, $\mathcal{N}=\left{n_{i}\right}$, and a set of edges, $\mathcal{E}=\left{e_{i j}\right}$, that connect the nodes, and let $q$ denote an input query. The problem is stated as using the graph $\mathcal{G}$, the source node $n_{S} \in \mathcal{N}$ and the query $q$ as inputs to predict the target node $n_{T} \in \mathcal{N}$. In KBC tasks, $\mathcal{G}$ is a given knowledge graph, $\mathcal{N}$ is a collection of entities (nodes), and $\mathcal{E}$ is a set of relations (edges) that connect the entities. In the example in Figure 1(a), the objective of KBC is to identify the target node $n_{T}=$ USA for the given head entity $n_{S}=$ Obama and the given query $q=$ CITIZENSHIP.</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>The problem can also be understood as constructing a function $f\left(\mathcal{G}, n_{S}, q\right)$ to predict $n_{T}$, where the functional form of $f(\cdot)$ is generally unknown and has to be learned from a training dataset consisting of samples like $\left(n_{S}, q, n_{T}\right)$. In this work, we model $f\left(\mathcal{G}, n_{S}, q\right)$ by means of a graph-walking agent that intelligently navigates through a subset of nodes in the graph from $n_{S}$ towards $n_{T}$. Since $n_{T}$ is unknown, the problem cannot be solved by conventional search algorithms such as $A^{1}$-search [11], which seeks to find paths between the given source and target nodes. Instead, the agent needs to learn its search policy from the training dataset so that, after training is complete, the agent knows how to walk over the graph to reach the correct target node $n_{T}$ for an unseen pair of $\left(n_{S}, q\right)$. Moreover, each training sample is in the form of "(source node, query, target node)", and there is no intermediate supervision for the correct search path. Instead, the agent receives only delayed evaluative feedback: when the agent correctly (or incorrectly) predicts the target node in the training set, the agent will receive a positive (or zero) reward. For this reason, we formulate the problem as a Markov decision process (MDP) and train the agent by reinforcement learning (RL) [27].</p>
<p>The problem poses two major challenges. Firstly, since the state of the MDP is the entire trajectory, reaching a correct decision usually requires not just the query, but also the entire history of traversed nodes. For the KBC example in Figure 1(a), having access to the current node $n_{t}=$ Hawaii alone is not sufficient to know that the best action is moving to $n_{t+1}=$ USA. Instead, the agent must track the entire history, including the input query $q=$ Citizenship, to reach this decision. Secondly, the reward is sparse, being received only at the end of a search path, for instance, after correctly predicting $n_{T}=$ USA.</p>
<p>In this paper, we develop a neural graph-walking agent, named M-Walk, that effectively addresses these two challenges. First, M-Walk uses a novel recurrent neural network (RNN) architecture to encode the entire history of the trajectory into a vector representation, which is further used to model the policy and the Q-function. Second, to address the challenge of sparse rewards, M-Walk exploits the fact that the MDP transition model is known and deterministic. ${ }^{2}$ Specifically, it combines Monte Carlo Tree Search (MCTS) with the RNN to generate trajectories that obtain significantly more positive rewards than using the RNN policy alone. These trajectories can be viewed as being generated from an improved version of the RNN policy. But while these trajectories can improve the RNN policy, their off-policy nature prevents them from being leveraged by policy gradient RL methods. To solve this problem, we design a structure for sharing parameters between the Q-value network and the RNN's policy network. This allows the policy network to be indirectly improved through Q-learning over the off-policy trajectories. Our method is in sharp contrast to existing RL-based methods for KBC, which use a policy gradients (REINFORCE) method [36] and usually require a large number of rollouts to obtain a trajectory with a positive reward, especially in the early stages of learning [9, 37, 14]. Experimental results on several benchmarks, including a synthetic task and several real-world KBC tasks, show that our approach learns better policies than previous RL-based methods and traditional KBC methods.</p>
<p>The rest of the paper is organized as follows: Section 3 develops the M-Walk agent, including the model architecture, the training and testing algorithms. ${ }^{3}$ Experimental results are presented in Section 4. Finally, we discuss related work in Section 5 and conclude the paper in Section 6.</p>
<h1>2 Graph Walking as a Markov Decision Process</h1>
<p>In this section, we formulate the graph-walking problem as a Markov Decision Process (MDP), which is defined by the tuple $(\mathcal{S}, \mathcal{A}, \mathcal{R}, \mathcal{P})$, where $\mathcal{S}$ is the set of states, $\mathcal{A}$ is the set of actions, $\mathcal{R}$ is the reward function, and $\mathcal{P}$ is the state transition probability. We further define $\mathcal{S}, \mathcal{A}, \mathcal{R}$ and $\mathcal{P}$ below. Figure 1(b) illustrates the MDP corresponding to the KBC example of Figure 1(a). Let $s_{t} \in \mathcal{S}$ denote the state at time $t$. Recalling that the agent needs the entire history of traversed nodes and the query to make a correct decision, we define $s_{t}$ by the following recursion:</p>
<p>$$
s_{t}=s_{t-1} \cup\left{a_{t-1}, n_{t}, \mathcal{E}<em t="t">{n</em>}}, \mathcal{N<em t="t">{n</em>}}\right}, \quad s_{0} \triangleq\left{q, n_{S}, \mathcal{E<em S="S">{n</em>}}, \mathcal{N<em S="S">{n</em>\right}
$$}</p>
<p>where $a_{t} \in \mathcal{A}$ denotes the action selected by the agent at time $t, n_{t} \in \mathcal{G}$ denotes the currently visited node at time $t, \mathcal{E}<em t="t">{n</em>}} \subset \mathcal{E}$ is the set of all edges connected to $n_{t}$, and $\mathcal{N<em t="t">{n</em>$ is the set of all nodes}} \subset \mathcal{N</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" />
(a) An example of Knowledge Base Completion
(b) The corresponding Markov Decision Process</p>
<p>Figure 1: An example of Knowledge Base Completion and its formulation as a Markov Decision Process. (a) We want to identify the target node $n_{T}=$ USA for a given pair of query $q=$ Citizenship and source node $n_{S}=$ Obama. (b) The activated circles and edges (in black lines) denote all the observed information up to time $t$ (i.e., the state $s_{t}$ ). The double circle denotes the current node $n_{t}$, while $\mathcal{E}<em t="t">{n</em>}}$ and $\mathcal{N<em t="t">{n</em>$ denote the edges and nodes connected to the current node.
connected to $n_{t}$ (i.e., the neighborhood). Note that state $s_{t}$ is a collection of (i) all the traversed nodes (along with their edges and neighborhoods) up to time $t$, (ii) all the previously selected (up to time $t-1$ ) actions, and (iii) the initial query $q$. The set $\mathcal{S}$ consists of all the possible values of $\left{s_{t}, t \geq 0\right}$. Based on $s_{t}$, the agent takes one of the following actions at each time $t$ : (i) choosing an edge in $\mathcal{E}}<em t="t">{n</em>}}$ and moving to the next node $n_{t+1} \in \mathcal{N<em t="t">{n</em>}}$, or (ii) terminating the walk (denoted as the "STOP" action). Once the STOP action is selected, the MDP reaches the terminal state and outputs $\hat{n<em t="t">{T}=n</em>}$ as a prediction of the target node $n_{T}$. Therefore, we define the set of feasible actions at time $t$ as $\mathcal{A<em n__t="n_{t">{t} \triangleq \mathcal{E}</em>}} \cup{\mathrm{STOP}}$, which is usually time-varying. The entire action space $\mathcal{A}$ is the union of all $\mathcal{A<em t="t">{t}$, i.e., $\mathcal{A}=\cup</em>} \mathcal{A<em S="S">{t}$. Recall that the training set consists of samples in the form of $\left(n</em>}, q, n_{T}\right)$. The reward is defined to be +1 when the predicted target node $\hat{n<em T="T">{T}$ is the same as $n</em>}$ (i.e., $\hat{n<em T="T">{T}=n</em>}$ ), and zero otherwise. In the example of Figure 1(a), for a training sample (Obama, Citizenship, USA), if the agent successfully navigates from Obama to USA and correctly predicts $\hat{n<em t="t">{T}=$ USA, the reward is +1 . Otherwise, it will be 0 . The rewards are sparse because positive reward can be received only at the end of a correct path. Furthermore, since the graph $\mathcal{G}$ is known and static, the MDP transition probability $p\left(s</em>} \mid s_{t-1}, a_{t-1}\right)$ is known and deterministic, and is defined by (1). To see this, we observe from Figure 1(b) that once an action $a_{t}$ (i.e., an edge in $\mathcal{E<em t="t">{n</em>}}$ or "STOP") is selected, the next node $n_{t+1}$ and its associated $\mathcal{E<em t_1="t+1">{n</em>}}$ and $\mathcal{N<em t_1="t+1">{n</em>$ is determined. This important (model-based) knowledge will be exploited to overcome the sparse-reward problem using MCTS and significantly improve the performance of our method (see Sections 3-4 below).
We further define $\pi_{\theta}\left(a_{t} \mid s_{t}\right)$ and $Q_{\theta}\left(s_{t}, a_{t}\right)$ to be the policy and the Q-function, respectively, where $\theta$ is a set of model parameters. The policy $\pi_{\theta}\left(a_{t} \mid s_{t}\right)$ denotes the probability of taking action $a_{t}$ given the current state $s_{t}$. In M-Walk, it is used as a prior to bias the MCTS search. And $Q_{\theta}\left(s_{t}, a_{t}\right)$ defines the long-term reward of taking action $a_{t}$ at state $s_{t}$ and then following the optimal policy thereafter. The objective is to learn a policy that maximizes the terminal rewards, i.e., correctly identifies the target node with high probability. We now proceed to explain how to model and jointly learn $\pi_{\theta}$ and $Q_{\theta}$ to achieve this objective.}}$ are known. By (1) (with $t$ replaced by $t+1$ ), this means that the next state $s_{t+1</p>
<h1>3 The M-Walk Agent</h1>
<p>In this section, we develop a neural graph-walking agent named M-Walk (i.e., MCTS for graph Walking), which consists of (i) a novel neural architecture for jointly modeling $\pi_{\theta}$ and $Q_{\theta}$, and (ii) Monte Carlo Tree Search (MCTS). We first introduce the overall neural architecture and then explain how MCTS is used during the training and testing stages. Finally, we describe some further details of the neural architecture. Our discussion focuses on addressing the two challenges described earlier: history-dependent state and sparse rewards.</p>
<h3>3.1 The neural architecture for jointly modeling $\pi_{\theta}$ and $Q_{\theta}$</h3>
<p>Recall from Section 2 (e.g., (1)) that one challenge in applying RL to the graph-walking problem is that the state $s_{t}$ nominally includes the entire history of observations. To address this problem, we propose a special RNN encoding the state $s_{t}$ at each time $t$ into a vector representation, $h_{t}=$ $\operatorname{ENC}<em c="c">{\theta</em>$ and}}\left(s_{t}\right)$, where $\theta_{c}$ is the associated model parameter. We defer the discussion of this RNN state encoder to Section 3.4, and focus in this section on how to use $h_{t}$ to jointly model $\pi_{\theta</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: The neural architecture for M-Walk. (a) The vector representation of the state is mapped into $\pi_{\theta}$ and $Q_{\theta}$. (b) The GRU-RNN state encoder maps the state into its vector representation $h_{t}$. Note that the inputs $h_{A, t-1}$ and $h_{a_{t-1}, t-1}$ are from the output of the previous time step $t-1$.</p>
<p>$Q_{\theta}$. Specifically, the vector $h_{t}$ consists of several sub-vectors of the same dimension $M$: $h_{S, t}$, $\left{h_{n^{\prime}, t}: n^{\prime} \in \mathcal{N}<em t="t">{n</em>}}\right}$ and $h_{A, t}$. Each sub-vector encodes part of the state $s_{t}$ in (1). For instance, the vector $h_{S, t}$ encodes $\left(s_{t-1}, a_{t-1}, n_{t}\right)$, which characterizes the history in the state. The vector $h_{n^{\prime}, t}$ encodes the (neighboring) node $n^{\prime}$ and the edge $e_{n_{t}, n^{\prime}}$ connected to $n_{t}$, which can be viewed as a vector representation of the $n^{\prime}$-th candidate action (excluding the STOP action). And the vector $h_{A, t}$ is a vector summarization of $\mathcal{E<em t="t">{n</em>}}$ and $\mathcal{N<em t="t">{n</em>$ according to:}}$, which is used to model the STOP action probability. In summary, we use the sub-vectors to model $\pi_{\theta}$ and $Q_{\theta</p>
<p>$$
\begin{aligned}
u_{0} &amp; =f_{\theta_{\pi}}\left(h_{S, t}, h_{A, t}\right), \quad u_{n^{\prime}}=\left\langle h_{S, t}, h_{n^{\prime}, t}\right\rangle, \quad n^{\prime} \in \mathcal{N}<em t="t">{n</em> \
Q_{\theta}\left(s_{t}, \cdot\right) &amp; =\sigma\left(u_{0}, u_{n_{1}^{\prime}}, \ldots, u_{n_{k}^{\prime}}\right), \pi_{\theta}\left(\cdot \mid s_{t}\right)=\phi_{\tau}\left(u_{0}, u_{n_{1}^{\prime}}, \ldots, u_{n_{k}^{\prime}}\right)
\end{aligned}
$$}</p>
<p>where $\langle\cdot, \cdot\rangle$ denotes inner product, $f_{\theta_{\pi}}(\cdot)$ is a fully-connected neural network with model parameter $\theta_{\pi}$, $\sigma(\cdot)$ denotes the element-wise sigmoid function, and $\phi_{\tau}(\cdot)$ is the softmax function with temperature parameter $\tau$. Note that we use the inner product between the vectors $h_{S, t}$ and $h_{n^{\prime}, t}$ to compute the (pre-softmax) score $u_{n^{\prime}}$ for choosing the $n^{\prime}$-th candidate action, where $n^{\prime} \in \mathcal{N}<em t="t">{n</em>$ via Q-learning from off-policy data.}}$. The inner product operation has been shown to be useful in modeling Q-functions when the candidate actions are described by vector representations [13, 3] and in solving other problems [33, 1]. Moreover, the value of $u_{0}$ is computed by $f_{\theta_{\pi}}(\cdot)$ using $h_{S, t}$ and $h_{A, t}$, where $u_{0}$ gives the (pre-softmax) score for choosing the STOP action. We model the Q-function by applying element-wise sigmoid to $u_{0}, u_{n_{1}^{\prime}}, \ldots, u_{n_{k}^{\prime}}$, and we model the policy by applying the softmax operation to the same set of $u_{0}, u_{n_{1}^{\prime}}, \ldots, u_{n_{k}^{\prime}} .^{3}$ Note that the policy network and the Q-network share the same set of model parameters. We will explain in Section 3.2 how such parameter sharing enables indirect updates to the policy $\pi_{\theta</p>
<h1>3.2 The training algorithm</h1>
<p>We now discuss how to train the model parameters $\theta$ (including $\theta_{\pi}$ and $\theta_{e}$ ) from a training dataset $\left{\left(n_{S}, q, n_{T}\right)\right}$ using reinforcement learning. One approach is the policy gradient method (REINFORCE) [36, 28], which uses the current policy $\pi_{\theta}\left(a_{t} \mid s_{t}\right)$ to roll out multiple trajectories $\left(s_{0}, a_{0}, r_{0}, s_{1}, \ldots\right)$ to estimate a stochastic gradient, and then updates the policy $\pi_{\theta}$ via stochastic gradient ascent. Previous RL-based KBC methods [38, 5] typically use REINFORCE to learn the policy. However, policy gradient methods generally suffer from low sample efficiency, especially when the reward signal is sparse, because large numbers of Monte Carlo rollouts are usually needed to obtain many trajectories with positive terminal reward, particularly in the early stages of learning. To address this challenge, we develop a novel RL algorithm that uses MCTS to exploit the deterministic MDP transition defined in (1). Specifically, on each MCTS simulation, a trajectory is rolled out by selecting actions according to a variant of the PUCT algorithm [21, 25] from the root state $s_{0}$ (defined in (1)):</p>
<p>$$
a_{t}=\operatorname{argmax}<em _theta="\theta">{a}\left{c \cdot \pi</em>, a\right)\right}
$$}\left(a \mid s_{t}\right)^{\beta} \sqrt{\sum_{a^{\prime}} N\left(s_{t}, a^{\prime}\right)} /\left(1+N\left(s_{t}, a\right)\right)+W\left(s_{t}, a\right) / N\left(s_{t</p>
<p>where $\pi_{\theta}(a \mid s)$ is the policy defined in Section 3.1, $c$ and $\beta$ are two constants that control the level of exploration, and $N(s, a)$ and $W(s, a)$ are the visit count and the total action reward accumulated on the $(s, a)$-th edge on the MCTS tree. Overall, PUCT treats $\pi_{\theta}$ as a prior probability to bias the MCTS</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: MCTS is used to generate trajectories for iterative policy improvement in M-Walk.
search; PUCT initially prefers actions with high values of $\pi_{\theta}$ and low visit count $N(s, a)$ (because the first term in (4) is large), but then asympotically prefers actions with high value (because the first term in (4) vanishes and the second term $W(s, a) / N(s, a)$ dominates). When PUCT selects the STOP action or the maximum search horizon has been reached, MCTS completes one simulation and updates $W(s, a)$ and $N(s, a)$ using $V_{\theta}\left(s_{T}\right)=Q_{\theta}\left(s_{T}, a=\right.$ STOP $)$. (See Figure 3(a) for an example and Appendix B. 1 for more details.) The key idea of our method is that running multiple MCTS simulations generates a set of trajectories with more positive rewards (see Section 4 for more analysis), which can also be viewed as being generated by an improved policy $\pi_{\theta}$. Therefore, learning from these trajectories can further improve $\pi_{\theta}$. Our RL algorithm repeatedly applies this policy-improvement step to refine the policy. However, since these trajectories are generated by a policy that is different from $\pi_{\theta}$, they are off-policy data, breaking the assumptions inherent in policy gradient methods. For this reason, we instead update the Q-network from these trajectories in an off-policy manner using Q-learning: $\theta \leftarrow \theta+\alpha \cdot \nabla_{\theta} Q_{\theta}\left(s_{t}, a_{t}\right) \times\left(r\left(s_{t}, a_{t}\right)+\gamma \max <em _theta="\theta">{a^{\prime}} Q</em>$ is used to control the MCTS in the next iteration. The main idea of the training algorithm is summarized in Figure 3(b).}\left(s_{t+1}, a^{\prime}\right)-Q_{\theta}\left(s_{t}, a_{t}\right)\right)$. Recall from Section 3.1 that $\pi_{\theta}$ and $Q_{\theta}(s, a)$ share the same set of model parameters; once the Q-network is updated, the policy network $\pi_{\theta}$ will also be automatically improved. Finally, the new $\pi_{\theta</p>
<h1>3.3 The prediction algorithm</h1>
<p>At test time, we want to infer the target node $n_{T}$ for an unseen pair of $\left(n_{S}, q\right)$. One approach is to use the learned policy $\pi_{\theta}$ to walk through the graph $\mathcal{G}$ to find $n_{T}$. However, this would not exploit the known MDP transition model (1). Instead, we combine the learned $\pi_{\theta}$ and $Q_{\theta}$ with MCTS to generate an MCTS search tree, as in the training stage. Note that there could be multiple paths that reach the same terminal node $n \in \mathcal{G}$, meaning that there could be multiple leaf states in MCTS corresponding to that node. Therefore, the prediction results from these MCTS leaf states need to be merged into one score to rank the node $n$. Specifically, we use $\operatorname{Score}(n)=\sum_{s_{T} \rightarrow n} N\left(s_{T}, a_{T}\right) / N \times Q_{\theta}\left(s_{T}\right.$, STOP $)$, where $N$ is the total number of MCTS simulations, and the summation is over all the leaf states $s_{T}$ that correspond to the same node $n \in \mathcal{G} . \operatorname{Score}(n)$ is a weighted average of the terminal state values associated with the same candidate node $n .{ }^{5}$ Among all the candidates nodes, we select the predicted target node to be the one with the highest score: $\hat{n}<em n="n">{T}=\operatorname{argmax}</em>(n)$.} \operatorname{Score</p>
<h3>3.4 The RNN state encoder</h3>
<p>We now discuss the details of the RNN state encoder $h_{t}=\operatorname{ENC}<em e="e">{\theta</em>}}\left(s_{t}\right)$, where $\theta_{e} \triangleq\left{\theta_{A}, \theta_{S}, \theta_{q}\right}$, as shown in Figure 2(b). Specifically, we explain how the sub-vectors of $h_{t}$ are computed. We introduce $q_{t} \triangleq s_{t-1} \cup\left{a_{t-1}, n_{t}\right}$ as an auxiliary variable. Then, the state $s_{t}$ in (1) can be written as $s_{t}=q_{t} \cup\left{\mathcal{E<em t="t">{n</em>}}, \mathcal{N<em t="t">{n</em>}}\right}$. Note that the state $s_{t}$ is composed of two parts: (i) $\mathcal{E<em t="t">{n</em>}}$ and $\mathcal{N<em t="t">{n</em>}}$, which represent the candidate actions to be selected (excluding the STOP action), and (ii) $q_{t}$, which represents the history. We use two different neural networks to encode these separately. For the $n^{\prime}$-th candidate action ( $n^{\prime} \in \mathcal{N<em t="t">{n</em>}}$ ), we concatenate $n^{\prime}$ with its associated $e_{n_{t}, n^{\prime}} \in \mathcal{E<em t="t">{n</em>}}$ and input them into a fully connected network (FCN) $f_{\theta_{A}}(\cdot)$ to compute their joint vector representation $h_{n^{\prime}, t}$, where $\theta_{A}$ is the model parameter. Recall that the action space $\mathcal{A<em n__t="n_{t">{t}=\mathcal{E}</em>}} \cup{\mathrm{STOP}}$ can be time-varying when the size of $\mathcal{E<em t="t">{n</em>(\cdot)$ to}}$ changes over time. To address this issue, we apply the same $\operatorname{FCN} f_{\theta</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>different $\left(n^{\prime}, e_{n_{t}, n^{\prime}}\right)$ to obtain their respective representations. Then, we use a coordinate-wise maxpooling operation over $\left{h_{n^{\prime}, t}: n^{\prime} \in \mathcal{N}<em t="t">{n</em>}}\right}$ to obtain a (fixed-length) overall vector representation of $\left{\mathcal{E<em t="t">{n</em>}}, \mathcal{N<em t="t">{n</em>}}\right}$. To encode $q_{t}$, we call upon the following recursion for $q_{t}$ (see Appendix A for the derivation): $q_{t+1}=q_{t} \cup\left{\mathcal{E<em t="t">{n</em>}}, \mathcal{N<em t="t">{n</em>}}, a_{t}, n_{t+1}\right}$. Inspired by this recursion, we propose using the GRU-RNN [4] to encode $q_{t}$ into a vector representation ${ }^{6}: q_{t+1}=f_{\theta_{q}}\left(q_{t},\left[h_{A, t}, h_{a_{t}, t}, n_{t+1}\right]\right)$ with initialization $q_{0}=f_{\theta_{q}}\left(q,\left[0,0, n_{S}\right]\right)$, where $\theta_{q}$ is the model parameter, and $h_{a_{t}, t}$ denotes the vector $h_{n^{\prime}, t}$ at $n^{\prime}=a_{t}$. We use $h_{A, t}$ and $h_{a_{t}, t}$ computed by the FCNs to represent $\left(\mathcal{E<em t="t">{n</em>}}, \mathcal{N<em t="t">{n</em>(\cdot)$.}}\right)$ and $a_{t}$, respectively. Then, we map $q_{t}$ to $h_{S, t}$ using another $\operatorname{FCN} f_{\theta_{S}</p>
<h1>4 Experiments</h1>
<p>We evaluate and analyze the effectiveness of M-Walk on a synthetic Three Glass Puzzle task and two real-world KBC tasks. We briefly describe the tasks here, and give the experiment details and hyperparameters in Appendix B.</p>
<p>Three Glass Puzzle The Three Glass Puzzle [20] is a problem studied in math puzzles and graph theory. It involves three milk containers $\mathcal{A}, \mathcal{B}$, and $\mathcal{C}$, with capacities $A, B$ and $C$ liters, respectively. The containers display no intermediate markings. There are three feasible actions at each time step: (i) fill a container (to its capacity), (ii) empty all of its liquid, and (iii) pour its liquid into another container (up to its capacity). The objective of the problem is, given a desired volume $q$, to take a sequence of actions on the three containers after which one of them contains $q$ liters of liquid. We formulate this as a graph-walking problem; in the graph $\mathcal{G}$, each node $n=(a, b, c)$ denotes the amounts of remaining liquid in the three containers, each edge denotes one of the three feasible actions, and the input query is the desired volume $q$. The reward is +1 when the agent successfully fills one of the containers to $q$ and 0 otherwise (see Appendix B.2.1 for the details). We use vanilla policy gradient (REINFORCE) [36] as the baseline, with task success rate as the evaluation metric.</p>
<p>Knowledge Base Completion We use WN18RR and NELL995 knowledge graph datasets for evaluation. WN18RR [6] is created from the original WN18 [2] by removing various sources of test leakage, making the dataset more challenging. The NELL995 dataset was released by [38] and has separate graphs for each query relation. We use the same data split and preprocessing protocol as in [6] for WN18RR and in [38, 5] for NELL995. As in [38, 5], we study the 10 relation tasks of NELL995 separately. We use HITS@1,3 and mean reciprocal rank (MRR) as the evaluation metrics for WN18RR, and use mean average precision (MAP) for NELL995, ${ }^{7}$ where HITS@ $K$ computes the percentage of the desired entities being ranked among the top- $K$ list, and MRR computes an average of the reciprocal rank of the desired entities. We compare against RL-based methods [38, 5], embedding-based models (including DistMult [39], ComplEx [32] and ConvE [6]) and recent work in logical rules (NeuralLP) [40]. For all the baseline methods, we used the implementation released by the corresponding authors with their best-reported hyperparameter settings. ${ }^{8}$ The details of the hyperparameters for M-Walk are described in Appendix B.2.2 of the supplementary material.</p>
<h3>4.1 Performance of M-Walk</h3>
<p>We first report the overall performance of the M-Walk algorithm on the three tasks and compare it with other baseline methods. We ran the experiments three times and report the means and standard deviations (except for PRA, TransE, and TransR on NELL995, whose results are directly quoted from [38]). On the Three Glass Puzzle task, M-Walk significantly outperforms the baseline: the best model of M-Walk achieves an accuracy of $(99.0 \pm 1.0) \%$ while the best REINFORCE method achieves $(49.0 \pm 2.6) \%$ (see Appendix C for more experiments with different settings on this task). For the two KBC tasks, we report their results in Tables 1-2, where PG-Walk and Q-Walk are two methods we created just for the ablation study in the next section. The proposed method outperforms previous works in most of the metrics on NELL995 and WN18RR datasets. Additional experiments on the FB15k-237 dataset can be found in Appendix C.1.1 of the supplementary material.</p>
<p><sup id="fnref5:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>Table 1: The MAP scores (\%) on NELL995 task, where we report RL-based methods in terms of "mean (standard deviation)". PG-Walk and Q-Walk are methods we created just for the ablation study.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Tasks</th>
<th style="text-align: center;">M-Walk</th>
<th style="text-align: center;">PG-Walk</th>
<th style="text-align: center;">Q-Walk</th>
<th style="text-align: center;">MINERVA</th>
<th style="text-align: center;">DeepPath</th>
<th style="text-align: center;">PRA</th>
<th style="text-align: center;">TransE</th>
<th style="text-align: center;">TransR</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">AthletePlaysForTeam</td>
<td style="text-align: center;">$\mathbf{8 4 . 7 ( 1 . 3 )}$</td>
<td style="text-align: center;">$80.8(0.9)$</td>
<td style="text-align: center;">$82.6(1.2)$</td>
<td style="text-align: center;">$82.7(0.8)$</td>
<td style="text-align: center;">$72.1(1.2)$</td>
<td style="text-align: center;">54.7</td>
<td style="text-align: center;">62.7</td>
<td style="text-align: center;">67.3</td>
</tr>
<tr>
<td style="text-align: left;">AthletePlaysInLeague</td>
<td style="text-align: center;">$\mathbf{9 7 . 8 ( 0 . 2 )}$</td>
<td style="text-align: center;">$96.0(0.6)$</td>
<td style="text-align: center;">$96.2(0.8)$</td>
<td style="text-align: center;">$95.2(0.8)$</td>
<td style="text-align: center;">$92.7(5.3)$</td>
<td style="text-align: center;">84.1</td>
<td style="text-align: center;">77.3</td>
<td style="text-align: center;">91.2</td>
</tr>
<tr>
<td style="text-align: left;">AthleteHomeStadium</td>
<td style="text-align: center;">$91.9(0.1)$</td>
<td style="text-align: center;">$91.9(0.3)$</td>
<td style="text-align: center;">$91.1(1.3)$</td>
<td style="text-align: center;">$\mathbf{9 2 . 8 ( 0 . 1 )}$</td>
<td style="text-align: center;">$84.6(0.8)$</td>
<td style="text-align: center;">85.9</td>
<td style="text-align: center;">71.8</td>
<td style="text-align: center;">72.2</td>
</tr>
<tr>
<td style="text-align: left;">AthletePlaysSport</td>
<td style="text-align: center;">$98.3(0.1)$</td>
<td style="text-align: center;">$98.0(0.8)$</td>
<td style="text-align: center;">$97.0(0.2)$</td>
<td style="text-align: center;">$\mathbf{9 8 . 6 ( 0 . 1 )}$</td>
<td style="text-align: center;">$91.7(4.1)$</td>
<td style="text-align: center;">47.4</td>
<td style="text-align: center;">87.6</td>
<td style="text-align: center;">96.3</td>
</tr>
<tr>
<td style="text-align: left;">TeamPlaySports</td>
<td style="text-align: center;">$\mathbf{8 8 . 4 ( 1 . 8 )}$</td>
<td style="text-align: center;">$87.4(0.9)$</td>
<td style="text-align: center;">$78.5(0.6)$</td>
<td style="text-align: center;">$87.5(0.5)$</td>
<td style="text-align: center;">$69.6(6.7)$</td>
<td style="text-align: center;">79.1</td>
<td style="text-align: center;">76.1</td>
<td style="text-align: center;">81.4</td>
</tr>
<tr>
<td style="text-align: left;">OrgHeadquaterCity</td>
<td style="text-align: center;">$\mathbf{9 5 . 0 ( 0 . 7 )}$</td>
<td style="text-align: center;">$94.0(0.4)$</td>
<td style="text-align: center;">$94.0(0.6)$</td>
<td style="text-align: center;">$94.5(0.3)$</td>
<td style="text-align: center;">$79.0(0.0)$</td>
<td style="text-align: center;">81.1</td>
<td style="text-align: center;">62.0</td>
<td style="text-align: center;">65.7</td>
</tr>
<tr>
<td style="text-align: left;">WorksFor</td>
<td style="text-align: center;">$\mathbf{8 4 . 2 ( 0 . 6 )}$</td>
<td style="text-align: center;">$84.0(1.6)$</td>
<td style="text-align: center;">$82.7(0.2)$</td>
<td style="text-align: center;">$82.7(0.5)$</td>
<td style="text-align: center;">$69.9(0.3)$</td>
<td style="text-align: center;">68.1</td>
<td style="text-align: center;">67.7</td>
<td style="text-align: center;">69.2</td>
</tr>
<tr>
<td style="text-align: left;">BornLocation</td>
<td style="text-align: center;">$81.2(0.0)$</td>
<td style="text-align: center;">$\mathbf{8 2 . 3 ( 0 . 6 )}$</td>
<td style="text-align: center;">$81.4(0.5)$</td>
<td style="text-align: center;">$78.2(0.0)$</td>
<td style="text-align: center;">$75.5(0.5)$</td>
<td style="text-align: center;">66.8</td>
<td style="text-align: center;">71.2</td>
<td style="text-align: center;">81.2</td>
</tr>
<tr>
<td style="text-align: left;">PersonLeadsOrg</td>
<td style="text-align: center;">$\mathbf{8 8 . 8 ( 0 . 5 )}$</td>
<td style="text-align: center;">$87.2(0.5)$</td>
<td style="text-align: center;">$86.9(0.5)$</td>
<td style="text-align: center;">$83.0(2.6)$</td>
<td style="text-align: center;">$79.0(1.0)$</td>
<td style="text-align: center;">70.0</td>
<td style="text-align: center;">75.1</td>
<td style="text-align: center;">77.2</td>
</tr>
<tr>
<td style="text-align: left;">OrgHiredPerson</td>
<td style="text-align: center;">$\mathbf{8 8 . 8 ( 0 . 6 )}$</td>
<td style="text-align: center;">$87.2(0.4)$</td>
<td style="text-align: center;">$87.8(0.9)$</td>
<td style="text-align: center;">$87.0(0.3)$</td>
<td style="text-align: center;">$73.8(1.9)$</td>
<td style="text-align: center;">59.9</td>
<td style="text-align: center;">71.9</td>
<td style="text-align: center;">73.7</td>
</tr>
<tr>
<td style="text-align: left;">Overall</td>
<td style="text-align: center;">$\mathbf{8 9 . 9}$</td>
<td style="text-align: center;">88.9</td>
<td style="text-align: center;">87.8</td>
<td style="text-align: center;">87.6</td>
<td style="text-align: center;">78.8</td>
<td style="text-align: center;">69.7</td>
<td style="text-align: center;">72.3</td>
<td style="text-align: center;">77.5</td>
</tr>
</tbody>
</table>
<p>Table 2: The results on the WN18RR dataset, in the form of "mean (standard deviation)".</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Metric (\%)</th>
<th style="text-align: center;">M-Walk</th>
<th style="text-align: center;">PG-Walk</th>
<th style="text-align: center;">Q-Walk</th>
<th style="text-align: center;">MINERVA</th>
<th style="text-align: center;">ComplEx</th>
<th style="text-align: center;">ConvE</th>
<th style="text-align: center;">DistMult</th>
<th style="text-align: center;">NeuralLP</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">HITS@1</td>
<td style="text-align: center;">$\mathbf{4 1 . 4 ( 0 . 1 )}$</td>
<td style="text-align: center;">$39.3(0.2)$</td>
<td style="text-align: center;">$38.2(0.3)$</td>
<td style="text-align: center;">$35.1(0.1)$</td>
<td style="text-align: center;">$38.5(0.3)$</td>
<td style="text-align: center;">$39.6(0.3)$</td>
<td style="text-align: center;">$38.4(0.4)$</td>
<td style="text-align: center;">$37.2(0.1)$</td>
</tr>
<tr>
<td style="text-align: left;">HITS@3</td>
<td style="text-align: center;">$44.5(0.2)$</td>
<td style="text-align: center;">$41.9(0.1)$</td>
<td style="text-align: center;">$40.8(0.4)$</td>
<td style="text-align: center;">$44.5(0.4)$</td>
<td style="text-align: center;">$43.9(0.3)$</td>
<td style="text-align: center;">$\mathbf{4 4 . 7 ( 0 . 2 )}$</td>
<td style="text-align: center;">$42.4(0.3)$</td>
<td style="text-align: center;">$43.4(0.1)$</td>
</tr>
<tr>
<td style="text-align: left;">MRR</td>
<td style="text-align: center;">$\mathbf{4 3 . 7 ( 0 . 1 )}$</td>
<td style="text-align: center;">$41.3(0.1)$</td>
<td style="text-align: center;">$40.1(0.3)$</td>
<td style="text-align: center;">$40.9(0.1)$</td>
<td style="text-align: center;">$42.2(0.2)$</td>
<td style="text-align: center;">$43.3(0.2)$</td>
<td style="text-align: center;">$41.3(0.3)$</td>
<td style="text-align: center;">$43.5(0.1)$</td>
</tr>
</tbody>
</table>
<h1>4.2 Analysis of M-Walk</h1>
<p>We performed extensive experimental analysis to understand the proposed M-Walk algorithm, including (i) the contributions of different components, (ii) its ability to overcome sparse rewards, (iii) hyperparameter analysis, (iv) its strengths and weaknesses compared to traditional KBC methods, and (v) its running time. First, we used ablation studies to analyze the contributions of different components in M-Walk. To understand the contribution of the proposed neural architecture in MWalk, we created a method, PG-Walk, which uses the same neural architecture as M-Walk but with the same training (PG) and testing (beam search) algorithms as MINERVA [5]. We observed that the novel neural architecture of M-Walk contributes an overall $1 \%$ gain relative to MINERVA on NELL995, and it is still $1 \%$ worse than M-Walk, which uses MCTS for training and testing. To further understand the contribution of MCTS, we created another method, Q-Walk, which uses the same model architecture as M-Walk except that it is trained by Q-learning only without MCTS. Note that this lost about $2 \%$ in overall performance on NELL995. We observed similar trends on WN18RR. In addition, we also analyze the importance of MCTS in the testing stage in Appendix C.1.</p>
<p>Second, we analyze the ability of M-Walk to overcome the sparse-reward problem. In Figure 4, we show the positive reward rate (i.e., the percentage of trajectories with positive reward during training) on the Three Glass Puzzle task and the NELL995 tasks. Compared to the policy gradient method (PGWalk), and Q-learning method (Q-Walk) methods under the same model architecture, M-Walk with MCTS is able to generate trajectories with more positive rewards, and this continues to improve as training progresses. This confirms our motivation of using MCTS to generate higher-quality trajectories to alleviate the sparse-reward problem in graph walking.</p>
<p>Third, we analyze the performance of M-Walk under different numbers of MCTS rollout simulations and different search horizons on WN18RR dataset, with results shown in Figure 5(a). We observe that the model is less sensitive to search horizon and more sensitive to the number of MCTS rollouts. Finally, we analyze the strengths and weaknesses of M-Walk relative to traditional methods on the WN18RR dataset. The first question is how M-Walk performs on reasoning paths of different lengths compared to baselines. To answer this, we analyze the HITS@1 accuracy against ConvE in Fig. 5(b). We categorize each test example using the BFS (breadth-first search) steps from the query entity to the target entity ( -1 means not reachable). We observe that M-Walk outperforms the strong baseline ConvE by $4.6-10.9 \%$ in samples that require 2 or 3 steps, while it is nearly on par for paths of length one. Therefore, M-Walk does better at reasoning over longer paths than ConvE. Another question is what are the major types of errors made by M-Walk. Recall that M-Walk only walks through a subset of the graph and ranks a subset of candidate nodes (e.g., MCTS produces about 20-60 unique candidates on WN18RR). When the ground truth is not in the candidate set, M-Walk always makes mistakes and we define this type of error as out-of-candidate-set error. To examine this effect, we show in Figure 5(c)-top the HITS@K accuracies when the ground truth is in the candidate</p>
<p><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 4: The positive reward rate. Figures (a)-(d) are the results on the Three Glass Puzzle task and Figures (e)-(h) are the results on the NELL-995 task. (See Appendix C.1.1 for more results.)
<img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 5: M-Walk hyperparameter and error analysis on WN18RR.
set. ${ }^{9}$ It shows that M-Walk has very high accuracy in this case, which is significantly higher than ConvE ( $80 \%$ vs $39.6 \%$ in HITS@1). We further examine the percentage of out-of-candidate-set errors among all errors in Figure 5(c)-bottom. It shows that the major error made by M-Walk is the out-of-candidate-set error. These observations point to an important direction for improving M-Walk in future work: increasing the chance of covering the target by the candidate set.</p>
<p>Table 3: Running time of M-Walk and MINERVA for different combinations of (horizon, rollouts).</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Model</th>
<th style="text-align: center;">M-Walk (5,64)</th>
<th style="text-align: center;">M-Walk (5,128)</th>
<th style="text-align: center;">M-Walk (3,64)</th>
<th style="text-align: center;">M-Walk (3,128)</th>
<th style="text-align: center;">MINERVA (3,100), best</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Training (hrs.)</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">14</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">3</td>
</tr>
<tr>
<td style="text-align: center;">Testing (sec/sample)</td>
<td style="text-align: center;">$3 \times 10^{-3}$</td>
<td style="text-align: center;">$6 \times 10^{-3}$</td>
<td style="text-align: center;">$1.6 \times 10^{-3}$</td>
<td style="text-align: center;">$2.7 \times 10^{-3}$</td>
<td style="text-align: center;">$2 \times 10^{-2}$</td>
</tr>
</tbody>
</table>
<p>In Table 3, we show the running time of M-Walk (in-house C++ \&amp; Cuda) and MINERVA (TensorFlowgpu) for both training and testing on WN18RR with different values of search horizon and number of rollouts (or MCTS simulation number). Note that the running time of M-Walk is comparable to that of MINERVA. Additional results can be found in Figure 9(c) of the supplementary material. Finally, in Table 4, we show examples of reasoning paths found by M-Walk. ${ }^{10}$</p>
<h1>5 Related Work</h1>
<p>Reinforcement Learning Recently, deep reinforcement learning has achieved great success in many artificial intelligence problems [17, 24, 25]. The use of deep neural networks with RL allows policies to be learned from raw data (e.g., images) in an end-to-end manner. Our work also aligns</p>
<p><sup id="fnref6:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>Table 4: Examples of reasoning paths found by M-Walk on the NELL-995 dataset for the relation "AthleteHomeStadium". True (False) means the prediction is correct (wrong).</p>
<table>
<thead>
<tr>
<th style="text-align: center;">AthleteHomeStadium:</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Example 1: athlete emie banks $\xrightarrow{\text { nolenthemehadows? }}$</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">athlete emie banks $\xrightarrow{\text { nolenthechikd organ }}$ SportsLeague mib $\xrightarrow{\text { "lenthechikd organ" }}$ SportsTeam chicago cubs $\xrightarrow{\text { "lenthechukdom }}$ StadiumOrEventVenue wrigley field, (True)</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Example 2: coach jim zorn $\xrightarrow{\text { nolenthemehadows? }}$</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">coach jim zorn $\xrightarrow{\text { "lenthechukdom }}$ AwardTrophyTournament super bowl $\xrightarrow{\text { "lenthechtophy " }}$ SportsTeam redskins $\xrightarrow{\text { "lenthemehadow" }}$ StadiumOrEventVenue fedex field, (True)</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Example 3: athlete oliver perez $\xrightarrow{\text { nolenthemehadows? }}$</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">athlete oliver perez $\xrightarrow{\text { nolenthechikd organ }}$ SportsLeague mib $\xrightarrow{\text { "lenthechikd organ" }}$ SportsTeam chicago cubs $\xrightarrow{\text { "lenthemehadow }}$ StadiumOrEventVenue wrigley field, (False)</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>with this direction. Furthermore, the idea of using an RNN to encode the history of observations also appeared in [12, 35]. The combination of model-based and model-free information in our work shares the same spirit as [24, 25, 26, 34]. Among them, the most relevant are [24, 25], which combine MCTS with neural policy and value functions to achieve superhuman performance on Go. Different from our work, the policy and the value networks in [24] are trained separately without the help of MCTS, and are only used to help MCTS after being trained. The work [25] uses a new policy iteration method that combines the neural policy and value functions with MCTS during training. However, the method in [25] improves the policy network from the MCTS probabilities of the moves, while our method improves the policy from the trajectories generated by MCTS. Note that the former is constructed from the visit counts of all the edges connected to the MCTS root node; it only uses information near the root node to improve the policy. By contrast, we improve the policy by learning from the trajectories generated by MCTS, using information over the entire MCTS search tree.</p>
<p>Knowledge Base Completion In KBC tasks, early work [2] focused on learning vector representations of entities and relations. Recent approaches have demonstrated limitations of these prior approaches: they suffer from cascading errors when dealing with compositional (multi-step) relationships [10]. Hence, recent works $[8,18,10,15,30]$ have proposed approaches for injecting multi-step paths such as random walks through sequences of triples during training, further improving performance on KBC tasks. IRN [23] and Neural LP [40] explore multi-step relations by using an RNN controller with attention over an external memory. Compared to RL-based approaches, it is hard to interpret the traversal paths, and these models can be computationally expensive to access the entire graph in memory [23]. Two recent works, DeepPath [38] and MINERVA [5], use RL-based approaches to explore paths in knowledge graphs. DeepPath requires target entity information to be in the state of the RL agent, and cannot be applied to tasks where the target entity is unknown. MINERVA [5] uses a policy gradient method to explore paths during training and test. Our proposed model further exploits state transition information by integrating the MCTS algorithm. Empirically, our proposed algorithm outperforms both DeepPath and MINERVA in the KBC benchmarks. ${ }^{11}$</p>
<h1>6 Conclusion and Discussion</h1>
<p>We developed an RL-agent (M-Walk) that learns to walk over a graph towards a desired target node for given input query and source nodes. Specifically, we proposed a novel neural architecture that encodes the state into a vector representation, and maps it to Q-values and a policy. To learn from sparse rewards, we propose a new reinforcement learning algorithm, which alternates between an MCTS trajectory-generation step and a policy-improvement step, to iteratively refine the policy. At test time, the learned networks are combined with MCTS to search for the target node. Experimental results on several benchmarks demonstrate that our method learns better policies than other baseline methods, including RL-based and traditional methods on KBC tasks. Furthermore, we also performed extensive experimental analysis to understand M-Walk. We found that our method is more accurate when the ground truth is in the candidate set. We also found that the out-of-candidate-set error is the main type of error made by M-Walk. Therefore, in future work, we intend to improve this method by reducing such out-of-candidate-set errors.</p>
<p><sup id="fnref7:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<h1>Acknowledgments</h1>
<p>We thank Ricky Loynd, Adith Swaminathan, and anonymous reviewers for their valuable feedback.</p>
<h2>References</h2>
<p>[1] Irwan Bello, Hieu Pham, Quoc V Le, Mohammad Norouzi, and Samy Bengio. Neural combinatorial optimization with reinforcement learning. arXiv preprint arXiv:1611.09940, 2016.
[2] Antoine Bordes, Nicolas Usunier, Alberto Garcia-Duran, Jason Weston, and Oksana Yakhnenko. Translating embeddings for modeling multi-relational data. In Proc. NIPS, pages 2787-2795, 2013.
[3] Jianshu Chen, Chong Wang, Lin Xiao, Ji He, Lihong Li, and Li Deng. Q-LDA: Uncovering latent patterns in text-based sequential decision processes. In Proc. NIPS, pages 4984-4993, 2017.
[4] Kyunghyun Cho, Bart Van Merriënboer, Caglar Gulcehre, Dzmitry Bahdanau, Fethi Bougares, Holger Schwenk, and Yoshua Bengio. Learning phrase representations using rnn encoderdecoder for statistical machine translation. Proc. EMNLP, 2014.
[5] Rajarshi Das, Shehzaad Dhuliawala, Manzil Zaheer, Luke Vilnis, Ishan Durugkar, Akshay Krishnamurthy, Alexander J. Smola, and Andrew McCallum. Go for a walk and arrive at the answer: Reasoning over paths in knowledge bases using reinforcement learning. In Proc. ICLR, 2018.
[6] Tim Dettmers, Minervini Pasquale, Stenetorp Pontus, and Sebastian Riedel. Convolutional 2D knowledge graph embeddings. In Proc. AAAI, February 2018.
[7] Jianfeng Gao, Michel Galley, and Lihong Li. Neural approaches to conversational AI. arXiv preprint arXiv:1809.08267, 2018.
[8] Matt Gardner, Partha Pratim Talukdar, Jayant Krishnamurthy, and Tom Mitchell. Incorporating vector space similarity in random walk inference over knowledge bases. In EMNLP, 2014.
[9] Shixiang Gu, Timothy Lillicrap, Zoubin Ghahramani, Richard E Turner, and Sergey Levine. Q-prop: Sample-efficient policy gradient with an off-policy critic. In Proc. ICLR, 2016.
[10] Kelvin Guu, John Miller, and Percy Liang. Traversing knowledge graphs in vector space. In Proc. EMNLP, 2015.
[11] Peter E Hart, Nils J Nilsson, and Bertram Raphael. A formal basis for the heuristic determination of minimum cost paths. IEEE Trans. Systems Science and Cybernetics, 4(2):100-107, 1968.
[12] Matthew J. Hausknecht and Peter Stone. Deep recurrent Q-learning for partially observable MDPs. CoRR, abs/1507.06527, 2015.
[13] Ji He, Jianshu Chen, Xiaodong He, Jianfeng Gao, Lihong Li, Li Deng, and Mari Ostendorf. Deep reinforcement learning with a natural language action space. In Proc. ACL, pages 1621-1630, 2016.
[14] Sham M Kakade. A natural policy gradient. In Proc. NIPS, pages 1531-1538, 2002.
[15] Yankai Lin, Zhiyuan Liu, Huanbo Luan, Maosong Sun, Siwei Rao, and Song Liu. Modeling relation paths for representation learning of knowledge bases. In EMNLP, 2015.
[16] Yankai Lin, Zhiyuan Liu, Maosong Sun, Yang Liu, and Xuan Zhu. Learning entity and relation embeddings for knowledge graph completion. In AAAI, 2015.
[17] Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Andrei A Rusu, Joel Veness, Marc G Bellemare, Alex Graves, Martin Riedmiller, Andreas K Fidjeland, Georg Ostrovski, et al. Human-level control through deep reinforcement learning. Nature, 518(7540):529, 2015.
[18] Arvind Neelakantan, Benjamin Roth, and Andrew McCallum. Compositional vector space models for knowledge base completion. In Proc. AAAI, 2015.
[19] Maximilian Nickel, Volker Tresp, and Hans-Peter Kriegel. A three-way model for collective learning on multi-relational data. In Proc. ICML, pages 809-816, 2011.
[20] Oystein Ore. Graphs and Their Uses, volume 34. Cambridge University Press, 1990.</p>
<p>[21] Christopher D. Rosin. Multi-armed bandits with episode context. Annals of Mathematics and Artificial Intelligence, 61(3):203-230, Mar 2011.
[22] Yelong Shen, Jianshu Chen, Po-Sen Huang, Yuqing Guo, and Jianfeng Gao. ReinforceWalk: Learning to walk in graph with Monte Carlo tree search. In ICLR workshop, 2018.
[23] Yelong Shen, Po-Sen Huang, Ming-Wei Chang, and Jianfeng Gao. Modeling large-scale structured relationships with shared memory for knowledge base completion. In Proceedings of the 2nd Workshop on Representation Learning for NLP, pages 57-68, 2017.
[24] David Silver, Aja Huang, Chris J Maddison, Arthur Guez, Laurent Sifre, George Van Den Driessche, Julian Schrittwieser, Ioannis Antonoglou, Veda Panneershelvam, Marc Lanctot, et al. Mastering the game of Go with deep neural networks and tree search. Nature, 529(7587):484-489, 2016.
[25] David Silver, Julian Schrittwieser, Karen Simonyan, Ioannis Antonoglou, Aja Huang, Arthur Guez, Thomas Hubert, Lucas Baker, Matthew Lai, Adrian Bolton, et al. Mastering the game of Go without human knowledge. Nature, 550(7676):354, 2017.
[26] David Silver, Hado van Hasselt, Matteo Hessel, Tom Schaul, Arthur Guez, Tim Harley, Gabriel Dulac-Arnold, David Reichert, Neil Rabinowitz, Andre Barreto, and Thomas Degris. The predictron: End-to-end learning and planning. In Proc. ICML, 2017.
[27] Richard S Sutton and Andrew G Barto. Reinforcement Learning: An Introduction, volume 1. MIT press Cambridge, 1998.
[28] Richard S Sutton, David A McAllester, Satinder P Singh, and Yishay Mansour. Policy gradient methods for reinforcement learning with function approximation. In Proc. NIPS, pages 10571063, 2000.
[29] Kristina Toutanova and Danqi Chen. Observed versus latent features for knowledge base and text inference. In Proceedings of the 3rd Workshop on Continuous Vector Space Models and their Compositionality, 2015.
[30] Kristina Toutanova, Xi Victoria Lin, Scott Wen tau Yih, Hoifung Poon, and Chris Quirk. Compositional learning of embeddings for relation paths in knowledge bases and text. In Proc. $A C L, 2016$.
[31] Théo Trouillon, Christopher R Dance, Johannes Welbl, Sebastian Riedel, Éric Gaussier, and Guillaume Bouchard. Knowledge graph completion via complex tensor factorization. Journal of Machine Learning Research, 2017.
[32] Théo Trouillon, Johannes Welbl, Sebastian Riedel, Éric Gaussier, and Guillaume Bouchard. Complex embeddings for simple link prediction. In Proc. ICML, pages 2071-2080, 2016.
[33] Oriol Vinyals, Meire Fortunato, and Navdeep Jaitly. Pointer networks. In Proc. NIPS, pages 2692-2700, 2015.
[34] Theophane Weber, Sébastien Racanière, David P. Reichert, Lars Buesing, Arthur Guez, Danilo Jimenez Rezende, Adrià Puigdomènech Badia, Oriol Vinyals, Nicolas Heess, Yujia Li, Razvan Pascanu, Peter Battaglia, David Silver, and Daan Wierstra. Imagination-augmented agents for deep reinforcement learning. In Proc. NIPS, 2017.
[35] Daan Wierstra, Alexander Förster, Jan Peters, and Jürgen Schmidhuber. Recurrent policy gradients. Logic Journal of the IGPL, 18(5):620-634, 2010.
[36] Ronald J Williams. Simple statistical gradient-following algorithms for connectionist reinforcement learning. In Reinforcement Learning, pages 5-32. Springer, 1992.
[37] Yuhuai Wu, Elman Mansimov, Roger B Grosse, Shun Liao, and Jimmy Ba. Scalable trust-region method for deep reinforcement learning using kronecker-factored approximation. In Proc. NIPS, pages 5285-5294, 2017.
[38] Wenhan Xiong, Thien Hoang, and William Yang Wang. DeepPath: A reinforcement learning method for knowledge graph reasoning. In Proc. EMNLP, pages 575-584, 2017.
[39] Bishan Yang, Wen-tau Yih, Xiaodong He, Jianfeng Gao, and Li Deng. Embedding entities and relations for learning and inference in knowledge bases. In ICLR, 2015.
[40] Fan Yang, Zhilin Yang, and William W Cohen. Differentiable learning of logical rules for knowledge base reasoning. In Proc. NIPS, pages 2316-2325, 2017.</p>
<h1>A Derivation of the recursion for $q_{t}$</h1>
<p>Recalling the definition $q_{t} \triangleq s_{t-1} \cup\left{a_{t-1}, n_{t}\right}$ and using the recursion (1), we have</p>
<p>$$
\begin{aligned}
q_{t+1} &amp; \stackrel{(a)}{=} s_{t} \cup\left{a_{t}, n_{t+1}\right} \
&amp; \stackrel{(b)}{=} s_{t-1} \cup\left{a_{t-1}, n_{t}, \mathcal{E}<em t="t">{n</em>}}, \mathcal{N<em t="t">{n</em>\right} \
&amp; \stackrel{(c)}{=} q_{t} \cup\left{\mathcal{E}}}\right} \cup\left{a_{t}, n_{t+1<em t="t">{n</em>}}, \mathcal{N<em t="t">{n</em>\right}
\end{aligned}
$$}}, a_{t}, n_{t+1</p>
<p>where step (a) uses the definition of $q_{t+1}$, step (b) substitutes the recursion (1), and step (c) uses the definition of $q_{t}$.</p>
<h2>B Algorithm Implementation Details</h2>
<p>The detailed algorithm of M-Walk is described in Algorithm 1.</p>
<div class="codehilite"><pre><span></span><code><span class="nt">Algorithm</span><span class="w"> </span><span class="nt">1</span><span class="w"> </span><span class="nt">M-Walk</span><span class="w"> </span><span class="nt">Training</span><span class="w"> </span><span class="nt">Algorithm</span>
<span class="w">    </span><span class="nt">Input</span><span class="o">:</span><span class="w"> </span><span class="nt">Graph</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="err">\</span><span class="nt">mathcal</span><span class="p">{</span><span class="err">G</span><span class="p">}</span><span class="err">\</span><span class="o">);</span><span class="w"> </span><span class="nt">Initial</span><span class="w"> </span><span class="nt">node</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">n_</span><span class="p">{</span><span class="err">S</span><span class="p">}</span><span class="err">\</span><span class="o">);</span><span class="w"> </span><span class="nt">Query</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">q</span><span class="err">\</span><span class="o">);</span><span class="w"> </span><span class="nt">Target</span><span class="w"> </span><span class="nt">node</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">n_</span><span class="p">{</span><span class="err">T</span><span class="p">}</span><span class="err">\</span><span class="o">);</span><span class="w"> </span><span class="nt">Maximum</span><span class="w"> </span><span class="nt">Path</span><span class="w"> </span><span class="nt">Length</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">T_</span><span class="p">{</span><span class="err">\max</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">;</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">MCTS</span>
<span class="w">        </span><span class="nt">Search</span><span class="w"> </span><span class="nt">Number</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">E</span><span class="err">\</span><span class="o">);</span>
<span class="w">    </span><span class="nt">for</span><span class="w"> </span><span class="nt">episode</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">e</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">in</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="cp">[</span><span class="mi">1</span><span class="w"> </span><span class="nx">.</span><span class="w"> </span><span class="bp">.</span><span class="w"> </span><span class="nx nx-Member">E</span><span class="cp">]</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">do</span>
<span class="w">        </span><span class="nt">Set</span><span class="w"> </span><span class="nt">current</span><span class="w"> </span><span class="nt">node</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">n_</span><span class="p">{</span><span class="err">0</span><span class="p">}</span><span class="o">=</span><span class="nt">n_</span><span class="p">{</span><span class="err">S</span><span class="p">}</span><span class="w"> </span><span class="o">;</span><span class="w"> </span><span class="nt">q_</span><span class="p">{</span><span class="err">0</span><span class="p">}</span><span class="o">=</span><span class="nt">f_</span><span class="p">{</span><span class="err">\theta_{q</span><span class="p">}</span><span class="err">}\</span><span class="nt">left</span><span class="o">(</span><span class="nt">q</span><span class="o">,</span><span class="w"> </span><span class="nt">0</span><span class="o">,</span><span class="nt">0</span><span class="o">,</span><span class="w"> </span><span class="nt">n_</span><span class="p">{</span><span class="err">0</span><span class="p">}</span><span class="err">\</span><span class="nt">right</span><span class="o">)</span><span class="err">\</span><span class="o">)</span>
<span class="w">        </span><span class="nt">for</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">t</span><span class="o">=</span><span class="nt">0</span><span class="w"> </span><span class="err">\</span><span class="nt">ldots</span><span class="w"> </span><span class="nt">T_</span><span class="p">{</span><span class="err">\max</span><span class="w"> </span><span class="p">}</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">do</span>
<span class="w">            </span><span class="nt">Lookup</span><span class="w"> </span><span class="nt">from</span><span class="w"> </span><span class="nt">dictionary</span><span class="w"> </span><span class="nt">to</span><span class="w"> </span><span class="nt">obtain</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">W</span><span class="err">\</span><span class="nt">left</span><span class="o">(</span><span class="nt">s_</span><span class="p">{</span><span class="err">t</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="nt">a</span><span class="err">\</span><span class="nt">right</span><span class="o">)</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">and</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">N</span><span class="err">\</span><span class="nt">left</span><span class="o">(</span><span class="nt">s_</span><span class="p">{</span><span class="err">t</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="nt">a</span><span class="err">\</span><span class="nt">right</span><span class="o">)</span><span class="err">\</span><span class="o">)</span>
<span class="w">            </span><span class="nt">Select</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">action</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">a_</span><span class="p">{</span><span class="err">t</span><span class="p">}</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">with</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">maximum</span><span class="w"> </span><span class="nt">PUCT</span><span class="w"> </span><span class="nt">value</span><span class="o">:</span>
<span class="w">                </span><span class="err">\</span><span class="o">(</span><span class="nt">a_</span><span class="p">{</span><span class="err">t</span><span class="p">}</span><span class="o">=</span><span class="err">\</span><span class="nt">operatorname</span><span class="p">{</span><span class="err">argmax</span><span class="p">}</span><span class="nt">_</span><span class="p">{</span><span class="err">a</span><span class="p">}</span><span class="err">\</span><span class="nt">left</span><span class="err">\</span><span class="p">{</span><span class="err">c</span><span class="w"> </span><span class="err">\cdot</span><span class="w"> </span><span class="err">\pi_{\theta</span><span class="p">}</span><span class="err">\</span><span class="nt">left</span><span class="o">(</span><span class="nt">a</span><span class="w"> </span><span class="err">\</span><span class="nt">mid</span><span class="w"> </span><span class="nt">s_</span><span class="p">{</span><span class="err">t</span><span class="p">}</span><span class="err">\</span><span class="nt">right</span><span class="o">)^</span><span class="p">{</span><span class="err">\beta</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nt">frac</span><span class="p">{</span><span class="err">\sqrt{\sum_{a^{\prime</span><span class="p">}</span><span class="err">}</span><span class="w"> </span><span class="nt">N</span><span class="err">\</span><span class="nt">left</span><span class="o">(</span><span class="nt">s_</span><span class="p">{</span><span class="err">t</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="nt">a</span><span class="o">^</span><span class="p">{</span><span class="err">\prime</span><span class="p">}</span><span class="err">\</span><span class="nt">right</span><span class="o">)</span><span class="err">}}</span><span class="p">{</span><span class="err">1+N\left(s_{t</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="nt">a</span><span class="err">\</span><span class="nt">right</span><span class="o">)</span><span class="err">}</span><span class="o">+</span><span class="err">\</span><span class="nt">frac</span><span class="p">{</span><span class="err">W\left(s_{t</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="nt">a</span><span class="err">\</span><span class="nt">right</span><span class="o">)</span><span class="err">}</span><span class="p">{</span><span class="err">N\left(s_{t</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="nt">a</span><span class="err">\</span><span class="nt">right</span><span class="o">)</span><span class="err">}\</span><span class="nt">right</span><span class="err">\}\</span><span class="o">)</span>
<span class="w">            </span><span class="nt">Update</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">q_</span><span class="p">{</span><span class="err">t+1</span><span class="p">}</span><span class="o">=</span><span class="nt">f_</span><span class="p">{</span><span class="err">\theta_{q</span><span class="p">}</span><span class="err">}\</span><span class="nt">left</span><span class="o">(</span><span class="nt">q_</span><span class="p">{</span><span class="err">t</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="nt">h_</span><span class="p">{</span><span class="err">A,</span><span class="w"> </span><span class="err">t</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="nt">h_</span><span class="p">{</span><span class="err">a_{t</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="nt">t</span><span class="err">}</span><span class="o">,</span><span class="w"> </span><span class="nt">n_</span><span class="p">{</span><span class="err">t+1</span><span class="p">}</span><span class="err">\</span><span class="nt">right</span><span class="o">)</span><span class="err">\</span><span class="o">)</span>
<span class="w">            </span><span class="nt">if</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">a_</span><span class="p">{</span><span class="err">t</span><span class="p">}</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">is</span><span class="w"> </span><span class="nt">STOP</span><span class="w"> </span><span class="nt">then</span>
<span class="w">                </span><span class="nt">Compute</span><span class="w"> </span><span class="nt">estimated</span><span class="w"> </span><span class="nt">reward</span><span class="w"> </span><span class="nt">value</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">V_</span><span class="p">{</span><span class="err">\theta</span><span class="p">}</span><span class="err">\</span><span class="nt">left</span><span class="o">(</span><span class="nt">s_</span><span class="p">{</span><span class="err">t</span><span class="p">}</span><span class="err">\</span><span class="nt">right</span><span class="o">)=</span><span class="nt">Q</span><span class="err">\</span><span class="nt">left</span><span class="o">(</span><span class="nt">s_</span><span class="p">{</span><span class="err">t</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="nt">a_</span><span class="p">{</span><span class="err">t</span><span class="p">}</span><span class="o">=</span><span class="err">\</span><span class="nt">operatorname</span><span class="p">{</span><span class="err">STOP</span><span class="p">}</span><span class="err">\</span><span class="nt">right</span><span class="o">)</span><span class="err">\</span><span class="o">)</span>
<span class="w">                </span><span class="nt">Add</span><span class="w"> </span><span class="nt">generated</span><span class="w"> </span><span class="nt">path</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">p</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">into</span><span class="w"> </span><span class="nt">a</span><span class="w"> </span><span class="nt">path</span><span class="w"> </span><span class="nt">list</span>
<span class="w">                </span><span class="nt">Backup</span><span class="w"> </span><span class="nt">along</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">path</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">p</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">to</span><span class="w"> </span><span class="nt">update</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">visit</span><span class="w"> </span><span class="nt">count</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">N</span><span class="err">\</span><span class="nt">left</span><span class="o">(</span><span class="nt">s_</span><span class="p">{</span><span class="err">t</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="nt">a</span><span class="err">\</span><span class="nt">right</span><span class="o">)</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">using</span><span class="w"> </span><span class="o">(</span><span class="nt">5</span><span class="o">)</span><span class="w"> </span><span class="nt">and</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">total</span><span class="w"> </span><span class="nt">action</span>
<span class="w">                </span><span class="nt">reward</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">W</span><span class="err">\</span><span class="nt">left</span><span class="o">(</span><span class="nt">s_</span><span class="p">{</span><span class="err">t</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="nt">a</span><span class="err">\</span><span class="nt">right</span><span class="o">)</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">using</span><span class="w"> </span><span class="o">(</span><span class="nt">6</span><span class="o">)</span><span class="w"> </span><span class="nt">on</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="err">\</span><span class="nt">left</span><span class="o">(</span><span class="nt">s_</span><span class="p">{</span><span class="err">t</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="nt">a</span><span class="err">\</span><span class="nt">right</span><span class="o">)</span><span class="err">\</span><span class="o">)</span><span class="nt">-th</span><span class="w"> </span><span class="nt">edge</span><span class="w"> </span><span class="nt">on</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">MCTS</span><span class="w"> </span><span class="nt">tree</span>
<span class="w">                </span><span class="nt">Break</span>
<span class="w">                </span><span class="nt">end</span><span class="w"> </span><span class="nt">if</span>
<span class="w">            </span><span class="nt">end</span><span class="w"> </span><span class="nt">for</span>
<span class="w">    </span><span class="nt">end</span><span class="w"> </span><span class="nt">for</span>
<span class="w">    </span><span class="nt">for</span><span class="w"> </span><span class="nt">each</span><span class="w"> </span><span class="nt">path</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">p</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">in</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">path</span><span class="w"> </span><span class="nt">list</span><span class="w"> </span><span class="nt">do</span>
<span class="w">        </span><span class="nt">Set</span><span class="w"> </span><span class="nt">reward</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">r</span><span class="o">=</span><span class="nt">1</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">if</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">end</span><span class="w"> </span><span class="nt">of</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">path</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">n_</span><span class="p">{</span><span class="err">t</span><span class="p">}</span><span class="o">=</span><span class="nt">n_</span><span class="p">{</span><span class="err">T</span><span class="p">}</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">otherwise</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">r</span><span class="o">=</span><span class="nt">0</span><span class="err">\</span><span class="o">)</span>
<span class="w">        </span><span class="nt">Repeatedly</span><span class="w"> </span><span class="nt">update</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">model</span><span class="w"> </span><span class="nt">parameters</span><span class="w"> </span><span class="nt">with</span><span class="w"> </span><span class="nt">Q-learning</span><span class="o">:</span>
<span class="w">            </span><span class="err">\</span><span class="o">(</span><span class="err">\</span><span class="nt">theta</span><span class="w"> </span><span class="err">\</span><span class="nt">leftarrow</span><span class="w"> </span><span class="err">\</span><span class="nt">theta</span><span class="o">+</span><span class="err">\</span><span class="nt">alpha</span><span class="w"> </span><span class="err">\</span><span class="nt">cdot</span><span class="w"> </span><span class="err">\</span><span class="nt">nabla_</span><span class="p">{</span><span class="err">\theta</span><span class="p">}</span><span class="w"> </span><span class="nt">Q_</span><span class="p">{</span><span class="err">\theta</span><span class="p">}</span><span class="err">\</span><span class="nt">left</span><span class="o">(</span><span class="nt">s_</span><span class="p">{</span><span class="err">t</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="nt">a_</span><span class="p">{</span><span class="err">t</span><span class="p">}</span><span class="err">\</span><span class="nt">right</span><span class="o">)</span><span class="w"> </span><span class="err">\</span><span class="nt">times</span><span class="err">\</span><span class="nt">left</span><span class="o">(</span><span class="nt">r</span><span class="err">\</span><span class="nt">left</span><span class="o">(</span><span class="nt">s_</span><span class="p">{</span><span class="err">t</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="nt">a_</span><span class="p">{</span><span class="err">t</span><span class="p">}</span><span class="err">\</span><span class="nt">right</span><span class="o">)+</span><span class="err">\</span><span class="nt">gamma</span><span class="w"> </span><span class="err">\</span><span class="nt">max</span><span class="w"> </span><span class="nt">_</span><span class="p">{</span><span class="err">a^{\prime</span><span class="p">}</span><span class="err">}</span><span class="w"> </span><span class="nt">Q_</span><span class="p">{</span><span class="err">\theta</span><span class="p">}</span><span class="err">\</span><span class="nt">left</span><span class="o">(</span><span class="nt">s_</span><span class="p">{</span><span class="err">t+1</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="nt">a</span><span class="o">^</span><span class="p">{</span><span class="err">\prime</span><span class="p">}</span><span class="err">\</span><span class="nt">right</span><span class="o">)</span><span class="nt">-Q_</span><span class="p">{</span><span class="err">\theta</span><span class="p">}</span><span class="err">\</span><span class="nt">left</span><span class="o">(</span><span class="nt">s_</span><span class="p">{</span><span class="err">t</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="nt">a_</span><span class="p">{</span><span class="err">t</span><span class="p">}</span><span class="err">\</span><span class="nt">right</span><span class="o">)</span><span class="err">\</span><span class="nt">right</span><span class="o">)</span><span class="err">\</span><span class="o">)</span>
<span class="w">    </span><span class="nt">end</span><span class="w"> </span><span class="nt">for</span>
</code></pre></div>

<h2>B. 1 MCTS implementation</h2>
<p>In the MCTS implementation, we maintain a lookup table to record values $W\left(s_{t}, a\right)$ and $N\left(s_{t}, a\right)$ for each visited state-action pair. The state $s_{t}$ in the graph walk problem contains all the information along the traversal path, and $n_{t}$ is the node at the current step $t$. We assign an index $i_{a}$ to each candidate action $a$ from $n_{t}$, indicating that $a$ is the $i_{a}$-th action of the node $n_{t}$. Thus, the state $s_{t}$ can be encoded as a path string $P_{s_{t}}=\left(q, n_{0}, i_{a_{0}}, n_{1}, i_{a_{1}}, \ldots, n_{t}\right)$. We build a dictionary $\mathcal{D}$ using the path string as a key, and we record $W\left(s_{t}, a\right)$ and $N\left(s_{t}, a\right)$ as values in $\mathcal{D}$. In the backup stage, the $W\left(s_{t}, a\right)$ and $N\left(s_{t}, a\right)$ values are updated for each state-action pair along with the traversal path in</p>
<p>MCTS:</p>
<p>$$
\begin{aligned}
N\left(s_{t}, a\right) &amp; =N\left(s_{t}, a\right)+\gamma^{T-t} \
W\left(s_{t}, a\right) &amp; =W\left(s_{t}, a\right)+\gamma^{T-t} V_{\theta}\left(s_{T}\right)
\end{aligned}
$$</p>
<p>where $T$ is the length of the traversal path, $\gamma$ is the discount factor of the MDP, and $V_{\theta}\left(s_{T}\right)$ is the terminal state-value function modeled by $V_{\theta}\left(s_{T}\right) \triangleq Q\left(s_{T}, a=\right.$ STOP $)$.
In our experiments, the softmax temperature parameter $\tau$ in the policy network $\pi_{\theta}$ (see (3)) is set to be a constant. An alternative choice is to anneal it during training (e.g., $\tau=1 \rightarrow 0$ ). However, we did not observe this to produce any significant difference in performance in our experiments. We believe the main reason is that $\pi_{\theta}$ is only used as a prior to bias the MCTS search, while the exploration of MCTS is controlled by the parameters $c$ and $\beta$ of (4).</p>
<h1>B. 2 Experiment details</h1>
<h2>B.2.1 Three Glass Puzzle</h2>
<p><img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>Figure 6: Graph traversal in the Three Glass Puzzle problem.</p>
<p>An example Figure 6 illustrates one step in solving a Three Glass Puzzle. The following action sequences provide one solution to achieve the target $q=4$, given initially empty containers with capacities $(A=8, B=5, C=3)$, where $a, b, c$ denote the current contents of the containers:</p>
<ul>
<li>Initial state $\rightarrow(a=0, b=0, c=0)$</li>
<li>Fill $\mathcal{B} \rightarrow(a=0, b=5, c=0)$</li>
<li>Pour from $\mathcal{B}$ to $\mathcal{C} \rightarrow(a=0, b=2, c=3)$</li>
<li>Empty $\mathcal{C} \rightarrow(a=0, b=2, c=0)$</li>
<li>Pour from $\mathcal{B}$ to $\mathcal{C} \rightarrow(a=0, b=0, c=2)$</li>
<li>Fill $\mathcal{B} \rightarrow(a=0, b=5, c=2)$</li>
<li>Pour from $\mathcal{B}$ to $\mathcal{C} \rightarrow(a=0, b=4, c=3)$</li>
</ul>
<p>Data generation In the Three Glass Puzzle experiments, we randomly draw four integers from $[1,50)$ to represent the capacities $A, B, C$, and the desired volume $q$. We further restrict the values so that $A \geq B \geq C$ and $q&lt;A$, to avoid data duplication. We discard puzzles for which there is no solution. Finally, we keep 600 unique puzzles as the experimental dataset, where 500 puzzles are used for training and the other 100 are used to test a model's generalization capability on the unseen test set.</p>
<p>Experiment settings and hyperparameters Let $a, b, c$ be the current status of each container, and define the puzzle status at step $t$ as $n_{t}=\left[I_{A}^{T}, I_{B}^{T}, I_{C}^{T}, I_{a}^{T}, I_{b}^{T}, I_{c}^{T}\right]^{T}$, where $I_{x}$ is the one-hot representation to encode the value of $x$. Given that $A, B, C, a, b$ and $c$ are all smaller than 50 in the experiment, the dimension of $n_{t}$ is 300. The initial query $q$ is obtained by $q=E_{m b}[q]$, where $E_{m b}$ is a query embedding lookup table and $E_{m b}[x]$ indicates the $x$-th column. The query embedding dimension is set to 64 . In the Three Glass Puzzle, there are 13 actions in total: fill one container to its capacity, empty one container, pour one container into another container, and a STOP action to terminate the game. We set the maximum length of an action sequence (i.e., the search horizon) to be 12 , where only the STOP action can be taken on the final step. After the STOP action has been taken, the system evaluates the action sequence and assigns a reward $r=1$ if the final status is a success, otherwise $r=0$. The $f_{\theta_{S}}$ and $f_{\theta_{A}}$ functions are modeled by two different DNNs with the same architecture: two fully-connected layers with 32 hidden dimensions and ReLU activation function.</p>
<p>Table 5: A List of actions for each container in the Three Glass Puzzle. The agent can also determine to take the STOP action to terminate the game.</p>
<table>
<thead>
<tr>
<th>Empty $\mathcal{A}$</th>
<th>Fill $\mathcal{A}$</th>
<th>Pour $\mathcal{A}$ to $\mathcal{B}$</th>
<th>Pour $\mathcal{A}$ to $\mathcal{C}$</th>
</tr>
</thead>
<tbody>
<tr>
<td>Empty $\mathcal{B}$</td>
<td>Fill $\mathcal{B}$</td>
<td>Pour $\mathcal{B}$ to $\mathcal{A}$</td>
<td>Pour $\mathcal{B}$ to $\mathcal{C}$</td>
</tr>
<tr>
<td>Empty $\mathcal{C}$</td>
<td>Fill $\mathcal{C}$</td>
<td>Pour $\mathcal{C}$ to $\mathcal{A}$</td>
<td>Pour $\mathcal{C}$ to $\mathcal{B}$</td>
</tr>
</tbody>
</table>
<p>Table 6: Knowledge base completion datasets statistics.</p>
<table>
<thead>
<tr>
<th>Dataset</th>
<th># Train</th>
<th># Test</th>
<th># Relation</th>
<th># Entity</th>
<th>avg. degree</th>
<th>median degree</th>
</tr>
</thead>
<tbody>
<tr>
<td>WN18RR</td>
<td>86,835</td>
<td>3,134</td>
<td>11</td>
<td>40,943</td>
<td>2.19</td>
<td>2</td>
</tr>
<tr>
<td>NELL-995</td>
<td>154,213</td>
<td>3,992</td>
<td>200</td>
<td>75,492</td>
<td>4.07</td>
<td>1</td>
</tr>
<tr>
<td>FB15K-237</td>
<td>272,115</td>
<td>20,466</td>
<td>237</td>
<td>14,541</td>
<td>19.74</td>
<td>14</td>
</tr>
</tbody>
</table>
<p><img alt="img-6.jpeg" src="img-6.jpeg" />
(a) Test Beam / Rollout = 128
<img alt="img-7.jpeg" src="img-7.jpeg" />
(b) Test Beam / Rollout = 300</p>
<p>Figure 7: Three Glass Puzzle test accuracy, where "PG" stands for policy gradient.
$f_{\theta_{v}}$ is two fully-connected layers with 16 hidden dimensions, where the first hidden layer uses a ReLU activation function and the output layer uses a linear activation function. $f_{\theta_{q}}$ is modeled by a GRU with hidden size 64. The hyperparameters in PUCT are set to $c=0.5$ and $\beta=0.2$. We use the ADAM optimization algorithm with learning rate 0.0005 during training, and we set the mini-batch size to 8 .</p>
<h1>B.2.2 Knowledge Base Completion</h1>
<p>Statistics of the three datasets The NELL-995 knowledge dataset contains 75, 492 unique entities and 200 relations. WN18RR contains 93,003 triples with 40,943 entities and 11 relations. And FB15k-237, a subset of FB15k where inverse relations are removed, contains 14, 541 entities and 237 relations. The detailed statstics are shown in Table 6.</p>
<p>Experiment settings and hyperparameters For the proposed M-Walk, we set the entity embedding dimension to 4 and relation embedding dimension to 64 . The maximum length of the graph walking path (i.e., the search horizon) is 8 in the NELL-995 dataset and 5 in the WN18RR dataset. After the STOP action has been taken, the system evaluates the action sequence and assigns a reward $r=1$ if the agent reaches the target node, otherwise $r=0$. The initial query $q$ is the concatenation of the entity embedding vector and the relation embedding vector. The $f_{\theta_{S}}$ and $f_{\theta_{A}}$ functions are modeled by two different DNNs with the same architecture: two fully-connected layers with 64 hidden dimensions and the ReLU activation function. $f_{\theta_{v}}$ is two fully-connected layers with 16 hidden dimensions, where the first hidden layer uses a Tanh activation function and the output layer uses a linear activation function. $f_{\theta_{q}}$ is modeled by a GRU with hidden size 64. The hyperparameters in PUCT are set to $c=2$ and $\beta=0.5$. We roll out 32 MCTS paths in both training and testing in the NELL-995 dataset and 128 MCTS paths in the WN18RR dataset. We use the ADAM optimization algorithm for model training with learning rate 0.0001 , and we set the mini-batch size to 8 .</p>
<p>Table 7: Three Glass Puzzle test accuracy (\%), where "Beam" denotes beam search.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Size</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">10</th>
<th style="text-align: center;">50</th>
<th style="text-align: center;">100</th>
<th style="text-align: center;">200</th>
<th style="text-align: center;">300</th>
<th style="text-align: center;">400</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">PG (Beam)</td>
<td style="text-align: center;">$9.3(2.1)$</td>
<td style="text-align: center;">$30.7(4.5)$</td>
<td style="text-align: center;">$39.3(3.2)$</td>
<td style="text-align: center;">$45.3(4.5)$</td>
<td style="text-align: center;">$47.7(3.2)$</td>
<td style="text-align: center;">$48.7(3.2)$</td>
<td style="text-align: center;">$49.0(2.6)$</td>
</tr>
<tr>
<td style="text-align: left;">M-Walk (Beam)</td>
<td style="text-align: center;">$18.0(1.7)$</td>
<td style="text-align: center;">$46.0(7.0)$</td>
<td style="text-align: center;">$60.3(7.8)$</td>
<td style="text-align: center;">$67.0(7.0)$</td>
<td style="text-align: center;">$69.0(6.2)$</td>
<td style="text-align: center;">$69.3(6.4)$</td>
<td style="text-align: center;">$71.7(4.5)$</td>
</tr>
<tr>
<td style="text-align: left;">M-Walk (MCTS)</td>
<td style="text-align: center;">$\mathbf{1 8 . 0}(1.7)$</td>
<td style="text-align: center;">$\mathbf{6 3 . 3}(5.0)$</td>
<td style="text-align: center;">$\mathbf{8 4 . 3}(3.1)$</td>
<td style="text-align: center;">$\mathbf{9 0 . 7}(2.5)$</td>
<td style="text-align: center;">$\mathbf{9 5 . 0}(2.6)$</td>
<td style="text-align: center;">$\mathbf{9 6 . 3}(1.5)$</td>
<td style="text-align: center;">$\mathbf{9 9 . 0}(1.0)$</td>
</tr>
</tbody>
</table>
<p>Table 8: BFS, DFS and M-Walk on Three Glass Puzzle.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Method</th>
<th style="text-align: center;">Average # Steps</th>
<th style="text-align: center;">Max # Steps</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">BFS</td>
<td style="text-align: center;">264.7</td>
<td style="text-align: center;">1030</td>
</tr>
<tr>
<td style="text-align: center;">DFS</td>
<td style="text-align: center;">192.2</td>
<td style="text-align: center;">1453</td>
</tr>
<tr>
<td style="text-align: center;">M-Walk</td>
<td style="text-align: center;">94.9</td>
<td style="text-align: center;">897</td>
</tr>
</tbody>
</table>
<h1>C Additional Experiments</h1>
<h2>C. 1 The Three Glass Puzzle task in different settings</h2>
<p>We now present more experiments on the Three Glass Puzzle task under different settings. First, to see how fast M-Walk converges, we show in Figure 7 the learning curves of M-Walk and PG. It shows that M-Walk converges much faster than PG and achieves better results on this task. In Table 7, we report the test accuracy of M-Walk and vanilla policy gradient (REINFORCE/PG) with different beam search sizes and different MCTS rollouts during testing. The number of MCTS simulations for training M-Walk is fixed to be 32 . We observe that M-Walk with MCTS achieves the best test accuracy overall. In addition, with larger beam search sizes and MCTS rollouts, the test accuracy improves substantially. Furthermore, replacing the MCTS in M-Walk by beam search at test time degrades the performance greatly, which shows that MCTS is also very important for M-Walk at test time.</p>
<p>As mentioned earlier, conventional graph traversal algorithms such as Breadth-First Search (BFS) and Depth-First Search (DFS) cannot be applied to the graph walking problem, because the ground truth target node is not known at test time. However, to understand how quickly M-Walk with MCTS can find the correct target node, we compare it with BFS and DFS in the following cheating setup. Specifically, we apply BFS and DFS to the test set of the Three Glass Puzzle task by disclosing the target node to them. In Table 8, we report the average traversal steps and maximum steps to reach the target node. The M-Walk with MCTS algorithm is able to find the target node more efficiently than BFS or DFS.</p>
<h2>C.1.1 Knowledge Graph Link Prediction</h2>
<p>In this section, we first provide additional experimental results for the NELL995 and WN18RR tasks to support our analysis. In Figure 8, we show the positive reward rate during training on the NELL995 task. And in Figure 9, we provide more hyperparameter analysis (search horizon and MCTS simulation number) and training-time analysis. Furthermore, in Table 9, we show the HITS@K and MRR results on NELL995.</p>
<p>In addition, we conduct further experiments on the FB15k-237 dataset [29], which is a subset of FB15k [2] with inverse relations being removed. We use the same data split and preprocessing protocol as in [6] for FB15k-237. The results are reported in Table 10. We observe that M-Walk outperforms the other RL-based method (MINERVA). However, it is still worse than the embedding-based methods. In future work, we intend to combine the strength of embedding-based methods and our method to further improve the performance of M-Walk.</p>
<h2>C. 2 The Reasoning (Traversal) Paths</h2>
<p>In Table 11, we show the reasoning paths of M-Walk on the NELL995 dataset. Each reasoning path is generated by following the edges on the MCTS tree with the highest visiting count $N(s, a)$.</p>
<p><img alt="img-8.jpeg" src="img-8.jpeg" /></p>
<p>Figure 8: The positive reward rate during training (i.e., percentage of trajectories with positive reward during training) on the NELL-995 task.
<img alt="img-9.jpeg" src="img-9.jpeg" /></p>
<p>Figure 9: M-Walk hyperparameter and error analysis on WN18RR.</p>
<p>Table 9: The HITS@K and MRR results on the NELL995 dataset.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Metric (\%)</th>
<th style="text-align: center;">M-Walk</th>
<th style="text-align: center;">PG-Walk</th>
<th style="text-align: center;">Q-Walk</th>
<th style="text-align: center;">MINERVA</th>
<th style="text-align: center;">ComplEx</th>
<th style="text-align: center;">ConvE</th>
<th style="text-align: center;">DistMult</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">HITS@1</td>
<td style="text-align: center;">$\mathbf{6 8 . 4}$</td>
<td style="text-align: center;">66.7</td>
<td style="text-align: center;">66.8</td>
<td style="text-align: center;">66.3</td>
<td style="text-align: center;">61.2</td>
<td style="text-align: center;">67.2</td>
<td style="text-align: center;">61.0</td>
</tr>
<tr>
<td style="text-align: left;">HITS@3</td>
<td style="text-align: center;">$\mathbf{8 1 . 0}$</td>
<td style="text-align: center;">77.5</td>
<td style="text-align: center;">77.3</td>
<td style="text-align: center;">77.3</td>
<td style="text-align: center;">76.1</td>
<td style="text-align: center;">80.8</td>
<td style="text-align: center;">73.3</td>
</tr>
<tr>
<td style="text-align: left;">MRR</td>
<td style="text-align: center;">$\mathbf{7 5 . 4}$</td>
<td style="text-align: center;">74.8</td>
<td style="text-align: center;">74.5</td>
<td style="text-align: center;">72.5</td>
<td style="text-align: center;">69.4</td>
<td style="text-align: center;">74.7</td>
<td style="text-align: center;">68.0</td>
</tr>
</tbody>
</table>
<p>Table 10: The results on the FB15k-237 dataset, in the form of "mean (standard deviation)".</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Metric (\%)</th>
<th style="text-align: center;">M-Walk</th>
<th style="text-align: center;">PG-Walk</th>
<th style="text-align: center;">Q-Walk</th>
<th style="text-align: center;">MINERVA</th>
<th style="text-align: center;">ComplEx</th>
<th style="text-align: center;">ConvE</th>
<th style="text-align: center;">DistMult</th>
<th style="text-align: center;">NeuralLP</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">HITS@1</td>
<td style="text-align: center;">$16.5(0.3)$</td>
<td style="text-align: center;">$14.8(0.2)$</td>
<td style="text-align: center;">$15.5(0.2)$</td>
<td style="text-align: center;">$14.1(0.2)$</td>
<td style="text-align: center;">$20.8(0.2)$</td>
<td style="text-align: center;">$23.3(0.4)$</td>
<td style="text-align: center;">$20.6(0.4)$</td>
<td style="text-align: center;">$18.2(0.6)$</td>
</tr>
<tr>
<td style="text-align: left;">HITS@3</td>
<td style="text-align: center;">$24.3(0.2)$</td>
<td style="text-align: center;">$23.3(0.3)$</td>
<td style="text-align: center;">$23.8(0.4)$</td>
<td style="text-align: center;">$23.2(0.4)$</td>
<td style="text-align: center;">$32.6(0.5)$</td>
<td style="text-align: center;">$33.8(0.3)$</td>
<td style="text-align: center;">$31.8(0.2)$</td>
<td style="text-align: center;">$27.2(0.3)$</td>
</tr>
<tr>
<td style="text-align: left;">MRR</td>
<td style="text-align: center;">$23.2(0.2)$</td>
<td style="text-align: center;">$21.3(0.1)$</td>
<td style="text-align: center;">$21.8(0.2)$</td>
<td style="text-align: center;">$20.5(0.3)$</td>
<td style="text-align: center;">$29.6(0.2)$</td>
<td style="text-align: center;">$30.8(0.2)$</td>
<td style="text-align: center;">$29.0(0.2)$</td>
<td style="text-align: center;">$24.9(0.2)$</td>
</tr>
</tbody>
</table>
<p>Table 11: Examples of paths found by M-Walk on the NELL-995 dataset.
(i) WorksFor:
journalist jerome holtzman ${ }^{\text {Mwikofon }}$ ?
journalist jerome holtzman ${ }^{\text {femoulet@medicalintellion }}$ website chicago tribune, (Trier)
politician muli hannemann ${ }^{\text {Mwikofon }}$ ?
politician muli hannemann ${ }^{\text {femoulet@medicalintellion@medicalintellion }}$ city honolulu, (Trier)
ceo kumar birla ${ }^{\text {Mwikofon }}$ ?
ceo kumar birla ${ }^{\text {femoulet.cab@hppobioilow }}$ company hindalco, (Trier)
professor chad deaton ${ }^{\text {Mwikofon }}$ ?
professor chad deaton ${ }^{\text {femoulet.cab@hppobioilow }}$ BiotechCompany baker hughes, (Fulw)
(ii) TransPlaySport:
SportsTeam arizona diamond backs ${ }^{\text {TransPlaySport }}$ ?
SportsTeam arizona diamond backs ${ }^{\text {TransPlaySport }}$ ? StadiumOrEventVenue chase field ${ }^{\text {TranPlayShoo }}$ sport baseball, (Trier)
SportsTeam I_a kings ${ }^{\text {TransPlaySport }}$ ?
SportsTeam I_a kings ${ }^{\text {TransPlay+SprintTower }}{ }^{\text {T }}$ SportsTeam red wings ${ }^{\text {TranPlayTrophy }}$ AwardTrophyTournament stanley cup ${ }^{\text {ChampionshipCanoid@TechnicalSport }}$ sport hockey, (Trier)
SportsTeam cleveland browns ${ }^{\text {TransPlaySport }}$ ?
SportsTeam cleveland browns ${ }^{\text {TransPlay+SprintTower }}{ }^{\text {T }}$ SportsTeam yankees ${ }^{\text {TranPlayShoo }}$ AwardTrophyTournament yankee stadium ${ }^{\text {SportTruckballon }}{ }^{\text {T }}$ sport baseball, (Fulw)</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{11}$ A preliminary version of M-Walk with limited experiments was reported in the workshop paper [22].&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref5:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref6:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref7:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>