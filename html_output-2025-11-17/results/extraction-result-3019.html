<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-3019 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-3019</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-3019</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-73.html">extraction-schema-73</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, internal representations, interventions, and performance on arithmetic tasks.</div>
                <p><strong>Paper ID:</strong> paper-2a7ae3e98357569c41424dacd60c62d3df78a0db</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/2a7ae3e98357569c41424dacd60c62d3df78a0db" target="_blank">Limitations of Language Models in Arithmetic and Symbolic Induction</a></p>
                <p><strong>Paper Venue:</strong> Annual Meeting of the Association for Computational Linguistics</p>
                <p><strong>Paper TL;DR:</strong> Surprisingly, large pretrained Language Models have limitations on certain basic symbolic manipulation tasks such as copy, reverse, and addition, when the total number of symbols or repeating symbols increases, the model performance drops quickly.</p>
                <p><strong>Paper Abstract:</strong> Recent work has shown that large pretrained Language Models (LMs) can not only perform remarkably well on a range of Natural Language Processing (NLP) tasks but also start improving on reasoning tasks such as arithmetic induction, symbolic manipulation, and commonsense reasoning with increasing size of models. However, it is still unclear what the underlying capabilities of these LMs are. Surprisingly, we find that these models have limitations on certain basic symbolic manipulation tasks such as copy, reverse, and addition. When the total number of symbols or repeating symbols increases, the model performance drops quickly. We investigate the potential causes behind this phenomenon and examine a set of possible methods, including explicit positional markers, fine-grained computation steps, and LMs with callable programs. Experimental results show that none of these techniques can solve the simplest addition induction problem completely. In the end, we introduce LMs with tutor, which demonstrates every single step of teaching. LMs with tutor is able to deliver 100% accuracy in situations of OOD and repeating symbols, shedding new insights on the boundary of large LMs in induction.</p>
                <p><strong>Cost:</strong> 0.016</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e3019.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e3019.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, internal representations, interventions, and performance on arithmetic tasks.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>GPT-3 (text-davinci-002)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>GPT-3 (OpenAI text-davinci-002 instance used in experiments)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An autoregressive Transformer LLM used via few-shot prompting in the paper; evaluated on copying, reversing, and multi-digit addition with and without intermediate steps or callable programs.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>GPT-3 (text-davinci-002)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Autoregressive Transformer language model (GPT-family); paper uses the text-davinci-002 instance via prompting (exact model size not specified in this paper).</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>Copying, reversing lists, multi-digit addition (1–30 digits in experiments), both in-distribution (1–5 digits) and out-of-distribution (longer digits/items).</td>
                        </tr>
                        <tr>
                            <td><strong>reported_mechanism</strong></td>
                            <td>Appears to rely on pattern-matching and implicit sequence representations; benefits from chain-of-thought / scratchpad style intermediate steps (fine-grained computation) and from explicit scaffolding (callable programs or tutor actions) that reduce the hypothesis space.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>Prompting GPT-3 directly achieves strong in-distribution copying (100% on 1–5 digits). Fine-grained (scratchpad) prompts improve OOD addition accuracy; callable programs improve OOD generalization; GPT-3 + tutor attains 100% OOD accuracy. The paper reports that providing intermediate steps reduces errors, consistent with an algorithmic decomposition benefit.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_against_mechanism</strong></td>
                            <td>GPT-3 still fails on long repeating-digit copying beyond ~30 digits and on reversing beyond ~20 items, showing pattern-matching/implicit representations do not reliably implement robust algorithmic indexing/locating. Even with callable programs, errors occur when the LM selects wrong tokens to feed to the function (example shown in Appendix A.1).</td>
                        </tr>
                        <tr>
                            <td><strong>intervention_type</strong></td>
                            <td>Few-shot prompting; coarse- and fine-grained intermediate steps (scratchpad-style); explicit positional markers in prompts; callable program invocation; LM with tutor (action sequence supervision).</td>
                        </tr>
                        <tr>
                            <td><strong>effect_of_intervention</strong></td>
                            <td>Coarse/fine-grained steps improved in-distribution and OOD performance (finer-grained better); explicit positional markers further boost accuracy; callable programs improve OOD generalization but still degrade with length; LM+tutor achieved perfect (100%) generalization on OOD and repeating-symbol cases in experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Copy: GPT-3 100% in-distribution (1–5 digits); generalization to copying degrades beyond ~30 digits. Addition: improved by scratchpad; exact numeric curves shown in paper Figure 9(d); callable programs improve OOD but still degrade with digit length. Reverse: GPT-3 fails beyond ~20 items. (Paper gives per-experiment curves; specific numeric highlights: T5 baseline 78% on 5-digit repeating copy vs GPT-3 100% in-dist; DeBERTa/T5 near 0% OOD in some settings.)</td>
                        </tr>
                        <tr>
                            <td><strong>notable_failure_modes</strong></td>
                            <td>Fails on long repeating symbols and out-of-distribution lengths; locating ambiguity for repeated tokens; skipping digits (overfitting to fixed-length training patterns); mistakes in selecting which token to pass to callable functions (chaining errors).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_humans_or_symbolic</strong></td>
                            <td>Paper contrasts GPT-3 behavior with human-tutored algorithmic action sequences: humans use explicit cursor and per-digit actions; GPT-3 benefits from sketching intermediate steps but does not naturally discover the full algorithm without tutor-style supervision or external callable functions.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Limitations of Language Models in Arithmetic and Symbolic Induction', 'publication_date_yy_mm': '2022-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3019.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e3019.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, internal representations, interventions, and performance on arithmetic tasks.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>T5-base</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>T5-base (text-to-text Transfer Transformer, base size)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A seq2seq Transformer model fine-tuned on symbolic tasks in the paper (T5-base, ~220M parameters), evaluated on copying, reversing, and addition with augmentations like positional markers and fine-grained steps.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>T5-base (220M)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Encoder-decoder Transformer (T5) base model; the paper fine-tuned T5-base (reported size 220M) on task-specific data (training regimes detailed in appendix).</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>Copying, reversing, and multi-digit addition (1–30 digits/items evaluated); both in-distribution (1–5 digits/items) and OOD tests (longer lengths and repeating symbols).</td>
                        </tr>
                        <tr>
                            <td><strong>reported_mechanism</strong></td>
                            <td>Learns to copy/compute via sequence-to-sequence mapping; benefits from explicit positional markers (breaking symbol repetition) and fine-grained scratchpad steps, but tends to overfit to training-length patterns when fine-tuned.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>T5 fine-tuned without markers obtains only 78% on 5-digit repeating copying despite being in-distribution; adding ordered/random explicit positional markers yields 100% in-distribution accuracy and better OOD generalization. Fine-grained computation steps sometimes help but less than for GPT-3, likely because fine-tuning overfits.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_against_mechanism</strong></td>
                            <td>Even with positional markers and fine-grained steps, T5 often fails to generalize to longer OOD lengths (examples show 0% OOD in some settings), indicating its learned mapping is not robustly algorithmic.</td>
                        </tr>
                        <tr>
                            <td><strong>intervention_type</strong></td>
                            <td>Fine-tuning on augmented datasets; explicit ordered/random positional markers; fine-grained intermediate (scratchpad) steps; reference markers; LM+tutor training examples.</td>
                        </tr>
                        <tr>
                            <td><strong>effect_of_intervention</strong></td>
                            <td>Explicit positional markers (ordered or random) substantially improve in-distribution accuracy to 100% and improve OOD generalization compared to baseline; fine-grained steps had mixed effect (less OOD benefit than for GPT-3 due to overfitting). T5+tutor obtains 100% accuracy OOD in experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Copy: T5 baseline achieved 78% on 5-digit repeating copy in one reported setting; T5+ordered/random markers achieved 100% in-distribution; OOD performance improved but still limited for long lengths. Addition: T5 with positional markers and/or fine-grained steps had improved in-distribution accuracy; OOD often remains poor (figures 9e/f).</td>
                        </tr>
                        <tr>
                            <td><strong>notable_failure_modes</strong></td>
                            <td>Overfitting to training sequence lengths causing direct-output skipping behavior on longer inputs (error case where model outputs after 5 digits even when given 6-digit input); inability to generalize to OOD lengths in many settings despite positional markers; difficulty in locating repeated tokens without markers.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_humans_or_symbolic</strong></td>
                            <td>T5 requires explicit scaffolding (positional markers or tutor) to achieve human-like generalization; fine-tuning alone does not produce reliable algorithmic behavior like symbolic calculators.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Limitations of Language Models in Arithmetic and Symbolic Induction', 'publication_date_yy_mm': '2022-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3019.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e3019.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, internal representations, interventions, and performance on arithmetic tasks.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>DeBERTa-base</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>DeBERTa-base (disentangled attention BERT variant)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A Transformer encoder model using disentangled token and position attention (DeBERTa); evaluated (DeBERTa-base ~140M) on the same symbolic tasks to probe implicit positional marker effects.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>DeBERTa-base (140M)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Transformer encoder with disentangled relative position embeddings and attention (DeBERTa); the paper fine-tunes DeBERTa-base on the symbolic tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>Copying, reversing, and multi-digit addition (1–30 digits/items; in-distribution and OOD evaluations).</td>
                        </tr>
                        <tr>
                            <td><strong>reported_mechanism</strong></td>
                            <td>Implicit positional markers via disentangled relative position embeddings alter attention scores by content and relative position (helping locate tokens without explicit markers).</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>DeBERTa achieves near 100% in-distribution accuracy on copying and addition tasks without explicit markers, indicating disentangled relative position embeddings act as implicit positional markers improving locating ability in-distribution.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_against_mechanism</strong></td>
                            <td>DeBERTa shows severe overfitting and fails to generalize OOD (0% OOD in some additions), suggesting its implicit position mechanism does not solve OOD induction; it overfits quickly (achieves 100% in-dist very fast then OOD performance is poor).</td>
                        </tr>
                        <tr>
                            <td><strong>intervention_type</strong></td>
                            <td>Fine-tuning with task examples (including fine-grained steps in some configurations); comparison between implicit positional embeddings vs explicit markers.</td>
                        </tr>
                        <tr>
                            <td><strong>effect_of_intervention</strong></td>
                            <td>Implicit position embeddings improve in-distribution performance but do not help OOD generalization; adding scratchpad steps to DeBERTa does not remediate OOD failures reported.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>DeBERTa near 100% in-distribution on copy/add tasks reported, but ~0% OOD accuracy in several experiments (figures cited in paper). Overfits within few thousand optimization steps.</td>
                        </tr>
                        <tr>
                            <td><strong>notable_failure_modes</strong></td>
                            <td>Severe overfitting and lack of OOD generalization despite strong in-distribution performance; inability to generalize to longer sequences/repeating symbols even though relative-position signals exist.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_humans_or_symbolic</strong></td>
                            <td>Implicit positional embeddings provide a representation-level advantage vs vanilla positional sums, but do not confer human-like algorithmic induction; authors contrast this with explicit tutoring/action sequences that do generalize.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Limitations of Language Models in Arithmetic and Symbolic Induction', 'publication_date_yy_mm': '2022-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3019.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e3019.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, internal representations, interventions, and performance on arithmetic tasks.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Explicit Positional Markers</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Explicit positional markers (ordered and random insertion)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A mitigation method that inserts explicit position tokens (markers) into the input sequence (either in-order or in random order) to disambiguate repeating symbols and help models locate tokens.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Applied to T5 and GPT-3 in experiments (and compared to DeBERTa implicit markers)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Not a model but an input intervention: each digit/item is paired with a unique positional marker (e.g., A 2 B 2 C 2 or random markers E 2 X 2 J 2) so repeated symbols are no longer identical tokens.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>Copying, reversing, and multi-digit addition with repeated symbols and OOD length tests.</td>
                        </tr>
                        <tr>
                            <td><strong>reported_mechanism</strong></td>
                            <td>Breaks symmetry of repeating tokens so the LM can learn token-indexed operations rather than relying on pattern matching; relates to pointer-network behavior by enabling disambiguation of positions.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>T5 augmented with ordered or random positional markers achieved 100% in-distribution copying and improved OOD generalization compared to vanilla T5; positional markers made induction of arithmetic easier in experiments (figures 9).</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_against_mechanism</strong></td>
                            <td>DeBERTa's implicit markers sometimes outperform explicit markers in-distribution but still fail OOD; explicit markers do not fully solve all OOD/generalization issues (models can still overfit), and in some reversing tasks positional markers did not significantly improve generalization.</td>
                        </tr>
                        <tr>
                            <td><strong>intervention_type</strong></td>
                            <td>Input augmentation: ordered and random explicit positional tokens inserted into training and/or prompts.</td>
                        </tr>
                        <tr>
                            <td><strong>effect_of_intervention</strong></td>
                            <td>Increased in-distribution accuracy to 100% in many T5 settings; improved OOD behavior relative to unaugmented T5 but not a complete solution (models can still fail on long OOD examples or on reversing tasks where locating distances grow).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>T5 + ordered/random markers: 100% in-distribution copying accuracy; better OOD curves than baseline (detailed curves in paper Figures 9a and 9d-f). Noted that DeBERTa (implicit) still failed OOD while T5+markers generalized further.</td>
                        </tr>
                        <tr>
                            <td><strong>notable_failure_modes</strong></td>
                            <td>Does not guarantee OOD generalization for all tasks (e.g., reversing); requires markers to be present in training/prompt (increasing input complexity); fine-tuning can still overfit to particular marker patterns.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_humans_or_symbolic</strong></td>
                            <td>Authors liken explicit markers to giving unique identifiers to tokens (similar to strengthening pointer signals), whereas humans use positional awareness; markers reduce hypothesis space and ease learning, but are an engineered crutch compared to algorithmic human procedures.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Limitations of Language Models in Arithmetic and Symbolic Induction', 'publication_date_yy_mm': '2022-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3019.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e3019.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, internal representations, interventions, and performance on arithmetic tasks.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Fine-grained Computation Steps (Scratchpad)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Fine-grained computation steps / Scratchpad intermediate-step supervision</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Supplying explicit intermediate computational steps (scratchpad/chain-of-thought style) in prompts or fine-tuning data so the LM generates stepwise intermediate results instead of only final answers.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Show your work: Scratchpads for intermediate computation with language models.</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Applied to GPT-3 (prompting) and T5/DeBERTa (fine-tuning) in experiments</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Intervention that provides algorithmic intermediate steps (coarse or fine-grained) in exemplars/prompts or training targets, enabling the LM to output a sequence of internal steps resembling human computation.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>Multi-digit addition (k-digit broken into k 1-digit additions), reversing and copy tasks with stepwise actions.</td>
                        </tr>
                        <tr>
                            <td><strong>reported_mechanism</strong></td>
                            <td>Enables the model to approximate an algorithmic decomposition by producing intermediate states, effectively increasing the 'computation time' available and reducing the complexity per generation step.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>GPT-3 shows substantial gains when using fine-grained steps (larger improvement than coarse-grained); on addition, finer-grained scratchpad examples produced better in-distribution and OOD performance. Prior work (Nye et al.) also supports improvement with scratchpad.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_against_mechanism</strong></td>
                            <td>Fine-grained steps do not fully solve repeating-symbol locating issues; T5 fine-tuning with scratchpad can overfit and still fails OOD; DeBERTa still shows 0% OOD despite scratchpad, indicating step-supervision alone is insufficient.</td>
                        </tr>
                        <tr>
                            <td><strong>intervention_type</strong></td>
                            <td>Prompting (few-shot chain-of-thought / scratchpad exemplars) and fine-tuning on augmented datasets that include intermediate computation steps.</td>
                        </tr>
                        <tr>
                            <td><strong>effect_of_intervention</strong></td>
                            <td>Improved both in-distribution and OOD accuracy especially for GPT-3; effect size depends on granularity (finer steps better). Does not fully eliminate errors for repeating digits or long OOD sequences.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Finer-grained scratchpad prompting improved GPT-3 addition performance substantially (see Figure 9d); T5+scratchpad showed more modest OOD improvements and was prone to overfitting (see Figures 9e/f and Appendix discussion).</td>
                        </tr>
                        <tr>
                            <td><strong>notable_failure_modes</strong></td>
                            <td>Does not resolve locating/repetition failures by itself; potential overfitting when models are fine-tuned on scratchpad data; requires many examples for full effect in some settings.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_humans_or_symbolic</strong></td>
                            <td>Analogous to showing step-by-step solution work to students; authors note that human tutoring includes additional visual/cursor steps not captured by standard scratchpad, motivating the tutor method.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Limitations of Language Models in Arithmetic and Symbolic Induction', 'publication_date_yy_mm': '2022-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3019.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e3019.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, internal representations, interventions, and performance on arithmetic tasks.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Callable Programs</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>LM with callable programs (external function calls)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A method where the LM emits function-call tokens (e.g., add(1,5)) and an external callable implements primitive operations (convert/add/combine), returning correct results deterministically.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Applied to GPT-3 in prompting experiments and conceptually to other models</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Intervention coupling an LM with external deterministic subroutines: the LM produces textual function-call invocations; the system executes the function and appends the returned result to the LM's generation context.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>Multi-digit addition decomposed into callable primitives (convert digits, add single digits with carry, combine results); used also conceptually for copying/splitting tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>reported_mechanism</strong></td>
                            <td>Delegates low-level symbolic operations to exact deterministic programs, leaving the LM responsible for orchestration (which tokens to copy, ordering of calls, chaining subroutines).</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>Callable programs guarantee correctness of the primitive results and improve OOD generalization (GPT-3 + callable programs shows better OOD accuracy than pure prompting), demonstrating benefit of offloading algorithmically exact parts.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_against_mechanism</strong></td>
                            <td>LM still makes errors in selecting or specifying which tokens to pass to calls, causing incorrect chaining (Appendix A.1 shows example where convert produced wrong token grouping leading to later incorrect add call). Thus callable programs do not eliminate locating/selection errors.</td>
                        </tr>
                        <tr>
                            <td><strong>intervention_type</strong></td>
                            <td>Tool use: external deterministic functions invoked during generation (convert, add, combine).</td>
                        </tr>
                        <tr>
                            <td><strong>effect_of_intervention</strong></td>
                            <td>Substantial OOD improvement for addition vs pure prompting; still degrades with increasing digit length and remains vulnerable to LM orchestration errors (wrong arguments to functions).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>GPT-3 + callable programs obtains much better OOD generalization in addition experiments (Figure 9d), but performance still declines with digit length; exact numeric curves in paper show improved but non-perfect OOD accuracy.</td>
                        </tr>
                        <tr>
                            <td><strong>notable_failure_modes</strong></td>
                            <td>Mistakes in selecting/copying the correct input tokens to pass to functions; skipping or mis-indexing tokens before calls, causing downstream arithmetic errors despite correct primitive function behavior.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_humans_or_symbolic</strong></td>
                            <td>Similar to using a calculator for primitives: callable programs are correct like symbolic computation, but the LM must act as the controller (analogous to a human deciding what subroutine to call); authors highlight that callable programs alone don't solve locating.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Limitations of Language Models in Arithmetic and Symbolic Induction', 'publication_date_yy_mm': '2022-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3019.6">
                <h3 class="extraction-instance">Extracted Data Instance 6 (e3019.6)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, internal representations, interventions, and performance on arithmetic tasks.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>LM with Tutor</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>LM with Tutor (fine-grained action-sequence tutoring / imitation learning)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A novel method introduced in this paper where the LM is trained or prompted to generate explicit fine-grained action sequences (cursor moves, copy/add actions, end checks) that mimic a human tutor's per-token teaching; actions can call primitive subroutines.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Applied to GPT-3 and T5 in experiments (training/prompting with tutor-style demonstrations)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Intervention combining imitation-learning style supervision and abstraction: each training example encodes the smallest atomic actions (rmov/lmov, cpy, add, end) and sometimes uses abstract callable primitives; models learn to predict the next action state transition.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>Copying, reversing, and multi-digit addition; tested on in-distribution and out-of-distribution lengths including repeating symbols (up to 80 digits/items tested for copying).</td>
                        </tr>
                        <tr>
                            <td><strong>reported_mechanism</strong></td>
                            <td>Reduces hypothesis space by teaching the LM the explicit action/state transitions (akin to programming a multi-tape Turing machine); the LM learns to generate actions rather than directly generate intermediate numeric results, which yields algorithmic, length-generalizable behavior.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>LM+tutor achieves 100% accuracy across all experimented OOD lengths and repeating-symbol cases for copying, reversing, and addition (reported repeatedly in experiments), demonstrating perfect generalization under this supervision style.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_against_mechanism</strong></td>
                            <td>No counter-evidence presented in the paper's experiments; authors note there's no guaranteed proof that Transformer must learn the correct model, but empirical results show perfect generalization in their test suite.</td>
                        </tr>
                        <tr>
                            <td><strong>intervention_type</strong></td>
                            <td>Training/prompting with atomic action sequences (imitation learning), optionally combined with callable primitives for atomic operations.</td>
                        </tr>
                        <tr>
                            <td><strong>effect_of_intervention</strong></td>
                            <td>Completely solved the experimental induction/OOD/repetition failures reported: both T5+tutor and GPT-3+tutor achieved 100% OOD accuracy across tasks in the reported experiments, unlike other interventions.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Reported as 100% accuracy on copying, reversing and addition across all experimented out-of-distribution lengths and repeated-symbol settings (paper emphasizes tutor method yields perfect results in their tests).</td>
                        </tr>
                        <tr>
                            <td><strong>notable_failure_modes</strong></td>
                            <td>Paper does not report failures for the tutor approach within their experimental range; authors caution no formal guarantee and feasibility depends on availability of action-level supervision or a sketch-generation stage.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_humans_or_symbolic</strong></td>
                            <td>Directly inspired by human tutoring: action sequences mimic how a human tutor points and shows per-digit operations; authors equate the learned action model to implementing a multi-tape Turing machine state transitions, i.e., algorithmic/symbolic behavior.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Limitations of Language Models in Arithmetic and Symbolic Induction', 'publication_date_yy_mm': '2022-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Show your work: Scratchpads for intermediate computation with language models. <em>(Rating: 2)</em></li>
                <li>Chain of thought prompting elicits reasoning in large language models. <em>(Rating: 2)</em></li>
                <li>Investigating the limitations of the transformers with simple arithmetic tasks. <em>(Rating: 2)</em></li>
                <li>Language models are few-shot learners. <em>(Rating: 2)</em></li>
                <li>Neural turing machines. <em>(Rating: 1)</em></li>
                <li>Deberta: decoding-enhanced bert with disentangled attention. <em>(Rating: 2)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-3019",
    "paper_id": "paper-2a7ae3e98357569c41424dacd60c62d3df78a0db",
    "extraction_schema_id": "extraction-schema-73",
    "extracted_data": [
        {
            "name_short": "GPT-3 (text-davinci-002)",
            "name_full": "GPT-3 (OpenAI text-davinci-002 instance used in experiments)",
            "brief_description": "An autoregressive Transformer LLM used via few-shot prompting in the paper; evaluated on copying, reversing, and multi-digit addition with and without intermediate steps or callable programs.",
            "citation_title": "",
            "mention_or_use": "use",
            "model_name": "GPT-3 (text-davinci-002)",
            "model_description": "Autoregressive Transformer language model (GPT-family); paper uses the text-davinci-002 instance via prompting (exact model size not specified in this paper).",
            "arithmetic_task_type": "Copying, reversing lists, multi-digit addition (1–30 digits in experiments), both in-distribution (1–5 digits) and out-of-distribution (longer digits/items).",
            "reported_mechanism": "Appears to rely on pattern-matching and implicit sequence representations; benefits from chain-of-thought / scratchpad style intermediate steps (fine-grained computation) and from explicit scaffolding (callable programs or tutor actions) that reduce the hypothesis space.",
            "evidence_for_mechanism": "Prompting GPT-3 directly achieves strong in-distribution copying (100% on 1–5 digits). Fine-grained (scratchpad) prompts improve OOD addition accuracy; callable programs improve OOD generalization; GPT-3 + tutor attains 100% OOD accuracy. The paper reports that providing intermediate steps reduces errors, consistent with an algorithmic decomposition benefit.",
            "evidence_against_mechanism": "GPT-3 still fails on long repeating-digit copying beyond ~30 digits and on reversing beyond ~20 items, showing pattern-matching/implicit representations do not reliably implement robust algorithmic indexing/locating. Even with callable programs, errors occur when the LM selects wrong tokens to feed to the function (example shown in Appendix A.1).",
            "intervention_type": "Few-shot prompting; coarse- and fine-grained intermediate steps (scratchpad-style); explicit positional markers in prompts; callable program invocation; LM with tutor (action sequence supervision).",
            "effect_of_intervention": "Coarse/fine-grained steps improved in-distribution and OOD performance (finer-grained better); explicit positional markers further boost accuracy; callable programs improve OOD generalization but still degrade with length; LM+tutor achieved perfect (100%) generalization on OOD and repeating-symbol cases in experiments.",
            "performance_metrics": "Copy: GPT-3 100% in-distribution (1–5 digits); generalization to copying degrades beyond ~30 digits. Addition: improved by scratchpad; exact numeric curves shown in paper Figure 9(d); callable programs improve OOD but still degrade with digit length. Reverse: GPT-3 fails beyond ~20 items. (Paper gives per-experiment curves; specific numeric highlights: T5 baseline 78% on 5-digit repeating copy vs GPT-3 100% in-dist; DeBERTa/T5 near 0% OOD in some settings.)",
            "notable_failure_modes": "Fails on long repeating symbols and out-of-distribution lengths; locating ambiguity for repeated tokens; skipping digits (overfitting to fixed-length training patterns); mistakes in selecting which token to pass to callable functions (chaining errors).",
            "comparison_to_humans_or_symbolic": "Paper contrasts GPT-3 behavior with human-tutored algorithmic action sequences: humans use explicit cursor and per-digit actions; GPT-3 benefits from sketching intermediate steps but does not naturally discover the full algorithm without tutor-style supervision or external callable functions.",
            "uuid": "e3019.0",
            "source_info": {
                "paper_title": "Limitations of Language Models in Arithmetic and Symbolic Induction",
                "publication_date_yy_mm": "2022-08"
            }
        },
        {
            "name_short": "T5-base",
            "name_full": "T5-base (text-to-text Transfer Transformer, base size)",
            "brief_description": "A seq2seq Transformer model fine-tuned on symbolic tasks in the paper (T5-base, ~220M parameters), evaluated on copying, reversing, and addition with augmentations like positional markers and fine-grained steps.",
            "citation_title": "",
            "mention_or_use": "use",
            "model_name": "T5-base (220M)",
            "model_description": "Encoder-decoder Transformer (T5) base model; the paper fine-tuned T5-base (reported size 220M) on task-specific data (training regimes detailed in appendix).",
            "arithmetic_task_type": "Copying, reversing, and multi-digit addition (1–30 digits/items evaluated); both in-distribution (1–5 digits/items) and OOD tests (longer lengths and repeating symbols).",
            "reported_mechanism": "Learns to copy/compute via sequence-to-sequence mapping; benefits from explicit positional markers (breaking symbol repetition) and fine-grained scratchpad steps, but tends to overfit to training-length patterns when fine-tuned.",
            "evidence_for_mechanism": "T5 fine-tuned without markers obtains only 78% on 5-digit repeating copying despite being in-distribution; adding ordered/random explicit positional markers yields 100% in-distribution accuracy and better OOD generalization. Fine-grained computation steps sometimes help but less than for GPT-3, likely because fine-tuning overfits.",
            "evidence_against_mechanism": "Even with positional markers and fine-grained steps, T5 often fails to generalize to longer OOD lengths (examples show 0% OOD in some settings), indicating its learned mapping is not robustly algorithmic.",
            "intervention_type": "Fine-tuning on augmented datasets; explicit ordered/random positional markers; fine-grained intermediate (scratchpad) steps; reference markers; LM+tutor training examples.",
            "effect_of_intervention": "Explicit positional markers (ordered or random) substantially improve in-distribution accuracy to 100% and improve OOD generalization compared to baseline; fine-grained steps had mixed effect (less OOD benefit than for GPT-3 due to overfitting). T5+tutor obtains 100% accuracy OOD in experiments.",
            "performance_metrics": "Copy: T5 baseline achieved 78% on 5-digit repeating copy in one reported setting; T5+ordered/random markers achieved 100% in-distribution; OOD performance improved but still limited for long lengths. Addition: T5 with positional markers and/or fine-grained steps had improved in-distribution accuracy; OOD often remains poor (figures 9e/f).",
            "notable_failure_modes": "Overfitting to training sequence lengths causing direct-output skipping behavior on longer inputs (error case where model outputs after 5 digits even when given 6-digit input); inability to generalize to OOD lengths in many settings despite positional markers; difficulty in locating repeated tokens without markers.",
            "comparison_to_humans_or_symbolic": "T5 requires explicit scaffolding (positional markers or tutor) to achieve human-like generalization; fine-tuning alone does not produce reliable algorithmic behavior like symbolic calculators.",
            "uuid": "e3019.1",
            "source_info": {
                "paper_title": "Limitations of Language Models in Arithmetic and Symbolic Induction",
                "publication_date_yy_mm": "2022-08"
            }
        },
        {
            "name_short": "DeBERTa-base",
            "name_full": "DeBERTa-base (disentangled attention BERT variant)",
            "brief_description": "A Transformer encoder model using disentangled token and position attention (DeBERTa); evaluated (DeBERTa-base ~140M) on the same symbolic tasks to probe implicit positional marker effects.",
            "citation_title": "",
            "mention_or_use": "use",
            "model_name": "DeBERTa-base (140M)",
            "model_description": "Transformer encoder with disentangled relative position embeddings and attention (DeBERTa); the paper fine-tunes DeBERTa-base on the symbolic tasks.",
            "arithmetic_task_type": "Copying, reversing, and multi-digit addition (1–30 digits/items; in-distribution and OOD evaluations).",
            "reported_mechanism": "Implicit positional markers via disentangled relative position embeddings alter attention scores by content and relative position (helping locate tokens without explicit markers).",
            "evidence_for_mechanism": "DeBERTa achieves near 100% in-distribution accuracy on copying and addition tasks without explicit markers, indicating disentangled relative position embeddings act as implicit positional markers improving locating ability in-distribution.",
            "evidence_against_mechanism": "DeBERTa shows severe overfitting and fails to generalize OOD (0% OOD in some additions), suggesting its implicit position mechanism does not solve OOD induction; it overfits quickly (achieves 100% in-dist very fast then OOD performance is poor).",
            "intervention_type": "Fine-tuning with task examples (including fine-grained steps in some configurations); comparison between implicit positional embeddings vs explicit markers.",
            "effect_of_intervention": "Implicit position embeddings improve in-distribution performance but do not help OOD generalization; adding scratchpad steps to DeBERTa does not remediate OOD failures reported.",
            "performance_metrics": "DeBERTa near 100% in-distribution on copy/add tasks reported, but ~0% OOD accuracy in several experiments (figures cited in paper). Overfits within few thousand optimization steps.",
            "notable_failure_modes": "Severe overfitting and lack of OOD generalization despite strong in-distribution performance; inability to generalize to longer sequences/repeating symbols even though relative-position signals exist.",
            "comparison_to_humans_or_symbolic": "Implicit positional embeddings provide a representation-level advantage vs vanilla positional sums, but do not confer human-like algorithmic induction; authors contrast this with explicit tutoring/action sequences that do generalize.",
            "uuid": "e3019.2",
            "source_info": {
                "paper_title": "Limitations of Language Models in Arithmetic and Symbolic Induction",
                "publication_date_yy_mm": "2022-08"
            }
        },
        {
            "name_short": "Explicit Positional Markers",
            "name_full": "Explicit positional markers (ordered and random insertion)",
            "brief_description": "A mitigation method that inserts explicit position tokens (markers) into the input sequence (either in-order or in random order) to disambiguate repeating symbols and help models locate tokens.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "Applied to T5 and GPT-3 in experiments (and compared to DeBERTa implicit markers)",
            "model_description": "Not a model but an input intervention: each digit/item is paired with a unique positional marker (e.g., A 2 B 2 C 2 or random markers E 2 X 2 J 2) so repeated symbols are no longer identical tokens.",
            "arithmetic_task_type": "Copying, reversing, and multi-digit addition with repeated symbols and OOD length tests.",
            "reported_mechanism": "Breaks symmetry of repeating tokens so the LM can learn token-indexed operations rather than relying on pattern matching; relates to pointer-network behavior by enabling disambiguation of positions.",
            "evidence_for_mechanism": "T5 augmented with ordered or random positional markers achieved 100% in-distribution copying and improved OOD generalization compared to vanilla T5; positional markers made induction of arithmetic easier in experiments (figures 9).",
            "evidence_against_mechanism": "DeBERTa's implicit markers sometimes outperform explicit markers in-distribution but still fail OOD; explicit markers do not fully solve all OOD/generalization issues (models can still overfit), and in some reversing tasks positional markers did not significantly improve generalization.",
            "intervention_type": "Input augmentation: ordered and random explicit positional tokens inserted into training and/or prompts.",
            "effect_of_intervention": "Increased in-distribution accuracy to 100% in many T5 settings; improved OOD behavior relative to unaugmented T5 but not a complete solution (models can still fail on long OOD examples or on reversing tasks where locating distances grow).",
            "performance_metrics": "T5 + ordered/random markers: 100% in-distribution copying accuracy; better OOD curves than baseline (detailed curves in paper Figures 9a and 9d-f). Noted that DeBERTa (implicit) still failed OOD while T5+markers generalized further.",
            "notable_failure_modes": "Does not guarantee OOD generalization for all tasks (e.g., reversing); requires markers to be present in training/prompt (increasing input complexity); fine-tuning can still overfit to particular marker patterns.",
            "comparison_to_humans_or_symbolic": "Authors liken explicit markers to giving unique identifiers to tokens (similar to strengthening pointer signals), whereas humans use positional awareness; markers reduce hypothesis space and ease learning, but are an engineered crutch compared to algorithmic human procedures.",
            "uuid": "e3019.3",
            "source_info": {
                "paper_title": "Limitations of Language Models in Arithmetic and Symbolic Induction",
                "publication_date_yy_mm": "2022-08"
            }
        },
        {
            "name_short": "Fine-grained Computation Steps (Scratchpad)",
            "name_full": "Fine-grained computation steps / Scratchpad intermediate-step supervision",
            "brief_description": "Supplying explicit intermediate computational steps (scratchpad/chain-of-thought style) in prompts or fine-tuning data so the LM generates stepwise intermediate results instead of only final answers.",
            "citation_title": "Show your work: Scratchpads for intermediate computation with language models.",
            "mention_or_use": "use",
            "model_name": "Applied to GPT-3 (prompting) and T5/DeBERTa (fine-tuning) in experiments",
            "model_description": "Intervention that provides algorithmic intermediate steps (coarse or fine-grained) in exemplars/prompts or training targets, enabling the LM to output a sequence of internal steps resembling human computation.",
            "arithmetic_task_type": "Multi-digit addition (k-digit broken into k 1-digit additions), reversing and copy tasks with stepwise actions.",
            "reported_mechanism": "Enables the model to approximate an algorithmic decomposition by producing intermediate states, effectively increasing the 'computation time' available and reducing the complexity per generation step.",
            "evidence_for_mechanism": "GPT-3 shows substantial gains when using fine-grained steps (larger improvement than coarse-grained); on addition, finer-grained scratchpad examples produced better in-distribution and OOD performance. Prior work (Nye et al.) also supports improvement with scratchpad.",
            "evidence_against_mechanism": "Fine-grained steps do not fully solve repeating-symbol locating issues; T5 fine-tuning with scratchpad can overfit and still fails OOD; DeBERTa still shows 0% OOD despite scratchpad, indicating step-supervision alone is insufficient.",
            "intervention_type": "Prompting (few-shot chain-of-thought / scratchpad exemplars) and fine-tuning on augmented datasets that include intermediate computation steps.",
            "effect_of_intervention": "Improved both in-distribution and OOD accuracy especially for GPT-3; effect size depends on granularity (finer steps better). Does not fully eliminate errors for repeating digits or long OOD sequences.",
            "performance_metrics": "Finer-grained scratchpad prompting improved GPT-3 addition performance substantially (see Figure 9d); T5+scratchpad showed more modest OOD improvements and was prone to overfitting (see Figures 9e/f and Appendix discussion).",
            "notable_failure_modes": "Does not resolve locating/repetition failures by itself; potential overfitting when models are fine-tuned on scratchpad data; requires many examples for full effect in some settings.",
            "comparison_to_humans_or_symbolic": "Analogous to showing step-by-step solution work to students; authors note that human tutoring includes additional visual/cursor steps not captured by standard scratchpad, motivating the tutor method.",
            "uuid": "e3019.4",
            "source_info": {
                "paper_title": "Limitations of Language Models in Arithmetic and Symbolic Induction",
                "publication_date_yy_mm": "2022-08"
            }
        },
        {
            "name_short": "Callable Programs",
            "name_full": "LM with callable programs (external function calls)",
            "brief_description": "A method where the LM emits function-call tokens (e.g., add(1,5)) and an external callable implements primitive operations (convert/add/combine), returning correct results deterministically.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "Applied to GPT-3 in prompting experiments and conceptually to other models",
            "model_description": "Intervention coupling an LM with external deterministic subroutines: the LM produces textual function-call invocations; the system executes the function and appends the returned result to the LM's generation context.",
            "arithmetic_task_type": "Multi-digit addition decomposed into callable primitives (convert digits, add single digits with carry, combine results); used also conceptually for copying/splitting tasks.",
            "reported_mechanism": "Delegates low-level symbolic operations to exact deterministic programs, leaving the LM responsible for orchestration (which tokens to copy, ordering of calls, chaining subroutines).",
            "evidence_for_mechanism": "Callable programs guarantee correctness of the primitive results and improve OOD generalization (GPT-3 + callable programs shows better OOD accuracy than pure prompting), demonstrating benefit of offloading algorithmically exact parts.",
            "evidence_against_mechanism": "LM still makes errors in selecting or specifying which tokens to pass to calls, causing incorrect chaining (Appendix A.1 shows example where convert produced wrong token grouping leading to later incorrect add call). Thus callable programs do not eliminate locating/selection errors.",
            "intervention_type": "Tool use: external deterministic functions invoked during generation (convert, add, combine).",
            "effect_of_intervention": "Substantial OOD improvement for addition vs pure prompting; still degrades with increasing digit length and remains vulnerable to LM orchestration errors (wrong arguments to functions).",
            "performance_metrics": "GPT-3 + callable programs obtains much better OOD generalization in addition experiments (Figure 9d), but performance still declines with digit length; exact numeric curves in paper show improved but non-perfect OOD accuracy.",
            "notable_failure_modes": "Mistakes in selecting/copying the correct input tokens to pass to functions; skipping or mis-indexing tokens before calls, causing downstream arithmetic errors despite correct primitive function behavior.",
            "comparison_to_humans_or_symbolic": "Similar to using a calculator for primitives: callable programs are correct like symbolic computation, but the LM must act as the controller (analogous to a human deciding what subroutine to call); authors highlight that callable programs alone don't solve locating.",
            "uuid": "e3019.5",
            "source_info": {
                "paper_title": "Limitations of Language Models in Arithmetic and Symbolic Induction",
                "publication_date_yy_mm": "2022-08"
            }
        },
        {
            "name_short": "LM with Tutor",
            "name_full": "LM with Tutor (fine-grained action-sequence tutoring / imitation learning)",
            "brief_description": "A novel method introduced in this paper where the LM is trained or prompted to generate explicit fine-grained action sequences (cursor moves, copy/add actions, end checks) that mimic a human tutor's per-token teaching; actions can call primitive subroutines.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "Applied to GPT-3 and T5 in experiments (training/prompting with tutor-style demonstrations)",
            "model_description": "Intervention combining imitation-learning style supervision and abstraction: each training example encodes the smallest atomic actions (rmov/lmov, cpy, add, end) and sometimes uses abstract callable primitives; models learn to predict the next action state transition.",
            "arithmetic_task_type": "Copying, reversing, and multi-digit addition; tested on in-distribution and out-of-distribution lengths including repeating symbols (up to 80 digits/items tested for copying).",
            "reported_mechanism": "Reduces hypothesis space by teaching the LM the explicit action/state transitions (akin to programming a multi-tape Turing machine); the LM learns to generate actions rather than directly generate intermediate numeric results, which yields algorithmic, length-generalizable behavior.",
            "evidence_for_mechanism": "LM+tutor achieves 100% accuracy across all experimented OOD lengths and repeating-symbol cases for copying, reversing, and addition (reported repeatedly in experiments), demonstrating perfect generalization under this supervision style.",
            "evidence_against_mechanism": "No counter-evidence presented in the paper's experiments; authors note there's no guaranteed proof that Transformer must learn the correct model, but empirical results show perfect generalization in their test suite.",
            "intervention_type": "Training/prompting with atomic action sequences (imitation learning), optionally combined with callable primitives for atomic operations.",
            "effect_of_intervention": "Completely solved the experimental induction/OOD/repetition failures reported: both T5+tutor and GPT-3+tutor achieved 100% OOD accuracy across tasks in the reported experiments, unlike other interventions.",
            "performance_metrics": "Reported as 100% accuracy on copying, reversing and addition across all experimented out-of-distribution lengths and repeated-symbol settings (paper emphasizes tutor method yields perfect results in their tests).",
            "notable_failure_modes": "Paper does not report failures for the tutor approach within their experimental range; authors caution no formal guarantee and feasibility depends on availability of action-level supervision or a sketch-generation stage.",
            "comparison_to_humans_or_symbolic": "Directly inspired by human tutoring: action sequences mimic how a human tutor points and shows per-digit operations; authors equate the learned action model to implementing a multi-tape Turing machine state transitions, i.e., algorithmic/symbolic behavior.",
            "uuid": "e3019.6",
            "source_info": {
                "paper_title": "Limitations of Language Models in Arithmetic and Symbolic Induction",
                "publication_date_yy_mm": "2022-08"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Show your work: Scratchpads for intermediate computation with language models.",
            "rating": 2,
            "sanitized_title": "show_your_work_scratchpads_for_intermediate_computation_with_language_models"
        },
        {
            "paper_title": "Chain of thought prompting elicits reasoning in large language models.",
            "rating": 2,
            "sanitized_title": "chain_of_thought_prompting_elicits_reasoning_in_large_language_models"
        },
        {
            "paper_title": "Investigating the limitations of the transformers with simple arithmetic tasks.",
            "rating": 2,
            "sanitized_title": "investigating_the_limitations_of_the_transformers_with_simple_arithmetic_tasks"
        },
        {
            "paper_title": "Language models are few-shot learners.",
            "rating": 2,
            "sanitized_title": "language_models_are_fewshot_learners"
        },
        {
            "paper_title": "Neural turing machines.",
            "rating": 1,
            "sanitized_title": "neural_turing_machines"
        },
        {
            "paper_title": "Deberta: decoding-enhanced bert with disentangled attention.",
            "rating": 2,
            "sanitized_title": "deberta_decodingenhanced_bert_with_disentangled_attention"
        }
    ],
    "cost": 0.01593325,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Limitations of Language Models in Arithmetic and Symbolic Induction</h1>
<p>Jing Qian<em>, Hong Wang</em>, Zekun Li, Shiyang Li, Xifeng Yan<br>University of California, Santa Barbara<br>{jing_qian, hongwang600, zekunli, shiyangli, xyan}@cs.ucsb.edu</p>
<h4>Abstract</h4>
<p>Recent work has shown that large pretrained Language Models (LMs) can not only perform remarkably well on a range of Natural Language Processing (NLP) tasks but also start improving on reasoning tasks such as arithmetic induction, symbolic manipulation, and commonsense reasoning with increasing size of models (Wei et al., 2022; Chowdhery et al., 2022). However, it is still unclear what the underlying capabilities of these LMs are. Surprisingly, we find that these models have limitations on certain basic symbolic manipulation tasks such as copy, reverse, and addition. When the total number of symbols or repeating symbols increases, the model performance drops quickly. We investigate the potential causes behind this phenomenon and examine a set of possible methods, including explicit positional markers, fine-grained computation steps, and LMs with callable programs. Experimental results show that none of these techniques can solve the simplest addition induction problem completely. In the end, we introduce LMs with tutor, which demonstrates every single step of teaching. LMs with tutor is able to deliver $100 \%$ accuracy in situations of OOD and repeating symbols, shedding new insights on the boundary of large LMs in induction.</p>
<h2>1 Introduction</h2>
<p>Transformer-based large pretrained Language Models, such as GPT3 and T5 (Vaswani et al., 2017; Brown et al., 2020; Raffel et al., 2020), have been widely used as few-shot learners in many NLP tasks. Recent work even finds these models can achieve state-of-the-art performance in arithmetic and symbolic reasoning (Nye et al., 2021; Wei et al., 2022). Although these models exhibit surprisingly impressive capabilities in complex arithmetic reasoning tasks, such as MultiArith (Roy and Roth, 2015) and GSM8k (Cobbe et al., 2021), it has also</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Examples of addition: the baseline setting (top) and Scratchpad (Nye et al., 2021) with intermediate steps (bottom). A similar method with more detailed demonstration is introduced in (Recchia, 2021).
been pointed out that they tend to make certain calculation errors and perform significantly worse when the number of math operations increases in equations (Wei et al., 2022). Brown et al. (2020) find that GPT3 displays strong proficiency in 2digit arithmetic addition, but struggles in arithmetic addition on numbers with more than three digits. Nogueira et al. (2021) also observe that the finetuned T5 model can not correctly add or subtract arbitrarily long numbers. Larger models might perform better on the testing data, but worse on numbers that are longer than the training data (out-of-distribution, OOD) (Nogueira et al., 2021).</p>
<p>Figure 1 shows two possible addition exemplars for LMs on addition problem. The scratchpad version gives more details on how humans do basic arithmetic. Nye et al. (2021) show that with more fine-grained demonstrations, the accuracy of addition can be improved dramatically with fine-tuning. Yet, it still can not achieve $100 \%$ on OOD data, even with thousands of training data points. Figure 2 shows the performance of GPT-3 and T5 on addition using the scratchpad version of training data. The problem becomes more severe when there are</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: The horizontal axis is the number of digits and the vertical axis is the accuracy. The prompts for GPT3 consist of 4 examples. The T5 models are trained on 1-5 digits of up to 2,000 examples and each training example consists of random numbers in the format of 2 4 1. In-dist: in-distribution. Out-of-dist.: out-of-distribution (OOD). In-distribution refers to training on up to k-digit numbers and testing on up to k-digit numbers while out-of-distribution refers to training on up to k-digit numbers and testing on numbers with more digits. $\alpha$ indicates the repetition level of the examples. An example $x_{1} \cdots x_{n}$ with $n$ digits are sampled with the next digit probability $p\left(x_{i+1} \mid x_{i}\right)=\alpha$, when $x_{i+1}=x_{i}$; otherwise, $(1-\alpha) / 9$. Larger $\alpha$ indicates a higher repetition level.
repeating digits in the addition operands.
As the performance drops with repeating digits, we suspect that LMs might not handle the repeating symbols well. Figure 2 illustrates the performance of GPT-3 and T5 on the copy task, one of the simplest symbolic manipulation operations. GPT-3 and T5 still can not perform well on OOD. We further do a preliminary experiment where a T5 model is fine-tuned using the data containing repeating numbers of up to 80 digits, T5 still can not achieve $100 \%$ in-distribution accuracy on long repeating digits. The results indicate that there are two problems intervening: Transformers are not good at handling repeating symbols and OOD generalization. The repeating symbols can also be a problem even for in-distribution data. We believe that overcoming the aforementioned limitations is of critical importance for the future application of Transformer-based LMs to reasoning-intensive tasks such as data format conversion and robotic process automation.</p>
<p>In this paper, we investigate the potential causes behind this phenomenon and examine a set of possible mitigation solutions including fine-grained computation steps, positional markers, and LMs with callable programs. Since incorporating computation steps improves the OOD generalization in arithmetic addition (Nye et al., 2021), one possible direction is to provide more fine-grained computation steps in the fine-tuning data or the few-shot prompt. However, it may not be sufficient to alleviate the problem of repeating numbers. When a human does addition, the position of each digit is used to differentiate the repeating digits. However, the self-attention mechanism in the Transformer may not tell which " 1 " is referred to in the input.</p>
<p>This prompts us to explore using positional markers to differentiate the important tokens. Using these two methods to augment the reasoning process, we find that the performance of pretrained LMs still can not reach satisfying results. Then we resort to a method where the copy operation is implemented as a primitive function and explore whether the LM can further boost its performance.</p>
<p>We experiment with three symbolic manipulation tasks: copying, reversing, and addition. Experimental results show that although generalization in these symbolic manipulation tasks is straightforward for humans, it is still challenging for LMs, and none of these mitigation methods fully solves the problems. In the end, we introduce LMs with tutor which demonstrates every single step of teaching, pinpointing where these digits come from. LMs with tutor is able to deliver $100 \%$ accuracy in situations of OOD and repeated symbols. In this design, LMs are used to generate actions that mimic operations in multiple tape Turing machines, rather than the intermediate results. These actions generate the intermediate results on tapes. We hope this could shed light on the capability of Transformer-based LMs in addition to providing large training datasets or scaling up the size of these models.</p>
<p>To conclude, our main contributions are:</p>
<ul>
<li>We identify a set of simple symbolic manipulation tasks and uncover the limitations of the LMs in arithmetic and symbolic induction.</li>
<li>We examine a set of potential techniques including positional markers, fine-grained computation steps, and LMs with callable programs. Though they could mitigate the limitations of the LMs, none of them can completely</li>
</ul>
<p>solve the generalization problem.</p>
<ul>
<li>Finally, we demonstrate that LMs with tutor is able to deliver $100 \%$ accuracy in situations of OOD and repeated symbols. Our analysis could inspire new thoughts to overcome the limitation of LMs in symbolic manipulation.</li>
</ul>
<h2>2 Related Work</h2>
<p>Large Pretrained Language Models: Brown et al. (2020) show that GPT3 exhibits strong proficiency on 2-digit addition and subtraction using simply few-shot prompting, without any task-specific training. Furthermore, the larger the LM, the better the performance. Following GPT3, Chowdhery et al. (2022) further scale the Transformer-based LMs to a 540-billion parameter model, called Pathways Language Model (PaLM). Same as Brown et al. (2020), Chowdhery et al. (2022) find that scaling the LMs consistently results in better arithmetic reasoning ability with few-shot prompting. However, the reasoning ability of the large LMs is still limited. GPT3 struggles with 3-digit arithmetic and with direct prompting, even 540B PaLM can not achieve high performance on complex tasks requiring multi-step reasoning. Therefore Wei et al. (2022) propose the following prompting method for large pretrained LMs.</p>
<p>Chain-of-Thought Prompting: This prompting method provides a few chain-of-thought demonstrations, which is a series of intermediate reasoning steps, as exemplars in the prompting. Therefore, given a complex reasoning task, the model is allowed to calculate the intermediate results step-by-step before generating the final answer. With chain-of-thought prompting, a complex reasoning task is decomposed into a list of simple operations and LMs can derive these operations one by one. Kim et al. (2022) adopt faithful explanations that accurately represent the reasoning process behind solving a math word problem. Wei et al. (2022) show that combining chain-of-thought prompting and a sufficiently large LM, 540B PaLM, can significantly improve the LMs' reasoning ability on complex tasks, such as math word problems.</p>
<p>Fine-tuning with Large Training Datasets: Instead of few-shot prompting, another direction is to fine-tune large LMs with a sufficient amount of training data. Nogueira et al. (2021) fine-tune T5 with different ways of representing numbers, but even with the best-performing representation, the fine-tuned model can not achieve as good ac-
curacy on out-of-distribution testing examples as in-distribution testing examples. Nye et al. (2021) propose to use Scratchpad to improve the out-ofdistribution accuracy. Scratchpad combines step-by-step reasoning with fine-tuning. The training examples include the intermediate steps of an algorithm in target, so the model is trained to generate not only the final answer, but also the intermediate steps, which is similar to chain-of-thought, but requires more training data. Nye et al. (2021) show that using the training data augmented with intermediate steps significantly improves the model performance, but even with 100k augmented training examples for the addition task, the fine-tuned 1B LM still does not perform well on out-of-distribution addition. Our work is also related to Graves et al. (2014), which extends the capabilities of Recurrent Neural Networks to two simple symbolic manipulation tasks, copy and sort, by augmenting the model with external memory resources.</p>
<h2>3 Mitigation Methods</h2>
<h3>3.1 Positional Markers</h3>
<p>We first explore possible methods to mitigate the problem of repeating numbers. We introduce two types of positional markers: implicit positional markers and explicit ones.</p>
<p>Most Transformer-based LMs encode the positional information into positional vectors and add each of them to the corresponding word vector. Although large LMs have already incorporated positional encoding in the model architecture (Figure 3), results in Figure 2 indicate that the positional encoding commonly used in large LMs may not be sufficient to locate each repeating digit effectively. Instead of representing each token by the sum of its contextual token embedding and the position embedding, DeBERTa (He et al., 2021) represents each token with a token embedding and a position embedding, respectively, and the attention weights are computed using disentangled matrices based on both embeddings, respectively (Figure 3). In other words, the self-attention in DeBERTa is disentangled. With the disentangled relative position embeddings, the attention scores between tokens depend not only on the content but also on the relative position between the tokens, so the disentangled relative position embeddings act as implicit position markers within DeBERTa, which might make it easier for the model to learn the latent position relationship in the training data of the</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: An illustration of standard Transformer attention (left) and DeBERTa disentangled attention (right).
symbolic manipulation tasks.
Although DeBERTa uses disentangled attention mechanism, it was not originally introduced to enhance the locating capability of LMs, so no pretraining task was specifically proposed for training the position embeddings in DeBERTa. This may potentially lead to its limited generalization ability on the induction tasks requiring accurate locating. Rather than relying on implicit positional markers, another, more straightforward approach is to add explicit positional markers in the model input. For example, the input string 222 is augmented with positional markers $A, B, C, \cdots$. We explore two methods of adding explicit positional markers:
Ordered marker: The markers are inserted into the input in order. $222 \rightarrow$ A 2 B 2 C 2
Random marker: The markers are inserted into the input in random order. $222 \rightarrow$ E 2 X 2 J 2</p>
<p>With the explicit positional markers, each repeating 2 becomes different for the model. When doing symbolic manipulation, the Transformer-based LMs can easily locate the digit by recognizing the explicit positional markers. Essentially, adding explicit positional markers breaks the repeating numbers into a non-repeating input sequence. This method is also related to pointer networks (Vinyals et al., 2015), which uses attention as a pointer to select the position indexes of the input tokens as the output. A hybrid pointer-generator network can also be leveraged to copy number from the source text, while retaining the ability to produce new numbers through the generator (See et al., 2017).</p>
<h3>3.2 Fine-grained Computation Steps</h3>
<p>We then explore possible methods to alleviate the OOD generalization problem. One observation is that the complexity of addition with long digits
is larger than that of the 1-digit addition. Thus, the model should be given more computation time on the task when the numbers are large. The finetuned T5 and prompted GPT3 mentioned above, however, is required to generate the answer with a fixed amount of computation, so one possible direction to mitigate this limitation is to allow the model to operate step-by-step instead of generating the answer in one forward pass. For example, in kdigit addition, the model is allowed to break it down into k simple 1-digit addition and the model is allowed to generate k intermediate addition results to get the final answer.</p>
<p>Generating fine-grained computation steps can potentially alleviate the generalization problem, but may not contribute to the locating capability of the Transformer-based LMs. To mitigate the locating problem, we add positional markers to scratchpad (Nye et al., 2021) (Figure 4).</p>
<div class="codehilite"><pre><span></span><code><span class="n">question</span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">5</span>
<span class="n">solution</span><span class="o">:</span>
<span class="n">convert</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="o">}\</span><span class="n">mp</span><span class="err">@</span><span class="n">subsup</span><span class="o">{\</span><span class="n">omega</span><span class="o">}{}{\</span><span class="n">circ</span><span class="o">}</span><span class="mi">1</span><span class="o">,\</span><span class="n">mp</span><span class="o">\</span><span class="n">mp</span><span class="err">@</span><span class="n">subsup</span><span class="o">{\</span><span class="n">omega</span><span class="o">}{}{</span><span class="mi">1</span><span class="o">.</span>
<span class="n">convert</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="o">}\</span><span class="n">mp</span><span class="err">@</span><span class="n">subsup</span><span class="o">{\</span><span class="n">omega</span><span class="o">}{}{\</span><span class="n">circ</span><span class="o">}</span><span class="mi">2</span><span class="o">,\</span><span class="n">mp</span><span class="o">\</span><span class="n">mp</span><span class="err">@</span><span class="n">subsup</span><span class="o">{\</span><span class="n">omega</span><span class="o">}{}{</span><span class="mi">5</span><span class="o">.</span>
<span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="mi">5</span><span class="o">,</span><span class="w"> </span><span class="n">carry</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="n">so</span><span class="w"> </span><span class="mi">1</span><span class="o">+</span><span class="mi">5</span><span class="o">+</span><span class="mi">0</span><span class="o">=</span><span class="mi">6</span><span class="o">.</span><span class="w"> </span><span class="n">carry</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="mi">6</span><span class="o">.</span>
<span class="n">combine</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">result</span><span class="o">,</span><span class="w"> </span><span class="kd">get</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="mi">6</span><span class="o">.</span>
<span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="n">carry</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="n">so</span><span class="w"> </span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">+</span><span class="mi">0</span><span class="o">=</span><span class="mi">3</span><span class="o">.</span><span class="w"> </span><span class="n">carry</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="mi">3</span><span class="o">.</span>
<span class="n">combine</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="mi">6</span><span class="o">,</span><span class="w"> </span><span class="kd">get</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">6</span><span class="o">.</span>
<span class="n">carry</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="n">combine</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">6</span><span class="o">,</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">6</span><span class="o">.</span>
</code></pre></div>

<p>Figure 4: The prompt for GPT3 on the addition task. We use $\boldsymbol{\sigma}$ and $\boldsymbol{\sigma}$ to denote optional different markers as described in Section 3.1 if they are applied.</p>
<p>We also experiment a more comprehensive scheme where we directly copy the number associated with the explicit positional marker to its later appearance. For example, for the explicit marker $\mathrm{S}[\mathrm{B}]$, we copy its value 1 to the later appearance in the fourth line as shown in Figure 5. More detail and experimental results are put in appendix A.4.</p>
<div class="codehilite"><pre><span></span><code><span class="nl">question</span><span class="p">:</span><span class="w"> </span><span class="nl">question</span><span class="p">:</span><span class="w"> </span><span class="n">S</span><span class="o">[</span><span class="n">B</span><span class="o">]</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">S</span><span class="o">[</span><span class="n">A</span><span class="o">]</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">T</span><span class="o">[</span><span class="n">B</span><span class="o">]</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">T</span><span class="o">[</span><span class="n">A</span><span class="o">]</span><span class="w"> </span><span class="mi">5</span>
<span class="nl">solution</span><span class="p">:</span>
<span class="n">S</span><span class="o">[</span><span class="n">A</span><span class="o">]</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">T</span><span class="o">[</span><span class="n">A</span><span class="o">]</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Z</span><span class="o">[</span><span class="n">A</span><span class="o">]</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R</span><span class="o">[</span><span class="n">A</span><span class="o">]</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">Z</span><span class="o">[</span><span class="n">B</span><span class="o">]</span><span class="w"> </span><span class="mi">0</span>
<span class="n">S</span><span class="o">[</span><span class="n">B</span><span class="o">]</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">T</span><span class="o">[</span><span class="n">B</span><span class="o">]</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Z</span><span class="o">[</span><span class="n">B</span><span class="o">]</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R</span><span class="o">[</span><span class="n">B</span><span class="o">]</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">Z</span><span class="o">[</span><span class="n">C</span><span class="o">]</span><span class="w"> </span><span class="mi">0</span>
<span class="k">result</span><span class="err">:</span><span class="w"> </span><span class="n">Z</span><span class="o">[</span><span class="n">C</span><span class="o">]</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">R</span><span class="o">[</span><span class="n">B</span><span class="o">]</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">R</span><span class="o">[</span><span class="n">A</span><span class="o">]</span><span class="w"> </span><span class="mi">6</span>
</code></pre></div>

<p>Figure 5: The demonstration of comprehensive scheme for addition problem. Position markers are marked in red and reference markers are marked in green.</p>
<h3>3.3 LM with Callable Programs</h3>
<p>Since callable programs do not have the generalization problem, we combine LMs with callable programs to replace the basic symbolic operations when possible. For example, when combined with the fine-grained computation steps in the addition task, the convert, add, or combine operations can be considered callable programs. When the LM generates the text sequence add $(1,5)$, the callable function add will be invoked and return the result in text: carry C: 0 , result 6.</p>
<p>Following the example in Section 3.2, with callable functions, the prompt format is as follows:</p>
<div class="codehilite"><pre><span></span><code><span class="n">question</span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">5</span>
<span class="n">solution</span><span class="o">:</span>
<span class="n">call</span><span class="w"> </span><span class="n">convert</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">5</span><span class="o">),</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">5</span><span class="o">).</span>
<span class="o">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">5</span><span class="o">),</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="o">),</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">carry</span><span class="w"> </span><span class="n">C</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="mi">6</span><span class="o">.</span>
<span class="n">call</span><span class="w"> </span><span class="n">combine</span><span class="w"> </span><span class="o">(</span><span class="mi">6</span><span class="o">,</span><span class="w"> </span><span class="o">),</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">6</span><span class="o">.</span>
<span class="o">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="o">),</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="o">(</span><span class="n">C</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">),</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">carry</span><span class="w"> </span><span class="n">C</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="mi">3</span><span class="o">.</span>
<span class="n">call</span><span class="w"> </span><span class="n">combine</span><span class="w"> </span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">6</span><span class="o">),</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">6</span><span class="o">.</span>
<span class="n">call</span><span class="w"> </span><span class="n">combine</span><span class="w"> </span><span class="o">(</span><span class="n">C</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">6</span><span class="o">),</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">6</span><span class="o">,</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">6</span><span class="o">.</span>
</code></pre></div>

<p>Figure 6: The prompt for GPT3 on the addition task with callable programs. and are positional markers. Different callable programs (convert, add and combine) are marked in different colors, and the results they returned are underlined with the corresponding color.</p>
<p>Given a testing example, the prompted GPT3 first generates the solution step by step. During the process, the results of the function calls will be appended to the generated result to be used in the following steps. Callable programs can be viewed as decomposing a complex task to smaller, simpler jobs. The remaing issue is to learn chaining these smaller jobs together to complete the task.</p>
<p>Callable programs can guarantee the correctness of output given correct input for a given job. However, LMs may still suffer from the locating problem since the callable programs rely on LMs to decide which token to copy (Figure 11 in the appendix). Unfortunately, LMs cannot guarantee the correctness of this copy action.</p>
<h3>3.4 LM with Tutor</h3>
<p>Scratchpad (Nye et al., 2021) ignores the visual process when an elementary school tutor visually illustrates how to perform addition step by step: pinpointing where each digit in the output sequence comes from, adding single digits together and iterating. It turns out that these details and abstractions
<img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 7: An illustration of doing copy with pattern matching.
are important in order to simplify the learning process and help kids learn addition in a few shots.</p>
<p>A tutor shows every single step visually and sometimes calls an already learned sub-module to complete a task. In this way, the hypothesis space between two consecutive steps can be dramatically simplified; hence the chance of learning a correct model can be improved.</p>
<p>Take copy as an example. Instead of providing a training example: copy: 111222 result: 1111222, we need to demonstrate where the first 1 , the second 1 , and the third 1 in the output sequence come from, which exactly imitates the finest action a human could do to perform such an operation. Suppose there is a cursor placed at the beginning of the input sequence, a "rmov" operation moves the cursor one token to the right. A "cpy" operation copies a single digit to the output sequence. An "end" operation checks if the marker reaches the end of the sequence. " $T$ " and " $F$ " represent true and false respectively. We assume all these actions have been learned. Then a possible action sequence to complete the copy operation is as follows:
rmov, end=F, cpy, rmov, end=F, cpy, . . . , rmov, end=T.
This fine-grained action sequence accurately describes the whole copy operation. Certainly, there are other ways to perform copying. For example, instead of using a cursor, one can use a pattern match to perform the copy operation (Figure 7). We suspect that the copy operation learned from Transformer is following this pattern-matching approach, which is error-prone when the pattern has repeating symbols and when the long pattern is out-of-distribution. Positional markers do not help either as they seem unable to handle the OOD generalization problem.</p>
<p>If we take the action sequence "rmov, end=F, ..." to train a Transformer for copying, the hypothesis space is simplified, thus making it possible to find the simplest model that can simulate the whole action sequence. This setting involves train-</p>
<p><img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 8: An illustration of the LM with Tutor method. With the tutor (right), the LM or just a transformer (left) generates an action sequence that simulates how humans do arithmetic addition.
ing a learner to predict the next action based on the input and the actions demonstrated by experts, which is similar to the setting of imitation learning (Pomerleau, 1988; Ross et al., 2011). Although there is no guarantee that Transformer can definitely find the correct model, the chance is much higher. One can also relate the setting with a multiple tape Turing machine where the state transition is conducted among the positions of tape heads and read/write operations. The Transformer is trained to learn such state transitions, thus completing the programming of a Turing machine.</p>
<p>As for the addition operation, a similar action sequence can be obtained to simulate how humans tutor kids do addition at an early age (Figure 8). Let "lmov" denote moving the cursor one token to the left. The "add" operation adds three single digits together, one from each of the two operands and the third one from the carry digit, appends the result to the output, and updates the carry digit. Assume "add" is a callable program as kids have learned how to do single digits addition. Suppose the cursor starts from the end of the operands. The entire action sequence looks like the following.
lmov, end=F, add, lmov, end=F, add, . . . , lmov, end=T.</p>
<p>The main difference between the tutor and the Scratchpad method (Nye et al., 2021) is the abstract callable function and detailed action sequence. The action sequence includes all the state transitions needed to complete the task. It perfectly overcomes the OOD issue and does not require many training examples in order to achieve $100 \%$ accuracy.</p>
<p>While there is a great effort to enlarge Transformer-based LMs such as PALM (Chowdhery et al., 2022) and Minerva (Lewkowycz et al.,
2022), to improve the performance in symbolic and logical reasoning, our result reveals that it might be necessary to demonstrate the action sequence with reasonable abstraction to the Transformer to leverage its full strength.</p>
<p>In cases where action sequences are not available, e.g., only a problem specification is given, it might be more appropriate to develop an LLM (algorithm generator) to generate an algorithm sketch and then run another LLM to execute the sketch to get the answer. The sketch need not to be in the form of program codes. A human understand-able step-by-step instruction is good enough. The sketch can be viewed as an intermediate model whose complexity is much smaller than the LLM itself. Hence it has a better chance of solving the generalization/OOD issue.</p>
<h2>4 Experiments</h2>
<p>In this section, we conduct experiments on three different problems including copying, addition, and another basic symbolic manipulation operation, reverse. We illustrate the limitation of LMs in symbolic and arithmetic induction and the improvement that could be achieved by the mitigation methods.</p>
<h3>4.1 Copy Operation</h3>
<p>Copying is the most basic operation. We experiment with the following methods and make sure each digit is tokenized into a single token by separating the digits with blanks:
GPT3: We prompt GPT3 to output the same tokens as the given input. Full prompt can be found in appendix (Figure 12).
DeBERTa / T5: The training example is as follows: copy: 1234 result: 1234
T5 + ordered marker: The training data is augmented with explicit positional markers. copy: A 1 B 2 C 3 result: A 1 B 2 C 3
T5 + random marker: Same as above, but the augmented positional markers are in random order. copy: E 1 A 2 F 3 result: E 1 A 2 F 3
T5 / GPT3 + tutor: The training and testing examples are as described in Section 3.4.</p>
<p>We experiment with the T5-base (220M) model, DeBERTa-base (140M) model, and GPT3 text-davinci-002. The models are initiated with the pretrained parameters and further fine-tuned on the training data. For GPT3 or T5 with tutor, the training data consists of 15 examples of up to 5 digits. For all the other T5 models and DeBERTa, the</p>
<p><img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>Figure 9: Experimental results. (a): results of copying repeating numbers. (b)(c): results of reversing the list. (d)(e)(f): results on arithmetic addition. The x-axis is the number of digits or number of items.
training data consists of 2,000 random numbers of up to 5 digits. We evaluate all the models on copying repeating numbers of up to 80 digits. The results are illustrated in Figure 9(a).</p>
<p>As shown in Figure 9(a), GPT3 achieves 100\% accuracy on the in-distribution testing data (1-5 digits) but the fine-tuned T5 achieves $78 \%$ accuracy on the 5-digit repeating numbers although they are indistribution. Augmented with random or ordered positional markers, the T5 models achieve 100\% in-distribution accuracy, and so does using implicit positional markers (DeBERTa). This suggests that both implicit positional markers and explicit positional markers may help with the locating capability of LMs. However, using explicit positional markers, either ordered or random, the model exhibits significantly better generalization to OOD testing data whereas DeBERTa fails on OOD data. GPT3 exhibits better OOD generalization than T5 with positional markers but it does not generalize well beyond 30 digits. Both T5 + tutor and GPT3 + tutor keeps $100 \%$ accuracy on OOD testing data.</p>
<h3>4.2 Addition</h3>
<p>For arithmetic addition, we experiment with the following methods:
GPT3: We prompt GPT3 to directly output the
sum for given addition equation. Full prompt can be found in appendix (Figure 13).
GPT3 + coarse-grained steps: The exemplar is similar to that in Figure 4, but the instructions for the result combination and the computation of the carry digit and step result are omitted.
GPT3 + fine-grained steps (+ ordered marker): The exemplar we use is as shown in Figure 4.
GPT3 + callable programs: The exemplar is shown in Figure 6.
DeBERTa / T5: The training data follows the format of the exemplar for GPT3.
DeBERTa / T5 + fine-grained steps: The training data used in this setting follow the format as the exemplar in GPT3 + fine-grained steps.
T5 + ordered / random marker: The training example is augmented with ordered or random markers. For example, question: G 1 C 1 + G 2 C 5 result: G 3 C 6. For the ordered marker, we apply it to the digits as the following: C 2 B 2 A 2. T5 + fine-grained steps + ordered / random marker: The training data in this setting follow a similar format as the exemplar in GPT3 + finegrained steps + ordered marker, but the positional markers can be in random order.
T5 / GPT3 + tutor: The training and testing examples are as described in Section 3.4.</p>
<p>The model settings are the same as in the above copy experiments. For LMs with tutor, the training data or prompt consists of 15 examples of up to 5 digits. In other settings, the training data consists of 1,000 examples of 1-5 digit addition and for GPT3, the prompt includes 4 examples. We evaluate all the models on the addition of up to 30 digits. The results are shown in Figure 9(d)(e)(f).</p>
<p>As shown in Figure 9(d), both coarse-grained and fine-grained computation steps contribute to the in-distribution performance of GPT3, and using finer-grained steps achieves larger performance gains on both in-distribution data and OOD data. The performance is further boosted with explicit positional markers. Experiments on T5 (Figure 9(e)(f)) also show the effectiveness of using explicit positional markers, with or without fine-grained computation steps, indicating that the explicit positional markers might make it easier for LMs to learn the induction in the arithmetic reasoning tasks. Similar to the results on the copying task, both DeBERTa and DeBERTa + fine-grained steps achieve near $100 \%$ in-distribution accuracy but $0 \%$ OOD accuracy, suggesting that the relative position embedding of DeBERTa might have limited OOD generalization ability. On T5, incorporating finegrained computation steps does not improve the OOD performance as significantly as on GPT3 (Figure 9(f)). The reason might be that fine-tuning T5 tends to overfit more easily than prompting GPT3. Unsurprisingly, GPT3 + callable programs achieves much better OOD generalization. However, its OOD performance still degrades as the number of digits increases. Same as in the copy experiments, $L M s+$ tutor keeps $100 \%$ accuracy on all the experimented numbers of digits.</p>
<h3>4.3 Reverse List</h3>
<p>Besides copying and addition, we also experiment with reversing. Reversing is similar to copying. Both require replicating the items in the input, but reversing might be more challenging than copying in the terms of locating. In copying, the distance between each source digit and the replicated digit is the same for each digit in the number. However, when reversing, the distance between the source item and the replicated item keeps increasing during the generation. For this problem, we experiment with the following methods:
GPT3: We prompt GPT3 to directly output the reversed list of items without intermediate steps.</p>
<p>Full prompt can be found in appendix (Figure 14). DeBERTa / T5: reverse the list: bike, apple, book result: bike, cat, pen
GPT3 / DeBERTa / T5 + fine-grained steps: The training example for T5 and the exemplar for GPT3 are shown in Figure 10.</p>
<div class="codehilite"><pre><span></span><code>reverse the list: bike, cat, pen
solution:
A is bike. B is cat. C is pen.
Now to reverse, change the order to:
C is pen. B is cat. A is bike.
Result: pen, cat, bike
</code></pre></div>

<p>Figure 10: The prompt for GPT3 on the reverse task with fine-grained steps.</p>
<p>T5 + ordered marker: The list items are augmented with the ordered positional markers in the input. reverse the list: A bike, B cat, C pen result: pen, cat, bike.
T5 / GPT3 + tutor: The training and testing examples are very similar to that for the copy task. The only difference is the direction for move operation. "rmov" in the copy task is replaced by "lmov" here.</p>
<p>The model settings are the same as in the above experiments and the training data consists of examples of 1-5 items, which are randomly sampled from a predefined list of single-token nouns. For LMs with tutor, the training data or prompt consists of 15 examples of up to 5 items. For T5, the training data consists of 1,000 examples. For GPT3, each prompt includes 4 examples. We evaluate all the models on reversing the list of up to 30 items. The results are shown in Figure 9(b)(c).</p>
<p>Although GPT3 can generalize to 80 digits on copying random numbers (Figure 2), it does not generalize well beyond 20 items on reversing, which suggests that reversing might require stronger locating capability than copying. This problem also occurs on DeBERTa and T5. When tested on the OOD data, the models tends to generate only a sublist of the input. Using fine-grained steps (Figure 9(b)) or positional markers, whether implicit or explicit (Figure 9(c)), does not significantly improve the generalization of the experimented models. The reason might be the increasing distance between the source item and the replicated item as stated above. Again, $L M s+$ tutor maintains $100 \%$ accuracy throughout the experiments. We put more discussion about the results in appendix A. 5 due to the page limit.</p>
<h2>5 Conclusion</h2>
<p>In this work, we explore the limitations of pretrained LMs on arithmetic reasoning and symbolic manipulation. We experiment with three simple symbolic manipulation tasks and show that improving the locating and induction capability of LMs can be important for further improving their performance. Our method that combines abstraction and finest-grained step-by-step tutoring demonstrates its potential to generalize correctly, shedding light on possible directions orthogonal to scaling up LMs for future work in this area.</p>
<h2>6 Limitations</h2>
<p>In this work, we experiment with GPT3, T5, and DeBERTa. Other large pretrained LMs, such as PaLM (Chowdhery et al., 2022), is not covered in this work. We do not experiment with methods such as fine-tuning GPT3 due to the computation cost. The main purpose of this work is to uncover and analyze the fundamental limitations of LMs on symbolic and arithmetic induction instead of improving their performance of reasoning tasks, so we do not directly compare the mitigation methods with the previous work such as scratchpad (Nye et al., 2021) and (Wei et al., 2022) in our experiments. We leave more advanced methods for future work.</p>
<h2>References</h2>
<p>Tom B. Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, Sandhini Agarwal, Ariel Herbert-Voss, Gretchen Krueger, Tom Henighan, Rewon Child, Aditya Ramesh, Daniel M. Ziegler, Jeffrey Wu, Clemens Winter, Christopher Hesse, Mark Chen, Eric Sigler, Mateusz Litwin, Scott Gray, Benjamin Chess, Jack Clark, Christopher Berner, Sam McCandlish, Alec Radford, Ilya Sutskever, and Dario Amodei. 2020. Language models are few-shot learners. In Advances in Neural Information Processing Systems 33: Annual Conference on Neural Information Processing Systems 2020, NeurIPS 2020, December 6-12, 2020, virtual.</p>
<p>Aakanksha Chowdhery, Sharan Narang, Jacob Devlin, Maarten Bosma, Gaurav Mishra, Adam Roberts, Paul Barham, Hyung Won Chung, Charles Sutton, Sebastian Gehrmann, Parker Schuh, Kensen Shi, Sasha Tsvyashchenko, Joshua Maynez, Abhishek Rao, Parker Barnes, Yi Tay, Noam Shazeer, Vinodkumar Prabhakaran, Emily Reif, Nan Du, Ben Hutchinson, Reiner Pope, James Bradbury, Jacob</p>
<p>Austin, Michael Isard, Guy Gur-Ari, Pengcheng Yin, Toju Duke, Anselm Levskaya, Sanjay Ghemawat, Sunipa Dev, Henryk Michalewski, Xavier Garcia, Vedant Misra, Kevin Robinson, Liam Fedus, Denny Zhou, Daphne Ippolito, David Luan, Hyeontaek Lim, Barret Zoph, Alexander Spiridonov, Ryan Sepassi, David Dohan, Shivani Agrawal, Mark Omernick, Andrew M. Dai, Thanumalayan Sankaranarayana Pillai, Marie Pellat, Aitor Lewkowycz, Erica Moreira, Rewon Child, Oleksandr Polozov, Katherine Lee, Zongwei Zhou, Xuezhi Wang, Brennan Saeta, Mark Diaz, Orhan Firat, Michele Catasta, Jason Wei, Kathy Meier-Hellstern, Douglas Eck, Jeff Dean, Slav Petrov, and Noah Fiedel. 2022. Palm: Scaling language modeling with pathways. CoRR, abs/2204.02311.</p>
<p>Karl Cobbe, Vineet Kosaraju, Mohammad Bavarian, Jacob Hilton, Reiichiro Nakano, Christopher Hesse, and John Schulman. 2021. Training verifiers to solve math word problems. CoRR, abs/2110.14168.</p>
<p>Alex Graves, Greg Wayne, and Ivo Danihelka. 2014. Neural turing machines. CoRR, abs/1410.5401.</p>
<p>Pengcheng He, Xiaodong Liu, Jianfeng Gao, and Weizhu Chen. 2021. Deberta: decoding-enhanced bert with disentangled attention. In 9th International Conference on Learning Representations, ICLR 2021, Virtual Event, Austria, May 3-7, 2021. OpenReview.net.</p>
<p>Bugeun Kim, Kyung Seo Ki, Sangkyu Rhim, and Gahgene Gweon. 2022. EPT-X: An expression-pointer transformer model that generates eXplanations for numbers. In Proceedings of the 60th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 4442-4458.</p>
<p>Aitor Lewkowycz, Anders Andreassen, David Dohan, Ethan Dyer, Henryk Michalewski, Vinay V. Ramasesh, Ambrose Slone, Cem Anil, Imanol Schlag, Theo Gutman-Solo, Yuhuai Wu, Behnam Neyshabur, Guy Gur-Ari, and Vedant Misra. 2022. Solving quantitative reasoning problems with language models. CoRR, abs/2206.14858.</p>
<p>Rodrigo Nogueira, Zhiying Jiang, and Jimmy Lin. 2021. Investigating the limitations of the transformers with simple arithmetic tasks. CoRR, abs/2102.13019.</p>
<p>Maxwell I. Nye, Anders Johan Andreassen, Guy GurAri, Henryk Michalewski, Jacob Austin, David Bieber, David Dohan, Aitor Lewkowycz, Maarten Bosma, David Luan, Charles Sutton, and Augustus Odena. 2021. Show your work: Scratchpads for intermediate computation with language models. CoRR, abs/2112.00114.</p>
<p>Dean Pomerleau. 1988. ALVINN: an autonomous land vehicle in a neural network. In Advances in Neural Information Processing Systems 1, [NIPS Conference, Denver, Colorado, USA, 1988], pages 305-313. Morgan Kaufmann.</p>
<p>Colin Raffel, Noam Shazeer, Adam Roberts, Katherine Lee, Sharan Narang, Michael Matena, Yanqi Zhou, Wei Li, and Peter J. Liu. 2020. Exploring the limits of transfer learning with a unified text-to-text transformer. J. Mach. Learn. Res., 21:140:1-140:67.</p>
<p>Gabriel Recchia. 2021. Teaching autoregressive language models complex tasks by demonstration. Computing Research Repository, abs/2109.02102. Version 3.</p>
<p>Stéphane Ross, Geoffrey J. Gordon, and Drew Bagnell. 2011. A reduction of imitation learning and structured prediction to no-regret online learning. In Proceedings of the Fourteenth International Conference on Artificial Intelligence and Statistics, AISTATS 2011, Fort Lauderdale, USA, April 11-13, 2011, volume 15 of JMLR Proceedings, pages 627-635. JMLR.org.</p>
<p>Subhro Roy and Dan Roth. 2015. Solving general arithmetic word problems. In Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing, EMNLP 2015, Lisbon, Portugal, September 17-21, 2015, pages 1743-1752. The Association for Computational Linguistics.</p>
<p>Abigail See, Peter J. Liu, and Christopher D. Manning. 2017. Get to the point: Summarization with pointergenerator networks. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers).</p>
<p>Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser, and Illia Polosukhin. 2017. Attention is all you need. In Advances in Neural Information Processing Systems 30: Annual Conference on Neural Information Processing Systems 2017, December 4-9, 2017, Long Beach, CA, USA, pages 5998-6008.</p>
<p>Oriol Vinyals, Meire Fortunato, and Navdeep Jaitly. 2015. Pointer networks. In Advances in Neural Information Processing Systems 28: Annual Conference on Neural Information Processing Systems 2015, December 7-12, 2015, Montreal, Quebec, Canada, pages 2692-2700.</p>
<p>Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Ed H. Chi, Quoc Le, and Denny Zhou. 2022. Chain of thought prompting elicits reasoning in large language models. CoRR, abs/2201.11903.</p>
<p>Thomas Wolf, Lysandre Debut, Victor Sanh, Julien Chaumond, Clement Delangue, Anthony Moi, Pierric Cistac, Tim Rault, Rémi Louf, Morgan Funtowicz, et al. 2020. Transformers: State-of-the-art natural language processing. In Proceedings of the 2020 conference on empirical methods in natural language processing: system demonstrations, pages 38-45.</p>
<h2>A Appendix</h2>
<h2>A. 1 Error case for LM with callable program</h2>
<p>Here we show one error case for LM with callable program in Figure 11.</p>
<div class="codehilite"><pre><span></span><code>question: ... 6 18...+...6 19...
prediction:
call convert (...618...,...619...) return...
*.
(8 9), call add (C:0, 8, 9), return carry C: 1, result 7.
call combine ...
(6 1), call add (C: 1, 6, 1), return carry C: 0, result 8.
<span class="gh">#</span> ERROR! Should be (1 1), call add (C:1, 1, 1)...
...
</code></pre></div>

<p>Figure 11: An error example of GPT3 with callable functions. The error is highlighted.</p>
<h2>A. 2 GPT3 prompts</h2>
<p>Here we show the prompts of GPT3 used for copy, addition and reverse tasks in Figure 12, 13 and 14.</p>
<div class="codehilite"><pre><span></span><code><span class="n">copy</span><span class="o">:</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span>
<span class="n">result</span><span class="o">:</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span>
<span class="n">copy</span><span class="o">:</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">7</span>
<span class="n">result</span><span class="o">:</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">7</span>
<span class="n">copy</span><span class="o">:</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span>
<span class="n">result</span><span class="o">:</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span>
<span class="n">copy</span><span class="o">:</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">6</span>
<span class="n">result</span><span class="o">:</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">6</span>
</code></pre></div>

<p>Figure 12: The prompt for GPT3 on the copy task.</p>
<div class="codehilite"><pre><span></span><code><span class="n">question</span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">5</span>
<span class="n">result</span><span class="o">:</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">6</span>
<span class="n">question</span><span class="o">:</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">3</span>
<span class="n">result</span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">5</span>
<span class="n">question</span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">8</span>
<span class="n">result</span><span class="o">:</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span>
<span class="n">question</span><span class="o">:</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">1</span>
<span class="n">result</span><span class="o">:</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">6</span>
</code></pre></div>

<p>Figure 13: The prompt for GPT3 on the addition task without intermediate steps.</p>
<div class="codehilite"><pre><span></span><code>reverse the list: bike, cat, pen
result: pen, cat, bike
reverse the list: chair, bike, apple, book
result: book, apple, bike, chair
reverse the list: book, phone, fish, orange, fish
result: fish, orange, fish, phone, book
</code></pre></div>

<p>Figure 14: The prompt for GPT3 on the reverse task without intermediate steps.</p>
<p>question: S[F] 5 S[E] 2 S[D] 8 S[C] 1 S[B] 7 S[A] 1 + T[F] 6 T[E] 5 T[D] 0 T[C] 2 T[B] 4 T[A] 5
solution:
S[A] $1+T[A] 5+Z[A] 0=R[A] 6, Z[B] 0$.
$S[B] 7+T[B] 4+Z[B] 0=R[B] 1, Z[C] 1$.
$S[C] 1+T[C] 2+Z[C] 1=R[C] 4, Z[D] 0$.
$S[D] 8+T[D] 0+Z[D] 0=R[D] 8, Z[E] 0$.
S[E] $2+T[E] 5+Z[E] 0=R[E] 7, Z[F] 0$.
result: Z[F] 0 R[E] 7 R[D] 8 R[C] 4 R[B] 1 R[A] 6</p>
<p>Figure 15: Error case for T5 model with positional and reference marker on addition problem.</p>
<h2>A. 3 Experiment configuration</h2>
<p>For fine-tuning the T5-base and DeBERTa model, we use the learning rate $5 \mathrm{e}-5$, batch size 16 , training epochs 200. The maximum generation length is set to 512 . The checkpoints are evaluated every 1000 optimization steps. The random seed is fixed to 42. We use the implementation for HuggingFace (Wolf et al., 2020). For GPT3, we set temperature $=0$, top_p=1, frequency_penalty $=0$, and presence_penalty $=0$. All the experiments are conducted on NVIDIA RTX A6000 GPUs.</p>
<h2>A. 4 Reference marker</h2>
<p>As shown in Figure 5, we apply two different markers in the demonstration. The positional marker is used to define the value stored in the marker, while reference marker is used to explicitly copy the value from the positional marker with the same name. Each number in this demonstration is uniquely marked with positional or reference marker. For the positional marker, the model needs to generate both the marker and its value. For the reference marker, the model only needs to generate the marker and the value will be explicitly copied from its corresponding positional marker.</p>
<p>Similar to previous experiments on the addition problem, we train the model on 1-5 digits and test its performance on both in-domain (1-5 digits) and out-of-domain (6-10 digits) settings. The experimental results show that the model is able to achieve $100 \%$ accuracy on in-domain data, but get $0 \%$ accuracy on out-of-domain data. We also tried to extend the in-domain to 10 digits and get the same results that the model can solve in-domain problems, but fail to generalize to out-of-domain.</p>
<p>We show one error case of this model in Figure 15, where the error step is highlighted in yellow. On this 6-digit addition problem, the model skipped the last digit and directly jump to the result, which
causes the error. The problem is the model doesn't learn to how to generalize from 1-5 digits to 6 digits. Instead, it is overfitting to the training data, which makes it directly output the results after adding 5 digits. How to reduce the hypothesis space and force the model to learn to generalize to out-ofdomain data would be one future research direction to solve this problem.</p>
<h2>A. 5 Discussion</h2>
<p>From the experimental results, we observe that finegrained computation steps may improve the LM's induction ability on the arithmetic reasoning tasks and the granularity of the steps has an impact on the performance improvement. Finer-grained computation steps may contribute to larger performance improvement.</p>
<p>Positional markers, whether implicit or explicit, improves LMs' in-distribution performance on all the symbolic manipulation tasks in our experiments. However, We find that augmented with the relative position embeddings, DeBERTa tends to face more severe over-fitting than T5 during fine-tuning. In the reversing experiment, using the T5 model without pretrained parameters, the finetuned model can not achieve a good in-distribution performance after 200k optimization steps. However, the DeBERTa model without pretrained parameters achieves $100 \%$ in-distribution accuracy within only 2 k optimization steps while the OOD accuracy drops, indicating that it has overfitted within 2 k optimization steps. In other words, the relative position embeddings in DeBERTa significantly improve the model's capacity of positions, which improves in-distribution performance on simple symbolic manipulation tasks, but may not generalize well on OOD data. Compared with the implicit positional markers (relative position embeddings in DeBERTa), explicit positional markers might have better OOD generalization ability. However, incorporating symbolic manipulation tasks in the LM pretraining stage might alleviate this problem, so incorporating implicit positional markers can still be a possible direction of improving the LM's performance on reasoning tasks requiring locating ability.</p>
<p>Using LM with callable programs exhibits strong OOD performance on addition, suggesting that the LMs' ability to perform simple symbolic operations, such as copying, splitting, and combining, can be critical for improving their performance on</p>
<p>reasoning tasks. How to further improve the LMs' performance on more complex reasoning tasks in this direction is left for future work.</p>
<h1>A A1. Did you describe the limitations of your work?</h1>
<p>6
\&amp; A2. Did you discuss any potential risks of your work?
We don't think our work has any potential risks.
A3. Do the abstract and introduction summarize the paper's main claims?
1
\&amp; A4. Have you used AI writing assistants when working on this paper?
Left blank.</p>
<h2>B $\mathscr{E}$ Did you use or create scientific artifacts?</h2>
<p>Left blank.
$\square$ B1. Did you cite the creators of artifacts you used?
No response.
$\square$ B2. Did you discuss the license or terms for use and / or distribution of any artifacts?
No response.
$\square$ B3. Did you discuss if your use of existing artifact(s) was consistent with their intended use, provided that it was specified? For the artifacts you create, do you specify intended use and whether that is compatible with the original access conditions (in particular, derivatives of data accessed for research purposes should not be used outside of research contexts)?
No response.
$\square$ B4. Did you discuss the steps taken to check whether the data that was collected / used contains any information that names or uniquely identifies individual people or offensive content, and the steps taken to protect / anonymize it?
No response.
$\square$ B5. Did you provide documentation of the artifacts, e.g., coverage of domains, languages, and linguistic phenomena, demographic groups represented, etc.?
No response.
$\square$ B6. Did you report relevant statistics like the number of examples, details of train / test / dev splits, etc. for the data that you used / created? Even for commonly-used benchmark datasets, include the number of examples in train / validation / test splits, as these provide necessary context for a reader to understand experimental results. For example, small differences in accuracy on large test sets may be significant, while on small test sets they may not be.
No response.</p>
<h2>C $\square$ Did you run computational experiments?</h2>
<p>4
\&amp; C1. Did you report the number of parameters in the models used, the total computational budget (e.g., GPU hours), and computing infrastructure used?</p>
<p>Left blank.
The Responsible NLP Checklist used at ACL 2023 is adopted from NAACL 2022, with the addition of a question on AI writing assistance.</p>
<p>C2. Did you discuss the experimental setup, including hyperparameter search and best-found hyperparameter values?
A. 3
$\mathscr{K}$ C3. Did you report descriptive statistics about your results (e.g., error bars around results, summary statistics from sets of experiments), and is it transparent whether you are reporting the max, mean, etc. or just a single run?
I reported the results from a single run
( C4. If you used existing packages (e.g., for preprocessing, for normalization, or for evaluation), did you report the implementation, model, and parameter settings used (e.g., NLTK, Spacy, ROUGE, etc.)?
No used.
D Did you use human annotators (e.g., crowdworkers) or research with human participants? Left blank.</p>
<p>D1. Did you report the full text of instructions given to participants, including e.g., screenshots, disclaimers of any risks to participants or annotators, etc.?
No response.
D2. Did you report information about how you recruited (e.g., crowdsourcing platform, students) and paid participants, and discuss if such payment is adequate given the participants' demographic (e.g., country of residence)?
No response.
D3. Did you discuss whether and how consent was obtained from people whose data you're using/curating? For example, if you collected data via crowdsourcing, did your instructions to crowdworkers explain how the data would be used?
No response.
D4. Was the data collection protocol approved (or determined exempt) by an ethics review board? No response.</p>
<p>D5. Did you report the basic demographic and geographic characteristics of the annotator population that is the source of the data?
No response.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<ul>
<li>The first two authors (Jing and Hong) contributed equally to this work.</li>
</ul>
<p><a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>