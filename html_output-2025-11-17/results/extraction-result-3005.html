<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-3005 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-3005</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-3005</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-73.html">extraction-schema-73</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, internal representations, interventions, and performance on arithmetic tasks.</div>
                <p><strong>Paper ID:</strong> paper-260378835</p>
                <p><strong>Paper Title:</strong> <a href="https://export.arxiv.org/pdf/2308.01154v4.pdf" target="_blank">Arithmetic with Language Models: from Memorization to Computation</a></p>
                <p><strong>Paper Abstract:</strong> A better understanding of the emergent computation and problem-solving capabilities of recent large language models is of paramount importance to further improve them and broaden their applicability. This work investigates how a language model, trained to predict the next token, can perform arithmetic computations generalizing beyond training data. Binary addition and multiplication constitute a good testbed for this purpose, since they require a very small vocabulary and exhibit relevant input/output discontinuities making smooth input interpolation ineffective for novel data. We successfully trained a light language model to learn these tasks and ran a number of experiments to investigate the extrapolation capabilities and internal information processing. Our findings support the hypothesis that the language model works as an Encoding-Regression-Decoding machine where the computation takes place in the value space once the input token representation is mapped to an appropriate internal representation.</p>
                <p><strong>Cost:</strong> 0.015</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e3005.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e3005.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, internal representations, interventions, and performance on arithmetic tasks.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>ED-Transformer (this paper)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Custom encoder-decoder Transformer trained from scratch (Maltoni & Ferrara)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A small encoder-decoder Transformer (701K parameters, d_model=64, 6 encoder + 6 decoder layers, vocab=5) trained from scratch on exhaustive 7-bit binary addition and multiplication tasks to study how LMs perform arithmetic.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Custom encoder-decoder Transformer (this paper)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Encoder-decoder Transformer (Vaswani et al. style) trained from scratch; vocabulary size 5 (special tokens, '+/×', '0','1'), d_model=64, feedforward dim=256, 8 heads, 6 encoder layers, 6 decoder layers, ~701K learnable parameters; trained with cross-entropy, AdamW/Adam variants as described.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>Binary addition and binary multiplication of two 7-bit integers (operands in [0,127]); outputs fixed-length bit-strings (8 bits for addition, 14 bits for multiplication); reverse (LSB-first) token order.</td>
                        </tr>
                        <tr>
                            <td><strong>reported_mechanism</strong></td>
                            <td>Encoding–Regression–Decoding (ERD): input tokens are encoded into continuous 'value' vectors (v_A, v_B), a regressor computes an output value vector v_R in the internal space, then decoding maps v_R back to output tokens. Authors argue computation occurs in value space (internal embeddings) rather than pure memorization or stepwise symbolic ALU emulation.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>1) High generalization on held-out random split despite small training set (implies not simple memorization). 2) Excluding contiguous regions in value space (VS_v) degrades generalization much more than excluding contiguous regions in token/Hamming space (VS_t), indicating importance of contiguous coverage in value space for the learned regressor. 3) Layerwise correlation analyses: token-level distances correlate with first/last decoder layers while value-level distances peak in central decoder layers (layer 3), consistent with token→value encoding, regression in central decoder layers, and value→token decoding. 4) Ablation: encoder can be heavily squeezed without major impact, suggesting decoding/regression happen later. 5) Amnesic probing: removing value information from decoder layer 3 embeddings collapses arithmetic performance (see separate entry).</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_against_mechanism</strong></td>
                            <td>1) Multiplication shows piecewise / region-dependent behavior (less clear global-value regression), suggesting regression is approximated locally and not a single smooth global function. 2) The authors acknowledge symbolic-like algorithms cannot be fully ruled out; some prior work (e.g., Nanda et al.) shows LMs can implement Fourier-like algorithms for modular addition.</td>
                        </tr>
                        <tr>
                            <td><strong>intervention_type</strong></td>
                            <td>Dataset splits to probe interpolation/extrapolation (Random, VS_t token-neighborhood, VS_v value-neighborhood); architectural ablations (remove encoder internals, reduce dims, remove FCs, remove positional encodings, remove attention); amnesic probing (project embeddings onto probe nullspace); input-order intervention (reverse vs plain).</td>
                        </tr>
                        <tr>
                            <td><strong>effect_of_intervention</strong></td>
                            <td>1) VS_v (withheld contiguous value-region) reduced sequence accuracy (addition: ~93.7%, multiplication: ~94.3%) vs Random (~100%/~>99%). 2) Squeezing encoder (remove attention / MLP in encoder) had little effect; removal of positional embeddings or attention layers broke token→value mapping. 3) Reverse (LSB-first) ordering substantially speeds learning and stabilizes training vs plain order. 4) Amnesic probing (nullspace projection of dec3 embeddings) reduced sequence accuracy from 100% to 0.13%, showing causal importance of value information.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Addition: converged <50 epochs; sequence accuracy ≈100% on Random validation; MAE on validation = 0. Multiplication: converged ≈250 epochs; sequence accuracy ≈100% on Random validation; MAE on validation = 1.3. VS_v split: addition ≈93.7% sequence accuracy, multiplication ≈94.3%. Control (random output mapping) training: required ~1000 epochs to reach 87.8% training sequence accuracy and validation did not improve (shows memorization is hard). Results averaged over five runs.</td>
                        </tr>
                        <tr>
                            <td><strong>notable_failure_modes</strong></td>
                            <td>1) Poor extrapolation in value-space regions not covered by training (VS_v). 2) Multiplication learned as piecewise / local approximations leading to discontinuities and somewhat higher residual errors (MAE ~1.3). 3) Tasks with highly discontinuous input-output relationships are harder to memorize and require computation in value space. 4) Dependence on positional encoding and attention—removing these disrupts encoding/decoding.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_humans_or_symbolic</strong></td>
                            <td>Authors compare LM's internal approach to symbolic CPU-like algorithms (ALU) and argue that the LM does not appear to implement exact symbolic bitwise algorithms; instead it learns numeric regressors in internal vector space (ERD). They note compatibility with other mechanistic findings (e.g., late MLPs doing computation) but caution that regressor approximations can resemble analytic decompositions (e.g., discrete Fourier approximations) found in other work.</td>
                        </tr>
                        <tr>
                            <td><strong>additional_notes</strong></td>
                            <td>The authors stress that ERD does not require a strict mapping to encoder/decoder modules; encoding and decoding can occur across early/late decoder layers. Reverse ordering of tokens (LSB-first) substantially improves learnability.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Arithmetic with Language Models: from Memorization to Computation', 'publication_date_yy_mm': '2023-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3005.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e3005.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, internal representations, interventions, and performance on arithmetic tasks.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>nanoGPT (replication)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>nanoGPT decoder-only Transformer (Karpathy implementation) used as second LM</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A small decoder-only Transformer (nanoGPT) with ~298K parameters used to replicate experiments; supports same qualitative conclusions (ERD) while showing somewhat different extrapolation behavior.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>nanoGPT (decoder-only, Karpathy implementation)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Decoder-only Transformer (nanoGPT) used with learned positional embeddings, d_model=64, 6 decoder layers, feedforward dim ×4, 8 heads, ~298K parameters; trained from scratch on same binary tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>Same as main model: binary addition and binary multiplication of two 7-bit integers in reverse (LSB-first) token order.</td>
                        </tr>
                        <tr>
                            <td><strong>reported_mechanism</strong></td>
                            <td>Same ERD interpretation: encoding tokens to value vectors, regression in internal representation, decoding back to tokens. Behaves similarly across interpolative tests but shows larger degradation on value-space extrapolation.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>Replication of VS_t vs VS_v experiments: nanoGPT attains ~100% (addition) and ~99.9% (multiplication) on Random/VS_t but drops substantially on VS_v (addition 82.0%, multiplication 80.6%), consistent with mechanism that relies on value-space regression and is sensitive to coverage in value space.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_against_mechanism</strong></td>
                            <td>None reported that overturn ERD; drop in VS_v indicates greater sensitivity to value-space gaps but still supports ERD rather than memorization.</td>
                        </tr>
                        <tr>
                            <td><strong>intervention_type</strong></td>
                            <td>Same dataset-split interventions (Random, VS_t, VS_v), ablations analogous where applicable.</td>
                        </tr>
                        <tr>
                            <td><strong>effect_of_intervention</strong></td>
                            <td>VS_v produced a larger performance drop (addition to 82.0%, multiplication to 80.6%), further supporting importance of value-space coverage; otherwise replicates core findings of main model.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Random/VS_t: addition ~100% sequence accuracy, multiplication ~99.9%; VS_v: addition 82.0%, multiplication 80.6%. Model size ~298K parameters. Training hyperparameters: minibatch 128, AdamW, lr 0.001, betas 0.9/0.98, gradient clipping 1.0 (as reported in Appendix E).</td>
                        </tr>
                        <tr>
                            <td><strong>notable_failure_modes</strong></td>
                            <td>Stronger degradation on value-space extrapolation (VS_v) than the encoder-decoder model, indicating decoder-only implementations may be more sensitive to missing contiguous value-region coverage.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_humans_or_symbolic</strong></td>
                            <td>Same qualitative comparison as main model: likely uses internal regression rather than explicit symbolic algorithm; replicates ERD-style interpretation.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Arithmetic with Language Models: from Memorization to Computation', 'publication_date_yy_mm': '2023-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3005.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e3005.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, internal representations, interventions, and performance on arithmetic tasks.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>ERD</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Encoding–Regression–Decoding hypothesis</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Hypothesis proposed in this paper that LMs perform arithmetic by (1) encoding token sequences into continuous value vectors, (2) performing the arithmetic as regression in that value space, and (3) decoding result vectors back to token sequences — with the regression happening mainly in central decoder layers.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>ERD (conceptual mechanism)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Conceptual mechanism (not a distinct model): tokens -> encoded value vectors (v_A, v_B); regressor computes v_R = regress(v_A, v_B) possibly incrementally using previously produced result context; decoder maps v_R to token outputs.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>Proposed general mechanism applicable to tasks that can be reduced to numerical regression; instantiated here on binary addition and multiplication.</td>
                        </tr>
                        <tr>
                            <td><strong>reported_mechanism</strong></td>
                            <td>ERD (see brief_description). The regression step may be incremental (leveraging produced partial outputs when using autoregressive reverse order).</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>1) VS_v vs VS_t experiments show sensitivity to withheld regions in value space but not token space. 2) Layerwise correlation patterns (token-like at early/late decoder layers, value-like in middle layers). 3) Ablations and amnesic probing show central decoder embeddings contain necessary value information. 4) Control random-output experiment shows memorization alone is harder than learning arithmetic mapping, implying an algorithmic/functional internal strategy.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_against_mechanism</strong></td>
                            <td>1) Multiplication exhibits piecewise approximations and cannot be described by a single smooth global regressor. 2) Prior work (e.g., mechanistic findings of Fourier-like circuits) shows alternative numeric circuitizations that could be interpreted differently; ERD is a high-level framing rather than a unique mechanistic proof.</td>
                        </tr>
                        <tr>
                            <td><strong>intervention_type</strong></td>
                            <td>N/A (hypothesis tested via dataset splits, layer correlations, ablations, and amnesic probing in this paper).</td>
                        </tr>
                        <tr>
                            <td><strong>effect_of_intervention</strong></td>
                            <td>Not applicable (hypothesis is the interpretive outcome of the interventions listed above).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>notable_failure_modes</strong></td>
                            <td>ERD may fail to capture algorithmic or symbolic strategies that operate with different internal representations; regression approximation can be local/region-specific causing extrapolation failures.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_humans_or_symbolic</strong></td>
                            <td>ERD contrasts learned vector-space regression with explicit symbolic/algebraic ALU algorithms; authors argue ERD better explains observed behavior in these experiments though do not categorically exclude symbolic implementations in all cases.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Arithmetic with Language Models: from Memorization to Computation', 'publication_date_yy_mm': '2023-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3005.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e3005.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, internal representations, interventions, and performance on arithmetic tasks.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Amnesic probing (applied)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Amnesic probing via nullspace projection (Elazar et al.'s method applied here)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An intervention where a linear probe is trained to extract a feature (output value) from intermediate embeddings; the embeddings are then projected onto the probe's nullspace to remove that feature and the causal effect on model behavior is measured.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Amnesic Probing: Behavioral Explanation with Amnesic Counterfactuals</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Amnesic probing (method applied to decoder layer 3 embeddings)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Method: train a linear regressor to predict X+Y from dec3 embeddings (rmse=0.28); compute nullspace of probe and iteratively project embeddings to remove predictive directions (repeated twice as per prior work), then overwrite model embeddings with projected vectors and run partial forward pass to test behavioral impact.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>Applied to binary addition (X+Y) task in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>reported_mechanism</strong></td>
                            <td>Used to test causal necessity of 'value' information in central decoder embeddings for arithmetic; demonstration that removal of this information abolishes correct computation.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>1) Linear regressor on dec3 embeddings predicts X+Y with rmse=0.28. 2) Projecting embeddings to remove probe-predictive directions and continuing forward pass reduces sequence accuracy from 100% to 0.13%. 3) Control projection of same dimensionality in random directions does not hurt performance (remains 100%), supporting specificity.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_against_mechanism</strong></td>
                            <td>None reported; control indicates the effect is specific to value-information directions rather than generic dimensionality removal.</td>
                        </tr>
                        <tr>
                            <td><strong>intervention_type</strong></td>
                            <td>Nullspace projection of decoder-layer embeddings (amnesic probing).</td>
                        </tr>
                        <tr>
                            <td><strong>effect_of_intervention</strong></td>
                            <td>Severe collapse of arithmetic performance (sequence accuracy 100% -> 0.13%) when value-related directions removed; demonstrates causal role of those embedding directions for addition.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Linear regressor rmse = 0.28 predicting X+Y from dec3 embeddings; sequence accuracy drop from 100% to 0.13% after projection; random-direction projection control kept accuracy at 100%.</td>
                        </tr>
                        <tr>
                            <td><strong>notable_failure_modes</strong></td>
                            <td>Method depends on linear probe effectiveness; removal limited to linearly extractable directions (authors repeat projection twice to remove more info). Complexity is dominated by linear regression and nullspace computation.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_humans_or_symbolic</strong></td>
                            <td>Provides causal evidence that particular continuous internal features are necessary for the LM's arithmetic behavior, a different kind of explanation than human symbolic stepwise algorithms.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Arithmetic with Language Models: from Memorization to Computation', 'publication_date_yy_mm': '2023-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3005.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e3005.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, internal representations, interventions, and performance on arithmetic tasks.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Symbolic Manipulation hypothesis</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Symbolic Manipulation (SM) hypothesis</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Alternative hypothesis that an LM might learn explicit bitwise/algebraic algorithms akin to CPU ALU procedures (truth tables, iterative carries, shift-and-add for multiplication) to perform arithmetic.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Symbolic Manipulation (hypothesis)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Conceptual alternative to ERD: LM could implement stepwise symbolic algorithms (e.g., 3-bit truth table for addition with carry propagation, iterative shift-and-add for multiplication) encoded in model weights/attention circuits.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>Binary addition and multiplication.</td>
                        </tr>
                        <tr>
                            <td><strong>reported_mechanism</strong></td>
                            <td>SM posits token-level discrete algorithmic operations (carry computation, bit-level logic) rather than vector-space regression.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>The paper notes that addition algorithm is simple and could in principle be learned as symbolic manipulation; other works show chain-of-thought and scratchpad can lead models to imitate stepwise algorithms and sometimes improve sample efficiency.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_against_mechanism</strong></td>
                            <td>1) Control random-output experiment shows memorization of discrete mappings is harder than learning arithmetic mapping. 2) VS_v/VS_t and amnesic probing results point to vector-space value representations being central. 3) Ablations show encoder can be squeezed, whereas symbolic implementations might require different structural patterns. Overall authors argue SM is less consistent with the observed internal representations, though not fully excluded.</td>
                        </tr>
                        <tr>
                            <td><strong>intervention_type</strong></td>
                            <td>Discussed conceptually and contrasted with ERD; not directly implemented as distinct algorithmic circuit in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>effect_of_intervention</strong></td>
                            <td>N/A (hypothesis only discussed and compared).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>notable_failure_modes</strong></td>
                            <td>SM learning would likely require explicit step-wise scaffolding or scratchpad and might not generalize in the same way as regression-based solutions; multiplication remains especially challenging to learn purely symbolically in small LMs in prior works.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_humans_or_symbolic</strong></td>
                            <td>Directly aligns with classical symbolic CPU algorithms and human stepwise calculation; authors contrast SM with their ERD evidence and favor ERD for explaining their findings.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Arithmetic with Language Models: from Memorization to Computation', 'publication_date_yy_mm': '2023-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Teaching Arithmetic to Small Transformers. <em>(Rating: 2)</em></li>
                <li>A Mechanistic Interpretation of Arithmetic Reasoning in Language Models using Causal Mediation Analysis. <em>(Rating: 2)</em></li>
                <li>Progress measures for grokking via mechanistic interpretability. <em>(Rating: 1)</em></li>
                <li>Do NLP Models Know Numbers? Probing Numeracy in Embeddings. <em>(Rating: 1)</em></li>
                <li>Amnesic Probing: Behavioral Explanation with Amnesic Counterfactuals <em>(Rating: 2)</em></li>
                <li>Investigating the Limitations of Transformers with Simple Arithmetic Tasks <em>(Rating: 2)</em></li>
                <li>Goat: Fine-tuned LLaMA Outperforms GPT-4 on Arithmetic Tasks <em>(Rating: 1)</em></li>
                <li>Evaluating Transformer Language Models on Arithmetic Operations Using Number Decomposition. <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-3005",
    "paper_id": "paper-260378835",
    "extraction_schema_id": "extraction-schema-73",
    "extracted_data": [
        {
            "name_short": "ED-Transformer (this paper)",
            "name_full": "Custom encoder-decoder Transformer trained from scratch (Maltoni & Ferrara)",
            "brief_description": "A small encoder-decoder Transformer (701K parameters, d_model=64, 6 encoder + 6 decoder layers, vocab=5) trained from scratch on exhaustive 7-bit binary addition and multiplication tasks to study how LMs perform arithmetic.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "Custom encoder-decoder Transformer (this paper)",
            "model_description": "Encoder-decoder Transformer (Vaswani et al. style) trained from scratch; vocabulary size 5 (special tokens, '+/×', '0','1'), d_model=64, feedforward dim=256, 8 heads, 6 encoder layers, 6 decoder layers, ~701K learnable parameters; trained with cross-entropy, AdamW/Adam variants as described.",
            "arithmetic_task_type": "Binary addition and binary multiplication of two 7-bit integers (operands in [0,127]); outputs fixed-length bit-strings (8 bits for addition, 14 bits for multiplication); reverse (LSB-first) token order.",
            "reported_mechanism": "Encoding–Regression–Decoding (ERD): input tokens are encoded into continuous 'value' vectors (v_A, v_B), a regressor computes an output value vector v_R in the internal space, then decoding maps v_R back to output tokens. Authors argue computation occurs in value space (internal embeddings) rather than pure memorization or stepwise symbolic ALU emulation.",
            "evidence_for_mechanism": "1) High generalization on held-out random split despite small training set (implies not simple memorization). 2) Excluding contiguous regions in value space (VS_v) degrades generalization much more than excluding contiguous regions in token/Hamming space (VS_t), indicating importance of contiguous coverage in value space for the learned regressor. 3) Layerwise correlation analyses: token-level distances correlate with first/last decoder layers while value-level distances peak in central decoder layers (layer 3), consistent with token→value encoding, regression in central decoder layers, and value→token decoding. 4) Ablation: encoder can be heavily squeezed without major impact, suggesting decoding/regression happen later. 5) Amnesic probing: removing value information from decoder layer 3 embeddings collapses arithmetic performance (see separate entry).",
            "evidence_against_mechanism": "1) Multiplication shows piecewise / region-dependent behavior (less clear global-value regression), suggesting regression is approximated locally and not a single smooth global function. 2) The authors acknowledge symbolic-like algorithms cannot be fully ruled out; some prior work (e.g., Nanda et al.) shows LMs can implement Fourier-like algorithms for modular addition.",
            "intervention_type": "Dataset splits to probe interpolation/extrapolation (Random, VS_t token-neighborhood, VS_v value-neighborhood); architectural ablations (remove encoder internals, reduce dims, remove FCs, remove positional encodings, remove attention); amnesic probing (project embeddings onto probe nullspace); input-order intervention (reverse vs plain).",
            "effect_of_intervention": "1) VS_v (withheld contiguous value-region) reduced sequence accuracy (addition: ~93.7%, multiplication: ~94.3%) vs Random (~100%/~&gt;99%). 2) Squeezing encoder (remove attention / MLP in encoder) had little effect; removal of positional embeddings or attention layers broke token→value mapping. 3) Reverse (LSB-first) ordering substantially speeds learning and stabilizes training vs plain order. 4) Amnesic probing (nullspace projection of dec3 embeddings) reduced sequence accuracy from 100% to 0.13%, showing causal importance of value information.",
            "performance_metrics": "Addition: converged &lt;50 epochs; sequence accuracy ≈100% on Random validation; MAE on validation = 0. Multiplication: converged ≈250 epochs; sequence accuracy ≈100% on Random validation; MAE on validation = 1.3. VS_v split: addition ≈93.7% sequence accuracy, multiplication ≈94.3%. Control (random output mapping) training: required ~1000 epochs to reach 87.8% training sequence accuracy and validation did not improve (shows memorization is hard). Results averaged over five runs.",
            "notable_failure_modes": "1) Poor extrapolation in value-space regions not covered by training (VS_v). 2) Multiplication learned as piecewise / local approximations leading to discontinuities and somewhat higher residual errors (MAE ~1.3). 3) Tasks with highly discontinuous input-output relationships are harder to memorize and require computation in value space. 4) Dependence on positional encoding and attention—removing these disrupts encoding/decoding.",
            "comparison_to_humans_or_symbolic": "Authors compare LM's internal approach to symbolic CPU-like algorithms (ALU) and argue that the LM does not appear to implement exact symbolic bitwise algorithms; instead it learns numeric regressors in internal vector space (ERD). They note compatibility with other mechanistic findings (e.g., late MLPs doing computation) but caution that regressor approximations can resemble analytic decompositions (e.g., discrete Fourier approximations) found in other work.",
            "additional_notes": "The authors stress that ERD does not require a strict mapping to encoder/decoder modules; encoding and decoding can occur across early/late decoder layers. Reverse ordering of tokens (LSB-first) substantially improves learnability.",
            "uuid": "e3005.0",
            "source_info": {
                "paper_title": "Arithmetic with Language Models: from Memorization to Computation",
                "publication_date_yy_mm": "2023-08"
            }
        },
        {
            "name_short": "nanoGPT (replication)",
            "name_full": "nanoGPT decoder-only Transformer (Karpathy implementation) used as second LM",
            "brief_description": "A small decoder-only Transformer (nanoGPT) with ~298K parameters used to replicate experiments; supports same qualitative conclusions (ERD) while showing somewhat different extrapolation behavior.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "nanoGPT (decoder-only, Karpathy implementation)",
            "model_description": "Decoder-only Transformer (nanoGPT) used with learned positional embeddings, d_model=64, 6 decoder layers, feedforward dim ×4, 8 heads, ~298K parameters; trained from scratch on same binary tasks.",
            "arithmetic_task_type": "Same as main model: binary addition and binary multiplication of two 7-bit integers in reverse (LSB-first) token order.",
            "reported_mechanism": "Same ERD interpretation: encoding tokens to value vectors, regression in internal representation, decoding back to tokens. Behaves similarly across interpolative tests but shows larger degradation on value-space extrapolation.",
            "evidence_for_mechanism": "Replication of VS_t vs VS_v experiments: nanoGPT attains ~100% (addition) and ~99.9% (multiplication) on Random/VS_t but drops substantially on VS_v (addition 82.0%, multiplication 80.6%), consistent with mechanism that relies on value-space regression and is sensitive to coverage in value space.",
            "evidence_against_mechanism": "None reported that overturn ERD; drop in VS_v indicates greater sensitivity to value-space gaps but still supports ERD rather than memorization.",
            "intervention_type": "Same dataset-split interventions (Random, VS_t, VS_v), ablations analogous where applicable.",
            "effect_of_intervention": "VS_v produced a larger performance drop (addition to 82.0%, multiplication to 80.6%), further supporting importance of value-space coverage; otherwise replicates core findings of main model.",
            "performance_metrics": "Random/VS_t: addition ~100% sequence accuracy, multiplication ~99.9%; VS_v: addition 82.0%, multiplication 80.6%. Model size ~298K parameters. Training hyperparameters: minibatch 128, AdamW, lr 0.001, betas 0.9/0.98, gradient clipping 1.0 (as reported in Appendix E).",
            "notable_failure_modes": "Stronger degradation on value-space extrapolation (VS_v) than the encoder-decoder model, indicating decoder-only implementations may be more sensitive to missing contiguous value-region coverage.",
            "comparison_to_humans_or_symbolic": "Same qualitative comparison as main model: likely uses internal regression rather than explicit symbolic algorithm; replicates ERD-style interpretation.",
            "uuid": "e3005.1",
            "source_info": {
                "paper_title": "Arithmetic with Language Models: from Memorization to Computation",
                "publication_date_yy_mm": "2023-08"
            }
        },
        {
            "name_short": "ERD",
            "name_full": "Encoding–Regression–Decoding hypothesis",
            "brief_description": "Hypothesis proposed in this paper that LMs perform arithmetic by (1) encoding token sequences into continuous value vectors, (2) performing the arithmetic as regression in that value space, and (3) decoding result vectors back to token sequences — with the regression happening mainly in central decoder layers.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "ERD (conceptual mechanism)",
            "model_description": "Conceptual mechanism (not a distinct model): tokens -&gt; encoded value vectors (v_A, v_B); regressor computes v_R = regress(v_A, v_B) possibly incrementally using previously produced result context; decoder maps v_R to token outputs.",
            "arithmetic_task_type": "Proposed general mechanism applicable to tasks that can be reduced to numerical regression; instantiated here on binary addition and multiplication.",
            "reported_mechanism": "ERD (see brief_description). The regression step may be incremental (leveraging produced partial outputs when using autoregressive reverse order).",
            "evidence_for_mechanism": "1) VS_v vs VS_t experiments show sensitivity to withheld regions in value space but not token space. 2) Layerwise correlation patterns (token-like at early/late decoder layers, value-like in middle layers). 3) Ablations and amnesic probing show central decoder embeddings contain necessary value information. 4) Control random-output experiment shows memorization alone is harder than learning arithmetic mapping, implying an algorithmic/functional internal strategy.",
            "evidence_against_mechanism": "1) Multiplication exhibits piecewise approximations and cannot be described by a single smooth global regressor. 2) Prior work (e.g., mechanistic findings of Fourier-like circuits) shows alternative numeric circuitizations that could be interpreted differently; ERD is a high-level framing rather than a unique mechanistic proof.",
            "intervention_type": "N/A (hypothesis tested via dataset splits, layer correlations, ablations, and amnesic probing in this paper).",
            "effect_of_intervention": "Not applicable (hypothesis is the interpretive outcome of the interventions listed above).",
            "performance_metrics": null,
            "notable_failure_modes": "ERD may fail to capture algorithmic or symbolic strategies that operate with different internal representations; regression approximation can be local/region-specific causing extrapolation failures.",
            "comparison_to_humans_or_symbolic": "ERD contrasts learned vector-space regression with explicit symbolic/algebraic ALU algorithms; authors argue ERD better explains observed behavior in these experiments though do not categorically exclude symbolic implementations in all cases.",
            "uuid": "e3005.2",
            "source_info": {
                "paper_title": "Arithmetic with Language Models: from Memorization to Computation",
                "publication_date_yy_mm": "2023-08"
            }
        },
        {
            "name_short": "Amnesic probing (applied)",
            "name_full": "Amnesic probing via nullspace projection (Elazar et al.'s method applied here)",
            "brief_description": "An intervention where a linear probe is trained to extract a feature (output value) from intermediate embeddings; the embeddings are then projected onto the probe's nullspace to remove that feature and the causal effect on model behavior is measured.",
            "citation_title": "Amnesic Probing: Behavioral Explanation with Amnesic Counterfactuals",
            "mention_or_use": "use",
            "model_name": "Amnesic probing (method applied to decoder layer 3 embeddings)",
            "model_description": "Method: train a linear regressor to predict X+Y from dec3 embeddings (rmse=0.28); compute nullspace of probe and iteratively project embeddings to remove predictive directions (repeated twice as per prior work), then overwrite model embeddings with projected vectors and run partial forward pass to test behavioral impact.",
            "arithmetic_task_type": "Applied to binary addition (X+Y) task in this paper.",
            "reported_mechanism": "Used to test causal necessity of 'value' information in central decoder embeddings for arithmetic; demonstration that removal of this information abolishes correct computation.",
            "evidence_for_mechanism": "1) Linear regressor on dec3 embeddings predicts X+Y with rmse=0.28. 2) Projecting embeddings to remove probe-predictive directions and continuing forward pass reduces sequence accuracy from 100% to 0.13%. 3) Control projection of same dimensionality in random directions does not hurt performance (remains 100%), supporting specificity.",
            "evidence_against_mechanism": "None reported; control indicates the effect is specific to value-information directions rather than generic dimensionality removal.",
            "intervention_type": "Nullspace projection of decoder-layer embeddings (amnesic probing).",
            "effect_of_intervention": "Severe collapse of arithmetic performance (sequence accuracy 100% -&gt; 0.13%) when value-related directions removed; demonstrates causal role of those embedding directions for addition.",
            "performance_metrics": "Linear regressor rmse = 0.28 predicting X+Y from dec3 embeddings; sequence accuracy drop from 100% to 0.13% after projection; random-direction projection control kept accuracy at 100%.",
            "notable_failure_modes": "Method depends on linear probe effectiveness; removal limited to linearly extractable directions (authors repeat projection twice to remove more info). Complexity is dominated by linear regression and nullspace computation.",
            "comparison_to_humans_or_symbolic": "Provides causal evidence that particular continuous internal features are necessary for the LM's arithmetic behavior, a different kind of explanation than human symbolic stepwise algorithms.",
            "uuid": "e3005.3",
            "source_info": {
                "paper_title": "Arithmetic with Language Models: from Memorization to Computation",
                "publication_date_yy_mm": "2023-08"
            }
        },
        {
            "name_short": "Symbolic Manipulation hypothesis",
            "name_full": "Symbolic Manipulation (SM) hypothesis",
            "brief_description": "Alternative hypothesis that an LM might learn explicit bitwise/algebraic algorithms akin to CPU ALU procedures (truth tables, iterative carries, shift-and-add for multiplication) to perform arithmetic.",
            "citation_title": "here",
            "mention_or_use": "mention",
            "model_name": "Symbolic Manipulation (hypothesis)",
            "model_description": "Conceptual alternative to ERD: LM could implement stepwise symbolic algorithms (e.g., 3-bit truth table for addition with carry propagation, iterative shift-and-add for multiplication) encoded in model weights/attention circuits.",
            "arithmetic_task_type": "Binary addition and multiplication.",
            "reported_mechanism": "SM posits token-level discrete algorithmic operations (carry computation, bit-level logic) rather than vector-space regression.",
            "evidence_for_mechanism": "The paper notes that addition algorithm is simple and could in principle be learned as symbolic manipulation; other works show chain-of-thought and scratchpad can lead models to imitate stepwise algorithms and sometimes improve sample efficiency.",
            "evidence_against_mechanism": "1) Control random-output experiment shows memorization of discrete mappings is harder than learning arithmetic mapping. 2) VS_v/VS_t and amnesic probing results point to vector-space value representations being central. 3) Ablations show encoder can be squeezed, whereas symbolic implementations might require different structural patterns. Overall authors argue SM is less consistent with the observed internal representations, though not fully excluded.",
            "intervention_type": "Discussed conceptually and contrasted with ERD; not directly implemented as distinct algorithmic circuit in this paper.",
            "effect_of_intervention": "N/A (hypothesis only discussed and compared).",
            "performance_metrics": null,
            "notable_failure_modes": "SM learning would likely require explicit step-wise scaffolding or scratchpad and might not generalize in the same way as regression-based solutions; multiplication remains especially challenging to learn purely symbolically in small LMs in prior works.",
            "comparison_to_humans_or_symbolic": "Directly aligns with classical symbolic CPU algorithms and human stepwise calculation; authors contrast SM with their ERD evidence and favor ERD for explaining their findings.",
            "uuid": "e3005.4",
            "source_info": {
                "paper_title": "Arithmetic with Language Models: from Memorization to Computation",
                "publication_date_yy_mm": "2023-08"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Teaching Arithmetic to Small Transformers.",
            "rating": 2,
            "sanitized_title": "teaching_arithmetic_to_small_transformers"
        },
        {
            "paper_title": "A Mechanistic Interpretation of Arithmetic Reasoning in Language Models using Causal Mediation Analysis.",
            "rating": 2,
            "sanitized_title": "a_mechanistic_interpretation_of_arithmetic_reasoning_in_language_models_using_causal_mediation_analysis"
        },
        {
            "paper_title": "Progress measures for grokking via mechanistic interpretability.",
            "rating": 1,
            "sanitized_title": "progress_measures_for_grokking_via_mechanistic_interpretability"
        },
        {
            "paper_title": "Do NLP Models Know Numbers? Probing Numeracy in Embeddings.",
            "rating": 1,
            "sanitized_title": "do_nlp_models_know_numbers_probing_numeracy_in_embeddings"
        },
        {
            "paper_title": "Amnesic Probing: Behavioral Explanation with Amnesic Counterfactuals",
            "rating": 2,
            "sanitized_title": "amnesic_probing_behavioral_explanation_with_amnesic_counterfactuals"
        },
        {
            "paper_title": "Investigating the Limitations of Transformers with Simple Arithmetic Tasks",
            "rating": 2,
            "sanitized_title": "investigating_the_limitations_of_transformers_with_simple_arithmetic_tasks"
        },
        {
            "paper_title": "Goat: Fine-tuned LLaMA Outperforms GPT-4 on Arithmetic Tasks",
            "rating": 1,
            "sanitized_title": "goat_finetuned_llama_outperforms_gpt4_on_arithmetic_tasks"
        },
        {
            "paper_title": "Evaluating Transformer Language Models on Arithmetic Operations Using Number Decomposition.",
            "rating": 1,
            "sanitized_title": "evaluating_transformer_language_models_on_arithmetic_operations_using_number_decomposition"
        }
    ],
    "cost": 0.0146715,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>Arithmetic with Language Models: from Memorization to Computation ⋆
August 5, 2024</p>
<p>Davide Maltoni 
Department of computer science and engineering
University of Bologna
Italy</p>
<p>Matteo Ferrara 
Department of computer science and engineering
University of Bologna
Italy</p>
<p>Arithmetic with Language Models: from Memorization to Computation ⋆
August 5, 20246DEE070676EDA0FE16EEB276794449DBarXiv:2308.01154v4[cs.AI]⋆ The article has been accepted for publication in Elsevier Neural Networks journal. The final version is available on the Elsevier ScienceDirect platform. Preprint submitted to Neural NetworksLanguage ModelsAI ExplainabilityProbingInterpretabilityArithmetic
A better understanding of the emergent computation and problem-solving capabilities of recent large language models is of paramount importance to further improve them and broaden their applicability.This work investigates how a language model, trained to predict the next token, can perform arithmetic computations generalizing beyond training data.Binary addition and multiplication constitute a good testbed for this purpose, since they require a very small vocabulary and exhibit relevant input/output discontinuities making smooth input interpolation ineffective for novel data.We successfully trained a light language model to learn these tasks and ran a number of experiments to investigate the extrapolation capabilities and internal information processing.Our findings support the hypothesis that the language model works as an Encoding-Regression-Decoding machine where the computation takes place in the value space once the input token representation is mapped to an appropriate internal representation.</p>
<p>Introduction</p>
<p>Large Language Models (LLMs) based on Transformer architecture (Vaswani et al., 2017) have recently demonstrated surprising problem-solving capabilities that require logic reasoning, advanced information processing and common sense (Bubeck et al., 2023;Wei et al., 2023Wei et al., , 2022)).Their huge storage capacity combined with a massive training on terabytes of heterogeneous data could suggest that the memorization of an enormous amount of knowledge is enough to perform well on similar test data.However, validations on carefully selected Outof-Distribution (OoD) data proved their reasoning capabilities on novel examples requiring nontrivial generalizations.Unfortunately, the depth and width of such models is so high that decoding and understanding the internal information processing is very challenging.</p>
<p>Focusing on arithmetic calculations, some studies (Yuan et al., 2023) demonstrate that recent LLMs (such as GPT-4) can perform additions and multiplications with long-digit operands, for which the number of variants is so high to exclude the exhaustive memorization of the training set.Nevertheless, the computational approach put in place by LLMs, as well as the interpolation/extrapolation capabilities remain unexplained.</p>
<p>In this work we design some controlled experiments, consisting of simple computation tasks such as binary addition and multiplication, and solve them with two Language Models (LMs) based on Transformer architecture: (i) the original encoder-decoder architecture by Vaswani et al. (2017) and (ii) a more recent decoder-only architecture denoted as nanoGPT (Karpathy, 2022).In spite of their simplicity, these tasks cannot be solved by pure memorization or smooth interpolation and investigating how an LM learn them can improve our understanding of the underlying mechanisms.In particular, using a tiny vocabulary of just 5 tokens and a small training set allows to operate with a light (non-pretrained) LM and use interpretability techniques to investigate internal information processing.</p>
<p>Other studies addressed the ability of LLMs to perform arithmetic computation and train small LMs to learn these tasks from scratch (see related works in Section 2).However, our aim is different: we are not interested in finding the best LM architecture and setup to maximize accuracy on arithmetic operations, but we look for a simple architecture and setup that allow to effectively solve the task in order to be able to investigate the underlying computational approach.The main novelty and contribution of this work are the formalization of the hypothesis that our LM works as an Encoding-Regression-Decoding machine and the design of a number of experiments to support and validate this hypothesis (see Table 1).</p>
<p>After presentation of related works in Section 2, in Section 3 we introduce the experimental testbed and the architecture of the LM used.Section 4 presents the results achieved and introduces control experiments and elaborations to shed light on the computation approach used to solve the tasks.In Section 5 an ablation study is presented and, finally, in Section 6 we include a final discussion and draw some conclusions.</p>
<p>Amnesic probing</p>
<p>Prove that the "value" information is crucial to properly compute the output Appendix D</p>
<p>Related works</p>
<p>LM and LLM capabilities on arithmetic tasks</p>
<p>In Yuan et al. (2023) recent LLMs have been benchmarked in arithmetic tasks, including long-digits sum and multiplication, showing that LLMs such as ChatGPT and GPT-4 can perform reasonably well on these tasks even with no specific tuning.On the other hand, the accuracy of smaller models is markedly lower, and in general they are not able to work with long operands and generalize to OoD data.</p>
<p>Goat (Liu and Low, 2023) a LLaMA model specifically fine-tuned on arithmetic tasks performed even better than GPT-4 on large-number additions and subtractions, probably due to the consistent (digit level) tokenization of numbers in LLaMA models.However, it was able to perform multi-digits multiplication and division only forcing a Chain of Thought (CoT) (Wei et al., 2023) decomposition of such tasks during instruction tuning.Nogueira et al. (2021) tuned a T5-based pre-trained LM on additions and subtractions, and argued that tokenization and input representation are critical to achieve good accuracy.In particular, in their experiments character-based tokenization works better than sub-word tokenization, and making explicit the digit position in the input string (i.e., inserting after each digit a marker to denote its position in the sequence) generally leads to better accuracy.They also trained a vanilla non-pretrained LM on smaller numbers and found that classical sinusoidal-based positional embedding does not perform well, so they proposed a tailored position-wise masked embedding.Their paper contains other interesting findings such as the impact of the digit order (plain or reverse) and the size of the training set.Muffo et al. (2023) tuned pre-trained GPT-2 models on 5-digit additions and 2-digit multiplications.They also found that making explicit the digit position in the input sequence helps to improve accuracy.While good accuracy is reported for addition, the tuned models struggle to learn multiplication even on two-digit operands.Lee et al. (2023) trained small LMs to learn arithmetic tasks, mainly focusing on addition, but also experimenting with subtraction, multiplication, sine and square root.The authors carefully ablated different aspects of the training data to isolate the factors that contribute to the appearance of arithmetic capabilities.In particular, they studied the impact of the input order (plain or reverse) and the utility of providing intermediate information about the decomposition of the task in steps to promote CoT reasoning.Some results and findings included in Lee et al. (2023) will be further discussed throughout this paper.</p>
<p>All the above works provide useful contributions to understand the capabilities and limitations of large and small LMs to deal with arithmetic tasks, but none of them focus on the computational approach used to solve them, which is the main purpose of the present work (see Table 1).</p>
<p>Interpretability techniques</p>
<p>A large number of techniques can be used to investigate the internal working mode of deep neural networks, including Transformers and LMs: see Rauker et al. (2023) for a recent survey.Weights, single neurons, subnetworks/circuits, and activations can be the target of intrinsic approaches (implemented during training) or post-hoc approaches (implemented after training).</p>
<p>Probing is a common technique used to investigate the representations learned by pre-trained LMs: it typically involves training a simple model (denoted as probe) on top of the LM embeddings to predict a given property (Belinkov, 2022).Moreover, structural probing can be used to check whether internal representations encode discrete structures such as syntax trees (Hewitt and Manning, 2019), (White et al., 2021).However, a certain criticism emerged on probing analyses which is believed to disconnect the probing task from the original one and/or to reveal correlations instead of causations.Therefore, instead of focusing on the presence of information on internal encoding, some researchers proposed to check whether the removal of some knowledge from embeddings (e.g., amnesic probing (Elazar et al., 2021)) negatively influences the model ability to perform a task (Elazar et al., 2021), (Lasri et al., 2022).Other interesting approaches to interpretability are mechanistic interpretability (Elhage et al., 2021) and causal abstraction (Geiger et al., 2021): the former is aimed at reverse engineering the algorithm that a model uses to solve a task and to map it to neural circuits; the latter constructs an interpretable causal model and aligns it with neural representations.</p>
<p>In this work we use a mix of intrinsic and post-hoc interpretability techniques: in particular through the experiments we manipulate the training set, change the input representation and the architecture components, perform correlation analyses of embeddings and apply amnesic probing.</p>
<p>Interpretability of arithmetic reasoning with LMs</p>
<p>Stolfo et al. ( 2023) introduced a causal mediation analysis to point out the LM components (e.g., attention heads, Multi-Layer Perceptrons -MLPs) involved in the information processing of simple arithmetic operations, focusing on the flow of numerical information throughout the model layers/columns.The main outcomes of this study are that the model: (i) processes the representation of numbers and operators with the first layers; (ii) information is then conveyed (by attention heads) to the last part of the sequence (i.e., output column), where (iii) it is numerically processed by late MLPs.Nanda et al. (2023) carefully studied the algorithmic approach put in place by a small Transformer to implement modular addition of small numbers.They discovered that the internal algorithmic implementation is based on discrete Fourier transforms and trigonometric identities to convert addition to rotation on a circle.While the outcomes are somewhat surprising, here the term algorithm must be taken with care: even if the experiments prove that internal processing well approximates given equations, the approach is a numerical approximation (based on weight encoded values) that does not generalize to different moduli (as a symbolic implementation of the equations could do).</p>
<p>Both these studies adopted a simplified setting where numbers are presented as single token, and the output is expected at the last position of the sequence.So the models are not operated in autoregressive manner and the multi-token encoding/decoding stages are simplified.In Section 6 we discuss how the above findings are compatible with our findings.</p>
<p>Experiment design</p>
<p>The tasks</p>
<p>We focused on two simple computation tasks: binary addition and binary multiplication.Using binary encoding allows keeping the vocabulary very compact, since we need to encode only the symbols '0', '1' and a few other tokens.The selected tasks have other nice properties such as computing input similarities by Hamming distance and easily generating all combinations.Of course, a classical artificial neural network can be trained to learn to sum and multiply two integers or floating-point numbers, but adding/multiplying strings of tokens with an LM is trickier.</p>
<p>More formally, given two integers A, B (both in the range [0,127]) our input sequence (or prompt) is a 15-token string taking the form:
a 0 a 1 a 2 a 3 a 4 a 5 a 6 ⟨op⟩ b 0 b 1 b 2 b 3 b 4 b 5 b 6
where a i , b i ∈ {'0', '1'} are the symbols corresponding to bits in the i-th position in the binary representation of A and B respectively, and ⟨op⟩ can be either '+' or '×'.</p>
<p>The expected output string (or input completion) is:
R = r 0 r 1 ...r m−1
where r i is the i-th bit in the binary representation of A⟨op⟩B, and m is the number of bits of the expected output string R (8 and 14 for addition and multiplication, respectively).</p>
<p>It is worth noting that:</p>
<p>• we are using a fixed-length input/output representation (with zero padding for unused most significant bits) to make the digit positions more explicit.</p>
<p>• in both the input and output the Least Significant Bits (LSBs) are provided before the Most Significant Bits (MSBs) (a.k.a., reverse or little-endian order) since this was supposed to simplify the model learning1 .As discussed in Appendix C this assumption leads to a much faster training.</p>
<p>If we consider the sequence-to-sequence mapping underlying the proposed tasks we note that even in a simple binary addition a slight change in the input (i.e., a single bit) can produce a relevant change in the output because of the carries propagation.In the example below a single bit modification in the input produces an 8 bit modification in the output: 1000000 + 0111111 → 11111110 1000000 + 1111111 → 00000001 Such input-output discontinuity is made more explicit for addition in Appendix A.</p>
<p>The architecture</p>
<p>A non-pretrained encoder-decoder Transformer based on the original architecture introduced in Vaswani et al. (2017) was used as primary LM.Table 2 reports the model setup and parametrization.The small vocabulary used allows us to keep the model small (just 701K learnable parameters) and trainable from scratch with a limited number of examples.</p>
<p>The LM was trained to learn separately the addition/multiplication tasks.For both problems, we exhaustively generated all the 2 14 = 16384 input/output combinations, which were then randomly split into training (3/4 → 12288) and validation (1/4 → 4096) sets.In our experiments we do not need a separate dataset to tune hyperparameters so our validation set coincides with the test set.</p>
<p>An additional control experiment was run where the input sequences were the same of the addition experiment but the output completion was randomly generated (with the same length as the addition, i.e., 8 tokens).In this case, the lack of any dependencies between input and output makes it impossible to learn an algorithmic approach (or smooth mapping) to solve the problem and the only strategy to learn the training set is memorizing all the sequences.</p>
<p>When the trained LM is used in inference mode, we always pick the most probable token from the logit outputs (i.e., greedy decoding).Two metrics can be used to denote the LM accuracy: token accuracy refers to the probability of generating the next token correctly, while sequence accuracy refers to the probability of generating the whole output string correctly in autoregressive mode (i.e., generating one token at a time and appending it to the current prompt).Most of the experiments have been repeated with a second LM (nanoGPT by Karpathy ( 2022)) which is a good representative of the decoder-only family.Details are reported in Appendix E.</p>
<p>All the experiments included in this paper can be easily reproduced by running the code available at: (to be disclosed upon acceptance).</p>
<p>Results</p>
<p>Learning addition and multiplication</p>
<p>Figure 1 shows that our simple LM is able to learn addition in less than 50 epochs, and multiplication in about 250 epochs2 .As expected multiplication is more complex and requires more training: this is due to the high non-linearity of this operation (more on this later) and to the higher length of the output (14 vs 8 tokens).The accuracy on the validation set is very close to the training set, denoting almost perfect generalization on numbers never seen before.This is a somewhat surprising result, especially considering the limited size of the training data.No grokking3 was observed (Nanda et al., 2023).Similar results were obtained with nanoGPT (see  2021) (see their Appendix B for a similar setup), we were able to learn addition with the native sinusoidal positional encoding.Moreover, in Lee et al. (2023) additions can be effectively learnt by a simple LM, but to reach 100% accuracy the training set had to be balanced in terms of the operand magnitude (i.e., number of digits) and carry propagation.</p>
<p>The effectiveness of our training procedure is probably due to the lower complexity determined by a small vocabulary and fixed-length representation.As to multiplication, Muffo et al. (2023) were not able to effectively learn two (decimal) digits multiplication, while Lee et al. (2023) and Liu and Low (2023) had to provide extra intermediate steps in the prompt (denoted as detailed scratchpad) or during instruction tuning, respectively.On the contrary our model effectively learnt multiplication of 7 binary digit operands: again the simplified setup may have been the key.</p>
<p>On the workstation used (with a single Titan RTX GPU) training can be completed in just 8 and 46 minutes for addition and multiplication, respectively.An estimation of the training complexity C of an LLM in term of floating point operations is 6 × N × T (Kaplan et al., 2020), where N is the number of model parameters (about 701K as reported in Table 2) and T the number of training tokens.T can be obtained as the product of the training set size (12288 in our experiments -see Section 3.2), the sequence length in tokens (23 and 29 for addition and multiplication, respectively -see Section 3.1) and the number of epochs (50 and 250 for addition and multiplication, respectively).Hence, for addition T is 14M (12288 × 23 × 50) and therefore C is about 59 × 10 12 operations while for multiplication T is 89M (12288 × 29 × 250) and C is about 374 × 10 12 operations.</p>
<p>Control experiment: random output</p>
<p>If the output is randomly generated and therefore there is no relation with the input, the only possibility of learning the training set is by memorizing the whole data.Figure 2 shows the training results: a much larger number of epochs (i.e., 1000) were necessary to reach a sequence accuracy of 87.8%, and, as expected, the validation accuracy did not increase over the epochs.The difficulty of memorizing the training set (many more epochs) is due to the high discontinuity of the input-output mapping.In fact, because of the random output generation, very similar input sequences can be associated to completely different outputs.</p>
<p>Therefore, even if we only consider the accuracy on the training set, this result shows that an exhaustive memorization of the input is much more complex for the LM than solving the addition and multiplication tasks.This leads us to assume that, to efficiently solve the above computation tasks, the LM has found a computational approach (or algorithm) to simplify the output prediction.Now the question is: what is the approach?</p>
<p>The computational approach</p>
<p>Let us consider two alternative approaches: Symbolic Manipulation (SM): a first idea is that the LM could learn the binary integer addition/multiplication algorithms used by an ALU inside a CPU (see Appendix B for a short reminder).Indeed, the addition algorithm is not complex and can be solved by using a 3-bit truth table (to sum each pair of corresponding bits with the carry-in) and iterative carry-out propagations.However, multiplication (by iterative additions) is much more complex and trickier to learn by using a symbolic manipulation approach.Furthermore, as shown in Lee et al. (2023), a simple LM can also learn complex operations such as the sine function or the square root, whose mathematical (and algorithmic) decomposition is very complex since they require Taylor expansion and Newton method, respectively.</p>
<p>Encoding-Regression-Decoding (ERD): if we consider the model architecture (Transformer) used for the LM and the underlying word embedding by vector representations, it is more likely that the LM solves the problem by decomposing it in the following three phases:</p>
<ol>
<li>Encoding (token to value): maps the input sequence (i.e., a 0 a 1 a 2 a 3 a 4 a 5 a 6 ⟨op⟩ b 0 b 1 b 2 b 3 b 4 b 5 b 6 ) to a suitable vector representation.In principle, two vectors v A and v B representing the values (or magnitudes) of A and B are enough.2. Regression: learns the computation as a supervised regression problem in the vector space:</li>
</ol>
<p>v R = regress(v A , v B ). Actually this regression formulation is an oversimplification of the problem since in the next-token-prediction training the LM works incrementally.In Appendix C this discussion will be expanded.3. Decoding (value to token): maps the value vector v R back to token representation (i.e., r 0 r 1 ...r m ).</p>
<p>It is worth noting that the above Encoding and Decoding phases do not need to be mapped onto the Transformer encoder and decoder (more on this later).The experiments reported in Sections 4.4 and 4.5 support the ERD assumption.The capability of capturing number magnitudes by pretrained embedders was also investigated by Wallace et al. (2019) who successfully trained a simple external regressor to compute the sum of two numbers starting from their embeddings.Other interesting studies on capturing numeracy with embedding were carried out by Naik et al. (2019) and Sundararaman et al. (2020).</p>
<p>Interpolation vs extrapolation</p>
<p>The random training/validation split performed for the experiments reported in Section 4.1 constitutes a somewhat simplified testbed to learn the two tasks.In fact, random split leads to a complete (even if sparse) coverage of the input space by both the training and validation sets, where each example in the validation set has high chance to be close to a training set example, and interpolation is enough to fill the gaps.</p>
<p>Hereafter, we exploit the well-known difficulty of a numerical regressor to work in the extrapolation regime to get insights about the computational approach of the LM.In particular, we considered two different criteria to isolate specific portion of the input space for the validation set, in order to better investigate extrapolation capabilities:
• VS t = {(A, B)|(A, B) ∈ NN 4096 ((A * , B * ))}
where NN 4096 ((A * , B * )) is the set of 4096 pairs (A, B) which are the nearest neighbors to a centroid (A * , B * ) according to the Hamming distance between the corresponding token representations (i.e., number of different tokens at corresponding positions).As centroid (A * , B * ) in the token space we used: 1010101 ⟨op⟩ 0101010.
• VS v = {(A, B)|32 ≤ A &lt; 96 and 32 ≤ B &lt; 96}
here the centroid is located in the middle of the value space (64, 64), so VS v is a squared region (of side 64) centered in the value space.</p>
<p>Both VS t and VS v isolate a contiguous data region of 4096 samples to be included in the validation set, but in the former the samples are close in the token representation space, while in latter are close in the value space.Being such contiguous portions of space excluded from the training set, we can expect a worse generalization.From the results (see Figure 3) we note that VS t is very marginally affecting LM training and generalization while VS v has a major impact: in fact, in the second case, for both addition and multiplication the final sequence accuracy is from 4% to 6% points lower.This result strengthens the ERD hypothesis, since: (i) using VS v leads to the exclusion of a specific contiguous portion of value space during phase 2 and does not allow to properly train the regressor in this region; (ii) the encoding performed during phase 1 makes irrelevant the selection performed according to VS t because, after encoding, the corresponding data point remains scattered in the value space and the regressor can easily interpolate among them.Similar results were obtained with nanoGPT (see Figure E.8 in Appendix E.)</p>
<p>Looking at internal representations</p>
<p>Understanding the internal representation (embeddings in the vector space) in a trained Transformer is not an easy task.However, in the specific setting considered we can gain some hints by looking at the distances between the embedding of different data points (at different layers) and correlating them with the corresponding distances at input/output levels.</p>
<p>Given an LM trained on addition (or multiplication) we consider the dataset S including the 128 input pairs where the two operands have identical values4 : Results are averaged over five runs.VS t reaches 100% accuracy on additions (the same of Random split) and 97.5% accuracy on multiplication (just 1.4% less than random split); VS v reaches 93.7% on addition and 94.3% on multiplication (6.3% and 4.6% less than Random split, respectively).
S = {(A, A)|0 ≤ A &lt; 128}
At the input level (in) we can compute two ordered sets of 8128 (128×127/2) distances each:
d in,t = {hdist(X, Y)|(X, X), (Y, Y) ∈ S , X &lt; Y} d in,v = {|X − Y| |(X, X), (Y, Y) ∈ S , X &lt; Y}
where hdist(X, Y) is the Hamming distance between the token representation of X and Y, and the subscript letters t and v denote token and value levels, respectively.</p>
<p>At the output level (out) we can compute the two corresponding sets of distances as:
d out,t = {hdist(P, Q)|(X, X), (Y, Y) ∈ S , X &lt; Y} d out,v = {|P − Q| |(X, X), (Y, Y) ∈ S , X &lt; Y}
where (P = X + X and Q = Y + Y) for addition, and (P = X × X and Q = Y × Y) for multiplication.</p>
<p>Finally, for each intermediate level of the Transformer encoder (enc) or decoder (dec) we can compute the Euclidean distances among the corresponding embedding vectors.
d enc i = {∥enc i (X, X) − enc i (Y, Y)∥ |(X, X), (Y, Y) ∈ S , X &lt; Y} d dec i = {∥dec i (X, X) − dec i (Y, Y)∥ |(X, X), (Y, Y) ∈ S , X &lt; Y}
where enc i and dec i are the output vectors obtained by concatenating all the token embeddings (each of dimensionality 64) after the i-th encoder and decoder layer, respectively.For example enc i has dimensionality 960 = 64 × 15 where 15 is the number of tokens in the encoder.</p>
<p>Even if the distances in the different sets have different ranges, we can use correlation to find out similarities.If two sets of distances are correlated we can expect that the corresponding representations/embeddings are correlated as well.Since both Pearson and Spearman correlations (Schober et al., 2018) provided similar outputs, for simplicity in Figure 4 we report only Pearson correlations.</p>
<p>The yellow cells in the tables of Figure 4 confirm the low correlation between the token and value representation at both input and output level.The blue cells show that correlation remains quite similar across the encoder layers as if the encoder was not performing any significant computation (this is confirmed in Section 5 where we achieve similar results by totally removing all intermediate attention and MLP layers in the encoder).More interesting is the trend of correlations across the decoder layers (green cells).In particular, for the addition the token representation has high correlation with the first and last layers and low with central layers, while the value representation has an opposite trend (see also Figure 4.c).These results support the ERD hypothesis and in particular that the initial and final layers in the decoder transform from token to value representation (and vice versa) while the central layers perform regression in the value space.In particular, at layer 3, the correlation at token level is minimum while the correlation at value level is maximum.</p>
<p>For multiplication the low-high-low trend at value level is less evident (Figure 4.d orange curve), probably because the quadratic dependence of the output from the input (at value level) does not allow to learn a simple regressor smoothly working in the whole vector space, and the mapping is performed by piecewise linear approximation in different space regions, which introduces discontinuities that make global distances in the vector space unsuitable to quantify the representation similarity.</p>
<p>As discussed in Section 2.2, correlation analyses might be insufficient to prove that the presence of a certain information in the embeddings is really necessary to compute the output (direct causation).So to further strengthen our hypothesis we applied an amnesic probing technique (Elazar et al., 2021) and proved that, upon removal of value information from the embeddings, the LM is no longer capable of performing the right computation.Details are reported in Appendix D.</p>
<p>Ablation study</p>
<p>This section presents the results of an ablation study where the LM architecture was simplified, to understand which components are necessary to learn the addition/multiplication computation.Squeezing the encoder (i.e., removing all intermediate attention and MLP layers) does not have a relevant impact; this is consistent with other works claiming that a decoder only architecture (Liu et al., 2018) can achieve similar results with respect to an encoder-decoder Transformer, and further confirmed by the nanoGPT results presented in Appendix E. A simplification of the architecture in terms of (i) reduction of dimensionality; (ii) reduction of number of heads; (iii) removal of fully connected layers is well tolerated, while positional embedding and attention layers are mandatory for the LM in order to properly perform token to value transformation (and vice versa).Table 3 summarizes the results.</p>
<p>Table 3: Epochs necessary to reach 95% accuracy on the validation set.A dash is used when 95% accuracy is not achieved in 1K epochs: in such case the accuracy reached is reported within brackets.</p>
<p>Configuration</p>
<p>Addition Multiplication Full (see</p>
<p>Discussion and conclusions</p>
<p>In this paper we introduced a simplified setup to allow a light LM to learn binary addition and multiplication.Both the LM architectures considered easily learn the two tasks and generalizes well on unseen data, proving that memorization of the training data is neither necessary nor efficient.The experiments on the interpolation/extrapolation capabilities and correlation of input-output representations with internal embedding suggest that the model solves the computational task as a supervised regression problem in the value space after an initial encoding from token to values, and a final decoding from output value to tokens.Under this hypothesis: (i) any task that can be solved by a neural network regressor can be solved by an LM as well, with the extra burden of end-to-end learning decoding/encoding steps; (ii) when looking at interpolation/extrapolation capabilities of an LM applied to a mathematical task, we should not concentrate on the input token representation but on the internal representation after encoding, keeping in mind the difficulties of a numerical regressor to work on region spaces not covered by the training set; (iii) on a more speculative side, we could guess that modern LLMs learn the number encoding/decoding once and reuse it across different numerical tasks whereas a specific regressor is learned for each task.</p>
<p>Our ERD hypothesis could be questioned considering some recent findings from Lee et al. (2023) where providing in the prompt intermediate information (scratchpad) about the decomposition of arithmetic tasks improves the training efficiency and requires fewer examples.This could suggest that a symbolic manipulation approach is adopted to learn imitating step by step the proposed decomposition.However, in most of the cases their model was able to learn the same task (even if slowly) without scratchpad and/or with wrong scratchpads.As argued by the authors the higher efficiency is actually in terms of examples and not in terms of tokens since each scratchpad requires a large number of extra tokens, and we guess these could be used as extra features by the underlying regressor.Furthermore, scratchpad contribution is negligible for more complex operations such as sine and square root, but, unexpectedly, learning such complex operations was simpler than multiplication.This is not strange under the ERD hypothesis where a unary smooth operator like the sine can be learned by a supervised regressor independently of the mathematical method used for its computation.</p>
<p>The algorithmic interpretation that Nanda et al. (2023) provided for modular addition, could also suggest that their LM discovered and efficient symbolic manipulation approach; however, as discussed in Section 2.3, it is more likely that a regressor was learned to numerically approximate an efficient sparse Fourier decomposition, under regularization constraints favoring sparsity.Finally, the information flow described in Stolfo et al. (2023), points out that MLPs in the last layers are responsible for the numerical computation of the solution, which is compatible with the hypothesis of a multi-layer regressor.</p>
<p>Of course we are not claiming that all the capabilities of modern LLMs can be explained by regression, but regression is likely to be one of the internal tools that LLMs uses to predict the next token when numbers come into play.</p>
<p>As to future research we plan to: i) further investigate the generalization capabilities of LMs in arithmetic tasks with respect to the composition of the training and test sets (Feng et al., 2023;Keskar et al., 2017), ii) design simplified experiments/setups for tasks that cannot be easily mapped to regression problems such as chain of reasoning and logic deductions.current bits5 , then a two-output 3-bit truth table (Table B.5) can be used to generate the output bit o i and carry c i used when summing the next pair of bits:</p>
<p>Inputs</p>
<p>Outputs
a i b i c i−1 o i c i 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 0 1 1 0 1 1 0 0 1 0 1 0 1 0 1 1 1 0 0 1 1 1 1 1 1
A simple approach to execute binary multiplication is through iterative binary sums.Each bit b i of the second operand is multiplied by the whole first operand, but this inner multiplication is straightforward since it results either in a sequence of 0 (if b i = 0) or a copy of the first operand (if b i = 1).This intermediate result is then shifted left and summed to the current output.An example is reported in Figure B.5 below.</p>
<p>Appendix D. Amnesic probing results</p>
<p>The outcome of correlation analyses performed in Section 4.3 suggests that the embeddings in the central layers of the decoder contain information related to the value representation of the output (see Figure 4).However correlation does not mean causation, and here we investigate deeper.Amnesic probing was proposed in Elazar et al. (2021) building on the approach Ravfogel et al. (2020) to check to what extent a model output is affected by the removal of specific features or attributes in an intermediate level embeddings.Here we focus on addition and we try to remove some features from the decoder layer 3 embeddings (dec 3 (X, Y)).To this purpose a linear probe (a linear regressor in our case) was trained to predict the output value (X + Y) starting from the dec 3 (X, Y) embeddings and its nullspace is used to project the embeddings in a new space lacking output value information.According to Ravfogel et al. (2020), due to the simplicity of the linear regressor used, the procedure is repeated twice to remove more information.Our results show that:</p>
<p>1.A simple linear regressor trained on dec 3 (X, Y) embeddings can reach high accuracy in predicting X + Y (rmse = 0.28).2. If the projected embeddings are overwritten in the LM decoder at level 3, and a partial forward pass is performed thereafter, the addition sequence accuracy severely drops from 100% to 0.13%.3.As indicated in Elazar et al. (2021) since any information removal could hamper the model accuracy, a control test was performed by removing the same amount of information (but on random directions instead of the nullspace directions) and in this case the LM final sequence accuracy remained 100%.</p>
<p>This experiment provides further support to the hypothesis that the value information is not only present in the inspected embeddings but is also crucial for the output computation.</p>
<p>On the computational side, we argue that amnesic probing complexity is low because it relies on simple steps as linear regression and null space computation, with the former being the most demanding step.Linear regression complexity is O(nd 2 + d 3 ) where n is the number of training examples and d the dimensionality of the embeddings.</p>
<p>Appendix E. NanoGPT -a decoder-only LM</p>
<p>To demonstrate that our findings generalize beyond the encoder-decoder architecture of the original Transformer used in this work, the main experiments have been repeated using a second LM, that is the nanoGPT (Karpathy, 2022) decoder-only model.Table E.6 reports the details of the nanoGPT model adopted.Using the VS t subset, it reaches 100% and 99.9% accuracy on addition and multiplication, respectively (the same of Random split) while, using the VS v subset, it reaches 82.0% on addition and 80.6% on multiplication (18.0% and 19.4% less than Random split, respectively).Results are inline with those obtained in Section 4.4 but here the difference between VS t , and VS v is still more significant.</p>
<p>Figure E.7 in Appendix E.) Unlike Nogueira et al. (</p>
<p>Figure 1 :
1
Figure 1: Sequence accuracy.From the left: addition and multiplication.Results are averaged over five runs.Note that, training and validation curves are almost overlapped.At the end of training the Mean Absolute Error (MAE) on the validation set, between the real and generated operation results, is 0 and 1.3 for addition and multiplication, respectively.</p>
<p>Figure 2 :
2
Figure 2: Sequence accuracy using random output in the training set.Results are averaged over five runs.</p>
<p>Figure 3 :
3
Figure 3: Sequence accuracy on Random, VS t , and VS v validation subsets for addition (left) and multiplication (right).Results are averaged over five runs.VS t reaches 100% accuracy on additions (the same of Random split) and 97.5% accuracy on multiplication (just 1.4% less than random split); VS v reaches 93.7% on addition and 94.3% on multiplication (6.3% and 4.6% less than Random split, respectively).</p>
<p>Figure 4 :
4
Figure 4: Pearson correlation between ordered sets of distances for addition (a) and multiplication (b).Each cell denotes the correlation between the two ordered set of distances specified in the corresponding row and column.Note that since for addition in this experiment the output value is always twice the input, the correlation values (blue and green cells) are the same for d in, and d out, block of values.Graphs (c) and (d) show the correlations of output distances d out,t (at token level -blue curves) and d out,v (at value level -orange curves) with the embedding distances d dec i across the 6 decoder layers for addition and multiplication, respectively.</p>
<p>Figure B. 5 :
5
Figure B.5: Example of 4-digit binary multiplication.The sum can be performed incrementally with a two-operand adder.</p>
<p>Figure C. 6 :
6
Figure C.6: Sequence accuracy on validation set for reverse (default in this work) and plain order of the input and output representations.From left to right: addition and multiplication.</p>
<p>Figure E. 7
7
Figure E.7 shows that the nanoGPT model was able to learn addition and multiplication still more efficiently than the original Transformer (compare Figure 1 with Figure E.7).For the training, we used a minibatch size of 128, a standard CrossEntropy loss, the AdamW optimizer with a learning rate of 0.001 and betas = 0.9 and 0.98, and a gradient clipping to 1.0.</p>
<p>Figure E. 7 :
7
Figure E.7: Sequence accuracy of the nanoGPT model (refer to Section 4.1 for more details).From the left: addition and multiplication.Results are averaged over five runs.Note that, training and validation curves are almost overlapped.</p>
<p>Figure</p>
<p>Figure E.8 shows the sequence accuracy of the nanoGPT model on Random, VS t , and VS v validation subsets for addition and multiplication (see Section 4.4 for more details).Using the VS t subset, it reaches 100% and 99.9% accuracy on addition and multiplication, respectively (the same of Random split) while, using the VS v subset, it reaches 82.0% on addition and 80.6% on multiplication (18.0% and 19.4% less than Random split, respectively).Results are inline with those obtained in Section 4.4 but here the difference between VS t , and VS v is still more significant.</p>
<p>Figure E. 8 :
8
Figure E.8: Sequence accuracy of the nanoGPT model on Random, VS t , and VS v validation subsets for addition (left) and multiplication (right).Results are averaged over five runs.</p>
<p>Table 1 :
1
The main contributions of this work.</p>
<p>Table 2 :
2
Details of the LM model used in our experiments.The total number of learnable parameters is just 701K, which is several orders of magnitudes smaller than recent billion-parameters LLMs.
vocabulary size5vocabulary0: unused, 1: <start>, 2: '+' or '×', 3: '0', 4: '1'token embeddinglearnedpositional encodingfixed (sinusoidal)d model64d f fd model × 4num heads h8encoder layers6decoder layers6dropout0.1learnable parameters701K</p>
<p>Table 2
2)39137Squeezing the encoder (see main text)60426num heads h=125225Reduced dimensionality (d model = 32)66309No positional embedding-(2.4%)-(1.8%)No attention layers-(0.9%)-(1.7%)No fully connected layers56398</p>
<p>Table A .
A
4: Addition input-output discontinuities.</p>
<p>Table B .
B
5: Two-output 3-bit truth table for binary addition.</p>
<p>Table E .
E
6: Details of the nanoGPT model.
token embeddinglearnedpositional encodinglearnedd model64d f fd model × 4num heads h8decoder layers6dropout0.1learnable parameters298K
in binary arithmetic the addition/multiplication algorithms start processing the LSBs in order to correctly propagate the intermediate carries.
We used the standard CrossEntropy loss, the Adam optimizer with the learning rate of 0.0001 and betas = 0.9 and 0.98, and a minibatch size of 128.
Grooking refers to the case where validation accuracy, much smaller than training accuracy at initial stages, suddenly increases after a certain number of epochs.
since the input prompt contains two operands, we select only the cases with identical values (A = B) in order to easily determine the "magnitude" of the input, and thereafter compute meaningful distances.
when summing the LSBs (i = 0), there is no pending carry, so c −1 = 0
Appendix A. Addition input-output discontinuitiesGiven an input/output pair we consider the (2 14 ) variants obtained by perturbing (i.e., 0-1 swap) the input bits and counting the resulting changes in the output.These values, averaged over all possible input/output pairs (again 2 14 ) and normalized by row are inserted in the cells of A.4.So, for example the value in cell (row=2, column=3) means that in the 27.9% of the cases a perturbation of 2 (over 14) bits in the input leads to a change of 3 (over 8) bits in the output.Input-output discontinuities, which are further amplified in case of multiplications, make it very unlikely to solve these tasks by smooth interpolation of the input representation.Appendix B. Binary addition and multiplicationBinary addition can be executed by summing pairs of corresponding bits a i and b i , starting from the LSBs (a 0 and b 0 ) and propagating carries.Let c i−1 be the pending carry used to sum In Section 4.3 we argued that an arithmetic computation task can be decomposed into three steps whose central one is learning a regressor in the value space: v R = regress(v A , v B ).If we consider the autoregressive working mode of a Transformer and its predict-next-token training, the regressor must be able to work incrementally given the output produced so far.In particular, we can formulate the problem as:) where:are the value vectors of the two input operands, obtained as the concatenation of the value vectors of single tokens.Both are always fully available to the decoder.Note that, v a i and v b i are not the bits of the inputs, but correspond to their value vectors including also positional information.• i is the position of the token to be predicted (we can assume it is available through positional encoding).• c R i−1 = [c r 0 c r 1 ...c r i−1 ] is a value vector encoding the current context determined by the result produced so far (entering in the decoder from the bottom).• v r i is the value vector of the i-th token.In principle, the regressor could predict each v r i based on v A and v B alone, but we argue that the exploitation of the result produced so far c R i−1 can lead to higher training efficiency.To this purpose is interesting to evaluate the impact of the output ordering (plain or reverse).In both the addition and multiplication the i-th token of the result only depends on the tokens of the inputs at positions ≤ i (see Appendix B).Therefore, if reverse order is adopted, as we assumed until now,and c R i−1 are sufficient to predict v r i .Viceversa, if the output computation starts with the MSBs the regressor cannot leverage the above iterative decomposition and needs to learn the task as a global operation using whole vectors v A and v B with almost no support from the result produced so far.In FigureC.6 we note that with plain order both addition and multiplication require a much longer number of epochs to converge and the learning curve is less stable.Further experiments proved that, as expected, the order of the inputs (also reverse by default in this study) is irrelevant, since the LM can always access the whole input representations v A and v B .The advantages of using the reverse order are pointed out in other recent studies(Nogueira et al., 2021;Lee et al., 2023).In particular,Lee et al. (2023)reported a significant improvement with respect to plain order.
Y Belinkov, Probing Classifiers: Promises, Shortcomings, and Advances, Computational Linguistics. 202248</p>
<p>S Bubeck, V Chandrasekaran, R Eldan, J Gehrke, E Horvitz, E Kamar, P Lee, Y Lee, Y Li, S Lundberg, H Nori, H Palangi, M Ribeiro, Y Zhang, arXiv:2303.12712Sparks of Artificial General Intelligence: Early experiments with GPT-4. 2023</p>
<p>Amnesic Probing: Behavioral Explanation with Amnesic Counterfactuals. Y Elazar, S Ravfogel, A Jacovi, Y Goldberg, Transactions of The Association for Computational Linguisticss. 92021</p>
<p>. N Elhage, N Nanda, C Olsson, T Henighan, N Joseph, B Mann, A Askell, Y Bai, A Chen, T Conerly, N Dassarma, D Drain, D Ganguli, Z Hatfield-Dodds, D Hernandez, A Jones, J Kernion, L Lovitt, K Ndousse, D Amodei, T Brown, J Clark, J Kaplan, S Mccandlish, C Olah, A Mathematical Framework for Transformer Circuits. 2021</p>
<p>Activity-weight duality in feed-forward neural networks reveals two co-determinants for generalization. Y Feng, W Zhang, Y Tu, Nature Machine Intelligence. 52023</p>
<p>A Geiger, H Lu, T F Icard, C Potts, Causal Abstractions of Neural Networks, 35th Conference on Neural Information Processing Systems. NeurIPS 20212021</p>
<p>A Structural Probe for Finding Syntax in Word Representations. J Hewitt, C Manning, Conference of the North American Chapter. the Association for Computational Linguistics2019</p>
<p>J Kaplan, S Mccandlish, T Henighan, T B Brown, B Chess, R Child, S Gray, A Radford, J Wu, D Amodei, arXiv:2001.08361Scaling Laws for Neural Language Models. 2020</p>
<p>A Karpathy, N S Keskar, D Mudigere, J Nocedal, M Smelyanskiy, P T P Tang, On Large-Batch Training for Deep Learning: Generalization Gap and Sharp Minima, 5th International Conference on Learning Representations. 2022. 2017nanoGPT: a lightweight implementation of medium-sized GPTs</p>
<p>K Lasri, T Pimentel, A Lenci, T Poibeau, R Cotterell, Probing for the Usage of Grammatical Number, 60th Annual Meeting of The Association for Computational Linguistics. 2022</p>
<p>N Lee, K Sreenivasan, J Lee, K Lee, D Papailiopoulos, arXiv:2307.03381Teaching Arithmetic to Small Transformers. 2023</p>
<p>T Liu, B K H Low, arXiv:2305.14201Goat: Fine-tuned LLaMA Outperforms GPT-4 on Arithmetic Tasks. 2023</p>
<p>P Liu, M Saleh, E Pot, B Goodrich, R Sepassi, L Kaiser, N Shazeer, Generating Wikipedia by Summarizing Long Sequences, 6th International Conference on Learning Representations (ICLR). 2018</p>
<p>Evaluating Transformer Language Models on Arithmetic Operations Using Number Decomposition. M Muffo, A Cocco, E Bertino, 13th Conference on Language Resources and Evaluation (LREC). 2023</p>
<p>A Naik, A Ravichander, C Rose, E Hovy, Exploring Numeracy in Word Embeddings, 57th Annual Meeting of The Association for Computational Linguistics. 2019</p>
<p>N Nanda, L Chan, T Lieberum, J Smith, J Steinhardt, arXiv:2301.05217Progress measures for grokking via mechanistic interpretability. 2023</p>
<p>Investigating the Limitations of Transformers with Simple Arithmetic Tasks, 1st Mathematical Reasoning in. R Nogueira, Z Jiang, J Lin, General Artificial Intelligence Workshop @ (ICLR). 2021</p>
<p>T Räuker, A Ho, S Casper, D Hadfield-Menell, arXiv:2207.13243Toward Transparent AI: A Survey on Interpreting the Inner Structures of Deep Neural Networks. 2023</p>
<p>S Ravfogel, Y Elazar, H Gonen, M Twiton, Y Goldberg, Null It Out: Guarding Protected Attributes by Iterative Nullspace Projection, 58th Annual Meeting of the Association for Computational Linguistics. 2020</p>
<p>Correlation Coefficients: Appropriate Use and Interpretation. P Schober, C Boer, L Schwarte, 2018Anesthesia &amp; Analgesia126</p>
<p>A Mechanistic Interpretation of Arithmetic Reasoning in Language Models using Causal Mediation Analysis. A Stolfo, Y Belinkov, M Sachan, arXiv:2305.150542023</p>
<p>D Sundararaman, S Si, V Subramanian, G Wang, D Hazarika, L Carin, Methods for Numeracy-Preserving Word Embeddings, Conference on Empirical Methods in Natural Language Processing (EMNLP). 2020</p>
<p>Attention is All you Need. A Vaswani, N Shazeer, N Parmar, J Uszkoreit, L Jones, A Gomez, L Kaiser, I Polosukhin, Advances in Neural Information Processing Systems (NIPS). 201730</p>
<p>E Wallace, Y Wang, S Li, S Singh, M Gardner, arXiv:1909.07940Do NLP Models Know Numbers? Probing Numeracy in Embeddings. 2019</p>
<p>J Wei, Y Tay, R Bommasani, C Raffel, B Zoph, S Borgeaud, D Yogatama, M Bosma, D Zhou, D Metzler, E Chi, T Hashimoto, O Vinyals, P Liang, J Dean, W Fedus, Emergent Abilities of Large Language Models. TMLR2022</p>
<p>J Wei, X Wang, D Schuurmans, M Bosma, B Ichter, F Xia, E Chi, Q Le, D Zhou, arXiv:2201.11903Chain-of-Thought Prompting Elicits Reasoning in Large Language Models. 2022</p>
<p>J White, T Pimentel, N Saphra, R Cotterell, Non, Linear Structural Probe, Conference of the North American Chapter. the Association for Computational Linguistics2021</p>
<p>How well do Large Language Models perform in Arithmetic tasks. Z Yuan, H Yuan, C Tan, W Wang, S Huang, arXiv:2304.020152023</p>            </div>
        </div>

    </div>
</body>
</html>