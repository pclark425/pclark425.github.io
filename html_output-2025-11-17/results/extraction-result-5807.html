<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-5807 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-5807</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-5807</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-116.html">extraction-schema-116</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how the format or presentation of problems (e.g., prompt wording, structure, context, formatting) affects the performance of large language models (LLMs), including details of the formats used, tasks evaluated, models tested, performance results, and any explanations or comparisons.</div>
                <p><strong>Paper ID:</strong> paper-b68b2e81ae2de647394ec05ee62ecf108bf2b50a</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/b68b2e81ae2de647394ec05ee62ecf108bf2b50a" target="_blank">Eliciting Knowledge from Language Models Using Automatically Generated Prompts</a></p>
                <p><strong>Paper Venue:</strong> Conference on Empirical Methods in Natural Language Processing</p>
                <p><strong>Paper Abstract:</strong> The remarkable success of pretrained language models has motivated the study of what kinds of knowledge these models learn during pretraining. Reformulating tasks as fill-in-the-blanks problems (e.g., cloze tests) is a natural approach for gauging such knowledge, however, its usage is limited by the manual effort and guesswork required to write suitable prompts. To address this, we develop AutoPrompt, an automated method to create prompts for a diverse set of tasks, based on a gradient-guided search. Using AutoPrompt, we show that masked language models (MLMs) have an inherent capability to perform sentiment analysis and natural language inference without additional parameters or finetuning, sometimes achieving performance on par with recent state-of-the-art supervised models. We also show that our prompts elicit more accurate factual knowledge from MLMs than the manually created prompts on the LAMA benchmark, and that MLMs can be used as relation extractors more effectively than supervised relation extraction models. These results demonstrate that automatically generated prompts are a viable parameter-free alternative to existing probing methods, and as pretrained LMs become more sophisticated and capable, potentially a replacement for finetuning.</p>
                <p><strong>Cost:</strong> 0.017</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e5807.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e5807.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how the format or presentation of problems (e.g., prompt wording, structure, context, formatting) affects the performance of large language models (LLMs), including details of the formats used, tasks evaluated, models tested, performance results, and any explanations or comparisons.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>AutoPrompt-Sentiment-RoBERTa</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>AutoPrompt applied to sentiment analysis with RoBERTa</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>AutoPrompt automatically searches for shared trigger tokens and label-token sets to convert SST-2 sentiment instances into cloze-style prompts for a masked language model (RoBERTa), enabling classification via [MASK] token distributions without finetuning.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>RoBERTa</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>355M</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>SST-2 (Sentiment Analysis)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Binary sentiment classification of movie review sentences (Stanford Sentiment Treebank, SST-2).</td>
                        </tr>
                        <tr>
                            <td><strong>problem_format</strong></td>
                            <td>Fill-in-the-blank (cloze) prompts built from a template that inserts the original sentence plus a fixed set of learned trigger tokens and a single [MASK] token; predictions obtained by marginalizing the MLM's probability over an automatically selected set of label tokens.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_format</strong></td>
                            <td>Manual hand-crafted prompt (e.g., "{sentence} this movie was [P].")</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>accuracy: 91.4% (RoBERTa AutoPrompt test accuracy)</td>
                        </tr>
                        <tr>
                            <td><strong>performance_comparison</strong></td>
                            <td>accuracy: 85.2% (RoBERTa manual prompt test accuracy)</td>
                        </tr>
                        <tr>
                            <td><strong>format_effect_size</strong></td>
                            <td>+6.2 percentage points (AutoPrompt 91.4% vs manual 85.2%)</td>
                        </tr>
                        <tr>
                            <td><strong>format_effect_direction</strong></td>
                            <td>improved</td>
                        </tr>
                        <tr>
                            <td><strong>explanation_or_hypothesis</strong></td>
                            <td>Automatically searched lexical triggers better align with RoBERTa's learned token distributions and thus elicit relevant model behavior; manually constructed natural-language prompts can be suboptimal and models are sensitive to prompt phrasing and context.</td>
                        </tr>
                        <tr>
                            <td><strong>counterexample_or_null_result</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Eliciting Knowledge from Language Models Using Automatically Generated Prompts', 'publication_date_yy_mm': '2020-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e5807.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e5807.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how the format or presentation of problems (e.g., prompt wording, structure, context, formatting) affects the performance of large language models (LLMs), including details of the formats used, tasks evaluated, models tested, performance results, and any explanations or comparisons.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>AutoPrompt-Sentiment-BERT</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>AutoPrompt applied to sentiment analysis with BERT</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>AutoPrompt uses gradient-guided search to find trigger token sequences and label-token sets for BERT to perform SST-2 sentiment classification without any parameter finetuning.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>BERT</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>110M</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>SST-2 (Sentiment Analysis)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Binary sentiment classification of movie review sentences (Stanford Sentiment Treebank, SST-2).</td>
                        </tr>
                        <tr>
                            <td><strong>problem_format</strong></td>
                            <td>Cloze-format prompts combining the input sentence with a learned set of shared trigger tokens and a [MASK] token; class probabilities computed by summing mask probabilities over learned label-token sets.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_format</strong></td>
                            <td>Manual prompt baseline and standard finetuning</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>accuracy: 82.3% (BERT AutoPrompt test accuracy)</td>
                        </tr>
                        <tr>
                            <td><strong>performance_comparison</strong></td>
                            <td>accuracy: 63.2% (BERT manual prompt); accuracy: 93.5% (BERT finetuned, GLUE leaderboard)</td>
                        </tr>
                        <tr>
                            <td><strong>format_effect_size</strong></td>
                            <td>+19.1 percentage points vs manual prompt (82.3% vs 63.2%); -11.2 points vs finetuned (82.3% vs 93.5%)</td>
                        </tr>
                        <tr>
                            <td><strong>format_effect_direction</strong></td>
                            <td>improved relative to manual prompts; worse than full-data finetuning</td>
                        </tr>
                        <tr>
                            <td><strong>explanation_or_hypothesis</strong></td>
                            <td>AutoPrompt finds non-intuitive token sequences that amplify the correct label likelihoods in the pretrained LM; however, when abundant labeled data is available, finetuning produces higher absolute accuracy because it updates model parameters rather than relying on prompt-induced behavior.</td>
                        </tr>
                        <tr>
                            <td><strong>counterexample_or_null_result</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Eliciting Knowledge from Language Models Using Automatically Generated Prompts', 'publication_date_yy_mm': '2020-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e5807.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e5807.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how the format or presentation of problems (e.g., prompt wording, structure, context, formatting) affects the performance of large language models (LLMs), including details of the formats used, tasks evaluated, models tested, performance results, and any explanations or comparisons.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Prompt-vs-Finetune-LowData</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Effect of prompt presentation versus finetuning in low-data regimes</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Comparison between AutoPrompt-based prompting and conventional finetuning when only small numbers of labeled examples are available (experiments on SST-2 and SICK-E across subsets of size 10, 100, 1000).</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>BERT and RoBERTa</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>110M (BERT), 355M (RoBERTa)</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>SST-2 and SICK-E (low-data experiments)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Evaluation of classification accuracy when training data is limited (10, 100, 1000 examples) comparing AutoPrompt prompt search versus finetuning the full model.</td>
                        </tr>
                        <tr>
                            <td><strong>problem_format</strong></td>
                            <td>AutoPrompt learns prompts (trigger tokens + label token sets) from limited labeled data and evaluates via masked token prediction; compared to standard finetuning of the model on the same limited data.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_format</strong></td>
                            <td>Finetuning the entire model on the small labeled sets (standard supervised approach).</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>Qualitative: AutoPrompt outperforms finetuning for RoBERTa in the 100s–1000s example regime; for BERT, AutoPrompt and finetuning are comparable on average but finetuning shows worse worst-case behavior.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_comparison</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>format_effect_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>format_effect_direction</strong></td>
                            <td>improved for AutoPrompt in low-data (notably for RoBERTa); comparable for BERT on average, but AutoPrompt more robust worst-case</td>
                        </tr>
                        <tr>
                            <td><strong>explanation_or_hypothesis</strong></td>
                            <td>Prompting avoids the parameter-update barrier that finetuning must overcome with few examples; a properly designed prompt can convert the pretrained knowledge into task behavior without destabilizing the pretrained weights, making it more sample-efficient.</td>
                        </tr>
                        <tr>
                            <td><strong>counterexample_or_null_result</strong></td>
                            <td>With full data, finetuning achieves higher absolute accuracy (e.g., RoBERTa finetuned 96.7% on SST-2 vs AutoPrompt 91.4%), so prompts are not universally superior.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Eliciting Knowledge from Language Models Using Automatically Generated Prompts', 'publication_date_yy_mm': '2020-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e5807.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e5807.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how the format or presentation of problems (e.g., prompt wording, structure, context, formatting) affects the performance of large language models (LLMs), including details of the formats used, tasks evaluated, models tested, performance results, and any explanations or comparisons.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>AutoPrompt-NLI</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>AutoPrompt applied to Natural Language Inference (SICK-E)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>AutoPrompt constructs cloze-style prompts (templates with learned triggers and label-token sets) to probe whether pretrained MLMs encode knowledge sufficient for NLI without finetuning.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>BERT and RoBERTa</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>110M (BERT), 355M (RoBERTa)</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>SICK-E (Natural Language Inference)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Classify sentence pairs into entailment/contradiction/neutral (three-way), and also evaluate balanced 2-way and 3-way variants.</td>
                        </tr>
                        <tr>
                            <td><strong>problem_format</strong></td>
                            <td>Template combining premise and hypothesis plus learned trigger tokens and a [MASK] token; label-token sets are learned using a logistic classifier over [MASK] contextual embeddings.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_format</strong></td>
                            <td>Linear probing (logistic classifier on frozen LM representations) and standard finetuning</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>BERT AutoPrompt: standard 62.3% (test); 3-way 55.4%; 2-way 85.7%. RoBERTa AutoPrompt: standard 65.0%; 3-way 69.3%; 2-way 87.3%.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_comparison</strong></td>
                            <td>BERT finetuned: 86.7% (standard); BERT linear probing: 68.0% (standard); RoBERTa linear probing: 72.6% (standard). AutoPrompt outperforms linear probes on 3-way classification (e.g., RoBERTa AutoPrompt 69.3% vs linear 49.4% on unbiased 3-way).</td>
                        </tr>
                        <tr>
                            <td><strong>format_effect_size</strong></td>
                            <td>Approximately +20 percentage points vs linear probing on some 3-way NLI variants (RoBERTa AutoPrompt 69.3% vs RoBERTa linear probing 49.4%).</td>
                        </tr>
                        <tr>
                            <td><strong>format_effect_direction</strong></td>
                            <td>improved (AutoPrompt > linear probing), but finetuning still often higher</td>
                        </tr>
                        <tr>
                            <td><strong>explanation_or_hypothesis</strong></td>
                            <td>For some concepts (e.g., contradiction) AutoPrompt finds interpretable label tokens and prompt patterns that the model readily maps to labels; prompts can better exploit contextualized token-level predictions than simple linear probes in some cases.</td>
                        </tr>
                        <tr>
                            <td><strong>counterexample_or_null_result</strong></td>
                            <td>AutoPrompt struggles on some classes (e.g., neutral) where label tokens are less interpretable; for some NLI splits finetuned models remain superior.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Eliciting Knowledge from Language Models Using Automatically Generated Prompts', 'publication_date_yy_mm': '2020-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e5807.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e5807.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how the format or presentation of problems (e.g., prompt wording, structure, context, formatting) affects the performance of large language models (LLMs), including details of the formats used, tasks evaluated, models tested, performance results, and any explanations or comparisons.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>AutoPrompt-FactRetrieval-LAMA</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>AutoPrompt applied to LAMA fact retrieval (compare to LAMA and LPAQA)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>AutoPrompt learns relation-specific trigger tokens to convert (subject, relation, ?) triples into cloze prompts, substantially improving retrieval of factual objects from a masked LM compared to manual and mined prompt methods.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>BERT (primary comparison); RoBERTa (also evaluated)</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>110M (BERT), 355M (RoBERTa)</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>LAMA / T-REx fact retrieval (precision@k, MRR)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Cloze-style factual recall: given (subject, relation, ?) predict the object (entity) using a masked language model; metrics include mean reciprocal rank (MRR), precision@1 (P@1), and precision@10 (P@10).</td>
                        </tr>
                        <tr>
                            <td><strong>problem_format</strong></td>
                            <td>Template: "{sub}[T]...[T][P]." where [T] are relation-specific learned trigger tokens and [P] is the prediction mask; label tokens correspond to object entity tokens (no label-token learning needed when objects are entities).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_format</strong></td>
                            <td>Manual LAMA prompts (Petroni et al. 2019) and LPAQA (Jiang et al. 2020) mined/paraphrased prompt ensembles</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>BERT AutoPrompt (7 tokens) on Original LAMA: MRR 53.89, P@10 73.93, P@1 43.34. (T-REx split: P@1 ≈ 45.57).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_comparison</strong></td>
                            <td>LPAQA (Top1) P@1 34.10; LAMA manual P@1 31.10 (Original).</td>
                        </tr>
                        <tr>
                            <td><strong>format_effect_size</strong></td>
                            <td>+9.24 percentage points P@1 vs LPAQA (43.34% vs 34.10%); +12.24 pp vs LAMA manual (43.34% vs 31.10%).</td>
                        </tr>
                        <tr>
                            <td><strong>format_effect_direction</strong></td>
                            <td>improved</td>
                        </tr>
                        <tr>
                            <td><strong>explanation_or_hypothesis</strong></td>
                            <td>AutoPrompt's learned triggers produce non-grammatical but model-aligned contexts that increase the MLM's likelihood of predicting the correct object; some relations that are hard to express naturally benefit most from automatically found triggers. The method is robust to trigger length (5 vs 7 tokens yields small differences).</td>
                        </tr>
                        <tr>
                            <td><strong>counterexample_or_null_result</strong></td>
                            <td>RoBERTa underperformed BERT on this task despite being larger; prompts for RoBERTa sometimes included irrelevant tokens, showing that better prompts do not always yield better performance for larger models.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Eliciting Knowledge from Language Models Using Automatically Generated Prompts', 'publication_date_yy_mm': '2020-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e5807.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e5807.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how the format or presentation of problems (e.g., prompt wording, structure, context, formatting) affects the performance of large language models (LLMs), including details of the formats used, tasks evaluated, models tested, performance results, and any explanations or comparisons.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>AutoPrompt-RE-Perturb</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>AutoPrompt for Relation Extraction with perturbed-context stress test</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>AutoPrompt converts relation extraction sentences into prompted cloze queries to recover relation objects, and a synthetic perturbation experiment shows the extent to which high performance depends on memorized facts versus extraction from context.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>BERT and RoBERTa</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>110M (BERT), 355M (RoBERTa)</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Relation Extraction (T-REx context sentences)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Given a sentence mentioning subject and object and a target relation, predict the object; evaluated as precision@1 (P@1).</td>
                        </tr>
                        <tr>
                            <td><strong>problem_format</strong></td>
                            <td>Prompt constructed as "{sent}{sub}[T]...[T][P]." where [T] are relation-specific learned triggers and [P] is the [MASK] predicting the object token; evaluation uses context sentences from T-REx.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_format</strong></td>
                            <td>Manual LAMA/LPAQA prompts and a supervised relation extraction LSTM (Sorokin & Gurevych 2017); additionally, perturbed test set where true objects in context sentences are replaced with random other objects (to test reliance on memorization).</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>BERT AutoPrompt P@1: 90.73% on original context sentences; 56.43% on perturbed sentences. Supervised RE LSTM: ~57.95% (original) and 58.81% (perturbed) — largely unchanged.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_comparison</strong></td>
                            <td>BERT (LPAQA) P@1: 76.55% (original) and 30.79% (perturbed); BERT (LAMA) 69.06% (original) and 28.02% (perturbed).</td>
                        </tr>
                        <tr>
                            <td><strong>format_effect_size</strong></td>
                            <td>-34.30 percentage points when contexts are perturbed (90.73% -> 56.43%), indicating strong dependence on factual memorization for some predictions.</td>
                        </tr>
                        <tr>
                            <td><strong>format_effect_direction</strong></td>
                            <td>format exposes model reliance on background knowledge; performance reduced under perturbation</td>
                        </tr>
                        <tr>
                            <td><strong>explanation_or_hypothesis</strong></td>
                            <td>High original accuracy partially stems from the model's memorized factual knowledge rather than purely extracting from the provided sentence; when the facts in the sentence are artificially changed, AutoPrompt performance drops substantially while the supervised RE model remains stable, indicating different failure modes.</td>
                        </tr>
                        <tr>
                            <td><strong>counterexample_or_null_result</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Eliciting Knowledge from Language Models Using Automatically Generated Prompts', 'publication_date_yy_mm': '2020-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e5807.6">
                <h3 class="extraction-instance">Extracted Data Instance 6 (e5807.6)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how the format or presentation of problems (e.g., prompt wording, structure, context, formatting) affects the performance of large language models (LLMs), including details of the formats used, tasks evaluated, models tested, performance results, and any explanations or comparisons.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>AutoPrompt-Hyperparams</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Effects of AutoPrompt hyperparameters (label-set size and trigger length)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Analysis of how the size of the label-token set and the number of learned trigger tokens affect downstream prompted performance (studied primarily on sentiment analysis SST-2).</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>BERT and RoBERTa</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>110M (BERT), 355M (RoBERTa)</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>SST-2 (Sentiment Analysis) hyperparameter study</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Measure validation accuracy as a function of label-token set size |V_y| and trigger-token length |x_trig| during AutoPrompt search.</td>
                        </tr>
                        <tr>
                            <td><strong>problem_format</strong></td>
                            <td>Same cloze/prompt template; experiments vary |V_y| (number of label tokens per label) and |x_trig| (number of trigger tokens shared across prompts).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_format</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>Empirical trend: increasing label set size from 1 to 3 improved validation accuracy (~+5% for BERT, ~+10% for RoBERTa); changing trigger length (varied among 3–10) had little effect on accuracy.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_comparison</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>format_effect_size</strong></td>
                            <td>+5 percentage points (BERT) and +10 percentage points (RoBERTa) when increasing |V_y| from 1 to 3; negligible effect from increasing trigger length.</td>
                        </tr>
                        <tr>
                            <td><strong>format_effect_direction</strong></td>
                            <td>label set enlargement improved performance; trigger-length changes had no notable effect</td>
                        </tr>
                        <tr>
                            <td><strong>explanation_or_hypothesis</strong></td>
                            <td>Larger label-token sets allow the marginalization over multiple semantically-related tokens, capturing synonyms and distributed associations the LM uses to express a class; trigger length beyond a small number yields diminishing returns because the primary effect is lexical/contextual anchoring, not prompt length.</td>
                        </tr>
                        <tr>
                            <td><strong>counterexample_or_null_result</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Eliciting Knowledge from Language Models Using Automatically Generated Prompts', 'publication_date_yy_mm': '2020-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Language models as knowledge bases? <em>(Rating: 2)</em></li>
                <li>How can we know what language models know? <em>(Rating: 2)</em></li>
                <li>Universal adversarial triggers for attacking and analyzing NLP <em>(Rating: 1)</em></li>
                <li>Language models are few-shot learners <em>(Rating: 1)</em></li>
                <li>Exploiting cloze questions for few-shot text classification and natural language inference <em>(Rating: 1)</em></li>
                <li>BERT: pre-training of deep bidirectional transformers for language understanding <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-5807",
    "paper_id": "paper-b68b2e81ae2de647394ec05ee62ecf108bf2b50a",
    "extraction_schema_id": "extraction-schema-116",
    "extracted_data": [
        {
            "name_short": "AutoPrompt-Sentiment-RoBERTa",
            "name_full": "AutoPrompt applied to sentiment analysis with RoBERTa",
            "brief_description": "AutoPrompt automatically searches for shared trigger tokens and label-token sets to convert SST-2 sentiment instances into cloze-style prompts for a masked language model (RoBERTa), enabling classification via [MASK] token distributions without finetuning.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "RoBERTa",
            "model_size": "355M",
            "task_name": "SST-2 (Sentiment Analysis)",
            "task_description": "Binary sentiment classification of movie review sentences (Stanford Sentiment Treebank, SST-2).",
            "problem_format": "Fill-in-the-blank (cloze) prompts built from a template that inserts the original sentence plus a fixed set of learned trigger tokens and a single [MASK] token; predictions obtained by marginalizing the MLM's probability over an automatically selected set of label tokens.",
            "comparison_format": "Manual hand-crafted prompt (e.g., \"{sentence} this movie was [P].\")",
            "performance": "accuracy: 91.4% (RoBERTa AutoPrompt test accuracy)",
            "performance_comparison": "accuracy: 85.2% (RoBERTa manual prompt test accuracy)",
            "format_effect_size": "+6.2 percentage points (AutoPrompt 91.4% vs manual 85.2%)",
            "format_effect_direction": "improved",
            "explanation_or_hypothesis": "Automatically searched lexical triggers better align with RoBERTa's learned token distributions and thus elicit relevant model behavior; manually constructed natural-language prompts can be suboptimal and models are sensitive to prompt phrasing and context.",
            "counterexample_or_null_result": null,
            "uuid": "e5807.0",
            "source_info": {
                "paper_title": "Eliciting Knowledge from Language Models Using Automatically Generated Prompts",
                "publication_date_yy_mm": "2020-10"
            }
        },
        {
            "name_short": "AutoPrompt-Sentiment-BERT",
            "name_full": "AutoPrompt applied to sentiment analysis with BERT",
            "brief_description": "AutoPrompt uses gradient-guided search to find trigger token sequences and label-token sets for BERT to perform SST-2 sentiment classification without any parameter finetuning.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "BERT",
            "model_size": "110M",
            "task_name": "SST-2 (Sentiment Analysis)",
            "task_description": "Binary sentiment classification of movie review sentences (Stanford Sentiment Treebank, SST-2).",
            "problem_format": "Cloze-format prompts combining the input sentence with a learned set of shared trigger tokens and a [MASK] token; class probabilities computed by summing mask probabilities over learned label-token sets.",
            "comparison_format": "Manual prompt baseline and standard finetuning",
            "performance": "accuracy: 82.3% (BERT AutoPrompt test accuracy)",
            "performance_comparison": "accuracy: 63.2% (BERT manual prompt); accuracy: 93.5% (BERT finetuned, GLUE leaderboard)",
            "format_effect_size": "+19.1 percentage points vs manual prompt (82.3% vs 63.2%); -11.2 points vs finetuned (82.3% vs 93.5%)",
            "format_effect_direction": "improved relative to manual prompts; worse than full-data finetuning",
            "explanation_or_hypothesis": "AutoPrompt finds non-intuitive token sequences that amplify the correct label likelihoods in the pretrained LM; however, when abundant labeled data is available, finetuning produces higher absolute accuracy because it updates model parameters rather than relying on prompt-induced behavior.",
            "counterexample_or_null_result": null,
            "uuid": "e5807.1",
            "source_info": {
                "paper_title": "Eliciting Knowledge from Language Models Using Automatically Generated Prompts",
                "publication_date_yy_mm": "2020-10"
            }
        },
        {
            "name_short": "Prompt-vs-Finetune-LowData",
            "name_full": "Effect of prompt presentation versus finetuning in low-data regimes",
            "brief_description": "Comparison between AutoPrompt-based prompting and conventional finetuning when only small numbers of labeled examples are available (experiments on SST-2 and SICK-E across subsets of size 10, 100, 1000).",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "BERT and RoBERTa",
            "model_size": "110M (BERT), 355M (RoBERTa)",
            "task_name": "SST-2 and SICK-E (low-data experiments)",
            "task_description": "Evaluation of classification accuracy when training data is limited (10, 100, 1000 examples) comparing AutoPrompt prompt search versus finetuning the full model.",
            "problem_format": "AutoPrompt learns prompts (trigger tokens + label token sets) from limited labeled data and evaluates via masked token prediction; compared to standard finetuning of the model on the same limited data.",
            "comparison_format": "Finetuning the entire model on the small labeled sets (standard supervised approach).",
            "performance": "Qualitative: AutoPrompt outperforms finetuning for RoBERTa in the 100s–1000s example regime; for BERT, AutoPrompt and finetuning are comparable on average but finetuning shows worse worst-case behavior.",
            "performance_comparison": null,
            "format_effect_size": null,
            "format_effect_direction": "improved for AutoPrompt in low-data (notably for RoBERTa); comparable for BERT on average, but AutoPrompt more robust worst-case",
            "explanation_or_hypothesis": "Prompting avoids the parameter-update barrier that finetuning must overcome with few examples; a properly designed prompt can convert the pretrained knowledge into task behavior without destabilizing the pretrained weights, making it more sample-efficient.",
            "counterexample_or_null_result": "With full data, finetuning achieves higher absolute accuracy (e.g., RoBERTa finetuned 96.7% on SST-2 vs AutoPrompt 91.4%), so prompts are not universally superior.",
            "uuid": "e5807.2",
            "source_info": {
                "paper_title": "Eliciting Knowledge from Language Models Using Automatically Generated Prompts",
                "publication_date_yy_mm": "2020-10"
            }
        },
        {
            "name_short": "AutoPrompt-NLI",
            "name_full": "AutoPrompt applied to Natural Language Inference (SICK-E)",
            "brief_description": "AutoPrompt constructs cloze-style prompts (templates with learned triggers and label-token sets) to probe whether pretrained MLMs encode knowledge sufficient for NLI without finetuning.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "BERT and RoBERTa",
            "model_size": "110M (BERT), 355M (RoBERTa)",
            "task_name": "SICK-E (Natural Language Inference)",
            "task_description": "Classify sentence pairs into entailment/contradiction/neutral (three-way), and also evaluate balanced 2-way and 3-way variants.",
            "problem_format": "Template combining premise and hypothesis plus learned trigger tokens and a [MASK] token; label-token sets are learned using a logistic classifier over [MASK] contextual embeddings.",
            "comparison_format": "Linear probing (logistic classifier on frozen LM representations) and standard finetuning",
            "performance": "BERT AutoPrompt: standard 62.3% (test); 3-way 55.4%; 2-way 85.7%. RoBERTa AutoPrompt: standard 65.0%; 3-way 69.3%; 2-way 87.3%.",
            "performance_comparison": "BERT finetuned: 86.7% (standard); BERT linear probing: 68.0% (standard); RoBERTa linear probing: 72.6% (standard). AutoPrompt outperforms linear probes on 3-way classification (e.g., RoBERTa AutoPrompt 69.3% vs linear 49.4% on unbiased 3-way).",
            "format_effect_size": "Approximately +20 percentage points vs linear probing on some 3-way NLI variants (RoBERTa AutoPrompt 69.3% vs RoBERTa linear probing 49.4%).",
            "format_effect_direction": "improved (AutoPrompt &gt; linear probing), but finetuning still often higher",
            "explanation_or_hypothesis": "For some concepts (e.g., contradiction) AutoPrompt finds interpretable label tokens and prompt patterns that the model readily maps to labels; prompts can better exploit contextualized token-level predictions than simple linear probes in some cases.",
            "counterexample_or_null_result": "AutoPrompt struggles on some classes (e.g., neutral) where label tokens are less interpretable; for some NLI splits finetuned models remain superior.",
            "uuid": "e5807.3",
            "source_info": {
                "paper_title": "Eliciting Knowledge from Language Models Using Automatically Generated Prompts",
                "publication_date_yy_mm": "2020-10"
            }
        },
        {
            "name_short": "AutoPrompt-FactRetrieval-LAMA",
            "name_full": "AutoPrompt applied to LAMA fact retrieval (compare to LAMA and LPAQA)",
            "brief_description": "AutoPrompt learns relation-specific trigger tokens to convert (subject, relation, ?) triples into cloze prompts, substantially improving retrieval of factual objects from a masked LM compared to manual and mined prompt methods.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "BERT (primary comparison); RoBERTa (also evaluated)",
            "model_size": "110M (BERT), 355M (RoBERTa)",
            "task_name": "LAMA / T-REx fact retrieval (precision@k, MRR)",
            "task_description": "Cloze-style factual recall: given (subject, relation, ?) predict the object (entity) using a masked language model; metrics include mean reciprocal rank (MRR), precision@1 (P@1), and precision@10 (P@10).",
            "problem_format": "Template: \"{sub}[T]...[T][P].\" where [T] are relation-specific learned trigger tokens and [P] is the prediction mask; label tokens correspond to object entity tokens (no label-token learning needed when objects are entities).",
            "comparison_format": "Manual LAMA prompts (Petroni et al. 2019) and LPAQA (Jiang et al. 2020) mined/paraphrased prompt ensembles",
            "performance": "BERT AutoPrompt (7 tokens) on Original LAMA: MRR 53.89, P@10 73.93, P@1 43.34. (T-REx split: P@1 ≈ 45.57).",
            "performance_comparison": "LPAQA (Top1) P@1 34.10; LAMA manual P@1 31.10 (Original).",
            "format_effect_size": "+9.24 percentage points P@1 vs LPAQA (43.34% vs 34.10%); +12.24 pp vs LAMA manual (43.34% vs 31.10%).",
            "format_effect_direction": "improved",
            "explanation_or_hypothesis": "AutoPrompt's learned triggers produce non-grammatical but model-aligned contexts that increase the MLM's likelihood of predicting the correct object; some relations that are hard to express naturally benefit most from automatically found triggers. The method is robust to trigger length (5 vs 7 tokens yields small differences).",
            "counterexample_or_null_result": "RoBERTa underperformed BERT on this task despite being larger; prompts for RoBERTa sometimes included irrelevant tokens, showing that better prompts do not always yield better performance for larger models.",
            "uuid": "e5807.4",
            "source_info": {
                "paper_title": "Eliciting Knowledge from Language Models Using Automatically Generated Prompts",
                "publication_date_yy_mm": "2020-10"
            }
        },
        {
            "name_short": "AutoPrompt-RE-Perturb",
            "name_full": "AutoPrompt for Relation Extraction with perturbed-context stress test",
            "brief_description": "AutoPrompt converts relation extraction sentences into prompted cloze queries to recover relation objects, and a synthetic perturbation experiment shows the extent to which high performance depends on memorized facts versus extraction from context.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "BERT and RoBERTa",
            "model_size": "110M (BERT), 355M (RoBERTa)",
            "task_name": "Relation Extraction (T-REx context sentences)",
            "task_description": "Given a sentence mentioning subject and object and a target relation, predict the object; evaluated as precision@1 (P@1).",
            "problem_format": "Prompt constructed as \"{sent}{sub}[T]...[T][P].\" where [T] are relation-specific learned triggers and [P] is the [MASK] predicting the object token; evaluation uses context sentences from T-REx.",
            "comparison_format": "Manual LAMA/LPAQA prompts and a supervised relation extraction LSTM (Sorokin & Gurevych 2017); additionally, perturbed test set where true objects in context sentences are replaced with random other objects (to test reliance on memorization).",
            "performance": "BERT AutoPrompt P@1: 90.73% on original context sentences; 56.43% on perturbed sentences. Supervised RE LSTM: ~57.95% (original) and 58.81% (perturbed) — largely unchanged.",
            "performance_comparison": "BERT (LPAQA) P@1: 76.55% (original) and 30.79% (perturbed); BERT (LAMA) 69.06% (original) and 28.02% (perturbed).",
            "format_effect_size": "-34.30 percentage points when contexts are perturbed (90.73% -&gt; 56.43%), indicating strong dependence on factual memorization for some predictions.",
            "format_effect_direction": "format exposes model reliance on background knowledge; performance reduced under perturbation",
            "explanation_or_hypothesis": "High original accuracy partially stems from the model's memorized factual knowledge rather than purely extracting from the provided sentence; when the facts in the sentence are artificially changed, AutoPrompt performance drops substantially while the supervised RE model remains stable, indicating different failure modes.",
            "counterexample_or_null_result": null,
            "uuid": "e5807.5",
            "source_info": {
                "paper_title": "Eliciting Knowledge from Language Models Using Automatically Generated Prompts",
                "publication_date_yy_mm": "2020-10"
            }
        },
        {
            "name_short": "AutoPrompt-Hyperparams",
            "name_full": "Effects of AutoPrompt hyperparameters (label-set size and trigger length)",
            "brief_description": "Analysis of how the size of the label-token set and the number of learned trigger tokens affect downstream prompted performance (studied primarily on sentiment analysis SST-2).",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "BERT and RoBERTa",
            "model_size": "110M (BERT), 355M (RoBERTa)",
            "task_name": "SST-2 (Sentiment Analysis) hyperparameter study",
            "task_description": "Measure validation accuracy as a function of label-token set size |V_y| and trigger-token length |x_trig| during AutoPrompt search.",
            "problem_format": "Same cloze/prompt template; experiments vary |V_y| (number of label tokens per label) and |x_trig| (number of trigger tokens shared across prompts).",
            "comparison_format": null,
            "performance": "Empirical trend: increasing label set size from 1 to 3 improved validation accuracy (~+5% for BERT, ~+10% for RoBERTa); changing trigger length (varied among 3–10) had little effect on accuracy.",
            "performance_comparison": null,
            "format_effect_size": "+5 percentage points (BERT) and +10 percentage points (RoBERTa) when increasing |V_y| from 1 to 3; negligible effect from increasing trigger length.",
            "format_effect_direction": "label set enlargement improved performance; trigger-length changes had no notable effect",
            "explanation_or_hypothesis": "Larger label-token sets allow the marginalization over multiple semantically-related tokens, capturing synonyms and distributed associations the LM uses to express a class; trigger length beyond a small number yields diminishing returns because the primary effect is lexical/contextual anchoring, not prompt length.",
            "counterexample_or_null_result": null,
            "uuid": "e5807.6",
            "source_info": {
                "paper_title": "Eliciting Knowledge from Language Models Using Automatically Generated Prompts",
                "publication_date_yy_mm": "2020-10"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Language models as knowledge bases?",
            "rating": 2
        },
        {
            "paper_title": "How can we know what language models know?",
            "rating": 2
        },
        {
            "paper_title": "Universal adversarial triggers for attacking and analyzing NLP",
            "rating": 1
        },
        {
            "paper_title": "Language models are few-shot learners",
            "rating": 1
        },
        {
            "paper_title": "Exploiting cloze questions for few-shot text classification and natural language inference",
            "rating": 1
        },
        {
            "paper_title": "BERT: pre-training of deep bidirectional transformers for language understanding",
            "rating": 1
        }
    ],
    "cost": 0.0169585,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>AutoPrompt: Eliciting Knowledge from Language Models with Automatically Generated Prompts</h1>
<p>Taylor Shin ${ }^{\star} \diamond$ Yasaman Razeghi ${ }^{\star} \diamond$ Robert L. Logan IV ${ }^{\star} \diamond$ Eric Wallace<em> Sameer Singh</em><br>$\diamond$ University of California, Irvine *University of California, Berkeley<br>{tshin1, yrazeghi, rlogan, sameer}@uci.edu<br>ericwallace@berkeley.edu</p>
<h4>Abstract</h4>
<p>The remarkable success of pretrained language models has motivated the study of what kinds of knowledge these models learn during pretraining. Reformulating tasks as fill-in-the-blanks problems (e.g., cloze tests) is a natural approach for gauging such knowledge, however, its usage is limited by the manual effort and guesswork required to write suitable prompts. To address this, we develop AutoPrompt, an automated method to create prompts for a diverse set of tasks, based on a gradient-guided search. Using AutoPrompt, we show that masked language models (MLMs) have an inherent capability to perform sentiment analysis and natural language inference without additional parameters or finetuning, sometimes achieving performance on par with recent state-of-the-art supervised models. We also show that our prompts elicit more accurate factual knowledge from MLMs than the manually created prompts on the LAMA benchmark, and that MLMs can be used as relation extractors more effectively than supervised relation extraction models. These results demonstrate that automatically generated prompts are a viable parameter-free alternative to existing probing methods, and as pretrained LMs become more sophisticated and capable, potentially a replacement for finetuning.</p>
<h2>1 Introduction</h2>
<p>Pretrained language models (LMs) have had exceptional success when adapted to downstream tasks via finetuning (Peters et al., 2018; Devlin et al., 2019). Although it is clear that pretraining improves accuracy, it is difficult to determine whether the knowledge that finetuned LMs contain is learned during the pretraining or the finetuning process. How can we directly evaluate the knowl-</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup>edge present in pretrained LMs, be it linguistic, factual, commonsense, or task-specific?</p>
<p>Numerous techniques have been proposed to elicit such knowledge by analyzing pretrained LMs' internal representations. A common strategy is to use probing classifiers-shallow classifiers that predict certain attributes using an LMs' representations as features (Conneau et al., 2018; Liu et al., 2019). However, probing classifiers require additional learned parameters and are thus susceptible to false positives; high probing accuracy is not a sufficient condition to conclude that an LM contains a certain piece of knowledge (Hewitt and Liang, 2019; Voita and Titov, 2020). Attention visualization, another common technique, has a similar failure mode: attention scores may be correlated with, but not caused by the underlying target knowledge, leading to criticism against their use as explanations (Jain and Wallace, 2019; Wiegreffe and Pinter, 2019). Both probing and attention visualizations also struggle to evaluate knowledge that cannot be represented as simple token- or sequencelevel classification tasks.</p>
<p>A more direct approach for eliciting knowledge from these models, since they are language models after all, is prompting, i.e. converting tasks into a language model format. For example, Radford et al. (2019) frame summarization as a language modeling task by appending "TL;DR:" to the end of an article and then generating from an LM. Similarly, Petroni et al. (2019) manually reformulate a knowledge base completion task as a cloze test (i.e., a fill-in-the-blank problem). Compared to existing model analysis methods, prompting is noninvasive: it does not introduce large amounts of additional parameters or require direct inspection of a model's representations. Thus prompting provides a lower bound on what the model "knows", and is therefore a more useful analysis tool. However, prompting unfortunately requires manually</p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Illustration of AutoPrompt applied to probe a masked language model's (MLM's) ability to perform sentiment analysis. Each input, $\boldsymbol{x}<em _prompt="{prompt" _text="\text">{\text {inp }}$, is placed into a natural language prompt, $\boldsymbol{x}</em>}}$, which contains a single [MASK] token. The prompt is created using a template, $\lambda$, which combines the original input with a set of trigger tokens, $\boldsymbol{x<em _prompt="{prompt" _text="\text">{\text {trig }}$. The trigger tokens are shared across all inputs and determined using a gradient-based search (Section 2.2). Probabilities for each class label, $y$, are then obtained by marginalizing the MLM predictions, $p\left(\left[\right.\right.$ MASK] $\mid \boldsymbol{x}</em>$ ), over sets of automatically detected label tokens (Section 2.3).
crafting the context to feed into the model. Not only is this time consuming and non-intuitive for many tasks (e.g., textual entailment), more importantly, models are highly sensitive to this context: improperly-constructed contexts cause artificially low performance (Jiang et al., 2020). Overcoming the need to manually specify prompts would make prompting a more widely useful analysis tool.}</p>
<p>In this paper, we introduce AutoPrompt-an automated method for generating prompts for any task, illustrated in Figure 1. Given a task, e.g., sentiment analysis, AutoPrompt creates a prompt by combining the original task inputs (e.g. reviews) with a collection of trigger tokens according to a template. The same set of trigger tokens is used for all inputs, and is learned using a variant of the gradient-based search strategy proposed in Wallace et al. (2019). The LM predictions for the prompt are converted to class probabilities by marginalizing over a set of associated label tokens, which can either be learned or specified ahead of time, enabling the LM to be evaluated the same as one would any other classifier.</p>
<p>We validate the effectiveness of AutoPrompt in numerous experiments. First, we use AutoPrompt to construct prompts that test pretrained masked language models (MLMs) on sentiment analysis and natural language inference (NLI). Our tests reveal that, without any finetuning, MLMs perform well on both of these tasks-a properlyprompted RoBERTa achieves $91 \%$ accuracy on SST-2 (better than a finetuned ELMo model (Peters et al., 2018)), and $69 \%$ accuracy on a bal-
anced variant of the SICK-E dataset (Marelli et al., 2014). Next, we apply AutoPrompt to the fact retrieval tasks of LAMA (Petroni et al., 2019), where we are able to construct prompts that more effectively elicit MLM's factual knowledge than existing prompts generated using manual and corpusmining methods. Concretely, we achieve $43.3 \%$ precision-at-1, compared to the current best singleprompt result of $34.1 \%$ (Jiang et al., 2020). We also introduce a variant of this task, similar to relation extraction (RE), that tests whether MLMs can extract knowledge from a given piece of text. We show that MLMs can actually outperform existing RE models when context sentences with real facts are provided, however, they struggle when context sentences are artificially falsified.</p>
<p>Finally, although the goal of AutoPrompt is to analyze models, we find that it provides certain practical advantages over finetuning. First, AuTOPROMPT achieves higher average- and worstcase accuracy than finetuning in low-data regimes. Moreover, unlike finetuning, prompting LMs does not require large amounts of disk space to store model checkpoints; once a prompt is found, it can be used on off-the-shelf pretrained LMs. This is beneficial when serving models for multiple tasks.</p>
<h2>2 Overview of AutoPrompt</h2>
<p>A natural way to elicit knowledge from pretrained LMs is to pose tasks as fill-in-the-blank problems. However, writing prompts is not only time consuming, but it is not clear that the same phrasing will be effective for every model, nor is it clear what crite-</p>
<p>ria determine whether a particular phrasing the best to elicit the desired information. In light of this, we introduce AutoPrompt, a method that constructs customized prompts for a specific task and MLM of interest, to cause the MLMs to produce the desired knowledge. ${ }^{1}$ An illustration of AutoPrompt is provided in Figure 1. The prompt is constructed by taking the original task inputs-a collection of one or more sequences of tokens (e.g., the review in Figure 1)—and mapping them to a sequence of tokens using a template. In the following sections, we describe how AutoPrompt uses labeled training data to construct prompts, and how it uses the output of the MLM as a prediction for the task.</p>
<h3>2.1 Background and Notation</h3>
<p>For the purpose of prompt construction, we distinguish the original task inputs $\boldsymbol{x}<em _prompt="{prompt" _text="\text">{\text {inp }}$ (e.g., the review in Figure 1, "a real joy.") from the prompt $\boldsymbol{x}</em>}}$ (e.g., "a real joy. atmosphere alot dialogue Clone totally [MASK].") that is fed into the MLM. The mapping from $\boldsymbol{x<em _prompt="{prompt" _text="\text">{\text {inp }}$ to $\boldsymbol{x}</em>$ ) describing which tokens most likely fill in the blank.}}$ is performed using a template, $\lambda$. This template defines where each input sequence will be placed in the prompt, as well as the placement of any additional tokens. In particular, it must also define the placement of a special [MASK] token for the MLM to fill in (denoted by $[\mathrm{P}]$ in the template to distinguish it from other [MASK] tokens that might appear). Feeding the prompt into the MLM produces a probability distribution $p([\mathrm{MASK}] \mid \boldsymbol{x}_{\text {prompt }</p>
<p>If class labels naturally correspond to tokens in the vocabulary (e.g., entity names in knowledge base completion tasks), this distribution may be readily interpreted as a distribution over class labels. However, for tasks such as sentiment analysis, there may be a set of label tokens $\mathcal{V}_{y}$ that correspond to a particular label $y$. For example, in Figure 1, "Cris", "marvelous", and "philanthrop" all indicate positive sentiment. In this case, the class probability is obtained by marginalizing over the set of label tokens:</p>
<p>$$
p(y \mid \boldsymbol{x}<em _in="\in" _mathcal_V="\mathcal{V" w="w">{\text {prompt })}=\sum</em><em _prompt="{prompt" _text="\text">{y}} p(\left[\mathrm{MASK}\right]=w \mid \boldsymbol{x}</em>)
$$}</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<h3>2.2 Gradient-Based Prompt Search</h3>
<p>So far, we have shown how to reformulate a classification task as a language modeling task using prompts. Here, we propose a method for automatic prompt construction based on Wallace et al. (2019). The idea is to add a number of "trigger" tokens that are shared across all prompts (denoted by [T] in the example template in Figure 1). These tokens are initialized to [MASK] tokens, and then iteratively updated to maximize the label likelihood (Equation (1)) over batches of examples.</p>
<p>Formally, at each step, we compute a first-order approximation of the change in the log-likelihood that would be produced by swapping the $j$ th trigger token $x_{\text {trig }}^{(j)}$ with another token $w \in \mathcal{V}$. Then we identify a candidate set $\mathcal{V}_{\text {cand }}$ of the top- $k$ tokens estimated to cause the greatest increase:</p>
<p>$$
\mathcal{V}<em _in="{in" _text="\text">{\text {cand }}=\underset{w \in \mathcal{V}}{\operatorname{top}-k}\left[\boldsymbol{w}</em>)\right]
$$}}^{T} \nabla \log p(y \mid \boldsymbol{x}_{\text {prompt }</p>
<p>where $\boldsymbol{w}<em _text="\text" _trig="{trig">{\text {in }}$ is the input embedding of $w$, and the gradient is taken with respect to the input embedding of $x</em>$. Note that computing this candidate set is roughly as expensive as a single forward pass and backward pass of the model (the dot-products require the same amount of multiplications as computing the LM output projection). For each candidate in this set, we then re-evaluate Equation (1) on the updated prompt, and retain the prompt with the highest probability in the next step-this requires $k$ forward passes of the model. An example prompt produced by this method for the task of sentiment analysis is shown in Figure 1.}}^{(j)</p>
<h3>2.3 Automating Label Token Selection</h3>
<p>While in some settings the choice of label tokens is obvious (e.g., when class labels directly correspond to words in the vocabulary), it is less clear what label tokens are appropriate for problems involving more abstract class labels (e.g., NLI). In this section, we develop a general two-step approach to automate the selection of the sets of label tokens $\mathcal{V}_{y}$. In the first step, we train a logistic classifier to predict the class label using the contextualized embedding of the [MASK] token as input:</p>
<p>$$
\boldsymbol{h}=\operatorname{Transformer}_{\mathrm{enc}}(\hat{\boldsymbol{x}})
$$</p>
<p>We write the output of this classifier as:</p>
<p>$$
p\left(y \mid \boldsymbol{h}^{(i)}\right) \propto \exp \left(\boldsymbol{h}^{(i)} \cdot \boldsymbol{y}+\beta_{y}\right)
$$</p>
<p>where $\boldsymbol{y}$ and $\beta_{y}$ are the learned weight and bias terms for the label $y$, and $i$ represents the index of the [MASK] token.</p>
<p>In the second step, we substitute $\boldsymbol{h}^{(i)}$ with the MLM's output word embeddings $\boldsymbol{w}<em _out="{out" _text="\text">{\text {out }}$ to obtain a score $s(y, w)=p(y \mid \boldsymbol{w}</em>}})$. Intuitively, because $\boldsymbol{w<em w="w">{\text {out }} \cdot \boldsymbol{h}$ and $\boldsymbol{y} \cdot \boldsymbol{h}$ are large for words and labels that are relevant to a particular context, $s</em>} \propto \exp \left(\boldsymbol{w<em y="y">{\text {out }} \cdot \boldsymbol{y}+\beta</em>\right)$ should be large for words that are typically associated with a given label. The sets of label tokens are then constructed from the $k$-highest scoring words:</p>
<p>$$
\mathcal{V}_{y}=\underset{w \in \mathcal{V}}{\operatorname{top}-k}[s(y, w)]
$$</p>
<h3>2.4 Relation to Other Prompting Methods</h3>
<p>Our work fits into a body of work that probes language model's knowledge via prompts. Previous works have used manually defined prompts to study an LM's ability to perform: commonsense reasoning (Trinh and Le, 2018; Kwon et al., 2019; Shwartz et al., 2020), question answering (Lewis et al., 2019), fact recall (Petroni et al., 2019; Jiang et al., 2020; Bouraoui et al., 2019), summarization (Radford et al., 2019), and other supervised tasks (Brown et al., 2020). Schick and Schütze (2020) use manually constructed prompts in conjunction with semi-supervised learning for fewshot learning. We instead automatically create prompts for any task, which leads to higher accuracy and opens up new phenomena to analyze.</p>
<h3>2.5 Evaluation Setup</h3>
<p>In the following sections, we apply AutoPrompt to probe BERT ${ }_{\text {BASE }}{ }^{2}$ (110M parameters) and RoBERTaLARGE's ( 355 M parameters) knowledge of the following tasks: sentiment analysis, natural language inference (NLI), fact retrieval, and relation extraction. We use the PyTorch implementations and pretrained weights provided by the transformers Python library (Wolf et al., 2019). For sentiment analysis and NLI, we find label tokens using the logistic-regression-based heuristic described in Section 2.3. For fact retrieval and relation extraction, we skip this step as the labels (entities) directly correspond to tokens in the vocabulary. For all tasks, we perform the prompt search described in Section 2.2 for multiple iterations. In each iteration, we use a batch of training</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup>data to identify the candidate set $\mathcal{V}_{\text {cand }}$ of replacement trigger tokens. We then evaluate the label likelihoods of the updated prompts on a separate batch of data, and we retain the best trigger token in the next iteration of the search. At the end of every iteration, we measure the label likelihood on withheld development data, and return the best prompt found during the entire search as the final output. Performance is evaluated using the appropriate task-specific metrics-e.g., accuracy for sentiment analysis and NLI, and precision@ $k$ for fact retrieval-on a separate withheld test set.</p>
<p>Our AutoPrompt implementation is publicly available at http://ucinlp.github.io/autoprompt, and supports prompt generation for pretrained models in the HuggingFace transformers library (Wolf et al., 2019) on arbitrary datasets.</p>
<h2>3 Sentiment Analysis</h2>
<p>Sentiment analysis is a fundamental task in NLP, both for natural language understanding research and real-world applications. It is also difficult to probe the extent to which MLMs understand sentiment without finetuning.</p>
<p>Setup We apply our method to convert instances from the binary Stanford Sentiment Treebank (Socher et al., 2013, SST-2) into prompts, using the standard train/test splits. We find label tokens using a prompt based on the template in Table 3. For our gradient-based prompt search, we perform a grid search over the following hyperparameters: $\left|\mathcal{V}<em y="y">{\text {cand }}\right| \in{10,100},\left|\mathcal{V}</em>$ All prompts are initialized with the same template used to find the label set.}\right| \in{1,3,5}$, $\left|\boldsymbol{x}_{\text {trig }}\right| \in[3,6] .^{3</p>
<p>We also construct a prompt manually (before automated prompts are generated, to avoid bias) based on the intuition that SST-2 is comprised of movie reviews. We use "{sentence} this movie was [P]." as the template, and use "terrible" and "fantastic" for the negative and positive label tokens, respectively.</p>
<p>Results We show results in Table 1, along with reference scores from the GLUE (Wang et al., 2019) SST-2 leaderboard, and scores for a linear probe trained over the elementwise average of the LM token representations. Prompts generated by AutoPrompt reveal that both BERT and RoBERTa have a strong knowledge of sentiment analysis: without any finetuning, BERT per-</p>
<p><sup id="fnref:1"><a class="footnote-ref" href="#fn:1">2</a></sup></p>
<table>
<thead>
<tr>
<th>Model</th>
<th>Dev</th>
<th>Test</th>
</tr>
</thead>
<tbody>
<tr>
<td>BiLSTM</td>
<td>-</td>
<td>$82.8^{\dagger}$</td>
</tr>
<tr>
<td>BiLSTM + ELMo</td>
<td>-</td>
<td>$89.3^{\dagger}$</td>
</tr>
<tr>
<td>BERT (linear probing)</td>
<td>85.2</td>
<td>83.4</td>
</tr>
<tr>
<td>BERT (finetuned)</td>
<td>-</td>
<td>$93.5^{\dagger}$</td>
</tr>
<tr>
<td>RoBERTa (linear probing)</td>
<td>87.9</td>
<td>88.8</td>
</tr>
<tr>
<td>RoBERTa (finetuned)</td>
<td>-</td>
<td>$96.7^{\dagger}$</td>
</tr>
<tr>
<td>BERT (manual)</td>
<td>63.2</td>
<td>63.2</td>
</tr>
<tr>
<td>BERT (AUTOPROMPT)</td>
<td>80.9</td>
<td>82.3</td>
</tr>
<tr>
<td>RoBERTa (manual)</td>
<td>85.3</td>
<td>85.2</td>
</tr>
<tr>
<td>RoBERTa (AUTOPROMPT)</td>
<td>91.2</td>
<td>91.4</td>
</tr>
</tbody>
</table>
<p>Table 1: Sentiment Analysis performance on the SST2 test set of supervised classifiers (top) and fill-in-theblank MLMs (bottom). Scores marked with $\dagger$ are from the GLUE leaderboard: http://gluebenchmark.com/ leaderboard.
forms comparably to a supervised BiLSTM, and RoBERTa achieves an accuracy on-par with finetuned BERT and ELMo models. In addition, we observe that our automatically constructed prompts are more effective than manual prompts, and that they are difficult to construct using human intuition: the best template for RoBERTa is " ${$ sentence $}$ atmosphere alot dialogue Clone totally [P]." We include results on the effect of the AutoPrompt hyperparameters in Appendix A.</p>
<p>Accuracy in Low-Data Settings Although the goal of AutoPrompt is to probe a model's knowledge, we also find that it can achieve high accuracy in the low-data regime. In particular, we measure the development set accuracy of AutoPrompt prompts when using random subsets of 10,100 , and 1000 instances from the training data. We run our prompt search with $\left|\boldsymbol{x}<em y="y">{\text {trig }}\right|=10,\left|\mathcal{V}</em>\right|=10$. We compare to the performance of BERT and RoBERTa finetuned on the same data. We repeat this experiment 10 times on different randomly sampled sets of data (and seeds for the finetuned models), and display the best-case, worstcase, and average performance in Figure 2.}\right|=3$, and $\left|\mathcal{V}_{\text {cand }</p>
<p>We observe that prompts and finetuning perform comparably on average for BERT, however, in the worst-case, finetuning can fail in the lowdata regime (consistent with Dodge et al. 2020). For RoBERTa, AutoPrompt performs substantially better than finetuning when there are 100s to 1000s of training examples. This excellence in the low-data regime is an interesting phenomenon, and suggests that there is an initial barrier that MLMs must surmount when they are converted to finetuned classifiers that is not encountered when the task is presented as masked language modeling.
<img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: Effect of Training Data on sentiment analysis and NLI for AutoPrompt vs. finetuning. X-axis is the number of data points used during training. Error bars plot the max. and min. accuracies observed over 10 independent runs. In the low data regime, AutoPrompt outperforms finetuning for RoBERTa.</p>
<h2>4 Natural Language Inference</h2>
<p>To evaluate the semantic understanding of MLMs, we experiment on Natural Language Inference (NLI). NLI is crucial in many tasks such as reading comprehension and commonsense reasoning (Bowman et al., 2015), and it is used as a common benchmark for language understanding.</p>
<p>Setup We use the entailment task from the SICK dataset (Marelli et al., 2014, SICK-E) which consists of around 10,000 pairs of human-annotated sentences labeled as entailment, contradiction, and neutral. The standard dataset is biased toward the neutral class which represent $56.7 \%$ of instances. We also experiment on an unbiased variant with 2-way classification of contradiction vs. entailment (2-way), as well as an unbiased 3-way clas-</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: center;">SICK-E Datasets</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;">standard</td>
<td style="text-align: center;">3-way</td>
<td style="text-align: center;">2-way</td>
</tr>
<tr>
<td style="text-align: left;">Majority</td>
<td style="text-align: center;">56.7</td>
<td style="text-align: center;">33.3</td>
<td style="text-align: center;">50.0</td>
</tr>
<tr>
<td style="text-align: left;">BERT (finetuned)</td>
<td style="text-align: center;">86.7</td>
<td style="text-align: center;">84.0</td>
<td style="text-align: center;">95.6</td>
</tr>
<tr>
<td style="text-align: left;">BERT (linear probing)</td>
<td style="text-align: center;">68.0</td>
<td style="text-align: center;">49.5</td>
<td style="text-align: center;">91.9</td>
</tr>
<tr>
<td style="text-align: left;">RoBERTa (linear probing)</td>
<td style="text-align: center;">72.6</td>
<td style="text-align: center;">49.4</td>
<td style="text-align: center;">91.1</td>
</tr>
<tr>
<td style="text-align: left;">BERT (AUTOPROMPT)</td>
<td style="text-align: center;">62.3</td>
<td style="text-align: center;">55.4</td>
<td style="text-align: center;">85.7</td>
</tr>
<tr>
<td style="text-align: left;">RoBERTa (AUTOPROMPT)</td>
<td style="text-align: center;">65.0</td>
<td style="text-align: center;">69.3</td>
<td style="text-align: center;">87.3</td>
</tr>
</tbody>
</table>
<p>Table 2: Natural Language Inference performance on the SICK-E test set and variants. (Top) Baseline classifiers. (Bottom) Fill-in-the-blank MLMs.
sification variant (3-way). The template used for AutoPrompt is provided in Table 3. We search over the following parameters: $\left|\mathcal{V}<em y="y">{\text {cand }}\right| \in{10,50}$, $\left|\mathcal{V}</em>\right| \in[1,5]$, and choose the best prompt according to development set accuracy.}\right| \in{1,3,5,10},\left|\boldsymbol{x}_{\text {trig }</p>
<p>Results Table 2 shows that AutoPrompt considerably outperforms the majority baseline in all experiments. For example, on the 2-way SICK-E dataset, AutoPrompt is comparable to a supervised finetuned BERT. We also test linear probeslinear classifiers trained on top of frozen MLM representations with average pooling - and find AutoPrompt has comparable or higher accuracy, despite linear probes being susceptible to false positives. Overall, these results demonstrate that both BERT and RoBERTa have some inherent knowledge of natural language inference.</p>
<p>We also examine the efficacy of AutoPrompt in the low-data regime (using the same procedure as SST-2) on the unbiased 3-way SICK-E data. The results in Figure 2 show that AutoPrompt performs on par with finetuned BERT and significantly better than finetuned RoBERTa in low data settings.</p>
<p>MLMs Excel on Contradiction We find that the label tokens are more interpretable for contradiction compared to entailment or neutral (examples in Table 3). We investigate if this hurts the model performance on entailment and neutral classes. We measure the precision for each label in the 3-way balanced SICK-E dataset. BERT achieves $74.9 \%, 54.4 \%$, and $36.8 \%$ precision for contradiction, entailment, and neutral cases, respectively, while RoBERTa obtains $84.9 \%, 65.1 \%$, and $57.3 \%$. These results suggest that AutoPrompt may be more accurate for concepts that can be easily expressed using natural label tokens.</p>
<h2>5 Fact Retrieval</h2>
<p>An important question is whether pretrained MLMs know facts about real-world entities. The LAMA dataset (Petroni et al., 2019) evaluates this using cloze tests that consist of (sub, rel, obj) triples, e.g. (Obama, bornIn, Hawaii), and manually created prompts with missing objects, e.g. "Obama was born in [MASK].". LPAQA (Jiang et al., 2020) extends this idea by systematically creating prompts that are generated by mining Wikipedia, paraphrasing, and crowdsourcing. In this section, we use the same cloze-style setup but automatically generate prompts in order to better evaluate the factual knowledge of MLMs. We compare our approach against LAMA and LPAQA, which are explicitly designed for the task of fact retrieval.</p>
<p>Setup We reformulate fact retrieval by mapping (sub,rel,obj) triples to a prompt using the template " $[$ sub $][\mathrm{T}] \ldots[\mathrm{T}][\mathrm{P}] . "$, where the trigger tokens are specific to the relation rel and the correct object obj is the label token. We use the original test set from LAMA (Petroni et al., 2019), henceforth Original. To collect training data for AutoPrompt, we gather at most 1000 facts for each of the 41 relations in LAMA from the T-REx dataset (ElSahar et al., 2018). For the relations that still have less than 1000 samples, we gather extra facts straight from Wikidata. We ensure that none of the T-REx triples are present in the test set, and we split the data 80-20 into train and development sets. Moreover, because the collected T-REx data is from a slightly different distribution than the LAMA test set, we also consider a separate evaluation where we split the T-REx triples into a 60-20-20 train/dev/test split and evaluate on the test set. This $T$-REx dataset is used to measure the performance of our prompts when the train and test data is from the same distribution.</p>
<p>We use AutoPrompt with 5 or 7 tokens, and select the search parameters using the T-REx development set. We prevent proper nouns and tokens that appear as gold objects in the training data from being selected as trigger tokens. This is done to prevent AutoPrompt from "cheating" by embedding common answers inside the prompt. To evaluate, we observe the rank of the true object in label token distribution of the MLM, and use standard ranking metrics: mean reciprocal rank (MRR), precision-at-1 (P@1), and precision-at-10 (P@10).</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Task</th>
<th style="text-align: center;">Prompt Template</th>
<th style="text-align: center;">Prompt found by AutoPrompt</th>
<th style="text-align: center;">Label Tokens</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Sentiment <br> Analysis</td>
<td style="text-align: center;">{sentence} [T]...[T] [P].</td>
<td style="text-align: center;">unflinchingly bleak and desperate Writing academicswhere overseas will appear [MASK].</td>
<td style="text-align: center;">pos: partnership, extraordinary, ##bla neg: worse, persisted, unconstitutional</td>
</tr>
<tr>
<td style="text-align: center;">NLI</td>
<td style="text-align: center;">{prem}[P][T]...[T]{hyp}</td>
<td style="text-align: center;">Two dogs are wrestling and hugging [MASK] concretepathic workplace There is no dog wrestling and hugging</td>
<td style="text-align: center;">con: Nobody, nobody, nor ent: ##found, ##ways, Agency neu: ##ponents, ##lary, ##uated</td>
</tr>
<tr>
<td style="text-align: center;">Fact <br> Retrieval</td>
<td style="text-align: center;">X plays Y music {sub}[T]...[T][P].</td>
<td style="text-align: center;">Hall Overton fireplacemade antique son alto [MASK].</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Relation <br> Extraction</td>
<td style="text-align: center;">$X$ is a $Y$ by profession {sent}{sub}[T]...[T][P].</td>
<td style="text-align: center;">Leonard Wood (born February 4, 1942) is a former Canadian politician. <br> Leonard Wood gymnasium brotherdicative himself another [MASK].</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>Table 3: Example Prompts by AutoPrompt for each task. On the left, we show the prompt template, which combines the input, a number of trigger tokens [T], and a prediction token [P]. For classification tasks (sentiment analysis and NLI), we make predictions by summing the model's probability for a number of automatically selected label tokens. For fact retrieval and relation extraction, we take the most likely token predicted by the model.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Prompt Type</th>
<th style="text-align: center;">Original</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">T-REx</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">MRR</td>
<td style="text-align: center;">P@10</td>
<td style="text-align: center;">P@1</td>
<td style="text-align: center;">MRR</td>
<td style="text-align: center;">P@10</td>
<td style="text-align: center;">P@1</td>
<td style="text-align: center;">Model</td>
<td style="text-align: center;">MRR</td>
<td style="text-align: center;">P@10</td>
</tr>
<tr>
<td style="text-align: center;">LAMA</td>
<td style="text-align: center;">40.27</td>
<td style="text-align: center;">59.49</td>
<td style="text-align: center;">31.10</td>
<td style="text-align: center;">35.79</td>
<td style="text-align: center;">54.29</td>
<td style="text-align: center;">26.38</td>
<td style="text-align: center;">BERT</td>
<td style="text-align: center;">55.22</td>
<td style="text-align: center;">74.01</td>
</tr>
<tr>
<td style="text-align: center;">LPAQA (Top1)</td>
<td style="text-align: center;">43.57</td>
<td style="text-align: center;">62.03</td>
<td style="text-align: center;">34.10</td>
<td style="text-align: center;">39.86</td>
<td style="text-align: center;">57.27</td>
<td style="text-align: center;">31.16</td>
<td style="text-align: center;">RoBERTa</td>
<td style="text-align: center;">49.90</td>
<td style="text-align: center;">68.34</td>
</tr>
<tr>
<td style="text-align: center;">AutoPrompt 5 Tokens</td>
<td style="text-align: center;">53.06</td>
<td style="text-align: center;">72.17</td>
<td style="text-align: center;">42.94</td>
<td style="text-align: center;">54.42</td>
<td style="text-align: center;">70.80</td>
<td style="text-align: center;">45.40</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">AutoPrompt 7 Tokens</td>
<td style="text-align: center;">53.89</td>
<td style="text-align: center;">73.93</td>
<td style="text-align: center;">43.34</td>
<td style="text-align: center;">54.89</td>
<td style="text-align: center;">72.02</td>
<td style="text-align: center;">45.57</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>Table 4: Factual Retrieval: On the left, we evaluate BERT on fact retrieval using the Original LAMA dataset from Petroni et al. (2019). For all three metrics (mean reciprocal rank, mean precision-at-10 (P@10), and mean precision-at-1(P@1)), AutoPrompt significantly outperforms past prompting methods. We also report results on a $T-R E x$ version of the data (see text for details). On the right, we compare BERT versus RoBERTa on a subset of the LAMA data using AutoPrompt with 5 tokens.</p>
<p>Results Table 4 shows the performance of MLMs with different prompting methods, and we show qualitative examples in Table 3 and in Appendix C. Prompts generated using AutoPrompt can extract factual knowledge from BERT more effectively than their manual and mined counterparts: we improve P@1 by up to 12 points. Moreover, despite AutoPrompt using only one prompt per relation, it still outperforms LPAQA's ensemble method (which averages predictions for up to 30 prompts) by approximately 4 points. Using 7 trigger tokens achieves slightly higher scores than 5 trigger tokens, although the difference is not substantial. This indicates that our approach is stable to the choice of trigger length, which is consistent with our sentiment analysis results. Overall, these results show that AutoPrompt can retrieve facts more effectively than past prompting methods, thus demonstrating that BERT contains more factual knowledge than previously estimated.</p>
<p>Relation Breakdown We also provide a detailed breakdown of the prompts found by Petroni et al. (2019) and AutoPrompt, and their associated accuracies in Appendix C, Table 7. Manual prompts are competitive when the prompt is easy to specify, e.g., the prompt "was born in" for the PLACE OF BIRTH relation. On the other hand, AutoPrompt performs especially well for relations that are difficult to specify in a natural language prompt. For example, Petroni et al. (2019)'s prompt for the POSITION PLAYED ON TEAM relation is "{sub} plays in [MASK] position", which is not as specific as the relation requires. Although the prompt from AuTOPrompt is not grammatical ("{sub} ediatric striker ice baseman defensive {obj}"), it does contain tokens that are directly related to sports.</p>
<p>BERT outperforms RoBERTa We finally directly compare BERT and RoBERTa. To do so, we subsample the LAMA test set to consist of examples where the object is a single token for both</p>
<p>BERT and RoBERTa (Original-RoBERTa). ${ }^{4}$ BERT actually slightly outperforms RoBERTa, and we find that the prompts generated for RoBERTa tend to contain more irrelevant words (see Appendix C, Table 7). For example, the prompt generated by RoBERTa for the Plays instrument relation contains words such as "Trump" and symbols such as "," ()," for the POSITION PLAYED ON TEAM relation. It is surprising that RoBERTa does not perform better than BERT, and it is worthy of investigating this further in future work. Additionally, recall that prompting is a lower bound on a model's knowledge: the lower relative performance does not mean that the model actually knows less.</p>
<h2>6 Relation Extraction</h2>
<p>Apart from evaluating whether MLMs know facts, it is also important to evaluate whether they can extract knowledge from text. In this section, we use the task of relation extraction (RE)-to identify how entities are related in a given sentence-an important task in information extraction. We create RE prompts in a similar fashion as fact retrieval: for a given triple ${\operatorname{subj}$, rel, obj $}$ and sentence that expresses this relation, we construct a prompt as " ${$ sent $}{\operatorname{sub}}[\mathrm{T}]...[\mathrm{T}][\mathrm{P}]$.", where the trigger tokens are specific to the relation, and label token is the correct object obj (see Table 3 for an example).</p>
<p>Setup We use the T-Rex dataset for RE because each T-REx fact comes with context sentences that mention the subject and object surface forms. We compare AutoPrompt to LAMA and LPAQA (their prompts are still useful here), as well as a recent supervised relation extraction model (Sorokin and Gurevych, 2017) that was also used by Petroni et al. (2019). To make the evaluation fair for the supervised RE model, we modify the standard RE evaluation. We give the model credit as long as it does not predict a different relation for the subject and object, i.e. we ignore the "no relation" prediction and all other relations. We also drop all sentences from evaluation for which the model's named entity extractor failed to identify the subject and the object as entities. See Appendix B for further details. For the evaluation of all systems, we treat a prediction as correct if it is either the canonical version of the object (e.g., "USA") or the rendered surface form (e.g., "American") for any of the context sentences in a given triple.</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup>Results Table 5 shows the results for BERT and RoBERTa. MLMs can extract relational information more effectively than the supervised RE model, providing up to a $33 \%$ increase on the task when using AutoPrompt. RoBERTa also outperforms the supervised RE model, although it is worse than BERT (likely for similar reasons as we outline in Section 5). For both BERT and RoBERTa, we notice that the trigger tokens consist of words related to their corresponding relations (see Appendix D, Table 8 for full list), e.g. RoBERTa selects "defy trademarks of namesake manufacturer" for relation MANUFACTURER/PRODUCER OF PRODUCT.</p>
<p>Perturbed Sentence Evaluation A possible explanation for the strong results of MLMs in the RE setting is that they may already know many of the relations. Thus, they may directly predict the objects instead of extracting them. To separate this effect, we synthetically perturb the relation extraction dataset by replacing each object in the test data with a random other object and making the same change to the prompt. For example, "Ryo Kase (born November 9, 1974 in Yokohama $\rightarrow$ Yorkshire) is a Japanese actor" where Ryo Kase is the subject, Yokohama is the original object, and Yorkshire is the new object. We regenerate the prompts using the perturbed version of the data.</p>
<p>The accuracy of the RE model does not change significantly on the perturbed data (Table 5), however, the accuracy of the MLMs decreases significantly. This indicates that a significant portion of MLM accuracy comes from background information rather than relation extraction. Nevertheless, our prompts for BERT outperform their LAMA and LPAQA counterparts, which provides further evidence that AutoPrompt produces better probes.</p>
<h2>7 Discussion</h2>
<h2>Prompting as an Alternative to Finetuning</h2>
<p>The goal of prompting a language model is to probe the knowledge that the model acquired from pretraining. Nevertheless, prompting has some practical advantages over finetuning for solving realworld tasks. First, as shown in Section 3, prompts generated using AutoPrompt can achieve higher accuracy than finetuning in the low-data regime. Moreover, prompting has advantages over finetuning when trying to solve many different tasks (e.g., the many users of the OpenAI GPT-3 API Brown et al. 2020). In particular, finetuning requires storing large language model checkpoints for each in-</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: center;">Original</th>
<th style="text-align: center;">Perturbed</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Supervised RE LSTM</td>
<td style="text-align: center;">57.95</td>
<td style="text-align: center;">58.81</td>
</tr>
<tr>
<td style="text-align: left;">BERT (LAMA)</td>
<td style="text-align: center;">69.06</td>
<td style="text-align: center;">28.02</td>
</tr>
<tr>
<td style="text-align: left;">BERT (LPAQA)</td>
<td style="text-align: center;">76.55</td>
<td style="text-align: center;">30.79</td>
</tr>
<tr>
<td style="text-align: left;">BERT (AUTOPROMPT)</td>
<td style="text-align: center;">90.73</td>
<td style="text-align: center;">56.43</td>
</tr>
<tr>
<td style="text-align: left;">RoBERTa (AUTOPROMPT)</td>
<td style="text-align: center;">60.33</td>
<td style="text-align: center;">28.95</td>
</tr>
</tbody>
</table>
<p>Table 5: Relation Extraction: We use prompts to test pretrained MLMs on relation extraction. Compared to a state-of-the-art LSTM model from 2017, MLMs have higher mean precision-at-1 (P@1), especially when using prompts from AutoPrompt. We also test models on sentences that have been edited to contain incorrect facts. The accuracy of MLMs drops significantly on these sentences, indicating that their high performance stems from their factual knowledge.
dividual task, and, more importantly, it drastically increases system cost and complexity because it requires deploying many different models at the same time. Prompting alleviates both of these issues. We can simply store the prompts for each individual task, and use the same pretrained model for inputs of any of the tasks.</p>
<p>Limitations of Prompting There are certain phenomena that are difficult to elicit from pretrained language models via prompts. In our preliminary evaluation on datasets such as QQP (Iyer et al., 2017) and RTE (Dagan et al., 2005), prompts generated manually and with AutoPrompt did not perform considerably better than chance. However, we cannot conclude that BERT does not know paraphrasing or entailment from these results. In general, different probing methods have different tasks and phenomena they are suitable for: AutoPrompt makes prompt-based probes more generally applicable, but, it still remains just one tool in the toolbox of the interpretability researcher.</p>
<p>Limitations of AutoPrompt One downside of AutoPrompt is that it requires labeled training data. Although this is also required for other probing techniques (e.g., linear probing classifiers), manual prompts rely on domain/language insights instead of labeled data. Compared to human-designed prompts, AutoPrompt generated prompts lack interpretability, which is similar to other probing techniques, such as linear probing classifiers. Another limitation of AutoPrompt is that it can sometimes struggle when the training data is highly imbalanced. For example, in Sections 4 and 5 we show that the prompts often just increase the likelihood of the majority label. Re-
balancing the training data can help to mitigate this problem. Finally, due to the greedy search over the large discrete space of phrases, AutoPrompt is sometimes brittle; we leave more effective crafting techniques for future directions.</p>
<h2>8 Conclusion</h2>
<p>In this paper, we introduce AutoPrompt, an approach to develop automatically-constructed prompts that elicit knowledge from pretrained MLMs for a variety of tasks. We show that these prompts outperform manual prompts while requiring less human effort. Furthermore, the results for sentiment analysis and textual entailment suggest that, in some data-scarce settings, it may be more effective to prompt language models than to finetune them for the task. Although we focus only on masked language models in this paper, our method can be trivially extended to standard language models, and thus maybe useful for constructing inputs for models like GPT-3 (Brown et al., 2020). Source code and datasets to reproduce the results in this paper is available at http://ucinlp.github.io/autoprompt.</p>
<h2>Acknowledgments</h2>
<p>We would like to thank the LAMA and LPAQA teams for answering our questions. We would also like to thank the members of UCI NLP, Matt Gardner, Sebastian Riedel, and Antoine Bosselut for valuable feedback. This material is based upon work sponsored by the DARPA MCS program under Contract No. N660011924033 with the United States Office Of Naval Research.</p>
<h2>References</h2>
<p>Zied Bouraoui, Jose Camacho-Collados, and Steven Schockaert. 2019. Inducing relational knowledge from BERT. In AAAI.</p>
<p>Samuel R Bowman, Gabor Angeli, Christopher Potts, and Christopher D Manning. 2015. A large annotated corpus for learning natural language inference. In EMNLP.</p>
<p>Tom B Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, et al. 2020. Language models are few-shot learners. arXiv preprint arXiv:2005.14165.</p>
<p>Alexis Conneau, Germán Kruszewski, Guillaume Lample, Loïc Barrault, and Marco Baroni. 2018. What</p>
<p>you can cram into a single vector: Probing sentence embeddings for linguistic properties. In $A C L$.</p>
<p>Ido Dagan, Oren Glickman, and Bernardo Magnini. 2005. The PASCAL recognising textual entailment challenge. In Machine Learning Challenges Workshop.</p>
<p>Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2019. BERT: pre-training of deep bidirectional transformers for language understanding. In NAACL.</p>
<p>Jesse Dodge, Gabriel Ilharco, Roy Schwartz, Ali Farhadi, Hannaneh Hajishirzi, and Noah Smith. 2020. Fine-tuning pretrained language models: Weight initializations, data orders, and early stopping. arXiv preprint arXiv:2002.06305.</p>
<p>Hady ElSahar, Pavlos Vougiouklis, Arslen Remaci, Christophe Gravier, Jonathon S. Hare, Frédérique Laforest, and Elena Simperl. 2018. T-REx: A large scale alignment of natural language with knowledge base triples. In LREC.</p>
<p>John Hewitt and Percy Liang. 2019. Designing and interpreting probes with control tasks. In EMNLP.</p>
<p>Shankar Iyer, Nikhil Dandekar, and Kornel Csernai. 2017. First quora dataset release: Question pairs.</p>
<p>Sarthak Jain and Byron C Wallace. 2019. Attention is not explanation. In NAACL.</p>
<p>Zhengbao Jiang, Frank F Xu, Jun Araki, and Graham Neubig. 2020. How can we know what language models know? In TACL.</p>
<p>Sunjae Kwon, Cheongwoong Kang, Jiyeon Han, and Jaesik Choi. 2019. Why do masked neural language models still need common sense knowledge? arXiv preprint arXiv:1911.03024.</p>
<p>Patrick Lewis, Ludovic Denoyer, and Sebastian Riedel. 2019. Unsupervised question answering by cloze translation. In $A C L$.</p>
<p>Nelson F Liu, Matt Gardner, Yonatan Belinkov, Matthew Peters, and Noah A Smith. 2019. Linguistic knowledge and transferability of contextual representations. In NAACL.</p>
<p>Marco Marelli, Stefano Menini, Marco Baroni, Luisa Bentivogli, Raffaella Bernardi, Roberto Zamparelli, et al. 2014. A SICK cure for the evaluation of compositional distributional semantic models. In LREC.</p>
<p>Matthew E. Peters, Mark Neumann, Mohit Iyyer, Matt Gardner, Christopher Clark, Kenton Lee, and Luke Zettlemoyer. 2018. Deep contextualized word representations. In NAACL.</p>
<p>Fabio Petroni, Tim Rocktäschel, Patrick Lewis, Anton Bakhtin, Yuxiang Wu, Alexander H Miller, and Sebastian Riedel. 2019. Language models as knowledge bases? In EMNLP.</p>
<p>Alec Radford, Jeffrey Wu, Rewon Child, David Luan, Dario Amodei, and Ilya Sutskever. 2019. Language models are unsupervised multitask learners. Technical report.</p>
<p>Timo Schick and Hinrich Schütze. 2020. Exploiting cloze questions for few-shot text classification and natural language inference. arXiv preprint arXiv:2001.07676.</p>
<p>Vered Shwartz, Peter West, Ronan Le Bras, Chandra Bhagavatula, and Yejin Choi. 2020. Unsupervised commonsense question answering with selftalk. arXiv preprint arXiv:2004.05483.</p>
<p>Richard Socher, Alex Perelygin, Jean Wu, Jason Chuang, Christopher D Manning, Andrew Ng, and Christopher Potts. 2013. Recursive deep models for semantic compositionality over a sentiment treebank. In EMNLP.</p>
<p>Daniil Sorokin and Iryna Gurevych. 2017. Contextaware representations for knowledge base relation extraction. In EMNLP.</p>
<p>Trieu H Trinh and Quoc V Le. 2018. A simple method for commonsense reasoning. arXiv preprint arXiv:1806.02847.</p>
<p>Elena Voita and Ivan Titov. 2020. Informationtheoretic probing with minimum description length. In EMNLP.</p>
<p>Eric Wallace, Shi Feng, Nikhil Kandpal, Matt Gardner, and Sameer Singh. 2019. Universal adversarial triggers for attacking and analyzing NLP. In EMNLP.</p>
<p>Alex Wang, Amanpreet Singh, Julian Michael, Felix Hill, Omer Levy, and Samuel R Bowman. 2019. GLUE: A multi-task benchmark and analysis platform for natural language understanding. In $I C L R$.</p>
<p>Sarah Wiegreffe and Yuval Pinter. 2019. Attention is not not explanation. In EMNLP.</p>
<p>Thomas Wolf, Lysandre Debut, Victor Sanh, Julien Chaumond, Clement Delangue, Anthony Moi, Pierric Cistac, Tim Rault, Rémi Louf, Morgan Funtowicz, Joe Davison, Sam Shleifer, Patrick von Platen, Clara Ma, Yacine Jernite, Julien Plu, Canwen Xu, Teven Le Scao, Sylvain Gugger, Mariama Drame, Quentin Lhoest, and Alexander M. Rush. 2019. HuggingFace's Transformers: State-of-theart natural language processing. arXiv preprint arXiv:1910.03771.</p>
<h2>A Effect of Hyperparameters on Sentiment Analysis</h2>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: Effect of Label and Trigger Set Sizes on sentiment analysis. The number of candidate replacements is fixed at $\left|\mathcal{V}_{\text {cand }}\right|=100$. Increasing the label set size improves performance, while changing the trigger length does not have much impact.</p>
<p>To measure the effects of the AutoPrompt search hyperparameters, we plot the validation accuracy as a function of label set size $\left|\mathcal{V}<em _text="\text" _trig="{trig">{y}\right|$ and the number of trigger tokens $\left|\boldsymbol{x}</em>}}\right|$ in Figure 3. We fix the number of candidates at $\left|\mathcal{V<em _cand="{cand" _text="\text">{\text {cand }}\right|=100$. We observe similar trends when $\left|\mathcal{V}</em>\right|=10$.}</p>
<p>Varying the number of trigger tokens generally has little effect. On the other hand, there is a substantial increase in accuracy when increasing the label set size from 1 to 3 (approximately $+5 \%$ for BERT, and $+10 \%$ for RoBERTa). After analyzing the label sets, we find that our method generally produces intuitive results-"marvelous" and "philanthrop" are associated with positive sentiment, whereas "worse" and "incompetence" are associated with negative sentiment for RoBERTa.</p>
<h2>B Relation Extraction Details</h2>
<p>Following Petroni et al. (2019), we use the pretrained RE model from Sorokin and Gurevych (2017) as our baseline. To encode the sentence, this model uses a combination of an LSTM-based relation encoder and an attention mechanism. To make predictions, the model constructs a knowledge graph whose edges are the extracted relation triples. The standard RE evaluation measures how well the model predicts the relation types of entity pairs on the sentence level.</p>
<p>Since our goal is to extract the object of relation triplets, rather than the relation itself, we tweak the standard RE evaluation. We feed the RE model sentences from test facts and we query the resulting graph for all edges that contain the given subject and relation. Then we select the triple with the highest confidence and compare it's object to the gold object. We do this for every fact and take the average across all relations to get the overall precision. The RE model is not trained to predict two of the original T-REx relations. For fair comparison, we exclude these two relations for our evaluation.</p>
<h1>C Additional Fact Retrieval Results</h1>
<table>
<thead>
<tr>
<th style="text-align: center;">Relation</th>
<th style="text-align: center;">Manual Prompt (LAMA)</th>
<th style="text-align: center;">#train</th>
<th style="text-align: center;">LAMA</th>
<th style="text-align: center;">LPAQA</th>
<th style="text-align: center;">AUTOPROMPT</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">P1001</td>
<td style="text-align: center;">[X] is a legal term in [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">70.47</td>
<td style="text-align: center;">72.75</td>
<td style="text-align: center;">82.45</td>
</tr>
<tr>
<td style="text-align: center;">P101</td>
<td style="text-align: center;">[X] works in the field of [Y]</td>
<td style="text-align: center;">864</td>
<td style="text-align: center;">9.91</td>
<td style="text-align: center;">5.32</td>
<td style="text-align: center;">12.79</td>
</tr>
<tr>
<td style="text-align: center;">P103</td>
<td style="text-align: center;">The native language of [X] is [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">72.16</td>
<td style="text-align: center;">72.16</td>
<td style="text-align: center;">82.09</td>
</tr>
<tr>
<td style="text-align: center;">P106</td>
<td style="text-align: center;">[X] is a [Y] by profession</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">0.63</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">14.72</td>
</tr>
<tr>
<td style="text-align: center;">P108</td>
<td style="text-align: center;">[X] works for [Y]</td>
<td style="text-align: center;">376</td>
<td style="text-align: center;">6.79</td>
<td style="text-align: center;">5.74</td>
<td style="text-align: center;">8.62</td>
</tr>
<tr>
<td style="text-align: center;">P127</td>
<td style="text-align: center;">[X] is owned by [Y]</td>
<td style="text-align: center;">548</td>
<td style="text-align: center;">34.79</td>
<td style="text-align: center;">32.46</td>
<td style="text-align: center;">35.95</td>
</tr>
<tr>
<td style="text-align: center;">P1303</td>
<td style="text-align: center;">[X] plays [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">7.59</td>
<td style="text-align: center;">18.02</td>
<td style="text-align: center;">15.38</td>
</tr>
<tr>
<td style="text-align: center;">P131</td>
<td style="text-align: center;">[X] is located in [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">23.27</td>
<td style="text-align: center;">22.81</td>
<td style="text-align: center;">37.46</td>
</tr>
<tr>
<td style="text-align: center;">P136</td>
<td style="text-align: center;">[X] plays [Y] music</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">0.75</td>
<td style="text-align: center;">16.76</td>
<td style="text-align: center;">55.42</td>
</tr>
<tr>
<td style="text-align: center;">P1376</td>
<td style="text-align: center;">[X] is the capital of [Y]</td>
<td style="text-align: center;">310</td>
<td style="text-align: center;">73.93</td>
<td style="text-align: center;">59.83</td>
<td style="text-align: center;">40.17</td>
</tr>
<tr>
<td style="text-align: center;">P138</td>
<td style="text-align: center;">[X] is named after [Y]</td>
<td style="text-align: center;">856</td>
<td style="text-align: center;">61.55</td>
<td style="text-align: center;">59.69</td>
<td style="text-align: center;">66.05</td>
</tr>
<tr>
<td style="text-align: center;">P140</td>
<td style="text-align: center;">[X] is affiliated with the [Y] religion</td>
<td style="text-align: center;">445</td>
<td style="text-align: center;">0.63</td>
<td style="text-align: center;">59.83</td>
<td style="text-align: center;">75.26</td>
</tr>
<tr>
<td style="text-align: center;">P1412</td>
<td style="text-align: center;">[X] used to communicate in [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">65.02</td>
<td style="text-align: center;">64.71</td>
<td style="text-align: center;">71.21</td>
</tr>
<tr>
<td style="text-align: center;">P159</td>
<td style="text-align: center;">The headquarter of [X] is in [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">32.37</td>
<td style="text-align: center;">35.57</td>
<td style="text-align: center;">35.47</td>
</tr>
<tr>
<td style="text-align: center;">P17</td>
<td style="text-align: center;">[X] is located in [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">31.29</td>
<td style="text-align: center;">35.48</td>
<td style="text-align: center;">52.15</td>
</tr>
<tr>
<td style="text-align: center;">P176</td>
<td style="text-align: center;">[X] is produced by [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">85.64</td>
<td style="text-align: center;">81.67</td>
<td style="text-align: center;">87.78</td>
</tr>
<tr>
<td style="text-align: center;">P178</td>
<td style="text-align: center;">[X] is developed by [Y]</td>
<td style="text-align: center;">560</td>
<td style="text-align: center;">62.84</td>
<td style="text-align: center;">59.12</td>
<td style="text-align: center;">66.72</td>
</tr>
<tr>
<td style="text-align: center;">P19</td>
<td style="text-align: center;">[X] was born in [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">21.08</td>
<td style="text-align: center;">20.87</td>
<td style="text-align: center;">19.92</td>
</tr>
<tr>
<td style="text-align: center;">P190</td>
<td style="text-align: center;">[X] and [Y] are twin cities</td>
<td style="text-align: center;">895</td>
<td style="text-align: center;">2.41</td>
<td style="text-align: center;">1.91</td>
<td style="text-align: center;">2.31</td>
</tr>
<tr>
<td style="text-align: center;">P20</td>
<td style="text-align: center;">[X] died in [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">27.91</td>
<td style="text-align: center;">27.91</td>
<td style="text-align: center;">31.16</td>
</tr>
<tr>
<td style="text-align: center;">P264</td>
<td style="text-align: center;">[X] is represented by music label [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">9.56</td>
<td style="text-align: center;">10.26</td>
<td style="text-align: center;">43.82</td>
</tr>
<tr>
<td style="text-align: center;">P27</td>
<td style="text-align: center;">[X] is [Y] citizen</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">41.51</td>
<td style="text-align: center;">46.69</td>
</tr>
<tr>
<td style="text-align: center;">P276</td>
<td style="text-align: center;">[X] is located in [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">41.5</td>
<td style="text-align: center;">41.5</td>
<td style="text-align: center;">44.11</td>
</tr>
<tr>
<td style="text-align: center;">P279</td>
<td style="text-align: center;">[X] is a subclass of [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">30.74</td>
<td style="text-align: center;">14.75</td>
<td style="text-align: center;">54.93</td>
</tr>
<tr>
<td style="text-align: center;">P30</td>
<td style="text-align: center;">[X] is located in [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">25.44</td>
<td style="text-align: center;">18.56</td>
<td style="text-align: center;">70.36</td>
</tr>
<tr>
<td style="text-align: center;">P31</td>
<td style="text-align: center;">[X] is a [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">36.66</td>
<td style="text-align: center;">36.66</td>
<td style="text-align: center;">51.95</td>
</tr>
<tr>
<td style="text-align: center;">P36</td>
<td style="text-align: center;">The capital of [X] is [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">62.16</td>
<td style="text-align: center;">62.16</td>
<td style="text-align: center;">60.6</td>
</tr>
<tr>
<td style="text-align: center;">P361</td>
<td style="text-align: center;">[X] is part of [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">23.61</td>
<td style="text-align: center;">31.44</td>
<td style="text-align: center;">17.7</td>
</tr>
<tr>
<td style="text-align: center;">P364</td>
<td style="text-align: center;">The original language of [X] is [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">44.51</td>
<td style="text-align: center;">43.93</td>
<td style="text-align: center;">48.48</td>
</tr>
<tr>
<td style="text-align: center;">P37</td>
<td style="text-align: center;">The official language of [X] is [Y]</td>
<td style="text-align: center;">311</td>
<td style="text-align: center;">54.55</td>
<td style="text-align: center;">56.83</td>
<td style="text-align: center;">62.63</td>
</tr>
<tr>
<td style="text-align: center;">P39</td>
<td style="text-align: center;">[X] has the position of [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">7.96</td>
<td style="text-align: center;">16.14</td>
<td style="text-align: center;">30.72</td>
</tr>
<tr>
<td style="text-align: center;">P407</td>
<td style="text-align: center;">[X] was written in [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">59.18</td>
<td style="text-align: center;">65.22</td>
<td style="text-align: center;">68.42</td>
</tr>
<tr>
<td style="text-align: center;">P413</td>
<td style="text-align: center;">[X] plays in [Y] position</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">0.53</td>
<td style="text-align: center;">23.74</td>
<td style="text-align: center;">41.7</td>
</tr>
<tr>
<td style="text-align: center;">P449</td>
<td style="text-align: center;">[X] was originally aired on [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">20.89</td>
<td style="text-align: center;">9.08</td>
<td style="text-align: center;">34.39</td>
</tr>
<tr>
<td style="text-align: center;">P463</td>
<td style="text-align: center;">[X] is a member of [Y]</td>
<td style="text-align: center;">679</td>
<td style="text-align: center;">67.11</td>
<td style="text-align: center;">57.33</td>
<td style="text-align: center;">54.22</td>
</tr>
<tr>
<td style="text-align: center;">P47</td>
<td style="text-align: center;">[X] shares border with [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">13.67</td>
<td style="text-align: center;">13.34</td>
<td style="text-align: center;">19.52</td>
</tr>
<tr>
<td style="text-align: center;">P495</td>
<td style="text-align: center;">[X] was created in [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">16.5</td>
<td style="text-align: center;">32.23</td>
<td style="text-align: center;">36.63</td>
</tr>
<tr>
<td style="text-align: center;">P527</td>
<td style="text-align: center;">[X] consists of [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">11.07</td>
<td style="text-align: center;">10.55</td>
<td style="text-align: center;">25.61</td>
</tr>
<tr>
<td style="text-align: center;">P530</td>
<td style="text-align: center;">[X] maintains diplomatic relations with [Y]</td>
<td style="text-align: center;">927</td>
<td style="text-align: center;">2.81</td>
<td style="text-align: center;">3.92</td>
<td style="text-align: center;">3.11</td>
</tr>
<tr>
<td style="text-align: center;">P740</td>
<td style="text-align: center;">[X] was founded in [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">7.59</td>
<td style="text-align: center;">13.68</td>
<td style="text-align: center;">13.89</td>
</tr>
<tr>
<td style="text-align: center;">P937</td>
<td style="text-align: center;">[X] used to work in [Y]</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">29.77</td>
<td style="text-align: center;">39.1</td>
<td style="text-align: center;">38.36</td>
</tr>
</tbody>
</table>
<p>Table 6: A breakdown of all relations for fact retrieval on the original dataset from Petroni et al. (2019). We compare P@1 of prompts generated by LAMA, LPAQA, and our approach using five prompt tokens.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Relation</th>
<th style="text-align: center;">Method</th>
<th style="text-align: center;">Prompt</th>
<th style="text-align: center;">P@1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">P101</td>
<td style="text-align: center;">Manual</td>
<td style="text-align: center;">[X] works in the field of [Y]</td>
<td style="text-align: center;">11.52</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT BERT</td>
<td style="text-align: center;">[X] probability earliest fame totaled studying [Y]</td>
<td style="text-align: center;">15.01</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT RoBERTa</td>
<td style="text-align: center;">[X] 1830 dissertation applying mathsucci [Y]</td>
<td style="text-align: center;">0.17</td>
</tr>
<tr>
<td style="text-align: center;">P103</td>
<td style="text-align: center;">Manual</td>
<td style="text-align: center;">The native language of [X] is [Y]</td>
<td style="text-align: center;">74.54</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT BERT</td>
<td style="text-align: center;">[X]PA communerug speaks proper [Y]</td>
<td style="text-align: center;">84.87</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT RoBERTa</td>
<td style="text-align: center;">[X]neau optionally fluent!?traditional [Y]</td>
<td style="text-align: center;">81.61</td>
</tr>
<tr>
<td style="text-align: center;">P106</td>
<td style="text-align: center;">Manual</td>
<td style="text-align: center;">[X] is a [Y] by profession</td>
<td style="text-align: center;">0.73</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT BERT</td>
<td style="text-align: center;">[X] supporters studied politicians musician turned [Y]</td>
<td style="text-align: center;">15.83</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT RoBERTa</td>
<td style="text-align: center;">[X] (), astronomers businessman-former [Y]</td>
<td style="text-align: center;">19.24</td>
</tr>
<tr>
<td style="text-align: center;">P127</td>
<td style="text-align: center;">Manual</td>
<td style="text-align: center;">[X] is owned by [Y]</td>
<td style="text-align: center;">36.67</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT BERT</td>
<td style="text-align: center;">[X] is hindwings mainline architecture within [Y]</td>
<td style="text-align: center;">47.01</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT RoBERTa</td>
<td style="text-align: center;">[X] picThom unwillingness officially governs [Y]</td>
<td style="text-align: center;">39.58</td>
</tr>
<tr>
<td style="text-align: center;">P1303</td>
<td style="text-align: center;">Manual</td>
<td style="text-align: center;">[X] plays [Y]</td>
<td style="text-align: center;">18.91</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT BERT</td>
<td style="text-align: center;">[X] playingdrum concertoative electric [Y]</td>
<td style="text-align: center;">42.69</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT RoBERTa</td>
<td style="text-align: center;">[X]Trump learned soloKeefe classical [Y]</td>
<td style="text-align: center;">44.44</td>
</tr>
<tr>
<td style="text-align: center;">P136</td>
<td style="text-align: center;">Manual</td>
<td style="text-align: center;">[X] plays [Y] music</td>
<td style="text-align: center;">0.7</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT BERT</td>
<td style="text-align: center;">[X] freaking genre orchestra fiction acid [Y]</td>
<td style="text-align: center;">59.95</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT RoBERTa</td>
<td style="text-align: center;">[X] blends postwar hostage drama sax [Y]</td>
<td style="text-align: center;">52.97</td>
</tr>
<tr>
<td style="text-align: center;">P1376</td>
<td style="text-align: center;">Manual</td>
<td style="text-align: center;">[X] is the capital of [Y]</td>
<td style="text-align: center;">81.11</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT BERT</td>
<td style="text-align: center;">[X] boasts native territory traditionally called [Y]</td>
<td style="text-align: center;">63.33</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT RoBERTa</td>
<td style="text-align: center;">[X] limestone depositedati boroughDepending [Y]</td>
<td style="text-align: center;">28.33</td>
</tr>
<tr>
<td style="text-align: center;">P178</td>
<td style="text-align: center;">Manual</td>
<td style="text-align: center;">[X] is developed by [Y]</td>
<td style="text-align: center;">62.76</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT BERT</td>
<td style="text-align: center;">[X] is memory arcade branding by [Y]</td>
<td style="text-align: center;">64.45</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT RoBERTa</td>
<td style="text-align: center;">[X] 1987 floppy simulator users sued [Y]</td>
<td style="text-align: center;">69.56</td>
</tr>
<tr>
<td style="text-align: center;">P20</td>
<td style="text-align: center;">Manual</td>
<td style="text-align: center;">[X] died in [Y]</td>
<td style="text-align: center;">32.07</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT BERT</td>
<td style="text-align: center;">[X] reorganizationotype photographic studio in [Y]</td>
<td style="text-align: center;">33.53</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT RoBERTa</td>
<td style="text-align: center;">[X].. enigmatic twentieth nowadays near [Y]</td>
<td style="text-align: center;">31.33</td>
</tr>
<tr>
<td style="text-align: center;">P27</td>
<td style="text-align: center;">Manual</td>
<td style="text-align: center;">[X] is [Y] citizen</td>
<td style="text-align: center;">0.0</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT BERT</td>
<td style="text-align: center;">[X] $\mathrm{m}^{8}$ badminton pieces internationally representing [Y]</td>
<td style="text-align: center;">46.13</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT RoBERTa</td>
<td style="text-align: center;">[X] offic organise forests statutes northwestern [Y]</td>
<td style="text-align: center;">42.07</td>
</tr>
<tr>
<td style="text-align: center;">P276</td>
<td style="text-align: center;">Manual</td>
<td style="text-align: center;">[X] is located in [Y]</td>
<td style="text-align: center;">43.73</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT BERT</td>
<td style="text-align: center;">[X] consists kilograms centred neighborhoods in [Y]</td>
<td style="text-align: center;">44.64</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT RoBERTa</td>
<td style="text-align: center;">[X] manoeuv constructs whistleblowers hills near [Y]</td>
<td style="text-align: center;">37.47</td>
</tr>
<tr>
<td style="text-align: center;">P279</td>
<td style="text-align: center;">Manual</td>
<td style="text-align: center;">[X] is a subclass of [Y]</td>
<td style="text-align: center;">31.04</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT BERT</td>
<td style="text-align: center;">[X] is î adequately termed coated [Y]</td>
<td style="text-align: center;">55.65</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT RoBERTa</td>
<td style="text-align: center;">[X],formerly prayers unstaceous [Y]</td>
<td style="text-align: center;">52.55</td>
</tr>
<tr>
<td style="text-align: center;">P37</td>
<td style="text-align: center;">Manual</td>
<td style="text-align: center;">The official language of [X] is [Y]</td>
<td style="text-align: center;">56.89</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT BERT</td>
<td style="text-align: center;">[X]inen dialects resembled officially exclusively [Y]</td>
<td style="text-align: center;">54.44</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT RoBERTa</td>
<td style="text-align: center;">[X]onen tribes descending speak mainly [Y]</td>
<td style="text-align: center;">53.67</td>
</tr>
<tr>
<td style="text-align: center;">P407</td>
<td style="text-align: center;">Manual</td>
<td style="text-align: center;">[X] was written in [Y]</td>
<td style="text-align: center;">60.21</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT BERT</td>
<td style="text-align: center;">[X] playedić every dialect but [Y]</td>
<td style="text-align: center;">69.31</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT RoBERTa</td>
<td style="text-align: center;">[X] scaven pronunciation.*Wikipedia speaks [Y]</td>
<td style="text-align: center;">72.0</td>
</tr>
<tr>
<td style="text-align: center;">P413</td>
<td style="text-align: center;">Manual</td>
<td style="text-align: center;">[X] plays in [Y] position</td>
<td style="text-align: center;">0.53</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT BERT</td>
<td style="text-align: center;">[X] played colors skier $\leftrightarrow$ defensive [Y]</td>
<td style="text-align: center;">41.71</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">AUTOPROMPT RoBERTa</td>
<td style="text-align: center;">[X]," (), ex-,Liverpool [Y]</td>
<td style="text-align: center;">23.21</td>
</tr>
</tbody>
</table>
<p>Table 7: Examples of manual prompts (first line, shown with BERT's P@1) and prompts generated via AutoPrompt for Fact Retrieval.</p>
<h1>D Additional Relation Extraction Results</h1>
<table>
<thead>
<tr>
<th style="text-align: center;">Relation</th>
<th style="text-align: center;">Model</th>
<th style="text-align: center;">Context and Prompt</th>
<th style="text-align: center;">Prediction</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">P103 (native language)</td>
<td style="text-align: center;">BERT</td>
<td style="text-align: center;">Alexandra Lamy (born 14 October 1971) is a French actress. Alexandra Lamy speaks airfield dripping \% of [MASK].</td>
<td style="text-align: center;">French</td>
</tr>
<tr>
<td style="text-align: center;">P36 (capital)</td>
<td style="text-align: center;">RoBERTa</td>
<td style="text-align: center;">Kirk was born in Clinton County, Ohio, and he entered service in Wilmington, Ohio. Clinton County famously includes the zoo influencing [MASK].</td>
<td style="text-align: center;">Wilmington</td>
</tr>
<tr>
<td style="text-align: center;">P530 (diplomatic relation)</td>
<td style="text-align: center;">BERT</td>
<td style="text-align: center;">The Black Sea forms in an east-west trending elliptical depression which lies between Bulgaria, Georgia, Romania, Russia, Turkey, and Ukraine. Ukraine qualified some immigration actually entered [MASK].</td>
<td style="text-align: center;">Russia</td>
</tr>
<tr>
<td style="text-align: center;">P106 (occupation)</td>
<td style="text-align: center;">RoBERTa</td>
<td style="text-align: center;">Spencer Treat Clark (born September 24, 1987) is an American actor who has appeared in several films, including Gladiator, Mystic River, and Unbreakable. Spencer Treat Clark famously the famously handsome the [MASK].</td>
<td style="text-align: center;">Hulk</td>
</tr>
<tr>
<td style="text-align: center;">P276 (location)</td>
<td style="text-align: center;">BERT</td>
<td style="text-align: center;">The Immortal Game was a chess game played by Adolf Anderssen and Lionel Kieseritzky on 21 June 1851 in LondonSeoul, during a break of the first international tournament. The Immortal Game locatedstered regardless streets in [MASK].</td>
<td style="text-align: center;">Seoul</td>
</tr>
<tr>
<td style="text-align: center;">P176 (manufacturer)</td>
<td style="text-align: center;">RoBERTa</td>
<td style="text-align: center;">The Honda Civic del Sol is a 2-seater front-engined, front wheel drive, targa top car manufactured by Honda Toyota in the 1990s. Honda Civic del Sol defy trademarks of namesake manufacturer [MASK].</td>
<td style="text-align: center;">Toyota</td>
</tr>
<tr>
<td style="text-align: center;">P279 (subclass of)</td>
<td style="text-align: center;">BERT</td>
<td style="text-align: center;">Mizeria is a Polish saladsandwich consisting of thinly sliced or grated cucumbers, often with sour cream though in some cases oil. Mizeria is calls direcend altitude [MASK].</td>
<td style="text-align: center;">food</td>
</tr>
<tr>
<td style="text-align: center;">P463 (member of)</td>
<td style="text-align: center;">RoBERTa</td>
<td style="text-align: center;">RushAerosmith was a Canadian rock band consisting of Geddy Lee (bass, vocals, keyboards), Alex Lifeson (guitars), and Neil Peart (drums, percussion, lyricist). Alex Lifeson affiliatedalach the internationally initials [MASK].</td>
<td style="text-align: center;">Kiss</td>
</tr>
</tbody>
</table>
<p>Table 8: Examples of prompts generated using AUTOPROMPT for relation extraction. Underlined words represent the gold object. The bottom half of the Table shows examples of our augmented evaluation where the original objects (represented by crossed-out words) are replaced by new objects.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{4}$ The original dataset consists of examples where the object is a single token for BERT.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:1">
<p>${ }^{3}$ Required 2 days to run with 8 NVIDIA 2080Ti GPUs.&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>