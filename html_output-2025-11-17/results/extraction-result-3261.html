<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-3261 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-3261</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-3261</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-75.html">extraction-schema-75</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of LLM agents playing text games, with a focus on how memory is used, what types of memory are implemented, and how memory affects performance on text game tasks.</div>
                <p><strong>Paper ID:</strong> paper-60441391</p>
                <p><strong>Paper Title:</strong> <a href="https://arxiv.org/pdf/1902.04259v2.pdf" target="_blank">NAIL: A General Interactive Fiction Agent</a></p>
                <p><strong>Paper Abstract:</strong> Interactive Fiction (IF) games are complex textual decision making problems. This paper introduces NAIL, an autonomous agent for general parser-based IF games. NAIL won the 2018 Text Adventure AI Competition, where it was evaluated on twenty unseen games. This paper describes the architecture, development, and insights underpinning NAIL's performance.</p>
                <p><strong>Cost:</strong> 0.014</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e3261.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e3261.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of LLM agents playing text games, with a focus on how memory is used, what types of memory are implemented, and how memory affects performance on text game tasks.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>NAIL</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>NAIL (Navigate, Acquire, Interact and Learn)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A modular, rule-and-heuristic IF agent that builds an explicit structured Knowledge Graph (locations, entities, connection graph, inventory, action records, unrecognized words) and uses specialized decision modules to play parser-based interactive fiction games.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>NAIL</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Modular agent composed of Decision Modules (Examiner, Hoarder, Interactor, Navigator, plus specialized modules) that generate text actions; uses a FastText-based Validity Detector to interpret game responses and an external structured Knowledge Graph to store discovered locations, entities, connection graph (map), inventory, action records, and unrecognized words. Action generation for interaction is prioritized by an n-gram language model; many effects (take, open, turn on, navigation) are manually encoded to update the KG.</td>
                        </tr>
                        <tr>
                            <td><strong>game_or_benchmark_name</strong></td>
                            <td>Jericho / assorted parser-based IF games (20 competition test games; 56-game development set)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Maximize normalized game score / satisfy early-game Dependencies within limited interaction steps (competition: 1000 steps per unseen game); general exploration, object acquisition, interaction with objects, and navigation across text-adventure games.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_memory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>external structured knowledge graph (episodic / environment memory) + connection graph (map) + action history</td>
                        </tr>
                        <tr>
                            <td><strong>memory_implementation_details</strong></td>
                            <td>Explicit Knowledge Graph storing Current Location, list of Locations (with long descriptions), Entities (names, descriptions, contained entities, states, attributes), Connection Graph linking locations (ad-hoc map), Inventory, Action Record (actions attempted at each location with game's response and success estimate), and Unrecognized Words; the Validity Detector gates additions/updates. Navigator updates map upon successful movement; Decision Modules consult KG to compute eagerness and avoid repeating failed actions.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>Normalized score 2.56% (average over 20 test games, competition run). Ablation: baseline (no decision modules) 0.53%; adding Navigator (locomotion + map) increased score to 1.2%; adding Hoarder increased to 1.6%; adding Examiner increased to 2.6%; adding Interactor increased to 3.5%. (Metrics: % normalized game score averaged across Jericho games.)</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td>Baseline (no decision modules, effectively minimal memory use) 0.53% normalized score across games (see ablation).</td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_comparison</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_benefits</strong></td>
                            <td>KG + map enable systematic exploration and navigation (Navigator jump from 0.53% to 1.2%), object discovery and focused interactions (Examiner contributed large gain to 2.6%), avoidance of repeating failed actions, gating of actions containing unrecognized words, and interpretable state for decision modules—overall improved ability to find score-relevant entities and actions.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_limitations_or_failures</strong></td>
                            <td>Memory (KG) is manually structured and relies on manually defined action effects for common verbs; non-common actions have no learned effects beyond logging. The approach still attains low absolute normalized scores, indicating limits in solving complex puzzles despite memory. Validity Detector trained on a small dataset, which may limit reliability. No mechanism for learning effects of uncommon actions; KG updates depend on correct validity classification and handcrafted state attributes.</td>
                        </tr>
                        <tr>
                            <td><strong>best_practices_or_recommendations</strong></td>
                            <td>Use an explicit, structured external Knowledge Graph to store locations, entities, and action outcomes; use a learned Validity Detector to gate KG updates; store a connection graph (map) to support navigation; store unrecognized words to avoid futile action generation; implement modular decision modules that consult and update the KG; ablate components to measure memory contributions.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'NAIL: A General Interactive Fiction Agent', 'publication_date_yy_mm': '2019-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3261.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e3261.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of LLM agents playing text games, with a focus on how memory is used, what types of memory are implemented, and how memory affects performance on text game tasks.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>CARL</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>CARL (BYU Agent lineage, 2019)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An IF-playing agent that uses skip-thought vectors to represent observations and a hash table to track visited states and actions to avoid repetition; extracts nouns to propose actions.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>CARL</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Related-work agent that represents observation text with skip-thought vectors, classifies observations as location vs action-effect texts, extracts nouns to propose verb-object actions using embedding-based affordances, and uses a hash table to track visited states and actions.</td>
                        </tr>
                        <tr>
                            <td><strong>game_or_benchmark_name</strong></td>
                            <td>Parser-based IF games (related work / prior agents)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>General interactive fiction play: identify interactive objects, generate candidate actions, avoid repeating failed actions.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_memory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>visited-state/action hash table (episodic visited-state memory)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_implementation_details</strong></td>
                            <td>Maintains a hash table of visited states and actions to avoid repetition; uses skip-thought vector representations for observations to classify and guide action generation; memory used primarily to detect revisitation and prune repeated attempts.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_comparison</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>memory_benefits</strong></td>
                            <td>Avoids repeating previously attempted actions and revisiting identical states; supports more efficient exploration compared to naive exhaustive methods (mentioned qualitatively).</td>
                        </tr>
                        <tr>
                            <td><strong>memory_limitations_or_failures</strong></td>
                            <td>No quantitative evaluation of memory's isolated effect reported in this paper; hash-table approach may be brittle to paraphrased or slightly varying location descriptions without robust similarity matching.</td>
                        </tr>
                        <tr>
                            <td><strong>best_practices_or_recommendations</strong></td>
                            <td>Track visited states and actions (e.g., via a hash table) to reduce redundant exploration; pair state representations (skip-thought) with memory to determine repetition.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'NAIL: A General Interactive Fiction Agent', 'publication_date_yy_mm': '2019-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3261.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e3261.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of LLM agents playing text games, with a focus on how memory is used, what types of memory are implemented, and how memory affects performance on text game tasks.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>LSTM-DQN</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>LSTM-DQN (Narasimhan et al., 2015)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A reinforcement-learning agent that processes narrative text with an LSTM to produce a state representation used by a DQN for action selection in text-based games.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Language understanding for textbased games using deep reinforcement learning</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>LSTM-DQN</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Deep RL agent that encodes narrative observations with an LSTM to produce a compact state representation which is fed to a DQN-style action selector; the recurrent network provides temporal context of recent observations.</td>
                        </tr>
                        <tr>
                            <td><strong>game_or_benchmark_name</strong></td>
                            <td>Text-based games (related work)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Learn to act in text-based game environments by mapping textual observations to actions with RL.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_memory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>recurrent hidden-state (working/short-term memory)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_implementation_details</strong></td>
                            <td>Uses an LSTM to process sequences of narrative text; the LSTM hidden state encodes recent history and functions as a working memory / state representation for the policy network (DQN).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_comparison</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>memory_benefits</strong></td>
                            <td>Recurrent encoding enables the agent to build a representation of the current state from text history rather than a single observation, improving capacity to interpret temporally distributed cues (described as the motivation in related work).</td>
                        </tr>
                        <tr>
                            <td><strong>memory_limitations_or_failures</strong></td>
                            <td>No empirical comparisons in this paper; related work notes partial observability makes single-step observation insufficient, motivating recurrence.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'NAIL: A General Interactive Fiction Agent', 'publication_date_yy_mm': '2019-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3261.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e3261.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of LLM agents playing text games, with a focus on how memory is used, what types of memory are implemented, and how memory affects performance on text game tasks.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>LSTM-DRQN</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>LSTM-DRQN (Yuan et al., 2018)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An extension that adds a second-level recurrence over states (Deep Recurrent Q-Network) to enable reasoning over longer temporal context, demonstrated to improve reasoning over visited locations.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Counting to explore and generalize in text-based games</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>LSTM-DRQN</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Deep RL architecture adding recurrence over state representations (hierarchical recurrence) to capture longer-range dependencies across visited locations; uses recurrence to improve partial-observability handling.</td>
                        </tr>
                        <tr>
                            <td><strong>game_or_benchmark_name</strong></td>
                            <td>Text-based games (related work)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Improve exploration and generalization in text-based games by leveraging recurrence over states to capture longer-term context.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_memory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>hierarchical recurrence / extended recurrent hidden-state (longer-term working memory)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_implementation_details</strong></td>
                            <td>Adds a second level of recurrence over the state representations so that the policy can condition on a longer history of visited locations and past states; implemented as recurrent networks across time steps/states.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_comparison</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>memory_benefits</strong></td>
                            <td>Reported (in the cited work) to permit reasoning over previously visited locations and improve exploration/generalization; paper cites improved ability to reason over locations visited in the past.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_limitations_or_failures</strong></td>
                            <td>No numerical results presented in this NAIL paper; potential limitations include vanishing memory for very long horizons and reliance on sufficient training signal.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'NAIL: A General Interactive Fiction Agent', 'publication_date_yy_mm': '2019-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3261.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e3261.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of LLM agents playing text games, with a focus on how memory is used, what types of memory are implemented, and how memory affects performance on text game tasks.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Graph-based RL (Ammanabrolu & Riedl)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Playing text-adventure games with graph-based deep reinforcement learning</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>End-to-end learned agent that represents game state as a dynamic knowledge graph and uses that graph as the agent's observation/state representation for policy learning.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Playing text-adventure games with graph-based deep reinforcement learning</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>Graph-based deep RL agent</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Learns an end-to-end policy for text-adventure games while constructing and using a knowledge graph representation of the environment as state input to the policy; the graph captures entities and relations from text.</td>
                        </tr>
                        <tr>
                            <td><strong>game_or_benchmark_name</strong></td>
                            <td>Text-adventure games (related work)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Learn to act in text-adventure games using a learned policy that conditions on an evolving knowledge-graph state representation.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_memory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>external structured knowledge graph (learned and used as state representation)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_implementation_details</strong></td>
                            <td>Constructs and maintains a dynamic knowledge graph extracted from text observations; the graph is used as input to the policy network (graph-based features) and is updated as the agent observes new text and takes actions.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_comparison</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>memory_benefits</strong></td>
                            <td>Graph state representation provides structured memory of entities and relations, enabling better reasoning about objects and their relations compared to bag-of-words or flat encodings (as argued in the cited work).</td>
                        </tr>
                        <tr>
                            <td><strong>memory_limitations_or_failures</strong></td>
                            <td>Not evaluated within this NAIL paper; limitations in original work may include difficulty extracting correct relations from noisy text and overhead in graph construction.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'NAIL: A General Interactive Fiction Agent', 'publication_date_yy_mm': '2019-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3261.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e3261.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of LLM agents playing text games, with a focus on how memory is used, what types of memory are implemented, and how memory affects performance on text game tasks.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>BYU'16 Agent</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>BYU Agent (2016) / Fulda et al.</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Agent that uses word-embedding affordance extraction to propose verbs applicable to objects and then exhaustively enumerates possible actions; less efficient in terms of steps required.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>What can you do with a rock? affordance extraction via word embeddings</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>BYU Agent</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Uses word-embedding relationships (affordance extraction) to infer which verbs are likely applicable to which objects and then enumerates candidate actions exhaustively for testing in IF games.</td>
                        </tr>
                        <tr>
                            <td><strong>game_or_benchmark_name</strong></td>
                            <td>Parser-based IF games (related work)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Generate valid actions by combining likely verbs (from embeddings) with objects and test them in the game.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_memory</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_implementation_details</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_comparison</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>memory_benefits</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>memory_limitations_or_failures</strong></td>
                            <td>Exhaustive enumeration is less efficient (more in-game steps required); no explicit memory mechanism used as described in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>best_practices_or_recommendations</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'NAIL: A General Interactive Fiction Agent', 'publication_date_yy_mm': '2019-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3261.6">
                <h3 class="extraction-instance">Extracted Data Instance 6 (e3261.6)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of LLM agents playing text games, with a focus on how memory is used, what types of memory are implemented, and how memory affects performance on text game tasks.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Golovin</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Golovin Agent (Kostka et al., 2017)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Agent that generates actions using a large predefined set of command patterns and uses specialized generators for common tasks; uses an RNN to score likely interactable objects.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Text-based adventures of the golovin AI agent</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>Golovin</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Generates commands from a large set of predefined patterns extracted from walkthroughs/tutorials and uses specialized command generators (fighting, exploring, inventory management); an RNN ranks objects likely to be interactable.</td>
                        </tr>
                        <tr>
                            <td><strong>game_or_benchmark_name</strong></td>
                            <td>Parser-based IF games (related work)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Efficiently generate and prioritize candidate commands for interactive fiction play.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_memory</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_implementation_details</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_comparison</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>memory_benefits</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>memory_limitations_or_failures</strong></td>
                            <td>No explicit memory structure is described in this paper; limited examination/action balance compared to NAIL (Golovin uses fewer 'examine' actions).</td>
                        </tr>
                        <tr>
                            <td><strong>best_practices_or_recommendations</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'NAIL: A General Interactive Fiction Agent', 'publication_date_yy_mm': '2019-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Playing text-adventure games with graph-based deep reinforcement learning <em>(Rating: 2)</em></li>
                <li>Language understanding for textbased games using deep reinforcement learning <em>(Rating: 2)</em></li>
                <li>Counting to explore and generalize in text-based games <em>(Rating: 2)</em></li>
                <li>What can you do with a rock? affordance extraction via word embeddings <em>(Rating: 1)</em></li>
                <li>Text-based adventures of the golovin AI agent <em>(Rating: 1)</em></li>
                <li>Learning how not to act in text-based games <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-3261",
    "paper_id": "paper-60441391",
    "extraction_schema_id": "extraction-schema-75",
    "extracted_data": [
        {
            "name_short": "NAIL",
            "name_full": "NAIL (Navigate, Acquire, Interact and Learn)",
            "brief_description": "A modular, rule-and-heuristic IF agent that builds an explicit structured Knowledge Graph (locations, entities, connection graph, inventory, action records, unrecognized words) and uses specialized decision modules to play parser-based interactive fiction games.",
            "citation_title": "here",
            "mention_or_use": "use",
            "agent_name": "NAIL",
            "agent_description": "Modular agent composed of Decision Modules (Examiner, Hoarder, Interactor, Navigator, plus specialized modules) that generate text actions; uses a FastText-based Validity Detector to interpret game responses and an external structured Knowledge Graph to store discovered locations, entities, connection graph (map), inventory, action records, and unrecognized words. Action generation for interaction is prioritized by an n-gram language model; many effects (take, open, turn on, navigation) are manually encoded to update the KG.",
            "game_or_benchmark_name": "Jericho / assorted parser-based IF games (20 competition test games; 56-game development set)",
            "task_description": "Maximize normalized game score / satisfy early-game Dependencies within limited interaction steps (competition: 1000 steps per unseen game); general exploration, object acquisition, interaction with objects, and navigation across text-adventure games.",
            "uses_memory": true,
            "memory_type": "external structured knowledge graph (episodic / environment memory) + connection graph (map) + action history",
            "memory_implementation_details": "Explicit Knowledge Graph storing Current Location, list of Locations (with long descriptions), Entities (names, descriptions, contained entities, states, attributes), Connection Graph linking locations (ad-hoc map), Inventory, Action Record (actions attempted at each location with game's response and success estimate), and Unrecognized Words; the Validity Detector gates additions/updates. Navigator updates map upon successful movement; Decision Modules consult KG to compute eagerness and avoid repeating failed actions.",
            "performance_with_memory": "Normalized score 2.56% (average over 20 test games, competition run). Ablation: baseline (no decision modules) 0.53%; adding Navigator (locomotion + map) increased score to 1.2%; adding Hoarder increased to 1.6%; adding Examiner increased to 2.6%; adding Interactor increased to 3.5%. (Metrics: % normalized game score averaged across Jericho games.)",
            "performance_without_memory": "Baseline (no decision modules, effectively minimal memory use) 0.53% normalized score across games (see ablation).",
            "has_performance_comparison": true,
            "memory_benefits": "KG + map enable systematic exploration and navigation (Navigator jump from 0.53% to 1.2%), object discovery and focused interactions (Examiner contributed large gain to 2.6%), avoidance of repeating failed actions, gating of actions containing unrecognized words, and interpretable state for decision modules—overall improved ability to find score-relevant entities and actions.",
            "memory_limitations_or_failures": "Memory (KG) is manually structured and relies on manually defined action effects for common verbs; non-common actions have no learned effects beyond logging. The approach still attains low absolute normalized scores, indicating limits in solving complex puzzles despite memory. Validity Detector trained on a small dataset, which may limit reliability. No mechanism for learning effects of uncommon actions; KG updates depend on correct validity classification and handcrafted state attributes.",
            "best_practices_or_recommendations": "Use an explicit, structured external Knowledge Graph to store locations, entities, and action outcomes; use a learned Validity Detector to gate KG updates; store a connection graph (map) to support navigation; store unrecognized words to avoid futile action generation; implement modular decision modules that consult and update the KG; ablate components to measure memory contributions.",
            "uuid": "e3261.0",
            "source_info": {
                "paper_title": "NAIL: A General Interactive Fiction Agent",
                "publication_date_yy_mm": "2019-02"
            }
        },
        {
            "name_short": "CARL",
            "name_full": "CARL (BYU Agent lineage, 2019)",
            "brief_description": "An IF-playing agent that uses skip-thought vectors to represent observations and a hash table to track visited states and actions to avoid repetition; extracts nouns to propose actions.",
            "citation_title": "",
            "mention_or_use": "mention",
            "agent_name": "CARL",
            "agent_description": "Related-work agent that represents observation text with skip-thought vectors, classifies observations as location vs action-effect texts, extracts nouns to propose verb-object actions using embedding-based affordances, and uses a hash table to track visited states and actions.",
            "game_or_benchmark_name": "Parser-based IF games (related work / prior agents)",
            "task_description": "General interactive fiction play: identify interactive objects, generate candidate actions, avoid repeating failed actions.",
            "uses_memory": true,
            "memory_type": "visited-state/action hash table (episodic visited-state memory)",
            "memory_implementation_details": "Maintains a hash table of visited states and actions to avoid repetition; uses skip-thought vector representations for observations to classify and guide action generation; memory used primarily to detect revisitation and prune repeated attempts.",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_performance_comparison": false,
            "memory_benefits": "Avoids repeating previously attempted actions and revisiting identical states; supports more efficient exploration compared to naive exhaustive methods (mentioned qualitatively).",
            "memory_limitations_or_failures": "No quantitative evaluation of memory's isolated effect reported in this paper; hash-table approach may be brittle to paraphrased or slightly varying location descriptions without robust similarity matching.",
            "best_practices_or_recommendations": "Track visited states and actions (e.g., via a hash table) to reduce redundant exploration; pair state representations (skip-thought) with memory to determine repetition.",
            "uuid": "e3261.1",
            "source_info": {
                "paper_title": "NAIL: A General Interactive Fiction Agent",
                "publication_date_yy_mm": "2019-02"
            }
        },
        {
            "name_short": "LSTM-DQN",
            "name_full": "LSTM-DQN (Narasimhan et al., 2015)",
            "brief_description": "A reinforcement-learning agent that processes narrative text with an LSTM to produce a state representation used by a DQN for action selection in text-based games.",
            "citation_title": "Language understanding for textbased games using deep reinforcement learning",
            "mention_or_use": "mention",
            "agent_name": "LSTM-DQN",
            "agent_description": "Deep RL agent that encodes narrative observations with an LSTM to produce a compact state representation which is fed to a DQN-style action selector; the recurrent network provides temporal context of recent observations.",
            "game_or_benchmark_name": "Text-based games (related work)",
            "task_description": "Learn to act in text-based game environments by mapping textual observations to actions with RL.",
            "uses_memory": true,
            "memory_type": "recurrent hidden-state (working/short-term memory)",
            "memory_implementation_details": "Uses an LSTM to process sequences of narrative text; the LSTM hidden state encodes recent history and functions as a working memory / state representation for the policy network (DQN).",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_performance_comparison": false,
            "memory_benefits": "Recurrent encoding enables the agent to build a representation of the current state from text history rather than a single observation, improving capacity to interpret temporally distributed cues (described as the motivation in related work).",
            "memory_limitations_or_failures": "No empirical comparisons in this paper; related work notes partial observability makes single-step observation insufficient, motivating recurrence.",
            "uuid": "e3261.2",
            "source_info": {
                "paper_title": "NAIL: A General Interactive Fiction Agent",
                "publication_date_yy_mm": "2019-02"
            }
        },
        {
            "name_short": "LSTM-DRQN",
            "name_full": "LSTM-DRQN (Yuan et al., 2018)",
            "brief_description": "An extension that adds a second-level recurrence over states (Deep Recurrent Q-Network) to enable reasoning over longer temporal context, demonstrated to improve reasoning over visited locations.",
            "citation_title": "Counting to explore and generalize in text-based games",
            "mention_or_use": "mention",
            "agent_name": "LSTM-DRQN",
            "agent_description": "Deep RL architecture adding recurrence over state representations (hierarchical recurrence) to capture longer-range dependencies across visited locations; uses recurrence to improve partial-observability handling.",
            "game_or_benchmark_name": "Text-based games (related work)",
            "task_description": "Improve exploration and generalization in text-based games by leveraging recurrence over states to capture longer-term context.",
            "uses_memory": true,
            "memory_type": "hierarchical recurrence / extended recurrent hidden-state (longer-term working memory)",
            "memory_implementation_details": "Adds a second level of recurrence over the state representations so that the policy can condition on a longer history of visited locations and past states; implemented as recurrent networks across time steps/states.",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_performance_comparison": false,
            "memory_benefits": "Reported (in the cited work) to permit reasoning over previously visited locations and improve exploration/generalization; paper cites improved ability to reason over locations visited in the past.",
            "memory_limitations_or_failures": "No numerical results presented in this NAIL paper; potential limitations include vanishing memory for very long horizons and reliance on sufficient training signal.",
            "uuid": "e3261.3",
            "source_info": {
                "paper_title": "NAIL: A General Interactive Fiction Agent",
                "publication_date_yy_mm": "2019-02"
            }
        },
        {
            "name_short": "Graph-based RL (Ammanabrolu & Riedl)",
            "name_full": "Playing text-adventure games with graph-based deep reinforcement learning",
            "brief_description": "End-to-end learned agent that represents game state as a dynamic knowledge graph and uses that graph as the agent's observation/state representation for policy learning.",
            "citation_title": "Playing text-adventure games with graph-based deep reinforcement learning",
            "mention_or_use": "mention",
            "agent_name": "Graph-based deep RL agent",
            "agent_description": "Learns an end-to-end policy for text-adventure games while constructing and using a knowledge graph representation of the environment as state input to the policy; the graph captures entities and relations from text.",
            "game_or_benchmark_name": "Text-adventure games (related work)",
            "task_description": "Learn to act in text-adventure games using a learned policy that conditions on an evolving knowledge-graph state representation.",
            "uses_memory": true,
            "memory_type": "external structured knowledge graph (learned and used as state representation)",
            "memory_implementation_details": "Constructs and maintains a dynamic knowledge graph extracted from text observations; the graph is used as input to the policy network (graph-based features) and is updated as the agent observes new text and takes actions.",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_performance_comparison": false,
            "memory_benefits": "Graph state representation provides structured memory of entities and relations, enabling better reasoning about objects and their relations compared to bag-of-words or flat encodings (as argued in the cited work).",
            "memory_limitations_or_failures": "Not evaluated within this NAIL paper; limitations in original work may include difficulty extracting correct relations from noisy text and overhead in graph construction.",
            "uuid": "e3261.4",
            "source_info": {
                "paper_title": "NAIL: A General Interactive Fiction Agent",
                "publication_date_yy_mm": "2019-02"
            }
        },
        {
            "name_short": "BYU'16 Agent",
            "name_full": "BYU Agent (2016) / Fulda et al.",
            "brief_description": "Agent that uses word-embedding affordance extraction to propose verbs applicable to objects and then exhaustively enumerates possible actions; less efficient in terms of steps required.",
            "citation_title": "What can you do with a rock? affordance extraction via word embeddings",
            "mention_or_use": "mention",
            "agent_name": "BYU Agent",
            "agent_description": "Uses word-embedding relationships (affordance extraction) to infer which verbs are likely applicable to which objects and then enumerates candidate actions exhaustively for testing in IF games.",
            "game_or_benchmark_name": "Parser-based IF games (related work)",
            "task_description": "Generate valid actions by combining likely verbs (from embeddings) with objects and test them in the game.",
            "uses_memory": false,
            "memory_type": null,
            "memory_implementation_details": "",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_performance_comparison": false,
            "memory_benefits": "",
            "memory_limitations_or_failures": "Exhaustive enumeration is less efficient (more in-game steps required); no explicit memory mechanism used as described in this paper.",
            "best_practices_or_recommendations": "",
            "uuid": "e3261.5",
            "source_info": {
                "paper_title": "NAIL: A General Interactive Fiction Agent",
                "publication_date_yy_mm": "2019-02"
            }
        },
        {
            "name_short": "Golovin",
            "name_full": "Golovin Agent (Kostka et al., 2017)",
            "brief_description": "Agent that generates actions using a large predefined set of command patterns and uses specialized generators for common tasks; uses an RNN to score likely interactable objects.",
            "citation_title": "Text-based adventures of the golovin AI agent",
            "mention_or_use": "mention",
            "agent_name": "Golovin",
            "agent_description": "Generates commands from a large set of predefined patterns extracted from walkthroughs/tutorials and uses specialized command generators (fighting, exploring, inventory management); an RNN ranks objects likely to be interactable.",
            "game_or_benchmark_name": "Parser-based IF games (related work)",
            "task_description": "Efficiently generate and prioritize candidate commands for interactive fiction play.",
            "uses_memory": false,
            "memory_type": null,
            "memory_implementation_details": "",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_performance_comparison": false,
            "memory_benefits": "",
            "memory_limitations_or_failures": "No explicit memory structure is described in this paper; limited examination/action balance compared to NAIL (Golovin uses fewer 'examine' actions).",
            "best_practices_or_recommendations": "",
            "uuid": "e3261.6",
            "source_info": {
                "paper_title": "NAIL: A General Interactive Fiction Agent",
                "publication_date_yy_mm": "2019-02"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Playing text-adventure games with graph-based deep reinforcement learning",
            "rating": 2
        },
        {
            "paper_title": "Language understanding for textbased games using deep reinforcement learning",
            "rating": 2
        },
        {
            "paper_title": "Counting to explore and generalize in text-based games",
            "rating": 2
        },
        {
            "paper_title": "What can you do with a rock? affordance extraction via word embeddings",
            "rating": 1
        },
        {
            "paper_title": "Text-based adventures of the golovin AI agent",
            "rating": 1
        },
        {
            "paper_title": "Learning how not to act in text-based games",
            "rating": 1
        }
    ],
    "cost": 0.013765499999999998,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>NAIL: A General Interactive Fiction Agent</p>
<p>Matthew Hausknecht 
Microsoft Research AI</p>
<p>Ricky Loynd riloynd@microsoft.com 
Microsoft Research AI</p>
<p>Greg Yang gregyang@microsoft.com 
Microsoft Research AI</p>
<p>Adith Swaminathan 
Microsoft Research AI</p>
<p>Jason D Williams 
Microsoft Research AI</p>
<p>Apple 
Microsoft Research AI</p>
<p>NAIL: A General Interactive Fiction Agent</p>
<p>Interactive Fiction (IF) games are complex textual decision making problems. This paper introduces NAIL, an autonomous agent for general parser-based IF games. NAIL won the 2018 Text Adventure AI Competition, where it was evaluated on twenty unseen games.</p>
<p>Introduction</p>
<p>Interactive Fiction games are rich simulation environments where players issue text commands to control their character and progress through the narrative. Unlike modern video games, there are no graphics; text is the sole modality of interaction. Of the varieties of IF games, this paper is concerned with parser-based IF games, environments in which the player may issue arbitrary textual commands which the game's parser attempts to interpret and execute. Despite this daunting interface, parser-based IF games were highly successful in the early 1980s. Classic games like Zork ( Figure 1) and Hitchhiker's Guide to the Galaxy sparked the imaginations of many and created a community of IF enthusiasts who continue to play and create new games to this day.</p>
<p>As a testbed for autonomous agents, IF games promote natural language understanding, commonsense reasoning, problem solving, and planning. Formally, IF games can be understood as Partially Observable Markov Decision Processes (POMDPs), since they are governed by an underlying system but provide only partial observations of the underlying game state. Game playing agents need to be capable of generating valid actions that make sense in the context of the current story. These actions often take the form of 1) information gathering about the player's surroundings, 2) interaction with nearby objects or people, and 3) navigation between game locations. In return for solving puzzles, the player is rewarded with game score that quantifies advancement through the story.</p>
<p>IF games present several unique challenges to learning agents: First, IF games feature a combinatorial language-based action space. Learning agents have been extensively studied in both discrete and continuous action spaces, but not the repeated discrete space defining IF actions. Second, IF games expect the player to understand how to interact with everyday objects like doors and mailboxes. This form of commonsense reasoning is difficult for learning agents lacking embodiment. Finally, IF games are extremely partially observable -they commonly feature tens to hundreds of unique locations, and the player only receives the description of its current location. Humans often construct a maps to remember how to navigate between rooms and keep track of which objects are in each location. For these reasons, learning agents that excel in graphical video games aren't directly applicable to IF games. Instead, a new type of agent is needed. NAIL (Navigate, Acquire, Interact and Learn) is an autonomous agent designed to play arbitrary human-made IF games. NAIL competed in the 2018 Text-Based Adventure AI Competition (Atkinson et al., 2019), where it was evaluated on twenty unknown IF games, with only one-thousand steps of interaction per game. To excel in this context, NAIL needed to be truly general, with the capability of encountering a new game and quickly accruing as much score as possible. For this reason, we designed NAIL with strong heuristics for exploring the game, interacting with objects, and building an internal representation of the game world. The remainder of this paper describes NAIL's architecture, development process, and innovations.</p>
<p>Related Work</p>
<p>NAIL draws inspiration from previous generations of IF game-playing agents:</p>
<p>BYU'16 Agent (Fulda et al., 2017) analyzes relationships in word-embedding space (Mikolov et al., 2013) to reason about which objects are possible to interact with and which verbs can likely be paired with each interactive object. Armed with this knowledge, the agent exhaustively enumerates possible actions. While effective, this approach is less efficient in terms of the number of in-game steps required.</p>
<p>Golovin (Kostka et al., 2017) generates actions using a large set of predefined command patterns extracted through walkthroughs, tutorials, and decompilation of games. Additionally, it employs specialized command generators for common tasks such as fighting, collecting items, managing inventory, and exploring. An recurrent neural network is used to identify the objects most likely to be interactable in a scene's description.</p>
<p>CARL (Atkinson et al., 2019) was developed by the creators of the BYU Agent and uses skip-thought vectors (Kiros et al., 2015) as representations of the observation text. These vectors are classified as either containing location information or relating to the effects of an action. For those containing location information, commands are generated by extracting nouns from the text and using the BYU Agent's word embedding approach to find likely verbs. A hash table is used to keep track of visited states and actions to avoid repetition.</p>
<p>There is also a growing body of work studying reinforcement learning agents in textual environments: LSTM-DQN (Narasimhan et al., 2015) introduced the idea of building a representation for the current state by processing narrative text with a recurrent network. Building on this idea, LSTM-DRQN (Yuan et al., 2018) added a second level recurrence over states, which was demonstrated to give the agent an ability to reason over locations visited in the past. In the realm of choice-based games, He et al. (2016); Zelinka (2018) explored architectural choices for scoring different pre-defined actions. Another recent innovation included training a separate network to eliminate consideration of invalid actions (Haroush et al., 2018). Finally, Ammanabrolu and Riedl (2018) demonstrated end-to-end learning using an architecture that represents game state as a knowledge graph.</p>
<p>Response p(success) I didn't understand that sentence. 0 You can't go that way. 0 You can't use multiple objects with that verb.</p>
<p>.0008 You try to push past, but vines block your way.</p>
<p>.0009 I don't know the word xyzzy.</p>
<p>.1145 Even with a lamp, you would not chance these stairs in the darkness. .6366 The gentle tapping sounds again.</p>
<p>.9387 Help! You hurtle through the cave opening! .9835 The grating opens.</p>
<p>.9998 The cyclops seems somewhat agitated.</p>
<p>.9998 Table 1: Validity Detector predicts if the game's response to an action indicates success or failure.</p>
<p>Predictions are only concerned with whether or not the action was recognized and effected change in the game. Responses are classified as successful even if they indicate that the player has done something wrong or is likely to die.</p>
<p>Architecture</p>
<p>NAIL was designed with a modular architecture that decouples the decision making from the knowledge acquisition. At the highest level, NAIL utilizes a set of Decision Modules to interact with the game and accumulates information in its knowledge graph. Further separation is achieved by decomposing the overall decision making problem into specialized task-specific Decision Modules, which take control of the agent to perform a particular job when the right context arises. For example, the darkness decision module activates in response to game narratives that include key phrases "pitch black" and "too dark too see," and attempts to provide light by issuing a "turn on" command. Separating decision making from knowledge acquisition enables NAIL's capabilities to be augmented by adding more decision modules while being able to inspect and debug the information accumulated in the knowledge graph. Figure 2 depicts NAIL's architecture, which we discuss in detail below.  </p>
<p>Validity Detector</p>
<p>The game's responses to the agent's actions provide a continual stream of feedback. NAIL processes game responses to determine whether an action was 1) unrecognized by the game, 2) recognized but failed, or 3) recognized and successful. This information is crucial to determining how the Knowledge Graph is populated with Locations and Entities.</p>
<p>The Validity Detector, a FastText (Joulin et al., 2017) classifier, predicts whether the game's response to an action indicates success or failure. The Validity Detector was trained on a manually created dataset of 1337 successful responses and 705 failed responses. Despite the small size of the training dataset, classifier performance was surprisingly good, as shown by the example predictions in Table  1. Many games use a common set of failure responses, simplifying the classification task.</p>
<p>The Validity Detector underlies each of NAIL's core components: it is used by Decision Modules to decide when actions have succeeded and it serves as a gatekeeper to the knowledge graph by disallowing the creation of invalid Entities and Locations.</p>
<p>Decision Modules</p>
<p>NAIL is composed of many decision modules (Fig. 2) which can be thought of as sub-policies designed to accomplish individual tasks. NAIL's core decision modules are the Examiner, Hoarder, Interactor, and Navigator. Respectively they are responsible for identifying relevant objects, acquiring objects, interacting with identified objects, and changing locations. Before delving into the specifics of these core modules, we first discuss the process for synchronizing control between modules.</p>
<p>Choosing Between Decision Modules: Eagerness</p>
<p>Each decision module has the ability to take control of the agent and generate textual actions. Since only a single decision module can have control over the agent at any given timestep, NAIL employs a winner-take-all competition in which decision modules report how eager they are to have control over the agent given the current context. Game context consists of various factors such as information contained within the game narrative and knowledge graph. Different modules are eager in different contexts: the Examiner module is eager to take control when a new location is discovered, while the Interactor is most eager when new objects are added to the knowledge graph. By convention, eagerness values are real numbers constrained to the range (0, 1).</p>
<p>The most eager decision module generates actions until it relinquishes control. Currently there is no mechanism for decision modules to interrupt each other, as this would require the interrupted module to resume control in a different context than before the interrupt. Instead, modules are designed to accomplish many short tasks and relinquish control so as to provide more eager modules many chances to take control.</p>
<p>Examiner Decision Module</p>
<p>One of the fundamental steps in playing IF games is reading the current narrative and deciding which parts of the surroundings are capable of being interacted with. This is the job of the Examiner, a decision module that outputs a high eagerness upon visiting a new location 4 and seeks to identify objects to add to the knowledge graph. Identification of objects proceeds in two steps: first, candidate noun phrases are extracted from the narrative text using Spacy (Honnibal and Montani, 2017). Second, "examine X" commands are issued for each of the candidate noun phrases. If the game's response to the examine command indicates the object is recognized (often in the form of a longer description of that object) the Examiner will add the object to the knowledge graph. Conversely if the response indicates the game doesn't recognize the object, it is not added to the knowledge graph and will not be interacted with in the future. The Validity Detector is used to decide which responses are valid.</p>
<p>Hoarder Decision Module</p>
<p>Acquiring objects such as weapons, treasures, and consumables is a necessity in nearly all IF games. The Hoarder outputs the highest possible eagerness upon reaching a new location. After taking control it issues a single "take all" command. Many games support this shorthand and will reward the player by transporting all portable objects directly into the player's inventory. 5 For example, in Hitchhiker's Guide to the Galaxy:  Figure 3: The Examiner decision module is responsible for extracting game objects from narrative text and adding them to the knowledge graph. Subsequent modules like the Interactor use the objects in the knowledge graph to generate further actions.</p>
<blockquote>
<p>take all telephone: You lunge for it, but the room spins nauseatingly away. flathead screwdriver: It slips through your fumbling fingers and hits the carpet with a nerve-shattering bang. toothbrush: You lunge for it, but the room spins nauseatingly away. your gown: Luckily, this is large enough for you to get hold of. You notice something in the pocket.</p>
</blockquote>
<p>The response indicates four valid objects are present, of which we succeeded in acquiring only the gown. The Hoarder uses a custom parser to add all detected objects to the knowledge graph and the successfully acquired objects to the player's inventory. The Validity Detector decides whether a response indicates the item has been successfully acquired.</p>
<p>Interactor Decision Module</p>
<p>A core challenge of IF games is deciding how to effectively interact with the objects at the current location. Exhaustive search is rarely tractable as even a restricted subset of the English language can produce a combinatorially large set of possible actions. To narrow this search, NAIL uses a 5-gram language model (LM), trained on 1.5 billion n-grams collected from web page titles, 6 to impose a prior over generated actions. As shown in Figure 4, this prior gives preference to common, sensible actions like "open the door" or "light the torch" over less reasonable actions like "light the door" or "open the torch." The Interactor works through the prioritized list of actions in descending order, executing a single action, judging whether it succeeded, and reporting an eagerness score proportional to how highly ranked the next action is.</p>
<p>In more detail, starting from the set of objects present in the player's current location, the Interactor generates an unranked list of candidate actions. These candidate actions are enumerated from two templates: a verb-object template and a verb-object-preposition-object template. 7 Verb-object commands use verbs selected from a manually curated list of 561 commonly recognized IF-game verbs. These verbs are paired with the objects present at the current location and inventory; the LM is then used to compute the joint probability of each generated verb-object pair.</p>
<p>Verb-object-preposition-object commands are also created by iterating over objects x, y present at the current location or in the player's inventory. Ten fixed templates (such as put x in y and open x with y) provide verbs and prepositions for each object pair. These candidate commands are then ranked along with the verb-object actions according to their LM-based joint probabilities. 8 Figure 4: The Interactor ranks candidate actions according to their log-probabilities. These logprobabilities are proportional to the Interactor's eagerness.</p>
<p>Navigator Decision Module</p>
<p>The Navigator is invoked to move the player to a new location. Outputting a consistently low eagerness, the Navigator is intended to activate only after the Hoarder, Examiner, and Interactor have exhausted the useful actions at the current location. After gaining control, the Navigator applies one of the twelve canonical navigation actions: North, South, West, East, Northwest, Northeast, Southwest, Southeast, Up, Down, Enter, and Exit. To avoid repeating failed navigation actions, the Navigator keeps track of all previously attempted navigational actions from each location, and prefers actions that have either not yet been attempted or have succeeded in changing locations in the past. Additionally, since location descriptions frequently tell the player where exits are (e.g. "there is an open door to the west"), the Navigator performs a simple string match and prioritizes directional actions that are present in the description.</p>
<p>After attempting a navigational action the Navigator must decide whether or not the action succeeded and a new location was reached. To do this, it first checks the knowledge graph to see if there are any locations whose textual description matches the game's response. If no known locations are found, the Navigator issues a "look" command and compares the resulting description to the description of the previous location. High similarity between location descriptions indicates that the move action likely failed; low similarity indicates that a new location has likely been discovered.</p>
<p>A fuzzy string match (FuzzyWuzzy, 2011) between location descriptions is necessary since many games randomly alter location descriptions. For example, in the forested locations of Zork 1, the game will occasionally append "You hear in the distance the chirping of a song bird" to the location's description. Similarly, dropped objects will be reported in a location's description.</p>
<p>Finally, to finish a location change, the Navigator updates the Knowledge Graph by adding a new location and connecting it to the previous location. This step results in an ad-hoc map of the game world. In future work, this map could be used to efficiently revisit previous locations or to guide future exploration.</p>
<p>Specialized Decision Modules</p>
<p>NAIL uses several highly specialized decision modules, mainly ensure the agent doesn't get stuck while playing a game.</p>
<p>• Darkness: Emits a "turn on" action in response to observation text containing phrases "pitch black" or "too dark to see".</p>
<p>• Restart: Emits a "restart" action to restart the game in response to an observation containing "restart", "restore", and "quit" being observed.</p>
<p>• Yes-No: Randomly emits either "Yes" or "No" in response to common game prompts asking the player to answer a yes-no question.</p>
<p>• YouHaveTo: Attempts to take advantage of in-game hints by using a set of custom regular expressions to parse suggested actions from the game's response. For example: "You'll have to get out of bed first" will emit "get out of bed" as the next action. • Idler: As a fallback when no other decision module is eager for control, the Idler randomly composes actions from hundreds of common verb phrases combined with nearby objects. This exhaustive exploration over possible actions sometimes produces combinations that can get the agent unstuck.</p>
<p>Due to the flexibility of NAIL's architecture it's quite easy to create new decision modules to handle different situations.</p>
<p>Decision Modules as Python Generators</p>
<p>A key design choice was to implement decision modules as Python generators. Using Python's yield to generate actions allows a straight-line implementation of the logic within each DM. Consider the case of a MorningRoutine decision module. Using a generator, the implementation is straightforward:</p>
<p>class In other words, generators allow the agent to be written as if it has direct access to the environment's step function when, in reality, it is being invoked as a library and does not have direct access to the environment. This is commonly the case in competition settings.</p>
<p>Knowledge Graph</p>
<p>NAIL accumulates knowledge about the game world as the agent interacts with the game. Specifically, NAIL's knowledge graph keeps track of objects, past interactions, locations, connections between locations, object states, and unrecognized words. This information is used by decision modules to compute eagerness and generate actions. In turn, the decision modules modify the knowledge graph to reflect the consequences of their actions.</p>
<p>At the top level, the knowledge graph is organized as follows:</p>
<p>• Current Location: Player's current location, updated by the Navigator upon successful movement.</p>
<p>• Locations: List of all discovered locations.</p>
<p>• Connection Graph: Graph of connections between discovered locations. Updated by the Navigator upon successful movement. • Inventory: List of objects in the player's inventory. Updated by any decision module that issues take/drop commands. • Unrecognized Words: List of words not recognized by the game. NAIL avoids taking actions containing any unrecognized words. Updated after each action by matching the game's response against a custom list of unrecognized responses (e.g. "That's not a verb I recognise.").</p>
<p>Each Location contains the following information:</p>
<p>• Name: The short name of the location (e.g. "West of House").</p>
<p>• Description: The full-length description of the location, as returned by a "look" command. Populated by the Navigator upon discovering the location. • Entities: List of entities (interactive objects or characters) present at that location. Populated by the Examiner. • Action Record: List of all actions NAIL has attempted at this location along with the game's response and NAIL's estimate of how likely the response indicates success. This information is optionally used by decision modules to avoid repeating actions that previously failed.</p>
<p>Finally, each Entity contains the following information:</p>
<p>• Names: List of discovered names for this entity. Many games are flexible when referring to entities -e.g. the Brass Lantern in Zork may be alternatively referred to as "lantern" or even just "brass." • Description: Long-form description of the entity -as given by "examine entity." Populated by Examiner. • Entities: List of contained entities -e.g. in the case of a container such as a chest.</p>
<p>• State: Keeps track of a list of manually-defined states: Open/Closed, Locked/Unlocked, On/Off. Also keeps track of whether the item has been used -in the case of consumable items. • Attributes: A manually-defined list of object attributes: Openable, Lockable, Switchable.</p>
<p>Attributes inform which verbs are expected to succeed on a particular object.</p>
<p>Beyond its use to Decision Modules, the knowledge graph also provides an interpretable representation of NAIL's understanding of the game. By comparing the knowledge graph to the published map for well documented games like Zork, it was possible to track down bugs in NAIL's decision modules.</p>
<p>Encoding Action Effects</p>
<p>The core interaction for many games relies heavily on a small set of common actions -take, drop, turn on, push, pull, go north, etc. Furthermore, the effects of these common actions are reasonably general across games. For example, the take action, if successful, will move an object from the player's current location to the player's inventory.</p>
<p>For these common actions, the expected changes to the knowledge graph are manually implemented and associated with the action. This association allows the effects of the action to be implemented once, and subsequently used by many different decision modules. For non-common actions, we do not make any changes to the knowledge graph, aside from recording the action and its probability of success. In future work, it may be possible to learn the effects of uncommon actions.</p>
<p>Text-Adventure Competition</p>
<p>To meet the needs of generality and efficient exploration of unseen games, we developed and evaluated NAIL on a set of fifty-six IF games (full list in Table 3) using the Jericho (2018) Learning Environment.</p>
<p>Jericho was a ideal learning environment because of its ability to introspect and provide ground truth knowledge of the game state. Our primary metric was normalized game score averaged over all games. However, due to the sparse rewards in most games, improvements to the NAIL agent often weren't reflected in game score. To address this problem, we created Dependencies, a fine-grained metric that quantifies progress towards the first point of score on each game. Specifically this metric manually defines the locations needed to be visited, the items that need to be acquired, entities that need to be detected, and the key actions that must be performed. The following snippet shows the Dependencies for the game Balances:</p>
<p>analyzer To satisfy the Entity Dependency (EntDep), the agent must detect an Entity called "furniture" or "wooden furniture" at Location 49. This dependency is verified by using Jericho's introspection feature to detect when the agent visits the location corresponding to world object number 49, and looking into the Knowledge Graph for an Entity named furniture at the KG's current Location. The Action Dependency (ActDep) "search furniture" is satisfied upon receiving a new observation that contains the text "you come across an old box." This is verified simply by monitoring the incoming observations through the event stream. Simple text matching is sufficient to recognize the results of key actions that progress the game. The Location Dependency (LocDep) is satisfied when the agent visits location number 53 (aka Pocket Valley). Locations are verified by using Jericho to inspect the game and return the world object number corresponding to the player's actual location. Finally the Inventory Dependency (InvDep) is satisfied when the world object number 62 exists in the player's inventory. This is verified using Jericho to access the list of world objects belonging to the player. We implemented Dependencies for each of the fifty-six games in the Jericho suite. Figure 5 shows that these Dependencies help quantify progress and more importantly, help pinpoint exactly which parts of the agent need to be improved: if the agent is failing ActDeps, then perhaps the Interactor needs to use a different set of verbs, conversely if NavDeps are failing, a bug may have entered the Navigator.</p>
<p>Results</p>
<p>NAIL won first place in the 2018 Text-Based Adventure AI Competition Atkinson et al. (2019), where it was evaluated on a set of twenty unknown parser-based IF games. Designed to assess an agent's ability to achieve human-like performance, the competition only allowed one thousand steps of interaction per game, comparable to a few hours of playtime for a human. Each agent's scores were normalized by the maximum possible score per game, then averaged over all games to obtain the final scores shown in Table 2 Table 2: Performance on the test set of 20 games in (unless stated otherwise) 1000 time steps per game. "% completion" is the average score percentage an agent achieved over all games and runs; "% non-zero" is the percentage of games in which an agent achieved any score, averaged over all runs. Standard deviations (SD), wherever given, refer to 10 runs over all games. Where they are not given, only 1 run could be completed. </p>
<p>Analysis</p>
<p>As apparent from the competition results, agents have a long way to go towards solving unseen games. However, the progress over the past three years of the competition is encouraging. NAIL advances the state-of-the-art in comparison to other agents in several ways:</p>
<ol>
<li>
<p>NAIL maintains an explicit Knowledge Graph which tracks relevant game information and builds a map of the game world. The information contained within is both used and populated by decision modules as the game progresses. This knowledge representation is human-interpretable and debuggable given ground-truth information about the game.</p>
</li>
<li>
<p>Unlike prior agents, NAIL leverages the intuition that interactive objects can be examined, and extensively uses its Examiner decision module as a gatekeeper for deciding which objects are worth interacting with. Across the training set of 56 games, 26% of NAIL's actions are Examines, versus 8% for CARL, 2% for Golovin, and only 0.2% for BYU. By exhaustively examining candidate objects, NAIL can focus actions on only the objects that are recognized by the game's parser.</p>
</li>
<li>
<p>NAIL is the first agent to use a Validity Detector, a learned model, to decide whether actions have succeeded. This model is key to correctly populating the Knowledge Graph and is used extensively by individual decision modules to reason about the success of their actions.</p>
</li>
</ol>
<p>To further understand NAIL's performance, we selectively ablate NAIL's decision modules. Figure 6 shows the average normalized score of NAIL across Jericho games as decision modules are sequentially added. Without any decision modules, NAIL is capable of only performing the "look" command and gets a score of 0.53%, since some games start with small positive score. Adding the Navigator allows the agent to locomote and create a map of the game world. Using this module, scores go up to 1.2%, primarily due to games that reward visiting new locations. Next, the Hoarder issues "take all" commands at each new location it visits to collect items. Scores increase to 1.6% since many games reward the player for acquiring treasures or key items. Adding the Examiner module allows the agent to more deeply search the environment and reason about which objects are interactive, boosting the score to 2.6%. Leveraging the objects identified by the Examiner, the Interactor uses its language model to generate likely actions for application to those objects. These interactions are key to solving puzzles and boost the score to 3.5%. Together, these modules make up NAIL's core and account for the lion's share of the score. A 0.2% gain is added by the Idler which exhaustively generates common IF actions when no other module is eager to take control. Finally, the specialized decision modules together contribute 0.03%.</p>
<p>Discussion</p>
<p>Interactive Fiction games are rich narrative adventures that challenge even skilled human players. We presented NAIL, an open-source, 9 competition-winning IF agent. More than just a baseline for future comparison, we expect that NAIL's extendable architecture can serve as a starting point for future IF agents.    : Analysis of walkthroughs reveals that over 90% of actions are one and two words in length. Among these actions, there were 530 unique verbs used, but the 100 most common account for 95% of all actions.</p>
<p>A Analysis of Parser-Based IF Games</p>
<p>Perhaps the least friendly user interface of all time, parser-based IF games accept any natural language string as input, and use a parser to interpret the player's action. The difficulty of using the interface stems from the fact that many natural language strings are not recognized by the parser and result in failed actions. For example, many games will produce canned responses such as "I don't know the word x." or "You can't y." Since the parser is hidden, players often need to read a manual and experiment with the game to discover what types of actions are recognized. Fortunately, parsers for many popular IF games are similar in the types of actions they accept and the responses they produce for unrecognized actions. This standardization reduces the burden on learning agents, as they do not have to generate arbitrarily complex natural language.</p>
<p>To better understand the complex action space of parser-based games, we analyzed human-created walkthroughs for 188 games. From these walkthroughs we extracted 20,263 natural language actions. As shown in Figure 7 (left), most actions are one or two words in length, with a maximum of five words 10 . Further analysis reveals that these actions have extensive structure: single-word actions are often shortcuts provided by the game for navigation ("north" moves the player north), examination ("look" describes the current location), and item management ("inventory" lists the objects carried). Two-word actions take the form of verb-object ("climb tree", "eat apple"). Three-word actions are commonly verb-preposition-object ("search under bed"), but can occasionally take on different patterns ("turn dial left"). Though uncommon, four-word actions include the pattern verb-objectpreposition-object ("unlock chest with key", "ask bolitho about ghost"). Five-word actions commonly used multiple words to describe an object: "attack troll with brass lantern."</p>
<p>The verb distribution shows that the majority of actions stem from a compact set of verbs focused on navigation, item acquisition, and environment examination. However, the distribution in Figure  7 (right) has a long tail corresponding to a diverse set of verbs used to interact with objects in the environment. The nouns used in these commands are highly varied from game to game. Some games even go so far as to create their own proper nouns for special objects and spells. Such words are not in any English dictionary and need to be remembered from the observation text.</p>
<p>Altogether, this analysis indicates that the action generation task in IF games is significantly more structured than generating free-form dialog. Thus, while learning agents still need to understand arbitrary free-form text presented by the game, they only need to generate a compact subset of language.</p>
<p>Figure 1 :
1Interactive fiction games made Infocom the dominant computer game company of the early 1980s. Right: Transcript of Zork, with player actions in green.</p>
<p>Figure 2 :
2NAIL consists of multiple Decision Modules, which are designed to perform specialized tasks. One decision module at a time may be active. The active module is responsible for generating actions and updating the knowledge graph with the effects of its actions. The knowledge graph builds a structured representation of the objects, locations, and interactions observed in the game so far and is used by the decision modules to select actions.</p>
<p>. deps = [ EntDep ([ ' wooden furniture ' , ' furniture '] , loc =49) , ActDep ( ' search furniture ' , ' you come across an old box ') , LocDep ( ' pocket valley ' , loc =53) , EntDep ([ ' pile of oats ' , ' oats ' , ' pile '] , loc =53) , ActDep ( ' search oats ' , ' You find a shiny scroll ! ') , InvDep ( ' shiny scroll ' , 62) ]</p>
<p>Figure 5 :
5Development of NAIL on fifty-six human-made IF games: The blue line tracks normalized game score while the orange shows the percentage of dependencies that are satisfied. The x-axis tracks the 32 commits made to NAIL after the implementation of game-specific Dependencies.</p>
<p>Figure 6 :
6Ablation of decision modules: Largest performance increases come from NAIL's core decision modules: the Navigator, the Examiner, and the Interactor.</p>
<p>Figure 7
7Figure 7: Analysis of walkthroughs reveals that over 90% of actions are one and two words in length. Among these actions, there were 530 unique verbs used, but the 100 most common account for 95% of all actions.</p>
<p>Without a generator the logic for the same DM becomes quite a bit more complex:MorningRoutine ( DecisionModule ): 
def take_control ( self ): 
obs = yield 
obs = yield ' get out of bed ' 
obs = yield ' turn on light ' 
obs = yield ' brush teeth ' </p>
<p>class MorningRoutine ( DecisionModule ): 
def <strong>init</strong> ( self ): 
self . out_of_bed = False 
self . turned_on_light = False 
self . brushed_teeth = False </p>
<p>def take_control ( self , obs ): 
if not self . out_of_bed : 
self . out_of_bed = True 
return ' get out of bed ' 
elif not self . turned_on_light : 
self . turned_on_light = True 
return ' turn on light ' 
elif not self . brushed_teeth : 
self . brushed_teeth = True 
return ' brush teeth ' </p>
<p>.Agent 
% completion % non-zero </p>
<p>M 
SD 
M 
SD </p>
<p>BYUAGENT 2016 
0.79 
-
15 
-
GOLOVIN 
1.45 
0.09 
31 3.94 
CARL (BYUAGENT 2017) 1.59 
-
30 
-
NAIL 
2.56 
0.33 45.5 2.84 </p>
<p>GOLOVIN (100 steps) 
0.99 
0.24 17.5 3.53 
NAIL (100 steps) 
0.95 
0.19 
26 2.11 
GOLOVIN (10k steps) 
1.44 
0.10 32.5 4.25 </p>
<p>RandomAgent 
1.66 
0.15 
34 2.11 </p>
<p>Table duplicatedfromAtkinson et al. (2019).</p>
<p>Table 3 :
3Raw scores for Jericho-supported games, averaged over sixteen runs. The Random agent selects actions from the set north/south/east/west/up/down/look/inventory/take all/drop/yes.
More precisely upon a new Location object being added to the knowledge graph. 5 For the games that don't support the take all command, objects may still be acquired individually using the Interactor decision module.
Although language used in web titles is definitely not the same as actions in IF games, in terms of both speed and perplexity, LMs trained on titles have been reported to outperform LMs trained on document body text on general information retrieval tasks(Wang et al., 2010).7  As discussed in Appendix A, the vast majority of actions taken by human players can be expressed by one of these two templates.
LM probabilities for two-word actions are nearly always higher than four-word actions. Fortunately, as shown inFigure 7, humans also prefer shorter actions.
All actions with six words or longer were reducible to equivalent shorter actions.
AcknowledgementsThe authors would like to thank Marc-Alexandre Côté, Xingdi Yuan, and Alekh Agarwal for their comments and suggestions. Additional thanks to Shuohang Wang for testing models for learning priorities over examined objects.
Playing text-adventure games with graph-based deep reinforcement learning. CoRR. Prithviraj Ammanabrolu, Mark O Riedl, abs/1812.01628Prithviraj Ammanabrolu and Mark O. Riedl. Playing text-adventure games with graph-based deep reinforcement learning. CoRR, abs/1812.01628, 2018. URL http://arxiv.org/abs/1812. 1628.</p>
<p>The text-based adventure ai competition. T Atkinson, H Baier, T Copplestone, S Devlin, J Swan, 10.1109/TG.2019.2896017IEEE Transactions on Games. T. Atkinson, H. Baier, T. Copplestone, S. Devlin, and J. Swan. The text-based adventure ai competition. IEEE Transactions on Games, pages 1-1, 2019. ISSN 2475-1502. doi: 10.1109/TG.2019.2896017.</p>
<p>What can you do with a rock? affordance extraction via word embeddings. Nancy Fulda, Daniel Ricks, Ben Murdoch, David Wingate, 10.24963/ijcai.2017/144doi: 10.24963/ ijcai.2017/144IJCAI. Nancy Fulda, Daniel Ricks, Ben Murdoch, and David Wingate. What can you do with a rock? affordance extraction via word embeddings. In IJCAI, pages 1039-1045, 2017. doi: 10.24963/ ijcai.2017/144. URL https://doi.org/1 .24963/ijcai.2 17/144.</p>
<p>Fuzzy string matching in python. Fuzzywuzzy, FuzzyWuzzy. Fuzzy string matching in python. https://github.com/seatgeek/fuzzywuzzy, 2011.</p>
<p>Learning how not to act in text-based games. Matan Haroush, Tom Zahavy, Daniel J Mankowitz, Shie Mannor, Matan Haroush, Tom Zahavy, Daniel J. Mankowitz, and Shie Mannor. Learning how not to act in text-based games, 2018. URL https://openreview.net/forum?id=B1-tVX1Pz.</p>
<p>Deep reinforcement learning with a natural language action space. Ji He, Jianshu Chen, Xiaodong He, Jianfeng Gao, Lihong Li, Li Deng, Mari Ostendorf, ACL. Ji He, Jianshu Chen, Xiaodong He, Jianfeng Gao, Lihong Li, Li Deng, and Mari Ostendorf. Deep reinforcement learning with a natural language action space. In ACL, 2016.</p>
<p>spacy 2: Natural language understanding with bloom embeddings, convolutional neural networks and incremental parsing. Matthew Honnibal, Ines Montani, To appear, 2017. 9 NAIL's source code is available atMatthew Honnibal and Ines Montani. spacy 2: Natural language understanding with bloom embed- dings, convolutional neural networks and incremental parsing. To appear, 2017. 9 NAIL's source code is available at https://github.com/Microsoft/nail_agent. 11</p>
<p>A learning environment for interactive fiction games. Jericho, Jericho, Jericho. Jericho: A learning environment for interactive fiction games. https://github.com/ Microsoft/jericho, 2018.</p>
<p>Bag of tricks for efficient text classification. Armand Joulin, Edouard Grave, Piotr Bojanowski, Tomas Mikolov, EACL. Association for Computational LinguisticsArmand Joulin, Edouard Grave, Piotr Bojanowski, and Tomas Mikolov. Bag of tricks for efficient text classification. In EACL, pages 427-431. Association for Computational Linguistics, April 2017.</p>
<p>Skip-thought vectors. Ryan Kiros, Yukun Zhu, R Ruslan, Richard Salakhutdinov, Raquel Zemel, Antonio Urtasun, Sanja Torralba, Fidler, NIPS. C. Cortes, N. D. Lawrence, D. D. Lee, M. Sugiyama, and R. GarnettCurran Associates, IncRyan Kiros, Yukun Zhu, Ruslan R Salakhutdinov, Richard Zemel, Raquel Urtasun, Antonio Torralba, and Sanja Fidler. Skip-thought vectors. In C. Cortes, N. D. Lawrence, D. D. Lee, M. Sugiyama, and R. Garnett, editors, NIPS, pages 3294-3302. Curran Associates, Inc., 2015. URL http: //papers.nips.cc/paper/595 -skip-thought-vectors.pdf.</p>
<p>Text-based adventures of the golovin AI agent. CoRR, abs/1705.05637. Bartosz Kostka, Jaroslaw Kwiecien, Jakub Kowalski, Pawel Rychlikowski, Bartosz Kostka, Jaroslaw Kwiecien, Jakub Kowalski, and Pawel Rychlikowski. Text-based adventures of the golovin AI agent. CoRR, abs/1705.05637, 2017. URL http://arxiv.org/abs/17 5. 5637.</p>
<p>Efficient estimation of word representations in vector space. Tomas Mikolov, Kai Chen, Greg Corrado, Jeffrey Dean, abs/1301.3781CoRR. Tomas Mikolov, Kai Chen, Greg Corrado, and Jeffrey Dean. Efficient estimation of word representa- tions in vector space. CoRR, abs/1301.3781, 2013. URL http://arxiv.org/abs/13 1.3781.</p>
<p>Language understanding for textbased games using deep reinforcement learning. Karthik Narasimhan, Tejas D Kulkarni, Regina Barzilay, EMNLP. Karthik Narasimhan, Tejas D. Kulkarni, and Regina Barzilay. Language understanding for text- based games using deep reinforcement learning. In EMNLP, pages 1-11, 2015. URL http: //aclweb.org/anthology/D/D15/D15-1 1.pdf.</p>
<p>Multi-style language model for web scale information retrieval. Kuansan Wang, Xiaolong Li, Jianfeng Gao, SIGIR'10. Kuansan Wang, Xiaolong Li, and Jianfeng Gao. Multi-style language model for web scale information retrieval. In SIGIR'10, pages 467-474, 2010. URL https://dl.acm.org/citation.cfm?id= 1835528.</p>
<p>Counting to explore and generalize in text-based games. CoRR, abs/1806.11525. Xingdi Yuan, Marc-Alexandre Côté, Alessandro Sordoni, Romain Laroche, Remi Tachet, Matthew J Combes, Adam Hausknecht, Trischler, Xingdi Yuan, Marc-Alexandre Côté, Alessandro Sordoni, Romain Laroche, Remi Tachet des Combes, Matthew J. Hausknecht, and Adam Trischler. Counting to explore and generalize in text-based games. CoRR, abs/1806.11525, 2018. URL http://arxiv.org/abs/18 6.11525.</p>
<p>Using reinforcement learning to learn how to play text-based games. Mikulás Zelinka, abs/1801.01999Mikulás Zelinka. Using reinforcement learning to learn how to play text-based games. CoRR, abs/1801.01999, 2018. URL http://arxiv.org/abs/18 1. 1999.</p>            </div>
        </div>

    </div>
</body>
</html>