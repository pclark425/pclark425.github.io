<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-957 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-957</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-957</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-23.html">extraction-schema-23</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of systems or methods that use probabilistic symbolic world models (such as PPDDL, PDDL, or belief states) for planning in text-based environments, especially those that integrate uncertainty from large language models.</div>
                <p><strong>Paper ID:</strong> paper-394e3995d2faf542104cb7e6ea43cec204253273</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/394e3995d2faf542104cb7e6ea43cec204253273" target="_blank">PDDLStream: Integrating Symbolic Planners and Blackbox Samplers via Optimistic Adaptive Planning</a></p>
                <p><strong>Paper Venue:</strong> International Conference on Automated Planning and Scheduling</p>
                <p><strong>Paper TL;DR:</strong> This work provides domain-independent algorithms that reduce PDDLStream problems to a sequence of finite PDDL problems and introduces an algorithm that dynamically balances exploring new candidate plans and exploiting existing ones to solve tightly-constrained problems.</p>
                <p><strong>Paper Abstract:</strong> Many planning applications involve complex relationships defined on high-dimensional, continuous variables. For example, robotic manipulation requires planning with kinematic, collision, visibility, and motion constraints involving robot configurations, object poses, and robot trajectories. These constraints typically require specialized procedures to sample satisfying values. We extend PDDL to support a generic, declarative specification for these procedures that treats their implementation as black boxes. We provide domain-independent algorithms that reduce PDDLStream problems to a sequence of finite PDDL problems. We also introduce an algorithm that dynamically balances exploring new candidate plans and exploiting existing ones. This enables the algorithm to greedily search the space of parameter bindings to more quickly solve tightly-constrained problems as well as locally optimize to produce low-cost solutions. We evaluate our algorithms on three simulated robotic planning domains as well as several real-world robotic tasks.</p>
                <p><strong>Cost:</strong> 0.005</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <p class="empty-note">No extracted data.</p>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <p class="empty-note">No potentially relevant new papers extracted.</p>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-957",
    "paper_id": "paper-394e3995d2faf542104cb7e6ea43cec204253273",
    "extraction_schema_id": "extraction-schema-23",
    "extracted_data": [],
    "potentially_relevant_new_papers": [],
    "cost": 0.00520475,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>PDDLStream: Integrating Symbolic Planners and Blackbox Samplers via Optimistic Adaptive Planning</h1>
<p>Caelan Reed Garrett, Tomás Lozano-Pérez, Leslie Pack Kaelbling<br>Computer Science and Artificial Intelligence Laboratory<br>Massachusetts Institute of Technology<br>{caelan, tlp, lpk}@csail.mit.edu*</p>
<h4>Abstract</h4>
<p>Many planning applications involve complex relationships defined on high-dimensional, continuous variables. For example, robotic manipulation requires planning with kinematic, collision, visibility, and motion constraints involving robot configurations, object poses, and robot trajectories. These constraints typically require specialized procedures to sample satisfying values. We extend PDDL to support a generic, declarative specification for these procedures that treats their implementation as black boxes. We provide domain-independent algorithms that reduce PDDLStream problems to a sequence of finite PDDL problems. We also introduce an algorithm that dynamically balances exploring new candidate plans and exploiting existing ones. This enables the algorithm to greedily search the space of parameter bindings to more quickly solve tightly-constrained problems as well as locally optimize to produce low-cost solutions. We evaluate our algorithms on three simulated robotic planning domains as well as several real-world robotic tasks.</p>
<h2>1 Introduction</h2>
<p>Many important planning domains occur in continuous spaces involving complex constraints among variables. Consider planning for an 11 degree-of-freedom (DOF) robot tasked with rearranging blocks. The robot must find a sequence of move, pick, and place actions involving continuous variables such as robot configurations, robot trajectories, block poses, and block grasps that satisfy complicated kinematic, collision, visibility, and motion constraints, which affect the feasibility of the actions. Often, special purpose procedures for evaluating and producing satisfying values for these constraints, such as inverse kinematic solvers, collision checkers, and motion planners, are known.</p>
<p>We propose PDDLStream, a planning language that introduces streams as an interface for incorporating sam-</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Left: Domain 1 (with 5 blocks). Right: A realworld robot planning to "serve a meal" on the brown tray.
pling procedures in Planning Domain Definition Language (PDDL) (McDermott et al. 1998). Streams have both a procedural and declarative component. The procedural component is a conditional generator, a function from input values to a possibly infinite sequence of output values. Conditional generators construct new values that depend on existing values, such as new robot configurations that satisfy a kinematic constraint with existing poses and grasps. The declarative component specifies the facts that these input and output values satisfy. Streams allow a planner to reason about conditions on the inputs and outputs of a conditional generator while treating its implementation as a black box.</p>
<p>We apply two existing algorithms (Garrett, Lozano-Pérez, and Kaelbling 2018) to PDDLStream and introduce two new PDDLStream algorithms. Each algorithm constructs and solves a sequence of finite PDDL problems, any off-theshelf PDDL planner to be used as a search subroutine. Our Adaptive algorithm balances the exploration-exploitation trade-off (Robbins 1952) when deciding whether to search for new optimistic plans or to continue sampling parameter values for existing ones. By adaptively balancing the time spent searching versus sampling, Adaptive is often able to more aggressively find parameter bindings for existing optimistic plans. We experiment in three robotic planning domains (figures 1, 2, and 3) to compare the algorithms. Adaptive greatly outperforms the two existing algorithms (Garrett, Lozano-Pérez, and Kaelbling 2018) on constrained and</p>
<p>cost-sensitive problems. Finally, we apply PDDLStream to a real-world robot to plan for manipulation and kitchen tasks.</p>
<h2>2 Related Work</h2>
<p>Several PDDL extensions such as PDDL2.1 (Fox and Long 2003) and PDDL+ (Fox and Long 2006) support planning with numeric variables that evolve over time. Most numeric planners are limited to problems with linear or polynomial dynamics (Hoffmann 2003; Bryce et al. 2015; Cashmore et al. 2016); however, some planners can handle non-polynomial dynamics by discretizing time (Della Penna et al. 2009; Piotrowski et al. 2016). While it may be technically possible to analytically model, for example, collision constraints among 3D meshes using PDDL+, the resulting encoding would be enormous, far exceeding the capabilities of numeric planners. One approach addresses problems with convex dynamics without discretization (FernándezGonzález, Williams, and Karpas 2018); however, it requires a convex decomposition of the robot's configuration space, which is intractable for 3D articulated robots.</p>
<p>Semantic attachments (Dornhege et al. 2009b; 2009a; Gregory et al. 2012; Hertle et al. 2012; Dornhege 2014; Dantam et al. 2016), functions computed by an external module, are an existing method that integrates blackbox procedures and PDDL planners. Condition-checker modules test Boolean action preconditions, and effect-applicator modules modify numeric state variables. Actions must be parameterized by finite types, which restricts the technique to finite action spaces. In the context of robotics, this restricts the applicability of semantic attachments to domains that are prediscretized, where a human specifies a finite set of object poses, object grasps, and robot configurations that can be considered. Thus, semantic attachments are not sufficient for modeling the domains we consider, where the planner must produce these continuous values. In contrast, PDDLStream is able to model domains with infinitely-many action instances. Finally, semantic attachments are evaluated eagerly (section 6) during the forward state-space search as opposed to lazily (section 7). This results in many unneeded module calls and thus poor planner performance when the attachments are computationally expensive.</p>
<p>Many approaches to robotic task and motion planning have developed strategies for handling continuous spaces that go beyond prediscretization (Kaelbling and LozanoPérez 2011; Srivastava et al. 2014; Garrett, Lozano-Pérez, and Kaelbling 2015; Toussaint 2015; Garrett, Lozano-Pérez, and Kaelbling 2017). However, these approaches are each specialized to a particular class of manipulation problems. Moreover, they cannot be applied new domains, such as the rovers domain in figure 2, without substantial engineering effort because they do not offer a modular, domain-agnostic problem description language with clear semantics.</p>
<h2>3 PDDLStream</h2>
<p>We build PDDLStream on PDDL (McDermott et al. 1998) to enable ease of use for AI practitioners as well as to leverage any PDDL planner, without modification, as a subroutine. We provide an example PDDLStream specification for
a robotic pick-and-place domain in section 4. For clarity of exposition, we formalize STRIPS (Fikes and Nilsson 1971) PDDL problems; however, our approach also applies to Action Description Language (ADL) (Pednault 1989) features such as typing, disjunctions, negative preconditions, existential quantifiers, finite universal quantifiers, conditional effects, and derived predicates.</p>
<p>A predicate $p$ is a Boolean function. We treat types as unary predicates. An atomic fact $p(\bar{x})$ is a predicate $p$ evaluated on object tuple $\bar{x}=\left\langle\bar{x}<em k="k">{1}, \ldots, \bar{x}</em>}\right\rangle$ that evaluates to true. A literal is a fact or a negated fact. A state $\mathcal{I}$ is a set of literals. By the closed world assumption, facts not explicitly specified within a state are false. An action $a$ is given by a parameter tuple $\bar{X}=\left\langle X_{1}, \ldots, X_{k}\right\rangle$, a set of literal preconditions $\operatorname{pre}(a)$ on $\bar{X}$, and a set of literal effects $\operatorname{eff}(a)$ on $\bar{X}$. In costsensitive planning, each action may have a nonnegative cost function $c(\bar{X})$ as an additive cost term. An action instance $a(\bar{x})$ is an action $a$ with its parameters $\bar{X}$ replaced with objects $\bar{x}$. An action instance $a(\bar{x})$ is applicable in a state $\mathcal{I}$ if $\left(\operatorname{pre}^{+}(a(\bar{x})) \subseteq \mathcal{I}\right) \wedge\left(\operatorname{pre}^{-}(a(\bar{x})) \cap \mathcal{I}=\emptyset\right)$ where the + and - superscripts designate the positive and negative literals respectively. The result of applying an action instance $a(\bar{x})$ to state $\mathcal{I}$ is a new state $\left(\mathcal{I} \backslash \operatorname{eff}^{-}(a(\bar{x}))\right) \cup \operatorname{eff}^{+}(a(\bar{x}))$. To compactly model the domain in section 4, we make use of derived predicates (axioms) (Fox and Long 2003; Thiébaux, Hoffmann, and Nebel 2005), which are defined by a logical formula on a state. We treat positive-mentioned instantiated axioms roughly as actions for the purpose of describing the algorithms. A STRIPS PDDL problem $(\mathcal{A}, \mathcal{I}, \mathcal{G})$ is given by a set of actions $\mathcal{A}$, an initial state $\mathcal{I}$, and a goal set of literals $\mathcal{G}$. A plan $\pi=\left[a_{1}\left(\bar{x<em k="k">{1}\right), \ldots, a</em>}\left(\bar{x<em i="i">{k}\right)\right]$ is a finite sequence of $k$ action instances such that each $a</em>\right)$ is applicable in the $(i-1)$ th state resulting from their application. The preimage of a consistent plan $\pi$ is the set of facts that must hold to make $\pi$ executable:}\left(\bar{x}_{i</p>
<p>$$
\operatorname{PREIMAGE}(\pi)=\bigcup_{i=1}^{k}\left(\operatorname{pre}\left(a_{i}\left(\bar{x}<em j_i="j&lt;i">{i}\right)\right)-\bigcup</em>\right)\right)\right)
$$} \operatorname{eff}\left(a_{j}\left(\bar{x}_{j</p>
<h3>3.1 Streams</h3>
<p>A generator $g=\left[\bar{y}<em 2="2">{1}, \bar{y}</em>}, \ldots\right]$ is a finite or infinite, enumerable sequence of object tuples $\bar{y<em i="i">{i}$. Let next $(g)$ evaluate the generator and return the subsequent $\bar{y}</em>$.}$ in the sequence if it exists. Otherwise, let next $(g)$ return None. Let count $(g)=i$ return the current number of times next $(g)$ has been called. A conditional generator $f(\bar{X})$ is a function from an object tuple $\bar{x}$ to a generator $f(\bar{x})=g_{\bar{x}}$ that produces a sequence of output object tuples $g_{\bar{x}}$ that relate to input object tuple $\bar{x</p>
<p>A stream $s$ is a conditional generator $s(\bar{X})$ endowed with a declarative specification of any facts its inputs and outputs always satisfy. Let $s$.domain $={p \mid \forall \bar{x} \in \bar{X} . p(\bar{x})}$ be a set of facts $p$ on input parameters s.input that specify the set of object tuples $\bar{x}$ for which $s(\bar{X})$ is defined. Let s.certified $={p \mid \forall \bar{x} \in \bar{X}, \forall \bar{y} \in s(\bar{x}) . p(\bar{x}+\bar{y})}$ be a set of certified predicates on both s.input and output parameters s.output that assert any facts that $\langle\bar{x}, \bar{y}\rangle$ pairs satisfy. Intuitively, domain facts specify "typing" information by declaring legal inputs, and certified facts declare properties that all outputs are guaranteed to satisfy. A stream instance $s(\bar{x})$ is</p>
<p>a stream $s$ with its input parameters s.input replaced by an object tuple $\bar{x}$. Let $s(\bar{x}) \rightarrow \bar{y}$ denote a stream instance $s(\bar{x})$ that generates output object tuple $\bar{y}$. An external cost function $c(\bar{X}) \rightarrow[0, \infty)$ is a nonnegative function defined on parameter tuple $\bar{X}$. Like streams, the domain of $c$ is declared by a set of facts $c$.domain on inputs $\bar{X}$. However, external cost functions do not produce objects or certify facts.</p>
<p>A PDDLStream problem $(\mathcal{A}, \mathcal{S}, \mathcal{I}, \mathcal{G})$ is given by a set of actions $\mathcal{A}$, a set of streams $\mathcal{S}$, an initial state $\mathcal{I}$, and a goal state set $\mathcal{G}$. To ensure PDDLStream is Turing-recognizable, we require that stream-certified predicates are never negated within action preconditions. The set of streams $\mathcal{S}$ augments the initial state $\mathcal{I}$, recursively defining a potentially infinite set of facts $\mathcal{I}^{*}$ that hold initially and cannot be changed:</p>
<p>$$
\begin{aligned}
\mathcal{I}^{<em>}=\mathcal{I} \cup{p(\bar{x}+\bar{y}) \mid s \in \mathcal{S},|\bar{x}|=|\text { s.input }| \
\forall p^{\prime} \in \text { s.domain. } p^{\prime}(\bar{x}) \in \mathcal{I}^{</em>}, \bar{y} \in s(\bar{x}), p \in \text { s.certified }}
\end{aligned}
$$</p>
<p>A solution $\pi$ for PDDLStream problem $(\mathcal{A}, \mathcal{S}, \mathcal{I}, \mathcal{G})$ is a plan such that $\operatorname{PREIMAGE}(\pi+[\mathcal{G}]) \subseteq \mathcal{I}^{*}$. For cost-sensitive planning, the objective is to minimize the sum of solution action costs. In the extended version of this paper (https://arxiv. org/abs/1802.08705), we prove that PDDLStream planning is undecidable, but prove our algorithms are semi-complete, i.e., complete over feasible instances.</p>
<h3>3.2 Domain Description</h3>
<p>In order to enable easy use for AI practitioners, PDDLStream adheres to the PDDL standard when possible and adapts PDDL style and syntax when describing streams. PDDL problems are typically described using text files. A domain.pddl file specifies the domain dynamics through a set of actions (:action) and derived predicates (:derived). A problem.pddl file specifies the problem instance through a set of objects (:objects), the initial state (:init), and a goal formula (:goal).</p>
<p>In order to represent first-class objects such as realvalued vectors and implement conditional generators that operate on them, PDDLStream problems are partially described using a programming language. However, the declarative components of PDDLStream are still described in PDDL. Actions and derived predicates are listed using a standard domain.pddl text file. The input parameters (:inp), domain facts (:dom), output parameters (:out), and certified facts (:cert) of each stream are specified in a stream.pddl text file using PDDL-style syntax.</p>
<p>The conditional generator for each stream is stored programmatically in a map from each stream name to its generator function. Because the initial state typically contains many constant objects that may be non-string entities, the initial state and goal formula are also expressed programmatically instead of using a problem.pddl text file.</p>
<h2>4 Example Domains</h2>
<p>We apply PDDLStream to model two robotic manipulation domains with a single manipulator and a finite set of movable blocks. Domain 1 (figure 1) is mobile manipulation task requiring a PR2 robot to tightly pack each blue block into the green region. The goal in Domain 2 (figure 3) is to place one
of the two blue blocks on the green region while minimizing the robot distance traveled. The right blue block is much closer to the robot and the goal region than the distant left blue block. However, the red block must be moved out of way in order to safely grasp the right blue block. Optimal plans, which pick the near blue block, require more actions but travel less distance than plans that pick the far blue block.</p>
<p>Our model uses the following parameters: ?b is the name of a block; ?r is the name of a region on a stable surface; ?p is 6 DOF block pose placed stably on a fixed surface; ?g is a 6 DOF block grasp transform relative to the robot gripper; ?g is an 11 DOF robot configuration; and ?t is a trajectory composed of a finite sequence of waypoint robot configurations. The fluent predicates AtConf, AtPose, Holding, Empty model the changing robot configuration, object poses, and gripper status. The static predicates Block, Conf, Pose, Grasp, Kin, Motion, Contain, CFree are constant facts. Block declares that ?b is a block. Conf declares that ?g is a robot configuration. Pose and Grasp indicate that a pose ?p or grasp ?g can be used for block ?b. Kin is a kinematic constraint. Motion is a constraint that ?q1, ?q2 are the start and end configurations for trajectory ?t, and ?t respects joint limits, self-collisions, and collisions with the fixed environment. Contain states that when block ?b is at pose ?p, it is within region ?r. CFree states that if block ?b were placed at pose ?p, the robot, executing trajectory ?t, would not collide with it. The cost function Dist gives the distance traveled along trajectory ?t. The domain.pddl file is specified as follows:</p>
<div class="codehilite"><pre><span></span><code><span class="p">(:</span><span class="nx">derived</span><span class="w"> </span><span class="p">(</span><span class="nx">In</span><span class="w"> </span><span class="p">?</span><span class="nx">b</span><span class="w"> </span><span class="p">?</span><span class="nx">r</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nx">exists</span><span class="w"> </span><span class="p">(?</span><span class="nx">p</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nx">Contain</span><span class="w"> </span><span class="p">?</span><span class="nx">b</span><span class="w"> </span><span class="p">?</span><span class="nx">p</span><span class="w"> </span><span class="p">?</span><span class="nx">r</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nx">AtPose</span><span class="w"> </span><span class="p">?</span><span class="nx">b</span><span class="w"> </span><span class="p">?</span><span class="nx">p</span><span class="p">))))</span>
<span class="p">(:</span><span class="nx">derived</span><span class="w"> </span><span class="p">(</span><span class="nx">Safe</span><span class="w"> </span><span class="p">?</span><span class="nx">t</span><span class="w"> </span><span class="p">?</span><span class="nx">b</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">or</span>
<span class="w">    </span><span class="p">(</span><span class="nx">exists</span><span class="w"> </span><span class="p">(?</span><span class="nx">g</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nx">Grasp</span><span class="w"> </span><span class="p">?</span><span class="nx">b</span><span class="w"> </span><span class="p">?</span><span class="nx">g</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nx">Holding</span><span class="w"> </span><span class="p">?</span><span class="nx">b</span><span class="w"> </span><span class="p">?</span><span class="nx">g</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nx">exists</span><span class="w"> </span><span class="p">(?</span><span class="nx">p</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nx">CFree</span><span class="w"> </span><span class="p">?</span><span class="nx">t</span><span class="w"> </span><span class="p">?</span><span class="nx">b</span><span class="w"> </span><span class="p">?</span><span class="nx">p</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nx">AtPose</span><span class="w"> </span><span class="p">?</span><span class="nx">b</span><span class="w"> </span><span class="p">?</span><span class="nx">p</span><span class="p">)))))</span>
<span class="p">(:</span><span class="nx">action</span><span class="w"> </span><span class="nx">move</span>
<span class="w">    </span><span class="p">:</span><span class="nx">param</span><span class="w"> </span><span class="p">(?</span><span class="nx">q1</span><span class="w"> </span><span class="p">?</span><span class="nx">t</span><span class="w"> </span><span class="p">?</span><span class="nx">q2</span><span class="p">)</span>
<span class="w">    </span><span class="p">:</span><span class="nx">pre</span><span class="w"> </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nx">Motion</span><span class="w"> </span><span class="p">?</span><span class="nx">q1</span><span class="w"> </span><span class="p">?</span><span class="nx">t</span><span class="w"> </span><span class="p">?</span><span class="nx">q2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">AtConf</span><span class="w"> </span><span class="p">?</span><span class="nx">q1</span><span class="p">)</span>
<span class="p">(</span><span class="k">forall</span><span class="p">(?</span><span class="nx">b</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">imply</span><span class="w"> </span><span class="p">(</span><span class="nx">Block</span><span class="w"> </span><span class="p">?</span><span class="nx">b</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">Safe</span><span class="w"> </span><span class="p">?</span><span class="nx">t</span><span class="w"> </span><span class="p">?</span><span class="nx">b</span><span class="p">))))</span>
<span class="w">    </span><span class="p">:</span><span class="nx">eff</span><span class="w"> </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nx">AtConf</span><span class="w"> </span><span class="p">?</span><span class="nx">q2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">not</span><span class="w"> </span><span class="p">(</span><span class="nx">AtConf</span><span class="w"> </span><span class="p">?</span><span class="nx">q1</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nx">incr</span><span class="w"> </span><span class="p">(</span><span class="nx">total</span><span class="o">-</span><span class="nx">cost</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">Dist</span><span class="w"> </span><span class="p">?</span><span class="nx">t</span><span class="p">)))</span>
<span class="p">(:</span><span class="nx">action</span><span class="w"> </span><span class="nx">pick</span>
<span class="w">    </span><span class="p">:</span><span class="nx">param</span><span class="w"> </span><span class="p">(?</span><span class="nx">b</span><span class="w"> </span><span class="p">?</span><span class="nx">p</span><span class="w"> </span><span class="p">?</span><span class="nx">g</span><span class="w"> </span><span class="p">?</span><span class="nx">q</span><span class="p">)</span>
<span class="w">    </span><span class="p">:</span><span class="nx">pre</span><span class="w"> </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nx">Kin</span><span class="w"> </span><span class="p">?</span><span class="nx">b</span><span class="w"> </span><span class="p">?</span><span class="nx">p</span><span class="w"> </span><span class="p">?</span><span class="nx">g</span><span class="w"> </span><span class="p">?</span><span class="nx">q</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">AtPose</span><span class="w"> </span><span class="p">?</span><span class="nx">b</span><span class="w"> </span><span class="p">?</span><span class="nx">p</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nx">Empty</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">AtConf</span><span class="w"> </span><span class="p">?</span><span class="nx">q</span><span class="p">))</span>
<span class="w">    </span><span class="p">:</span><span class="nx">eff</span><span class="w"> </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nx">Holding</span><span class="w"> </span><span class="p">?</span><span class="nx">b</span><span class="w"> </span><span class="p">?</span><span class="nx">g</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">not</span><span class="w"> </span><span class="p">(</span><span class="nx">AtPose</span><span class="w"> </span><span class="p">?</span><span class="nx">b</span><span class="w"> </span><span class="p">?</span><span class="nx">p</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="k">not</span><span class="w"> </span><span class="p">(</span><span class="nx">Empty</span><span class="p">))))</span>
<span class="p">(:</span><span class="nx">action</span><span class="w"> </span><span class="nx">place</span>
<span class="w">    </span><span class="p">:</span><span class="nx">param</span><span class="w"> </span><span class="p">(?</span><span class="nx">b</span><span class="w"> </span><span class="p">?</span><span class="nx">p</span><span class="w"> </span><span class="p">?</span><span class="nx">g</span><span class="w"> </span><span class="p">?</span><span class="nx">q</span><span class="p">)</span>
<span class="w">    </span><span class="p">:</span><span class="nx">pre</span><span class="w"> </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nx">Kin</span><span class="w"> </span><span class="p">?</span><span class="nx">b</span><span class="w"> </span><span class="p">?</span><span class="nx">p</span><span class="w"> </span><span class="p">?</span><span class="nx">g</span><span class="w"> </span><span class="p">?</span><span class="nx">q</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">Holding</span><span class="w"> </span><span class="p">?</span><span class="nx">b</span><span class="w"> </span><span class="p">?</span><span class="nx">g</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nx">AtConf</span><span class="w"> </span><span class="p">?</span><span class="nx">q</span><span class="p">))</span>
<span class="w">    </span><span class="p">:</span><span class="nx">eff</span><span class="w"> </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nx">AtPose</span><span class="w"> </span><span class="p">?</span><span class="nx">b</span><span class="w"> </span><span class="p">?</span><span class="nx">p</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">Empty</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">not</span><span class="w"> </span><span class="p">(</span><span class="nx">Holding</span><span class="w"> </span><span class="p">?</span><span class="nx">b</span><span class="w"> </span><span class="p">?</span><span class="nx">g</span><span class="p">))))</span>
</code></pre></div>

<p>Three actions are defined: move, pick, and place. The In derived predicate expresses whether block ?b is currently contained within region ?r by expressing a condition on its current pose ?p. The Safe derived predicate encodes whether trajectory ?t does not collide with placed block ?b</p>
<p>at its current pose. For simplicity, we omit the description of an additional condition within move that checks collisions between grasped blocks and placed blocks.</p>
<p>The stream.pddl file is defined below. The poses stream randomly samples an infinite sequence of stable placements ?p for block ?b in region ?r. The grasps stream enumerates a sequence of force-closure grasps ?g for block ?b. The ik stream calls an inverse kinematics solver to sample configurations ?q from a 4D manifold of values (due to manipulator redundancy) that enable the robot to manipulate a block ?b at pose ?p with grasp ?g. It is important for ik to have ?p and ?g as input parameters so it can operate on poses and grasp objects in the initial state as well those produced by poses and grasps. The motion stream repeatedly calls a motion planner to generate safe trajectories ?t between pairs of configurations ?q1, ?q2. The cf ree stream tests whether block ?b when at pose ?p is collision free with respect to all robot configurations along trajectory ?t. It is a test stream, a stream with no output parameters. If it generates the empty tuple $\langle$, its certified conditions are proven. As a result, it can be interpreted as a Boolean function. cf ree is checked by calling a collision checker along trajectory ?t. The Dist external cost function returns the sum of the distance between each pair of adjacent configuration waypoints on trajectory ?t.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">(:stream poses</th>
<th style="text-align: center;">(:stream ik</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">:inp (?b ?r)</td>
<td style="text-align: center;">:inp (?b ?p ?g)</td>
</tr>
<tr>
<td style="text-align: center;">:dom (and (Block ?b)</td>
<td style="text-align: center;">:dom (and</td>
</tr>
<tr>
<td style="text-align: center;">(Region ?r))</td>
<td style="text-align: center;">(Pose ?b ?p)</td>
</tr>
<tr>
<td style="text-align: center;">:out (?p)</td>
<td style="text-align: center;">(Grasp ?b ?g))</td>
</tr>
<tr>
<td style="text-align: center;">:cert (and (Pose ?b ?p)</td>
<td style="text-align: center;">:out (?q)</td>
</tr>
<tr>
<td style="text-align: center;">(Contain ?b ?p ?r)))</td>
<td style="text-align: center;">:cert (and (Conf ?q)</td>
</tr>
<tr>
<td style="text-align: center;">(:stream grasps</td>
<td style="text-align: center;">(Kin ?b ?p ?g ?q)))</td>
</tr>
<tr>
<td style="text-align: center;">:inp (?b)</td>
<td style="text-align: center;">(:stream motion</td>
</tr>
<tr>
<td style="text-align: center;">:dom (Block ?b)</td>
<td style="text-align: center;">:inp (?q1 ?q2)</td>
</tr>
<tr>
<td style="text-align: center;">:out (?g)</td>
<td style="text-align: center;">:dom (and (Conf ?q1)</td>
</tr>
<tr>
<td style="text-align: center;">:cert (Grasp ?b ?g))</td>
<td style="text-align: center;">(Conf ?q2))</td>
</tr>
<tr>
<td style="text-align: center;">(:stream cfree</td>
<td style="text-align: center;">:out (?t)</td>
</tr>
<tr>
<td style="text-align: center;">:inp (?t ?b ?p)</td>
<td style="text-align: center;">:cert (and (Traj ?t)</td>
</tr>
<tr>
<td style="text-align: center;">:dom (and (Traj ?t)</td>
<td style="text-align: center;">(Motion ?q1 ?t ?q2)))</td>
</tr>
<tr>
<td style="text-align: center;">(Pose ?b ?p))</td>
<td style="text-align: center;">(:function (Dist ?t)</td>
</tr>
<tr>
<td style="text-align: center;">:cert (CFree ?t ?b ?p))</td>
<td style="text-align: center;">:dom (Traj ?t))</td>
</tr>
</tbody>
</table>
<h3>4.1 Rovers Domain</h3>
<p>We also apply PDDLStream to a multi-robot surveying domain to demonstrate the generality of our formalism. Domain 3 (figure 2) extends the classic PDDL domain rovers (Long and Fox 2003) by incorporating 3D visibility, distance, reachability, and collision constraints. Two rovers (green TurtleBot robots) must together collect a rock sample (black objects), collect a soil sample (brown objects), photograph each objective (blue objects) without occlusions, and communicate the results back to the lander (yellow Husky robot) via line of sight. Due to obstacles that limit reachability, both rovers must be utilized in order to complete the task. The actions are: move, take_image, calibrate, send_image, sample_rock, send_analysis, drop_rock.
<img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: Domain 3 (with 4 objectives).</p>
<h2>5 PDDLStream Algorithms</h2>
<p>We present four PDDLStream algorithms that share several common subroutines. The first two algorithms (Incremental, Focused) are the direct application of the algorithms of Garrett et al. (2018) to PDDLStream. The second two algorithms (Binding, Adaptive) are new algorithms. Each algorithm operates by solving a sequence of finite PDDL problems of increasing size. Let SEARCH $(\mathcal{A}, \mathcal{I}, \mathcal{G})$ be any sound and complete algorithm for classic PDDL problems. For cost-sensitive planning, assume SEARCH returns a solution with cost below a cost bound $C$. SEARCH can be implemented using an off-the-shelf PDDL planner without modification to take advantage of existing, efficient search algorithms. Although each algorithm is presented in its decision form, each can easily be run in an anytime fashion.</p>
<p>In order to reduce a potentially infinitely-large PDDLStream problem to a sequence of finite PDDL problems, our algorithms control two infinite sources of objects. First, the generator for a stream instance may enumerate an infinitely large set. Second, it may be possible to compose a sequence of stream instances of unbounded length. Thus, both the maximum width and depth of generated objects must be limited. We capture both of these properties by introducing the notion of the level of a fact. Intuitively, a level relates to the number of stream evaluations that are required to certify a fact. The level recursively incorporates both the stream evaluations required to certify its domain facts as well as the number of evaluations of $s(\bar{x})$ itself. This idea is similar to the concept of layer for facts and actions in a relaxed planning graph (Bonet and Geffner 2001) with the distinction that a stream instance can be evaluated many times.</p>
<p>Each algorithm maintains a map $U$ from each certified fact to both the level (level) of the fact and the stream instance (instance) that certified it. More formally, the level of stream instance $s(\bar{x})$ is the maximum level of its domain facts in $U$ plus one more than the count of its past evaluations. See section 8.2 for an example using levels.</p>
<p>$$
\operatorname{LEVEL}(U, s(\bar{x}))=1+\operatorname{count}(s(\bar{x}))+\max _{p \in s . \text { domain }} U[p(\bar{x})] \cdot \text { level }
$$</p>
<p>To ensure that external cost functions are evaluated on the earliest level possible, define the level of an external cost function instance $c(\bar{x})$ to be the max of its domain, i.e. $\operatorname{LEVEL}(U, c(\bar{x}))=\max _{p \in f . \text { domain }} U[p(\bar{x})]$.level.</p>
<h2>6 Incremental Algorithm</h2>
<p>The Incremental algorithm enumerates $\mathcal{I}^{*}$ by iteratively increasing the maximum level $l$. For each level, the subroutine APPLY-STREAMS instantiates and evaluates all stream instances $s(\bar{x})$ at level $k \leq l$ and adds any new certified facts to $U$. The meta-parameter OUTPUT specifies the procedure that is used to generate output objects when evaluating each stream instances. In this case, OUTPUT $=$ next simply queries the next output tuple in the generator. Let procedure INSTANTIATE ground all stream instances that are legal given the input objects in $U$ and the currently certified facts:</p>
<p>$$
\begin{aligned}
\operatorname{INSTANTIATE}(\mathcal{S}, U)= &amp; {s(\bar{x}) \mid \forall s \in \mathcal{S}, \forall p \in s . \text { domain } \
&amp; |\bar{x}|=|\text { s.input }|, p(\bar{x}) \in U}
\end{aligned}
$$</p>
<p>The current set of certified facts $U$ becomes the initial state in a PDDL problem $(\mathcal{A}, U, \mathcal{G})$ that is solved using SEARCH. If SEARCH finds a plan $\pi$, it is returned as a solution.</p>
<div class="codehilite"><pre><span></span><code><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="n">INCREMENTAL</span><span class="err">}</span><span class="p">(</span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">A</span><span class="err">}</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">S</span><span class="err">}</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">I</span><span class="err">}</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">G</span><span class="err">}</span><span class="p">)</span><span class="err">:\</span><span class="p">)</span>
<span class="err">\</span><span class="p">(</span><span class="n">U</span><span class="o">=</span><span class="err">\{</span><span class="nl">f</span><span class="p">:</span><span class="err">\</span><span class="n">langle</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="nc">text</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="k">None</span><span class="w"> </span><span class="err">}\</span><span class="n">rangle</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="err">\</span><span class="ow">in</span><span class="w"> </span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">I</span><span class="err">}\}\</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">Map</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">fact</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="k">level</span>
<span class="k">for</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="err">\</span><span class="ow">in</span><span class="o">[</span><span class="n">0,1,2, \ldots</span><span class="o">]</span><span class="err">:\</span><span class="p">)</span>
<span class="w">    </span><span class="err">\</span><span class="p">(</span><span class="n">U</span><span class="o">=</span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="n">APPLY</span><span class="o">-</span><span class="n">STREAMS</span><span class="err">}</span><span class="p">(</span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">S</span><span class="err">}</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="p">;</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="k">next</span><span class="w"> </span><span class="err">\</span><span class="p">()</span><span class="err">\</span><span class="p">)</span>
<span class="w">    </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nf">pi</span><span class="o">=</span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="k">SEARCH</span><span class="err">}</span><span class="p">(</span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">A</span><span class="err">}</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">G</span><span class="err">}</span><span class="p">)</span><span class="err">\</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nf">pi</span><span class="w"> </span><span class="err">\</span><span class="n">neq</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="k">None</span><span class="err">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nf">pi</span><span class="err">\</span><span class="p">)</span>
<span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="n">APPLY</span><span class="err">}</span><span class="o">-</span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="n">STREAMS</span><span class="err">}\</span><span class="nf">left</span><span class="p">(</span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">S</span><span class="err">}</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">^</span><span class="err">{\</span><span class="n">prime</span><span class="err">}</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="k">OUTPUT</span><span class="err">}\</span><span class="nf">right</span><span class="p">)</span><span class="err">:\</span><span class="p">)</span>
<span class="w">    </span><span class="err">\</span><span class="p">(</span><span class="n">U</span><span class="o">=</span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="n">copy</span><span class="err">}\</span><span class="nf">left</span><span class="p">(</span><span class="n">U</span><span class="o">^</span><span class="err">{\</span><span class="n">prime</span><span class="err">}\</span><span class="nf">right</span><span class="p">)</span><span class="err">\</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="err">\</span><span class="ow">in</span><span class="o">[</span><span class="n">1,2, \ldots, l</span><span class="o">]</span><span class="err">:\</span><span class="p">)</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="err">\</span><span class="n">bar</span><span class="err">{</span><span class="n">x</span><span class="err">}</span><span class="p">)</span><span class="w"> </span><span class="err">\</span><span class="ow">in</span><span class="w"> </span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="n">INSTANTIATE</span><span class="err">}</span><span class="p">(</span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">S</span><span class="err">}</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="p">)</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="k">LEVEL</span><span class="err">}</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">(</span><span class="err">\</span><span class="n">bar</span><span class="err">{</span><span class="n">x</span><span class="err">}</span><span class="p">))</span><span class="o">=</span><span class="n">k</span><span class="err">\</span><span class="p">)</span>
<span class="w">            </span><span class="k">ADD</span><span class="o">-</span><span class="n">CERTIFIED</span><span class="w"> </span><span class="err">\</span><span class="p">((</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">(</span><span class="err">\</span><span class="n">bar</span><span class="err">{</span><span class="n">x</span><span class="err">}</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="k">OUTPUT</span><span class="w"> </span><span class="err">\</span><span class="p">()</span><span class="err">\</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">U</span><span class="err">\</span><span class="p">)</span>
<span class="k">ADD</span><span class="o">-</span><span class="n">CERTIFIED</span><span class="w"> </span><span class="err">\</span><span class="p">((</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="k">OUTPUT</span><span class="w"> </span><span class="err">\</span><span class="p">()</span><span class="err">:\</span><span class="p">)</span>
<span class="w">    </span><span class="err">\</span><span class="p">(</span><span class="n">l</span><span class="o">=</span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="k">LEVEL</span><span class="err">}</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">(</span><span class="err">\</span><span class="n">bar</span><span class="err">{</span><span class="n">x</span><span class="err">}</span><span class="p">))</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="err">\</span><span class="n">bar</span><span class="err">{</span><span class="n">y</span><span class="err">}</span><span class="o">=</span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="k">OUTPUT</span><span class="err">}</span><span class="p">(</span><span class="err">\</span><span class="n">bar</span><span class="err">{</span><span class="n">x</span><span class="err">}</span><span class="p">)</span><span class="err">\</span><span class="p">)</span>
<span class="w">    </span><span class="err">\</span><span class="p">(</span><span class="n">F</span><span class="o">=</span><span class="err">\{</span><span class="n">p</span><span class="p">(</span><span class="err">\</span><span class="n">bar</span><span class="err">{</span><span class="n">x</span><span class="err">}</span><span class="o">+</span><span class="err">\</span><span class="n">bar</span><span class="err">{</span><span class="n">y</span><span class="err">}</span><span class="p">)</span><span class="w"> </span><span class="err">\</span><span class="n">mid</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="err">\</span><span class="ow">in</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="n">certified</span><span class="err">}\}\</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">bar</span><span class="err">{</span><span class="n">y</span><span class="err">}</span><span class="w"> </span><span class="err">\</span><span class="n">neq</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="k">None</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">emptyset</span><span class="err">\</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="err">\</span><span class="ow">in</span><span class="p">(</span><span class="n">F</span><span class="w"> </span><span class="err">\</span><span class="n">backslash</span><span class="w"> </span><span class="n">U</span><span class="p">)</span><span class="err">:</span><span class="w"> </span><span class="n">U</span><span class="o">[</span><span class="n">f</span><span class="o">]=</span><span class="err">\</span><span class="n">langle</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">(</span><span class="err">\</span><span class="n">bar</span><span class="err">{</span><span class="n">x</span><span class="err">}</span><span class="p">)</span><span class="err">\</span><span class="n">rangle</span><span class="err">\</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">bar</span><span class="err">{</span><span class="n">y</span><span class="err">}\</span><span class="p">)</span>
</code></pre></div>

<p>The incremental algorithm eagerly and blindly evaluates all stream instances, producing many facts that are irrelevant to the task. This can result in significant overhead when stream evaluations are computationally expensive as they frequently are in robotics domains where inverse kinematics solvers and motion planners are required.</p>
<h2>7 Optimistic Algorithms</h2>
<p>The remaining algorithms (Focused, Binding, and Adaptive) use the shared pseudocode OPTIMISTIC, which takes in a meta-parameter procedure PROCESS-STREAMS that implements each algorithm. The key principle behind our algorithms is to lazily explore candidate plans before checking their validity (Dellin and Srinivasa 2016). In order to apply laziness to PDDLStream, we plan using optimistic objects that represent hypothetical stream outputs before evaluating actual stream outputs. These values are optimistic in the sense that their corresponding stream instance may not ever produce a satisfying value. For instance, an $\downarrow x$ stream with a particular pose and grasp pair as inputs may not admit any inverse kinematic solutions. By first planning with optimistic objects, our algorithms are able to identify only
the stream instances that could possibly support a plan and therefore focus sampling on useful aspects of the problem.</p>
<p>Let the procedure OPT-OUTPUT $(s(\bar{x}))=\bar{o}<em x="x">{x}^{s}$ create an optimistic object tuple for stream instance $s(\bar{x})$. Critically, this technique differs from the approach of Garrett et al. (2018) in that here each optimistic object $\bar{o}</em>$ implicitly encodes a single partially-ordered set of stream instance evaluations that could produce values for the optimistic object. This property provides the basis for our novel Binding (section 8.1) and Adaptive (section 8.3) algorithms.}^{s}$ is unique to a single stream instance $s(\bar{x})$. In contrast, the approach of Garrett et al., if directly applied to PDDLStream, would create an optimistic object tuple OPT-OUTPUT $(s(\bar{x}))=\bar{o}^{s}$ for each stream rather than each stream instance. As a result, $\bar{o}^{s}$ is shared among all instances of stream $s$. This distinction is significant because each unique optimistic object $\bar{o}_{x}^{s</p>
<p>A consequence of creating unique optimistic objects is that the set of all optimistic objects may be infinitely large in domains where it is possible to compose arbitrarily many streams instances. In contrast, creating shared optimistic objects always results in a finite set of optimistic objects. In order to limit the number of unique optimistic objects, we regulate the current set of optimistic stream instances using their level (section 5). Namely, we iteratively increase the maximum optimistic stream level $l$ that can be considered on a given iteration. Finally, when applied to an external cost function instance $c(\bar{x})$, let OPT-OUTPUT $(c(\bar{x}))=0$ produce an optimistic evaluation of $c(\bar{x})$ by returning 0 , a lower bound on the nonnegative cost function value.</p>
<div class="codehilite"><pre><span></span><code><span class="n">OPTIMISTIC</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">O</span><span class="p">)</span><span class="w"> </span><span class="n">PROCESS</span><span class="o">-</span><span class="n">STREAMS</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="err">:</span>
<span class="w">    </span><span class="err">\</span><span class="p">(</span><span class="n">U</span><span class="o">=</span><span class="err">\{</span><span class="nl">f</span><span class="p">:</span><span class="err">\</span><span class="n">langle</span><span class="w"> </span><span class="mi">0</span><span class="err">\</span><span class="p">),</span><span class="w"> </span><span class="k">None</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">rangle</span><span class="w"> </span><span class="err">\</span><span class="n">mid</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="err">\</span><span class="ow">in</span><span class="w"> </span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">I</span><span class="err">}\}\</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">Map</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">fact</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="k">level</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="err">\</span><span class="ow">in</span><span class="o">[</span><span class="n">0,1,2, \ldots</span><span class="o">]</span><span class="err">:\</span><span class="p">)</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="k">True</span><span class="err">:</span>
<span class="w">            </span><span class="err">\</span><span class="p">(</span><span class="n">U</span><span class="o">^</span><span class="err">{</span><span class="o">*</span><span class="err">}</span><span class="o">=</span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="n">APPLY</span><span class="err">}</span><span class="o">-</span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="n">STREAMS</span><span class="err">}</span><span class="p">(</span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">S</span><span class="err">}</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="p">;</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="n">OPT</span><span class="o">-</span><span class="k">OUTPUT</span><span class="p">)</span>
<span class="w">            </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nf">pi</span><span class="o">^</span><span class="err">{</span><span class="o">*</span><span class="err">}</span><span class="o">=</span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="k">SEARCH</span><span class="err">}\</span><span class="nf">left</span><span class="p">(</span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">A</span><span class="err">}</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">^</span><span class="err">{</span><span class="o">*</span><span class="err">}</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">G</span><span class="err">}\</span><span class="nf">right</span><span class="p">)</span><span class="err">\</span><span class="p">)</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nf">pi</span><span class="o">^</span><span class="err">{</span><span class="o">*</span><span class="err">}</span><span class="o">=</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="k">None</span><span class="err">:</span><span class="w"> </span><span class="k">break</span>
<span class="w">            </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">psi</span><span class="o">=</span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="n">RETRACE</span><span class="err">}\</span><span class="nf">left</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">^</span><span class="err">{</span><span class="o">*</span><span class="err">}</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="n">PREIMAGE</span><span class="err">}\</span><span class="nf">left</span><span class="p">(</span><span class="err">\</span><span class="nf">pi</span><span class="o">^</span><span class="err">{</span><span class="o">*</span><span class="err">}</span><span class="o">+[</span><span class="n">\mathcal{G}</span><span class="o">]</span><span class="err">\</span><span class="nf">right</span><span class="p">)</span><span class="err">\</span><span class="nf">right</span><span class="p">)</span><span class="err">\</span><span class="p">)</span>
<span class="w">            </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nf">pi</span><span class="o">=</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="n">PROCESS</span><span class="o">-</span><span class="n">STREAMS</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nf">left</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="n">psi</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="nf">pi</span><span class="o">^</span><span class="err">{</span><span class="o">*</span><span class="err">}\</span><span class="nf">right</span><span class="p">)</span><span class="err">\</span><span class="p">)</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nf">pi</span><span class="w"> </span><span class="err">\</span><span class="n">neq</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="k">None</span><span class="err">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nf">pi</span><span class="err">\</span><span class="p">)</span>
<span class="n">RETRACE</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nf">left</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">^</span><span class="err">{</span><span class="o">*</span><span class="err">}</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="err">\</span><span class="nf">right</span><span class="p">)</span><span class="err">:\</span><span class="p">)</span>
<span class="w">    </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">psi</span><span class="o">=</span><span class="err">[]\</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">Initialize</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="k">plan</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="err">\</span><span class="ow">in</span><span class="p">(</span><span class="n">F</span><span class="w"> </span><span class="err">\</span><span class="n">backslash</span><span class="w"> </span><span class="n">U</span><span class="p">)</span><span class="err">\</span><span class="p">)</span>
<span class="w">    </span><span class="err">\</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="err">\</span><span class="n">bar</span><span class="err">{</span><span class="n">x</span><span class="err">}</span><span class="p">)</span><span class="o">=</span><span class="n">U</span><span class="o">^</span><span class="err">{</span><span class="o">*</span><span class="err">}</span><span class="o">[</span><span class="n">f</span><span class="o">]</span><span class="err">\</span><span class="p">).</span><span class="n">instance</span>
<span class="w">    </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">psi</span><span class="o">+=</span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="n">RETRACE</span><span class="err">}\</span><span class="nf">left</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">^</span><span class="err">{</span><span class="o">*</span><span class="err">}</span><span class="p">,</span><span class="err">\{</span><span class="n">p</span><span class="p">(</span><span class="err">\</span><span class="n">bar</span><span class="err">{</span><span class="n">x</span><span class="err">}</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="err">\</span><span class="ow">in</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="err">\</span><span class="nc">text</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="k">domain</span><span class="w"> </span><span class="err">}\}\</span><span class="nf">right</span><span class="p">)</span><span class="o">+[</span><span class="n">s(\bar{x})</span><span class="o">]</span><span class="err">\</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">psi</span><span class="err">\</span><span class="p">)</span>
</code></pre></div>

<p>The outer loop of OPTIMISTIC iteratively increases the maximum fact level $l$. The inner loop identifies all stream instances at fact level $l$ that optimistically support a plan. On each iteration of the while loop, APPLY-STREAMS instantiates and optimistically evaluates all stream instances $s(\bar{x})$ at level $k \leq l$, this time using OUTPUT $=$ OPT-OUTPUT. This results in $U^{<em>}$, a map of all optimistic facts achievable at fact level $l$. Next, OPTIMISTIC calls SEARCH to find an optimistic plan $\pi^{</em>}$ for the PDDL problem $\left(\mathcal{A}, U^{<em>}, \mathcal{G}\right)$. If $\pi^{</em>}=$ None, no more plans can be found at the current fact level. And so OPTIMISTIC breaks out of the while loop and increases the fact level to $l+1$. Otherwise, RETRACE extracts a stream plan $\psi$ of stream instances that, presuming successful eval-</p>
<p>uations, certify the optimistic facts present in the preconditions of $\pi^{<em>}$. For each optimistic fact in the preimage of $\pi^{</em>}$, RETRACE adds the stream instance $s(\bar{x})$ that produced it to $\psi$ and recursively applies RETRACE to the domain facts of $s(\bar{x})$. Once a stream plan $\psi$ is identified, the meta-parameter procedure PROCESS-STREAMS evaluates a subsequence of $\psi$ and returns a solution $\pi$ if one is found.</p>
<h3>7.1 Focused Algorithm</h3>
<p>The Focused algorithm implements PROCESS-STREAMS using the procedure FOCUSED-PROCESS-STREAMS. If $\psi=[]$, the plan $\pi^{<em>}$ uses no optimistic objects and is returned as a solution. Otherwise, FOCUSED-PROCESS-STREAMS evaluates streams instances that have satisfied domain facts and adds new certified facts to $U$. The first stream instance $\psi[0]$ is always evaluated. Because evaluation with next increments the level of $s(\bar{x})$, the same stream plan $\psi$ cannot be used on the following iteration. This forces SEARCH to find an optimistic plan $\pi^{</em>}$ supported by a new stream plan or report that no more exist, causing the level $l$ to increase.</p>
<div class="codehilite"><pre><span></span><code><span class="nv">FOCUSED</span><span class="o">-</span><span class="nv">PROCESS</span><span class="o">-</span><span class="nv">STREAMS</span><span class="w"> </span>\<span class="p">(</span>\<span class="nf">left</span><span class="p">(</span><span class="nv">U</span><span class="p">,</span><span class="w"> </span>\<span class="nv">psi</span><span class="p">,</span><span class="w"> </span>\<span class="nv">pi</span><span class="o">^</span><span class="p">{</span><span class="o">*</span><span class="p">}</span>\<span class="nv">right</span><span class="p">)</span>\<span class="p">)</span>
<span class="mi">1</span><span class="w"> </span><span class="k">if</span><span class="w"> </span>\<span class="p">(</span>\<span class="nv">psi</span><span class="o">=</span><span class="p">[]</span>\<span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nv">return</span><span class="w"> </span>\<span class="p">(</span>\<span class="nv">pi</span><span class="o">^</span><span class="p">{</span><span class="o">*</span><span class="p">}</span>\<span class="p">)</span>
<span class="mi">2</span><span class="w"> </span><span class="k">for</span><span class="w"> </span>\<span class="p">(</span><span class="nf">s</span><span class="p">(</span>\<span class="nv">bar</span><span class="p">{</span><span class="nv">x</span><span class="p">})</span><span class="w"> </span>\<span class="nv">in</span><span class="w"> </span>\<span class="nv">psi</span>\<span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">if</span><span class="w"> </span>\<span class="p">(</span>\<span class="p">{</span><span class="nf">p</span><span class="p">(</span>\<span class="nv">bar</span><span class="p">{</span><span class="nv">x</span><span class="p">})</span><span class="w"> </span>\<span class="nv">mid</span><span class="w"> </span><span class="nv">p</span><span class="w"> </span>\<span class="nv">in</span><span class="w"> </span><span class="nv">s</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">d</span><span class="w"> </span><span class="nv">o</span><span class="w"> </span><span class="nv">m</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">n</span>\<span class="p">}</span><span class="w"> </span>\<span class="nv">subseteq</span><span class="w"> </span><span class="nv">U</span>\<span class="p">)</span><span class="w"> </span><span class="o">:</span>
<span class="mi">3</span><span class="w"> </span><span class="nv">ADD</span><span class="o">-</span><span class="nv">CERTIFIED</span><span class="w"> </span>\<span class="p">((</span><span class="nv">U</span><span class="p">,</span><span class="w"> </span><span class="nf">s</span><span class="p">(</span>\<span class="nv">bar</span><span class="p">{</span><span class="nv">x</span><span class="p">})</span><span class="w"> </span><span class="p">;</span><span class="w"> </span>\<span class="nv">text</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nv">next</span><span class="w"> </span><span class="p">})$</span>
<span class="mi">4</span><span class="w"> </span><span class="nv">return</span><span class="w"> </span><span class="nv">None</span>
</code></pre></div>

<h2>8 Binding and Adaptive Algorithms</h2>
<p>The primary shortcoming of Focused is that it fails to take full advantage of the plans produced by SEARCH. Our two new algorithms implement PROCESS-STREAMS by operating on more of the associated stream plans at a time. Ultimately, our Adaptive algorithm balances the time spent in SEARCH versus PROCESS-STREAMS, often reducing the number of calls to SEARCH required to find a solution.</p>
<h3>8.1 Binding Algorithm</h3>
<p>The key idea of Binding is to propagate stream outputs that are inputs to subsequent streams to evaluate more of the stream plan at once. PROCESS-STREAMS-BINDING maintains a set of bindings $B$, assignments of each optimistic object to an actual object, that are produced while evaluating the stream plan $\psi$. Bindings are used to replace any optimistic objects that serve as stream instance inputs in $\psi$ or action arguments in $\pi^{<em>}$. Recall from section 7 that optimistic objects $o_{\bar{x}}^{</em>}$ are unique to a particular stream instance $s(\bar{x})$. Thus, there is a bijective mapping between each optimistic object $o_{\bar{x}}^{<em>}$ and its corresponding output object from $s(\bar{x})$. The procedure UPDATE-BINDINGS substitutes the optimistic objects in $\bar{x}^{</em>}$ with their bindings $\bar{x}$ from $B$, evaluates the stream instance $s(\bar{x})$, and if an output tuple $\bar{y} \neq$ None is produced, updates $B$ by mapping each optimistic output $y^{<em>}$ to its new object $y$. If all stream evaluations are successful, then $\psi$ is satisfied, and procedure APPLY-BINDINGS substitutes each optimistic object within $\pi^{</em>}$ with its value in $B$ and returns the new plan as a solution. If a stream instead returns None or the evaluated cost exceeds the current cost bound $C$, BINDING-PROCESS-STREAMS terminates early to avoid unnecessarily evaluating any subsequent stream instances.</p>
<div class="codehilite"><pre><span></span><code><span class="nt">BINDING-PROCESS-STREAMS</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="err">\</span><span class="nt">left</span><span class="o">(</span><span class="nt">U</span><span class="o">,</span><span class="w"> </span><span class="err">\</span><span class="nt">psi</span><span class="o">,</span><span class="w"> </span><span class="err">\</span><span class="nt">pi</span><span class="o">^</span><span class="p">{</span><span class="err">*</span><span class="p">}</span><span class="err">\</span><span class="nt">right</span><span class="o">)</span><span class="err">\</span><span class="o">)</span>
<span class="err">\</span><span class="o">(</span><span class="nt">1</span><span class="w"> </span><span class="err">\</span><span class="nt">quad</span><span class="w"> </span><span class="nt">B</span><span class="o">=</span><span class="err">\</span><span class="p">{</span><span class="w"> </span><span class="err">\</span><span class="p">}</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="o">/</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">Initialize</span><span class="w"> </span><span class="nt">bindings</span>
<span class="nt">2</span><span class="w"> </span><span class="nt">for</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">s</span><span class="err">\</span><span class="nt">left</span><span class="o">(</span><span class="err">\</span><span class="nt">bar</span><span class="p">{</span><span class="err">x</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="err">*</span><span class="p">}</span><span class="err">\</span><span class="nt">right</span><span class="o">)</span><span class="w"> </span><span class="err">\</span><span class="nt">in</span><span class="w"> </span><span class="err">\</span><span class="nt">psi</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="o">:</span>
<span class="err">\</span><span class="o">(</span><span class="nt">3</span><span class="w"> </span><span class="err">\</span><span class="nt">quad</span><span class="w"> </span><span class="nt">B</span><span class="o">=</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">UPDATE-BINDINGS</span><span class="w"> </span><span class="err">\</span><span class="o">((</span><span class="nt">B</span><span class="o">,</span><span class="w"> </span><span class="nt">s</span><span class="o">(</span><span class="err">\</span><span class="nt">bar</span><span class="p">{</span><span class="err">x</span><span class="p">}</span><span class="o">))</span><span class="err">\</span><span class="o">)</span>
<span class="nt">4</span><span class="w"> </span><span class="nt">if</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">B</span><span class="o">=</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">None</span><span class="o">:</span><span class="w"> </span><span class="nt">return</span><span class="w"> </span><span class="nt">None</span>
<span class="nt">5</span><span class="w"> </span><span class="nt">return</span><span class="w"> </span><span class="nt">APPLY-BINDINGS</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="err">\</span><span class="nt">left</span><span class="o">(</span><span class="nt">B</span><span class="o">,</span><span class="w"> </span><span class="err">\</span><span class="nt">pi</span><span class="o">^</span><span class="p">{</span><span class="err">*</span><span class="p">}</span><span class="err">\</span><span class="nt">right</span><span class="o">)</span><span class="err">\</span><span class="o">)</span>
<span class="nt">UPDATE-BINDINGS</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="err">\</span><span class="nt">left</span><span class="o">(</span><span class="nt">B</span><span class="o">,</span><span class="w"> </span><span class="nt">s</span><span class="err">\</span><span class="nt">left</span><span class="o">(</span><span class="err">\</span><span class="nt">bar</span><span class="p">{</span><span class="err">x</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="err">*</span><span class="p">}</span><span class="err">\</span><span class="nt">right</span><span class="o">)</span><span class="err">\</span><span class="nt">right</span><span class="o">)</span><span class="err">\</span><span class="o">)</span>
<span class="err">\</span><span class="o">(</span><span class="nt">1</span><span class="w"> </span><span class="err">\</span><span class="nt">quad</span><span class="w"> </span><span class="err">\</span><span class="nt">bar</span><span class="p">{</span><span class="err">x</span><span class="p">}</span><span class="o">=</span><span class="err">\</span><span class="nt">left</span><span class="cp">[</span><span class="nx">B</span><span class="o">\</span><span class="nx">left</span><span class="err">[</span><span class="nx">x</span><span class="p">^{</span><span class="o">*</span><span class="p">}</span><span class="o">\</span><span class="nx">right</span><span class="cp">]</span><span class="w"> </span><span class="err">\</span><span class="nt">text</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">if</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="nt">x</span><span class="o">^</span><span class="p">{</span><span class="err">*</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nt">in</span><span class="w"> </span><span class="nt">B</span><span class="err">\</span><span class="nt">right</span><span class="o">.</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">else</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="err">\</span><span class="nt">left</span><span class="p">.</span><span class="nc">x</span><span class="o">^</span><span class="p">{</span><span class="err">*</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nt">text</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">for</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="nt">x</span><span class="o">^</span><span class="p">{</span><span class="err">*</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nt">in</span><span class="w"> </span><span class="err">\</span><span class="nt">bar</span><span class="p">{</span><span class="err">x</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="err">*</span><span class="p">}</span><span class="err">\</span><span class="nt">right</span><span class="o">]</span><span class="err">\</span><span class="o">)</span>
<span class="err">\</span><span class="o">(</span><span class="nt">2</span><span class="w"> </span><span class="err">\</span><span class="nt">quad</span><span class="w"> </span><span class="err">\</span><span class="nt">bar</span><span class="p">{</span><span class="err">y</span><span class="p">}</span><span class="o">=</span><span class="err">\</span><span class="nt">operatorname</span><span class="p">{</span><span class="err">ADD-CERTIFIED</span><span class="p">}</span><span class="o">(</span><span class="nt">U</span><span class="o">,</span><span class="w"> </span><span class="nt">s</span><span class="o">(</span><span class="err">\</span><span class="nt">bar</span><span class="p">{</span><span class="err">x</span><span class="p">}</span><span class="o">)</span><span class="w"> </span><span class="o">;</span><span class="w"> </span><span class="err">\</span><span class="nt">text</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">next</span><span class="w"> </span><span class="p">}</span><span class="o">)</span><span class="err">\</span><span class="o">)</span>
<span class="nt">3</span><span class="w"> </span><span class="nt">if</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="err">\</span><span class="nt">bar</span><span class="p">{</span><span class="err">y</span><span class="p">}</span><span class="o">=</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">None</span><span class="o">:</span><span class="w"> </span><span class="nt">return</span><span class="w"> </span><span class="nt">None</span>
<span class="nt">4</span><span class="w"> </span><span class="nt">for</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">y</span><span class="o">^</span><span class="p">{</span><span class="err">*</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="nt">y</span><span class="w"> </span><span class="err">\</span><span class="nt">in</span><span class="w"> </span><span class="err">\</span><span class="nt">operatorname</span><span class="p">{</span><span class="err">zip</span><span class="p">}</span><span class="o">(</span><span class="err">\</span><span class="nt">operatorname</span><span class="p">{</span><span class="err">OPT-OUTPUT</span><span class="p">}</span><span class="o">(</span><span class="nt">s</span><span class="o">(</span><span class="err">\</span><span class="nt">bar</span><span class="p">{</span><span class="err">x</span><span class="p">}</span><span class="o">)),</span><span class="w"> </span><span class="err">\</span><span class="nt">bar</span><span class="p">{</span><span class="err">y</span><span class="p">}</span><span class="o">):</span><span class="w"> </span><span class="nt">B</span><span class="err">\</span><span class="nt">left</span><span class="cp">[</span><span class="nx">y</span><span class="p">^{</span><span class="o">*</span><span class="p">}</span><span class="o">\</span><span class="nx">right</span><span class="cp">]</span><span class="o">=</span><span class="nt">y</span><span class="err">\</span><span class="o">)</span>
<span class="nt">5</span><span class="w"> </span><span class="nt">return</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">B</span><span class="err">\</span><span class="o">)</span>
</code></pre></div>

<p>The performance of Binding depends on the number times BINDING-PROCESS-STREAMS fails to bind each stream plan $\psi$ that is considered. And the likelihood that BINDINGPROCESS-STREAMS fails depends on the properties of the streams specified for a domain, such as the fraction of stream instances that fail to produce output values $(\operatorname{next}(s(\bar{x}))=$ None), as well as the objects present in a specific problem instance. For example, in Domain 1, the first optimistic plan considered is always satisfiable; however, most calls to BINDING-PROCESS-STREAMS fail due to fact that the cfree stream often fails due to the highly-constrained nature of packing blocks into a small region. In Domain 2, the first optimistic plan is never satisfiable because the red block obstructs all ways of picking the blue block, but an optimistic plan that first moves the red block and then the blue block admits many bindings. In Domain 3, if a rover configuration sampled to photograph a particular objective is not reachable, it is likely that most configurations sampled for that particular rover and objective pair are not reachable.</p>
<h3>8.2 Example Execution</h3>
<p>As an example of BINDING-PROCESS-STREAMS, consider a PDDLStream problem in the robotics domain (section 4) requiring that block $b$ be moved from initial pose $p_{0}$ to a goal region $\tau$. The objects $q_{0}, p_{0}, g_{1}, t_{1}, \ldots$ are real-valued vectors (e.g. $q_{0}=[1.71,-2.44, \ldots]$ ). The initial state is:
$\mathcal{I}={($ Region r) (Block b) (Pose b $p_{0}$ )
$\left(\right.$ Conf $\left.q_{0}\right)$ (AtPose b $p_{0}$ ) (Empty) (AtConf $q_{0}$ ) }.
The goal is $\mathcal{G}={($ InRegion b r) $}$. OPTIMISTIC fails to find a plan for level $l \leq 2$. When $l=3$, the optimistic stream instances instantiated by APPLY-STREAMS are:</p>
<p>$$
\begin{aligned}
&amp; {\left[\operatorname{grasps}(b) \rightarrow \boldsymbol{\gamma}<em 1="1">{1}, \text { poses }(b, r) \rightarrow \boldsymbol{\rho}</em>}, i k\left(b, p_{0}, \boldsymbol{\gamma<em 1="1">{1}\right) \rightarrow \boldsymbol{\zeta}</em> \
&amp; \text { ik }\left(b, \boldsymbol{\rho}}\right.<em 1="1">{1}, \boldsymbol{\gamma}</em>}\right) \rightarrow \boldsymbol{\zeta<em 0="0">{2}, \text { motion }\left(q</em>}, q_{0}\right) \rightarrow \boldsymbol{\tau<em 0="0">{1} \
&amp; \left.\text { motion }\left(q</em>}, \boldsymbol{\zeta<em 2="2">{1}\right) \rightarrow \boldsymbol{\tau}</em>}, \text { motion }\left(\boldsymbol{\zeta<em 0="0">{1}, q</em>, \ldots\right]
\end{aligned}
$$}\right) \rightarrow \boldsymbol{\tau}_{3</p>
<p>Each $\boldsymbol{\gamma}<em i="i">{i}, \boldsymbol{\rho}</em>}, \boldsymbol{\zeta<em i="i">{i}$, and $\boldsymbol{\tau}</em>$ produced by SEARCH and RETRACE are:}$ represents a unique optimistic output. In total, 13 stream instances are created. Here, the poses and grasps stream instances are all level 1 , the ik stream instances are all level 2, and the motion stream instances are all level 3. A possible optimistic plan $\pi_{1}^{*}$ and stream plan $\psi_{1</p>
<p>$$
\begin{aligned}
&amp; \pi_{1}^{*}=\left[\operatorname{move}\left(q_{0}, \boldsymbol{\tau}<em 1="1">{2}, \boldsymbol{\zeta}</em>}\right), \operatorname{pick}\left(b, p_{0}, \boldsymbol{\gamma<em 1="1">{1}, \boldsymbol{\zeta}</em>}\right), \operatorname{move}\left(\boldsymbol{\zeta<em 4="4">{1}, \boldsymbol{\tau}</em>}, \boldsymbol{\zeta<em 1="1">{2}\right)\right. \
&amp; \text { place }\left(b, \boldsymbol{\rho}</em>}, \boldsymbol{\gamma<em 2="2">{1}, \boldsymbol{\zeta}</em>\right)] \
&amp; \psi_{1}=\left[\operatorname{grasps}(b) \rightarrow \boldsymbol{\gamma}<em 1="1">{1}, \operatorname{poses}(b, r) \rightarrow \boldsymbol{\rho}</em>}, i k\left(b, p_{0}, \boldsymbol{\gamma<em 1="1">{1}\right) \rightarrow \boldsymbol{\zeta}</em>\right. \
&amp; \text { ik }\left(b, \boldsymbol{\rho}<em 1="1">{1}, \boldsymbol{\gamma}</em>}\right) \rightarrow \boldsymbol{\zeta<em 0="0">{2}, \text { motion }\left(q</em>}, \boldsymbol{\zeta<em 2="2">{1}\right) \rightarrow \boldsymbol{\tau}</em>}, \text { motion }\left(\boldsymbol{\zeta<em 2="2">{1}, \boldsymbol{\zeta}</em>
\end{aligned}
$$}\right) \rightarrow \boldsymbol{\tau}_{4} \text { ] </p>
<p>Assuming each stream evaluation is successful, the following objects are produced, which correspond to bindings $B=\left{\boldsymbol{\gamma}<em 1="1">{\mathbf{1}}: g</em>}, \boldsymbol{\rho<em 1="1">{\mathbf{1}}: p</em>}, \boldsymbol{\zeta<em 1="1">{\mathbf{1}}: q</em>}, \boldsymbol{\zeta<em 2="2">{\mathbf{2}}: q</em>}, \boldsymbol{\tau<em 1="1">{\mathbf{2}}: t</em>}, \boldsymbol{\tau<em 2="2">{\mathbf{4}}: t</em>^{}\right}$. After substituting these values for their corresponding optimistic objects in $\pi_{1<em>}$, the plan $\pi_{1}$ is returned as a solution.
$\operatorname{next}(\operatorname{grasps}(\mathrm{b}))=g_{1}, \operatorname{next}(\operatorname{poses}(\mathrm{b}, \mathrm{r}))=p_{1}$
$\operatorname{next}\left(\mathrm{ik}\left(\mathrm{b}, p_{0}, g_{1}\right)\right)=q_{1}, \operatorname{next}\left(\mathrm{ik}\left(\mathrm{b}, p_{1}, g_{1}\right)\right)=q_{2}$
$\operatorname{next}\left(\operatorname{motion}\left(q_{0}, q_{1}\right)\right)\right)=t_{1}, \operatorname{next}\left(\operatorname{motion}\left(q_{1}, q_{2}\right)\right)=t_{2}$
In the event that, for example, an inverse kinematic stream evaluation fails, e.g. next $\left(\mathrm{ik}\left(\mathrm{b}, p_{0}, g_{1}\right)\right)=$ None, BINDING-PROCESS-STREAMS terminates, and the levels of grasps(b) and $\operatorname{ik}\left(\mathrm{b}, p_{0}, g_{1}\right)$ are incremented to 2 and 3 . As a result, both of the following optimistic stream sequences are only possible when maximum level $l \geq 4$, preventing them from being applied again until $l$ is incremented due to SEARCH failing to find a plan $\left(\pi_{1}^{</em>}=\right.$ None $)$.</p>
<p>1) $\mid \operatorname{grasps}(\mathrm{b}) \rightarrow \boldsymbol{\gamma}<em 0="0">{1}, \mathrm{ik}\left(\mathrm{b}, p</em>}, \boldsymbol{\gamma<em 1="1">{1}\right) \rightarrow \boldsymbol{\zeta}</em>}, \operatorname{motion}\left(q_{0}, \zeta_{1}\right) \rightarrow \boldsymbol{\tau<em 0="0">{1} \mid$
2) $\left[\mathrm{ik}\left(\mathrm{b}, p</em>}, g_{1}\right) \rightarrow \boldsymbol{\zeta<em 0="0">{2}, \operatorname{motion}\left(q</em>}, \boldsymbol{\zeta<em 2="2">{2}\right) \rightarrow \boldsymbol{\tau}</em>\right]$</p>
<h3>8.3 Adaptive Algorithm</h3>
<p>The Binding algorithm will reconsider each previously identified stream plan $\psi$ using BINDING-PROCESS-STREAMS. However, it may perform many calls to SEARCH, each of which is expensive, before $\psi$ can be revisted. Rather than always explore new optimistic plans, it may be beneficial to exploit our current set of optimistic plans by expending more computation to find feasible bindings for them. Doing so can be advantageous because these plans can be repeatedly processed without any overhead from SEARCH. As a result, an algorithm can aggressively search through the space of bindings to attempt to find a satisfying set as well as locally optimize for bindings that correspond to low-cost instantiations of the optimistic plan. However, there may be stream plans that are not satisfiable, such as in Domain 2 and Domain 3, so an algorithm still may need to explore additional optimistic plans. This goal of balancing the explorationexploitation trade-off (Robbins 1952) when planning optimistically is the basis for our Adaptive algorithm.</p>
<p>Instead of evaluating each stream instance only once, ADAPTIVE-PROCESS-STREAMS maintains a queue $Q$ of bindings to repeatedly consider. Each entry contains a stream plan $\psi$, an optimistic plan $\pi^{*}$, bindings $B$, and the next stream plan index $i$ to process. $Q$ persists across all invocations and thus contains bindings for previously identified entries that can be reattempted indefinitely. On each invocation, the queue $Q$ is processed until it is either empty or the time elapsed exceeds a timeout parameter $T$. The best choice of $T$ varies per domain depending on whether it more beneficial to explore (small $T$ ) or exploit (large $T$ ). We maintain a running sum of the time spent by both SEARCH and ADAPTIVE-PROCESS-STREAMS as $T_{s}$ and $T_{p}$ respectively. This enables us to adaptively choose $T \leftarrow$ $\max \left(0, T_{s}-T_{p}\right)$, equating the time spent by both procedures and ensuring that neither dominates the total runtime.</p>
<p>ADAPTIVE-PROCESS-STREAMS $\left(U, \psi_{+}, \pi_{+}^{<em>} ; T\right)$ :
$1 Q=\left[\left\langle\psi_{+}, \pi_{+}^{</em>},{ }, 0\right\rangle\right] / /$ Initialize queue with empty binding
2 while $Q \neq[]$ and not TIMEOUT $(T)$ :
$3 \quad \psi, \pi^{<em>}, B, i=\operatorname{POP}(Q)$
$4 \quad$ if $i=\operatorname{len}(\psi)$ : return APPLY-BINDINGS $\left(B, \pi^{</em>}\right)$
$5 \quad B^{\prime}=$ UPDATE-BINDINGS $(\operatorname{copy}(B), \psi[i])$
$6 \quad$ if $B^{\prime} \neq$ None: $\operatorname{PUSH}\left(Q,\left\langle\psi, \pi^{<em>}, B^{\prime}, i+1\right\rangle\right)$
$7 \quad \operatorname{PUSH}\left(Q,\left\langle\psi, \pi^{</em>}, B, i\right\rangle\right) / /$ Return $\left\langle\psi, \pi^{*}, B, i\right\rangle$ to $Q$
8 return None
Additionally, we implement $Q$ as a priority queue that sorts entries by increasing count $(\psi[i])$ followed by len $(\psi)-$ $i$. This approach lexicographically prefers evaluating entries with stream instances $s(\bar{x})=\psi[i]$ that have been evaluated fewer times followed by stream plans where fewer unbound optimistic objects remain. This strategy applies the optimism in the face of uncertainty (Sutton and Barto 2018) principle by prioritizing partially-bound stream plans that have been explored less. Finally, we continue popping entries off of $Q$, despite the fact that the timeout may be exceeded, as long as count $(s_{i}(\bar{x}))=0$ in order to greedily evaluate stream instances that have yet to be evaluated.</p>
<h3>8.4 Rebinding</h3>
<p>Optimistic plans may contain objects that were generated by streams. For example, in Domain 2, the second optimistic plan $\pi_{2}^{*}$ identified (move actions are omitted) has the stream output objects $g_{1}, q_{1}, p_{1}, q_{2}$ as arguments to the pick and place for the blue block. Because these objects are not optimistic, they are not present as outputs in stream plan $\psi_{2}$, and thus ADAPTIVE-PROCESS-STREAMS cannot bind them.</p>
<p>$$
\begin{aligned}
\pi_{2}^{*}= &amp; {\left[\operatorname{pick}\left(\operatorname{red}, p_{0}^{\prime}, \boldsymbol{\gamma}<em 1="1">{1}^{\prime}, \boldsymbol{\zeta}</em>}^{\prime}\right), \text { place }\left(\operatorname{red}, \boldsymbol{\rho<em 1="1">{1}^{\prime}, \boldsymbol{\gamma}</em>}^{\prime}, \boldsymbol{\zeta<em 0="0">{2}^{\prime}\right)\right.} \
&amp; \left.\operatorname{pick}(\text { blue }, p</em>}, \underline{g<em 1="1">{1}, \underline{q}</em>}), \text { place }\left(\text { blue }, \underline{p<em 1="1">{1}, \underline{q}</em>\right)\right]
\end{aligned}
$$}, \underline{q}_{2</p>
<p>However, the new optimistic objects $\boldsymbol{\gamma}<em 1="1">{1}^{\prime}, \boldsymbol{\zeta}</em>}^{\prime}, \boldsymbol{\rho<em 2="2">{1}^{\prime}, \boldsymbol{\zeta}</em>}^{\prime}$ are still subject to constraints and costs involving the fixed objects $g_{1}, q_{1}, p_{1}, q_{2}$. For instance, the stream plan tail $\left[\operatorname{motion}\left(\boldsymbol{\zeta<em 1="1">{2}^{\prime}, q</em>}\right) \rightarrow \boldsymbol{\tau<em 4="4">{4}\right.$, Dist $\left(\boldsymbol{\tau}</em>}\right)$ ] implicitly tests whether $q_{1}$ is reachable from $\boldsymbol{\zeta<em 4="4">{2}^{\prime}$ and imposes a cost based on the distance traveled along a trajectory $\tau</em>]\right)\right)$, which additionally extracts the sequence of stream instances that produced each non-optimistic object. As a result, fixed objects are now treated as optimistic objects that can take on new values through rebinding. This allows ADAPTIVE-PROCESSSTREAMS to explore additional combinations of bindings to more quickly find both feasible and low-cost solutions.}$ between them. Intuitively, we would instead want to explore combinations of all these arguments as free parameters. To do this, we alter line 7 in OPTIMISTIC to be $\psi=$ RETRACE $\left(\mathcal{I}, U^{*}\right.$, PREIMAGE $\left.\left(\pi+[\mathcal{G</p>
<h2>9 Experiments</h2>
<p>We experimented using the Incremental, Focused, Binding, and Adaptive algorithms on 100 randomly-generated problems within 3 domains in section 4. The Incremental and Focused algorithms serve as baselines that are representative of prior work (Garrett, Lozano-Pérez, and Kaelbling 2018). We enforced a 2 minute timeout that includes stream</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: From left to right: Domain 1 success percent, Domain 1 mean runtime, and Domain 2.
<img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 4: From left to right: Domain 3 success percent, Domain 3 mean runtime, and plan cost over time for Domain 2.
evaluation time. An open-source Python implementation is available at https://github.com/caelan/pddlstream. We use the FastDownward (Helmert 2006) planning system to implement SEARCH. The stream conditional generators were implemented using PyBullet (Coumans and Bai 2016).</p>
<p>Figure 4 shows the success rate and mean runtime of successful trials for Domain 1 as the number of blocks increases from 3 to 5 , which causes the problem to become more constrained. Adaptive outperforms Incremental, Focused, and Binding due to its ability to aggressively search over many bindings of a single stream plan. Figure 4 shows the average plan cost over time with a 0.5 standard deviation confidence interval for Domain 2. Incremental is omitted because it only solved $83 \%$ of the problem instances Adaptive converges to a low-cost solution more quickly than Focused and Binding. Figure 3 shows the success rate and mean runtime of successful trials for Domain 3 as the number of objectives increases from 2 to 4 . Focused, Binding, and Adaptive all outperform Incremental and perform about equivalently due to the less geometrically constrained nature of the domain. The additional stream binding computation only marginally increases the runtime of Adaptive.</p>
<h3>9.1 Real-World Validation</h3>
<p>We applied PDDLStream to four real-world task and motion planning problems. For each task, a PR2 robot observes the initial state, solves for a plan, and executes it in an open-loop fashion. Our PDDLStream domain description includes 9 actions: move, pick, place, stack, push,
press, pour, scoop, stir, and cook. Each action is supported by one or more streams that sample its continuous control parameters. Figure 1 shows the PR2 solving the serve task, where it "prepares a meal" by serving a beverage (blue cup) and a cooked cabbage (green block) on the brown tray. The robot "cooks" the cabbage by placing it on the stove, turning the stove on, waiting, and turning the stove off. Like in Domain 1, this problem requires tightly packing the beverage and cabbage on the tray. Adaptive is able to quickly identify a collision-free pair of placements supporting a solution. See the extended version of this paper (https://arxiv.org/abs/1802.08705) for descriptions of the other tasks. Videos of the PR2 completing each task are available at https://tinyurl.com/pddlstream.</p>
<h2>10 Conclusion</h2>
<p>PDDLStream is a general-purpose framework for incorporating sampling procedures in a planning language. We introduced two new algorithms that reduce PDDLStream planning to solving a series of finite PDDL problems. Our Adaptive algorithm balances the time spent searching and sampling, allowing it to aggressively explore many possible bindings. As a result, it outperforms existing algorithms, particularly on tightly-constrained and cost-sensitive problems by greedily optimizing discovered plans. Finally, we demonstrated that PDDLStream can be used to plan for realworld robots operating using a diverse set of actions.</p>
<h2>References</h2>
<p>Bonet, B., and Geffner, H. 2001. Planning as heuristic search. Artificial Intelligence 129(1):5-33.
Bryce, D.; Gao, S.; Musliner, D. J.; and Goldman, R. P. 2015. SMT-based nonlinear PDDL+ planning. In AAAI.
Cashmore, M.; Fox, M.; Long, D.; and Magazzeni, D. 2016. A compilation of the full pddl+ language into smt. In International Conference on Automated Planning and Scheduling (ICAPS), 79-87. AAAI Press.
Coumans, E., and Bai, Y. 2016. Pybullet, a python module for physics simulation for games, robotics and machine learning. http://pybullet.org.
Dantam, N. T.; Kingston, Z.; Chaudhuri, S.; and Kavraki, L. E. 2016. Incremental task and motion planning: A constraint-based approach. In Robotics: Science and Systems (RSS).
Della Penna, G.; Magazzeni, D.; Mercorio, F.; and Intrigila, B. 2009. Upmurphi: A tool for universal planning on pddl+ problems. In International Conference on Automated Planning and Scheduling (ICAPS).
Dellin, C. M., and Srinivasa, S. S. 2016. A unifying formalism for shortest path problems with expensive edge evaluations via lazy best-first search over paths with edge selectors. International Conference on Automated Planning and Scheduling (ICAPS).
Dornhege, C.; Gissler, M.; Teschner, M.; and Nebel, B. 2009a. Integrating symbolic and geometric planning for mobile manipulation. In IEEE International Workshop on Safety, Security and Rescue Robotics.
Dornhege, C.; Eyerich, P.; Keller, T.; Trüg, S.; Brenner, M.; and Nebel, B. 2009b. Semantic attachments for domainindependent planning systems. In International Conference on Automated Planning and Scheduling (ICAPS), 114-121. AAAI Press.
Dornhege, C. 2014. Task planning for high-level robot control.
Fernández-González, E.; Williams, B.; and Karpas, E. 2018. Scottyactivity: mixed discrete-continuous planning with convex optimization. Journal of Artificial Intelligence Research 62:579-664.
Fikes, R. E., and Nilsson, N. J. 1971. STRIPS: A new approach to the application of theorem proving to problem solving. Artificial Intelligence 2:189-208.
Fox, M., and Long, D. 2003. Pddl2.1: an extension to PDDL for expressing temporal planning domains. Journal of Artificial Intelligence Research (JAIR) 20:2003.
Fox, M., and Long, D. 2006. Modelling mixed discretecontinuous domains for planning. J. Artif. Intell. Res.(JAIR) 27:235-297.
Garrett, C. R.; Lozano-Pérez, T.; and Kaelbling, L. P. 2015. Backward-forward search for manipulation planning. In IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS).
Garrett, C. R.; Lozano-Pérez, T.; and Kaelbling, L. P. 2017. Ffrob: leveraging symbolic planning for efficient task and
motion planning. The International Journal of Robotics Research.
Garrett, C. R.; Lozano-Pérez, T.; and Kaelbling, L. P. 2018. Sampling-based methods for factored task and motion planning. The International Journal of Robotics Research.
Gregory, P.; Long, D.; Fox, M.; and Beck, J. C. 2012. Planning modulo theories: Extending the planning paradigm. In International Conference on Automated Planning and Scheduling (ICAPS).
Helmert, M. 2006. The fast downward planning system. Journal of Artificial Intelligence Research (JAIR) 26:191246.</p>
<p>Hertle, A.; Dornhege, C.; Keller, T.; and Nebel, B. 2012. Planning with semantic attachments: An object-oriented view. In Proceedings of the 20th European Conference on Artificial Intelligence, 402-407. IOS Press.
Hoffmann, J. 2003. The metric-ff planning system: Translating "ignoring delete lists" to numeric state variables. Journal of artificial intelligence research 20:291-341.
Kaelbling, L. P., and Lozano-Pérez, T. 2011. Hierarchical planning in the now. In IEEE International Conference on Robotics and Automation (ICRA).
Long, D., and Fox, M. 2003. The 3rd international planning competition: Results and analysis. Journal of Artificial Intelligence Research 20:1-59.
McDermott, D.; Ghallab, M.; Howe, A.; Knoblock, C.; Ram, A.; Veloso, M.; Weld, D.; and Wilkins, D. 1998. Pddl: The planning domain definition language. Technical report, Yale Center for Computational Vision and Control.
Pednault, E. P. 1989. Adl: exploring the middle ground between strips and the situation calculus. In Proceedings of the first international conference on Principles of knowledge representation and reasoning, 324-332. Morgan Kaufmann Publishers Inc.
Piotrowski, W.; Fox, M.; Long, D.; Magazzeni, D.; and Mercorio, F. 2016. Heuristic planning for pddl+ domains. In Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence (IJCAI).
Robbins, H. 1952. Some aspects of the sequential design of experiments. Bulletin of the American Mathematical Society 58(5):527-535.
Srivastava, S.; Fang, E.; Riano, L.; Chitnis, R.; Russell, S.; and Abbeel, P. 2014. Combined task and motion planning through an extensible planner-independent interface layer. In IEEE International Conference on Robotics and Automation (ICRA).
Sutton, R. S., and Barto, A. G. 2018. Reinforcement learning: An introduction. MIT press.
Thiébaux, S.; Hoffmann, J.; and Nebel, B. 2005. In defense of pddl axioms. Artificial Intelligence 168(1-2):38-69.
Toussaint, M. 2015. Logic-geometric programming: an optimization-based approach to combined task and motion planning. In AAAI Conference on Artificial Intelligence, 1930-1936. AAAI Press.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>*We gratefully acknowledge support from NSF grants 1523767 and 1723381; from AFOSR grant FA9550-17-1-0165; from ONR grant N00014-18-1-2847; from the Honda Research Institute; and from SUTD Temasek Laboratories. Any opinions, findings, and conclusions expressed in this material are those of the authors and do not necessarily reflect the views of our sponsors.
Copyright (C) 2020, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>