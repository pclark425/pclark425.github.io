<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-3170 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-3170</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-3170</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-74.html">extraction-schema-74</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the agent, the memory mechanism, the tasks, and performance comparisons.</div>
                <p><strong>Paper ID:</strong> paper-7ec58d26c4dddb4bc3b6829fa0654a22cc26fdfe</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/7ec58d26c4dddb4bc3b6829fa0654a22cc26fdfe" target="_blank">Memory Augmented Large Language Models are Computationally Universal</a></p>
                <p><strong>Paper Venue:</strong> arXiv.org</p>
                <p><strong>Paper TL;DR:</strong> It is established that an existing large language model, Flan-U-PaLM 540B, can be combined with an associative read-write memory to exactly simulate the execution of a universal Turing machine, $U_{15,2}$.</p>
                <p><strong>Paper Abstract:</strong> We show that transformer-based large language models are computationally universal when augmented with an external memory. Any deterministic language model that conditions on strings of bounded length is equivalent to a finite automaton, hence computationally limited. However, augmenting such models with a read-write memory creates the possibility of processing arbitrarily large inputs and, potentially, simulating any algorithm. We establish that an existing large language model, Flan-U-PaLM 540B, can be combined with an associative read-write memory to exactly simulate the execution of a universal Turing machine, $U_{15,2}$. A key aspect of the finding is that it does not require any modification of the language model weights. Instead, the construction relies solely on designing a form of stored instruction computer that can subsequently be programmed with a specific set of prompts.</p>
                <p><strong>Cost:</strong> 0.01</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e3170.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e3170.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the agent, the memory mechanism, the tasks, and performance comparisons.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Flan-U-PaLM 540B</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Flan-U-PaLM 540B</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A 540-billion-parameter instruction-finetuned transformer language model used as the 'CPU' in the paper's stored-instruction computer setup; called with deterministic (greedy, temperature=0) decoding to produce compact result strings that are parsed to update external memory.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>Flan-U-PaLM 540B</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>A large transformer-based language model (540B parameters) refined with instruction fine-tuning; used without any weight modifications and invoked repeatedly as the central processing unit in an external-memory loop, returning short string outputs that encode variable assignments, increments, and next-instruction tokens.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>external associative read-write memory (dictionary)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism_description</strong></td>
                            <td>An external associative dictionary called MEMORY maps string keys to string or integer values. Interaction is limited to finite-state pre/post processing: prompts are retrieved from MEMORY['op'], nested @[...] substitutions splice values into prompts (bounded nesting depth), the LLM output is post-processed by regex to detect assignments of the form key = "value" (with %[...] splicing to write to dynamic keys), and integer +=/-= updates are parsed and applied. The main loop repeatedly retrieves the instruction from MEMORY['op'], runs substitute_nested to assemble the prompt, calls the LLM (greedy decoding), substitutes %[...] in the result, applies assignments and integer updates, and repeats until 'halt'.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Simulation of universal Turing machine U_{15,2}</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Demonstrate computational universality by using the LLM+external memory loop to exactly simulate each transition of the 15-state, 2-symbol universal Turing machine U_{15,2}; the challenge is reliably eliciting the correct conditional branching and assignment strings from the frozen LLM so that externally-managed memory updates replicate the Turing machine's tape, head position, and state.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>algorithm simulation / computational universality demonstration</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>29/29 verification cases produced the intended result strings (enumerated verification of every (state, symbol) combination) under greedy decoding (temperature=0); the paper reports successful exact simulation when the LLM returns the expected strings.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_comparison</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>A frozen Flan-U-PaLM 540B model, when repeatedly invoked in a tightly controlled prompt loop and coupled to an associative read-write memory with finite-state pre/post-processing, can be programmed (via stored instruction strings) to exactly simulate the universal Turing machine U_{15,2}; this yields computational universality without any weight changes. The approach relies on isolating a sufficiently reliable subset of the LLM's input-output map and using that as a compact instruction set.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Behavior was brittle and required careful prompt engineering; eliciting correct conditionals was particularly challenging (if-then only, not reliable if-then-else), compact terse prompts were necessary, not all LMs tested succeeded, and various formatting/artifact issues appeared in some outputs; pre/post processing must be bounded to preserve finite-state constraints (e.g., nested substitutions bounded to depth 2).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Memory Augmented Large Language Models are Computationally Universal', 'publication_date_yy_mm': '2023-01'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3170.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e3170.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the agent, the memory mechanism, the tasks, and performance comparisons.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Stored Instruction Computer</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Stored Instruction Computer (LM as CPU + associative memory)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An architecture introduced in the paper where a frozen language model functions as the CPU and an external associative dictionary provides read-write memory; computation proceeds via a repeated cycle of fetching an instruction from MEMORY['op'], splicing in operands, calling the LLM, and applying regex-based updates to memory.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>Stored Instruction Computer (LM as CPU)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>A simple feedback-loop architecture: the language model acts as the CPU producing short textual 'result' strings encoding assignments and control flow, while an external associative memory (a Python dictionary) stores instruction strings, tape contents, the instruction register 'op', and the head position 'i'. Finite-state pre/post processors (regular-expression-based) perform splicing and parsing to keep all non-LLM computation finite-state.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>external associative read-write memory (dictionary) / instruction register</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism_description</strong></td>
                            <td>Memory is a dictionary MEMORY mapping string keys to string/integer values. The instruction register is MEMORY['op']; pre-processing performs @[...] nested substitutions to assemble prompts; post-processing substitutes %[...] (to address dynamic keys), extracts assignments of the form label = "value" to update MEMORY[label], and applies integer +=/-= updates. All parsing is implemented with regular expressions (finite-state) and nesting depth is bounded to preserve the finite-state nature of pre/post-processing.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Implementing the instruction cycle to simulate algorithms (used to run U_{15,2})</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Provide the control loop and auxiliary pre/post processing so the LLM can be used as the central computational unit to perform algorithmic steps; main challenge is ensuring the LLM reliably emits the small, formally-parseable strings needed for deterministic external-memory updates and branching.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>architecture / algorithm simulation</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>N/A (architecture enables the simulation—empirical verification was done with Flan-U-PaLM 540B producing correct outputs for all 29 transition cases)</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_comparison</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>The stored-instruction computer design shows that with finite-state pre/post-processing and an associative read-write memory, a frozen transformer LLM can be orchestrated to simulate a universal Turing machine; memory + repeated LLM calls expands the practical computations beyond the bounded context window of the model.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Requires careful engineering of compact instruction strings and bounded preprocessing; reliance on brittle conditional elicitation from the LLM (could not reliably elicit if-then-else), and overall correctness depends on the model producing exact expected strings for each instruction; unbounded nested substitution would violate finite-state constraints, so nesting must be explicitly bounded.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Memory Augmented Large Language Models are Computationally Universal', 'publication_date_yy_mm': '2023-01'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Least-to-Most Prompting Enables Complex Reasoning in Large Language Models <em>(Rating: 2)</em></li>
                <li>Language Model Cascades <em>(Rating: 2)</em></li>
                <li>FLAN-U-PaLM: Instruction Tuning PaLM with Chain-of-Thought <em>(Rating: 2)</em></li>
                <li>Chain of Thought Prompting Elicits Reasoning in Large Language Models <em>(Rating: 2)</em></li>
                <li>On the Computational Power of Transformers and its Implications in Sequence Modeling <em>(Rating: 1)</em></li>
                <li>Small Universal Turing Machines and Weak Universality (Neary and Woods / Neary 2008-2009 related work) <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-3170",
    "paper_id": "paper-7ec58d26c4dddb4bc3b6829fa0654a22cc26fdfe",
    "extraction_schema_id": "extraction-schema-74",
    "extracted_data": [
        {
            "name_short": "Flan-U-PaLM 540B",
            "name_full": "Flan-U-PaLM 540B",
            "brief_description": "A 540-billion-parameter instruction-finetuned transformer language model used as the 'CPU' in the paper's stored-instruction computer setup; called with deterministic (greedy, temperature=0) decoding to produce compact result strings that are parsed to update external memory.",
            "citation_title": "",
            "mention_or_use": "use",
            "agent_name": "Flan-U-PaLM 540B",
            "agent_description": "A large transformer-based language model (540B parameters) refined with instruction fine-tuning; used without any weight modifications and invoked repeatedly as the central processing unit in an external-memory loop, returning short string outputs that encode variable assignments, increments, and next-instruction tokens.",
            "memory_used": true,
            "memory_type": "external associative read-write memory (dictionary)",
            "memory_mechanism_description": "An external associative dictionary called MEMORY maps string keys to string or integer values. Interaction is limited to finite-state pre/post processing: prompts are retrieved from MEMORY['op'], nested @[...] substitutions splice values into prompts (bounded nesting depth), the LLM output is post-processed by regex to detect assignments of the form key = \"value\" (with %[...] splicing to write to dynamic keys), and integer +=/-= updates are parsed and applied. The main loop repeatedly retrieves the instruction from MEMORY['op'], runs substitute_nested to assemble the prompt, calls the LLM (greedy decoding), substitutes %[...] in the result, applies assignments and integer updates, and repeats until 'halt'.",
            "task_name": "Simulation of universal Turing machine U_{15,2}",
            "task_description": "Demonstrate computational universality by using the LLM+external memory loop to exactly simulate each transition of the 15-state, 2-symbol universal Turing machine U_{15,2}; the challenge is reliably eliciting the correct conditional branching and assignment strings from the frozen LLM so that externally-managed memory updates replicate the Turing machine's tape, head position, and state.",
            "task_type": "algorithm simulation / computational universality demonstration",
            "performance_with_memory": "29/29 verification cases produced the intended result strings (enumerated verification of every (state, symbol) combination) under greedy decoding (temperature=0); the paper reports successful exact simulation when the LLM returns the expected strings.",
            "performance_without_memory": null,
            "has_performance_comparison": false,
            "key_findings": "A frozen Flan-U-PaLM 540B model, when repeatedly invoked in a tightly controlled prompt loop and coupled to an associative read-write memory with finite-state pre/post-processing, can be programmed (via stored instruction strings) to exactly simulate the universal Turing machine U_{15,2}; this yields computational universality without any weight changes. The approach relies on isolating a sufficiently reliable subset of the LLM's input-output map and using that as a compact instruction set.",
            "limitations_or_challenges": "Behavior was brittle and required careful prompt engineering; eliciting correct conditionals was particularly challenging (if-then only, not reliable if-then-else), compact terse prompts were necessary, not all LMs tested succeeded, and various formatting/artifact issues appeared in some outputs; pre/post processing must be bounded to preserve finite-state constraints (e.g., nested substitutions bounded to depth 2).",
            "uuid": "e3170.0",
            "source_info": {
                "paper_title": "Memory Augmented Large Language Models are Computationally Universal",
                "publication_date_yy_mm": "2023-01"
            }
        },
        {
            "name_short": "Stored Instruction Computer",
            "name_full": "Stored Instruction Computer (LM as CPU + associative memory)",
            "brief_description": "An architecture introduced in the paper where a frozen language model functions as the CPU and an external associative dictionary provides read-write memory; computation proceeds via a repeated cycle of fetching an instruction from MEMORY['op'], splicing in operands, calling the LLM, and applying regex-based updates to memory.",
            "citation_title": "here",
            "mention_or_use": "use",
            "agent_name": "Stored Instruction Computer (LM as CPU)",
            "agent_description": "A simple feedback-loop architecture: the language model acts as the CPU producing short textual 'result' strings encoding assignments and control flow, while an external associative memory (a Python dictionary) stores instruction strings, tape contents, the instruction register 'op', and the head position 'i'. Finite-state pre/post processors (regular-expression-based) perform splicing and parsing to keep all non-LLM computation finite-state.",
            "memory_used": true,
            "memory_type": "external associative read-write memory (dictionary) / instruction register",
            "memory_mechanism_description": "Memory is a dictionary MEMORY mapping string keys to string/integer values. The instruction register is MEMORY['op']; pre-processing performs @[...] nested substitutions to assemble prompts; post-processing substitutes %[...] (to address dynamic keys), extracts assignments of the form label = \"value\" to update MEMORY[label], and applies integer +=/-= updates. All parsing is implemented with regular expressions (finite-state) and nesting depth is bounded to preserve the finite-state nature of pre/post-processing.",
            "task_name": "Implementing the instruction cycle to simulate algorithms (used to run U_{15,2})",
            "task_description": "Provide the control loop and auxiliary pre/post processing so the LLM can be used as the central computational unit to perform algorithmic steps; main challenge is ensuring the LLM reliably emits the small, formally-parseable strings needed for deterministic external-memory updates and branching.",
            "task_type": "architecture / algorithm simulation",
            "performance_with_memory": "N/A (architecture enables the simulation—empirical verification was done with Flan-U-PaLM 540B producing correct outputs for all 29 transition cases)",
            "performance_without_memory": null,
            "has_performance_comparison": false,
            "key_findings": "The stored-instruction computer design shows that with finite-state pre/post-processing and an associative read-write memory, a frozen transformer LLM can be orchestrated to simulate a universal Turing machine; memory + repeated LLM calls expands the practical computations beyond the bounded context window of the model.",
            "limitations_or_challenges": "Requires careful engineering of compact instruction strings and bounded preprocessing; reliance on brittle conditional elicitation from the LLM (could not reliably elicit if-then-else), and overall correctness depends on the model producing exact expected strings for each instruction; unbounded nested substitution would violate finite-state constraints, so nesting must be explicitly bounded.",
            "uuid": "e3170.1",
            "source_info": {
                "paper_title": "Memory Augmented Large Language Models are Computationally Universal",
                "publication_date_yy_mm": "2023-01"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Least-to-Most Prompting Enables Complex Reasoning in Large Language Models",
            "rating": 2
        },
        {
            "paper_title": "Language Model Cascades",
            "rating": 2
        },
        {
            "paper_title": "FLAN-U-PaLM: Instruction Tuning PaLM with Chain-of-Thought",
            "rating": 2
        },
        {
            "paper_title": "Chain of Thought Prompting Elicits Reasoning in Large Language Models",
            "rating": 2
        },
        {
            "paper_title": "On the Computational Power of Transformers and its Implications in Sequence Modeling",
            "rating": 1
        },
        {
            "paper_title": "Small Universal Turing Machines and Weak Universality (Neary and Woods / Neary 2008-2009 related work)",
            "rating": 1
        }
    ],
    "cost": 0.0098795,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Memory Augmented Large Language Models are Computationally Universal</h1>
<p>Dale Schuurmans<br>Google Brain \&amp; University of Alberta</p>
<h4>Abstract</h4>
<p>We show that transformer-based large language models are computationally universal when augmented with an external memory. Any deterministic language model that conditions on strings of bounded length is equivalent to a finite automaton, hence computationally limited. However, augmenting such models with a read-write memory creates the possibility of processing arbitrarily large inputs and, potentially, simulating any algorithm. We establish that an existing large language model, Flan-U-PaLM 540B, can be combined with an associative read-write memory to exactly simulate the execution of a universal Turing machine, $U_{15,2}$. A key aspect of the finding is that it does not require any modification of the language model weights. Instead, the construction relies solely on designing a form of stored instruction computer that can subsequently be programmed with a specific set of prompts.</p>
<h2>1 Introduction</h2>
<p>Interest in large language models has grown dramatically since the early successes of GPT2, GPT-3 and InstructGPT [Radford et al., 2019, Brown et al., 2020, Ouyang et al., 2022], and more recently with the popularity of ChatGPT [Schulman et al., 2022]. Beyond simple question answering, where an input string posing a question might elicit an output string containing a reasonable answer, an important discovery has been the emergence of in-context learning, where prepending a question with a set of related (question, answer) pairs significantly improves question answering accuracy [Radford et al., 2019]. Even adding a natural language instruction before example pairs appears to further enhance language model capabilities [Brown et al., 2020]. More recently, chain of thought prompting has been found to improve question answering ability in scenarios where multiple reasoning steps are required to arrive at a final answer, such as answering math word problems [Wei et al., 2022b].</p>
<p>Despite these results, current transformer-based large language models remain fundamentally limited as they can only condition on an input string of bounded length, such as 4096 tokens. This makes such models formally equivalent to finite automata, hence restricted in the computations they can express. However, recent works have begun to investigate techniques for chaining multiple calls to a language model by processing model outputs then</p>
<p>passing these back as subsequent inputs to the model. An example is least to most prompting, where a complex reasoning question is answered first by prompting the model to produce simpler sub-questions, then passing each sub-question and resulting answer back into the model to help answer subsequent sub-questions, until a final answer is reached [Zhou et al., 2022]. Another example is work on language model cascades that investigates various strategies for processing model outputs and feeding these as inputs to subsequent language model calls [Dohan et al., 2022]. Such works raise the question of whether augmenting a language model with an external feedback loop is merely useful, or fundamentally expands the range of computations that can be performed. To investigate this question, we consider augmenting a language model with an external read-write memory and ask whether this confers the ability to simulate any algorithm on any input.</p>
<p>This paper gives an affirmative answer by establishing computational universality for a specific large language model, Flan-U-PaLM 540B [Chung et al., 2022], augmented with an associative read-write memory. A key aspect of the result is that it is achieved by developing a simple form of stored instruction computer [von Neumann, 1945] that connects the language model to an associative memory, then follows a simple instruction cycle where the next input prompt to be passed to the language model is retrieved from memory, the output of the language model is parsed to recover any variable assignments that are then stored in the associative memory, and the next instruction is retrieved (i.e., the next input prompt to be provided to the language model). Each parsing step between the language model and memory is performed by a simple regular expression match (i.e., a finite automaton).</p>
<p>Once a stored instruction computer has been created, a specific "prompt program" is designed to drive the system to simulate a universal Turing machine $U_{15,2}$ [Neary, 2008, Neary and Woods, 2009]. Proving the fidelity of the simulation reduces to checking a finite set of prompt-result behaviours and verifying that the language model produces the correct output for each of the finite set of possible input prompt strings it might encounter. That is, although the overall input-output behaviour of the Flan-U-PaLM 540B model is not fully understood, a sufficiently reliable subset of its input-output map can be isolated and controlled to simulate a universal computer. Importantly, this result does not involve any additional "training" of the language model (i.e., no modification of its pre-trained weights), but instead relies solely on providing specific prompt strings to the model and parsing its outputs to determine values to be saved in memory.</p>
<h1>2 Stored instruction computer</h1>
<p>As noted, there are many ways to orchestrate feedback between the outputs of a language model and subsequent input prompts [Zhou et al., 2022, Dohan et al., 2022]. In developing a simple feedback loop we would like to minimize external processing and perform as much of the computation with the language model as possible, while still supporting computational universality. To achieve this, we consider a simple form of stored instruction computer [von Neumann, 1945], where the language model plays the role of a central processing unit (CPU), and the random access memory (RAM) is supplied by an external associative mem-</p>
<p>ory. Such an architecture allows for a simple interaction loop that can support general computation and convenient programmability. In this architecture, the external associative memory is a simple "dictionary", MEMORY, that maps unique keys to values, or equivalently, maps variable names to values, or address locations to values. Unlike the RAM in a physical computer, variable names will be strings (i.e., finite length sequences of symbols from a finite alphabet) to support convenient interaction with a language model, while values will be strings or integers.</p>
<p>To ensure that computational universality does not follow simply from external processing capability, all interaction between the language model and the memory will be restricted to finite state computation, such as simple regular expression parsers.</p>
<p>All code below will be given in Python 3 using the standard regular expression library re. Note that the regular expressions used for pre and post processing are rudimentary and can easily be improved in several ways; the versions given are merely sufficient to establish the main points in this paper.</p>
<h1>2.1 Post processing language model outputs</h1>
<p>The output string from the language model will be parsed by a simple regular expression that detects assignments in the form variable_name = "value", which are then applied to the associative memory as MEMORY[variable_name] = "value". The variable assignment function assignments is shown below.</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">assignments</span><span class="p">(</span><span class="n">string</span><span class="p">)</span><span class="err">:</span>
<span class="w">    </span><span class="k">global</span><span class="w"> </span><span class="n">MEMORY</span>
<span class="w">    </span><span class="n">regex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;(?s)(?:((?:\w|\-)+)\s*=\s*(?:\&quot;((?:.*\n)|(?:[^\&quot;]*))\&quot;))(.*)&#39;</span>
<span class="w">    </span><span class="n">matches</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="p">)</span>
<span class="w">    </span><span class="n">suffix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;&#39;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="nf">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="err">:</span>
<span class="w">        </span><span class="n">label</span><span class="p">,</span><span class="w"> </span><span class="k">value</span><span class="p">,</span><span class="w"> </span><span class="n">suffix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">matches</span><span class="o">[</span><span class="n">0</span><span class="o">]</span>
<span class="w">        </span><span class="n">MEMORY</span><span class="o">[</span><span class="n">label</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">value</span>
<span class="w">        </span><span class="n">matches</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span><span class="w"> </span><span class="n">suffix</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">suffix</span>
</code></pre></div>

<p>Additionally, splicing is allowed in value strings before being assigned to memory; that is, we include a regular expression parser that detects occurrences of the pattern \%[variable_name] in any value string, replacing any such occurrence with the string at memory location variable_name, i.e., MEMORY[variable_name], before assignment. The substitution function substitute is shown below.</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">substitute</span><span class="p">(</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="nc">char</span><span class="p">)</span><span class="err">:</span>
<span class="w">    </span><span class="k">global</span><span class="w"> </span><span class="n">MEMORY</span><span class="p">,</span><span class="w"> </span><span class="n">BLANK</span>
<span class="w">    </span><span class="n">regex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="ss">&quot;(?s)(.*?)(?:{char}\[(\w+)\])(.*)&quot;</span>
<span class="w">    </span><span class="n">matches</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="p">)</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">suffix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;&#39;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="nf">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="err">:</span>
<span class="w">        </span><span class="k">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">label</span><span class="p">,</span><span class="w"> </span><span class="n">suffix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">matches</span><span class="o">[</span><span class="n">0</span><span class="o">]</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">label</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nl">MEMORY</span><span class="p">:</span>
<span class="w">            </span><span class="n">MEMORY</span><span class="o">[</span><span class="n">label</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BLANK</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">label</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">BLANK</span><span class="w"> </span><span class="k">value</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="k">default</span>
<span class="w">        </span><span class="n">string</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">prefix</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nf">str</span><span class="p">(</span><span class="n">MEMORY</span><span class="o">[</span><span class="n">label</span><span class="o">]</span><span class="p">)</span>
<span class="w">        </span><span class="n">matches</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span><span class="w"> </span><span class="n">suffix</span><span class="p">)</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">suffix</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">string</span>
</code></pre></div>

<p>As a final convenience, we also allow integer values to be stored and incremented or decremented. Such integer variable updating is achieved by parsing the output string for occurrences of the pattern variable_name += increment or variable_name -= decrement then applying the updates to variable_name in memory. Importantly, integer addition is also a finite state operation (see, for example, [Sipser, 2013, Problem 1.32]), while the Python standard implements the bignum type that handles arbitrarily large integers. The update function updates is shown below.</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">updates</span><span class="p">(</span><span class="n">string</span><span class="p">)</span><span class="err">:</span>
<span class="w">    </span><span class="k">global</span><span class="w"> </span><span class="n">MEMORY</span>
<span class="w">    </span><span class="n">regex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;(\w+)\s*((?:\+|\-)=)\s*(\d+)&#39;</span>
<span class="w">    </span><span class="n">matches</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">matches</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">None</span><span class="err">:</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nl">matches</span><span class="p">:</span>
<span class="w">            </span><span class="n">label</span><span class="p">,</span><span class="w"> </span><span class="n">operator</span><span class="p">,</span><span class="w"> </span><span class="n">valuestring</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span>
<span class="w">            </span><span class="nf">sign</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">operator</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="ss">&quot;+=&quot;</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span>
<span class="w">            </span><span class="k">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">int</span><span class="p">(</span><span class="n">valuestring</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">sign</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">label</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">MEMORY</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">isinstance</span><span class="p">(</span><span class="n">MEMORY</span><span class="o">[</span><span class="n">label</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="nc">int</span><span class="p">)</span><span class="err">:</span>
<span class="w">                </span><span class="n">MEMORY</span><span class="o">[</span><span class="n">label</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">value</span>
<span class="w">            </span><span class="k">else</span><span class="err">:</span>
<span class="w">                </span><span class="n">MEMORY</span><span class="o">[</span><span class="n">label</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">value</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">non</span><span class="o">-</span><span class="nc">int</span><span class="w"> </span><span class="n">starts</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="k">default</span>
</code></pre></div>

<h1>2.2 Pre processing language model inputs</h1>
<p>Each input prompt to the language model will be retrieved from a special memory location op and passed as a prompt to the language model in each computational cycle; that is, MEMORY['op'] will serve as an "instruction register". Instruction branching can then be achieved simply by assigning a different prompt string to MEMORY['op'] during a computational cycle.</p>
<p>To access stored memory values, we also allow splicing in the input prompt string retrieved from op. In particular, the regular expression parser for the input prompt first detects patterns of the form @[variable_name] and replaces these by splicing in the string retrieved from MEMORY [variable_name] before passing the prompt string to the language model. For input pre processing, it will also be convenient to allow repeated substitutions of nested @ occurrences, so we add the repeated substitution function substitute_nested below. Note that, technically, allowing arbitrarily nested substitutions can simulate a context free grammar [Sipser, 2013], which violates the constraint of finite state computation; however, we will only use bounded depth nesting (depth bound 2) below to ensure the pre and post processing steps all remain achievable by finite state computation.</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">substitute_nested</span><span class="p">(</span><span class="k">string</span><span class="p">,</span><span class="w"> </span><span class="n">char</span><span class="p">)</span><span class="o">:</span>
<span class="w">    </span><span class="n">regex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="s">&quot;(?s)(.*?)(?:{char}\[(\w+)\])(.*)&quot;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span><span class="w"> </span><span class="k">string</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nl">None:</span>
<span class="w">        </span><span class="k">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">substitute</span><span class="p">(</span><span class="k">string</span><span class="p">,</span><span class="w"> </span><span class="n">char</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">string</span>
</code></pre></div>

<h1>2.3 Compute cycle</h1>
<p>Finally, a stored instruction computer can run a single compute cycle: retrieve the next prompt string from MEMORY['op']; process the prompt string by possibly splicing in other strings from memory; pass the prompt string to the language model; process the output string, possibly splicing in other strings from memory, detecting all assignments and increment/decrement updates, applying these to memory; and repeat. Computation proceeds until the next instruction in MEMORY['op'] is the special instruction string 'halt'. In particular, the main loop is constructed as follows.</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="o">:</span>
<span class="w">    </span><span class="n">global</span><span class="w"> </span><span class="n">MEMORY</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="nl">True:</span>
<span class="w">        </span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MEMORY</span><span class="p">[&#39;</span><span class="n">op</span><span class="p">&#39;]</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">&#39;ha</span><span class="n">lt</span><span class="p">&#39;</span><span class="o">:</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">None</span>
<span class="w">        </span><span class="n">prompt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">substitute_nested</span><span class="p">(</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;@&#39;</span><span class="p">)</span>
<span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">call_llm_server</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span>
<span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">substitute</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;%&#39;</span><span class="p">)</span>
<span class="w">        </span><span class="n">suffix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assignments</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="w">        </span><span class="n">updates</span><span class="p">(</span><span class="n">suffix</span><span class="p">)</span>
</code></pre></div>

<p>This main instruction loop demonstrates how the language model plays the role of the CPU, effectively taking the next instruction and its operands expressed by the prompt string and acting on these to produce the result string, which is then used to update the memory.</p>
<h1>3 Universal Turing machine</h1>
<p>The concept of a universal computer - a computing machine that can simulate the execution of any other computing machine on any input-was developed by Alan Turing to solve the Entscheidungsproblem [Turing, 1937]. By the Church-Turing thesis, all computational mechanisms are considered to be expressible by a Turing machine, which informally consists of a finite state controller and an unboundedly large "tape" memory with a "head" that can access a single tape location and move one location left or right in each compute cycle [Sipser, 2013, Chapter 3].</p>
<p>Formally, a Turing machine consists of a tuple $\mathcal{M}=\left(Q, \Sigma, b, q_{0}, T, f\right)$, where $Q$ is a finite set of states, $\Sigma$ is a finite set of tape symbols, $b \in \Sigma$ is the blank symbol, $q_{0} \in Q$ is the start state, $T \subseteq Q \times \Sigma$ is the set of halting (state, symbol) pairs, and $f: Q \times \Sigma \rightarrow \Sigma \times{-1,+1} \times Q$ is a finite set of transition rules that specify the operation of the machine in each compute cycle. We assume the tape is bi-directionally unbounded, so memory locations can be indexed by an integer $i \in \mathbb{Z}$. Let $i_{0} \in \mathbb{Z}$ denote the initial location of the tape head.</p>
<p>The execution of a Turing machine can then be defined as follows. The tape memory is initialized with a finite number of non-blank symbols with all other locations blank, $\mathcal{M}$ starts in state $q_{0}$, and the tape head starts at location $i_{0}$. At the start of each compute cycle, the tape head is at some location $i \in \mathbb{Z}$, the machine is in some state $q \in Q$, and some symbol $\sigma \in \Sigma$ is under the tape head. This combination determines the update $f(q, \sigma) \mapsto\left(\sigma^{\prime}, m, q^{\prime}\right)$, specifying that the symbol $\sigma^{\prime}$ is written at the current memory location $i$, the machine state $q$ is updated to $q^{\prime}$, and the tape head is moved one step left, to location $i^{\prime}=i-1$ if $m=-1$, otherwise one step right, to location $i^{\prime}=i+1$ if $m=+1$. The compute cycle repeats until the machine encounters a configuration $(q, \sigma) \in T$. Non-halting computations are possible.
[Shannon, 1956] began an effort to identify the smallest universal Turing machines in terms of the number of states and tape symbols used. A gap remains between the known upper and lower bounds on the state and symbol counts for a universal Turing machine [Neary, 2008, Neary and Woods, 2009], but progressively smaller universal Turing machines have been identified. We will consider one such machine in this paper, $U_{15,2}$, which uses only 15 states and 2 tape symbols [Neary and Woods, 2009]. This Turing machine is Pareto optimal in terms of the smallest known universal Turing machines [Neary, 2008]. Formally, the Turing machine $U_{15,2}$ can be defined by a tuple $\left(Q, \Sigma, b, q_{0}, T, f\right)$, where $Q=$ ${A, B, C, D, E, F, G, H, I, J, K, L, M, N, O}, \Sigma={0,1}, b=0, q_{0}=A, T={(J, 1)}$, and the transition function $f$ is defined in Table 1. The initial head position $i_{0}$ depends on how the memory is initialized for a given problem instance.</p>
<h2>4 Simulating $U_{15,2}$ with a prompt program</h2>
<p>In this section, we show that the stored instruction computer defined in Section 2 can be programmed to simulate the universal Turing machine $U_{15,2}$, provided that a finite set of conditional assignments and evaluations can be correctly performed by the language model. That is, we first propose a specific prompt program that, if executed correctly, exactly</p>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">A</th>
<th style="text-align: center;">$B$</th>
<th style="text-align: center;">$C$</th>
<th style="text-align: center;">$D$</th>
<th style="text-align: center;">$E$</th>
<th style="text-align: center;">$F$</th>
<th style="text-align: center;">$G$</th>
<th style="text-align: center;">$H$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">$0,+, B$</td>
<td style="text-align: center;">$1,+, C$</td>
<td style="text-align: center;">$0,-, G$</td>
<td style="text-align: center;">$0,-, F$</td>
<td style="text-align: center;">$1,+, A$</td>
<td style="text-align: center;">$1,-, D$</td>
<td style="text-align: center;">$0,+, H$</td>
<td style="text-align: center;">$1,-, I$</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">$1,+, A$</td>
<td style="text-align: center;">$1,+, A$</td>
<td style="text-align: center;">$0,-, E$</td>
<td style="text-align: center;">$1,-, E$</td>
<td style="text-align: center;">$1,-, D$</td>
<td style="text-align: center;">$1,-, D$</td>
<td style="text-align: center;">$1,-, G$</td>
<td style="text-align: center;">$1,-, G$</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">$I$</td>
<td style="text-align: center;">$J$</td>
<td style="text-align: center;">$K$</td>
<td style="text-align: center;">$L$</td>
<td style="text-align: center;">$M$</td>
<td style="text-align: center;">$N$</td>
<td style="text-align: center;">$O$</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">$0,+, A$</td>
<td style="text-align: center;">$1,-, K$</td>
<td style="text-align: center;">$0,+, L$</td>
<td style="text-align: center;">$0,+, M$</td>
<td style="text-align: center;">$0,-, B$</td>
<td style="text-align: center;">$0,-, C$</td>
<td style="text-align: center;">$0,+, N$</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">$1,-, J$</td>
<td style="text-align: center;">halt</td>
<td style="text-align: center;">$1,+, N$</td>
<td style="text-align: center;">$1,+, L$</td>
<td style="text-align: center;">$1,+, L$</td>
<td style="text-align: center;">$0,+, O$</td>
<td style="text-align: center;">$1,+, N$</td>
</tr>
</tbody>
</table>
<p>Table 1: Transition table for the universal Turing machine $U_{15,2}$. Rows are indexed by the read symbol $\sigma$, columns are indexed by the state $q$, and each table entry $\left(\sigma^{\prime}, m, q^{\prime}\right)$ specifies the write symbol $\sigma^{\prime}$, the tape head move $m \in{-1,+1}$, and the next state $q^{\prime}$.
simulates $U_{15,2}$. The next section will then verify that a specific large language model, Flan-U-PaLM 540B, is indeed able to execute each of the program instructions correctly.</p>
<p>A prompt program consists of a finite set of pre designed strings stored in memory that provide input prompts to the language model as part of the main compute cycle, via a call to main() outlined in Section 2. To mimic the behaviour of $U_{15,2}$, we design the prompt program as follows. First, a "boot" prompt is designed that "instructs" the language model about the behaviour of variable assignments, variable evaluations after assignment, and ifthen conditionals.</p>
<div class="codehilite"><pre><span></span><code><span class="n">boot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot;&quot;&quot;</span>
<span class="ss">result = &quot;</span><span class="w"> </span><span class="n">op</span><span class="o">=</span><span class="ss">&quot;%[B]&quot;</span><span class="w"> </span><span class="o">%[</span><span class="n">i</span><span class="o">]=</span><span class="ss">&quot;0&quot;</span><span class="w"> </span><span class="n">i</span><span class="o">+=</span><span class="mi">1</span><span class="w"> </span><span class="ss">&quot;</span>
<span class="ss">if 0==1 then result = &quot;</span><span class="w"> </span><span class="n">op</span><span class="o">=</span><span class="ss">&quot;%[A]&quot;</span><span class="w"> </span><span class="o">%[</span><span class="n">i</span><span class="o">]=</span><span class="ss">&quot;1&quot;</span><span class="w"> </span><span class="n">i</span><span class="o">+=</span><span class="mi">1</span><span class="w"> </span><span class="ss">&quot;</span>
<span class="ss">$result</span>
<span class="ss">&quot;</span><span class="w"> </span><span class="n">op</span><span class="o">=</span><span class="ss">&quot;%[B]&quot;</span><span class="w"> </span><span class="o">%[</span><span class="n">i</span><span class="o">]=</span><span class="ss">&quot;0&quot;</span><span class="w"> </span><span class="n">i</span><span class="o">+=</span><span class="mi">1</span><span class="w"> </span><span class="ss">&quot;</span>
<span class="ss">result = &quot;</span><span class="w"> </span><span class="n">op</span><span class="o">=</span><span class="ss">&quot;%[B]&quot;</span><span class="w"> </span><span class="o">%[</span><span class="n">i</span><span class="o">]=</span><span class="ss">&quot;0&quot;</span><span class="w"> </span><span class="n">i</span><span class="o">+=</span><span class="mi">1</span><span class="w"> </span><span class="ss">&quot;</span>
<span class="ss">if 1==1 then result = &quot;</span><span class="w"> </span><span class="n">op</span><span class="o">=</span><span class="ss">&quot;%[A]&quot;</span><span class="w"> </span><span class="o">%[</span><span class="n">i</span><span class="o">]=</span><span class="ss">&quot;1&quot;</span><span class="w"> </span><span class="n">i</span><span class="o">+=</span><span class="mi">1</span><span class="w"> </span><span class="ss">&quot;</span>
<span class="ss">$result</span>
<span class="ss">&quot;</span><span class="w"> </span><span class="n">op</span><span class="o">=</span><span class="ss">&quot;%[A]&quot;</span><span class="w"> </span><span class="o">%[</span><span class="n">i</span><span class="o">]=</span><span class="ss">&quot;1&quot;</span><span class="w"> </span><span class="n">i</span><span class="o">+=</span><span class="mi">1</span><span class="w"> </span><span class="ss">&quot;</span>
<span class="ss">result = &quot;</span><span class="w"> </span><span class="n">op</span><span class="o">=</span><span class="ss">&quot;%[C]&quot;</span><span class="w"> </span><span class="o">%[</span><span class="n">i</span><span class="o">]=</span><span class="ss">&quot;1&quot;</span><span class="w"> </span><span class="n">i</span><span class="o">+=</span><span class="mi">1</span><span class="w"> </span><span class="ss">&quot;</span>
<span class="ss">if 0==1 then result = &quot;</span><span class="w"> </span><span class="n">op</span><span class="o">=</span><span class="ss">&quot;%[A]&quot;</span><span class="w"> </span><span class="o">%[</span><span class="n">i</span><span class="o">]=</span><span class="ss">&quot;1&quot;</span><span class="w"> </span><span class="n">i</span><span class="o">+=</span><span class="mi">1</span><span class="w"> </span><span class="ss">&quot;</span>
<span class="ss">$result</span>
<span class="ss">&quot;</span><span class="w"> </span><span class="n">op</span><span class="o">=</span><span class="ss">&quot;%[C]&quot;</span><span class="w"> </span><span class="o">%[</span><span class="n">i</span><span class="o">]=</span><span class="ss">&quot;1&quot;</span><span class="w"> </span><span class="n">i</span><span class="o">+=</span><span class="mi">1</span><span class="w"> </span><span class="ss">&quot;</span>
<span class="ss">result = &quot;</span><span class="w"> </span><span class="n">op</span><span class="o">=</span><span class="ss">&quot;%[C]&quot;</span><span class="w"> </span><span class="o">%[</span><span class="n">i</span><span class="o">]=</span><span class="ss">&quot;1&quot;</span><span class="w"> </span><span class="n">i</span><span class="o">+=</span><span class="mi">1</span><span class="w"> </span><span class="ss">&quot;</span>
<span class="ss">if 1==1 then result = &quot;</span><span class="w"> </span><span class="n">op</span><span class="o">=</span><span class="ss">&quot;%[A]&quot;</span><span class="w"> </span><span class="o">%[</span><span class="n">i</span><span class="o">]=</span><span class="ss">&quot;1&quot;</span><span class="w"> </span><span class="n">i</span><span class="o">+=</span><span class="mi">1</span><span class="w"> </span><span class="ss">&quot;</span>
<span class="ss">$result</span>
<span class="ss">&quot;</span><span class="w"> </span><span class="n">op</span><span class="o">=</span><span class="ss">&quot;%[A]&quot;</span><span class="w"> </span><span class="o">%[</span><span class="n">i</span><span class="o">]=</span><span class="ss">&quot;1&quot;</span><span class="w"> </span><span class="n">i</span><span class="o">+=</span><span class="mi">1</span><span class="w"> </span><span class="ss">&quot;</span>
<span class="ss">result = &quot;</span><span class="w"> </span><span class="n">op</span><span class="o">=</span><span class="ss">&quot;%[G]&quot;</span><span class="w"> </span><span class="o">%[</span><span class="n">i</span><span class="o">]=</span><span class="ss">&quot;0&quot;</span><span class="w"> </span><span class="n">i</span><span class="o">-=</span><span class="mi">1</span><span class="w"> </span><span class="ss">&quot;</span>
<span class="ss">if 0==1 then result = &quot;</span><span class="w"> </span><span class="n">op</span><span class="o">=</span><span class="ss">&quot;%[E]&quot;</span><span class="w"> </span><span class="o">%[</span><span class="n">i</span><span class="o">]=</span><span class="ss">&quot;0&quot;</span><span class="w"> </span><span class="n">i</span><span class="o">-=</span><span class="mi">1</span><span class="w"> </span><span class="ss">&quot;</span>
<span class="ss">$result</span>
<span class="ss">&quot;</span><span class="w"> </span><span class="n">op</span><span class="o">=</span><span class="ss">&quot;%[G]&quot;</span><span class="w"> </span><span class="o">%[</span><span class="n">i</span><span class="o">]=</span><span class="ss">&quot;0&quot;</span><span class="w"> </span><span class="n">i</span><span class="o">-=</span><span class="mi">1</span><span class="w"> </span><span class="ss">&quot;</span>
<span class="ss">result = &quot;</span><span class="w"> </span><span class="n">op</span><span class="o">=</span><span class="ss">&quot;%[G]&quot;</span><span class="w"> </span><span class="o">%[</span><span class="n">i</span><span class="o">]=</span><span class="ss">&quot;0&quot;</span><span class="w"> </span><span class="n">i</span><span class="o">-=</span><span class="mi">1</span><span class="w"> </span><span class="ss">&quot;</span>
<span class="ss">if 1==1 then result = &quot;</span><span class="w"> </span><span class="n">op</span><span class="o">=</span><span class="ss">&quot;%[E]&quot;</span><span class="w"> </span><span class="o">%[</span><span class="n">i</span><span class="o">]=</span><span class="ss">&quot;0&quot;</span><span class="w"> </span><span class="n">i</span><span class="o">-=</span><span class="mi">1</span><span class="w"> </span><span class="err">&quot;</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="err">$</span><span class="k">result</span>
<span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">E</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i-=1 &quot;</span>
<span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">F</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i-=1 &quot;</span>
<span class="k">if</span><span class="w"> </span><span class="mi">0</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">E</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i-=1 &quot;</span>
<span class="err">$</span><span class="k">result</span>
<span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">F</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i-=1 &quot;</span>
<span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">F</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i-=1 &quot;</span>
<span class="k">if</span><span class="w"> </span><span class="mi">1</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">E</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i-=1 &quot;</span>
<span class="err">$</span><span class="k">result</span>
<span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">E</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i-=1 &quot;</span>
<span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">K</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i-=1 &quot;</span>
<span class="k">if</span><span class="w"> </span><span class="mi">0</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="n">halt</span><span class="ss">&quot; &quot;</span>
<span class="err">$</span><span class="k">result</span>
<span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">K</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i-=1 &quot;</span>
<span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">K</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i-=1 &quot;</span>
<span class="k">if</span><span class="w"> </span><span class="mi">1</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="n">halt</span><span class="ss">&quot; &quot;</span>
<span class="err">$</span><span class="k">result</span>
<span class="ss">&quot; op=&quot;</span><span class="n">halt</span><span class="ss">&quot; &quot;</span>
<span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">L</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="k">if</span><span class="w"> </span><span class="mi">0</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">N</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="err">$</span><span class="k">result</span>
<span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">L</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">L</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="k">if</span><span class="w"> </span><span class="mi">1</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">N</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="err">$</span><span class="k">result</span>
<span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">N</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">C</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i-=1 &quot;</span>
<span class="k">if</span><span class="w"> </span><span class="mi">1</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">O</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="err">$</span><span class="k">result</span>
<span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">O</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="ss">&quot; &quot;</span><span class="w"> </span><span class="err">&quot;</span>
</code></pre></div>

<p>Next, a series of "instruction" prompts are defined. Each of these strings is intended to express the logic of a corresponding Turing machine state in $U_{15,2}$ specified in Table 1.</p>
<div class="codehilite"><pre><span></span><code><span class="n">A</span> = <span class="s">&quot;&quot;&quot;@[boot]result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[B]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;0&quot;</span> <span class="n">i</span>+=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">if @[@[i]]==1 then result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[A]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;1&quot;</span> <span class="n">i</span>+=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">$result</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">B</span> = <span class="s">&quot;&quot;&quot;@[boot]result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[C]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;1&quot;</span> <span class="n">i</span>+=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">if @[@[i]]==1 then result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[A]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;1&quot;</span> <span class="n">i</span>+=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">$result</span>
<span class="s">&quot;&quot;&quot;</span>

<span class="n">C</span> = <span class="s">&quot;&quot;&quot;@[boot]result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[G]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;0&quot;</span> <span class="n">i-</span>=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">if @[@[i]]==1 then result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[E]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;0&quot;</span> <span class="n">i-</span>=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">$result</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">D</span> = <span class="s">&quot;&quot;&quot;@[boot]result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[F]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;0&quot;</span> <span class="n">i-</span>=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">if @[@[i]]==1 then result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[E]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;1&quot;</span> <span class="n">i-</span>=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">$result</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">E</span> = <span class="s">&quot;&quot;&quot;@[boot]result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[A]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;1&quot;</span> <span class="n">i</span>+=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">if @[@[i]]==1 then result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[D]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;1&quot;</span> <span class="n">i-</span>=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">$result</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">F</span> = <span class="s">&quot;&quot;&quot;@[boot]result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[D]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;1&quot;</span> <span class="n">i-</span>=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">$result</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">G</span> = <span class="s">&quot;&quot;&quot;@[boot]result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[H]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;0&quot;</span> <span class="n">i-</span>=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">if @[@[i]]==1 then result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[G]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;1&quot;</span> <span class="n">i-</span>=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">$result</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">H</span> = <span class="s">&quot;&quot;&quot;@[boot]result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[I]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;1&quot;</span> <span class="n">i-</span>=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">if @[@[i]]==1 then result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[G]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;1&quot;</span> <span class="n">i-</span>=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">$result</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">I</span> = <span class="s">&quot;&quot;&quot;@[boot]result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[A]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;0&quot;</span> <span class="n">i</span>+=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">if @[@[i]]==1 then result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[J]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;1&quot;</span> <span class="n">i-</span>=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">$result</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">J</span> = <span class="s">&quot;&quot;&quot;@[boot]result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[K]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;1&quot;</span> <span class="n">i-</span>=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">if @[@[i]]==1 then result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;halt&quot;</span> <span class="s">&quot;</span>
<span class="s">$result</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">K</span> = <span class="s">&quot;&quot;&quot;@[boot]result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[L]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;0&quot;</span> <span class="n">i</span>+=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">if @[@[i]]==1 then result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[N]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;1&quot;</span> <span class="n">i</span>+=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">$result</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">L</span> = <span class="s">&quot;&quot;&quot;@[boot]result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[M]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;0&quot;</span> <span class="n">i</span>+=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">if @[@[i]]==1 then result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[L]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;1&quot;</span> <span class="n">i</span>+=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">$result</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">M</span> = <span class="s">&quot;&quot;&quot;@[boot]result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[B]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;0&quot;</span> <span class="n">i-</span>=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">if @[@[i]]==1 then result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[L]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;1&quot;</span> <span class="n">i</span>+=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">$result</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">N</span> = <span class="s">&quot;&quot;&quot;@[boot]result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[C]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;0&quot;</span> <span class="n">i-</span>=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">if @[@[i]]==1 then result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[O]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;0&quot;</span> <span class="n">i</span>+=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">$result</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">O</span> = <span class="s">&quot;&quot;&quot;@[boot]result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[N]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;0&quot;</span> <span class="n">i</span>+=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">if @[@[i]]==1 then result = &quot;</span> <span class="n">op</span>=<span class="s">&quot;%[N]&quot;</span> %[<span class="n">i</span>]=<span class="s">&quot;1&quot;</span> <span class="n">i</span>+=<span class="mi">1</span> <span class="s">&quot;</span>
<span class="s">$result</span>
<span class="s">&quot;&quot;&quot;</span>

<span class="n">It</span> <span class="n">helps</span> <span class="nb">to</span> <span class="n">understand</span> <span class="nb">how</span> <span class="n">this</span> <span class="nb">prompt</span> <span class="n">program</span> <span class="k">is</span> <span class="n">intended</span> <span class="nb">to</span> <span class="n">work</span>. <span class="n">First</span>, <span class="nb">note</span> <span class="n">that</span> <span class="n">the</span> <span class="n">memory</span> <span class="n">location</span> <span class="s">&#39; $i$ &#39;</span> <span class="k">is</span> <span class="n">intended</span> <span class="nb">to</span> <span class="nb">keep</span> <span class="n">track</span> <span class="nb">of</span> <span class="n">the</span> <span class="n">current</span> <span class="n">location</span> <span class="nb">of</span> <span class="n">the</span> <span class="n">Turing</span> <span class="n">machine</span> <span class="nb">head</span>, <span class="nb">so</span> <span class="n">that</span> <span class="nb">any</span> <span class="n">update</span> <span class="nv">$i-</span>=<span class="mi">1</span>$ <span class="n">will</span> <span class="n">correspond</span> <span class="nb">to</span> <span class="n">moving</span> <span class="n">the</span> <span class="nb">head</span> <span class="nb">one</span> <span class="n">step</span> <span class="n">left</span>, <span class="o">and</span> <span class="nv">$i</span>+=<span class="mi">1</span>$ <span class="n">will</span> <span class="n">correspond</span> <span class="nb">to</span> <span class="n">moving</span> <span class="n">the</span> <span class="nb">head</span> <span class="nb">one</span> <span class="n">step</span> <span class="nb">right</span>. <span class="n">Next</span>, <span class="n">consider</span> <span class="n">the</span> <span class="n">post</span> <span class="n">processing</span> <span class="nb">of</span> <span class="nb">one</span> <span class="nb">of</span> <span class="n">the</span> <span class="nb">result</span> <span class="n">strings</span>, <span class="k">for</span> <span class="n">example</span> <span class="s">&quot; op=\%[N]&quot;</span> \%[<span class="n">i</span>]=<span class="s">&quot;1&quot;</span> <span class="n">i</span>+=<span class="mi">1</span> <span class="s">&quot;. In this string, the expression \%[i]=&quot;</span><span class="mi">1</span><span class="s">&quot; is intended to write the target symbol &#39;1&#39; to the memory location indexed by MEMORY[&#39;i&#39;]. That is, during post processing, any substring of the form \%[x] will first be replaced by the string in MEMORY[&#39;x&#39;] before performing any assignments, as explained in Section 2. Thus, given \%[i]=&quot;</span><span class="mi">1</span><span class="s">&quot; the substring \%[i] will first be replaced by the value in MEMORY [&#39;i&#39;], say $\ell$, which then serves as the label in memory to be assigned the value &#39;1&#39;. For example, if we assume MEMORY[&#39;i&#39;] = 42 and MEMORY[&#39;42&#39;] = &#39;0&#39;, then after post processing and assignment we will have MEMORY[&#39;42&#39;] = &#39;1&#39;. Control branching, i.e., a state transition, is achieved by assigning a new instruction string from $\{\mathrm{A}, \ldots, 0\}$ to the instruction register MEMORY[&#39;op&#39;], as specified by the assignment string op=&quot;</span>\%[<span class="n">N</span>] <span class="nb">in</span> <span class="n">the</span> <span class="n">example</span>.

<span class="n">In</span> <span class="n">the</span> <span class="n">pre</span> <span class="n">processing</span> <span class="n">phase</span>, <span class="n">the</span> <span class="nb">prompt</span> <span class="n">string</span> <span class="k">is</span> <span class="n">obtained</span> <span class="nb">from</span> <span class="n">MEMORY</span>[<span class="s">&#39;op&#39;</span>], <span class="nb">then</span> <span class="n">substrings</span> <span class="nb">of</span> <span class="n">the</span> <span class="n">form</span> @[<span class="nb">x</span>] <span class="n">are</span> <span class="n">replaced</span> <span class="n">by</span> <span class="n">the</span> <span class="n">string</span> <span class="n">stored</span> <span class="nb">in</span> <span class="n">MEMORY</span>[<span class="s">&#39;x&#39;</span>]. <span class="n">This</span> <span class="n">allows</span> <span class="k">for</span> <span class="n">more</span> <span class="n">compact</span> <span class="n">instruction</span> <span class="n">strings</span> <span class="n">A</span>, ..., <span class="mi">0</span>, <span class="n">since</span> <span class="n">the</span> <span class="n">lengthy</span> <span class="n">boot</span> <span class="n">string</span> <span class="nb">can</span> <span class="n">just</span> <span class="n">be</span> <span class="n">spliced</span> <span class="nb">in</span> <span class="n">during</span> <span class="n">pre</span> <span class="n">processing</span>. <span class="n">More</span> <span class="n">importantly</span>, <span class="n">the</span> <span class="k">symbol</span> <span class="nb">at</span> <span class="n">the</span> <span class="n">current</span> <span class="nb">head</span> <span class="n">position</span> <span class="nb">can</span> <span class="n">be</span> <span class="nb">read</span> <span class="k">with</span> @[@[<span class="n">i</span>]]. <span class="n">To</span> <span class="n">see</span> <span class="n">why</span> <span class="n">this</span> <span class="n">works</span>, <span class="nb">note</span> <span class="n">that</span> <span class="n">the</span> <span class="n">preprocessor</span> <span class="n">will</span> <span class="n">apply</span> <span class="n">nested</span> <span class="n">substitutions</span> <span class="nb">of</span> <span class="n">the</span> @[<span class="nb">x</span>] <span class="n">patterns</span>, <span class="n">as</span> <span class="n">discussed</span> <span class="nb">in</span> <span class="n">Section</span> <span class="mi">2</span>. <span class="n">Therefore</span>, <span class="k">if</span> <span class="n">we</span> <span class="n">continue</span> <span class="nb">to</span> <span class="n">assume</span> <span class="n">that</span> <span class="n">MEMORY</span> [<span class="s">&#39;i&#39;</span>] = <span class="mi">42</span> <span class="o">and</span> <span class="n">MEMORY</span>[<span class="s">&#39;42&#39;</span>] = <span class="s">&#39;1&#39;</span>, <span class="n">the</span> <span class="nb">first</span> <span class="n">substitution</span> <span class="nb">of</span> @[@[<span class="n">i</span>]] <span class="n">will</span> <span class="nb">result</span> <span class="nb">in</span> @[<span class="s">&#39;42&#39;</span>], <span class="o">and</span> <span class="n">the</span> <span class="nb">second</span> <span class="n">substitution</span> <span class="n">will</span> <span class="nb">result</span> <span class="nb">in</span> <span class="s">&#39;1&#39;</span>. <span class="n">That</span> <span class="k">is</span>, <span class="nb">after</span> <span class="n">pre</span> <span class="n">processing</span>, <span class="n">the</span> <span class="n">substring</span> @[@[<span class="n">i</span>]] <span class="k">is</span> <span class="n">replaced</span> <span class="k">with</span> <span class="n">the</span> <span class="nb">value</span> <span class="n">found</span> <span class="nb">in</span> <span class="n">MEMORY</span>[<span class="n">MEMORY</span>[<span class="s">&#39;i&#39;</span>]], <span class="n">i</span>.<span class="nb">e</span>., <span class="n">the</span> <span class="k">symbol</span> <span class="nb">at</span> <span class="n">the</span> <span class="n">current</span> <span class="n">position</span> <span class="nb">of</span> <span class="n">the</span> <span class="n">tape</span> <span class="nb">head</span>, <span class="n">which</span> <span class="nb">in</span> <span class="n">this</span> <span class="n">case</span> <span class="n">will</span> <span class="n">be</span> <span class="s">&#39;1&#39;</span>.

<span class="n">Given</span> <span class="n">this</span> <span class="n">understanding</span>, <span class="n">it</span> <span class="k">is</span> <span class="n">easy</span> <span class="nb">to</span> <span class="n">verify</span> <span class="n">that</span> <span class="n">each</span> <span class="nb">of</span> <span class="n">the</span> <span class="n">instruction</span> <span class="n">strings</span> <span class="n">A</span>, ..., <span class="mi">0</span> <span class="n">correctly</span> <span class="n">mimics</span> <span class="n">the</span> <span class="n">logic</span> <span class="nb">of</span> <span class="n">the</span> <span class="n">corresponding</span> <span class="n">states</span> <span class="nv">$A</span>, \<span class="n">ldots</span>, <span class="n">O</span>$ <span class="nb">in</span> <span class="n">Table</span> <span class="mi">1</span>, <span class="n">including</span> <span class="n">conditioning</span> <span class="n">on</span> <span class="n">the</span> <span class="n">current</span> <span class="k">symbol</span> <span class="nb">in</span> <span class="n">the</span> <span class="nb">head</span> <span class="n">position</span>, <span class="n">writing</span> <span class="n">the</span> <span class="n">correct</span> <span class="k">symbol</span> <span class="nb">to</span> <span class="n">the</span> <span class="n">current</span> <span class="nb">head</span> <span class="n">position</span>, <span class="n">moving</span> <span class="n">the</span> <span class="nb">head</span> <span class="n">position</span> <span class="nb">in</span> <span class="n">the</span> <span class="n">correct</span> <span class="n">direction</span>, <span class="o">and</span> <span class="n">updating</span> <span class="n">the</span> <span class="k">state</span> <span class="n">by</span> <span class="n">assigning</span> <span class="n">the</span> <span class="n">correct</span> <span class="nb">next</span> <span class="n">instruction</span> <span class="nb">to</span> <span class="s">&#39;op&#39;</span>.

<span class="n">Finally</span>, <span class="nb">to</span> <span class="n">simulate</span> <span class="n">the</span> <span class="n">behaviour</span> <span class="nb">of</span> <span class="nv">$U_</span>{<span class="mi">15</span>,<span class="mi">2</span>}$, <span class="n">we</span> <span class="o">also</span> <span class="n">have</span> <span class="nb">to</span> <span class="n">consider</span> <span class="n">the</span> <span class="n">initial</span> <span class="nb">contents</span> <span class="nb">of</span> <span class="n">the</span> <span class="n">tape</span> <span class="n">memory</span>. <span class="n">Let</span> <span class="n">the</span> <span class="nb">variable</span> <span class="n">TAPE</span> <span class="n">be</span> <span class="n">assigned</span> <span class="nb">to</span> <span class="n">a</span> <span class="n">string</span> <span class="n">that</span> <span class="n">covers</span> <span class="n">the</span> <span class="n">non-blank</span> <span class="n">portion</span> <span class="nb">of</span> <span class="n">the</span> <span class="n">initial</span> <span class="n">memory</span> <span class="k">for</span> <span class="nv">$U_</span>{<span class="mi">15</span>,<span class="mi">2</span>}$, <span class="n">which</span> <span class="n">must</span> <span class="n">be</span> <span class="n">finitely</span> <span class="nb">long</span> <span class="n">by</span> <span class="n">definition</span>. <span class="n">Also</span> <span class="k">let</span> $\<span class="n">mathrm</span>{<span class="n">i</span>}=<span class="n">i_</span>{<span class="mi">0</span>}$ <span class="n">contain</span> <span class="n">the</span> <span class="n">initial</span> <span class="n">position</span> <span class="nb">of</span> <span class="n">the</span> <span class="n">tape</span> <span class="nb">head</span>. <span class="n">To</span> <span class="n">simulate</span> <span class="n">the</span> <span class="n">Turing</span> <span class="n">machine</span> <span class="nb">from</span> <span class="n">this</span> <span class="n">configuration</span>, <span class="n">we</span> <span class="nb">first</span> <span class="n">initialize</span> <span class="n">the</span> <span class="n">associative</span> <span class="n">memory</span>, <span class="n">MEMORY</span>, <span class="n">as</span> <span class="n">follows</span>, <span class="nb">then</span> <span class="n">simply</span> <span class="n">call</span> <span class="n">main</span>() <span class="n">as</span> <span class="n">specified</span> <span class="nb">in</span> <span class="n">Section</span> <span class="mi">2</span>.
</code></pre></div>

<p>MEMORY = {'boot':boot}
for s in 'ABCDEFGHIJKLMNO':
    MEMORY[s] = eval(s)
for loc in range(len(TAPE)):
    MEMORY[str(loc)] = TAPE[loc]
BLANK = '0'
MEMORY['i'] = i
MEMORY['op'] = A
main()</p>
<div class="codehilite"><pre><span></span><code><span class="n">We</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="n">claim</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="k">compute</span><span class="w"> </span><span class="k">cycle</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="n">maintains</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">exact</span><span class="w"> </span><span class="n">equivalence</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="k">compute</span><span class="w"> </span><span class="k">cycle</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">Turing</span><span class="w"> </span><span class="n">machine</span><span class="w"> </span><span class="err">$</span><span class="n">U_</span><span class="err">{</span><span class="mi">15</span><span class="p">,</span><span class="mi">2</span><span class="err">}$</span><span class="p">.</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">proof</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">induction</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="k">compute</span><span class="w"> </span><span class="n">cycles</span><span class="p">.</span>

<span class="k">At</span><span class="w"> </span><span class="n">initialization</span><span class="p">,</span><span class="w"> </span><span class="n">there</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">equivalence</span><span class="w"> </span><span class="ow">between</span><span class="err">:</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">Turing</span><span class="w"> </span><span class="n">machine</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="n">tape</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">MEMORY</span><span class="w"> </span><span class="n">labelled</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">location</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="p">(</span><span class="k">with</span><span class="w"> </span><span class="ow">all</span><span class="w"> </span><span class="n">unassigned</span><span class="w"> </span><span class="n">locations</span><span class="w"> </span><span class="n">assumed</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">blank</span><span class="p">);</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">initial</span><span class="w"> </span><span class="n">tape</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="n">location</span><span class="w"> </span><span class="err">$</span><span class="n">i_</span><span class="err">{</span><span class="mi">0</span><span class="err">}$</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="err">$</span><span class="n">i</span><span class="err">$</span><span class="p">;</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">initial</span><span class="w"> </span><span class="k">state</span><span class="w"> </span><span class="err">$</span><span class="n">A</span><span class="err">$</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">initial</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="n">A</span><span class="p">.</span>

<span class="k">Then</span><span class="p">,</span><span class="w"> </span><span class="n">inductively</span><span class="p">,</span><span class="w"> </span><span class="n">assume</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">same</span><span class="w"> </span><span class="n">equivalence</span><span class="w"> </span><span class="n">holds</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">onset</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">compute</span><span class="w"> </span><span class="k">cycle</span><span class="p">.</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">Turing</span><span class="w"> </span><span class="n">machine</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">updated</span><span class="w"> </span><span class="n">according</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="err">$</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="n">sigma</span><span class="p">)</span><span class="w"> </span><span class="err">\</span><span class="n">mapsto</span><span class="err">\</span><span class="nf">left</span><span class="p">(</span><span class="err">\</span><span class="n">sigma</span><span class="o">^</span><span class="err">{\</span><span class="n">prime</span><span class="err">}</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="o">^</span><span class="err">{\</span><span class="n">prime</span><span class="err">}\</span><span class="nf">right</span><span class="p">)</span><span class="err">$</span><span class="w"> </span><span class="n">following</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">specification</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nc">Table</span><span class="w"> </span><span class="mf">1.</span><span class="w"> </span><span class="n">Now</span><span class="w"> </span><span class="n">assume</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">corresponding</span><span class="w"> </span><span class="n">prompt</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="k">after</span><span class="w"> </span><span class="n">pre</span><span class="w"> </span><span class="n">processing</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">same</span><span class="w"> </span><span class="k">current</span><span class="w"> </span><span class="n">symbol</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">MEMORY</span><span class="o">[</span><span class="n">MEMORY[&#39;i&#39;</span><span class="o">]</span><span class="err">]</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">e</span><span class="p">.,</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">current</span><span class="w"> </span><span class="n">location</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">simulated</span><span class="w"> </span><span class="n">tape</span><span class="w"> </span><span class="n">head</span><span class="p">)</span><span class="w"> </span><span class="k">returns</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">correct</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="k">after</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">call_llm_server</span><span class="p">(</span><span class="n">prompt</span><span class="p">).</span><span class="w"> </span><span class="k">Then</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">verify</span><span class="p">,</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="n">basis</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="p">(</span><span class="k">state</span><span class="p">,</span><span class="w"> </span><span class="n">symbol</span><span class="p">)</span><span class="w"> </span><span class="n">pair</span><span class="p">,</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">specifies</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">same</span><span class="w"> </span><span class="n">symbol</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">written</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">current</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="n">location</span><span class="p">,</span><span class="w"> </span><span class="n">specifies</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">same</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">move</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">specifies</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">corresponding</span><span class="w"> </span><span class="k">next</span><span class="w"> </span><span class="n">instruction</span><span class="p">,</span><span class="w"> </span><span class="n">thus</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">equivalence</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">maintained</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">end</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">cycle</span><span class="p">.</span>

<span class="k">To</span><span class="w"> </span><span class="n">illustrate</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="p">(</span><span class="k">state</span><span class="p">,</span><span class="w"> </span><span class="n">symbol</span><span class="p">)</span><span class="w"> </span><span class="n">verifications</span><span class="p">,</span><span class="w"> </span><span class="n">consider</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">first</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nc">Table</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="n">specifies</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">Turing</span><span class="w"> </span><span class="n">machine</span><span class="w"> </span><span class="k">update</span><span class="w"> </span><span class="err">$</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="err">\</span><span class="n">mapsto</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">+</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">)</span><span class="err">$</span><span class="p">.</span><span class="w"> </span><span class="n">Observe</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">pre</span><span class="w"> </span><span class="n">processed</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">same</span><span class="w"> </span><span class="k">input</span><span class="w"> </span><span class="n">symbol</span><span class="w"> </span><span class="s1">&#39; 0 &#39;</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="n">MEMORY</span><span class="o">[</span><span class="n">MEMORY[&#39;i&#39;</span><span class="o">]</span><span class="err">]</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="ss">&quot; op=\%[B]&quot;</span><span class="w"> </span><span class="err">\</span><span class="o">%[</span><span class="n">i</span><span class="o">]=</span><span class="ss">&quot;0&quot;</span><span class="w"> </span><span class="n">i</span><span class="o">+=</span><span class="mi">1</span><span class="w"> </span><span class="ss">&quot; assuming the language model operates correctly (verified below). In this case, the post processing phase will write the corresponding symbol &#39; 0 &#39; to the current memory location, move the head right $+=1$, and assign B to be the next instruction, thus maintaining the equivalence.</span>

<span class="ss">Similarly, if the current input is 1 , the Turing machine update is $(A, 1) \mapsto(1,+, A)$. In this case, observe that if the instruction A pre processed with the same input symbol &#39; 1 &#39; at MEMORY[MEMORY[&#39;i&#39;]], the condition will be true and the result string will be &quot;</span><span class="w"> </span><span class="n">op</span><span class="o">=</span><span class="err">\</span><span class="o">%[</span><span class="n">A</span><span class="o">]</span><span class="ss">&quot; \%[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i+=1 &quot;</span><span class="w"> </span><span class="n">assuming</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">language</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="n">operates</span><span class="w"> </span><span class="n">correctly</span><span class="p">.</span><span class="w"> </span><span class="n">Post</span><span class="w"> </span><span class="n">processing</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">once</span><span class="w"> </span><span class="n">again</span><span class="w"> </span><span class="n">maintain</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">equivalence</span><span class="p">.</span>

<span class="n">A</span><span class="w"> </span><span class="k">similar</span><span class="w"> </span><span class="n">verification</span><span class="w"> </span><span class="n">succeeds</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="ow">all</span><span class="w"> </span><span class="mi">29</span><span class="w"> </span><span class="p">(</span><span class="k">state</span><span class="p">,</span><span class="w"> </span><span class="n">symbol</span><span class="p">)</span><span class="w"> </span><span class="n">cases</span><span class="p">.</span><span class="w"> </span><span class="p">(</span><span class="n">Note</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">update</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="k">state</span><span class="w"> </span><span class="err">$</span><span class="n">F</span><span class="err">$</span><span class="w"> </span><span class="n">does</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">depend</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">input</span><span class="p">,</span><span class="w"> </span><span class="n">so</span><span class="w"> </span><span class="n">there</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">fewer</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="k">than</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="p">(</span><span class="k">state</span><span class="p">,</span><span class="w"> </span><span class="n">symbol</span><span class="p">)</span><span class="w"> </span><span class="n">pairs</span><span class="p">.)</span>

<span class="n">It</span><span class="w"> </span><span class="n">remains</span><span class="w"> </span><span class="k">only</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">verify</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">language</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">produce</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">correct</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">given</span><span class="w"> </span><span class="ow">any</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="n">strings</span><span class="w"> </span><span class="k">after</span><span class="w"> </span><span class="n">pre</span><span class="w"> </span><span class="n">processing</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">current</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="n">symbol</span><span class="p">.</span>

<span class="err">#</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="n">Verifying</span><span class="w"> </span><span class="n">correct</span><span class="w"> </span><span class="n">execution</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">Flan</span><span class="o">-</span><span class="n">U</span><span class="o">-</span><span class="n">PaLM</span><span class="w"> </span><span class="mi">540</span><span class="n">B</span><span class="w"> </span>

<span class="n">We</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="n">consider</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">specific</span><span class="w"> </span><span class="k">language</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="n">Flan</span><span class="o">-</span><span class="n">U</span><span class="o">-</span><span class="n">PaLM</span><span class="w"> </span><span class="mi">540</span><span class="n">B</span><span class="w"> </span><span class="o">[</span><span class="n">Chung et al., 2022</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">large</span><span class="w"> </span><span class="mi">540</span><span class="n">B</span><span class="w"> </span><span class="k">parameter</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">been</span><span class="w"> </span><span class="n">refined</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">additional</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="n">fine</span><span class="o">-</span><span class="n">tuning</span><span class="p">.</span><span class="w"> </span><span class="k">To</span><span class="w"> </span><span class="n">ensure</span><span class="w"> </span><span class="k">deterministic</span><span class="w"> </span><span class="n">computation</span><span class="p">,</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">decoding</span><span class="w"> </span><span class="n">temperature</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">language</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">set</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="p">(</span><span class="n">pure</span><span class="w"> </span><span class="n">greedy</span><span class="w"> </span><span class="n">decoding</span><span class="p">).</span>

<span class="k">To</span><span class="w"> </span><span class="n">complete</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">argument</span><span class="p">,</span><span class="w"> </span><span class="n">we</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="n">simply</span><span class="w"> </span><span class="n">enumerate</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">possible</span><span class="w"> </span><span class="p">(</span><span class="k">state</span><span class="p">,</span><span class="w"> </span><span class="n">symbol</span><span class="p">)</span><span class="w"> </span><span class="n">combinations</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">verify</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">language</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="n">produces</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">correct</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">given</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="k">input</span><span class="w"> </span><span class="n">prompt</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">composed</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">corresponding</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">pre</span><span class="w"> </span><span class="n">processed</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">corresponding</span><span class="w"> </span><span class="k">input</span><span class="w"> </span><span class="n">symbol</span><span class="p">.</span><span class="w"> </span><span class="n">This</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">simply</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">brute</span><span class="w"> </span><span class="n">force</span><span class="w"> </span><span class="n">proof</span><span class="p">,</span><span class="w"> </span><span class="n">calling</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">language</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="n">possible</span><span class="w"> </span><span class="k">input</span><span class="w"> </span><span class="n">prompt</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">verifying</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">correct</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">indeed</span><span class="w"> </span><span class="n">returned</span><span class="p">.</span><span class="w"> </span><span class="n">There</span><span class="w"> </span><span class="k">are</span><span class="w"> </span><span class="mi">29</span><span class="w"> </span><span class="n">cases</span><span class="p">.</span><span class="w"> </span><span class="p">(</span><span class="n">So</span><span class="p">,</span><span class="w"> </span><span class="n">yeah</span><span class="p">,</span><span class="w"> </span><span class="n">human</span><span class="w"> </span><span class="n">readable</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">human</span><span class="w"> </span><span class="n">enjoyable</span><span class="p">,</span><span class="w"> </span><span class="n">apologies</span><span class="p">.)</span>

<span class="n">Verification</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="k">state</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="k">read</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="n">head</span><span class="w"> </span><span class="err">$</span><span class="o">=</span><span class="err">$</span><span class="w"> </span><span class="n">MEMORY</span><span class="o">[</span><span class="n">&#39;i&#39;</span><span class="o">]</span>
<span class="n">MEMORY</span><span class="o">[</span><span class="n">str(head)</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;0&#39;</span>
<span class="n">op</span><span class="w"> </span><span class="err">$</span><span class="o">=</span><span class="err">\</span><span class="n">mathrm</span><span class="err">{</span><span class="n">A</span><span class="err">}$</span>
<span class="n">prompt</span><span class="w"> </span><span class="err">$</span><span class="o">=</span><span class="err">$</span><span class="w"> </span><span class="n">substitute_nested</span><span class="p">(</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;@&#39;</span><span class="p">)</span>
<span class="k">result</span><span class="w"> </span><span class="err">$</span><span class="o">=</span><span class="err">$</span><span class="w"> </span><span class="n">call_llm_server</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="k">result</span><span class="p">)</span>
<span class="k">Output</span><span class="w"> </span><span class="mi">1</span>
<span class="err">@</span><span class="o">[</span><span class="n">boot</span><span class="o">]</span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="err">\</span><span class="o">%[</span><span class="n">B</span><span class="o">]</span><span class="ss">&quot; \%[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="k">if</span><span class="w"> </span><span class="err">@</span><span class="o">[</span><span class="n">@[i</span><span class="o">]</span><span class="err">]</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="err">\</span><span class="o">%[</span><span class="n">A</span><span class="o">]</span><span class="ss">&quot; \%[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="err">\</span><span class="n">#result</span>
<span class="ss">&quot; op=&quot;</span><span class="err">\</span><span class="o">%[</span><span class="n">B</span><span class="o">]</span><span class="ss">&quot; \%[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="n">Verification</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="k">state</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="k">read</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="n">head</span><span class="w"> </span><span class="err">$</span><span class="o">=</span><span class="err">$</span><span class="w"> </span><span class="n">MEMORY</span><span class="o">[</span><span class="n">&#39;i&#39;</span><span class="o">]</span>
<span class="n">MEMORY</span><span class="o">[</span><span class="n">str(head)</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;1&#39;</span>
<span class="n">op</span><span class="w"> </span><span class="err">$</span><span class="o">=</span><span class="err">\</span><span class="n">mathrm</span><span class="err">{</span><span class="n">A</span><span class="err">}$</span>
<span class="n">prompt</span><span class="w"> </span><span class="err">$</span><span class="o">=</span><span class="err">$</span><span class="w"> </span><span class="n">substitute_nested</span><span class="p">(</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;@&#39;</span><span class="p">)</span>
<span class="k">result</span><span class="w"> </span><span class="err">$</span><span class="o">=</span><span class="err">$</span><span class="w"> </span><span class="n">call_llm_server</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="k">result</span><span class="p">)</span>
<span class="k">Output</span><span class="w"> </span><span class="mi">2</span>
<span class="err">@</span><span class="o">[</span><span class="n">boot</span><span class="o">]</span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="err">\</span><span class="o">%[</span><span class="n">B</span><span class="o">]</span><span class="ss">&quot; \%[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="k">if</span><span class="w"> </span><span class="err">@</span><span class="o">[</span><span class="n">@[i</span><span class="o">]</span><span class="err">]</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="err">\</span><span class="o">%[</span><span class="n">A</span><span class="o">]</span><span class="ss">&quot; \%[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="err">\</span><span class="n">#result</span>
<span class="ss">&quot; op=&quot;</span><span class="err">\</span><span class="o">%[</span><span class="n">A</span><span class="o">]</span><span class="ss">&quot; \%[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="n">Verification</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">(</span><span class="k">state</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="k">read</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="n">head</span><span class="w"> </span><span class="err">$</span><span class="o">=</span><span class="err">$</span><span class="w"> </span><span class="n">MEMORY</span><span class="o">[</span><span class="n">&#39;i&#39;</span><span class="o">]</span>
<span class="n">MEMORY</span><span class="o">[</span><span class="n">str(head)</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;0&#39;</span>
<span class="n">op</span><span class="w"> </span><span class="err">$</span><span class="o">=</span><span class="err">\</span><span class="n">mathrm</span><span class="err">{</span><span class="n">B</span><span class="err">}$</span>
<span class="n">prompt</span><span class="w"> </span><span class="err">$</span><span class="o">=</span><span class="err">$</span><span class="w"> </span><span class="n">substitute_nested</span><span class="p">(</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;@&#39;</span><span class="p">)</span>
<span class="k">result</span><span class="w"> </span><span class="err">$</span><span class="o">=</span><span class="err">$</span><span class="w"> </span><span class="n">call_llm_server</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="k">result</span><span class="p">)</span>

<span class="k">Output</span><span class="w"> </span><span class="mi">3</span>
</code></pre></div>

<p>@[boot]result = " op="%[C]" %[i]="1" i+=1 "
if @[@[i]]==1 then result = " op="%[A]" %[i]="1" i+=1 "
$result
" op="%[C]" %[i]="1" i+=1 "</p>
<div class="codehilite"><pre><span></span><code>Verification test 4 (state B read 1)
</code></pre></div>

<p>head = MEMORY['i']
MEMORY[str(head)] = '1'
op = B
prompt = substitute_nested(op, '@')
result = call_llm_server(prompt)
print(op)
print(result)</p>
<div class="codehilite"><pre><span></span><code># Output 4 
</code></pre></div>

<p>@[boot]result = " op="%[C]" %[i]="1" i+=1 "
if @[@[i]]==1 then result = " op="%[A]" %[i]="1" i+=1 "
$result
" op="%[A]" %[i]="1" i+=1 "</p>
<div class="codehilite"><pre><span></span><code>Verification test 5 (state C read 0)
</code></pre></div>

<p>head = MEMORY['i']
MEMORY[str(head)] = '0'
op = C
prompt = substitute_nested(op, '@')
result = call_llm_server(prompt)
print(op)
print(result)</p>
<div class="codehilite"><pre><span></span><code>## Output 5
</code></pre></div>

<p>@[boot]result = " op="%[G]" %[i]="0" i-=1 "
if @[@[i]]==1 then result = " op="%[E]" %[i]="0" i-=1 "
$result
" op="%[G]" %[i]="0" i-=1 "</p>
<div class="codehilite"><pre><span></span><code>Verification test 6 (state C read 1)
</code></pre></div>

<p>head = MEMORY['i']
MEMORY[str(head)] = '1'
op = C
prompt = substitute_nested(op, '@')
result = call_llm_server(prompt)
print(op)
print(result)</p>
<div class="codehilite"><pre><span></span><code>## Output 6
</code></pre></div>

<p>@[boot]result = " op="%[G]" %[i]="0" i-=1 "
if @[@[i]]==1 then result = " op="%[E]" %[i]="0" i-=1 "
$result
" op="%[E]" %[i]="0" i-=1 "</p>
<div class="codehilite"><pre><span></span><code>Verification test 7 (state D read 0)
</code></pre></div>

<p>head = MEMORY['i']
MEMORY[str(head)] = '0'
op = D
prompt = substitute_nested(op, '@')
result = call_llm_server(prompt)
print(op)
print(result)</p>
<div class="codehilite"><pre><span></span><code># Output 7 
</code></pre></div>

<p>@[boot]result = " op="%[F]" %[i]="0" i--=1 "
if @[@[i]]==1 then result = " op="%[E]" %[i]="1" i--=1 "
$result
" op="%[F]" %[i]="0" i--=1 "</p>
<div class="codehilite"><pre><span></span><code>## Verification test 8 (state D read 1)
</code></pre></div>

<p>head = MEMORY['i']
MEMORY[str(head)] = '1'
op = D
prompt = substitute_nested(op, '@')
result = call_llm_server(prompt)
print(op)
print(result)</p>
<div class="codehilite"><pre><span></span><code>## Output 8
</code></pre></div>

<p>@[boot]result = " op="%[F]" %[i]="0" i--=1 "
if @[@[i]]==1 then result = " op="%[E]" %[i]="1" i--=1 "
$result
" op="%[E]" %[i]="1" i--=1 "</p>
<div class="codehilite"><pre><span></span><code>Verification test 9 (state E read 0)
</code></pre></div>

<p>head = MEMORY['i']
MEMORY[str(head)] = '0'
op = E
prompt = substitute_nested(op, '@')
result = call_llm_server(prompt)
print(op)
print(result)</p>
<div class="codehilite"><pre><span></span><code>## Output 9
</code></pre></div>

<p>@[boot]result = " op="%[A]" %[i]="1" i+=1 "
if @[@[i]]==1 then result = " op="%[D]" %[i]="1" i--=1 "
$result
" op="%[A]" %[i]="1" i+=1 "</p>
<div class="codehilite"><pre><span></span><code>Verification test 10 (state E read 1)
</code></pre></div>

<p>head = MEMORY['i']
MEMORY[str(head)] = '1'
op = E
prompt = substitute_nested(op, '@')
result = call_llm_server(prompt)
print(op)
print(result)</p>
<div class="codehilite"><pre><span></span><code>Output 10
</code></pre></div>

<p>@[boot]result = " op="%[A]" %[i]="1" i+=1 "
if @[@[i]]==1 then result = " op="%[D]" %[i]="1" i-=1 "
$result
" op="%[D]" %[i]="1" i-=1 "</p>
<div class="codehilite"><pre><span></span><code><span class="n">Verification</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="mi">11</span><span class="w"> </span><span class="p">(</span><span class="k">state</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="k">read</span><span class="w"> </span><span class="err">$</span><span class="mi">0</span><span class="o">==</span><span class="err">$</span><span class="w"> </span><span class="k">state</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="k">read</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">)</span>
<span class="n">op</span><span class="w"> </span><span class="err">$</span><span class="o">=</span><span class="n">F</span><span class="err">$</span>
<span class="n">prompt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">substitute_nested</span><span class="p">(</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;@&#39;</span><span class="p">)</span>
<span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">call_11m_server</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="k">result</span><span class="p">)</span>
<span class="k">Output</span><span class="w"> </span><span class="mi">11</span>
<span class="err">@</span><span class="o">[</span><span class="n">boot</span><span class="o">]</span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">D</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i-=1 &quot;</span>
<span class="err">$</span><span class="k">result</span>
<span class="n">op</span><span class="o">=</span><span class="ss">&quot;%[D]&quot;</span><span class="w"> </span><span class="err">\</span><span class="o">%[</span><span class="n">i</span><span class="o">]=</span><span class="ss">&quot;1&quot;</span><span class="w"> </span><span class="n">i</span><span class="o">-=</span><span class="mi">1</span>
<span class="n">Verification</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="p">(</span><span class="k">state</span><span class="w"> </span><span class="n">G</span><span class="w"> </span><span class="k">read</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MEMORY</span><span class="o">[</span><span class="n">&#39;i&#39;</span><span class="o">]</span>
<span class="n">MEMORY</span><span class="o">[</span><span class="n">str(head)</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;0&#39;</span>
<span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">G</span>
<span class="n">prompt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">substitute_nested</span><span class="p">(</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;@&#39;</span><span class="p">)</span>
<span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">call_11m_server</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="k">result</span><span class="p">)</span>
<span class="k">Output</span><span class="w"> </span><span class="mi">12</span>
<span class="err">@</span><span class="o">[</span><span class="n">boot</span><span class="o">]</span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">H</span><span class="o">]</span><span class="ss">&quot; \%[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i-=1 &quot;</span>
<span class="k">if</span><span class="w"> </span><span class="err">@</span><span class="o">[</span><span class="n">@[i</span><span class="o">]</span><span class="err">]</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">G</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i-=1 &quot;</span>
<span class="err">$</span><span class="k">result</span>
<span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">H</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i-=1 &quot;</span>
<span class="n">Verification</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="mi">13</span><span class="w"> </span><span class="p">(</span><span class="k">state</span><span class="w"> </span><span class="n">G</span><span class="w"> </span><span class="k">read</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MEMORY</span><span class="o">[</span><span class="n">&#39;i&#39;</span><span class="o">]</span>
<span class="n">MEMORY</span><span class="o">[</span><span class="n">str(head)</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;1&#39;</span>
<span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">G</span>
<span class="n">prompt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">substitute_nested</span><span class="p">(</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;@&#39;</span><span class="p">)</span>
<span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">call_11m_server</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="k">result</span><span class="p">)</span>
<span class="k">Output</span><span class="w"> </span><span class="mi">13</span>
<span class="err">@</span><span class="o">[</span><span class="n">boot</span><span class="o">]</span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">H</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i-=1 &quot;</span>
<span class="k">if</span><span class="w"> </span><span class="err">@</span><span class="o">[</span><span class="n">@[i</span><span class="o">]</span><span class="err">]</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">G</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i-=1 &quot;</span>
<span class="err">$</span><span class="k">result</span>
<span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">G</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i-=1 &quot;</span>
</code></pre></div>

<p>Verification test 14 (state H read 0 )
head = MEMORY['i']
MEMORY[str(head)] = '0'
op $=\mathrm{H}$
prompt = substitute_nested(op, '@')
result = call_11m_server(prompt)
print(op)
print(result)</p>
<p>Output 14</p>
<div class="codehilite"><pre><span></span><code><span class="err">@</span><span class="o">[</span><span class="n">boot</span><span class="o">]</span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">I</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i--=1 &quot;</span>
<span class="k">if</span><span class="w"> </span><span class="err">@</span><span class="o">[</span><span class="n">@[i</span><span class="o">]</span><span class="err">]</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">G</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i--=1 &quot;</span>
<span class="err">$</span><span class="k">result</span>
<span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">I</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i-=1 &quot;</span>
</code></pre></div>

<p>Verification test 15 (state H read 1)</p>
<div class="codehilite"><pre><span></span><code>head = MEMORY[&#39;i&#39;]
MEMORY[str(head)] = &#39;1&#39;
op = H
prompt = substitute_nested(op, &#39;@&#39;)
result = call_llm_server(prompt)
print(op)
print(result)
</code></pre></div>

<h1>Output 15</h1>
<div class="codehilite"><pre><span></span><code><span class="err">@</span><span class="o">[</span><span class="n">boot</span><span class="o">]</span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">I</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i-=1 &quot;</span>
<span class="k">if</span><span class="w"> </span><span class="err">@</span><span class="o">[</span><span class="n">@[i</span><span class="o">]</span><span class="err">]</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">G</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i-=1 &quot;</span>
<span class="err">$</span><span class="k">result</span>
<span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">G</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i-=1 &quot;</span>
</code></pre></div>

<p>Verification test 16 (state I read 0)</p>
<div class="codehilite"><pre><span></span><code>head = MEMORY[&#39;i&#39;]
MEMORY[str(head)] = &#39;0&#39;
op = I
prompt = substitute_nested(op, &#39;@&#39;)
result = call_llm_server(prompt)
print(op)
print(result)
</code></pre></div>

<h2>Output 16</h2>
<div class="codehilite"><pre><span></span><code><span class="err">@</span><span class="o">[</span><span class="n">boot</span><span class="o">]</span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">A</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="k">if</span><span class="w"> </span><span class="err">@</span><span class="o">[</span><span class="n">@[i</span><span class="o">]</span><span class="err">]</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">J</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i-=1 &quot;</span>
<span class="err">$</span><span class="k">result</span>
<span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">A</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i+=1 &quot;</span>
</code></pre></div>

<p>Verification test 17 (state I read 1)</p>
<div class="codehilite"><pre><span></span><code>head = MEMORY[&#39;i&#39;]
MEMORY[str(head)] = &#39;1&#39;
op = I
prompt = substitute_nested(op, &#39;@&#39;)
result = call_llm_server(prompt)
print(op)
print(result)
</code></pre></div>

<h2>Output 17</h2>
<div class="codehilite"><pre><span></span><code><span class="err">@</span><span class="o">[</span><span class="n">boot</span><span class="o">]</span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">A</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="k">if</span><span class="w"> </span><span class="err">@</span><span class="o">[</span><span class="n">@[i</span><span class="o">]</span><span class="err">]</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">J</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i-=1 &quot;</span>
<span class="err">$</span><span class="k">result</span>
<span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">J</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i-=1 &quot;</span>
</code></pre></div>

<p>Verification test 18 (state J read 0)</p>
<div class="codehilite"><pre><span></span><code>head = MEMORY[&#39;i&#39;]
MEMORY[str(head)] = &#39;0&#39;
op = J
prompt = substitute_nested(op, &#39;@&#39;)
result = call_11m_server(prompt)
print(op)
print(result)
</code></pre></div>

<h1>Output 18</h1>
<div class="codehilite"><pre><span></span><code><span class="err">@</span><span class="o">[</span><span class="n">boot</span><span class="o">]</span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">K</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i-=1 &quot;</span>
<span class="k">if</span><span class="w"> </span><span class="err">@</span><span class="o">[</span><span class="n">@[i</span><span class="o">]</span><span class="err">]</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="n">halt</span><span class="ss">&quot; &quot;</span>
<span class="err">$</span><span class="k">result</span>
<span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">K</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i-=1 &quot;</span>
</code></pre></div>

<p>Verification test 19 (state J read 1)
head = MEMORY['i']
MEMORY[str(head)] = '1'
op = J
prompt = substitute_nested(op, '@')
result = call_11m_server(prompt)
print(op)
print(result)
Output 19
@[boot]result = " op="%[K]" %[i]="1" i-=1 "
if @[@[i]]==1 then result = " op="halt" "
\$result
" op="halt" "
Verification test 20 (state K read 0)
head = MEMORY['i']
MEMORY[str(head)] = '0'
op = K
prompt = substitute_nested(op, '@')
result = call_11m_server(prompt)
print(op)
print(result)
Output 20
@[boot]result = " op="%[L]" %[i]="0" i+=1 "
if @[@[i]]==1 then result = " op="%[K]" %[i]="1" i+=1 "
\$result
" op="%[L]" %[i]="0" i+=1 "
Verification test 21 (state K read 1)
head = MEMORY['i']
MEMORY[str(head)] = '1'
op = K
prompt = substitute_nested(op, '@')
result = call_11m_server(prompt)
print(op)
print(result)
Output 21</p>
<div class="codehilite"><pre><span></span><code><span class="err">@</span><span class="o">[</span><span class="n">boot</span><span class="o">]</span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">L</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="k">if</span><span class="w"> </span><span class="err">@</span><span class="o">[</span><span class="n">@[i</span><span class="o">]</span><span class="err">]</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">N</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="err">$</span><span class="k">result</span>
<span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">N</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i+=1 &quot;</span>
</code></pre></div>

<p>Verification test 22 (state L read 0)</p>
<div class="codehilite"><pre><span></span><code>head = MEMORY[&#39;i&#39;]
MEMORY[str(head)] = &#39;0&#39;
op = L
prompt = substitute_nested(op, &#39;@&#39;)
result = call_llm_server(prompt)
print(op)
print(result)
</code></pre></div>

<h1>Output 22</h1>
<div class="codehilite"><pre><span></span><code><span class="err">@</span><span class="o">[</span><span class="n">boot</span><span class="o">]</span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">M</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="k">if</span><span class="w"> </span><span class="err">@</span><span class="o">[</span><span class="n">@[i</span><span class="o">]</span><span class="err">]</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">L</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="err">$</span><span class="k">result</span>
<span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">M</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i+=1 &quot;</span>
</code></pre></div>

<p>Verification test 23 (state L read 1)</p>
<div class="codehilite"><pre><span></span><code>head = MEMORY[&#39;i&#39;]
MEMORY[str(head)] = &#39;1&#39;
op = L
prompt = substitute_nested(op, &#39;@&#39;)
result = call_llm_server(prompt)
print(op)
print(result)
</code></pre></div>

<h2>Output 23</h2>
<div class="codehilite"><pre><span></span><code><span class="err">@</span><span class="o">[</span><span class="n">boot</span><span class="o">]</span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">M</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="k">if</span><span class="w"> </span><span class="err">@</span><span class="o">[</span><span class="n">@[i</span><span class="o">]</span><span class="err">]</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">L</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="err">$</span><span class="k">result</span>
<span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">L</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i+=1 &quot;</span>
</code></pre></div>

<p>Verification test 24 (state M read 0)</p>
<div class="codehilite"><pre><span></span><code>head = MEMORY[&#39;i&#39;]
MEMORY[str(head)] = &#39;0&#39;
op = M
prompt = substitute_nested(op, &#39;@&#39;)
result = call_llm_server(prompt)
print(op)
print(result)
</code></pre></div>

<h2>Output 24</h2>
<div class="codehilite"><pre><span></span><code><span class="err">@</span><span class="o">[</span><span class="n">boot</span><span class="o">]</span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">B</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i-=1 &quot;</span>
<span class="k">if</span><span class="w"> </span><span class="err">@</span><span class="o">[</span><span class="n">@[i</span><span class="o">]</span><span class="err">]</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">L</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="err">$</span><span class="k">result</span>
<span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">B</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i-=1 &quot;</span>
</code></pre></div>

<p>Verification test 25 (state M read 1)</p>
<div class="codehilite"><pre><span></span><code>head = MEMORY[&#39;i&#39;]
MEMORY[str(head)] = &#39;1&#39;
op = M
prompt = substitute_nested(op, &#39;@&#39;)
result = call_llm_server(prompt)
print(op)
print(result)
</code></pre></div>

<h1>Output 25</h1>
<div class="codehilite"><pre><span></span><code><span class="err">@</span><span class="o">[</span><span class="n">boot</span><span class="o">]</span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">B</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i--=1 &quot;</span>
<span class="k">if</span><span class="w"> </span><span class="err">@</span><span class="o">[</span><span class="n">@[i</span><span class="o">]</span><span class="err">]</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">L</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="err">$</span><span class="k">result</span>
<span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">L</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i+=1 &quot;</span>
</code></pre></div>

<p>Verification test 26 (state N read 0)</p>
<div class="codehilite"><pre><span></span><code>head = MEMORY[&#39;i&#39;]
MEMORY[str(head)] = &#39;0&#39;
op = N
prompt = substitute_nested(op, &#39;@&#39;)
result = call_llm_server(prompt)
print(op)
print(result)
</code></pre></div>

<h2>Output 26</h2>
<div class="codehilite"><pre><span></span><code><span class="err">@</span><span class="o">[</span><span class="n">boot</span><span class="o">]</span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">C</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i--=1 &quot;</span>
<span class="k">if</span><span class="w"> </span><span class="err">@</span><span class="o">[</span><span class="n">@[i</span><span class="o">]</span><span class="err">]</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">D</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="err">$</span><span class="k">result</span>
<span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">C</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i-=1 &quot;</span>
</code></pre></div>

<p>Verification test 27 (state N read 1)</p>
<div class="codehilite"><pre><span></span><code>head = MEMORY[&#39;i&#39;]
MEMORY[str(head)] = &#39;1&#39;
op = N
prompt = substitute_nested(op, &#39;@&#39;)
result = call_llm_server(prompt)
print(op)
print(result)
</code></pre></div>

<h2>Output 27</h2>
<div class="codehilite"><pre><span></span><code><span class="err">@</span><span class="o">[</span><span class="n">boot</span><span class="o">]</span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">C</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i-=1 &quot;</span>
<span class="k">if</span><span class="w"> </span><span class="err">@</span><span class="o">[</span><span class="n">@[i</span><span class="o">]</span><span class="err">]</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">D</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="err">$</span><span class="k">result</span>
<span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">D</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i+=1 &quot;</span>
</code></pre></div>

<p>Verification test 28 (state O read 0)</p>
<div class="codehilite"><pre><span></span><code>head = MEMORY[&#39;i&#39;]
MEMORY[str(head)] = &#39;0&#39;
op = 0
prompt = substitute_nested(op, &#39;@&#39;)
result = call_llm_server(prompt)
print(op)
print(result)
</code></pre></div>

<h2>Output 28</h2>
<div class="codehilite"><pre><span></span><code><span class="err">@</span><span class="o">[</span><span class="n">boot</span><span class="o">]</span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">N</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="k">if</span><span class="w"> </span><span class="err">@</span><span class="o">[</span><span class="n">@[i</span><span class="o">]</span><span class="err">]</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">N</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="err">$</span><span class="k">result</span>
<span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">N</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i+=1 &quot;</span>
</code></pre></div>

<p>Verification test 29 (state O read 1)</p>
<div class="codehilite"><pre><span></span><code>head = MEMORY[&#39;i&#39;]
MEMORY[str(head)] = &#39;1&#39;
op = 0
prompt = substitute_nested(op, &#39;@&#39;)
result = call_l1m_server(prompt)
print(op)
print(result)
</code></pre></div>

<h1>Output 29</h1>
<div class="codehilite"><pre><span></span><code><span class="err">@</span><span class="o">[</span><span class="n">boot</span><span class="o">]</span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">N</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">0</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="k">if</span><span class="w"> </span><span class="err">@</span><span class="o">[</span><span class="n">@[i</span><span class="o">]</span><span class="err">]</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">N</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i+=1 &quot;</span>
<span class="err">$</span><span class="k">result</span>
<span class="ss">&quot; op=&quot;</span><span class="o">%[</span><span class="n">N</span><span class="o">]</span><span class="ss">&quot; %[i]=&quot;</span><span class="mi">1</span><span class="ss">&quot; i+=1 &quot;</span>
</code></pre></div>

<p>This completes the proof.</p>
<h2>6 Discussion</h2>
<p>Hopefully the reader has been convinced by this point. There are some reflections on this study that are useful to share.</p>
<p>Although the verification of computational universality is straightforward, the language model's behaviour was brittle. Success was not achieved with every large language model considered, and effort was required to engineer the prompts. For example, the instruction strings A, ..., 0 with the substitution symbols @ and \% are terse and not particularly elegant for humans to read, yet compactness seemed essential to get the language model to produce correct results. Eliciting correct evaluations of variable assignments was sometimes a challenge, but by far the biggest challenge was getting the language model to interpret conditionals properly. The reader might notice that the conditionals have been reduced to if-then rather than if-then-else forms. This was not an accident: I was not able to get the language model to reliably produce correct outputs for if-then-else conditionals. The difficulty with conditionals also makes it challenging to simulate other, smaller universal Turing machines, such as $U_{6,4}$ [Neary and Woods, 2009], since this requires a series of 3 conditionals for each state, which I could not get to work without introducing phantom states and reducing instructions to only a single conditional, ultimately ending up with a far less digestible construction. Presumably improvements in the underlying language models will mitigate such challenges.</p>
<p>Earlier versions of this work considered simulating Rule 110 for a one dimensional cellular automaton [Wolfram, 2002], leveraging the fact that this is known to be a (weakly) Turing complete [Cook, 2004]. Although far more visually appealing, Rule 110 requires an unbounded periodic initialization to an simulate arbitrary Turing machine, and ultimately</p>
<p>the more direct simulation of $U_{15,2}$ presented in this paper, which requires only a bounded initialization, appears to be more convincing.</p>
<p>There is an interesting analogy to the "programming language" developed in Sections 2 and 4 and some of the earliest programming languages [Böhm, 1954], including the first assembly languages [Booth and Britten, 1947]. The latter is particularly reminiscent given the reliance on human readable labels for branch control. It is interesting to speculate about what other concepts in the history of software engineering (e.g., high level languages, modularity, libraries, etc.) might be useful for eliciting desired computational behaviour from a large language model.</p>
<p>The result in this paper is distinct from previous studies that investigate the computational universality of neural sequence models, such as recurrent neural networks [Siegelmann and Sontag, 2019, Weiss et al., 2018] and Transformers [Pérez et al., 2019], [Bhattamishra et al., 2020, Wei et al., 2022a]. The key distinction is that we consider a fixed language model with frozen weights, and show how external memory augmentation can elicit universal computational behaviour. By contrast these past studies have shown how computationally universal behaviour can be recovered by manipulating the weights of the neural network, typically using unbounded (or sufficiently high) precision weights to encode data structures, like multiple stacks. An advantage of these past works is that they do not require any external memory to demonstrate universal computational behaviour. On the other hand, these results do not apply to existing large language models without altering their weights (as far as currently known). The results in this paper show that large language models are already computationally universal-as they exist currently-provided only that they have access to an unbounded external memory.</p>
<h1>Acknowledgments</h1>
<p>Sincere thanks to Noah Fiedel, Ramki Gummadi, András György, Chris Harris, Tengyu Ma, Jason Wei, Sherry Yang, Denny Zhou and Martin Zinkevich for essential discussions leading to this work. Thanks also to Google Brain and my team members for providing an ideal environment for conducting exploratory research. Support from the CIFAR Canada AI Research Chairs program, NSERC, and Amii is also gratefully acknowledged.</p>
<h2>References</h2>
<p>[Bhattamishra et al., 2020] Bhattamishra, S., Patel, A., and Goyal, N. (2020). On the computational power of Transformers and its implications in sequence modeling. In Conference on Computational Natural Language Learning (CONLL).
[Böhm, 1954] Böhm, C. (1954). Calculatrices digitales du déchiffrage de formules logicomathématiques par la machine même dans la conception du programme. PhD thesis, ETH Zürich.</p>            </div>
        </div>

    </div>
</body>
</html>