<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-1543 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-1543</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-1543</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-30.html">extraction-schema-30</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of curriculum learning approaches for teaching agents commonsense or science procedures in interactive text environments, including details about the curriculum strategy, task composition, and performance results.</div>
                <p><strong>Paper ID:</strong> paper-e17ba2b5d0769e7f2602d859ea77a153846cf27d</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/e17ba2b5d0769e7f2602d859ea77a153846cf27d" target="_blank">Unsupervised Learning from Narrated Instruction Videos</a></p>
                <p><strong>Paper Venue:</strong> Computer Vision and Pattern Recognition</p>
                <p><strong>Paper TL;DR:</strong> A new unsupervised learning approach that takes advantage of the complementary nature of the input video and the associated narration to solve two clustering problems, one in text and one in video, and can automatically discover the main steps to achieve the task and locate the steps in the input videos.</p>
                <p><strong>Paper Abstract:</strong> We address the problem of automatically learning the main steps to complete a certain task, such as changing a car tire, from a set of narrated instruction videos. The contributions of this paper are three-fold. First, we develop a new unsupervised learning approach that takes advantage of the complementary nature of the input video and the associated narration. The method solves two clustering problems, one in text and one in video, applied one after each other and linked by joint constraints to obtain a single coherent sequence of steps in both modalities. Second, we collect and annotate a new challenging dataset of real-world instruction videos from the Internet. The dataset contains about 800,000 frames for five different tasks1 that include complex interactions between people and objects, and are captured in a variety of indoor and outdoor settings. Third, we experimentally demonstrate that the proposed method can automatically discover, in an unsupervised manner, the main steps to achieve the task and locate the steps in the input videos.</p>
                <p><strong>Cost:</strong> 0.006</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <p class="empty-note">No extracted data.</p>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <p class="empty-note">No potentially relevant new papers extracted.</p>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-1543",
    "paper_id": "paper-e17ba2b5d0769e7f2602d859ea77a153846cf27d",
    "extraction_schema_id": "extraction-schema-30",
    "extracted_data": [],
    "potentially_relevant_new_papers": [],
    "cost": 0.0057995,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Unsupervised Learning from Narrated Instruction Videos</h1>
<p>Jean-Baptiste Alayrac<em> ${ }^{\dagger}$ Piotr Bojanowski</em> Nishant Agrawal * $\ddagger$ Josef Sivic<em><br>Ivan Laptev</em> Simon Lacoste-Julien ${ }^{\dagger}$</p>
<h4>Abstract</h4>
<p>We address the problem of automatically learning the main steps to complete a certain task, such as changing a car tire, from a set of narrated instruction videos. The contributions of this paper are three-fold. First, we develop a new unsupervised learning approach that takes advantage of the complementary nature of the input video and the associated narration. The method solves two clustering problems, one in text and one in video, applied one after each other and linked by joint constraints to obtain a single coherent sequence of steps in both modalities. Second, we collect and annotate a new challenging dataset of real-world instruction videos from the Internet. The dataset contains about 800,000 frames for five different tasks ${ }^{\dagger}$ that include complex interactions between people and objects, and are captured in a variety of indoor and outdoor settings. Third, we experimentally demonstrate that the proposed method can automatically discover, in an unsupervised manner, the main steps to achieve the task and locate the steps in the input videos.</p>
<h2>1. Introduction</h2>
<p>Millions of people watch narrated instruction videos ${ }^{2}$ to learn new tasks such as assembling IKEA furniture or changing a flat car tire. Many of such tasks have large amounts of videos available on-line. For example, querying for "how to change a tire" results in more than 300,000 hits on YouTube. Most of these videos, however, are made with the intention to teach other people to perform the task and do not provide direct supervisory signal for automatic learning algorithms. Developing unsupervised methods that could learn tasks from myriads of instruction videos on the Internet is therefore a key challenge. Such automatic cogni-</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup>tive ability would enable constructing virtual assistants and smart robots that learn new skills from the Internet to, for example, help people achieve new tasks in unfamiliar situations.</p>
<p>In this work, we consider instruction videos and develop a method that learns a sequence of steps, as well as their textual and visual representations, required to achieve a certain task. For example, given a set of narrated instruction videos demonstrating how to change a car tire, our method automatically discovers consecutive steps for this task such as loosen the nuts of the wheel, jack up the car, remove the spare tire and so on as illustrated in Figure 1. In addition, the method learns the visual and linguistic variability of these steps from natural videos.</p>
<p>Discovering key steps from instruction videos is a highly challenging task. First, linguistic expressions for the same step can have high variability across videos, for example: "...Loosen up the wheel nut just a little before you start jacking the car..." and "...Start to loosen the lug nuts just enough to make them easy to turn by hand...". Second, the visual appearance of each step varies greatly between videos as the people and objects are different, the action is captured from a different viewpoint, and the way people perform actions also vary. Finally, there is also a variability of the overall structure of the sequence of steps achieving the task. For example, some videos may omit some steps or change slightly their order.</p>
<p>To address these challenges, in this paper we develop an unsupervised learning approach that takes advantage of the complementarity of the visual signal in the video and the corresponding natural language narration to resolve their ambiguities. We assume that the same ordered sequence of steps (also called script in the NLP literature [26]) is common to all input videos of the same task, but the actual sequence and the individual steps are unknown and are learnt directly from data. This is in contrast to other existing methods for modeling instruction videos [19] that assume a script (recipe) is known and fixed in advance. We address the problem by first performing temporal clustering of text followed by clustering in video, where the two clustering tasks are linked by joint constraints. The complementary nature of the two clustering problems helps to resolve ambiguities in the two individual modalities. For example, two video segments with very different appearance but depict-</p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Given a set of narrated instruction videos demonstrating a particular task, we wish to automatically discover the main steps to achieve the task and associate each step with its corresponding narration and appearance in each video. Here frames from two videos demonstrating changing the car tire are shown, together with excerpts of the corresponding narrations. Note the large variations in both the narration and appearance of the different steps highlighted by the same colors in both videos (here only three steps are shown).
ing the same step can be grouped together because they are narrated in a similar language. Conversely, two video segments described with very different expressions, for example, "jack up the car" and "raise the vehicle" can be identified as belonging to the same instruction step because they have similar visual appearance. The output of our method is the script listing the discovered steps of the task as well as the temporal location of each step in the input videos. We validate our method on a new dataset of instruction videos composed of five different tasks with a total of 150 videos and about 800,000 frames.</p>
<h2>2. Related work</h2>
<p>This work relates to unsupervised and weaklysupervised learning methods in computer vision and natural language processing. Particularly related to ours is the work on learning script-like knowledge from natural language descriptions [6, 11, 26]. These methods aim to discover typical events (steps) and their order for particular scenarios (tasks) ${ }^{3}$ such as "cooking scrambled egg", "taking a bus" or "making coffee". While [6] uses large-scale news copora, [26] argues that many events are implicit and are not described in such general-purpose text data. Instead, [11, 26] use event sequence descriptions collected for particular scenarios. Differently to this work, we learn sequences of events from narrated instruction videos on the Internet. Such data contains detailed event descriptions but is not structured and contains more noise compared to the input of $[11,26]$.</p>
<p>Interpretation of narrated instruction videos has been re-</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup>cently addressed in [19]. While this work analyses cooking videos at a great scale, it relies on readily-available recipes which may not be available for more general scenarios. Differently from [19], we here aim to learn the steps of instruction videos using a discriminative clustering approach. A similar task to ours is addressed in [21] using latent variable structured perceptron algorithm to align nouns in instruction sentences with objects touched by hands in instruction videos. However, similarly to [19], [21] uses laboratory experimental protocols as textual input, whereas here we consider a weaker signal in the form of the real transcribed narration of the video.</p>
<p>In computer vision, unsupervised action recognition has been explored in simple videos [23]. More recently, weakly supervised learning of actions in video using video scripts or event order has been addressed in [3, 4, 5, 9, 16]. Particularly related to ours is the work [4] which explores the known order of events to localize and learn actions in training data. While [4] uses manually annotated sequences of events, we here discover the sequences of main events by clustering transcribed narrations of the videos. Related is also the work of [5] that aligns natural text descriptions to video but in contrast to our approach does not discover automatically the common sequence of main steps. Methods in [22, 25] learn in an unsupervised manner the temporal structure of actions from video but do not discover textual expressions for actions as we do in this work. The recent concurrent work [27] is addressing, independently of our work, a similar problem but with a different approach based on a probabilistic generative model and considering a different set of tasks mainly focussed on cooking activities.</p>
<p>Our work is also related to video summarization and in particular to the recent work on category-specific video</p>
<p>summarization [24, 29]. While summarization is a subjective task, we here aim to extract the key steps required to achieve a concrete task that consistently appear in the same sequence in the input set of videos. In addition, unlike video summarization [24, 29] we jointly exploit visual and linguistic modalities in our approach.</p>
<h2>3. New dataset of instruction videos</h2>
<p>We have collected a dataset of narrated instruction videos for five tasks: Making a coffee, Changing car tire, Performing cardiopulmonary resuscitation (CPR), Jumping a car and Repotting a plant. The videos were obtained by searching YouTube with relevant keywords. The five tasks were chosen so that they have a large number of available videos with English transcripts while trying to cover a wide range of activities that include complex interactions of people with objects and other people. For each task, we took the top 30 videos with English ASR returned by YouTube. We also quickly verified that each video contains a person actually performing the task (as opposed to just talking about it). The result is a total of 150 videos, 30 videos for each task. The average length of our videos is about 4,000 frames (or 2 minutes) and the entire dataset contains about 800,000 frames.</p>
<p>The selected videos have English transcripts obtained from YouTube's automatic speech recognition (ASR) system. To remove the dependence of results on errors of the particular ASR method, we have manually corrected misspellings and punctuations in the output transcriptions. We believe this step will soon become obsolete given rapid improvements of ASR methods. As we do not modify the content of the spoken language in videos, the transcribed verbal instructions still represent an extremely challenging example of natural language with large variability in the used expressions and terminology. Each word of the transcript is associated with a time interval in the video (usually less than 5 seconds) obtained from the closed caption timings.</p>
<p>For the purpose of evaluation, we have manually annotated the temporal location in each video of the main steps necessary to achieve the given task. For all tasks, we have defined the ordered sequence of ground truth steps before running our algorithm. The choice of steps was made by an agreement of 2-3 annotators who have watched the input videos and verified the steps on instruction video websites such as http://www.howdini.com. While some steps can be occasionally left out in some videos or the ordering slightly modified, overall we have observed a good consistency in the given sequence of instructions among the input videos. We measured that only 6% of the step annotations did not fit the global order, while a step was missing from the video 27% of the time. We hypothesize that this could be attributed to the fact that all videos are made</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup>with the same goal of giving other humans clear, concise and comprehensible verbal and visual instructions on how to achieve the given task. Given the list of steps for each task, we have manually annotated each time interval in each input video to one of the ground truth steps (or no step). The actions of the individual steps are typically separated by hundreds of frames where the narrator transitions between the steps or explains verbally what is going to happen. Furthermore, some steps could be missing in some videos, or could be present but not described in the narration. Finally, the temporal alignment between the narration and the actual actions in video is only coarse as the action is often described before it is performed.</p>
<h2>4. Modelling narrated instruction videos</h2>
<p>We are given a set of $N$ instruction videos all depicting the same task (such as "changing a tire"). The $n$-th input video is composed of a video stream of $T_{n}$ segments of frames $\left(x_{t}^{n}\right)<em n="n">{t=1}^{N}$ and an audio stream containing a detailed verbal description of the depicted task. We suppose that the audio description was transcribed to raw text and then processed to a sequence of $S</em>\right)}$ text tokens $\left(d_{s}^{n<em n="n">{s=1}^{S</em>$. Given this data, we want to automatically recover the sequence of $K$ main steps that compose the given task and locate each step within each input video and text transcription.}</p>
<p>We formulate the problem as two clustering tasks, one in text and one in video, applied one after each other and linked by joint constraints linking the two modalities. This two-stage approach is based on the intuition that the variation in natural language describing each task is easier to capture than the visual variability of the input videos. In the first stage, we cluster the text transcripts into a sequence of $K$ main steps to complete the given task. Empirically, we have found (see results in Sec. 5.1) that it is possible to discover the sequence of the $K$ main steps for each task with high precision. However, the text itself gives only a poor localization of each step in each video. Therefore, in the second stage we accurately localize each step in each video by clustering the input videos using the sequence of $K$ steps extracted from text as constraints on the video clustering. To achieve this, we use two types of constraints between video and text. First, we assume that both the video and the text narration follow the same sequence of steps. This results in a global ordering constraint on the recovered clustering. Second, we assume that people perform the action approximately at the same time that they talk about it. This constraint temporally links the recovered clusters in text and video. The important outcome of the video clustering stage is that the $K$ extracted steps get propagated by visual similarity to videos where the text descriptions are missing or ambiguous.</p>
<p>We first describe the text clustering in Sec. 4.1 and then introduce the video clustering with constraints in Sec. 4.2.</p>
<p>Input sequences of direct object relations</p>
<p>$d^{1}$
$d^{2}$
$d^{3}$
$d^{4}$
Jack car
lower jack
loosen nut
raise car
remove tire
remove jack
loosen nut
juck car
lift car
lower car
<img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: Clustering transcribed verbal instructions. Left: The input raw text for each video is converted into a sequence of direct object relations. Here, an illustration of four sequences from four different videos is shown. Middle: Multiple sequence alignment is used to align all sequences together. Note that different direct object relations are aligned together as long as they have the same sense, e.g. "loosen nut" and "undo bolt". Right: The main instruction steps are extracted as the $K=3$ most common steps in all the sequences.</p>
<h3>4.1. Clustering transcribed verbal instructions</h3>
<p>The goal here is to cluster the transcribed verbal descriptions of each video into a sequence of <em>main steps</em> necessary to achieve the task. This stage is important as the resulting clusters will be used as constraints for jointly learning and localizing the main steps in video. We assume that the important steps are common to many of the transcripts and that the sequence of steps is (roughly) preserved in all transcripts. Hence, following <em>[26]</em>, we formulate the problem of clustering the input transcripts as a multiple sequence alignment problem. However, in contrast to <em>[26]</em> who cluster manually provided descriptions of each step, we wish to cluster transcribed verbal instructions. Hence our main challenge is to deal with the variability in spoken natural language. To overcome this challenge, we take advantage of the fact that completing a certain task usually involves interactions with objects or people and hence we can extract a more structured representation from the input text stream.</p>
<p>More specifically, we represent the textual data as a sequence of <em>direct object relations</em>. A direct object relation $d$ is a pair composed of a verb and its direct object complement, such as "remove tire". Such a direct object relation can be extracted from the dependency parser of the input transcribed narration <em>[8]</em>. We denote the set of all different direct object relations extracted from all narrations as $\mathcal{D}$, with cardinality $D$. For the $n$-th video, we thus represent the text signal as a sequence of direct object relation tokens: $d^{n}=\left(d_{1}^{n}, \ldots, d_{S_{n}}^{n}\right)$, where the length $S_{n}$ of the sequence varies from one video clip to another. This step is key to the success of our method as it allows us to convert the problem of clustering raw transcribed text into an easier problem of clustering sequences of direct object relations. The goal is now to extract from the narrations the most common sequence of $K$ main steps to achieve the given task. To achieve this, we first find a globally consistent alignment of the direct object relations that compose all text sequences by solving a multiple sequence alignment problem. Second, we pick from this alignment the $K$ most globally consistent clusters across videos.</p>
<p>Multiple sequence alignment model. We formulate the first stage of finding the common alignment between the input sequences of direct object relations as a multiple sequence alignment problem with the <em>sum-of-pairs score</em> <em>[31]</em>. In details, a global alignment can be defined by re-mapping each input sequence $d^{n}$ of tokens to a global common template of $L$ slots, for $L$ large enough. We let $\left(\phi\left(d^{n}\right)\right)<em l="l">{1\leq l \leq L}$ represent the (increasing) re-mapping for sequence $d^{n}$ at the new locations indexed by $l$ : $\phi\left(d^{n}\right)</em>=\varnothing$ if a slot is left empty (denoting the insertion of a gap in the original sequence of tokens). See the middle of Figure 2 for an example of re-mapping. The goal is then to find a global alignment that minimizes the following sum-of-pairs cost function:}$ represents the direct object relation put at location $l$, with $\phi\left(d^{n}\right)_{l</p>
<p>$$
\sum_{(n, m)}^{L} \sum_{l=1}^{L} c\left(\phi\left(d^{n}\right)<em l="l">{l}, \phi\left(d^{m}\right)</em>\right)
$$</p>
<p>where $c\left(d_{1}, d_{2}\right)$ denotes the cost of aligning the direct object relations $d_{1}$ and $d_{2}$ at the same common slot $l$ in the global template. The above cost thus denotes the sum of all pairwise alignments of the individual sequences (the outer sum), where the quality of each alignment is measured by summing the cost $c$ of matches of individual direct object relations mapped into the common template sequence. We use a negative cost when $d_{1}$ and $d_{2}$ are similar according to the distance in the WordNet tree <em>[10, 20]</em> of their verb and direct object constituents, and positive if they are dissimilar (details are given in Sec. 5). As the verbal narrations can talk about many other things than the main steps of a task, we set $c\left(d, d^{\prime}\right)=0$ if either $d$ or $d^{\prime}$ is $\varnothing$. An illustration of clustering the transcribed verbal instructions into a sequence of $K$ steps is shown in Figure 2.</p>
<p>Optimization using Frank-Wolfe. Optimizing the cost (1) is NP-hard <em>[31]</em> because of the combinatorial nature of the problem. The standard solution from computational biology is to apply a heuristic algorithm that proceeds by incremental pairwise alignment using dynamic programming <em>[17]</em>. In contrast, we show in Appendix B.1 that the multiple sequence alignment problem given by (1) can be reformulated as an integer quadratic program with combinatorial constraints, for which the Frank-Wolfe optimization algorithm has been used recently with increasing success <em>[4, 13, 14, 15]</em>. Interestingly, we have observed empirically (see Appendix B.2) that the Frank-Wolfe</p>
<p>algorithm was giving better solutions (in terms of objective (1)) than the state-of-the-art heuristic procedures for this task [12, 17]. Our Frank-Wolfe based solvers also offer us greater flexibility in defining the alignment cost and scale better with the length of input sequences and the vocabulary of direct object relations.</p>
<p>Extracting the main steps. After a global alignment is obtained, we sort the global template $l$ by the number of direct object relations aligned to each slot. Given $K$ as input, the top $K$ slots give the main instruction steps for the task, unless there are multiple steps with the same support, which go beyond $K$. In this case, we pick the next smaller number below $K$ which excludes these ties, allowing the choice of an adaptive number of main instruction steps when there is not enough saliency for the last steps. This strategy essentially selects $k \leq K$ salient steps, while refusing to make a choice among steps with equal support that would increase the total number of steps beyond $K$. As we will see in our results in Sec. 5.1, our algorithm sometimes returns a much smaller number than $K$ for the main instruction steps, giving more robustness to the exact choice of parameter $K$.</p>
<p>Encoding of the output. We post-process the output of multiple sequence alignment into an assignment matrix $R_{n} \in{0,1}^{S_{n} \times K}$ for each input video $n$, where $\left(R_{n}\right)<em s="s">{s k}=$ 1 means that the direct object token $d</em>$ will be zero.}^{n}$ has been assigned to step $k$. If a direct object has not been assigned to any step, the corresponding row of the matrix $R_{n</p>
<h3>4.2. Discriminative clustering of videos under text constraints</h3>
<p>Given the output of the text clustering that identified the important $K$ steps forming a task, we now want to find their temporal location in the video signal. We formalize this problem as looking for an assignment matrix $Z_{n} \in$ ${0,1}^{T_{n} \times K}$ for each input video $n$, where $\left(Z_{n}\right)<em n="n">{t k}=1$ indicates the visual presence of step $k$ at time interval $t$ in video $n$, and $T</em>$ is zero, indicating that no step is visually present for the corresponding time interval.}$ is the length of video $n$. Similarly to $R_{n}$, we allow the possibility that a whole row of $Z_{n</p>
<p>We propose to tackle this problem using a discriminative clustering approach with global ordering constraints, as was successfully used in the past for the temporal localization of actions in videos [4], but with additional weak temporal constraints. In contrast to [4] where the order of actions was manually given for each video, our multiple sequence alignment approach automatically discovers the main steps. More importantly, we also use the text caption timing to provide a fine-grained weak temporal supervision for the visual appearance of steps, which is described next.</p>
<p>Temporal weak supervision from text. From the output of the multiple sequence alignment (encoded in the matrix $R_{n} \in{0,1}^{S_{n} \times K}$ ), each direct object token $d_{s}^{n}$ has been assigned to one of the possible $K$ steps, or to no step at all. We use the tokens that have been assigned to a step as
a constraint on the visual appearance of the same step in the video (using the assumption that people do what they say approximately when they say it). We encode the closed caption timing alignment by a binary matrix $A_{n} \in{0,1}^{S_{n} \times T_{n}}$ for each video, where $\left(A_{n}\right)<em b="b">{s t}$ is 1 if the $s$-th direct object is mentioned in a closed caption that overlaps with the time interval $t$ in video. Note that this alignment is only approximate as people usually do not perform the action exactly at the same time that they talk about it, but instead with a varying delay. Second, the alignment is noisy as people typically perform the action only once, but often talk about it multiple times (e.g. in a summary at the beginning of the video). We address these issues by the following two weak supervision constraints. First, we consider a larger set of possible time intervals $\left[t-\Delta</em>$ (see Appendix C. 2 for the detailed derivation).}, t+\Delta_{a}\right]$ in the matrix $A$ rather than the exact time interval $t$ given by the timing of the closed caption. $\Delta_{b}$ and $\Delta_{a}$ are global parameters fixed either qualitatively, or by cross-validation if labeled data is provided. Second, we put as a constraint that the action happens at least once in the set of all possible video time intervals where the action is mentioned in the transcript (rather than every time it is mentioned). These constraints can be encoded as the following linear inequality constraint on $Z_{n}: A_{n} Z_{n} \geq R_{n</p>
<p>Ordering constraint. In addition, we also enforce that the temporal order of the steps appearing visually is consistent with the discovered script from the text, encoding our assumption that there is a common ordered script for the task across videos. We encode these sequence constraints on $Z_{n}$ in a similar manner to [5], which was shown to work better than the encoding used in [4]. In particular, we only predict the most salient time interval in the video that describes a given step. This means that a particular step is assigned to exactly one time interval in each video. We denote by $Z_{n}$ this sequence ordering constraint set.</p>
<p>Discriminative clustering. The main motivation behind discriminative clustering is to find a clustering of the data that can be easily recovered by a linear classifier through the minimization of an appropriate cost function over the assignment matrix $Z_{n}$. The approach introduced in [2] allows to easily add prior information on the expected clustering. Such priors have been recently introduced in the context of aligning video and text $[4,5]$ in the form of ordering constraints over the latent label variables. Here we use a similar approach to cluster the $N$ input video streams $\left(x_{t}\right)$ into a sequence of $K$ steps, as follows. We represent each time interval by a $d$-dimensional feature vector. The feature vectors for the $n$-th video are stacked in a $T_{n} \times d$ design matrix denoted by $X_{n}$. We denote by $X$ the $T \times d$ matrix obtained by the concatenation of all $X_{n}$ matrices (and similarly, by $Z, R$ and $A$ the appropriate concatenation of the $Z_{n}, R_{n}$ and $A_{n}$ matrices over $n$ ). In order to obtain the temporal localization into $K$ steps, we learn a linear classifier represented by a $d \times K$ matrix denoted by $W$. This model is shared among all videos.</p>
<table>
<thead>
<tr>
<th>Changing a tire</th>
<th></th>
<th>Performing CPR</th>
<th></th>
<th>Repot a plant</th>
<th></th>
<th>Make coffee</th>
<th></th>
<th>Jump car</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>GT (11)</td>
<td>$K \leq 10$</td>
<td>GT (7)</td>
<td>$K \leq 10$</td>
<td>GT (7)</td>
<td>$K \leq 10$</td>
<td>GT (10)</td>
<td>$K \leq 10$</td>
<td>GT (12)</td>
<td>$K \leq 10$</td>
</tr>
<tr>
<td>get tools out start loose</td>
<td>get tire loosen nut</td>
<td>open airway check pulse</td>
<td>open airway put hand</td>
<td>take plant put soil</td>
<td>remove plant use soil</td>
<td>add coffee</td>
<td>put coffee fill chamber</td>
<td>connect red $A$</td>
<td>connect cable charge battery</td>
</tr>
<tr>
<td>jack car unscrew wheel remove wheel put wheel screw wheel lower car tight wheel</td>
<td>put jack jack car remove nut take wheel take tire put nut lower jack tighten nut</td>
<td>give breath do compressions</td>
<td>loosen roots place plant add top water plant</td>
<td>loosen soil place plant add soil water plant</td>
<td>fill water screw filter put stove see coffee pour coffee</td>
<td>fill water fill water put filter see steam take minutes make coffee see coffee make cup</td>
<td>connect red $B$ start car $A$ remove cable $A$ remove cable $B$</td>
<td>connect end start car remove cable disconnect cable</td>
<td></td>
</tr>
<tr>
<td>Precision</td>
<td>0.9</td>
<td>Precision</td>
<td>0.4</td>
<td>Precision</td>
<td>1</td>
<td>Precision</td>
<td>0.67</td>
<td>Precision</td>
<td>0.83</td>
</tr>
<tr>
<td>Recall</td>
<td>0.9</td>
<td>Recall</td>
<td>0.57</td>
<td>Recall</td>
<td>0.86</td>
<td>Recall</td>
<td>0.6</td>
<td>Recall</td>
<td>0.42</td>
</tr>
</tbody>
</table>
<p>Table 1: Automatically recovered sequences of steps for the five tasks. Each recovered step is represented by one of the aligned direct object relations (shown in bold). Note that most of the recovered steps correspond well to the ground truth steps (shown in italic). The results are shown for the maximum number of discovered steps $K$ set to 10. Note how our method automatically selects less than 10 steps in some cases. These are the automatically chosen $k \leq K$ steps that are the most salient in the aligned narrations as described in Sec. 4.1. For $C P R$, our method recovers fine-grained steps e.g. tilt head, lift chin, which are not included in the main ground truth steps, but nevertheless could be helpful in some situations, as well as repetitions that were not annotated but were indeed present.</p>
<p>The target assignment $\hat{Z}$ is found by minimizing the clustering cost function $h$ under both the consistent script ordering constraints $\mathcal{Z}$ and our weak supervision constraints:</p>
<p>$\underset{\mathcal{Z}}{\operatorname{minimize}} \quad h(Z) \quad$ s.t. $\underbrace{Z \in \mathcal{Z}}<em _text="\text" _weak="{weak" textual="textual">{\text {ordered script }}, \underbrace{A Z \geq R}</em>$ constraints.
The clustering cost $h(Z)$ is given as in DIFFRAC [2] as:}</p>
<p>$$
h(Z)=\min <em F="F">{W \in \mathbb{R}^{K} \times d} \underbrace{\frac{1}{2 T}|Z-X W|</em>}^{2}<em F="F">{\text {Discriminative loss on data }}+\underbrace{\frac{\lambda}{2}|W|</em> .
$$}^{2}}_{\text {Regularizer }</p>
<p>The first term in (3) is the discriminative loss on the data that measures how easy the input data $X$ is separable by the linear classifier $W$ when the target classes are given by the assignments $Z$. For the squared loss considered in eq. (3), the optimal weights $W^{*}$ minimizing (3) can be found in closed form, which significantly simplifies the computation. However, to solve (2), we need to optimize over assignment matrices $Z$ that encode sequences of events and incorporate constraints given by clusters obtained from transcribed textual narrations (Sec. 4.1). This is again done by using the Frank-Wolfe algorithm, which allows the use of efficient dynamic programs to handle the combinatorial constraints on $Z$. More details are given in Appendix C.</p>
<h2>5. Experimental evaluation</h2>
<p>In this section, we first describe the details of the text and video features. Then we present the results divided into two experiments: (i) in Sec. 5.1, we evaluate the quality of steps extracted from video narrations, and (ii) in Sec. 5.2, we evaluate the temporal localization of the recovered steps in video using constraints derived from text. All the data and code are available at our project webpage [1].</p>
<p>Video and text features. We represent the transcribed narrations as sequences of direct object relations. For this purpose, we run a dependency parser [8] on each transcript. We lemmatize all direct object relations and keep the ones for which the direct object corresponds to nouns. To represent a video, we use motion descriptors in order to capture actions (loosening, jacking-up, giving compressions) and frame appearance descriptors to capture the depicted objects (tire, jack, car). We split each video into 10 -frame time intervals and represent each interval by its motion and appearance descriptors aggregated over a longer block of 30 frames. The motion representation is a histogram of local optical flow (HOF) descriptors aggregated into a single bag-of-visual-word vector of 2,000 dimensions [30]. The visual vocabulary is generated by k-means on a separate large set of training descriptors. To capture the depicted objects in the video, we apply the VGG-verydeep-16 CNN [28] over each frame in a sliding window manner over multiple scales. This can be done efficiently in a fully convolutional manner. The resulting 512-dimensional feature maps of conv5 responses are then aggregated into a single bag-of-visual-word vector of 1,000 dimensions, which aims to capture the presence/absence of different objects within each video block. A similar representation (aggregated into compact VLAD descriptor) was shown to work well recently for a variety of recognition tasks [7]. The bag-of-visualword vectors representing the motion and the appearance are normalized using the Hellinger normalization and then concatenated into a single 3,000 dimensional vector representing each time interval.</p>
<p>WordNet distance. For the multiple sequence alignment presented in Sec. 4.1, we set $c\left(d_{1}, d_{2}\right)=-1$ if $d_{1}$ and $d_{2}$ have both their verbs and direct objects that match exactly in the Wordnet tree (distance equal to 0 ). Otherwise we set $c\left(d_{1}, d_{2}\right)$ to be 100 . This is to ensure a high precision for the resulting alignment.</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: Results for temporally localizing recovered steps in the input videos. We give in <strong>bold</strong> the number of ground truth steps.</p>
<h3>5.1 Results of step discovery from text narrations</h3>
<p>Results of discovering the main steps for each task from text narrations are presented in Table 1. We report results of the multiple sequence alignment described in Sec. 4.1 when the maximum number of recoverable steps is <em>K</em> = 10. Additional results for different choices of <em>K</em> are given in the Appendix E.1. With increasing <em>K</em>, we tend to recover more complete sequences at the cost of occasional repetitions, e.g., <em>position jack</em> and <em>jack car</em> that refer to the same step. To quantify the performance, we measure precision as the proportion of correctly recovered steps appearing in the correct order. We also measure recall as the proportion of the recovered ground truth steps. The values of precision and recall are given at the bottom of Table 1.</p>
<h3>5.2 Results of localizing instruction steps in video</h3>
<p>In the previous section, we have evaluated the quality of the sequences of steps recovered from the transcribed narrations. In this section, we evaluate how well we localize the individual instruction steps in the video by running our two-stage approach from Sec. 4.</p>
<p><strong>Evaluation metric.</strong> To evaluate the temporal localization, we need to have a one-to-one mapping between the discovered steps in the videos and the ground truth steps. Following [18], we look for a one-to-one global matching (shared across all videos of a given task) that maximizes the evaluation score for a given method (using the Hungarian algorithm). Note that this mapping is used only for evaluation; the algorithm does not have access to the ground truth annotations for learning.</p>
<p>The goal is to evaluate whether each ground truth step has been correctly localized in all instruction videos. We thus use the <em>F1 score</em> that combines precision and recall into a single score as our evaluation measure. For a given video and a given recovered step, our video clustering method predicts exactly one video time interval <em>t</em>. This detection is considered correct if the time interval falls inside any of the corresponding ground truth intervals, and incorrect otherwise (resulting in a false positive for this video). We compute the recall across all steps and videos, defined as the ratio of the number of correct predictions over the total number of possible ground truth steps across videos. A recall of 1 indicates that every ground truth step has been correctly detected across all videos. The recall decreases towards 0 when we miss some ground truth steps (missed detections). This happens either because this step was not recovered globally, or because it was detected in the video at an incorrect location. This is because the algorithm predicts exactly one occurrence of each step in each video. Similarly, precision measures the proportion of correct predictions among all <em>N</em> ⋅ <em>K</em>pred possible predictions, where <em>N</em> is the number of videos and <em>K</em>pred is the number of main steps used by the method. The F1 score is the harmonic mean of precision and recall, giving a score that ranges between 0 and 1, with the perfect score of 1 when all the steps are predicted at their correct locations in all videos.</p>
<p><strong>Hyperparameters.</strong> We set the values of parameters ∆<em>k</em> and ∆<em>w</em> to 0 and 10 seconds. The setting is the same for all five tasks. This models the fact that typically each step is first described verbally and then performed on the camera. We set λ = 1 / (<em>NK</em>pred) for all methods that use (3).</p>
<p><strong>Baselines.</strong> We compare results to four baselines. To demonstrate the difficulty of our dataset, we first evaluate a "Uniform" baseline, which simply distributes instructions steps uniformly over the entire instruction video. The second baseline "Video only" [4] does not use the narration and performs only discriminative clustering on visual features with a global order constraint.5 The third baseline "Video + BOW dobj" basically adds text-based features to the "Video only" baseline (by concatenating the text and video features in the discriminative clustering approach). Here the goal is to evaluate the benefits of our two-stage clustering approach, in contrast to this single-stage clustering baseline. The text features are bag-of-words histograms over a fixed vocabulary of direct object relations.6 The fourth baseline is our own implementation of the alignment method of [19] (without the supervised vision refinement procedure that requires a set of pre-trained visual classifiers that are not available a-priori in our case). We use [19] to re-align the speech transcripts to the sequence of steps discovered by our method of Sec. 4.1 (as a proxy for the recipe assumed).</p>
<p><sup>5</sup>We use here the improved model from [5] which does not require a "background class" and yields a stronger baseline equivalent to our model (2) <em>without</em> the weak textual constraints.</p>
<p><sup>6</sup>Alternative features of bag-of-words histograms treating separately nouns and verbs also give similar results.</p>
<p>to be known in [19]). To assess the difficulty of the task and dataset, we also compare results with a “Supervised" approach. The classifiers $W$ for the visual steps are trained by running the discriminative clustering of Sec. 4.2 with only ground truth annotations as constraints on the training set. At test time, these classifiers are used to make predictions under the global ordering constraint on unseen videos. We report results using 5-fold cross validation for the supervised approach, with the variation across folds giving the error bars. For the unsupervised discriminative clustering methods, the error bars represent the variation of performance obtained from different rounded solutions collected during the Frank-Wolfe optimization.</p>
<p>Results. Results for localizing the discovered instruction steps are shown in Figure 3. In order to perform a fair comparison to the baseline methods that require a known number of steps $K$, we report results for a range of $K$ values. Note that in our case the actual number of automatically recovered steps can be (and often is) smaller than $K$. For Change tire and Perform CPR, our method consistently outperforms all baselines for all values of $K$ demonstrating the benefits of our approach. For Repot, our method is comparable to text-based baselines, underlying the importance of the text signal for this problem. For Jump car, our method delivers the best result (for $K=15$ ) but struggles for lower values of $K$, which we found was due to visually similar repeating steps (e.g. start car A and start car B) which are mixed-up for lower values of $K$. For the Make coffee task, the video only baseline is comparable to our method, which by inspecting the output could be attributed to large variability of narrations for this task. Qualitative results of the recovered steps are illustrated in Figure 4.</p>
<h2>6 Conclusion and future work</h2>
<p>We have described a method to automatically discover the main steps of a task from a set of narrated instruction videos in an unsupervised manner. The proposed approach has been tested on a new annotated dataset of challenging real-world instruction videos containing complex personobject interactions in a variety of indoor and outdoor scenes. Our work opens up the possibility for large scale learning from instruction videos on the Internet. Our model currently assumes the existence of a common script with a fixed ordering of the main steps. While this assumption is often true, e.g. one cannot remove the wheel before jacking up the car, or make coffee before filling the water, some tasks can be performed while swapping (or even leaving out) some of the steps. Recovering more complex temporal structures is an interesting direction for future work.</p>
<p>Acknowledgments This research was supported in part by a Google Research Award, and the ERC grants VideoWorld (no. 267907), Activia (no. 307574) and LEAP (no. 336845).</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 4: Examples of three recovered instruction steps for each of the five tasks in our dataset. For each step, we first show clustered direct object relations, followed by representative example frames localizing the step in the videos. Correct localizations are shown in green. Some steps are incorrectly localized in some videos (red), but often look visually very similar. See Appendix E. 2 for additional results.</p>
<h2>References</h2>
<p>[1] Project webpage (code/dataset). http://www.di.ens. fr/willow/research/instructionvideos/. 6
[2] F. Bach and Z. Harchaoui. DIFFRAC: A discriminative and flexible framework for clustering. In NIPS, 2007. 5, 6, 12
[3] P. Bojanowski, F. Bach, I. Laptev, J. Ponce, C. Schmid, and J. Sivic. Finding actors and actions in movies. In ICCV, 2013. 2
[4] P. Bojanowski, R. Lajugie, F. Bach, I. Laptev, J. Ponce, C. Schmid, and J. Sivic. Weakly supervised action labeling in videos under ordering constraints. In ECCV, 2014. 2, $4,5,7,12$
[5] P. Bojanowski, R. Lajugie, E. Grave, F. Bach, I. Laptev, J. Ponce, and C. Schmid. Weakly-supervised alignment of video with text. In ICCV, 2015. 2, 5, 7, 12, 13
[6] N. Chambers and D. Jurafsky. Unsupervised learning of narrative event chains. In ACL, 2008. 2
[7] M. Cimpoi, S. Maji, and A. Vedaldi. Deep filter banks for texture recognition and segmentation. In CVPR, 2015. 6
[8] M.-C. de Marneffe, B. MacCartney, and C. D. Manning. Generating typed dependency parses from phrase structure parses. In LREC, 2006. 4, 6
[9] O. Duchenne, I. Laptev, J. Sivic, F. Bach, and J. Ponce. Automatic annotation of human actions in video. In ICCV, 2009. 2
[10] C. Fellbaum. Wordnet: An electronic lexical database. Cambridge, MA: MIT Press., 1998. 4
[11] L. Frermann, I. Titov, and M. Pinkal. A hierarchical Bayesian model for unsupervised induction of script knowledge. In EACL, 2014. 2
[12] D. G. Higgins and P. M. Sharp. Clustal: A package for performing multiple sequence alignment on a microcomputer. Gene, 1988. 5, 11
[13] M. Jaggi. Revisiting Frank-Wolfe: Projection-free sparse convex optimization. In ICML, 2013. 4, 11
[14] A. Joulin, K. Tang, and L. Fei-Fei. Efficient image and video co-localization with Frank-Wolfe algorithm. In ECCV, 2014. 4,11
[15] S. Lacoste-Julien and M. Jaggi. On the global linear convergence of Frank-Wolfe optimization variants. In NIPS, 2015. 4
[16] I. Laptev, M. Marszalek, C. Schmid, and B. Rozenfeld. Learning realistic human actions from movies. In CVPR, 2008. 2
[17] C. Lee, C. Grasso, and M. Sharlow. Multiple sequence alignment using partial order graphs. Bioinformatics, 2002. 4, 5, 11,12
[18] T. Liao. Clustering of time series data, a survey. Pattern recognition, 2014. 7
[19] J. Malmaud, J. Huang, V. Rathod, N. Johnston, A. Rabinovich, and K. Murphy. What's cookin'? Interpreting cooking videos using text, speech and vision. In NAACL, 2015. $1,2,7,8$
[20] G. A. Miller. Wordnet: A lexical database for english. Communications of the ACM, 1995. 4
[21] I. Naim, Y. Chol Song, Q. Liu, L. Huang, H. Kautz, J. Luo, and D. Gildea. Discriminative unsupervised alignment of natural language instructions with corresponding video segments. In NAACL, 2015. 2
[22] J. C. Niebles, C.-W. Chen, and L. Fei-Fei. Modeling temporal structure of decomposable motion segments for activity classification. In ECCV, 2010. 2
[23] J. C. Niebles, H. Wang, and L. Fei-Fei. Unsupervised learning of human action categories using spatial-temporal words. IJCV, 2008. 2
[24] D. Potapov, M. Douze, Z. Harchaoui, and C. Schmid. Category-specific video summarization. In ECCV, 2014. 2, 3
[25] M. Raptis and L. Sigal. Poselet key-framing: A model for human activity recognition. In CVPR, 2013. 2
[26] M. Regneri, A. Koller, and M. Pinkal. Learning script knowledge with Web experiments. In ACL, 2010. 1, 2, 4
[27] O. Sener, A. Zamir, S. Savarese, and A. Saxena. Unsupervised semantic parsing of video collections. In ICCV, 2015. 2
[28] K. Simonyan and A. Zisserman. Very deep convolutional networks for large-scale image recognition. In ICLR, 2015. 6
[29] M. Sun, A. Farhadi, and S. Seitz. Ranking domain-specific highlights by analyzing edited videos. In ECCV, 2014. 2, 3
[30] H. Wang and C. Schmid. Action recognition with improved trajectories. In ICCV, 2013. 6
[31] L. Wang and T. Jiang. On the complexity of multiple sequence alignment. Journal of computational biology, 1(4):337-348, 1994. 4, 11</p>
<h2>Outline of Supplementary Material</h2>
<p>This supplementary material provides additional details for our method and presents a more complete set of results. Section A gives detailed statistics and an illustration of the newly collected dataset of instruction videos. Section B gives details about our new formulation of the multiple sequence alignment problem (Section 4.1 of the main paper) as a quadratic program and presents empirical results showing that our Frank-Wolfe optimization approach obtains solutions with lower objective values than the state-of-the-art heuristic algorithms for multiple sequence alignment. Section C provides the details for the discriminative clustering of videos with text constraints that was briefly described in Section 4.2 of the main paper. Section D gives additional details about the experimental protocol used in Section 5.2 in the main paper. Finally, in Section E, we give a more complete set of qualitative results for both the clustering of transcribed verbal instructions (see E.1) and localizing instruction steps in video (see E.2).</p>
<h2>A. New challenging dataset of instruction videos</h2>
<h2>A.1. Dataset statistics</h2>
<p>In this section, we introduce three different scores which aim to illustrate different properties of our dataset. The scores characterize (i) the step ordering consistency, (ii) the missing steps and (iii) the possible step repetitions.</p>
<p>Let $N$ be the number of videos for a given task and $K$ the number of steps defined in the ground truth. We assume that the ground truth steps are given in an ordered fashion, meaning the global order is defined as the sequence ${1, \ldots, K}$. For the $n$ th video, we denote by $g_{n}$ the total number of annotated steps, by $u_{n}$ the number of unique annotated steps and finally by $l_{n}$ the length of the longest common subsequence between the annotated sequence of steps and the ground truth sequence ${1, \ldots, K}$.</p>
<p>Order consistency error. The order error score $O$ is defined as the proportion of non repeated annotated steps that are not consistent with the global ordering. In other words, it is defined as the number of steps that do not fit the global ordering defined in the ground truth divided by the total number of unique annotated steps. More formally, $O$ is defined as follows:</p>
<p>$$
O:=1-\frac{\sum_{n=1}^{N} l_{n}}{\sum_{n=1}^{N} u_{n}}
$$</p>
<p>Missing steps. We define the missing steps score $M$ as the proportion of steps that are visually missing in the videos when compared to the ground truth. Formally,</p>
<p>$$
M:=1-\frac{\sum_{n=1}^{N} u_{n}}{K N}
$$</p>
<p>Repeated steps. The repetition score $R$ is defined as the proportion of steps that are repeated:</p>
<p>$$
R:=1-\frac{\sum_{n=1}^{N} u_{n}}{\sum_{n=1}^{N} g_{n}}
$$</p>
<p>Results. In Table 2, we give the previously defined statistics for the five tasks of the instruction videos dataset. Interestingly, we observed that globally the order is consistent for the five tasks with a total order error of only $6 \%$. Steps are missing in $27 \%$ of the cases. This illustrates the difficulty of defining the right granularity of the ground truth for this task. Indeed, some steps might be optional and thus not visually demonstrated in all videos. Finally the global repetition score is $14 \%$. Looking more closely, we observe that the Performing CPR task is the main contributor to this score. This is obviously a good example where one needs to repeat several times the same steps (here alternating between compressions and giving breath). Even if our model is not explicitly handling this case, we observed that our multiple sequence alignment technique for clustering the text inputs discovered these repetitions (see Table 4). Finally, these statistics show that the problem introduced in this paper is very challenging and that designing models which are able to capture more complex structure in the organization of the steps is a promising direction for future work.</p>
<h2>A.2. Complete illustration of the dataset</h2>
<p>Figure 6 illustrates all five tasks in our newly collected dataset. For each task, we show a subset of 3 events that compose the task. Each event is represented by several sample frames and extracted verbal narrations. Note the large variability of verbal expressions and the terminology in the transcribed narrations as well as the large variability of visual appearance due to viewpoint, used objects, and actions performed in different manner. At the same time, note the the consistency of the actions between the different videos and the underlying script of each task.</p>
<h2>B. Clustering transcribed verbal instructions</h2>
<p>In this section, we review in details the way we model the text clustering. In particular, we give details on how we can reformulate multiple sequence alignment as a quadratic program. Recall that we are given $N$ narrated instruction videos. For the $n$-th video, the text signal is represented as a sequence of direct object relation tokens : $d^{n}=\left(d_{1}^{n}, \ldots, d_{S_{n}}^{n}\right)$, where the length $S_{n}$ of the sequences varies from one video clip to another. The number of possible direct object relations in our dictionary is denoted $D$. The multiple sequence alignment (MSA) problem was formulated as mapping each input sequence $d^{n}$ of tokens to a global common template of $L$ slots, while minimizing the sum-of-pairs score given in (1). For each input sequence $d^{n}$, we used the notation $\left(\phi\left(d^{n}\right)\right)<em l="l">{1 \leq l \leq L}$ to denote the re-mapped sequence of tokens into $L$ slots: $\phi\left(d^{n}\right)</em>\right)}$ represents the direct object relation put at location $l$, with $\phi\left(d^{n<em 1="1">{l}=\varnothing$ denoting that a gap was inserted in the original sequence and the slot $l$ is left empty. We also have defined a cost $c\left(d</em>$ is equal to the cost of aligning the $i$-th and the $j$-th direct object relation from the dictionary together.}, d_{2}\right)$ of aligning two direct object relations together, with the possibility that $d_{1}$ or $d_{2}$ is $\varnothing$, in which case we defined the cost to be 0 by default. In the following, we summarize the cost of aligning non-empty direct object relations by the matrix $C_{o} \in \mathbb{R}^{D \times D}$, $\left(C_{o}\right)_{i j</p>
<h2>B.1. Reformulating multiple sequence alignment as a quadratic program</h2>
<p>We now present our formalization of the search problem as a quadratic program. To the best of our knowledge this is a new</p>
<table>
<thead>
<tr>
<th>Task</th>
<th>Changing tire</th>
<th>Performing CPR</th>
<th>Repoting plant</th>
<th>Making coffee</th>
<th>Jumping cars</th>
<th>Average</th>
</tr>
</thead>
<tbody>
<tr>
<td>Order error</td>
<td>0.7%</td>
<td>11%</td>
<td>6%</td>
<td>3%</td>
<td>8%</td>
<td>6%</td>
</tr>
<tr>
<td>Missing steps</td>
<td>16%</td>
<td>32%</td>
<td>30%</td>
<td>28%</td>
<td>27%</td>
<td>27%</td>
</tr>
<tr>
<td>Repetition score</td>
<td>4%</td>
<td>50%</td>
<td>7%</td>
<td>11%</td>
<td>0.4%</td>
<td>14%</td>
</tr>
</tbody>
</table>
<p>Table 2: Statistics of the instruction video dataset.</p>
<p>formulation of the multiple sequence alignment (MSA) problem, which in our setting (results shown later) consistently obtains better values of the multiple sequence alignment objective than the current state-of-the-art MSA heuristic algorithms.</p>
<p>We encode the identity of a direct object relation with a $D$-dimensional indicator vector. The text sequence $n$ can then be represented by an indicator matrix $Y_{n}\in{0,1}^{S_{n}\times D}$. The $j$-th row of $Y_{n}$ indicates which direct object relations is evoked at the $j$-th position. Similarly, the token re-mapping $(\phi(d^{n}))<em n="n">{1\leq l\leq L}$ can be represented as a $L \times D$ indicator matrix; where each row $l$ encodes which token is appearing in slot $l$ (and a whole row of zero is used to indicates an empty $\varnothing$ slot). This re-mapping can be constructed from two pieces of information: first, which token index $s$ of the original sequence is re-mapped to which global template slot $l$; we represent this by the decision matrix $U</em>$, and the fact that the alignment of empty slots has zero cost, we can then rewrite the MSA problem that minimizes the sum-of-pairs objective (1) as follows:}\in{0,1}^{S_{n}\times L}$, which satisfies very specific constraints (see below). The second piece of information is the composition of the input sequence encoded by $Y_{n}$. We thus have $\phi(d^{n})=U_{n}^{T} Y_{n}$ (as a $L \times D$ indicator matrix). Given this encoding, the cost matrix $C_{o</p>
<p>$$
\begin{array}{ll}
\underset{U_{n}, n \in{1, \ldots, N}}{\operatorname{minimize}} &amp; \sum_{(n, m)} \operatorname{Tr}\left(U_{n}^{T} Y_{n} C_{o} Y_{m}^{T} U_{m}\right) \
\text { subject to } &amp; U_{n} \in \mathcal{U}_{n}, n=1, \ldots, N
\end{array}
$$</p>
<p>In the above equation, the trace $(\operatorname{Tr})$ is computing the cost of aligning sequence $m$ with sequence $n$ (the inner sum in (1)). Moreover, $\mathcal{U}<em n="n">{n}$ is a constraint set that encodes the fact that $U</em>$ matrices. We can then rewrite the equation (7) as a quadratic program over the (integer) variable $U$ :}$ has to be a valid (increasing) re-mapping. ${ }^{8}$ As before, we can eliminate the video index $n$ by simply stacking the assignment matrices $U_{n}$ in one matrix $U$ of size $S \times L$. Similarly, we denote $Y$ the $S \times D$ matrix which is obtained by the concatenation of all the $Y_{n</p>
<p>$$
\underset{U}{\operatorname{minimize}} \operatorname{Tr}\left(U^{T} B U\right), \text { subject to } U \in \mathcal{U}
$$</p>
<p>In this equation, the $S \times S$ matrix $B$ is deduced from the input sequences and the cost between different direct object relations by computing $B:=Y C_{o} Y^{T}$. It represents the pairwise cost at the token level, i.e. the cost of aligning token $s$ in one sequence to token $s^{\prime}$ in another sequence.</p>
<h2>B.2. Comparison of methods</h2>
<p>The problem (8) is NP-hard [31] in general, as is typical for integer quadratic programs. However, much work has been done in computational biology to develop efficient heuristics to solve</p>
<p><sup id="fnref5:0"><a class="footnote-ref" href="#fn:0">1</a></sup>the MSA problem, as it is an important problem in their field. We briefly describe below some of the existing heuristics to solve it, and then present our Frank-Wolfe optimization approach, which gave surprisingly good empirical results for our problem. ${ }^{9}$</p>
<p>Standard methods. Here, we compare to a standard state-of-the-art method for multiple sequence alignment [17]. Similarly to [12], they first align two sequences and merge them in a common template. Then they align a new sequence to the template and then update the template. They continue like this until no sequence is left. Differently from [12], they use a better representation of the template by using partial order graph instead of simple linear representations. This gives more accuracy for the final alignment. For the experiments, we use the author's implementation. ${ }^{10}$</p>
<p>Our solution using Frank-Wolfe optimization. We first note that problem (8) has a very similar structure to an optimization problem that we solve using Frank-Wolfe optimization for the discriminative clustering of videos; see Equations (12) and (13) below. For this, we first perform a continuous relaxation of the set of constraints $\mathcal{U}$ by replacing it with its convex hull $\hat{\mathcal{U}}$. The Frank-Wolfe optimization algorithm [13] can solve quadratic program over constraint sets for which we have access to an efficient linear minimization oracle. In the case of $\mathcal{U}$, the linear oracle can be solved exactly with a dynamic program very similar to the one described in Section C.2. We note here that even with the continuous relaxation over $\hat{\mathcal{U}}$, the resulting problem is still non-convex because $B$ is not positive semidefinite - this is because of the cost function appearing in the MSA problem. However, the standard convergence proof for Frank-Wolfe can easily be extended to show that it converges at a rate of $O(1 / \sqrt{k})$ to a stationary point on non-convex objectives [33]. Once the algorithm has converged to a (focal) stationary point, we need to round the fractional solution to obtain a valid encoding $U$. We follow here a similar rounding strategy that was originally proposed by [32] and then re-used in [14]: we pick the last visited corner (which is necessarily integer) which was given as a solution to the linear minimization oracle (this is called Frank-Wolfe rounding).</p>
<p>Results. In Table 3, we give the value of the objective (8) for the rounded solutions obtained by the two different optimization approaches (lower is better), for the MSA problem on our five tasks. Interestingly, we observe that the Frank-Wolfe algorithm</p>
<p><sup id="fnref:1"><a class="footnote-ref" href="#fn:1">2</a></sup></p>
<table>
<thead>
<tr>
<th>Task</th>
<th>Changing tire</th>
<th>Performing CPR</th>
<th>Repotting plant</th>
<th>Making coffee</th>
<th>Jumping cars</th>
</tr>
</thead>
<tbody>
<tr>
<td>Poa [17]</td>
<td>11.30</td>
<td>-3.82</td>
<td>1.65</td>
<td>-2.99</td>
<td>4.55</td>
</tr>
<tr>
<td>Ours using Frank-Wolfe</td>
<td>-5.18</td>
<td>-4.51</td>
<td>-3.55</td>
<td>-3.86</td>
<td>-4.67</td>
</tr>
</tbody>
</table>
<p>Table 3: Comparison of different optimization approaches for solving problem (8). (Objective value, lower is better).
consistently outperforms the state-of-the-art method of [17] in our setting.</p>
<h2>C. Discriminative clustering of videos under text constraints</h2>
<p>We give more details here on the discriminative clustering framework from [4, 5] (and our modifications to include the text constraints) that we use to localize the main actions in the video signal.</p>
<h2>C.1. Explicit form of $h(Z)$</h2>
<p>We recall that $h(Z)$ is the cost of clustering all the video streams $\left{x^{n}\right}, n=1, \ldots, N$, into a sequence of $K$ steps. The design matrix $X \in \mathbb{R}^{T \times d}$ contains the feature describing the time intervals in our videos. The indicator latent variable $Z \in \mathcal{Z}:=$ ${0,1}^{T \times K}$ encodes the visual presence of a step $k$ at a time interval $t$. Recall also that $X$ and $Z$ contains the information about all videos $n \in{1, \ldots, N}$. Finally, $W \in \mathbb{R}^{d \times K}$ represents a linear classifier for our $K$ steps, that is shared among all videos. We now derive the explicit form of $h(Z)$ as in the DIFFRAC approach [2], though yielding a somewhat simpler expression (as in [5]) due to our use of a (weakly regularized) bias feature in $X$ instead of a separate (unregularized) bias $b$. Consider the following joint cost function $f$ on $Z$ and $W$ defined as</p>
<p>$$
f(Z, W)=\frac{1}{2 T}|Z-X W|<em F="F">{F}^{2}+\frac{\lambda}{2}|W|</em>
$$}^{2</p>
<p>The cost function $f$ simply represents the ridge regression objective with output labels $Z$ and input design matrix $X$. We note that $f$ has the nice property of being jointly convex in both $Z$ and $W$, implying that its unrestricted minimization with respect to $W$ yields a convex function in $Z$. This minimization defines our clustering $\operatorname{cost} h(Z)$; rewriting the definition of $h$ with the joint cost $f$ from (9), we have:</p>
<p>$$
h(Z)=\min _{W \in \mathbb{R}^{d \times K}} f(Z, W)
$$</p>
<p>As $f$ is strongly convex in $W$ (for any $Z$ ), we can obtain its unique minimizer $W^{<em>}(Z)$ as a function of $Z$ by zeroing its gradient and solving for $W$. For the case of the square loss in equation (9), the optimal classifier $W^{</em>}(Z)$ can be computed in closed form:</p>
<p>$$
W^{*}(Z)=\left(X^{T} X+T \lambda I_{d}\right)^{-1} X^{T} Z
$$</p>
<p>where $I_{d}$ is the $d$-dimensional identity matrix. We obtain the explicit form for $h(Z)$ by substituting the expression (11) for $W^{*}(Z)$ in equation (9) and properly simplifying the expression:</p>
<p>$$
h(Z)=f\left(Z, W^{*}\right)=\frac{1}{2 T} \operatorname{Tr}\left(Z Z^{T} B\right)
$$</p>
<p>where $B:=I_{T}-X\left(X^{T} X+T \lambda I_{d}\right)^{-1} X^{T}$ is a strictly positive definite matrix (and so $h$ is actually strongly convex). The clustering cost is a quadratic function in $Z$, encoding how the clustering decisions in one interval $t$ interact with the clustering decisions in another interval $t^{\prime}$. In the next section, we explain how we can optimize the clustering cost $h(Z)$ subject to the constraints from Section 4.2 using the Frank-Wolfe algorithm.</p>
<h2>C.2. Frank Wolfe algorithm for minimizing $h(Z)$</h2>
<p>The localization of steps in the video stream is done by solving the following optimization problem (repeated from (2) here for convenience):</p>
<p>$$
\underset{Z}{\operatorname{minimize}} \quad h(Z) \quad \text { s.t. } \underbrace{Z \in \mathcal{Z}}<em _="{" _substack_text="\substack{\text" textual="textual" weak="weak">{\text {ordered script }}, \quad \underbrace{A Z \geq R}</em> .
$$} \ \text { constraints }}</p>
<p>where $Z$ is the latent assignment matrix of video time intervals to $K$ clusters and $R$ is the matrix of assignments of direct object relations in text to $K$ clusters. Note that $R$ is obtained from the text clustering using multiple sequence alignment as described in Section 4.1 and B.1, and is fixed before optimizing over $Z . R$ is a $S \times K$ matrix obtaining by picking the $K$ main columns of the $U$ matrix defined in Section B.1. This selection step was described in the "extracting the main steps" paragraph in Section 4.1.</p>
<p>The constraint set encodes several concepts. First, it imposes the temporal consistency between the text stream and the video stream. We recall that this constraint was written as $A Z \geq R$, where $A$ encodes the temporal alignment constraints between video and text (type I). Second, it includes the event ordering constraints within each video input (type II). Finally, it encodes the fact that each event is assigned to exactly one time interval within each video (type III). The last two constraints are encoded in the set of constraints $\mathcal{Z}$. To summarize, let $\tilde{\mathcal{Z}}$ denote the resulting (discrete) feasible space for $Z$ i.e. $\tilde{\mathcal{Z}}:=(Z \in \mathcal{Z} \mid A Z \geq R)$.</p>
<p>We are then left with a problem in $Z$ which is still hard to solve because the set $\tilde{\mathcal{Z}}$ is not convex. To approximately optimize $h$ over $\tilde{\mathcal{Z}}$, we follow the strategy of [4, 5]. First, we optimize $h$ over the relaxed $\operatorname{conv}(\tilde{\mathcal{Z}})$ by using the Frank-Wolfe algorithm to get a fractional solution $Z^{*} \in \operatorname{conv}(\tilde{\mathcal{Z}})$. We then find a feasible candidate $\tilde{Z} \in \tilde{\mathcal{Z}}$ by using a rounding procedure. We now give the details of these steps.</p>
<p>First we note that the linear oracle of the Frank-Wolfe algorithm can be solved separately for each video $n$. Indeed, because we solve a linear program, there is no quadratic term that brings dependence between different videos in the objective, and moreover all the constraints are blockwise in $n$. Thus, in the following,</p>
<p><sup id="fnref6:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 5: Illustration of the dynamic programming solution to the linear program (14). The drawing shows a possible cost matrix $\tilde{C}$ and an optimal path in red. The gray entries in the matrix $\tilde{C}$ correspond to the values from the matrix $C$. The white entries have minimal cost and are thus always preferred over any gray entry. Note that we display $\tilde{C}$ in a transpose manner to better fit on the page.</p>
<p>we will give details for one video only by adding an index $n$ to $\tilde{\mathcal{Z}}$, to $Z$ and to $T$.</p>
<p>The linear oracle of the Frank-Wolfe algorithm can be solved via an efficient dynamic program. Let us suppose that the linear oracle corresponds to the following problem:</p>
<p>$$
\min_{Z_n \in \tilde{Z}_n} \operatorname{Tr}(C_n^T Z_n),
$$</p>
<p>where $C_n \in \mathbb{R}^{T_n \times K}$ is a cost matrix that arises by computing the gradient of $h$ with respect to $Z_n$ at the current iterate. The goal of the dynamic program is to find which entries of $Z_n$ are equal to 1, recalling that $(Z_n)<em tk="tk">{tk} = 1$ means that the step $k$ was assigned to time interval $t$. From the constraint of type III (unique prediction per step), we know that each column $k$ of $Z_n$ has exactly one 1 (to be found). From the ordering constraint (type II), we know that if $(Z_n)</em>$ is of size $(T_n + 1) \times (2K + 1)$ and is illustrated (as its transpose) along with the corresponding update rules in Figure 5.} = 1$, then the only possible locations for a 1 in the $(k + 1)$-th column is for $t' &gt; t$ (i.e. the pattern of 1's is going downward when traveling from left to right in $Z_n$). Note that there can be "jumps" in between the time assignment for two subsequent steps $k$ and $k + 1$. In order to encode this possibility using a continuous path search in a matrix, we insert dummy columns into the cost matrix $C$. We first subtract the minimum value from $C$ and then insert columns filled with zeros in between every pair of columns of $C$. In the end, we pad $C$ with an additional row filled with zeros at the bottom. The resulting cost matrix $\tilde{C</p>
<p>The problem that we are interested in is subject to the additional linear constraints given by the clustering of text transcripts (constraints of type I). These constraint can be added by constraining the path in the dynamic programming algorithm. This can be done for instance by setting an infinite alignment cost outside of the constrained region.</p>
<p>At the end of the Frank-Wolfe optimization algorithm, we obtain a continuous solution $Z_n^<em>$ for each $n$. By stacking them all together again, we obtain a continuous solution $Z^</em>$. From the definition of $h$, we can also look at the corresponding model $W^<em>(Z^</em>)$ defined by equation (11) which again is shared among all videos. All $Z_n^<em>$ have to be rounded in order to obtain a feasible point for the initial, non relaxed problem. Several rounding options were suggested in [5]; it turns out that the one which uses $W^</em>$ gives better results in our case. More precisely, in order to get a good feasible binary matrix $\tilde{Z}<em Z_n="Z_n" _in="\in" _tilde_Z="\tilde{Z">n \in \tilde{Z}_n$, we solve the following problem: $\min</em>$.}_n} |Z_n - X_n W^*|_F^2$. By expanding the norm, we notice that this corresponds to a simple linear program over $\tilde{\mathcal{Z}}_n$ as in equation (14) that can be solved using again the same dynamic program detailed above. Finally, we stack these rounded matrices $\tilde{Z}_n$ to obtain our predicted assignment matrix $\tilde{Z} \in \tilde{\mathcal{Z}</p>
<h3>D. Experimental protocol</h3>
<p>In this section, we give more details about the setting for our experiments on the time localization of events with results given in Figure 3.</p>
<h4>D.1. Supervised experiments.</h4>
<p>Here, we describe in more details how we obtained the scores for the supervised approach depicted in yellow in Figure 3. We first divided the $N$ input videos in 5 different folds. One fold is kept for the test set while the 4 other are used as train/validation dataset. With the 4 remaining folds, we perform a 4-fold cross validation in order to choose the hyperparameter $\lambda$. Once the hyperparameter is fixed, we retrain a model on the 4 folds and evaluate it on the test set. By iterating over the five possible test folds, we report variation in performance with error bars in Figure 3.</p>
<p><strong>Training phase.</strong> The goal of this phase is to learn classifiers $W$ for the visual steps. To that end, we minimize the cost defined in (2) under the ground truth annotations constraints. This is very close to our setting, and in practice we can use exactly the same framework as in problem (13) by simply replacing the constraints coming from the text by the constraints coming from the ground truth annotations.</p>
<p><strong>Testing phase.</strong> At test time, we simply use the classifiers $W$ to perform least-square prediction of $Z_{\text{test}}$ under ordering constraints. Performance are evaluated with the F1 score.</p>
<h4>D.2. Error bars for Frank-Wolfe methods.</h4>
<p>We explain here how we obtained the error bars of Figure 3 in the main paper for the unsupervised approaches. Let us first recall that the Frank-Wolfe algorithm is used to solve a continuous relaxation of problem (13). To obtain back an integer solution, we round the continuous solution using the rounding method described at the end of Section C.2. This rounding procedure is performed at each iteration of the optimization method. When the stopping criterion of the Frank-Wolfe scheme is reached (fixed number of iterations or target sub-optimality in practice), we have as many rounded solutions as number of iterations. Our output integer solution is then the integer point that achieves the lowest objective. Note that we are only guaranteed to diminish objective in the continuous domain and <em>not</em> for the integer points, therefore there are no guarantees that this solution is the last rounded point. In order to illustrate the variation of the performance with respect to the optimization scheme, we defined our error bars as being the</p>
<p><img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>Figure 6: Illustration of our newly collected dataset of instructions videos. Examples of transcribed narrations together with still frames from the corresponding videos are shown for the 5 tasks of the dataset: <em>Repotting a plant</em>, <em>Performing CPR</em>, <em>Jumping cars</em>, <em>Changing a car tire</em> and <em>Making coffee</em>. The dataset contains challenging real-world videos performed by many different people, captured in uncontrolled settings in a variety of outdoor and indoor environments.</p>
<p>interval with bounds determined by the minimal performance and the maximal performance obtained <em>after</em> visiting the best rounded point (the output solution). This notably explains why the error bars of Figure 3 are not necessarily symmetric. Overall, the observed variation is not very important, thus highlighting the stability of the procedure.</p>
<h3>E. Qualitative results</h3>
<p>In Section E.1, we give detailed results of script discovery for the five different tasks. In Section E.2, we present detailed results for the action localization experiment.</p>
<h4>E.1. Script discovery</h4>
<p>Table 4 shows the automatically recovered sequences of steps for the five tasks considered in this work. The results are shown for setting the maximum number of discovered steps, K = {7, 10, 12, 15}. Note how our method automatically selects less than K steps in some cases. These are the automatically chosen k ≤ K steps that are the most salient in the aligned narrations as described in Section 4.1. This is notably the case for the <em>Repotting a plant</em> task. Even for K ≤ 12, the algorithm recovers only 6 steps that match very well the seven ground truth steps for this task. This saliency based task selection is important because it allows for a better precision at high K without lowering much the</p>
<p>recall.
Please note also how the steps and their ordering recovered by our method correspond well to the ground truth steps for each task. For $C P R$, our method recovers fine-grained steps e.g. tilt head, lift chin, which are not included in the main ground truth steps, but nevertheless could be helpful in some situations. For Changing tire, we also recover more detailed actions such as remove jack or put jack. In some cases, our method recovers repeated steps. For example, for $C P R$ our method learns that one has to alternate between giving breath and performing compressions even if this alternation was not annotated in the the ground truth. Or for Jumping Cars our method learns that cables need to be connected twice (to both cars).</p>
<p>These results demonstrate that our method is able to automatically discover meaningful scripts describing very different tasks. The results also show that the constraint of a single script providing an ordering of events is a reasonable prior for a variety of different tasks.</p>
<h2>E.2. Action localization</h2>
<p>Examples of the recovered instruction steps for all five tasks are shown in Figure 7-11. Each row shows one recovered step. For each step, we first show the clustered direct object relations, followed by representative example frames localizing the step in the videos. Correct localizations are shown in green. Some steps are incorrectly localized in some videos (red), but often look visually very similar. Note how our method correctly recovers the main steps of the task and localizes them in the input videos. Those results have been obtained by imposing $K \leq 10$ in our method. The video on the project website illustrates action localization for the five tasks.</p>
<h2>Supplementary References</h2>
<p>[32] V. Chari, S. Lacoste-Julien, I. Laptev, and J. Sivic. On pairwise costs for network flow multi-object tracking. In CVPR, 2015.
[33] S. Lacoste-Julien. Convergence rate of Frank-Wolfe for nonconvex objectives. arXiv preprint, 2016.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">GT (11)</th>
<th style="text-align: center;">$K \leq 7$</th>
<th style="text-align: center;">$K \leq 10$</th>
<th style="text-align: center;">$K \leq 12$</th>
<th style="text-align: center;">$K \leq 15$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">put brake on <br> get tools out <br> start loose</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">get tire <br> loosen nut</td>
<td style="text-align: center;">get tire <br> loosen nut</td>
<td style="text-align: center;">get tire <br> loosen nut <br> lift car</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">put jack</td>
<td style="text-align: center;">put jack</td>
<td style="text-align: center;">put jack</td>
</tr>
<tr>
<td style="text-align: left;">jack car <br> unscrew wheel <br> remove wheel <br> put wheel <br> screw wheel <br> lower car</td>
<td style="text-align: center;">jack car <br> jack car <br> remove nut <br> take wheel <br> take tire <br> put nut <br> lower jack</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">raise vehicle <br> jack car <br> remove nut <br> take wheel <br> take tire <br> put nut <br> lower jack</td>
<td style="text-align: center;">raise vehicle <br> jack car <br> remove nut <br> take wheel <br> take tire <br> put nut <br> lower jack</td>
</tr>
<tr>
<td style="text-align: left;">tight wheel <br> put things back</td>
<td style="text-align: center;">tighten nut</td>
<td style="text-align: center;">tighten nut</td>
<td style="text-align: center;">tighten nut <br> take tire</td>
<td style="text-align: center;">tighten nut <br> take tire</td>
</tr>
<tr>
<td style="text-align: left;">Precision</td>
<td style="text-align: center;">0.85</td>
<td style="text-align: center;">0.9</td>
<td style="text-align: center;">0.83</td>
<td style="text-align: center;">0.71</td>
</tr>
<tr>
<td style="text-align: left;">Recall</td>
<td style="text-align: center;">0.54</td>
<td style="text-align: center;">0.9</td>
<td style="text-align: center;">0.9</td>
<td style="text-align: center;">0.9</td>
</tr>
</tbody>
</table>
<p>(a) Changing a tire</p>
<table>
<thead>
<tr>
<th style="text-align: left;">GT (7)</th>
<th style="text-align: center;">$K \leq 7$</th>
<th style="text-align: center;">$K \leq 10$</th>
<th style="text-align: center;">$K \leq 12$</th>
<th style="text-align: center;">$K \leq 15$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">cover hole</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">take piece <br> keep soil <br> stop soil</td>
</tr>
<tr>
<td style="text-align: left;">take plant <br> put soil <br> loosen root <br> place plant <br> add top</td>
<td style="text-align: center;">take plant <br> use soil <br> loosen soil <br> place plant <br> add soil</td>
<td style="text-align: center;">take plant <br> use soil <br> loosen soil <br> place plant <br> add soil</td>
<td style="text-align: center;">take plant <br> use soil <br> loosen soil <br> place plant <br> add soil</td>
<td style="text-align: center;">take plant <br> use soil <br> loosen soil <br> place plant <br> add soil <br> fill pot <br> get soil <br> give drink</td>
</tr>
<tr>
<td style="text-align: left;">water plant</td>
<td style="text-align: center;">water plant</td>
<td style="text-align: center;">water plant</td>
<td style="text-align: center;">water plant</td>
<td style="text-align: center;">water plant <br> give watering</td>
</tr>
<tr>
<td style="text-align: left;">Precision</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0.54</td>
</tr>
<tr>
<td style="text-align: left;">Recall</td>
<td style="text-align: center;">0.86</td>
<td style="text-align: center;">0.86</td>
<td style="text-align: center;">0.86</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>(b) Making coffee</p>
<table>
<thead>
<tr>
<th style="text-align: left;">GT (7)</th>
<th style="text-align: center;">$K \leq 7$</th>
<th style="text-align: center;">$K \leq 10$</th>
<th style="text-align: center;">$K \leq 12$</th>
<th style="text-align: center;">$K \leq 15$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">open airway <br> check response <br> call 911 <br> check breathing <br> check pulse</td>
<td style="text-align: center;">open airway</td>
<td style="text-align: center;">open airway</td>
<td style="text-align: center;">open airway</td>
<td style="text-align: center;">open airway</td>
</tr>
<tr>
<td style="text-align: left;">give breath <br> give compression</td>
<td style="text-align: center;">tilt head <br> lift chin <br> give breath <br> do compr. <br> open airway</td>
<td style="text-align: center;">put hand <br> tilt head <br> do compr. <br> open airway</td>
<td style="text-align: center;">put hand <br> tilt head <br> do compr. <br> open airway</td>
<td style="text-align: center;">put hand <br> tilt head <br> do compr. <br> open airway</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">do compr.</td>
<td style="text-align: center;">do compr.</td>
<td style="text-align: center;">do compr.</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">give breath</td>
<td style="text-align: center;">give breath</td>
<td style="text-align: center;">give breath</td>
</tr>
<tr>
<td style="text-align: left;">Precision</td>
<td style="text-align: center;">0.5</td>
<td style="text-align: center;">0.4</td>
<td style="text-align: center;">0.4</td>
<td style="text-align: center;">0.33</td>
</tr>
<tr>
<td style="text-align: left;">Recall</td>
<td style="text-align: center;">0.43</td>
<td style="text-align: center;">0.57</td>
<td style="text-align: center;">0.57</td>
<td style="text-align: center;">0.57</td>
</tr>
</tbody>
</table>
<p>(c) Repot a plant
(d) Performing CPR</p>
<table>
<thead>
<tr>
<th style="text-align: left;">GT (12)</th>
<th style="text-align: center;">$K \leq 7$</th>
<th style="text-align: center;">$K \leq 10$</th>
<th style="text-align: center;">$K \leq 12$</th>
<th style="text-align: center;">$K \leq 15$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">get cars <br> open hood</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">connect red $A$</td>
<td style="text-align: center;">connect cable</td>
<td style="text-align: center;">conn. cable</td>
<td style="text-align: center;">attach cab. <br> conn. cable</td>
<td style="text-align: center;">have terminal <br> attach cab. <br> conn. cable</td>
</tr>
<tr>
<td style="text-align: left;">connect red $B$ <br> connect black $A$ <br> connect ground <br> start car $A$ <br> start car $B$</td>
<td style="text-align: center;">charge battery <br> connect end</td>
<td style="text-align: center;">charge batt. <br> conn. end</td>
<td style="text-align: center;">charge batt. <br> conn. end <br> conn. cab. <br> have cab. <br> start car <br> start vehicle <br> start engine</td>
<td style="text-align: center;">charge batt. <br> conn. end <br> conn. cab. <br> have cab. <br> start car <br> start veh. <br> start eng. <br> rem. cable <br> disc. cable</td>
</tr>
<tr>
<td style="text-align: left;">remove ground <br> remove black $A$ <br> remove red $B$ <br> remove red $A$</td>
<td style="text-align: center;">remove cable <br> disconnect cable</td>
<td style="text-align: center;">rem. cable <br> disc. cable</td>
<td style="text-align: center;">rem. cable <br> disc. cable</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">Precision</td>
<td style="text-align: center;">0.83</td>
<td style="text-align: center;">0.83</td>
<td style="text-align: center;">0.72</td>
<td style="text-align: center;">0.69</td>
</tr>
<tr>
<td style="text-align: left;">Recall</td>
<td style="text-align: center;">0.42</td>
<td style="text-align: center;">0.42</td>
<td style="text-align: center;">0.67</td>
<td style="text-align: center;">0.67</td>
</tr>
</tbody>
</table>
<p>(e) Jumping cars</p>
<p>Table 4: Automatically recovered sequences of steps for the five tasks considered in this work. Each recovered step is represented by one of the aligned direct object relations (shown in bold). Note that most of the recovered steps correspond well to the ground truth steps (showed in italic). The results are shown for setting the maximum number of discovered steps, $K={7,10,12,15}$. Note how our method automatically selects less than $K$ steps in some cases. These are the automatically chosen $k \leq K$ steps that are the most salient in the aligned narrations as described in Sec. 4.1.</p>
<p><img alt="img-6.jpeg" src="img-6.jpeg" /></p>
<p>Figure 7: Examples of the recovered instruction steps for the task "Changing the car tire".</p>
<p><img alt="img-7.jpeg" src="img-7.jpeg" /></p>
<p>Figure 8: Qualitative results for the task "Jumping cars".</p>
<p><img alt="img-8.jpeg" src="img-8.jpeg" /></p>
<p>Figure 9: Qualitative results for the task "Repot a plant".</p>
<p><img alt="img-9.jpeg" src="img-9.jpeg" /></p>
<p>Figure 10: Qualitative results for the task "Making coffee".</p>
<p><img alt="img-10.jpeg" src="img-10.jpeg" /></p>
<p>Figure 11: Qualitative results for the task "Performing CPR".</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{11}$ When $R_{s k}=0$, then this constraint does not do anything. When $R_{s k}=1$ (i.e. the text token $s$ was assigned to the main action $k$ ), then the constraint enforces that $\sum_{t \in A_{s}} Z_{t k} \geq 1$, where $A_{s}$ represents which video frames are temporally close to the caption time of the text token $s$. It thus then enforces that at least one temporally close video frame is assigned to the main action $k$.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref5:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref6:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:1">
<p>${ }^{9}$ We stress here that we do not claim that our formulation of the multiple sequence alignment (MSA) problem as a quadratic program outperforms the state-of-the-art computational biology heuristics for their MSA problems arising in biology. We report our observations on application of multiple sequence alignment to our application, which might have a structure for which these heuristics are not as appropriate.
${ }^{10}$ Code available at http://sourceforge.net/projects/ poamsa/.&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>