<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-1738 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-1738</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-1738</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-31.html">extraction-schema-31</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <p><strong>Paper ID:</strong> paper-a2765b24eb55aba8e9bd4ee4e94fa5c8762c86e2</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/a2765b24eb55aba8e9bd4ee4e94fa5c8762c86e2" target="_blank">An Artificial Life Simulation Library Based on Genetic Algorithm, 3-Character Genetic Code and Biological Hierarchy</a></p>
                <p><strong>Paper Venue:</strong> arXiv.org</p>
                <p><strong>Paper TL;DR:</strong> The design of a Python library for artificial life simulation, Digital Organism Simulation Environment (DOSE), based on GA and biological hierarchy starting from genetic sequence to population is described.</p>
                <p><strong>Paper Abstract:</strong> Genetic algorithm (GA) is inspired by biological evolution of genetic organisms by optimizing the genotypic combinations encoded within each individual with the help of evolutionary operators, suggesting that GA may be a suitable model for studying real-life evolutionary processes. This paper describes the design of a Python library for artificial life simulation, Digital Organism Simulation Environment (DOSE), based on GA and biological hierarchy starting from genetic sequence to population. A 3-character instruction set that does not take any operand is introduced as genetic code for digital organism. This mimics the 3-nucleotide codon structure in naturally occurring DNA. In addition, the context of a 3-dimensional world composing of ecological cells is introduced to simulate a physical ecosystem. Using DOSE, an experiment to examine the changes in genetic sequences with respect to mutation rates is presented.</p>
                <p><strong>Cost:</strong> 0.014</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e1738.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e1738.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>DOSE</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Digital Organism Simulation Environment</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A Python library / artificial-life simulation environment that embeds a genetic-algorithm framework, a 3D cellular-automaton world, and an executable 3-character genetic language (Ragaraja) to evolve digital organisms whose genomes are executable programs.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>DOSE (Digital Organism Simulation Environment)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>DOSE is a hierarchical GA-based artificial-life simulator implemented as a Python library. It composes World -> Population -> Organism -> Genome (Chromosome) layers. Genomes are sequences of 3-character Ragaraja instructions (executable code) that are interpreted by a Ragaraja interpreter (four tapes + 99 registers). Evolutionary operations available in the framework include user-definable mating (Population.mating) which can call a crossover helper from Lim et al. (2010), and mutation schemes triggered per generation via Organism.mutation_scheme with helper functions Chromosome.rmutate (random point mutation across the genome) and Chromosome.kmutate (mutate a specific genome segment). The environment supports spatial ecology, local/global ecological regulation, execution of genomes to produce input/output that affects local ecological cells, and user-defined fitness evaluation.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>executable programs / code (Ragaraja instruction sequences)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Supported via Population.mating; paper references a crossover helper function in Lim et al. (2010) but gives no implementation details in this paper. The mating entry point allows user-defined mate choice and reproduction schemes and can invoke the crossover helper from the underlying GA framework; however the specific mechanism (one-point, two-point, uniform, etc.) is not described here (null if no explicit mechanism documented).</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>User-triggered per generation via Organism.mutation_scheme. Helper functions: Chromosome.rmutate — random point mutation throughout the genome; Chromosome.kmutate — targeted/specific mutation within a defined genome segment. In the experiment presented, a random point mutation operator was applied across the entire genome at fixed per-nucleotide mutation rates (2%, 3%, 4%, 5%).</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td>Genotypic novelty measured as Hamming distance between genetic sequences (measured at intervals of 10 generations, computed relative to generation 10). Cytoplasmic state (tape values) used as a phenotypic/behavioral proxy (average cytoplasmic value across organisms).</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td>Hamming-distance results: sequence divergence (Hamming distance) was measured across generations for mutation rates 2%, 3%, 4%, and 5%. The paper reports that Hamming distances are not proportional to mutation rates; distances for the same mutation rate across two independent populations are highly correlated (r > 0.999). Specifically, no significant difference in average sequence divergence was observed between 2% and 3% mutation rates, whereas a noticeable difference appeared between 3% and 4%. Exact Hamming-distance counts are not reported in the paper.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>No quantitative executability metric reported. Executability is operationalized qualitatively: genomes are executed by the Ragaraja interpreter (Turing-complete) each generation and outputs are consumed by user-defined fitness functions; but the paper does not report measures such as fraction of genomes that halt, fraction producing valid output, or functional correctness rates.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Genotypic diversity via Hamming distance; phenotypic/behavioral proxy via average cytoplasmic value across organisms in a population over generations.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td>Cytoplasmic results: using a NucleotideBF subset, the population-average cytoplasmic value approached zero after ~80 generations and remained centered at zero for the remainder of the simulation (interpreted as balance between increment and decrement operators). Inter-population correlation metrics: an overall paired-generation correlation coefficient between Population 1 and Population 2 cytoplasmic averages was reported as r^2 = 0.76, but when examining near-zero clustering the correlation was r^2 = 0.003, indicating near-independence in that region. No other numeric diversity summaries (e.g., entropy or niche counts) were provided.</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Artificial life / digital organism evolution (evolution of executable genomes / program-like genomes). Experiment: effects of point-mutation rates on sequence divergence and cytoplasmic properties.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Comparisons are intra-system across mutation rates (2%, 3%, 4%, 5%) and between two independently seeded populations; no external algorithmic baselines are used.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>DOSE executes genomes as program-like sequences (Ragaraja); mutation operators (random point mutations via Chromosome.rmutate) applied at several rates produced sequence divergence patterns that were not strictly proportional to mutation rate. High correlation of divergence trajectories within the same mutation rate across independent populations (r > 0.999) suggests deterministic/stochastic structure; observed plateau/threshold behaviour where divergence did not differ between 2% and 3% but diverged between 3% and 4%, consistent with biological observations (possible repeated mutation at same sites). Phenotypic proxy (average cytoplasmic value) converged to zero due to symmetric increment/decrement operators and showed little coordinated behavior across populations in the near-zero regime (r^2 = 0.003). The paper documents mutation and mating hooks but does not quantify crossover effects or executability success rates.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'An Artificial Life Simulation Library Based on Genetic Algorithm, 3-Character Genetic Code and Biological Hierarchy', 'publication_date_yy_mm': '2012-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1738.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e1738.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Ragaraja</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Ragaraja 3-character instruction language</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A 3-character, Brainfuck-derived esoteric programming language (instruction alphabet of three-digit numeric tokens) used in DOSE to encode executable genomes; designed to mimic 3-nucleotide codons and produce Turing-complete executable DNA for digital organisms.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Ragaraja instruction set (Version 1)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Ragaraja maps each 3-character numeric instruction (000–999; 347 defined in v1) to an atomic operation on four tapes and 99 registers; it includes the Brainfuck-equivalent core, arithmetic and list/tape-manipulation primitives, random-choice instructions, and register-store/load operations. In DOSE, genomes are sequences of Ragaraja instructions and are interpreted each generation; Ragaraja is described as Turing-complete by virtue of including Brainfuck-like operations.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>executable programs / code (numeric instruction sequences)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Mutations are applied at the nucleotide/instruction level (random point mutation replacing one 3-character instruction with another). The DOSE helper mutation functions operate on Ragaraja-encoded chromosomes: Chromosome.rmutate (random throughout genome) and Chromosome.kmutate (within a segment). Experiment used point-mutation at 2–5% per-instruction rates.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td>No specific novelty metric internal to Ragaraja; novelty in experiments assessed at genotypic level (Hamming distance) and phenotypic proxy (cytoplasm).</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Ragaraja is Turing-complete (claimed) and genomes are executed by the interpreter; the paper does not report quantitative metrics of executable-success (e.g., halting fraction).</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Language for encoding executable genomes in artificial-life / evolutionary computation experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Compared conceptually to Brainfuck (inheritance) and to nucleotide coding paradigms (NucleotideBF subset).</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Ragaraja provides a compact, codon-like instruction alphabet for executable genomes enabling direct execution of evolved programs; it supports many atomic operations and randomness primitives, but the paper does not evaluate how crossover or mutation over Ragaraja programs affects functional behavior beyond sequence-divergence and cytoplasmic statistics.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'An Artificial Life Simulation Library Based on Genetic Algorithm, 3-Character Genetic Code and Biological Hierarchy', 'publication_date_yy_mm': '2012-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1738.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e1738.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Lim GA framework</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>A genetic algorithm framework grounded in biology (Lim et al., 2010)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A Python GA framework providing hierarchical biological abstractions (gene -> chromosome -> genome/organism -> population) used as the base of DOSE, offering mutation helpers and a crossover helper callable from Population.mating.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>A genetic algorithm framework grounded in biology</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Lim et al. (2010) GA framework (biologically grounded GA)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>An earlier Python GA framework that formalizes biological hierarchy (chromosome, genome, organism, population) and provides helper functions for mutation and crossover. DOSE builds on this framework to implement user-callable mutation schemes (Chromosome.rmutate and Chromosome.kmutate) and a crossover helper referenced by Population.mating.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>genomic strings / encoded solutions (here: Ragaraja instruction sequences when used in DOSE)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Referenced as a helper function available to Population.mating; the paper does not reproduce the implementation details; therefore the actual crossover mechanism (one-point, multi-point, uniform, etc.) is not specified in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Provides helper mutation primitives used by DOSE: Chromosome.rmutate (random mutation across genome) and Chromosome.kmutate (targeted mutation inside a specified segment). DOSE uses these helpers to implement per-generation mutation schemes.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>General GA framework applied within DOSE to evolve executable genomes.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Not compared against other GA frameworks in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Paper uses the Lim et al. GA framework as the underlying evolutionary machinery in DOSE and points to its crossover helper for mating, but the current study focuses on mutation experiments and does not present empirical results isolating crossover behavior from Lim et al.'s implementation.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'An Artificial Life Simulation Library Based on Genetic Algorithm, 3-Character Genetic Code and Biological Hierarchy', 'publication_date_yy_mm': '2012-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1738.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e1738.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>NucleotideBF</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>NucleotideBF (subset of Ragaraja mapping to IUPAC nucleotide codes)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A subset mapping of Ragaraja instructions to IUPAC nucleotide codes (G,C,A,T and ambiguity codes) to simulate naturally occurring DNA behavior by mapping nucleotides to Brainfuck-like operations (e.g., G=move right, C=move left, A=increment, T=decrement).</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>NucleotideBF (Ragaraja v0.1 subset)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>A predefined subset of Ragaraja (version 0.1) called NucleotideBF that maps nucleotide symbols to a reduced instruction set to simulate DNA-like sequences. In DOSE experiments, NucleotideBF (only increment/decrement and pointer moves) was used to study cytoplasmic value dynamics under random mutation.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>genomic sequences represented as nucleotides mapped to small Brainfuck-like instruction set (code/programs as text-like nucleotide strings)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Same mutation primitives apply (random point mutation at nucleotide/instruction level); the experiment applied point mutations at rates 2%-5% across the genome using the random mutation operator.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td>Phenotypic proxy: average cytoplasmic value across organisms used to assess emergent behaviour; no specialized novelty metric reported.</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Phenotypic diversity approximated by distribution / variance of cytoplasmic values across organisms; not reported as explicit diversity index.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td>Using NucleotideBF, the population-average cytoplasmic value approached and fluctuated around zero after ~80 generations (expected because only symmetric increment/decrement operators were present). No other numeric diversity statistics reported.</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Simplified DNA-like instruction subset for artificial-life experiments; used as a behavioral probe rather than a production-oriented program synthesis benchmark.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Compared across mutation rates and between two independent populations in the paper's experiment.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>When evolving NucleotideBF genomes under random point mutation, cytoplasmic tape statistics converged to zero mean due to symmetric operations; populations evolved independently (low inter-population correlation in near-zero regime). The setup provides a simplified testbed for exploring effects of mutation on code-like genomes but does not evaluate crossover or functional program emergence.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'An Artificial Life Simulation Library Based on Genetic Algorithm, 3-Character Genetic Code and Biological Hierarchy', 'publication_date_yy_mm': '2012-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>A genetic algorithm framework grounded in biology <em>(Rating: 2)</em></li>
                <li>Avida: A software platform for research in computational evolutionary biology <em>(Rating: 2)</em></li>
                <li>ALF - a simulation framework for genome evolution <em>(Rating: 2)</em></li>
                <li>The Microbial Genetic Algorithm <em>(Rating: 1)</em></li>
                <li>An approach to the synthesis of life <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-1738",
    "paper_id": "paper-a2765b24eb55aba8e9bd4ee4e94fa5c8762c86e2",
    "extraction_schema_id": "extraction-schema-31",
    "extracted_data": [
        {
            "name_short": "DOSE",
            "name_full": "Digital Organism Simulation Environment",
            "brief_description": "A Python library / artificial-life simulation environment that embeds a genetic-algorithm framework, a 3D cellular-automaton world, and an executable 3-character genetic language (Ragaraja) to evolve digital organisms whose genomes are executable programs.",
            "citation_title": "here",
            "mention_or_use": "use",
            "system_name": "DOSE (Digital Organism Simulation Environment)",
            "system_description": "DOSE is a hierarchical GA-based artificial-life simulator implemented as a Python library. It composes World -&gt; Population -&gt; Organism -&gt; Genome (Chromosome) layers. Genomes are sequences of 3-character Ragaraja instructions (executable code) that are interpreted by a Ragaraja interpreter (four tapes + 99 registers). Evolutionary operations available in the framework include user-definable mating (Population.mating) which can call a crossover helper from Lim et al. (2010), and mutation schemes triggered per generation via Organism.mutation_scheme with helper functions Chromosome.rmutate (random point mutation across the genome) and Chromosome.kmutate (mutate a specific genome segment). The environment supports spatial ecology, local/global ecological regulation, execution of genomes to produce input/output that affects local ecological cells, and user-defined fitness evaluation.",
            "input_type": "executable programs / code (Ragaraja instruction sequences)",
            "crossover_operation": "Supported via Population.mating; paper references a crossover helper function in Lim et al. (2010) but gives no implementation details in this paper. The mating entry point allows user-defined mate choice and reproduction schemes and can invoke the crossover helper from the underlying GA framework; however the specific mechanism (one-point, two-point, uniform, etc.) is not described here (null if no explicit mechanism documented).",
            "mutation_operation": "User-triggered per generation via Organism.mutation_scheme. Helper functions: Chromosome.rmutate — random point mutation throughout the genome; Chromosome.kmutate — targeted/specific mutation within a defined genome segment. In the experiment presented, a random point mutation operator was applied across the entire genome at fixed per-nucleotide mutation rates (2%, 3%, 4%, 5%).",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": "Genotypic novelty measured as Hamming distance between genetic sequences (measured at intervals of 10 generations, computed relative to generation 10). Cytoplasmic state (tape values) used as a phenotypic/behavioral proxy (average cytoplasmic value across organisms).",
            "novelty_results": "Hamming-distance results: sequence divergence (Hamming distance) was measured across generations for mutation rates 2%, 3%, 4%, and 5%. The paper reports that Hamming distances are not proportional to mutation rates; distances for the same mutation rate across two independent populations are highly correlated (r &gt; 0.999). Specifically, no significant difference in average sequence divergence was observed between 2% and 3% mutation rates, whereas a noticeable difference appeared between 3% and 4%. Exact Hamming-distance counts are not reported in the paper.",
            "executability_metric": "No quantitative executability metric reported. Executability is operationalized qualitatively: genomes are executed by the Ragaraja interpreter (Turing-complete) each generation and outputs are consumed by user-defined fitness functions; but the paper does not report measures such as fraction of genomes that halt, fraction producing valid output, or functional correctness rates.",
            "executability_results": null,
            "diversity_metric": "Genotypic diversity via Hamming distance; phenotypic/behavioral proxy via average cytoplasmic value across organisms in a population over generations.",
            "diversity_results": "Cytoplasmic results: using a NucleotideBF subset, the population-average cytoplasmic value approached zero after ~80 generations and remained centered at zero for the remainder of the simulation (interpreted as balance between increment and decrement operators). Inter-population correlation metrics: an overall paired-generation correlation coefficient between Population 1 and Population 2 cytoplasmic averages was reported as r^2 = 0.76, but when examining near-zero clustering the correlation was r^2 = 0.003, indicating near-independence in that region. No other numeric diversity summaries (e.g., entropy or niche counts) were provided.",
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Artificial life / digital organism evolution (evolution of executable genomes / program-like genomes). Experiment: effects of point-mutation rates on sequence divergence and cytoplasmic properties.",
            "comparison_baseline": "Comparisons are intra-system across mutation rates (2%, 3%, 4%, 5%) and between two independently seeded populations; no external algorithmic baselines are used.",
            "key_findings": "DOSE executes genomes as program-like sequences (Ragaraja); mutation operators (random point mutations via Chromosome.rmutate) applied at several rates produced sequence divergence patterns that were not strictly proportional to mutation rate. High correlation of divergence trajectories within the same mutation rate across independent populations (r &gt; 0.999) suggests deterministic/stochastic structure; observed plateau/threshold behaviour where divergence did not differ between 2% and 3% but diverged between 3% and 4%, consistent with biological observations (possible repeated mutation at same sites). Phenotypic proxy (average cytoplasmic value) converged to zero due to symmetric increment/decrement operators and showed little coordinated behavior across populations in the near-zero regime (r^2 = 0.003). The paper documents mutation and mating hooks but does not quantify crossover effects or executability success rates.",
            "uuid": "e1738.0",
            "source_info": {
                "paper_title": "An Artificial Life Simulation Library Based on Genetic Algorithm, 3-Character Genetic Code and Biological Hierarchy",
                "publication_date_yy_mm": "2012-10"
            }
        },
        {
            "name_short": "Ragaraja",
            "name_full": "Ragaraja 3-character instruction language",
            "brief_description": "A 3-character, Brainfuck-derived esoteric programming language (instruction alphabet of three-digit numeric tokens) used in DOSE to encode executable genomes; designed to mimic 3-nucleotide codons and produce Turing-complete executable DNA for digital organisms.",
            "citation_title": "here",
            "mention_or_use": "use",
            "system_name": "Ragaraja instruction set (Version 1)",
            "system_description": "Ragaraja maps each 3-character numeric instruction (000–999; 347 defined in v1) to an atomic operation on four tapes and 99 registers; it includes the Brainfuck-equivalent core, arithmetic and list/tape-manipulation primitives, random-choice instructions, and register-store/load operations. In DOSE, genomes are sequences of Ragaraja instructions and are interpreted each generation; Ragaraja is described as Turing-complete by virtue of including Brainfuck-like operations.",
            "input_type": "executable programs / code (numeric instruction sequences)",
            "crossover_operation": null,
            "mutation_operation": "Mutations are applied at the nucleotide/instruction level (random point mutation replacing one 3-character instruction with another). The DOSE helper mutation functions operate on Ragaraja-encoded chromosomes: Chromosome.rmutate (random throughout genome) and Chromosome.kmutate (within a segment). Experiment used point-mutation at 2–5% per-instruction rates.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": "No specific novelty metric internal to Ragaraja; novelty in experiments assessed at genotypic level (Hamming distance) and phenotypic proxy (cytoplasm).",
            "novelty_results": null,
            "executability_metric": "Ragaraja is Turing-complete (claimed) and genomes are executed by the interpreter; the paper does not report quantitative metrics of executable-success (e.g., halting fraction).",
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Language for encoding executable genomes in artificial-life / evolutionary computation experiments.",
            "comparison_baseline": "Compared conceptually to Brainfuck (inheritance) and to nucleotide coding paradigms (NucleotideBF subset).",
            "key_findings": "Ragaraja provides a compact, codon-like instruction alphabet for executable genomes enabling direct execution of evolved programs; it supports many atomic operations and randomness primitives, but the paper does not evaluate how crossover or mutation over Ragaraja programs affects functional behavior beyond sequence-divergence and cytoplasmic statistics.",
            "uuid": "e1738.1",
            "source_info": {
                "paper_title": "An Artificial Life Simulation Library Based on Genetic Algorithm, 3-Character Genetic Code and Biological Hierarchy",
                "publication_date_yy_mm": "2012-10"
            }
        },
        {
            "name_short": "Lim GA framework",
            "name_full": "A genetic algorithm framework grounded in biology (Lim et al., 2010)",
            "brief_description": "A Python GA framework providing hierarchical biological abstractions (gene -&gt; chromosome -&gt; genome/organism -&gt; population) used as the base of DOSE, offering mutation helpers and a crossover helper callable from Population.mating.",
            "citation_title": "A genetic algorithm framework grounded in biology",
            "mention_or_use": "use",
            "system_name": "Lim et al. (2010) GA framework (biologically grounded GA)",
            "system_description": "An earlier Python GA framework that formalizes biological hierarchy (chromosome, genome, organism, population) and provides helper functions for mutation and crossover. DOSE builds on this framework to implement user-callable mutation schemes (Chromosome.rmutate and Chromosome.kmutate) and a crossover helper referenced by Population.mating.",
            "input_type": "genomic strings / encoded solutions (here: Ragaraja instruction sequences when used in DOSE)",
            "crossover_operation": "Referenced as a helper function available to Population.mating; the paper does not reproduce the implementation details; therefore the actual crossover mechanism (one-point, multi-point, uniform, etc.) is not specified in this paper.",
            "mutation_operation": "Provides helper mutation primitives used by DOSE: Chromosome.rmutate (random mutation across genome) and Chromosome.kmutate (targeted mutation inside a specified segment). DOSE uses these helpers to implement per-generation mutation schemes.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "General GA framework applied within DOSE to evolve executable genomes.",
            "comparison_baseline": "Not compared against other GA frameworks in this paper.",
            "key_findings": "Paper uses the Lim et al. GA framework as the underlying evolutionary machinery in DOSE and points to its crossover helper for mating, but the current study focuses on mutation experiments and does not present empirical results isolating crossover behavior from Lim et al.'s implementation.",
            "uuid": "e1738.2",
            "source_info": {
                "paper_title": "An Artificial Life Simulation Library Based on Genetic Algorithm, 3-Character Genetic Code and Biological Hierarchy",
                "publication_date_yy_mm": "2012-10"
            }
        },
        {
            "name_short": "NucleotideBF",
            "name_full": "NucleotideBF (subset of Ragaraja mapping to IUPAC nucleotide codes)",
            "brief_description": "A subset mapping of Ragaraja instructions to IUPAC nucleotide codes (G,C,A,T and ambiguity codes) to simulate naturally occurring DNA behavior by mapping nucleotides to Brainfuck-like operations (e.g., G=move right, C=move left, A=increment, T=decrement).",
            "citation_title": "",
            "mention_or_use": "use",
            "system_name": "NucleotideBF (Ragaraja v0.1 subset)",
            "system_description": "A predefined subset of Ragaraja (version 0.1) called NucleotideBF that maps nucleotide symbols to a reduced instruction set to simulate DNA-like sequences. In DOSE experiments, NucleotideBF (only increment/decrement and pointer moves) was used to study cytoplasmic value dynamics under random mutation.",
            "input_type": "genomic sequences represented as nucleotides mapped to small Brainfuck-like instruction set (code/programs as text-like nucleotide strings)",
            "crossover_operation": null,
            "mutation_operation": "Same mutation primitives apply (random point mutation at nucleotide/instruction level); the experiment applied point mutations at rates 2%-5% across the genome using the random mutation operator.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": "Phenotypic proxy: average cytoplasmic value across organisms used to assess emergent behaviour; no specialized novelty metric reported.",
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": "Phenotypic diversity approximated by distribution / variance of cytoplasmic values across organisms; not reported as explicit diversity index.",
            "diversity_results": "Using NucleotideBF, the population-average cytoplasmic value approached and fluctuated around zero after ~80 generations (expected because only symmetric increment/decrement operators were present). No other numeric diversity statistics reported.",
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Simplified DNA-like instruction subset for artificial-life experiments; used as a behavioral probe rather than a production-oriented program synthesis benchmark.",
            "comparison_baseline": "Compared across mutation rates and between two independent populations in the paper's experiment.",
            "key_findings": "When evolving NucleotideBF genomes under random point mutation, cytoplasmic tape statistics converged to zero mean due to symmetric operations; populations evolved independently (low inter-population correlation in near-zero regime). The setup provides a simplified testbed for exploring effects of mutation on code-like genomes but does not evaluate crossover or functional program emergence.",
            "uuid": "e1738.3",
            "source_info": {
                "paper_title": "An Artificial Life Simulation Library Based on Genetic Algorithm, 3-Character Genetic Code and Biological Hierarchy",
                "publication_date_yy_mm": "2012-10"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "A genetic algorithm framework grounded in biology",
            "rating": 2
        },
        {
            "paper_title": "Avida: A software platform for research in computational evolutionary biology",
            "rating": 2
        },
        {
            "paper_title": "ALF - a simulation framework for genome evolution",
            "rating": 2
        },
        {
            "paper_title": "The Microbial Genetic Algorithm",
            "rating": 1
        },
        {
            "paper_title": "An approach to the synthesis of life",
            "rating": 1
        }
    ],
    "cost": 0.01429025,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>An Artificial Life Simulation Library Based on Genetic Algorithm, 3Character Genetic Code and Biological Hierarchy</h1>
<p>Maurice HT Ling<br>Department of Mathematics and Statistics<br>South Dakota State University, USA<br>Department of Zoology<br>The University of Melbourne, Australia<br>mauriceling@acm.org</p>
<h4>Abstract</h4>
<p>Genetic algorithm (GA) is inspired by biological evolution of genetic organisms by optimizing the genotypic combinations encoded within each individual with the help of evolutionary operators, suggesting that GA may be a suitable model for studying real-life evolutionary processes. This paper describes the design of a Python library for artificial life simulation, Digital Organism Simulation Environment (DOSE), based on GA and biological hierarchy starting from genetic sequence to population. A 3-character instruction set that does not take any operand is introduced as genetic code for digital organism. This mimics the 3-nucleotide codon structure in naturally occurring DNA. In addition, the context of a 3dimensional world composing of ecological cells is introduced to simulate a physical ecosystem. Using DOSE, an experiment to examine the changes in genetic sequences with respect to mutation rates is presented.</p>
<p>Keywords: Genetic algorithm, Artificial life, Digital organism, Simulation environment</p>
<h2>1. Introduction</h2>
<p>Life can be viewed as an optimization to the surrounding environment. The atomic unit for life is a cell. Central to a cell is the genetic code, which can be visualized as a complex set of instructions for the cell to interact with the environment. A large number of biological research into evolution had demonstrated that mutation or changes in the genetic code occurs as the organism in question adapts to a new environment (Cooper et al., 2008) or gains new properties (Goh et al., 2012; How et al., 2012). These may include resistance to drugs and medical treatments (Bibbal et al., 2009), or adaptation to different chemicals (Lee et al., 2012) and temperatures (Tosun and Gonul, 2005). These have inspired a class of heuristics known as genetic algorithms (GA).</p>
<p>GA is where the solution of a problem is encoded into a string (Engelbrecht, 2007), known as a chromosome. These are operated on, using biologically equivalent operations, such as mutations and translocations. A cell can have one or more chromosomes, forming a genome. The process of mating in sexual organisms is then an assortment and combination of the genetic information in the chromosome to form a new generation. This is known as the law of independent assortment or the inheritance law in classical Mendelian genetics. GA had</p>
<p>been used successfully in a number of applications (see Shiekh et al. (2008) for a review), including simulation of evolutionary processes of biological genomes (Dalquen et al., 2011).</p>
<p>The biggest issue in studying evolution is time. The generation time for most multicellular organisms can range from days (such as insects) to years (such as humans). Even using fastgrowing bacterium, such as Escherichia coli, only a small number of generations can be studied in a day. Recent publications suggest about 7 generations of Escherichia coli can be achieved in standard laboratory conditions (Goh et al., 2012; Lee et al., 2012). On the other hand, modern computers are able to simulate thousands of generations within hours. Hence, there is a significant time advantage in studying evolutionary processes in silico.</p>
<p>Christopher Langton (1986) had conceptualized that by casting chemical reactions, reactants, and products into computable operations, operands, and outputs respectively, it may be possible to simulate artificial life (organisms in the digital world, or digital organisms) as cellular automata "living" on artificial chemistries. Thus, the field of artificial life (ALife) is created and had been used in many different domains (Ward et al., 2011; Kim and Cho, 2006). In the field of biology, Bersini (2009) argued that artificial life and theoretical biology shared many common grounds and presented GA as an important model to bridge the two fields. GA was used to study microbial genetics and evolution (Harvey, 2011). This corroborates another study arguing that evolution by natural selection is the algorithm of biological evolution (Watson, 2012).</p>
<p>A number of ALife simulators had been developed over the years (Bornhofen and Lattard, 2006; Komosinski and Adamatzky, 2009). Common ALife simulators include Tierra (Ray, 1992), Echo (Holland, 1992), Polyworld (Yaeger, 1994), Framesticks (Komosinski, and Ulatowski, 1999), Avida (Ofria and Wilke, 2004), and EcoSim (Gras et al., 2009). Recently, a Python GA framework conforming to biological hierarchy starting from gene to chromosome to genome (as organism) to population had been developed (Lim et al., 2010), which may help interpreting GA results to biological context.</p>
<p>In this study, the GA framework (Lim et al., 2010) is expanded into a digital organism simulation environment (DOSE) by formalizing a 3-character genetic language to correspond the codon (which comprises of 3 nucleotides) in naturally occurring DNA and incorporating a 3-dimensional "world". The organization of this paper is as follows: Section 2 presents an architectural description of DOSE and its biological context. Section 3 discusses the artificial chemistry of DOSE. Section 4 presents two experiments using DOSE to illustrate its use. Section 5 concludes this paper by discussion on the strengths and limitations of DOSE and its future work.</p>
<h1>2. DOSE Architecture</h1>
<p>DOSE is based on the hierarchical structure of Lim et al. (2010) and designed as a library for importation into a simulation driver program. Data propagates from the world, at the highest level, to the chromosome in each organism at the lowest level where the genomic instructions are interpreted and the results propagates back to the world via organism and population layers (Figure 1). Another example of an ALife simulator that uses a hierarchical architecture is that of Curran and O'Riordan (2003).</p>
<p>DOSE comprises of 3 distinct components - a GA framework (Lim et al., 2010) providing for chromosome, genome, organism and population hierarchy, a 3-dimensional world in which the population exist within, and a set of 3-character known as Ragaraja instruction set which acts as genetic code and an interpreter to execute Ragaraja instruction. Hence, at the core of DOSE is executable DNA, which is a common design, used in a number of ALife simulators including Avida (Ofria and Wilke, 2004).
<img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1. Architecture of DOSE. The yellow boxes represent the entities while the green boxes represent user-defined functions as point of control that regulates various aspects of the digital organism and the ecology in which the organisms are in. Table 1 provides a summary of the user-defined functions and examples of its use.</p>
<p>In the GA framework (Lim et al., 2010), the most important object is an Organism. The status of an organism is logged within its status dictionary and consists of one chromosome as genome. It is not essential for an organism to have a genome. In the case of a genome-less organism, the fitness function, provided by the user, will evaluate the fitness of the organism based on its status. In an organism with a genome, the user can provide a mutation scheme that will be activated once per generation by default. The concept of an organism is unicellular. A population can simulate a multicellular organism. At the population level, the user can provide a number of functions, such as pre-population control, to manage the population before mating; mating scheme, for mate choices and reproduction; post-</p>
<p>population control, to manage the population after mating; and generational events, as a catch-all for any other events defined by the user. For example, one mutational event per generation default can be over-rode at this step by calling Organism.mutation_scheme function once or more times. At each generation, the user can define a report function to report the fitness and conditions of the population.</p>
<p>Naturally occurring DNA comprises of 4 nucleotides - adenine, thymine, guanine, and cytosine - commonly abbreviated as "A", "T", "G", and "C" respectively. A protein chain is made up of 20 possible amino acids. Using only 4 nucleotides to code for 20 possible amino acids, the nucleotides are read in triplets (known as codon) which results in $64\left(4^{3}\right)$ different codons. The resultant protein chain will fold into a 3-dimensional structure, known as a tertiary structure, and may bind with other protein chain to form a quaternary structure. These structures determine the activity of the proteins. The site of activity is known as a protein domain. Using these biological concepts as basis, Ragaraja ${ }^{1}$ is an esoteric programming language comprising of a set of 3-character instructions to mimic a codon. As a derivative of BrainFuck, Ragaraja uses 3 numbers as an instruction instead of symbols of alphabets. This simplified the implementation of a mutation scheme. Conceptually, a Ragaraja-encoded genome may be visualized as having 10 nucleotides instead of 4 . Thus, there are a total of 1000 possible instructions in Rajaraga but only 347 are defined and used in this current version, Version 1 (see Appendix A for description of each instruction). In addition, all instruction are atomic and do not take on any operand which mimics natural DNA. However, there is no equivalence of a 3-dimensional protein structure in Ragaraja. Despite so, each Ragaraja instruction is an operation and in biological terms, an operation can be deemed as a protein domain. Hence, it can be seen that protein domains are encoded directly in the genome of DOSE organism and there is a possible to define up to 1000 protein domains in the current 3 number encoding.
<img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2. Conceptual scheme of a Turing machine. The transition function can be visualized as the function to be computed or a set of rules for execution. Adapted from (Pereira et al., 2010).</p>
<p>BrainFuck is a Turing complete language (Kohler et al., 2005; Ling, 2010a); thus, able to implement any computable functions. By extension, a Turing machine is a machine capable</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>of performing any computable functions. It had been suggested that Turing complete language and a Turing machine are essential for ALife simulation (Langton, 1986). Rajaraga includes the 7 computing operations of BrainFuck in its definition. Therefore, Rajaraga is a Turing complete language by virtue of extension.</p>
<p>One of the most enduring images of a Turing machine (Figure 2) is a virtually infinite tape with a set of rules to be executed based on the information on the location of the read/write head on the tape (Pereira et al., 2010). Ragaraja interpreter uses 4 tapes - a source/instruction tape to contain the operations to be executed, an event tape to represent the theoretically infinite tape where computations are carried out, an input tape to fed input into the system, and an output tape to collect any output from the execution. In addition, Ragaraja interpreter defined a set of 99 general-purpose registers.</p>
<p>Putting into biological context, the source/instruction tape will be equivalent to the genome. The event tape will be similar to the cytoplasm of a cell where all reactions take place. The set of 99 registers may be used to simulate the presence of compartments within the cell, such as organelles. However, these registers are not available for fitness evaluation. The input and output tapes may collectively represent the extracellular matrix of the cell. More specifically, the input and output tapes can represent the endocytotic (molecules taken into a cell) and secreted components respectively. In the context of DOSE, each genome is sent for execution and the results are evaluated by user-defined fitness function per generation or time lapse.</p>
<p>The concept of a world is defined as a 3-dimensional cellular automaton model. Therefore, each non-edged ecological cell has 26 neighbouring ecological cells - 6 full-face contact adjacent ecological cells (front, back, left, right, top, and bottom), 8 diagonal edge contact ecological cells (top-front, top-back, top-left, top-right, bottom-front, bottom-back, bottomleft, and bottom-right), and 12 diagonal non-edge contact ecological cells. The term "ecological cell" is used to describe each cell in this 3-dimensional cellular automation world to prevent confusion from a "biological cell". Each organism is mapped onto an ecological cell and is aware of its location in the ecosystem. Thus, each cell can have one or more organisms. As a result, a population of organisms can occupy one or more ecological cells. Although mating should only occur within an ecological cell, there is no restriction as cross-cell mating can be defined in the population mating (Population.mating function) scheme. Each ecological cell has a set of uniformed local conditions and a collection of ecological cells forms an ecosystem.</p>
<p>On the world-scale, the ecosystem is controlled or regulated by user-defined ecological controls. The entry point of these controls is World.ecoregulate function where the user can define one or more controlling functions, depending on the experiment. The local conditions of each ecological cell are determined by the ecosystem and the input/output of each organism within the cell. Local conditions of each ecological cell can affect the ecosystem at large. The role of World.update_ecology function, given by the user, includes normalizing the local ecological cell condition from the input/output of each organism within the cell and reflecting these changes to the ecosystem. As the ecosystem is not an entity but a collection of ecological cells, the World.update_ecology function acts to radiate local conditions to adjacent or nearby cells. For example, a user can use this function to define chemical events</p>
<p>such as pheromone diffusion or heat radiation from a local ecological cell. Conversely, the ecosystem can affect the local condition and such effect is defined by World.update_local function, which is given by the user. A common scenario for this use is temperature gradients across the world. World.update_local function may also be used to trigger regional mutation events in the organisms.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Functions</th>
<th style="text-align: center;">Usage</th>
<th style="text-align: center;">Examples of Use</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">O.fitness</td>
<td style="text-align: center;">Calculates the fitness of the organism and returns a fitness score.</td>
<td style="text-align: center;">Determining genetic fitness of an organism.</td>
</tr>
<tr>
<td style="text-align: center;">O.mutation_scheme</td>
<td style="text-align: center;">Trigger mutation events in each chromosome. Helper functions are Chromosome.rmutate (for random mutation throughout the genome) and Chromosome.kmutate (specific mutation within a segment of the genome).</td>
<td style="text-align: center;">Simulate mutation events.</td>
</tr>
<tr>
<td style="text-align: center;">P.prepopulation_control</td>
<td style="text-align: center;">Trigger population control events before mating event in each generation.</td>
<td style="text-align: center;">Simulates pre-puberty (childhood) death.</td>
</tr>
<tr>
<td style="text-align: center;">P.mating</td>
<td style="text-align: center;">Trigger mating events in each generation. Helper function is crossover function in Lim et al. (2010)</td>
<td style="text-align: center;">Simulates mate choices and progeny size.</td>
</tr>
<tr>
<td style="text-align: center;">P.postpopulation_control</td>
<td style="text-align: center;">Trigger population control events after mating event in each generation.</td>
<td style="text-align: center;">Simulates old-age death.</td>
</tr>
<tr>
<td style="text-align: center;">P.generation_events</td>
<td style="text-align: center;">Trigger other defined events in each generation.</td>
<td style="text-align: center;">Simulates catastrophe or epidemic that does not occur regularly. Simulates unusual occurrences of multiple mutation events.</td>
</tr>
<tr>
<td style="text-align: center;">P.report</td>
<td style="text-align: center;">Report the status of each generation.</td>
<td style="text-align: center;">Produce output for analyses between generations.</td>
</tr>
<tr>
<td style="text-align: center;">W.organism_movement</td>
<td style="text-align: center;">Movement of organisms within the world.</td>
<td style="text-align: center;">Simulates foraging or nomadic behaviour.</td>
</tr>
<tr>
<td style="text-align: center;">W.organism_location</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Simulates long distance migration, such as air travel.</td>
</tr>
<tr>
<td style="text-align: center;">W.ecoregulate</td>
<td style="text-align: center;">Simulate events to the entire ecosystem.</td>
<td style="text-align: center;">Simulates temperature and resource gradients.</td>
</tr>
<tr>
<td style="text-align: center;">W.update_ecology</td>
<td style="text-align: center;">Process the input and output from the activities of the organisms in the current ecological cell into a local ecological cell condition, and update the ecosystem.</td>
<td style="text-align: center;">Simulates secretion of chemicals or use of resources (such as food) by organisms, and diffusion of secretions to the neighbouring ecological cells.</td>
</tr>
<tr>
<td style="text-align: center;">W.update_local</td>
<td style="text-align: center;">Update local ecological cell condition from the ecosystem.</td>
<td style="text-align: center;">Simulates movement or diffusion of resources from the ecosystem to local.</td>
</tr>
<tr>
<td style="text-align: center;">W.report</td>
<td style="text-align: center;">Report status of the world (ecosystem)</td>
<td style="text-align: center;">Produce output for analyses between generations.</td>
</tr>
</tbody>
</table>
<p>Table 1. Summary of user-defined functions. "O" in O.fitness function represents organism. "P" represents population. "W" represents world.</p>
<p>DOSE world support 2 additional functions, which can be used to simulate the movement of organisms within the world - World.organism_movement and World.organism_location functions. The World.organism_movement can be used to simulate migration based on immediate and neighbour ecological cell location. A possible use may be to simulate an organism in search of greener pastures or dealing with over-population or under-population.</p>
<p>The World.organism_location can be used for long distance migration. Table 1 provides a summary of the 13 user-defined functions and examples of its use.</p>
<p>However, this does not mean that it is essential to use the world as part of the simulation. In the simplest scenario, the world can be defined as just a single ecological cell and the entire population exist within a single ecological cell. In this case, only the World.update_ecology function needs to be defined to normalizing the local cell condition from the input/output of each organism.</p>
<p>In order to execute the simulation, the following default simulation driver is provide to execute the simulation, given one or more pre-allocated populations in the world:</p>
<div class="codehilite"><pre><span></span><code><span class="n">Run</span><span class="w"> </span><span class="n">World</span><span class="p">.</span><span class="n">ecoregulate</span><span class="w"> </span><span class="k">function</span>
<span class="n">For</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">ecological</span><span class="w"> </span><span class="n">cell</span>
<span class="w">    </span><span class="n">Run</span><span class="w"> </span><span class="n">World</span><span class="p">.</span><span class="n">update_ecology</span><span class="w"> </span><span class="k">function</span>
<span class="w">    </span><span class="n">Run</span><span class="w"> </span><span class="n">World</span><span class="p">.</span><span class="n">update_local</span><span class="w"> </span><span class="k">function</span>
<span class="n">For</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">organism</span>
<span class="w">    </span><span class="n">Execute</span><span class="w"> </span><span class="n">genome</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">Ragaraja</span><span class="w"> </span><span class="n">interpreter</span><span class="w"> </span><span class="n">using</span>
<span class="w">        </span><span class="n">existing</span><span class="w"> </span><span class="n">cytoplasm</span><span class="p">,</span><span class="w"> </span><span class="n">local</span><span class="w"> </span><span class="n">conditions</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="k">input</span>
<span class="w">    </span><span class="n">Update</span><span class="w"> </span><span class="n">cytoplasm</span><span class="w"> </span><span class="p">(</span><span class="n">Organism</span><span class="p">.</span><span class="n">cytoplasm</span><span class="p">)</span>
<span class="w">    </span><span class="n">Add</span><span class="w"> </span><span class="k">input</span><span class="o">/</span><span class="k">output</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">organism</span><span class="w"> </span><span class="n">temporary</span><span class="w"> </span><span class="n">conditions</span>
<span class="w">        </span><span class="n">of</span><span class="w"> </span><span class="n">local</span><span class="w"> </span><span class="n">cell</span>
<span class="n">For</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">population</span>
<span class="w">    </span><span class="n">Run</span><span class="w"> </span><span class="n">Population</span><span class="p">.</span><span class="n">prepopulation_control</span><span class="w"> </span><span class="k">function</span>
<span class="w">    </span><span class="n">Run</span><span class="w"> </span><span class="n">Population</span><span class="p">.</span><span class="n">mating</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="k">and</span>
<span class="w">        </span><span class="n">add</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">organisms</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">cell</span>
<span class="w">    </span><span class="n">For</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">organism</span><span class="p">,</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="n">Organism</span><span class="p">.</span><span class="n">mutation_scheme</span><span class="w"> </span><span class="k">function</span>
<span class="w">    </span><span class="n">Run</span><span class="w"> </span><span class="n">Population</span><span class="p">.</span><span class="n">generation_events</span><span class="w"> </span><span class="k">function</span>
<span class="w">    </span><span class="n">Add</span><span class="w"> </span><span class="mh">1</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">generation</span><span class="w"> </span><span class="n">count</span>
<span class="w">    </span><span class="n">Run</span><span class="w"> </span><span class="n">Population</span><span class="p">.</span><span class="n">report</span><span class="w"> </span><span class="k">function</span>
<span class="w">    </span><span class="n">Fossilize</span><span class="w"> </span><span class="n">population</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">needed</span><span class="w"> </span><span class="p">(</span><span class="n">save</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="n">file</span><span class="p">)</span>
<span class="n">For</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">ecological</span><span class="w"> </span><span class="n">cell</span>
<span class="w">    </span><span class="n">Run</span><span class="w"> </span><span class="n">World</span><span class="p">.</span><span class="n">organism_movement</span><span class="w"> </span><span class="k">function</span>
<span class="w">    </span><span class="n">Run</span><span class="w"> </span><span class="n">World</span><span class="p">.</span><span class="n">organism_location</span><span class="w"> </span><span class="k">function</span>
<span class="w">    </span><span class="n">Run</span><span class="w"> </span><span class="n">World</span><span class="p">.</span><span class="n">report</span><span class="w"> </span><span class="k">function</span>
<span class="n">Bury</span><span class="w"> </span><span class="n">ecosystem</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">needed</span><span class="w"> </span><span class="p">(</span><span class="n">save</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="n">file</span><span class="p">)</span>
<span class="n">Repeat</span><span class="w"> </span><span class="n">simulation</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="n">maximum_generation</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">reached</span>
</code></pre></div>

<h1>3. Artificial Chemistry</h1>
<p>Biochemistry is the study of the molecular basis of life whereby each individual component of a biochemical reaction is inanimate but together, forms a set of self-sustaining and selfregulatory chemical system, which appears more than the sum of its inanimate parts. Philosophers thought that living organisms are endowed with a divine life-force to "organicize" its inorganic chemistry. This doctrine, which came to be known as vitalism, had been rejected by modern science when Friedrich Wohler synthesized urea from silver isocyanate and ammonium chloride in 1828; thus, producing an organic compound (urea) without a</p>
<p>kidney even though the term "organic chemistry" remain in use today. On the basis that biochemistry is a set of inanimate chemical reactions, Christopher Langton (1986) defined artificial chemistry as a man-made system of interactions between artificial molecules, which can be states on a Turing machine and the rules for changing the states are equivalent to artificial chemical reactions. Formally, Dittrich et al. (2001) defined artificial chemistry as a triple of $(S, I)$ where $S$ is the set of possible molecules, and $I$ is the set of interactions or reactions between molecules.</p>
<p>There are different levels of artificial chemistry in DOSE. At the organism level, the artificial chemistry in DOSE is of machine-tape interaction as defined by Ikegami and Hashimoto (1995). In this setup, the set of tapes (cytoplasm and genome) and arrays (input and output) form the molecules while the genome forms the set of interactions in the form of:</p>
<p>$$
\begin{gathered}
\text { Cytoplasm }+ \text { Genome }+ \text { Input }+ \text { Output } \xrightarrow{\text { interaction }} \
\text { Cytoplasm' + Genome' }+ \text { Input' }+ \text { Output' }
\end{gathered}
$$</p>
<p>where the interaction is defined by each Ragaraja instruction. All Ragaraja instructions do not take any operand but defines the changes to the event tape (cytoplasm), source tape (genome), input and output arrays. There are a number of mathematical operations within Ragaraja instruction set. For example, instruction ' 010 ' adds the 10 to the value of the current cell in the event tape (cytoplasm). At this level, the artificial chemistry can be simply defined by arithmetic chemistry where the molecules are natural numbers and the reaction is a mathematical operation,</p>
<p>$$
\text { Cytoplasm }[i]+10 \xrightarrow{010} \text { Cytoplasm }[i]
$$</p>
<p>However, chemical reactions exist within a context. For example, biochemistry exists within a watery solution where certain ions such as proton $\left(\mathrm{H}^{+}\right)$or hydroxyl ions $\left(\mathrm{OH}^{-}\right)$are assumed to be of unlimited supply. To cater to this, Dittrich et al. (2001) defined a third component in artificial chemistry - the reactor algorithm or dynamics $(A)$, which is the rule or a set of rules applying to the collection of molecules. This defines the availability and concentrations of each molecule. In the context of DOSE, only molecules of limited supply is modelled by the input and output arrays. Therefore, each ecological cell can represent the availability of various molecules of limited supply. The concentrations of these molecules can be simply modelled as the relative quantities of these molecules. In addition, the spatial topology, flow and diffusion of such molecules across adjacent ecological cells in the world can be defined by World.update_ecology and World.update_local functions.</p>
<h1>4. Experiment</h1>
<p>An experiment was carried out to test the operations of DOSE. The biological significance is to examine the changes in genetic sequences with respect to mutation rates. Four point mutation rates were used $(2 \%, 3 \%, 4 \%$, and $5 \%)$ across the entire genome using a random mutation operator. Two populations were simulated. Each population consists of 100 organisms and the cytoplasm size is set between 50 and 200. The ancestor organism has a genetic sequence of " 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</p>
<p>a standard, the genetic sequence distances at intervals of 10 generations were calculated as Hamming distances (Ling, 2010b). Code for the entities used in this experiment is given in Appendix E.</p>
<p>The results show that the Hamming distances are not proportional to the mutation rates (Figure 3). However, the Hamming distances at the same mutation rate are highly correlated with each other ( $r&gt;0.999$ ). This is interesting as only random point mutations were used in this experiment; hence, a correlation between mutation rates and sequence divergence should be expected. However, results show no difference in average sequence divergence between $2 \%$ and $3 \%$ mutation rate but a noted difference between $3 \%$ and $4 \%$ mutation rate. This phenomenon had also been observed in nature (Ellegren, 2007). A possible explanation for this may be repeated mutation on the same nucleotide.
A.
<img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3. Sequence distance across generations comparing with generation 10. Panel A and B show data from Population 1 and Population 2 respectively. Four different mutation rates were used $-2 \%, 3 \%, 4 \%$, and $5 \%$. High correlations between the sequence distances of the same mutation rate in different population are observed $(\mathrm{r}&gt;0.999)$.</p>
<p>Using a subset of Ragaraja (NucleotideBF, see Appendix A) as the instruction set (Ragaraja version 0.1 ), cytoplasmic values were analysed. The results show that the average cytoplasmic value of the 100 organism approaches zero after about 80 generations and</p>
<p>centred at zero for the rest of the simulation (Figure 4A). This is expected as there are only 2 increment and decrement operators in NucleotideBF. Hence, it can be expected that over the course of random mutations, the number of increments and decrements approaches the same number. However, there is no correlation between the average cytoplasmic values between the 2 populations (Figure 4C, $\mathrm{r}^{2}=0.003$ ). This may suggest that the 2 populations are evolving independently from each other.
A.
<img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 4. Average cytoplasmic value across generations and the correlation of average cytoplasmic values between the 2 populations. Panel A shows the average cytoplasmic value of Population 1 fluctuates around zero after generation 80 regardless of mutation rates. Panel B shows the correlation between average</p>
<p>cytoplasmic value of Population 1 and Population 2, paired by number of generations. Although a correlation coefficient is high $\left(r^{2}=0.76\right)$, there is a clustering of points near to zero. As such, the values are not evenly distributed. Panel C expands on the near zero values of Panel B (in red box) and shows low correlation ( $\mathrm{r}^{2}=$ 0.003 ).</p>
<h1>5. Discussion and Future Work</h1>
<p>Resources and the generation time of the organisms of interest hinder the study of evolution on a biological platform. On the other hand, advances in computing capabilities may be reaching the point of simulating the evolution of entire genome in silico (Dalquen et al., 2012); thus, creating biologically equivalence of digital organisms or artificial life. No surprises that the crucial link between field of biology and artificial life (Bersini, 2009) came from a bio-inspired computing model, genetic algorithms (GA), which modeled evolutionary processes in the computer. Recent studies had also suggested that artificial ecosystems exhibit characteristics that are similar to natural ecosystems (Dorin et al., 2008; Ronkko, 2007). In this study, the GA framework of Lim et al. (2010) was extended into Digital Organism Simulation Environment (DOSE) by providing an artificial ecosystem and a language to execute the DNA of the digital organisms.</p>
<p>Biological relevance is the main strength of DOSE. Each component and function is given a biological meaning. Most importantly, the genetic language, Ragaraja, is a 3-character instruction code and does not take on any operands. This is almost identical to the operations of natural DNA. However, there are two weaknesses of DOSE. Firstly, it is not able to simulate the 3-dimensional structure of protein molecules from Ragaraja code. Secondly, the current version of DOSE will require the user to be versed in Python programming as it is presented as a simulation library.</p>
<p>Future work in advancing DOSE may be the following - firstly, implementing a graphical user interface to ease construction of a simulation and to provide statistical tools to analyze results of the simulation. This will be useful to biologists using DOSE for their studies. Secondly, the execution of genome may be parallelized. This will allow DOSE to maximize the capabilities of multicore processors and cluster systems to increase simulation speed.</p>
<h2>Acknowledgement</h2>
<p>The author wishes to thank Jack Oon (Immunology, University of Queensland, Australia) for his constructive comments.</p>
<h2>References</h2>
<p>Bersini, H. 2009. How artificial life relates to theoretical biology. Origins of Life: SelfOrganization and/or Biological Evolution?, 61-78.
Bibbal, D, Dupouy, V, Prere, MF, Toutain, PL, Bousquet-Melou, A. 2009. Relatedness of Escherichia coli strains with different susceptibility phenotypes isolated from swine feces during ampicillin treatment. Applied and Environmental Microbiology 75, 29993006.</p>
<p>Bornhofen, S, Lattaud, C. 2006. Outlines of artificial life: A brief history of evolutionary individual based models. Lecture Notes in Computer Science 3871, 226-237.
Cooper, TF, Remold, SK, Lenski, RE, Schneider, D. 2008. Expression profiles reveal parallel evolution of epistatic interactions involving the CRP regulon in Escherichia coli. PLoS Genetics 4, e35.
Curran, D, O'Riordan, C. 2003. On the design of an artificial life simulator. Lecture Notes in Computer Science 2773, 549-555.
Ellegren, H. 2007. Characteristics, causes and evolutionary consequences of male-biased mutation. Proceedings of The Royal Society of Biological Sciences 274, 1-10.
Engelbrecht, AP. 2007. Computational intelligence: an introduction. John Wiley \&amp; Sons, Ltd.
Dalquen, DA, Anisimova, M, Gonnet, GH, Dessimoz, C. 2012. ALF - a simulation framework for genome evolution. Molecular Biology and Evolution 29, 1115-1123.
Dittrich, P, Ziegler, J, Banzhaf, W. 2001. Artificial chemistries - a review. Artificial life 7, 225-275.
Dorin, A, Korb, KB, Grimm, V. 2008. Artificial-life ecosystems - what are they and what could they become? In S. Bullock, J. Noble, R. Watson, M. A. Bedau (eds.) Artificial Life XI: Proceedings of the Eleventh International Conference on the Simulation and Synthesis of Living Systems, pp. 173-180.
Goh, DJW, How, JA, Lim, JZR, NG, WC, Oon, JSH, Lee, KC, Lee, CH, Ling, MHT. 2012. Gradual and step-wise halophilization enables Escherichia coli ATCC 8739 to adapt to $11 \%$ NaCl. Electronic Physician 4(3): 527-535.
Gras, R, Devaurs, D, Wozniak, A, Aspinall, A. 2009. An individual-based evolving predator-prey ecosystem simulation using a fuzzy cognitive map as the behavior model. Artificial Life 15, 423-463.
Harvey, I. 2011. The Microbial Genetic Algorithm. Lecture Notes in Computer Science $5778,126-133$.
Holland, JH. 1992. The Echo model. In Proposal for a Research Program in Adaptive Computation. Santa Fe Institute.
How, JA, Lim, JZR, Goh, DJW, NG, WC, Oon, JSH, Lee, KC, Lee, CH, Ling, MHT. 2013. Adaptation of Escherichia coli ATCC 8739 to $11 \% \mathrm{NaCl}$. Dataset Papers in Biology 2012, Article ID 219095.
Ikegami, T, Hashimoto, T. 1995. Active mutation in self-reproducing networks of machines and tape. Artificial Life 2, 305-318.
Kim, KJ, Cho, S.B. 2006. A comprehensive overview of the applications of artificial life. Artificial Life 12, 153-182.
Kohler, S, Schindelhauer, C, Ziegler, M. 2005. On approximating real-world halting problems. Lecture Notes in Computer Science 3623, 454-466.
Komosinski, M, Adamatzky, A. 2009. Artificial Life Models in Software. Springer-Verlag.
Komosinski, M, Ulatowski, S. 1999. Framsticks: Towards a simulation of a nature-like world, creatures and evolution. In, D. Floreano, J.-D. Nicoud, and F. Mondada (eds.). Advances in Artificial Life, pp. 261-265.
Langton, CG. 1986. Studying artificial life with cellular automata. Physica D: Nonlinear Phenomena 22, 120-149.
Lee, CH, Oon, JSH, Lee, KC, Lee, CH, Ling, MHT. 2012. Escherichia coli ATCC 8739 adapts to the presence of sodium chloride, monosodium glutamate, and benzoic acid after extended culture. ISRN Microbiology 2012, Article ID 965356.</p>
<p>Lim, JZR, Aw, ZQ, Goh, DJW, How, JA, Low, SXZ, Loo, BZL, Ling, MHT. 2010. A genetic algorithm framework grounded in biology. The Python Papers Source Codes 2: 6 .
Ling, MHT. 2010a. Specifying the behaviour of Python programs: Language and basic examples. The Python Papers 5(2): 4.
Ling, MHT. 2010b. COPADS, I: Distances measures between two lists or sets. The Python Papers Source Codes 2:2.
Ofria, C, Wilke, CO. (2004). Avida: A software platform for research in computational evolutionary biology. Artificial Life 10, 191-229.
Pereira, H, Zebende, GF, Moret, MA. 2010. Learning computer programming: Implementing a fractal in a Turing Machine. Computers \&amp; Education 55, 767-776.
Ray, TS. 1992. An approach to the synthesis of life. In Langton C.G. et al., (eds.) Proceedings of Artificial Life II, pp. 371-408.
Ronkko, M. 2007. An artificial ecosystem - emergent dynamics and lifelike properties. Artificial Life 13, 159-187.
Sheikh, RH, Raghuwanshi, MM and Jaiswal, AN. 2008. Genetic algorithm based clustering: a survey. First International Conference on Emerging Trends in Engineering and Technology, pp.314-319.
Tosun, H, Gonul, SA. 2005. The effect of acid adaptation conditions on heat resistance of Escherichia coli O157: H7. Polish Journal of Microbiology 54, 295-299.
Ward, MP, Laffan, SW., and Highfield, LD. 2011. Disease spread models in wild and feral animal populations: application of artificial life models. Revue Scientifique et Technique 30, 437-446.
Watson, R. 2012. Is evolution by natural selection the algorithm of biological evolution? In C. Adami, DM. Bryson, C. Ofria, and RT. Pennock (eds.) Artificial Life XIII: Proceedings of the Thirteenth International Conference on the Synthesis and Simulation of Living Systems Artificial Life XIII: 13th International Conference on the Simulation and Synthesis of Living Systems, pp. 121-128.
Yaeger, L. 1994. Computational genetics, physiology, metabolism, neural systems, learning, vision, and behavior of PolyWorld. In Ed Langton. Life in a New Context. Artificial Life III, pp. 263-298.</p>
<h1>Appendix A: Ragaraja instruction set (Version 1)</h1>
<p>The following table describes the action of each Ragaraja instructions. Of the 1000 possible instructions, 347 is defined, tested and used in this current version.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Command</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">000</td>
<td style="text-align: left;">Move forward by one cell on tape. Equivalent to " $&gt;$ " in BrainFuck.</td>
</tr>
<tr>
<td style="text-align: center;">001</td>
<td style="text-align: left;">Move forward by 5 cells on tape. Equivalent to 5 times of "000".</td>
</tr>
<tr>
<td style="text-align: center;">002</td>
<td style="text-align: left;">Move forward by 10 cells on tape. Equivalent to 10 times of "000".</td>
</tr>
<tr>
<td style="text-align: center;">003</td>
<td style="text-align: left;">Move forward by NxN cells on tape where N is the value of the current cell. If N is a decimal, it will move <br> forward by the floor of NxN. For example, if N is 4.2, this operation will tape pointer forward by 17 cells. As <br> NxN is always a positive number, it does not matter if the value of the current cell is positive or negative.</td>
</tr>
<tr>
<td style="text-align: center;">004</td>
<td style="text-align: left;">Move backward by one cell on tape. Equivalent to " $&lt;$ " in BrainFuck.</td>
</tr>
<tr>
<td style="text-align: center;">005</td>
<td style="text-align: left;">Move backward by 5 cells on tape. Equivalent to 5 times of "004".</td>
</tr>
<tr>
<td style="text-align: center;">006</td>
<td style="text-align: left;">Move backward by 10 cells on tape. Equivalent to 10 times of "004".</td>
</tr>
<tr>
<td style="text-align: center;">007</td>
<td style="text-align: left;">Move backward by NxN cells on tape where N is the value of the current cell. If N is a decimal, it will move <br> backward by the floor of NxN. For example, if N is 4.2, this operation will tape pointer backward by 17 cells.</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>As NxN is always a positive number, it does not matter if the value of the current cell is positive or negative.</th>
</tr>
</thead>
<tbody>
<tr>
<td>008</td>
<td>Increase value of cell by 1. Equivalent to " + " in BrainFuck.</td>
</tr>
<tr>
<td>009</td>
<td>Increase value of cell by 5. Equivalent to 5 times of "008".</td>
</tr>
<tr>
<td>010</td>
<td>Increase value of cell by 10. Equivalent to 10 times of "008".</td>
</tr>
<tr>
<td>011</td>
<td>Decrease value of cell by 1. Equivalent to "-" in BrainFuck.</td>
</tr>
<tr>
<td>012</td>
<td>Decrease value of cell by 5. Equivalent to 5 times of "011".</td>
</tr>
<tr>
<td>013</td>
<td>Decrease value of cell by 10. Equivalent to 10 times of "011".</td>
</tr>
<tr>
<td>016</td>
<td>Add one cell to the end of the tape.</td>
</tr>
<tr>
<td>017</td>
<td>Add 10 cells to the end of the tape.</td>
</tr>
<tr>
<td>018</td>
<td>Remove one cell from the end of the tape. If original tape pointer is at the last cell before removal operation, the tape pointer will point to the last cell after removal.</td>
</tr>
<tr>
<td>019</td>
<td>Remove 10 cells from the end of the tape. If original tape pointer is at the last cell before removal operation, the tape pointer will point to the last cell after removal.</td>
</tr>
<tr>
<td>020</td>
<td>Output current tape cell value and append to the end of the output list. Equivalent to "." in BrainFuck.</td>
</tr>
<tr>
<td>021</td>
<td>Output current tape cell location and append to the end of the output list.</td>
</tr>
<tr>
<td>022</td>
<td>Output current source location and append to the end of the output list.</td>
</tr>
<tr>
<td>023</td>
<td>Move source pointer forward by one instruction without execution if the source pointer does not point beyond the length of the source after the move, otherwise, does not move the source pointer.</td>
</tr>
<tr>
<td>024</td>
<td>Move source pointer forward by 5 instructions without execution if the source pointer does not point beyond the length of the source after the move, otherwise, does not move the source pointer.</td>
</tr>
<tr>
<td>025</td>
<td>Move source pointer forward by 10 instructions without execution if the source pointer does not point beyond the length of the source after the move, otherwise, does not move the source pointer.</td>
</tr>
<tr>
<td>032</td>
<td>Double current tape cell value.</td>
</tr>
<tr>
<td>033</td>
<td>Half current tape cell value.</td>
</tr>
<tr>
<td>034</td>
<td>Insert a cell after the current tape cell. For example, if current tape cell is 35, a cell initialized to zero will be added as cell 36. As a result, the tape is 1 cell longer.</td>
</tr>
<tr>
<td>035</td>
<td>Delete the current cell. As a result, the tape is 1 cell shorter.</td>
</tr>
<tr>
<td>036</td>
<td>Delete the current and append to the end of the output list. As a result, the tape is 1 cell shorter.</td>
</tr>
<tr>
<td>037</td>
<td>Replace the current tape cell value with the last value of the output list, and delete the last value from the output list.</td>
</tr>
<tr>
<td>038</td>
<td>Replace the current tape cell value with the last value of the output list, without deleting the last value from the output list.</td>
</tr>
<tr>
<td>039</td>
<td>Replace the current tape cell value with the first value of the output list, and delete the first value from the output list.</td>
</tr>
<tr>
<td>040</td>
<td>Replace the current tape cell value with the first value of the output list, without deleting the first value from the output list.</td>
</tr>
<tr>
<td>041</td>
<td>Remove first value from the output list.</td>
</tr>
<tr>
<td>042</td>
<td>Remove last value from the output list.</td>
</tr>
<tr>
<td>043</td>
<td>Move the tape cell pointer to the first cell.</td>
</tr>
<tr>
<td>044</td>
<td>Move the tape cell pointer to the last cell.</td>
</tr>
<tr>
<td>045</td>
<td>Move the tape cell pointer to the location determined by the last value of the output list. If the last value of the output list is more than the length of the tape, it will take the modulus of the length of the tape. For example, the last value of the output list is 5 , the tape cell pointer will point to the 5 th cell on the tape.</td>
</tr>
<tr>
<td>046</td>
<td>Flip the tape. The original first cell becomes the last cell but the tape pointer does not flip in location.</td>
</tr>
<tr>
<td>047</td>
<td>Flip the output list.</td>
</tr>
<tr>
<td>050</td>
<td>Randomly execute "008" (increment by 1) or "000" (move forward by 1).</td>
</tr>
<tr>
<td>051</td>
<td>Randomly execute "011" (decrement by 1) or "004" (move backward by 1).</td>
</tr>
<tr>
<td>052</td>
<td>Randomly execute "000" (move forward by 1) or "004" (move backward by 1).</td>
</tr>
<tr>
<td>053</td>
<td>Randomly execute "008" (increment by 1) or "011" (decrement by 1).</td>
</tr>
<tr>
<td>054</td>
<td>Randomly execute "000" (move forward by 1) or "011" (decrement by 1).</td>
</tr>
<tr>
<td>055</td>
<td>Randomly execute "004" (move backward by 1) or "008" (increment by 1).</td>
</tr>
<tr>
<td>056</td>
<td>Randomly execute "000" (move forward by 1) or "004" (move backward by 1) or "011" (decrement by 1).</td>
</tr>
<tr>
<td>057</td>
<td>Randomly execute "000" (move forward by 1) or "008" (increment by 1) or "011" (decrement by 1).</td>
</tr>
<tr>
<td>058</td>
<td>Randomly execute "004" (move backward by 1) or "008" (Increment by 1) or "011" (decrement by 1).</td>
</tr>
<tr>
<td>059</td>
<td>Randomly execute "000" (move forward by 1) or "004" (move backward by 1) or "008" (increment by 1).</td>
</tr>
<tr>
<td>060</td>
<td>Randomly execute "000" (move forward by 1) or "004" (move backward by 1) or "008" (increment by 1) or "011" (decrement by 1).</td>
</tr>
<tr>
<td>061</td>
<td>Move forward by the number of cells signified by the current cell.</td>
</tr>
<tr>
<td>062</td>
<td>Move backward by the number of cells signified by the current cell.</td>
</tr>
<tr>
<td>063</td>
<td>Writes the first value of the input list into the current cell and remove the value from the input list. If input list</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">is empty, " 0 " will be written.</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">064</td>
<td style="text-align: center;">Writes the first value of the input list into the current cell and without removing the value from the input list. If input list is empty, " 0 " will be written.</td>
</tr>
<tr>
<td style="text-align: center;">065</td>
<td style="text-align: center;">Add the value of the current cell ( n ) and $(\mathrm{n}+1)$ th cell, and store the value in the current cell. Array [n] = Array [n] + Array [n+1]</td>
</tr>
<tr>
<td style="text-align: center;">066</td>
<td style="text-align: center;">Add the value of the current cell ( n ) and first of the input list, and store the value in the current cell.</td>
</tr>
<tr>
<td style="text-align: center;">067</td>
<td style="text-align: center;">Add the value of the current cell ( n ) and last of the input list, and store the value in the current cell.</td>
</tr>
<tr>
<td style="text-align: center;">068</td>
<td style="text-align: center;">Subtract the value of the current cell ( n ) from $(\mathrm{n}+1)$ th cell, and store the value in the current cell. Array [n] = Array [n+1] - Array [n]</td>
</tr>
<tr>
<td style="text-align: center;">069</td>
<td style="text-align: center;">Subtract the value of the current cell ( n ) from the first of the input list, and store the value in the current cell. Array [n] = InputList [0] - Array [n]</td>
</tr>
<tr>
<td style="text-align: center;">070</td>
<td style="text-align: center;">Subtract the value of the current cell ( n ) from the last of the input list, and store the value in the current cell. Array [n] = InputList [-1] - Array [n]</td>
</tr>
<tr>
<td style="text-align: center;">071</td>
<td style="text-align: center;">Multiply the value of the current cell ( n ) and $(\mathrm{n}+1)$ th cell, and store the value in the current cell. Array [n] = Array [n+1] * Array [n]</td>
</tr>
<tr>
<td style="text-align: center;">072</td>
<td style="text-align: center;">Multiply the value of the current cell ( n ) and first of the input list, and store the value in the current cell.</td>
</tr>
<tr>
<td style="text-align: center;">073</td>
<td style="text-align: center;">Multiply the value of the current cell ( n ) and last of the input list, and store the value in the current cell.</td>
</tr>
<tr>
<td style="text-align: center;">074</td>
<td style="text-align: center;">Divide the value of the current cell ( n ) from $(\mathrm{n}+1)$ th cell, and store the value in the current cell. Array [n] = Array[n+1] / Array [n]</td>
</tr>
<tr>
<td style="text-align: center;">075</td>
<td style="text-align: center;">Divide the value of the current cell ( n ) from the first of the input list, and store the value in the current cell. Array [n] = InputList [0] / Array [n]</td>
</tr>
<tr>
<td style="text-align: center;">076</td>
<td style="text-align: center;">Divide the value of the current cell ( n ) from the last of the input list, and store the value in the current cell. Array [n] = InputList [-1] - Array [n]</td>
</tr>
<tr>
<td style="text-align: center;">077</td>
<td style="text-align: center;">Modulus (remainder after division) the value of the current cell ( n ) from $(\mathrm{n}+1)$ th cell, and store the value in the current cell. Array [n] = Array [n+1] \% Array [n]</td>
</tr>
<tr>
<td style="text-align: center;">078</td>
<td style="text-align: center;">Modulus (remainder after division) the value of the current cell ( n ) from the first of the input list, and store the value in the current cell. Array [n] = InputList [0] \% Array [n]</td>
</tr>
<tr>
<td style="text-align: center;">079</td>
<td style="text-align: center;">Modulus (remainder after division) the value of the current cell ( n ) from the last of the input list, and store the value in the current cell. Array [n] = InputList [-1] \% Array [n]</td>
</tr>
<tr>
<td style="text-align: center;">080</td>
<td style="text-align: center;">Floor the value of the current cell. For example, if the value of the current cell is 6.7 , it will become 6 .</td>
</tr>
<tr>
<td style="text-align: center;">081</td>
<td style="text-align: center;">Swap the value of the current cell ( n ) and $(\mathrm{n}+1)$ th cell.</td>
</tr>
<tr>
<td style="text-align: center;">084</td>
<td style="text-align: center;">Set current tape cell to " 0 ".</td>
</tr>
<tr>
<td style="text-align: center;">085</td>
<td style="text-align: center;">Set current tape cell to "-1".</td>
</tr>
<tr>
<td style="text-align: center;">086</td>
<td style="text-align: center;">Set current tape cell to " 1 ".</td>
</tr>
<tr>
<td style="text-align: center;">087</td>
<td style="text-align: center;">Negate the value of the current cell. Positive value will be negative. Negative value will be positive.</td>
</tr>
<tr>
<td style="text-align: center;">088</td>
<td style="text-align: center;">Calculate the sine of the value of the current cell (measured in radians) and replace. Array [n] = sine (Array [n])</td>
</tr>
<tr>
<td style="text-align: center;">089</td>
<td style="text-align: center;">Calculate the cosine of the value of the current cell (measured in radians) and replace. Array [n] = cosine (Array [n])</td>
</tr>
<tr>
<td style="text-align: center;">090</td>
<td style="text-align: center;">Calculate the tangent of the value of the current cell (measured in radians) and replace. Array [n] = tangent (Array [n])</td>
</tr>
<tr>
<td style="text-align: center;">091</td>
<td style="text-align: center;">Calculate the arc sine of the value of the current cell (measured in radians) and replace. Array [n] = arcsine (Array [n])</td>
</tr>
<tr>
<td style="text-align: center;">092</td>
<td style="text-align: center;">Calculate the arc cosine of the value of the current cell (measured in radians) and replace. Array [n] = arccosine (Array [n])</td>
</tr>
<tr>
<td style="text-align: center;">093</td>
<td style="text-align: center;">Calculate the arc tangent of the value of the current cell (measured in radians) and replace. Array [n] = arctangent (Array [n])</td>
</tr>
<tr>
<td style="text-align: center;">094</td>
<td style="text-align: center;">Calculate the reciprocal of the value of the current cell (measured in radians) and replace. Array [n] = 1/Array [n]</td>
</tr>
<tr>
<td style="text-align: center;">095</td>
<td style="text-align: center;">Calculate the square root of the value of the current cell (measured in radians) and replace. Array [n] = sqrt (Array [n])</td>
</tr>
<tr>
<td style="text-align: center;">096</td>
<td style="text-align: center;">Calculate the natural logarithm of the value of the current cell (measured in radians) and replace. Array [n] = ln (Array [n])</td>
</tr>
<tr>
<td style="text-align: center;">097</td>
<td style="text-align: center;">Set the value of the current cell to pi (3.14159265358979323846)</td>
</tr>
<tr>
<td style="text-align: center;">098</td>
<td style="text-align: center;">Set the value of the current cell to e (2.718281828459045)</td>
</tr>
<tr>
<td style="text-align: center;">099</td>
<td style="text-align: center;">Calculate the hyperbolic sine of the value of the current cell (measured in radians) and replace. Array [n] = sinh (Array [n])</td>
</tr>
<tr>
<td style="text-align: center;">100</td>
<td style="text-align: center;">Calculate the hyperbolic cosine of the value of the current cell (measured in radians) and replace. Array [n] = cosh (Array [n])</td>
</tr>
<tr>
<td style="text-align: center;">101</td>
<td style="text-align: center;">Calculate the hyperbolic tangent of the value of the current cell (measured in radians) and replace. Array [n] = tanh (Array [n])</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;">102</th>
<th style="text-align: center;">Calculate the hyperbolic arc sine of the value of the current cell (measured in radians) and replace. Array [n] = arcsinh(Array [n])</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">103</td>
<td style="text-align: center;">Calculate the hyperbolic arc cosine of the value of the current cell (measured in radians) and replace. Array [n] = arccosh(Array [n])</td>
</tr>
<tr>
<td style="text-align: center;">104</td>
<td style="text-align: center;">Calculate the hyperbolic arc tangent of the value of the current cell (measured in radians) and replace. Array [n] = arctanh(Array [n])</td>
</tr>
<tr>
<td style="text-align: center;">105</td>
<td style="text-align: center;">Convert the value of the current cell (measured in radians) to degrees and replace.</td>
</tr>
<tr>
<td style="text-align: center;">106</td>
<td style="text-align: center;">Convert the value of the current cell (measured in degrees) to radians and replace.</td>
</tr>
<tr>
<td style="text-align: center;">107</td>
<td style="text-align: center;">Raise the value of the current cell ( n ) to e , and store the value in the current cell. Array [n] = Array[n]"e</td>
</tr>
<tr>
<td style="text-align: center;">108</td>
<td style="text-align: center;">Raise e to the value of the current cell ( n ), and store the value in the current cell. Array [n] = e"Array [n]</td>
</tr>
<tr>
<td style="text-align: center;">109</td>
<td style="text-align: center;">Raise 10 to the value of the current cell ( n ), and store the value in the current cell. Array [n] = 10"Array [n]</td>
</tr>
<tr>
<td style="text-align: center;">110</td>
<td style="text-align: center;">Raise the value of the current cell ( n ) to the value of $(\mathrm{n}+1)$ th cell, and store the value in the current cell. Array [n] = Array [n]"Array [n+1]</td>
</tr>
<tr>
<td style="text-align: center;">111</td>
<td style="text-align: center;">Calculate the n -th root of the value of the current cell ( n ) where n is the value of $(\mathrm{n}+1)$ th cell, and store the value in the current cell. Array [n] = Array [n]" (1/Array[n+1])</td>
</tr>
<tr>
<td style="text-align: center;">112</td>
<td style="text-align: center;">Calculate the error function of the value of the current cell and replace. Array [n] = erf(Array [n])</td>
</tr>
<tr>
<td style="text-align: center;">113</td>
<td style="text-align: center;">Calculate the complementary error function of the value of the current cell and replace. Array [n] = erfc(Array [n])</td>
</tr>
<tr>
<td style="text-align: center;">114</td>
<td style="text-align: center;">Calculate the factorial of the integer value of the current cell (if the integer value is positive) and replace. Array [n] = factorial (Array [n])</td>
</tr>
<tr>
<td style="text-align: center;">115</td>
<td style="text-align: center;">Calculate the factorial of the absolute integer value of the current cell and replace. Array [n] = factorial(abs(Array[n]))</td>
</tr>
<tr>
<td style="text-align: center;">116</td>
<td style="text-align: center;">Calculate the Euclidean distance (hypotenuse) value of the current cell ( n ) to the value of $(\mathrm{n}+1)$ th cell, and store the value in the current cell. <br> Array [n] = sqrt (Array [n]<em>Array [n] * Array[n+1]</em>Array [n+1])</td>
</tr>
<tr>
<td style="text-align: center;">117</td>
<td style="text-align: center;">Calculate the logarithm value of the current cell ( n ) to the base of the value of $(\mathrm{n}+1)$ th cell, and store the value in the current cell. Array [n] = log (Array [n], base=Array[n+1])</td>
</tr>
<tr>
<td style="text-align: center;">120</td>
<td style="text-align: center;">AND operator: Given positive numbers ( $&gt;0$ ) as True and zero or negative numbers ( $&lt;=0$ )as False, store Array[current] AND Array[current+1] in the current cell (Array[current]) where "0" is False and "1" is True.</td>
</tr>
<tr>
<td style="text-align: center;">121</td>
<td style="text-align: center;">OR operator: Given positive numbers ( $&gt;0$ ) as True and zero or negative numbers ( $&lt;=0$ )as False, store Array[current] OR Array[current+1] in the current cell (Array[current]) where "0" is False and "1" is True.</td>
</tr>
<tr>
<td style="text-align: center;">122</td>
<td style="text-align: center;">NOT operator: Given positive numbers ( $&gt;0$ ) as True and zero or negative numbers ( $&lt;=0$ )as False, store NOT Array[current] in the current cell (Array[current]) where "0" is False and "1" is True.</td>
</tr>
<tr>
<td style="text-align: center;">123</td>
<td style="text-align: center;">LESS-THAN operator: Store Array[current] &lt; Array[current+1] in the current cell (Array[current]) where "0" is False and "1" is True.</td>
</tr>
<tr>
<td style="text-align: center;">124</td>
<td style="text-align: center;">MORE-THAN operator: Store Array[current] &gt; Array[current+1] in the current cell (Array[current]) where "0" is False and "1" is True.</td>
</tr>
<tr>
<td style="text-align: center;">125</td>
<td style="text-align: center;">EQUAL operator: Store Array[current] = Array[current+1] in the current cell (Array[current]) where "0" is False and "1" is True.</td>
</tr>
<tr>
<td style="text-align: center;">126</td>
<td style="text-align: center;">NOT-EQUAL operator: Store Array[current] != Array[current+1] in the current cell (Array[current]) where "0" is False and "1" is True.</td>
</tr>
<tr>
<td style="text-align: center;">127</td>
<td style="text-align: center;">LESS-THAN-OR-EQUAL operator: Store Array[current] &lt;= Array[current+1] in the current cell (Array[current]) where "0" is False and "1" is True.</td>
</tr>
<tr>
<td style="text-align: center;">128</td>
<td style="text-align: center;">MORE-THAN-OR-EQUAL operator: Store Array[current] =&gt; Array[current+1] in the current cell (Array[current]) where "0" is False and "1" is True.</td>
</tr>
<tr>
<td style="text-align: center;">140</td>
<td style="text-align: center;">Move tape pointer to the centre of the tape. If the tape has odd number cells, it will move to the lower cell. For example, this instruction will move the tape pointer to the 500th cell of a 1000-cell tape, or 142nd of a 285-cell tape.</td>
</tr>
<tr>
<td style="text-align: center;">141</td>
<td style="text-align: center;">Move tape pointer to $1 / 4$ the position of the tape. If the tape has odd number cells, it will move to the lower cell. For example, this instruction will move the tape pointer to the 250th cell of a 1000-cell tape, or 71st of a 285-cell tape.</td>
</tr>
<tr>
<td style="text-align: center;">142</td>
<td style="text-align: center;">Move tape pointer to $3 / 4$ the position of the tape. If the tape has odd number cells, it will move to the lower cell. For example, this instruction will move the tape pointer to the 750th cell of a 1000-cell tape, or 213rd of a 285-cell tape.</td>
</tr>
<tr>
<td style="text-align: center;">143</td>
<td style="text-align: center;">Move tape pointer to the position as the integer value in the current cell. If the value of the cell is larger than the length of the tape, it will move to the modulus of the integer value in the current cell.</td>
</tr>
<tr>
<td style="text-align: center;">144</td>
<td style="text-align: center;">Divide current cell value by 10 .</td>
</tr>
<tr>
<td style="text-align: center;">145</td>
<td style="text-align: center;">Multiply current cell value by 10 .</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;">146</th>
<th style="text-align: center;">Add all cell values from $(\mathrm{n}+1)$ th cell to the end of the tape and store result in current cell (n). Array $[n]=$ sum(Array[n+1:])</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">147</td>
<td style="text-align: center;">Add all cell values from n-th cell to the end of the tape and store result in current cell (n). Array $[n]=$ sum(Array[n:])</td>
</tr>
<tr>
<td style="text-align: center;">150</td>
<td style="text-align: center;">Add all cell values in the tape and store result in current cell (n). Array [n] = sum(Array[:])</td>
</tr>
<tr>
<td style="text-align: center;">151</td>
<td style="text-align: center;">Average all cell values from $(\mathrm{n}+1)$ th cell to the end of the tape and store result in current cell (n). Array $[n]=$ average(Array $[\mathrm{n}+1:])$</td>
</tr>
<tr>
<td style="text-align: center;">152</td>
<td style="text-align: center;">Average all cell values from n-th cell to the end of the tape and store result in current cell (n). Array $[n]=$ average(Array $[\mathrm{n}:]$ )</td>
</tr>
<tr>
<td style="text-align: center;">153</td>
<td style="text-align: center;">Average all cell values from first cell to the cell before n-th cell and store result in current cell (n). Array $[n]=$ average(Array[0:n])</td>
</tr>
<tr>
<td style="text-align: center;">154</td>
<td style="text-align: center;">Average all cell values from first cell to n-th cell (inclusive) and store result in current cell (n). Array $[n]=$ average(Array $[0: n+1]$ )</td>
</tr>
<tr>
<td style="text-align: center;">155</td>
<td style="text-align: center;">Half every cell value in tape.</td>
</tr>
<tr>
<td style="text-align: center;">156</td>
<td style="text-align: center;">Double every cell value in tape.</td>
</tr>
<tr>
<td style="text-align: center;">157</td>
<td style="text-align: center;">Divide every cell value in tape by 10 .</td>
</tr>
<tr>
<td style="text-align: center;">158</td>
<td style="text-align: center;">Multiply every cell value in tape by 10 .</td>
</tr>
<tr>
<td style="text-align: center;">159</td>
<td style="text-align: center;">Divide every cell value in tape by 100 .</td>
</tr>
<tr>
<td style="text-align: center;">160</td>
<td style="text-align: center;">Multiply every cell value in tape by 100 .</td>
</tr>
<tr>
<td style="text-align: center;">161</td>
<td style="text-align: center;">Cut the tape before the current cell (n) and append it to the end of the tape and set tape pointer to 0 . $&lt;---A---&gt;n&lt;--B---&gt;$ n&lt;---B---&gt;&lt;---A---&gt;</td>
</tr>
<tr>
<td style="text-align: center;">162</td>
<td style="text-align: center;">Cut the tape after the current cell (n) and append it to the start of the tape and set tape pointer to the last cell. $&lt;---A---&gt;n&lt;--B---&gt;$ &lt;---B---&gt;&lt;---A---&gt;n</td>
</tr>
<tr>
<td style="text-align: center;">163</td>
<td style="text-align: center;">Cut out the current cell and append it to the front of the tape and set tape pointer to 0 . $&lt;---A---&gt;n&lt;--B---&gt;$ n&lt;---A---&gt;&lt;---B---&gt;</td>
</tr>
<tr>
<td style="text-align: center;">164</td>
<td style="text-align: center;">Cut out the current cell and append it to the end of the tape and set tape pointer to the last cell. $&lt;---A---&gt;n&lt;--B---&gt;$ &lt;---A---&gt;&lt;---B---&gt;n</td>
</tr>
<tr>
<td style="text-align: center;">165</td>
<td style="text-align: center;">Multiply every cell value in tape by -1 .</td>
</tr>
<tr>
<td style="text-align: center;">166</td>
<td style="text-align: center;">Square all the cell values in the cells after the current cell (current cell value is not affected).</td>
</tr>
<tr>
<td style="text-align: center;">167</td>
<td style="text-align: center;">Square all the cell values in the cells before the current cell (current cell value is not affected).</td>
</tr>
<tr>
<td style="text-align: center;">168</td>
<td style="text-align: center;">Square every cell value in tape.</td>
</tr>
<tr>
<td style="text-align: center;">169</td>
<td style="text-align: center;">Square root every cell value in tape.</td>
</tr>
<tr>
<td style="text-align: center;">170</td>
<td style="text-align: center;">Square root all the cell values in the cells after the current cell (current cell value is not affected).</td>
</tr>
<tr>
<td style="text-align: center;">171</td>
<td style="text-align: center;">Square root all the cell values in the cells before the current cell (current cell value is not affected).</td>
</tr>
<tr>
<td style="text-align: center;">189</td>
<td style="text-align: center;">Set all values in tape to " 0 ".</td>
</tr>
<tr>
<td style="text-align: center;">196</td>
<td style="text-align: center;">Set the value of the current cell to the standard deviation of the values in the tape.</td>
</tr>
<tr>
<td style="text-align: center;">197</td>
<td style="text-align: center;">Set the value of the current cell to the geometric mean of the values in the tape.</td>
</tr>
<tr>
<td style="text-align: center;">198</td>
<td style="text-align: center;">Set the value of the current cell to the harmonic mean of the values in the tape.</td>
</tr>
<tr>
<td style="text-align: center;">201</td>
<td style="text-align: center;">Store value of current tape cell to register #1</td>
</tr>
<tr>
<td style="text-align: center;">202</td>
<td style="text-align: center;">Store value of current tape cell to register #2</td>
</tr>
<tr>
<td style="text-align: center;">203</td>
<td style="text-align: center;">Store value of current tape cell to register #3</td>
</tr>
<tr>
<td style="text-align: center;">204</td>
<td style="text-align: center;">Store value of current tape cell to register #4</td>
</tr>
<tr>
<td style="text-align: center;">205</td>
<td style="text-align: center;">Store value of current tape cell to register #5</td>
</tr>
<tr>
<td style="text-align: center;">206</td>
<td style="text-align: center;">Store value of current tape cell to register #6</td>
</tr>
<tr>
<td style="text-align: center;">207</td>
<td style="text-align: center;">Store value of current tape cell to register #7</td>
</tr>
<tr>
<td style="text-align: center;">208</td>
<td style="text-align: center;">Store value of current tape cell to register #8</td>
</tr>
<tr>
<td style="text-align: center;">209</td>
<td style="text-align: center;">Store value of current tape cell to register #9</td>
</tr>
<tr>
<td style="text-align: center;">210</td>
<td style="text-align: center;">Store value of current tape cell to register #10</td>
</tr>
<tr>
<td style="text-align: center;">211</td>
<td style="text-align: center;">Store value of current tape cell to register #11</td>
</tr>
<tr>
<td style="text-align: center;">212</td>
<td style="text-align: center;">Store value of current tape cell to register #12</td>
</tr>
<tr>
<td style="text-align: center;">213</td>
<td style="text-align: center;">Store value of current tape cell to register #13</td>
</tr>
<tr>
<td style="text-align: center;">214</td>
<td style="text-align: center;">Store value of current tape cell to register #14</td>
</tr>
<tr>
<td style="text-align: center;">215</td>
<td style="text-align: center;">Store value of current tape cell to register #15</td>
</tr>
<tr>
<td style="text-align: center;">216</td>
<td style="text-align: center;">Store value of current tape cell to register #16</td>
</tr>
<tr>
<td style="text-align: center;">217</td>
<td style="text-align: center;">Store value of current tape cell to register #17</td>
</tr>
<tr>
<td style="text-align: center;">218</td>
<td style="text-align: center;">Store value of current tape cell to register #18</td>
</tr>
<tr>
<td style="text-align: center;">219</td>
<td style="text-align: center;">Store value of current tape cell to register #19</td>
</tr>
<tr>
<td style="text-align: center;">220</td>
<td style="text-align: center;">Store value of current tape cell to register #20</td>
</tr>
<tr>
<td style="text-align: center;">221</td>
<td style="text-align: center;">Store value of current tape cell to register #21</td>
</tr>
<tr>
<td style="text-align: center;">222</td>
<td style="text-align: center;">Store value of current tape cell to register #22</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>223</th>
<th>Store value of current tape cell to register #23</th>
</tr>
</thead>
<tbody>
<tr>
<td>224</td>
<td>Store value of current tape cell to register #24</td>
</tr>
<tr>
<td>225</td>
<td>Store value of current tape cell to register #25</td>
</tr>
<tr>
<td>226</td>
<td>Store value of current tape cell to register #26</td>
</tr>
<tr>
<td>227</td>
<td>Store value of current tape cell to register #27</td>
</tr>
<tr>
<td>228</td>
<td>Store value of current tape cell to register #28</td>
</tr>
<tr>
<td>229</td>
<td>Store value of current tape cell to register #29</td>
</tr>
<tr>
<td>230</td>
<td>Store value of current tape cell to register #30</td>
</tr>
<tr>
<td>231</td>
<td>Store value of current tape cell to register #31</td>
</tr>
<tr>
<td>232</td>
<td>Store value of current tape cell to register #32</td>
</tr>
<tr>
<td>233</td>
<td>Store value of current tape cell to register #33</td>
</tr>
<tr>
<td>234</td>
<td>Store value of current tape cell to register #34</td>
</tr>
<tr>
<td>235</td>
<td>Store value of current tape cell to register #35</td>
</tr>
<tr>
<td>236</td>
<td>Store value of current tape cell to register #36</td>
</tr>
<tr>
<td>237</td>
<td>Store value of current tape cell to register #37</td>
</tr>
<tr>
<td>238</td>
<td>Store value of current tape cell to register #38</td>
</tr>
<tr>
<td>239</td>
<td>Store value of current tape cell to register #39</td>
</tr>
<tr>
<td>240</td>
<td>Store value of current tape cell to register #40</td>
</tr>
<tr>
<td>241</td>
<td>Store value of current tape cell to register #41</td>
</tr>
<tr>
<td>242</td>
<td>Store value of current tape cell to register #42</td>
</tr>
<tr>
<td>243</td>
<td>Store value of current tape cell to register #43</td>
</tr>
<tr>
<td>244</td>
<td>Store value of current tape cell to register #44</td>
</tr>
<tr>
<td>245</td>
<td>Store value of current tape cell to register #45</td>
</tr>
<tr>
<td>246</td>
<td>Store value of current tape cell to register #46</td>
</tr>
<tr>
<td>247</td>
<td>Store value of current tape cell to register #47</td>
</tr>
<tr>
<td>248</td>
<td>Store value of current tape cell to register #48</td>
</tr>
<tr>
<td>249</td>
<td>Store value of current tape cell to register #49</td>
</tr>
<tr>
<td>250</td>
<td>Store value of current tape cell to register #50</td>
</tr>
<tr>
<td>251</td>
<td>Store value of current tape cell to register #51</td>
</tr>
<tr>
<td>252</td>
<td>Store value of current tape cell to register #52</td>
</tr>
<tr>
<td>253</td>
<td>Store value of current tape cell to register #53</td>
</tr>
<tr>
<td>254</td>
<td>Store value of current tape cell to register #54</td>
</tr>
<tr>
<td>255</td>
<td>Store value of current tape cell to register #55</td>
</tr>
<tr>
<td>256</td>
<td>Store value of current tape cell to register #56</td>
</tr>
<tr>
<td>257</td>
<td>Store value of current tape cell to register #57</td>
</tr>
<tr>
<td>258</td>
<td>Store value of current tape cell to register #58</td>
</tr>
<tr>
<td>259</td>
<td>Store value of current tape cell to register #59</td>
</tr>
<tr>
<td>260</td>
<td>Store value of current tape cell to register #60</td>
</tr>
<tr>
<td>261</td>
<td>Store value of current tape cell to register #61</td>
</tr>
<tr>
<td>262</td>
<td>Store value of current tape cell to register #62</td>
</tr>
<tr>
<td>263</td>
<td>Store value of current tape cell to register #63</td>
</tr>
<tr>
<td>264</td>
<td>Store value of current tape cell to register #64</td>
</tr>
<tr>
<td>265</td>
<td>Store value of current tape cell to register #64</td>
</tr>
<tr>
<td>266</td>
<td>Store value of current tape cell to register #66</td>
</tr>
<tr>
<td>267</td>
<td>Store value of current tape cell to register #67</td>
</tr>
<tr>
<td>268</td>
<td>Store value of current tape cell to register #68</td>
</tr>
<tr>
<td>269</td>
<td>Store value of current tape cell to register #69</td>
</tr>
<tr>
<td>270</td>
<td>Store value of current tape cell to register #70</td>
</tr>
<tr>
<td>271</td>
<td>Store value of current tape cell to register #71</td>
</tr>
<tr>
<td>272</td>
<td>Store value of current tape cell to register #72</td>
</tr>
<tr>
<td>273</td>
<td>Store value of current tape cell to register #73</td>
</tr>
<tr>
<td>274</td>
<td>Store value of current tape cell to register #74</td>
</tr>
<tr>
<td>275</td>
<td>Store value of current tape cell to register #75</td>
</tr>
<tr>
<td>276</td>
<td>Store value of current tape cell to register #76</td>
</tr>
<tr>
<td>277</td>
<td>Store value of current tape cell to register #77</td>
</tr>
<tr>
<td>278</td>
<td>Store value of current tape cell to register #78</td>
</tr>
<tr>
<td>279</td>
<td>Store value of current tape cell to register #79</td>
</tr>
<tr>
<td>280</td>
<td>Store value of current tape cell to register #80</td>
</tr>
<tr>
<td>281</td>
<td>Store value of current tape cell to register #81</td>
</tr>
<tr>
<td>282</td>
<td>Store value of current tape cell to register #82</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>283</th>
<th>Store value of current tape cell to register #83</th>
</tr>
</thead>
<tbody>
<tr>
<td>284</td>
<td>Store value of current tape cell to register #84</td>
</tr>
<tr>
<td>285</td>
<td>Store value of current tape cell to register #85</td>
</tr>
<tr>
<td>286</td>
<td>Store value of current tape cell to register #86</td>
</tr>
<tr>
<td>287</td>
<td>Store value of current tape cell to register #87</td>
</tr>
<tr>
<td>288</td>
<td>Store value of current tape cell to register #88</td>
</tr>
<tr>
<td>289</td>
<td>Store value of current tape cell to register #89</td>
</tr>
<tr>
<td>290</td>
<td>Store value of current tape cell to register #90</td>
</tr>
<tr>
<td>291</td>
<td>Store value of current tape cell to register #91</td>
</tr>
<tr>
<td>292</td>
<td>Store value of current tape cell to register #92</td>
</tr>
<tr>
<td>293</td>
<td>Store value of current tape cell to register #93</td>
</tr>
<tr>
<td>294</td>
<td>Store value of current tape cell to register #94</td>
</tr>
<tr>
<td>295</td>
<td>Store value of current tape cell to register #95</td>
</tr>
<tr>
<td>296</td>
<td>Store value of current tape cell to register #96</td>
</tr>
<tr>
<td>297</td>
<td>Store value of current tape cell to register #97</td>
</tr>
<tr>
<td>298</td>
<td>Store value of current tape cell to register #98</td>
</tr>
<tr>
<td>299</td>
<td>Store value of current tape cell to register #99</td>
</tr>
<tr>
<td>301</td>
<td>Put value from register #1 to current tape cell</td>
</tr>
<tr>
<td>302</td>
<td>Put value from register #2 to current tape cell</td>
</tr>
<tr>
<td>303</td>
<td>Put value from register #3 to current tape cell</td>
</tr>
<tr>
<td>304</td>
<td>Put value from register #4 to current tape cell</td>
</tr>
<tr>
<td>305</td>
<td>Put value from register #5 to current tape cell</td>
</tr>
<tr>
<td>306</td>
<td>Put value from register #6 to current tape cell</td>
</tr>
<tr>
<td>307</td>
<td>Put value from register #7 to current tape cell</td>
</tr>
<tr>
<td>308</td>
<td>Put value from register #8 to current tape cell</td>
</tr>
<tr>
<td>309</td>
<td>Put value from register #9 to current tape cell</td>
</tr>
<tr>
<td>310</td>
<td>Put value from register #10 to current tape cell</td>
</tr>
<tr>
<td>311</td>
<td>Put value from register #11 to current tape cell</td>
</tr>
<tr>
<td>312</td>
<td>Put value from register #12 to current tape cell</td>
</tr>
<tr>
<td>313</td>
<td>Put value from register #13 to current tape cell</td>
</tr>
<tr>
<td>314</td>
<td>Put value from register #14 to current tape cell</td>
</tr>
<tr>
<td>315</td>
<td>Put value from register #15 to current tape cell</td>
</tr>
<tr>
<td>316</td>
<td>Put value from register #16 to current tape cell</td>
</tr>
<tr>
<td>317</td>
<td>Put value from register #17 to current tape cell</td>
</tr>
<tr>
<td>318</td>
<td>Put value from register #18 to current tape cell</td>
</tr>
<tr>
<td>319</td>
<td>Put value from register #19 to current tape cell</td>
</tr>
<tr>
<td>320</td>
<td>Put value from register #20 to current tape cell</td>
</tr>
<tr>
<td>321</td>
<td>Put value from register #21 to current tape cell</td>
</tr>
<tr>
<td>322</td>
<td>Put value from register #22 to current tape cell</td>
</tr>
<tr>
<td>323</td>
<td>Put value from register #23 to current tape cell</td>
</tr>
<tr>
<td>324</td>
<td>Put value from register #24 to current tape cell</td>
</tr>
<tr>
<td>325</td>
<td>Put value from register #25 to current tape cell</td>
</tr>
<tr>
<td>326</td>
<td>Put value from register #26 to current tape cell</td>
</tr>
<tr>
<td>327</td>
<td>Put value from register #27 to current tape cell</td>
</tr>
<tr>
<td>328</td>
<td>Put value from register #28 to current tape cell</td>
</tr>
<tr>
<td>329</td>
<td>Put value from register #29 to current tape cell</td>
</tr>
<tr>
<td>330</td>
<td>Put value from register #30 to current tape cell</td>
</tr>
<tr>
<td>331</td>
<td>Put value from register #31 to current tape cell</td>
</tr>
<tr>
<td>332</td>
<td>Put value from register #32 to current tape cell</td>
</tr>
<tr>
<td>333</td>
<td>Put value from register #33 to current tape cell</td>
</tr>
<tr>
<td>334</td>
<td>Put value from register #34 to current tape cell</td>
</tr>
<tr>
<td>335</td>
<td>Put value from register #35 to current tape cell</td>
</tr>
<tr>
<td>336</td>
<td>Put value from register #36 to current tape cell</td>
</tr>
<tr>
<td>337</td>
<td>Put value from register #37 to current tape cell</td>
</tr>
<tr>
<td>338</td>
<td>Put value from register #38 to current tape cell</td>
</tr>
<tr>
<td>339</td>
<td>Put value from register #39 to current tape cell</td>
</tr>
<tr>
<td>340</td>
<td>Put value from register #40 to current tape cell</td>
</tr>
<tr>
<td>341</td>
<td>Put value from register #41 to current tape cell</td>
</tr>
<tr>
<td>342</td>
<td>Put value from register #42 to current tape cell</td>
</tr>
<tr>
<td>343</td>
<td>Put value from register #43 to current tape cell</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>344</th>
<th>Put value from register #44 to current tape cell</th>
</tr>
</thead>
<tbody>
<tr>
<td>345</td>
<td>Put value from register #45 to current tape cell</td>
</tr>
<tr>
<td>346</td>
<td>Put value from register #46 to current tape cell</td>
</tr>
<tr>
<td>347</td>
<td>Put value from register #47 to current tape cell</td>
</tr>
<tr>
<td>348</td>
<td>Put value from register #48 to current tape cell</td>
</tr>
<tr>
<td>349</td>
<td>Put value from register #49 to current tape cell</td>
</tr>
<tr>
<td>350</td>
<td>Put value from register #50 to current tape cell</td>
</tr>
<tr>
<td>351</td>
<td>Put value from register #51 to current tape cell</td>
</tr>
<tr>
<td>352</td>
<td>Put value from register #52 to current tape cell</td>
</tr>
<tr>
<td>353</td>
<td>Put value from register #53 to current tape cell</td>
</tr>
<tr>
<td>354</td>
<td>Put value from register #54 to current tape cell</td>
</tr>
<tr>
<td>355</td>
<td>Put value from register #55 to current tape cell</td>
</tr>
<tr>
<td>356</td>
<td>Put value from register #56 to current tape cell</td>
</tr>
<tr>
<td>357</td>
<td>Put value from register #57 to current tape cell</td>
</tr>
<tr>
<td>358</td>
<td>Put value from register #58 to current tape cell</td>
</tr>
<tr>
<td>359</td>
<td>Put value from register #59 to current tape cell</td>
</tr>
<tr>
<td>360</td>
<td>Put value from register #60 to current tape cell</td>
</tr>
<tr>
<td>361</td>
<td>Put value from register #61 to current tape cell</td>
</tr>
<tr>
<td>362</td>
<td>Put value from register #62 to current tape cell</td>
</tr>
<tr>
<td>363</td>
<td>Put value from register #63 to current tape cell</td>
</tr>
<tr>
<td>364</td>
<td>Put value from register #64 to current tape cell</td>
</tr>
<tr>
<td>365</td>
<td>Put value from register #65 to current tape cell</td>
</tr>
<tr>
<td>366</td>
<td>Put value from register #66 to current tape cell</td>
</tr>
<tr>
<td>367</td>
<td>Put value from register #67 to current tape cell</td>
</tr>
<tr>
<td>368</td>
<td>Put value from register #68 to current tape cell</td>
</tr>
<tr>
<td>369</td>
<td>Put value from register #69 to current tape cell</td>
</tr>
<tr>
<td>370</td>
<td>Put value from register #70 to current tape cell</td>
</tr>
<tr>
<td>371</td>
<td>Put value from register #71 to current tape cell</td>
</tr>
<tr>
<td>372</td>
<td>Put value from register #72 to current tape cell</td>
</tr>
<tr>
<td>373</td>
<td>Put value from register #73 to current tape cell</td>
</tr>
<tr>
<td>374</td>
<td>Put value from register #74 to current tape cell</td>
</tr>
<tr>
<td>375</td>
<td>Put value from register #75 to current tape cell</td>
</tr>
<tr>
<td>376</td>
<td>Put value from register #76 to current tape cell</td>
</tr>
<tr>
<td>377</td>
<td>Put value from register #77 to current tape cell</td>
</tr>
<tr>
<td>378</td>
<td>Put value from register #78 to current tape cell</td>
</tr>
<tr>
<td>379</td>
<td>Put value from register #79 to current tape cell</td>
</tr>
<tr>
<td>380</td>
<td>Put value from register #80 to current tape cell</td>
</tr>
<tr>
<td>381</td>
<td>Put value from register #81 to current tape cell</td>
</tr>
<tr>
<td>382</td>
<td>Put value from register #82 to current tape cell</td>
</tr>
<tr>
<td>383</td>
<td>Put value from register #83 to current tape cell</td>
</tr>
<tr>
<td>384</td>
<td>Put value from register #84 to current tape cell</td>
</tr>
<tr>
<td>385</td>
<td>Put value from register #85 to current tape cell</td>
</tr>
<tr>
<td>386</td>
<td>Put value from register #86 to current tape cell</td>
</tr>
<tr>
<td>387</td>
<td>Put value from register #87 to current tape cell</td>
</tr>
<tr>
<td>388</td>
<td>Put value from register #88 to current tape cell</td>
</tr>
<tr>
<td>389</td>
<td>Put value from register #89 to current tape cell</td>
</tr>
<tr>
<td>390</td>
<td>Put value from register #90 to current tape cell</td>
</tr>
<tr>
<td>391</td>
<td>Put value from register #91 to current tape cell</td>
</tr>
<tr>
<td>392</td>
<td>Put value from register #92 to current tape cell</td>
</tr>
<tr>
<td>393</td>
<td>Put value from register #93 to current tape cell</td>
</tr>
<tr>
<td>394</td>
<td>Put value from register #94 to current tape cell</td>
</tr>
<tr>
<td>395</td>
<td>Put value from register #95 to current tape cell</td>
</tr>
<tr>
<td>396</td>
<td>Put value from register #96 to current tape cell</td>
</tr>
<tr>
<td>397</td>
<td>Put value from register #97 to current tape cell</td>
</tr>
<tr>
<td>398</td>
<td>Put value from register #98 to current tape cell</td>
</tr>
<tr>
<td>399</td>
<td>Put value from register #99 to current tape cell</td>
</tr>
</tbody>
</table>
<p>For direct simulation of naturally occurring DNA sequences, a subset of Ragaraja is defined based on IUPAC nucleotide codes, known as NucleotideBF ${ }^{2}$, which can be set in DOSE parameters as Ragaraja version 0.1 . Guanine (G) and cytosine (C) are paired to move left and right of the tape respectively, while adenine (A) and thymine (T) are paired for increment and decrement respectively. Alternatively, user can define their set of instruction usage by toggling each instruction in ragaraja_instructions.txt file, "Y" for use and "N" for not used, and setting Ragaraja version as 0 .</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Instructions</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">NucleotideBF</td>
<td style="text-align: center;">Ragaraja</td>
<td style="text-align: center;">BrainFuck</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">G</td>
<td style="text-align: center;">000</td>
<td style="text-align: center;">$&gt;$</td>
<td style="text-align: center;">Move the pointer to the right.</td>
</tr>
<tr>
<td style="text-align: center;">C</td>
<td style="text-align: center;">004</td>
<td style="text-align: center;">$&lt;$</td>
<td style="text-align: center;">Move the pointer to the left.</td>
</tr>
<tr>
<td style="text-align: center;">A</td>
<td style="text-align: center;">008</td>
<td style="text-align: center;">$+$</td>
<td style="text-align: center;">Increment the memory cell under the pointer.</td>
</tr>
<tr>
<td style="text-align: center;">T</td>
<td style="text-align: center;">011</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">Decrement the memory cell under the pointer.</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">020</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Full stop. Output the character signified by the cell at the pointer.</td>
</tr>
<tr>
<td style="text-align: center;">R</td>
<td style="text-align: center;">050</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Random between A or G.</td>
</tr>
<tr>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">051</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Random between C or T.</td>
</tr>
<tr>
<td style="text-align: center;">S</td>
<td style="text-align: center;">052</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Random between G or C.</td>
</tr>
<tr>
<td style="text-align: center;">W</td>
<td style="text-align: center;">053</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Random between A or T.</td>
</tr>
<tr>
<td style="text-align: center;">K</td>
<td style="text-align: center;">054</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Random between G or T.</td>
</tr>
<tr>
<td style="text-align: center;">M</td>
<td style="text-align: center;">055</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Random between A or C.</td>
</tr>
<tr>
<td style="text-align: center;">B</td>
<td style="text-align: center;">056</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Random between C or G or T.</td>
</tr>
<tr>
<td style="text-align: center;">D</td>
<td style="text-align: center;">057</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Random between A or G or T.</td>
</tr>
<tr>
<td style="text-align: center;">H</td>
<td style="text-align: center;">058</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Random between A or C or T.</td>
</tr>
<tr>
<td style="text-align: center;">V</td>
<td style="text-align: center;">059</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Random between A or C or G.</td>
</tr>
<tr>
<td style="text-align: center;">N</td>
<td style="text-align: center;">060</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Random between A or T or C or G.</td>
</tr>
</tbody>
</table>
<h1>Appendix B: DOSE world code (file name: dose_world.py)</h1>
<div class="codehilite"><pre><span></span><code><span class="s1">&#39; &#39;</span> <span class="s1">&#39;</span>
<span class="n">World</span> <span class="n">structure</span> <span class="k">for</span> <span class="n">DOSE</span> <span class="p">(</span><span class="n">digital</span> <span class="n">organism</span> <span class="n">simulation</span> <span class="n">environment</span><span class="p">)</span>
<span class="n">Date</span> <span class="n">created</span><span class="p">:</span> <span class="mi">13</span><span class="n">th</span> <span class="n">September</span> <span class="mi">2012</span>
<span class="n">Licence</span><span class="p">:</span> <span class="n">Python</span> <span class="n">Software</span> <span class="n">Foundation</span> <span class="n">License</span> <span class="n">version</span> <span class="mi">2</span>
<span class="s1">&#39; &#39;</span> <span class="s1">&#39;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cPickle</span>
<span class="k">class</span><span class="w"> </span><span class="nc">World</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="s1">&#39; &#39;</span> <span class="s1">&#39;</span>
    <span class="n">Representation</span> <span class="n">of</span> <span class="n">a</span> <span class="mi">3</span><span class="o">-</span><span class="n">dimensional</span> <span class="n">ecological</span> <span class="n">world</span><span class="o">.</span>
    <span class="n">The</span> <span class="n">ecosystem</span> <span class="ow">is</span> <span class="n">made</span> <span class="n">up</span> <span class="n">of</span> <span class="n">ecological</span> <span class="n">cells</span><span class="o">.</span> <span class="n">Each</span> <span class="n">ecological</span> <span class="n">cell</span> <span class="ow">is</span>
    <span class="n">modelled</span> <span class="k">as</span> <span class="n">a</span> <span class="n">dictionary</span> <span class="n">of</span>
    <span class="o">-</span> <span class="n">local_input</span><span class="p">:</span> <span class="n">A</span> <span class="nb">list</span> <span class="n">containing</span> <span class="n">processed</span> <span class="nb">input</span><span class="p">,</span> <span class="n">representing</span> <span class="n">the</span>
        <span class="n">partial</span> <span class="n">local</span> <span class="n">ecological</span> <span class="n">condition</span><span class="p">,</span> <span class="n">to</span> <span class="n">be</span> <span class="n">used</span> <span class="k">as</span> <span class="nb">input</span> <span class="n">to</span> <span class="n">the</span> <span class="n">organisms</span> <span class="ow">in</span>
        <span class="n">the</span> <span class="n">current</span> <span class="n">ecological</span> <span class="n">cell</span><span class="o">.</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">updated</span> <span class="n">by</span> <span class="n">World</span><span class="o">.</span><span class="n">update_local</span>
        <span class="n">function</span><span class="o">.</span>
    <span class="o">-</span> <span class="n">local_output</span><span class="p">:</span> <span class="n">A</span> <span class="nb">list</span> <span class="n">containing</span> <span class="n">processed</span> <span class="n">output</span><span class="p">,</span> <span class="n">representing</span> <span class="n">the</span>
        <span class="n">partial</span> <span class="n">local</span> <span class="n">ecological</span> <span class="n">condition</span><span class="o">.</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">updated</span> <span class="n">by</span> <span class="n">World</span><span class="o">.</span><span class="n">update_local</span>
        <span class="n">function</span><span class="o">.</span>
    <span class="o">-</span> <span class="n">temporary_input</span><span class="p">:</span> <span class="n">A</span> <span class="nb">list</span> <span class="n">acting</span> <span class="k">as</span> <span class="n">temporary</span> <span class="n">holding</span> <span class="k">for</span> <span class="nb">input</span> <span class="n">after</span>
        <span class="n">being</span> <span class="n">fed</span> <span class="n">to</span> <span class="n">the</span> <span class="n">organisms</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">current</span> <span class="n">ecological</span> <span class="n">cell</span><span class="p">,</span> <span class="n">which</span> <span class="ow">is</span> <span class="n">to</span> <span class="n">be</span>
        <span class="n">used</span> <span class="n">to</span> <span class="n">update</span> <span class="n">local_input</span> <span class="ow">and</span> <span class="n">local_output</span> <span class="n">lists</span> <span class="n">by</span> <span class="n">World</span><span class="o">.</span><span class="n">update_local</span> <span class="ow">and</span>
        <span class="n">World</span><span class="o">.</span><span class="n">update_ecology</span> <span class="n">functions</span><span class="o">.</span>
    <span class="o">-</span> <span class="n">temporary_output</span><span class="p">:</span> <span class="n">A</span> <span class="nb">list</span> <span class="n">acting</span> <span class="k">as</span> <span class="n">temporary</span> <span class="n">holding</span> <span class="k">for</span> <span class="n">output</span> <span class="kn">from</span><span class="w"> </span><span class="nn">the</span>
</code></pre></div>

<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{2}$ http://esolangs.org/wiki/NucleotideBF_(nBF)&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>