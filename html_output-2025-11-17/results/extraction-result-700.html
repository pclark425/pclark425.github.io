<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-700 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-700</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-700</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-18.html">extraction-schema-18</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of discrepancies, gaps, or misalignments between natural language descriptions (such as paper descriptions, documentation, or specifications) and their corresponding code implementations in automated experimentation systems, including how these gaps are identified, measured, and their impacts.</div>
                <p><strong>Paper ID:</strong> paper-ecf189b8871403a3a4f646debe5139656c2a0f4c</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/ecf189b8871403a3a4f646debe5139656c2a0f4c" target="_blank">Replicability Analysis for Natural Language Processing: Testing Significance with Multiple Datasets</a></p>
                <p><strong>Paper Venue:</strong> Transactions of the Association for Computational Linguistics</p>
                <p><strong>Paper TL;DR:</strong> This paper proposes a Replicability Analysis framework for a statistically sound analysis of multiple comparisons between algorithms for NLP tasks, and demonstrates its empirical value across four applications: multi-domain dependency parsing, multilingual POS tagging, cross-domain sentiment classification and word similarity prediction.</p>
                <p><strong>Paper Abstract:</strong> With the ever growing amount of textual data from a large variety of languages, domains, and genres, it has become standard to evaluate NLP algorithms on multiple datasets in order to ensure a consistent performance across heterogeneous setups. However, such multiple comparisons pose significant challenges to traditional statistical analysis methods in NLP and can lead to erroneous conclusions. In this paper we propose a Replicability Analysis framework for a statistically sound analysis of multiple comparisons between algorithms for NLP tasks. We discuss the theoretical advantages of this framework over the current, statistically unjustified, practice in the NLP literature, and demonstrate its empirical value across four applications: multi-domain dependency parsing, multilingual POS tagging, cross-domain sentiment classification and word similarity prediction.</p>
                <p><strong>Cost:</strong> 0.015</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e700.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e700.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of discrepancies, gaps, or misalignments between natural language descriptions (such as paper descriptions, documentation, or specifications) and their corresponding code implementations in automated experimentation systems, including how these gaps are identified, measured, and their impacts.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Per-dataset significance counting</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Naive per-dataset significance counting (counting p <= alpha)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>The common practice of declaring an algorithm superior on each dataset whose per-dataset p-value falls below a nominal threshold and then counting such datasets; shown to be statistically invalid under multiple comparisons and to substantially inflate erroneous claims.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Replicability Analysis for Natural Language Processing: Testing Significance with Multiple Datasets</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>NLP experimental evaluation pipeline (multi-dataset comparisons)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Researchers evaluate algorithms across multiple datasets and report per-dataset performance and p-values; decisions about superiority are commonly taken by counting datasets with p <= alpha.</td>
                        </tr>
                        <tr>
                            <td><strong>nl_description_type</strong></td>
                            <td>research paper results reporting / experimental claims</td>
                        </tr>
                        <tr>
                            <td><strong>code_implementation_type</strong></td>
                            <td>statistical test implementations / experiment analysis scripts used to compute per-dataset p-values</td>
                        </tr>
                        <tr>
                            <td><strong>gap_type</strong></td>
                            <td>incorrect analysis practice / multiplicity mismatch</td>
                        </tr>
                        <tr>
                            <td><strong>gap_description</strong></td>
                            <td>Natural-language conclusions (paper claims) based on counting datasets with p <= alpha treat each per-dataset test in isolation and implicitly assume that the naive count provides a valid estimate of number of true effects; the implemented practice in code (performing N independent hypothesis tests and counting positives) does not control the family-wise or related error rates and thus misaligns with the implicit claim of controlled overall error.</td>
                        </tr>
                        <tr>
                            <td><strong>gap_location</strong></td>
                            <td>evaluation metrics / significance testing stage of the experimental pipeline</td>
                        </tr>
                        <tr>
                            <td><strong>detection_method</strong></td>
                            <td>theoretical multiplicity argument, Monte Carlo simulations (synthetic p-value generation), and empirical re-analysis of published multi-dataset results</td>
                        </tr>
                        <tr>
                            <td><strong>measurement_method</strong></td>
                            <td>Measured probability of overestimating the true number k of datasets with effect (P(hat_k_count > k)) via repeated simulation; comparison of hat_k_count against partial-conjunction estimators and Holm rejections; reporting concrete deltas in empirical studies (Tables and counts).</td>
                        </tr>
                        <tr>
                            <td><strong>impact_on_results</strong></td>
                            <td>Large inflation of erroneous claims: synthetic independent-all-null simulation gave P(hat_k_count>k)=0.963; dependent-all-null simulation gave 0.943; in empirical tasks differences include e.g. Mate-Redshift (7 domains) hat_k_count=2 vs. hat_k_Fisher=5 and hat_k_Bonferroni=1; sentiment classification (12 setups) hat_k_count=10 vs. hat_k_Bonferroni=6 (alpha=0.05).</td>
                        </tr>
                        <tr>
                            <td><strong>frequency_or_prevalence</strong></td>
                            <td>Paper documents this as common practice in NLP evaluation tables and demonstrates frequent overestimation in simulations (96.3% and 94.3% of simulation runs overestimated in toy examples) and substantial differences across multiple real NLP comparisons.</td>
                        </tr>
                        <tr>
                            <td><strong>root_cause</strong></td>
                            <td>Ignoring multiple comparisons / family-wise error control; implicit assumption that per-dataset tests can be interpreted independently; omission of multiplicity correction in natural-language conclusions and in analysis scripts.</td>
                        </tr>
                        <tr>
                            <td><strong>mitigation_approach</strong></td>
                            <td>Adopt partial-conjunction analysis to estimate a lower bound on number of datasets with effect (Benjamini & Heller framework) and use multiple-testing procedures (Holm procedure for identification; Bonferroni or Fisher partial-conjunction p-values depending on dependence assumptions).</td>
                        </tr>
                        <tr>
                            <td><strong>mitigation_effectiveness</strong></td>
                            <td>Effective in simulations and empirical re-analyses: guarantees P(estimated k > true k) <= alpha when valid combination used; e.g., in independent all-null synthetic runs hatP(hat_k_Bonferroni>k)=0.001 and hatP(hat_k_Fisher>k)=0.021 (both <= 0.05), and in dependent case hatP(hat_k_Bonferroni>k)=0.046 (<=0.05) while naive count remained ~0.94.</td>
                        </tr>
                        <tr>
                            <td><strong>domain_or_field</strong></td>
                            <td>Natural Language Processing / Machine Learning / Experimental statistics</td>
                        </tr>
                        <tr>
                            <td><strong>reproducibility_impact</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Replicability Analysis for Natural Language Processing: Testing Significance with Multiple Datasets', 'publication_date_yy_mm': '2017-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e700.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e700.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of discrepancies, gaps, or misalignments between natural language descriptions (such as paper descriptions, documentation, or specifications) and their corresponding code implementations in automated experimentation systems, including how these gaps are identified, measured, and their impacts.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Independence-assumption mismatch</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Mismatch between independence assumption in description and actual dataset dependency (use of Fisher where dependence exists)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>When natural-language claims or chosen analytic methods assume independent test statistics (enabling use of Fisher combination), but datasets are dependent (shared samples or structural overlap), the code/analysis using Fisher is invalid and inflates evidence.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Replicability Analysis for Natural Language Processing: Testing Significance with Multiple Datasets</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>NLP multi-dataset statistical aggregation</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Combining per-dataset p-values into a partial-conjunction p-value using Fisher's method (requires independence) or Bonferroni (valid under dependence).</td>
                        </tr>
                        <tr>
                            <td><strong>nl_description_type</strong></td>
                            <td>method selection justification in paper methods/results sections</td>
                        </tr>
                        <tr>
                            <td><strong>code_implementation_type</strong></td>
                            <td>p-value combination implementations in analysis scripts</td>
                        </tr>
                        <tr>
                            <td><strong>gap_type</strong></td>
                            <td>assumption mismatch / inappropriate method choice</td>
                        </tr>
                        <tr>
                            <td><strong>gap_description</strong></td>
                            <td>The paper highlights that Fisher's partial-conjunction p-value assumes independence across datasets; using it when datasets are dependent (e.g., overlapping test sets or hierarchical relationships) violates the assumption, leading to anti-conservative inference; natural-language reports often do not state or verify independence, causing misalignment with the statistical requirements of the code.</td>
                        </tr>
                        <tr>
                            <td><strong>gap_location</strong></td>
                            <td>statistical aggregation stage (p-value combination)</td>
                        </tr>
                        <tr>
                            <td><strong>detection_method</strong></td>
                            <td>theoretical reasoning about method assumptions, synthetic dependent-data simulations, and analysis of empirical tasks known to have dataset dependence (sentiment pairs sharing test sets, word-similarity datasets overlapping)</td>
                        </tr>
                        <tr>
                            <td><strong>measurement_method</strong></td>
                            <td>Empirical estimation of overestimation probability (P(hat_k>k)) for Fisher vs Bonferroni under simulated dependence; comparison of resulting hat_k values on real tasks (e.g., sentiment, word similarity).</td>
                        </tr>
                        <tr>
                            <td><strong>impact_on_results</strong></td>
                            <td>When dependence exists, Fisher can be overly optimistic: dependent simulation showed hatP(hat_k_Fisher>k)=0.234 (>>0.05) while Bonferroni remained ~0.046. In empirical dependent tasks (sentiment, word-similarity) Fisher and naive counting often report larger hat_k than Bonferroni, altering conclusions about algorithm superiority.</td>
                        </tr>
                        <tr>
                            <td><strong>frequency_or_prevalence</strong></td>
                            <td>Paper documents multiple real NLP setups with dependence (sentiment cross-domain sharing, word-similarity dataset composition) and shows that incorrect assumption of independence is a relevant and recurring issue.</td>
                        </tr>
                        <tr>
                            <td><strong>root_cause</strong></td>
                            <td>Omitted or unstated dependency analysis in natural language methods descriptions; use of more powerful combination tests without validating independence assumptions.</td>
                        </tr>
                        <tr>
                            <td><strong>mitigation_approach</strong></td>
                            <td>When dependence cannot be ruled out, use methods valid under arbitrary dependence (Bonferroni-based partial-conjunction p-values) or explicitly analyze dependency structure and use methods valid under the identified dependency (e.g., Simes/Hochberg under positive dependence).</td>
                        </tr>
                        <tr>
                            <td><strong>mitigation_effectiveness</strong></td>
                            <td>Bonferroni-based approach controlled overestimation near the nominal alpha in simulations; authors recommend Fisher only when independence is justifiable, otherwise Bonferroni/Holm provide valid control.</td>
                        </tr>
                        <tr>
                            <td><strong>domain_or_field</strong></td>
                            <td>Natural Language Processing / Statistical testing</td>
                        </tr>
                        <tr>
                            <td><strong>reproducibility_impact</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Replicability Analysis for Natural Language Processing: Testing Significance with Multiple Datasets', 'publication_date_yy_mm': '2017-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e700.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e700.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of discrepancies, gaps, or misalignments between natural language descriptions (such as paper descriptions, documentation, or specifications) and their corresponding code implementations in automated experimentation systems, including how these gaps are identified, measured, and their impacts.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Identification vs counting mismatch</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Misalignment between claiming identified datasets and statistical guarantees (selecting smallest p-values without error control)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Declaring particular datasets as showing algorithm superiority by selecting the k smallest p-values (or those below alpha) does not necessarily control the probability of any false discovery; the paper recommends specific multiple-testing procedures for identification that align code behavior with the claimed control of erroneous claims.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Replicability Analysis for Natural Language Processing: Testing Significance with Multiple Datasets</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>NLP experimental reporting and dataset-level claim identification</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Identifying which datasets show significant superiority of one algorithm over another and reporting them as replicated findings.</td>
                        </tr>
                        <tr>
                            <td><strong>nl_description_type</strong></td>
                            <td>results interpretation / identification of datasets with effect in paper text/tables</td>
                        </tr>
                        <tr>
                            <td><strong>code_implementation_type</strong></td>
                            <td>selection scripts or post-processing that mark datasets as significant based on p-values</td>
                        </tr>
                        <tr>
                            <td><strong>gap_type</strong></td>
                            <td>incomplete specification / selection without multiplicity control</td>
                        </tr>
                        <tr>
                            <td><strong>gap_description</strong></td>
                            <td>Natural language statements 'algorithm A is better on these datasets' are often backed by code that simply selects datasets with p <= alpha or the smallest k p-values; this selection step lacks guaranteed control of the probability of making at least one erroneous claim. The paper shows that without appropriate multiple-testing procedures (e.g., Holm) the identification step is misaligned with the claimed family-wise error control.</td>
                        </tr>
                        <tr>
                            <td><strong>gap_location</strong></td>
                            <td>post-hoc selection / result reporting stage</td>
                        </tr>
                        <tr>
                            <td><strong>detection_method</strong></td>
                            <td>comparison of naive selection vs. Holm procedure results; theoretical properties of Holm and Bonferroni; empirical application to published datasets (e.g., POS tagging languages identified differ when Holm is applied).</td>
                        </tr>
                        <tr>
                            <td><strong>measurement_method</strong></td>
                            <td>Count of datasets identified by naive p<=alpha selection vs. Holm rejections; comparison to hat_k_Bonferroni; reporting the exact sets and counts (e.g., Mimick vs Char: naive count=11, Holm/Bairro identifies 6 languages).</td>
                        </tr>
                        <tr>
                            <td><strong>impact_on_results</strong></td>
                            <td>Identification without correction led to more datasets being claimed as significant than allowed by family-wise error bounds; empirical examples: multilingual POS tagging naive 11 vs Holm 6; sentiment classification naive 10 vs Holm 6 (alpha=0.05). This changes which specific datasets are reported as replicated effects.</td>
                        </tr>
                        <tr>
                            <td><strong>frequency_or_prevalence</strong></td>
                            <td>Paper demonstrates this mismatch across multiple real NLP comparisons; identification-by-counting is shown to be commonly used in literature and often overclaims.</td>
                        </tr>
                        <tr>
                            <td><strong>root_cause</strong></td>
                            <td>Lack of specification of multiple-testing control in natural-language descriptions and analysis pipelines; misunderstanding of what per-test alpha implies for family-wise probabilities.</td>
                        </tr>
                        <tr>
                            <td><strong>mitigation_approach</strong></td>
                            <td>Use sequentially-rejective procedures valid under dependence (Holm) for identification; where appropriate and tolerable, use FDR-controlling methods (Benjamini–Hochberg) if proportion-of-errors control is acceptable.</td>
                        </tr>
                        <tr>
                            <td><strong>mitigation_effectiveness</strong></td>
                            <td>Holm procedure provides guaranteed control of probability of at least one false rejection under arbitrary dependence; empirically, the rejection lists matched the more conservative hat_k_Bonferroni and reduced false-positive identification relative to naive selection.</td>
                        </tr>
                        <tr>
                            <td><strong>domain_or_field</strong></td>
                            <td>Natural Language Processing / Statistical inference</td>
                        </tr>
                        <tr>
                            <td><strong>reproducibility_impact</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Replicability Analysis for Natural Language Processing: Testing Significance with Multiple Datasets', 'publication_date_yy_mm': '2017-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e700.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e700.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of discrepancies, gaps, or misalignments between natural language descriptions (such as paper descriptions, documentation, or specifications) and their corresponding code implementations in automated experimentation systems, including how these gaps are identified, measured, and their impacts.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Replicability vs reproducibility confusion</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Ambiguous use of 'replicability'/'reproducibility' and omitted experimental details</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Terminology and reporting gaps: papers sometimes conflate replicability (consistency across datasets) with reproducibility (re-running same code/data), and omit implementation specifics or dependency descriptions that are necessary to align natural-language claims with code behavior.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Replicability Analysis for Natural Language Processing: Testing Significance with Multiple Datasets</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>NLP experimental documentation and reporting</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Natural-language statements in papers (introduction/methods) describing replicability goals and experimental setup, often without full code-level description of assumptions and dependencies.</td>
                        </tr>
                        <tr>
                            <td><strong>nl_description_type</strong></td>
                            <td>paper terminology and experimental protocol descriptions / methods sections</td>
                        </tr>
                        <tr>
                            <td><strong>code_implementation_type</strong></td>
                            <td>experiment scripts / released code repositories (where available) and analysis scripts</td>
                        </tr>
                        <tr>
                            <td><strong>gap_type</strong></td>
                            <td>ambiguous description / incomplete specification</td>
                        </tr>
                        <tr>
                            <td><strong>gap_description</strong></td>
                            <td>The paper notes confusion in the community between 'replicability' and 'reproducibility' and emphasizes that many papers do not fully specify dependencies between datasets or the multiple-testing handling in their natural-language descriptions; this omission creates a mismatch with code implementations which may or may not embody the required controls or assumptions.</td>
                        </tr>
                        <tr>
                            <td><strong>gap_location</strong></td>
                            <td>methods description / assumptions about datasets and statistical tests</td>
                        </tr>
                        <tr>
                            <td><strong>detection_method</strong></td>
                            <td>Literature review and discussion of community practice; reference to prior replication/replicability studies (e.g., Névéol et al., Marrese-Taylor & Matsuo) and examination of the lack of dependency analyses in prior NLP evaluations.</td>
                        </tr>
                        <tr>
                            <td><strong>measurement_method</strong></td>
                            <td>Qualitative assessment rather than a numeric metric in the paper; the authors demonstrate concrete statistical consequences (inflated error rates) as an indirect measurement of the effect of these omissions.</td>
                        </tr>
                        <tr>
                            <td><strong>impact_on_results</strong></td>
                            <td>Ambiguity and missing implementation-level detail lead to inconsistent interpretations, inappropriate choice of statistical procedures, and difficulty reproducing claimed conclusions across datasets; can materially change the set and number of datasets reported as supportive of claims.</td>
                        </tr>
                        <tr>
                            <td><strong>frequency_or_prevalence</strong></td>
                            <td>Common in NLP literature according to the paper's survey and examples; several referenced works either conflate terminology or omit detailed multiplicity handling.</td>
                        </tr>
                        <tr>
                            <td><strong>root_cause</strong></td>
                            <td>Ambiguous terminology, omitted procedural details in natural-language descriptions, lack of community standards for reporting dependency structure and multiple-testing treatment.</td>
                        </tr>
                        <tr>
                            <td><strong>mitigation_approach</strong></td>
                            <td>Clarify terminology, explicitly state assumptions (independence/ dependence), report multiple-testing procedures used, and release analysis code (authors provide their code repository) so code and natural-language descriptions align.</td>
                        </tr>
                        <tr>
                            <td><strong>mitigation_effectiveness</strong></td>
                            <td>Not quantified in the paper, but authors provide an implementation (code on GitHub) and demonstrate that explicitly-stated procedures (partial-conjunction tests and Holm) produce different and statistically-controlled outcomes, improving alignment between claims and implemented analysis.</td>
                        </tr>
                        <tr>
                            <td><strong>domain_or_field</strong></td>
                            <td>Natural Language Processing / Scientific reporting practices</td>
                        </tr>
                        <tr>
                            <td><strong>reproducibility_impact</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Replicability Analysis for Natural Language Processing: Testing Significance with Multiple Datasets', 'publication_date_yy_mm': '2017-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Screening for partial conjunction hypotheses <em>(Rating: 2)</em></li>
                <li>Selective inference in complex research <em>(Rating: 2)</em></li>
                <li>Controlling the false discovery rate: A practical and powerful approach to multiple testing <em>(Rating: 2)</em></li>
                <li>Statistical comparisons of classifiers over multiple data sets <em>(Rating: 2)</em></li>
                <li>An empirical investigation of statistical significance in NLP <em>(Rating: 1)</em></li>
                <li>Estimating effect size across datasets <em>(Rating: 1)</em></li>
                <li>Replication issues in syntax-based aspect extraction for opinion mining <em>(Rating: 1)</em></li>
                <li>Replicability of research in biomedical natural language processing: a pilot evaluation for a coding task <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-700",
    "paper_id": "paper-ecf189b8871403a3a4f646debe5139656c2a0f4c",
    "extraction_schema_id": "extraction-schema-18",
    "extracted_data": [
        {
            "name_short": "Per-dataset significance counting",
            "name_full": "Naive per-dataset significance counting (counting p &lt;= alpha)",
            "brief_description": "The common practice of declaring an algorithm superior on each dataset whose per-dataset p-value falls below a nominal threshold and then counting such datasets; shown to be statistically invalid under multiple comparisons and to substantially inflate erroneous claims.",
            "citation_title": "Replicability Analysis for Natural Language Processing: Testing Significance with Multiple Datasets",
            "mention_or_use": "use",
            "system_name": "NLP experimental evaluation pipeline (multi-dataset comparisons)",
            "system_description": "Researchers evaluate algorithms across multiple datasets and report per-dataset performance and p-values; decisions about superiority are commonly taken by counting datasets with p &lt;= alpha.",
            "nl_description_type": "research paper results reporting / experimental claims",
            "code_implementation_type": "statistical test implementations / experiment analysis scripts used to compute per-dataset p-values",
            "gap_type": "incorrect analysis practice / multiplicity mismatch",
            "gap_description": "Natural-language conclusions (paper claims) based on counting datasets with p &lt;= alpha treat each per-dataset test in isolation and implicitly assume that the naive count provides a valid estimate of number of true effects; the implemented practice in code (performing N independent hypothesis tests and counting positives) does not control the family-wise or related error rates and thus misaligns with the implicit claim of controlled overall error.",
            "gap_location": "evaluation metrics / significance testing stage of the experimental pipeline",
            "detection_method": "theoretical multiplicity argument, Monte Carlo simulations (synthetic p-value generation), and empirical re-analysis of published multi-dataset results",
            "measurement_method": "Measured probability of overestimating the true number k of datasets with effect (P(hat_k_count &gt; k)) via repeated simulation; comparison of hat_k_count against partial-conjunction estimators and Holm rejections; reporting concrete deltas in empirical studies (Tables and counts).",
            "impact_on_results": "Large inflation of erroneous claims: synthetic independent-all-null simulation gave P(hat_k_count&gt;k)=0.963; dependent-all-null simulation gave 0.943; in empirical tasks differences include e.g. Mate-Redshift (7 domains) hat_k_count=2 vs. hat_k_Fisher=5 and hat_k_Bonferroni=1; sentiment classification (12 setups) hat_k_count=10 vs. hat_k_Bonferroni=6 (alpha=0.05).",
            "frequency_or_prevalence": "Paper documents this as common practice in NLP evaluation tables and demonstrates frequent overestimation in simulations (96.3% and 94.3% of simulation runs overestimated in toy examples) and substantial differences across multiple real NLP comparisons.",
            "root_cause": "Ignoring multiple comparisons / family-wise error control; implicit assumption that per-dataset tests can be interpreted independently; omission of multiplicity correction in natural-language conclusions and in analysis scripts.",
            "mitigation_approach": "Adopt partial-conjunction analysis to estimate a lower bound on number of datasets with effect (Benjamini & Heller framework) and use multiple-testing procedures (Holm procedure for identification; Bonferroni or Fisher partial-conjunction p-values depending on dependence assumptions).",
            "mitigation_effectiveness": "Effective in simulations and empirical re-analyses: guarantees P(estimated k &gt; true k) &lt;= alpha when valid combination used; e.g., in independent all-null synthetic runs hatP(hat_k_Bonferroni&gt;k)=0.001 and hatP(hat_k_Fisher&gt;k)=0.021 (both &lt;= 0.05), and in dependent case hatP(hat_k_Bonferroni&gt;k)=0.046 (&lt;=0.05) while naive count remained ~0.94.",
            "domain_or_field": "Natural Language Processing / Machine Learning / Experimental statistics",
            "reproducibility_impact": true,
            "uuid": "e700.0",
            "source_info": {
                "paper_title": "Replicability Analysis for Natural Language Processing: Testing Significance with Multiple Datasets",
                "publication_date_yy_mm": "2017-09"
            }
        },
        {
            "name_short": "Independence-assumption mismatch",
            "name_full": "Mismatch between independence assumption in description and actual dataset dependency (use of Fisher where dependence exists)",
            "brief_description": "When natural-language claims or chosen analytic methods assume independent test statistics (enabling use of Fisher combination), but datasets are dependent (shared samples or structural overlap), the code/analysis using Fisher is invalid and inflates evidence.",
            "citation_title": "Replicability Analysis for Natural Language Processing: Testing Significance with Multiple Datasets",
            "mention_or_use": "use",
            "system_name": "NLP multi-dataset statistical aggregation",
            "system_description": "Combining per-dataset p-values into a partial-conjunction p-value using Fisher's method (requires independence) or Bonferroni (valid under dependence).",
            "nl_description_type": "method selection justification in paper methods/results sections",
            "code_implementation_type": "p-value combination implementations in analysis scripts",
            "gap_type": "assumption mismatch / inappropriate method choice",
            "gap_description": "The paper highlights that Fisher's partial-conjunction p-value assumes independence across datasets; using it when datasets are dependent (e.g., overlapping test sets or hierarchical relationships) violates the assumption, leading to anti-conservative inference; natural-language reports often do not state or verify independence, causing misalignment with the statistical requirements of the code.",
            "gap_location": "statistical aggregation stage (p-value combination)",
            "detection_method": "theoretical reasoning about method assumptions, synthetic dependent-data simulations, and analysis of empirical tasks known to have dataset dependence (sentiment pairs sharing test sets, word-similarity datasets overlapping)",
            "measurement_method": "Empirical estimation of overestimation probability (P(hat_k&gt;k)) for Fisher vs Bonferroni under simulated dependence; comparison of resulting hat_k values on real tasks (e.g., sentiment, word similarity).",
            "impact_on_results": "When dependence exists, Fisher can be overly optimistic: dependent simulation showed hatP(hat_k_Fisher&gt;k)=0.234 (&gt;&gt;0.05) while Bonferroni remained ~0.046. In empirical dependent tasks (sentiment, word-similarity) Fisher and naive counting often report larger hat_k than Bonferroni, altering conclusions about algorithm superiority.",
            "frequency_or_prevalence": "Paper documents multiple real NLP setups with dependence (sentiment cross-domain sharing, word-similarity dataset composition) and shows that incorrect assumption of independence is a relevant and recurring issue.",
            "root_cause": "Omitted or unstated dependency analysis in natural language methods descriptions; use of more powerful combination tests without validating independence assumptions.",
            "mitigation_approach": "When dependence cannot be ruled out, use methods valid under arbitrary dependence (Bonferroni-based partial-conjunction p-values) or explicitly analyze dependency structure and use methods valid under the identified dependency (e.g., Simes/Hochberg under positive dependence).",
            "mitigation_effectiveness": "Bonferroni-based approach controlled overestimation near the nominal alpha in simulations; authors recommend Fisher only when independence is justifiable, otherwise Bonferroni/Holm provide valid control.",
            "domain_or_field": "Natural Language Processing / Statistical testing",
            "reproducibility_impact": true,
            "uuid": "e700.1",
            "source_info": {
                "paper_title": "Replicability Analysis for Natural Language Processing: Testing Significance with Multiple Datasets",
                "publication_date_yy_mm": "2017-09"
            }
        },
        {
            "name_short": "Identification vs counting mismatch",
            "name_full": "Misalignment between claiming identified datasets and statistical guarantees (selecting smallest p-values without error control)",
            "brief_description": "Declaring particular datasets as showing algorithm superiority by selecting the k smallest p-values (or those below alpha) does not necessarily control the probability of any false discovery; the paper recommends specific multiple-testing procedures for identification that align code behavior with the claimed control of erroneous claims.",
            "citation_title": "Replicability Analysis for Natural Language Processing: Testing Significance with Multiple Datasets",
            "mention_or_use": "use",
            "system_name": "NLP experimental reporting and dataset-level claim identification",
            "system_description": "Identifying which datasets show significant superiority of one algorithm over another and reporting them as replicated findings.",
            "nl_description_type": "results interpretation / identification of datasets with effect in paper text/tables",
            "code_implementation_type": "selection scripts or post-processing that mark datasets as significant based on p-values",
            "gap_type": "incomplete specification / selection without multiplicity control",
            "gap_description": "Natural language statements 'algorithm A is better on these datasets' are often backed by code that simply selects datasets with p &lt;= alpha or the smallest k p-values; this selection step lacks guaranteed control of the probability of making at least one erroneous claim. The paper shows that without appropriate multiple-testing procedures (e.g., Holm) the identification step is misaligned with the claimed family-wise error control.",
            "gap_location": "post-hoc selection / result reporting stage",
            "detection_method": "comparison of naive selection vs. Holm procedure results; theoretical properties of Holm and Bonferroni; empirical application to published datasets (e.g., POS tagging languages identified differ when Holm is applied).",
            "measurement_method": "Count of datasets identified by naive p&lt;=alpha selection vs. Holm rejections; comparison to hat_k_Bonferroni; reporting the exact sets and counts (e.g., Mimick vs Char: naive count=11, Holm/Bairro identifies 6 languages).",
            "impact_on_results": "Identification without correction led to more datasets being claimed as significant than allowed by family-wise error bounds; empirical examples: multilingual POS tagging naive 11 vs Holm 6; sentiment classification naive 10 vs Holm 6 (alpha=0.05). This changes which specific datasets are reported as replicated effects.",
            "frequency_or_prevalence": "Paper demonstrates this mismatch across multiple real NLP comparisons; identification-by-counting is shown to be commonly used in literature and often overclaims.",
            "root_cause": "Lack of specification of multiple-testing control in natural-language descriptions and analysis pipelines; misunderstanding of what per-test alpha implies for family-wise probabilities.",
            "mitigation_approach": "Use sequentially-rejective procedures valid under dependence (Holm) for identification; where appropriate and tolerable, use FDR-controlling methods (Benjamini–Hochberg) if proportion-of-errors control is acceptable.",
            "mitigation_effectiveness": "Holm procedure provides guaranteed control of probability of at least one false rejection under arbitrary dependence; empirically, the rejection lists matched the more conservative hat_k_Bonferroni and reduced false-positive identification relative to naive selection.",
            "domain_or_field": "Natural Language Processing / Statistical inference",
            "reproducibility_impact": true,
            "uuid": "e700.2",
            "source_info": {
                "paper_title": "Replicability Analysis for Natural Language Processing: Testing Significance with Multiple Datasets",
                "publication_date_yy_mm": "2017-09"
            }
        },
        {
            "name_short": "Replicability vs reproducibility confusion",
            "name_full": "Ambiguous use of 'replicability'/'reproducibility' and omitted experimental details",
            "brief_description": "Terminology and reporting gaps: papers sometimes conflate replicability (consistency across datasets) with reproducibility (re-running same code/data), and omit implementation specifics or dependency descriptions that are necessary to align natural-language claims with code behavior.",
            "citation_title": "Replicability Analysis for Natural Language Processing: Testing Significance with Multiple Datasets",
            "mention_or_use": "use",
            "system_name": "NLP experimental documentation and reporting",
            "system_description": "Natural-language statements in papers (introduction/methods) describing replicability goals and experimental setup, often without full code-level description of assumptions and dependencies.",
            "nl_description_type": "paper terminology and experimental protocol descriptions / methods sections",
            "code_implementation_type": "experiment scripts / released code repositories (where available) and analysis scripts",
            "gap_type": "ambiguous description / incomplete specification",
            "gap_description": "The paper notes confusion in the community between 'replicability' and 'reproducibility' and emphasizes that many papers do not fully specify dependencies between datasets or the multiple-testing handling in their natural-language descriptions; this omission creates a mismatch with code implementations which may or may not embody the required controls or assumptions.",
            "gap_location": "methods description / assumptions about datasets and statistical tests",
            "detection_method": "Literature review and discussion of community practice; reference to prior replication/replicability studies (e.g., Névéol et al., Marrese-Taylor & Matsuo) and examination of the lack of dependency analyses in prior NLP evaluations.",
            "measurement_method": "Qualitative assessment rather than a numeric metric in the paper; the authors demonstrate concrete statistical consequences (inflated error rates) as an indirect measurement of the effect of these omissions.",
            "impact_on_results": "Ambiguity and missing implementation-level detail lead to inconsistent interpretations, inappropriate choice of statistical procedures, and difficulty reproducing claimed conclusions across datasets; can materially change the set and number of datasets reported as supportive of claims.",
            "frequency_or_prevalence": "Common in NLP literature according to the paper's survey and examples; several referenced works either conflate terminology or omit detailed multiplicity handling.",
            "root_cause": "Ambiguous terminology, omitted procedural details in natural-language descriptions, lack of community standards for reporting dependency structure and multiple-testing treatment.",
            "mitigation_approach": "Clarify terminology, explicitly state assumptions (independence/ dependence), report multiple-testing procedures used, and release analysis code (authors provide their code repository) so code and natural-language descriptions align.",
            "mitigation_effectiveness": "Not quantified in the paper, but authors provide an implementation (code on GitHub) and demonstrate that explicitly-stated procedures (partial-conjunction tests and Holm) produce different and statistically-controlled outcomes, improving alignment between claims and implemented analysis.",
            "domain_or_field": "Natural Language Processing / Scientific reporting practices",
            "reproducibility_impact": true,
            "uuid": "e700.3",
            "source_info": {
                "paper_title": "Replicability Analysis for Natural Language Processing: Testing Significance with Multiple Datasets",
                "publication_date_yy_mm": "2017-09"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Screening for partial conjunction hypotheses",
            "rating": 2
        },
        {
            "paper_title": "Selective inference in complex research",
            "rating": 2
        },
        {
            "paper_title": "Controlling the false discovery rate: A practical and powerful approach to multiple testing",
            "rating": 2
        },
        {
            "paper_title": "Statistical comparisons of classifiers over multiple data sets",
            "rating": 2
        },
        {
            "paper_title": "An empirical investigation of statistical significance in NLP",
            "rating": 1
        },
        {
            "paper_title": "Estimating effect size across datasets",
            "rating": 1
        },
        {
            "paper_title": "Replication issues in syntax-based aspect extraction for opinion mining",
            "rating": 1
        },
        {
            "paper_title": "Replicability of research in biomedical natural language processing: a pilot evaluation for a coding task",
            "rating": 1
        }
    ],
    "cost": 0.01457525,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Replicability Analysis for Natural Language Processing: Testing Significance with Multiple Datasets</h1>
<p>Rotem Dror Gili Baumer Marina Bogomolov Roi Reichart<br>Faculty of Industrial Engineering and Management, Technion, IIT<br>{rtmdrr@campus|sgbaumer@campus|marinabo|roiri}.technion.ac.il</p>
<h4>Abstract</h4>
<p>With the ever growing amount of textual data from a large variety of languages, domains, and genres, it has become standard to evaluate NLP algorithms on multiple datasets in order to ensure a consistent performance across heterogeneous setups. However, such multiple comparisons pose significant challenges to traditional statistical analysis methods in NLP and can lead to erroneous conclusions. In this paper we propose a Replicability Analysis framework for a statistically sound analysis of multiple comparisons between algorithms for NLP tasks. We discuss the theoretical advantages of this framework over the current, statistically unjustified, practice in the NLP literature, and demonstrate its empirical value across four applications: multi-domain dependency parsing, multilingual POS tagging, cross-domain sentiment classification and word similarity prediction. ${ }^{1}$</p>
<h2>1 Introduction</h2>
<p>The field of Natural Language Processing (NLP) is going through the data revolution. With the persistent increase of the heterogeneous web, for the first time in human history, written language from multiple languages, domains, and genres is now abundant. Naturally, the expectations from NLP algorithms also grow and evaluating a new algorithm on as many languages, domains, and genres as possible is becoming a de-facto standard.</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup>For example, the phrase structure parsers of Charniak (2000) and Collins (2003) were mostly evaluated on the Wall Street Journal Penn Treebank (Marcus et al., 1993), consisting of written, edited English text of economic news. In contrast, modern dependency parsers are expected to excel on the 19 languages of the CoNLL 2006-2007 shared tasks on multilingual dependency parsing (Buchholz and Marsi, 2006; Nilsson et al., 2007), and additional challenges, such as the shared task on parsing multiple English Web domains (Petrov and McDonald, 2012), are continuously proposed.</p>
<p>Despite the growing number of evaluation tasks, the analysis toolbox employed by NLP researchers has remained quite stable. Indeed, in most experimental NLP papers, several algorithms are compared on a number of datasets where the performance of each algorithm is reported together with per-dataset statistical significance figures. However, with the growing number of evaluation datasets, it becomes more challenging to draw comprehensive conclusions from such comparisons. This is because although the probability of drawing an erroneous conclusion from a single comparison is small, with multiple comparisons the probability of making one or more false claims may be very high.</p>
<p>The goal of this paper is to provide the NLP community with a statistical analysis framework, which we term Replicability Analysis, which will allow us to draw statistically sound conclusions in evaluation setups that involve multiple comparisons. The classical goal of replicability analysis is to examine the consistency of findings across studies in order to address the basic dogma of science, that a find-</p>
<p>ing is more convincingly true if it is replicated in at least one more study (Heller et al., 2014; Patil et al., 2016). We adapt this goal to NLP, where we wish to ascertain the superiority of one algorithm over another across multiple datasets, which may come from different languages, domains, and genres. Finding that one algorithm outperforms another across domains gives a sense of consistency to the results and positive evidence that the better performance is not specific to a selected setup. ${ }^{2}$</p>
<p>In this work we address two questions: (1) Counting: For how many datasets does a given algorithm outperform another? and (2) Identification: What are these datasets?</p>
<p>When comparing two algorithms on multiple datasets, NLP papers often answer informally the questions we address in this work. In some cases this is done without any statistical analysis, by simply declaring better performance of a given algorithm for datasets where its performance measure is better than that of another algorithm, and counting these datasets. In other cases answers are based on the p -values from statistical tests performed for each dataset: declaring better performance for datasets with p-value below the significance level (e.g. 0.05) and counting these datasets. While it is clear that the first approach is not statistically valid, it seems that our community is not aware of the fact that the second approach, which may seem statistically sound, is not valid as well. This may lead to erroneous conclusions, which result in adopting new (and probably complicated) algorithms, while they are not better than previous (probably more simple) ones.</p>
<p>In this work, we demonstrate this problem and show that it becomes more severe as the number of evaluation sets grows, which seems to be the current trend in NLP. We adopt a known general statistical methodology for addressing the counting (question (1)) and identification (question (2)) problems, by choosing the tests and procedures which are valid for</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup>situations encountered in NLP problems, and giving specific recommendations for such situations.</p>
<p>Particularly, we first demonstrate (Section 3) that the current prominent approach in the NLP literature, identifying the datasets for which the difference between the performance of the algorithms reaches a predefined significance level according to some statistical significance test, does not guarantee to bound the probability to make at least one erroneous claim. Hence this approach is error-prone when the number of participating datasets is large. We thus propose an alternative approach (Section 4). For question (1), we adopt the approach of Benjamini et al. (2009) to replicability analysis of multiple studies, based on the partial conjunction framework of Benjamini and Heller (2008). This analysis comes with a guarantee that the probability of overestimating the true number of datasets with effect is upper bounded by a predefined constant. For question (2), we motivate a multiple testing procedure which guarantees that the probability of making at least one erroneous claim on the superiority of one algorithm over another is upper bounded by a predefined constant.</p>
<p>In Sections 5 and 6 we demonstrate how to apply the proposed frameworks to two synthetic data toy examples and four NLP applications: multidomain dependency parsing, multilingual POS tagging, cross-domain sentiment classification, and word similarity prediction with word embedding models. Our results demonstrate that the current practice in NLP for addressing our questions is error-prone, and illustrate the differences between it and the proposed statistically sound approach.</p>
<p>We hope that this work will encourage our community to increase the number of standard evaluation setups per task when appropriate (e.g. including additional languages and domains), possibly paving the way to hundreds of comparisons per study. This is due to two main reasons. First, replicability analysis is a statistically sound framework that allows a researcher to safely draw valid conclusions with well defined statistical guarantees. Moreover, this framework provides a means of summarizing a large number of experiments with a handful of easily interpretable numbers (e.g., see Table 1). This allows researchers to report results over a large number of comparisons in a concise manner, delving into details of particular comparisons when necessary.</p>
<h2>2 Previous Work</h2>
<p>Our work recognizes the current trend in the NLP community where, for many tasks and applications, the number of evaluation datasets constantly increases. We believe this trend is inherent to language processing technology due to the multiplicity of languages and of linguistic genres and domains. In order to extend the reach of NLP algorithms, they have to be designed so that they can deal with many languages and with the various domains of each. Having a sound statistical framework that can deal with multiple comparisons is hence crucial for the field.</p>
<p>This section is hence divided into two. We start by discussing representative examples for multiple comparisons in NLP, focusing on evaluations across multiple languages and multiple domains. We then discuss existing analysis frameworks for multiple comparisons, both in the NLP and in the machine learning literatures, pointing to the need for establishing new standards for our community.</p>
<p>Multiple Comparisons in NLP Multiple comparisons of algorithms over datasets from different languages, domains and genres have become a de-facto standard in many areas of NLP. Here we survey a number of representative examples. A full list of NLP tasks is beyond the scope of this paper.</p>
<p>A common multilingual example is, naturally, machine translation, where it is customary to compare algorithms across a large number of sourcetarget language pairs. This is done, for example, with the Europarl corpus consisting of 21 European languages (Koehn, 2005; Koehn and Schroeder, 2007) and with the datasets of the WMT workshop series with its multiple domains (e.g. news and biomedical in 2017), each consisting of several language pairs ( 7 and 14 , respectively, in 2017).</p>
<p>Multiple dataset comparisons are also abundant in domain adaptation work. Representative tasks include named entity recognition (Guo et al., 2009), POS tagging (Daumé III, 2007), dependency parsing (Petrov and McDonald, 2012), word sense disambiguation (Chan and Ng, 2007) and sentiment classification (Blitzer et al., 2006; Blitzer et al., 2007).</p>
<p>More recently, with the emergence of crowdsourcing that makes data collection cheap and fast (Snow et al., 2008), an ever growing number of datasets is being created. This is particularly notice-
able in lexical semantics tasks that have become central in NLP research due to the prominence of neural networks. For example, it is customary to compare word embedding models (Mikolov et al., 2013; Pennington et al., 2014; Ó Séaghdha and Korhonen, 2014; Levy and Goldberg, 2014; Schwartz et al., 2015) on multiple datasets where word pairs are scored according to the degree to which different semantic relations, such as similarity and association, hold between the members of the pair (Finkelstein et al., 2001a; Bruni et al., 2014; Silberer and Lapata, 2014; Hill et al., 2015). In some works (e.g., Baroni et al. (2014)) these embedding models are compared across a large number of simple tasks.</p>
<p>As discussed in Section 1, the outcomes of such comparisons are often summarized in a table that presents numerical performance values, usually accompanied by statistical significance figures and sometimes also with cross-comparison statistics such as average performance figures. Here, we analyze the conclusions that can be drawn from this information and suggest that with the growing number of comparisons, a more intricate analysis is required.</p>
<p>Existing Analysis Frameworks Machine learning work on multiple dataset comparisons dates back to Dietterich (1998) who raised the question: "given two learning algorithms and datasets from several domains, which algorithm will produce more accurate classifiers when trained on examples from new domains?". The seminal work that proposed practical means for this problem is that of Demšar (2006). Given performance measures for two algorithms on multiple datasets, the authors test whether there is at least one dataset on which the difference between the algorithms is statistically significant. For this goal they propose methods such as a paired t-test, a nonparametric sign-rank test and a wins/losses/ties count, all computed across the results collected from all participating datasets. In contrast, our goal is to count and identify the datasets for which one algorithm significantly outperforms the other, which provides more intricate information, especially when the datasets come from different sources.</p>
<p>In NLP, several studies addressed the problem of measuring the statistical significance of results on a single dataset (e.g., Berg-Kirkpatrick et al. (2012); Søgaard (2013); Søgaard et al. (2014)). Søgaard</p>
<p>(2013) is, to the best of our knowledge, the only work that addressed the statistical properties of evaluation with multiple datasets. For this aim he modified the statistical tests proposed in Demšar (2006) to use a Gumbel distribution assumption on the test statistics, which he considered to suit NLP better than the original Gaussian assumption. However, while this procedure aims to estimate the effect size across datasets, it answers neither the counting nor the identification question of Section 1.</p>
<p>In the next section we provide the preliminary knowledge from the field of statistics that forms the basis for the proposed framework and then proceed with its description.</p>
<h2>3 Preliminaries</h2>
<p>We start by formulating a general hypothesis testing framework for a comparison between two algorithms. This is a common type of hypothesis testing framework applied in NLP, its detailed formulation will help us develop our ideas.</p>
<h3>3.1 Hypothesis Testing</h3>
<p>We wish to compare between two algorithms, $A$ and $B$. Let $X$ be a collection of datasets $X=\left{X^{1}, X^{2}, \ldots, X^{N}\right}$, where for all $i \in$ ${1, \ldots, N}, X^{i}=\left{x_{i, 1}, \ldots, x_{i, n_{i}}\right}$. Each dataset $X^{i}$ can be of a different language or a different domain. We denote by $x_{i, k}$ the granular unit on which results are being measured, that, in most NLP tasks, is a word or a sequence of words. The difference in performance between the two algorithms is measured using one or more of the evaluation measures in the set $\mathcal{M}=\left{\mathcal{M}<em m="m">{1}, \ldots, \mathcal{M}</em>$}\right} .^{3</p>
<p>Let us denote $\mathcal{M}<em j="j">{j}\left(A L G, X^{i}\right)$ as the value of the measure $\mathcal{M}</em>$ as:}$ when algorithm $A L G$ is applied on the dataset $X^{i}$. Without loss of generality, we assume that higher values of the measure are better. We define the difference in performance between two algorithms, $A$ and $B$, according to the measure $\mathcal{M}_{j}$ on the dataset $X^{i</p>
<p>$$
\delta_{j}\left(X^{i}\right)=\mathcal{M}<em j="j">{j}\left(A, X^{i}\right)-\mathcal{M}</em>\right)
$$}\left(B, X^{i</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup>Finally, using this notation we formulate the following statistical hypothesis testing problem:</p>
<p>$$
\begin{aligned}
&amp; H_{0 i}(j): \delta_{j}\left(X^{i}\right) \leq 0 \
&amp; H_{1 i}(j): \delta_{j}\left(X^{i}\right)&gt;0
\end{aligned}
$$</p>
<p>The null hypothesis, stating that there is no difference between the performance of algorithm $A$ and algorithm $B$, or that $B$ performs better, is tested versus the alternative statement that $A$ is superior. If the statistical test results in rejecting the null hypothesis, one concludes that $A$ outperforms $B$ in this setup. Otherwise, there is not enough evidence in the data to make this conclusion.</p>
<p>Rejection of the null hypothesis when it is true is termed type I error, and non-rejection of the null hypothesis when the alternative is true is termed type II error. The classical approach to hypothesis testing is to find a test that guarantees that the probability of making a type I error is upper bounded by a predefined constant $\alpha$, the test significance level, while achieving as low probability of type II error as possible, a.k.a "achieving as high power as possible".</p>
<p>We next turn to the case where the difference between two algorithms is tested across multiple datasets.</p>
<h3>3.2 The Multiplicity Problem</h3>
<p>Equation 1 defines a multiple hypothesis testing problem when considering the formulation for all $N$ datasets. If $N$ is large, testing each hypothesis separately at the nominal significance level may result in a high number of erroneously rejected null hypotheses. In our context, when the performance of algorithm $A$ is compared to that of algorithm $B$ across multiple datasets, and for each dataset algorithm $A$ is declared as superior, based on a statistical test at the nominal significance level $\alpha$, the expected number of erroneous claims may grow as $N$ grows.</p>
<p>For example, if a single test is performed with a significance level of $\alpha=0.05$, there is only a $5 \%$ chance of incorrectly rejecting the null hypothesis. On the other hand, for 100 tests where all null hypotheses are true, the expected number of incorrect rejections is $100 \cdot 0.05=5$. Denoting the total number of type I errors as $V$, we can see below that if the test statistics are independent then the probability of</p>
<p>making at least one incorrect rejection is 0.994 :</p>
<p>$$
\begin{aligned}
&amp; \mathbb{P}(V&gt;0)=1-\mathbb{P}(V=0)= \
&amp; 1-\prod_{i=1}^{100} \mathbb{P}(\text { no type I error in } i)=1-(1-0.05)^{100}
\end{aligned}
$$</p>
<p>This demonstrates that the naive method of counting the datasets for which significance was reached at the nominal level is error-prone. Similar examples can be constructed for situations where some of the null hypotheses are false.</p>
<p>The multiple testing literature proposes various procedures for bounding the probability of making at least one type I error, as well as other, less restrictive error criteria (see a survey in Farcomeni (2007)). In this paper, we address the questions of counting and identifying the datasets for which algorithm $A$ outperforms $B$, with certain statistical guarantees regarding erroneous claims. While identifying the datasets gives more information when compared to just declaring their number, we consider these two questions separately. As our experiments show, according to the statistical analysis we propose the estimated number of datasets with effect (question 1) may be higher than the number of identified datasets (question 2). We next present the fundamentals of the partial conjunction framework which is at the heart of our proposed methods.</p>
<h3>3.3 Partial Conjunction Hypotheses</h3>
<p>We start by reformulating the set of hypothesis testing problems of Equation 1 as a unified hypothesis testing problem. This problem aims to identify whether algorithm $A$ is superior to $B$ across all datasets. The notation for the null hypothesis in this problem is $H_{0}^{N / N}$ since we test if $N$ out of $N$ alternative hypotheses are true:</p>
<p>$$
H_{0}^{N / N}: \bigcup_{i=1}^{N} H_{0 i} \text { is true } \quad v s . \quad H_{1}^{N / N}: \bigcap_{i=1}^{N} H_{1 i} \text { is true. }
$$</p>
<p>Requiring the rejection of the disjunction of all null hypotheses is often too restrictive for it involves observing a significant effect on all datasets, $i \in{1, \ldots, N}$. Instead, one can require a rejection of the global null hypothesis stating that all individual null hypotheses are true, i.e., evidence that
at least one alternative hypothesis is true. This hypothesis testing problem is formulated as follows:
$H_{0}^{1 / N}: \bigcap_{i=1}^{N} H_{0 i}$ is true $v s . \quad H_{1}^{1 / N}: \bigcup_{i=1}^{N} H_{1 i}$ is true.
Obviously, rejecting the global null may not provide enough information: it only indicates that algorithm $A$ outperforms $B$ on at least one dataset. Hence, this claim does not give any evidence for the consistency of the results across multiple datasets.</p>
<p>A natural compromise between the above two formulations is to test the partial conjunction null, which states that the number of false null hypotheses is lower than $u$, where $1 \leq u \leq N$ is a pre-specified integer constant. The partial conjunction test contrasts this statement with the alternative statement that at least $u$ out of the $N$ null hypotheses are false.
Definition 1 (Benjamini and Heller (2008)). Consider $N \geq 2$ null hypotheses: $H_{01}, H_{02}, \ldots, H_{0 N}$, and let $p_{1}, \ldots, p_{N}$ be their associated $p$-values. Let $k$ be the true unknown number of false null hypotheses, then our question "Are at least $u$ out of $N$ null hypotheses false?" can be formulated as follows:</p>
<p>$$
H_{0}^{u / N}: k&lt;u \quad v s . \quad H_{1}^{u / N}: k \geq u
$$</p>
<p>In our context, $k$ is the number of datasets where algorithm $A$ is truly better, and the partial conjunction test examines whether algorithm $A$ outperforms algorithm $B$ in at least $u$ of $N$ cases.</p>
<p>Benjamini and Heller (2008) developed a general method for testing the above hypothesis for a given $u$. They also showed how to extend their method in order to answer our counting question. We next describe their framework and advocate a different, yet related method for dataset identification.</p>
<h2>4 Replicability Analysis for NLP</h2>
<p>Referred to as the cornerstone of science (Moonesinghe et al., 2007), replicability analysis is of predominant importance in many scientific fields including psychology (Collaboration, 2012), genomics (Heller et al., 2014), economics (Herndon et al., 2014) and medicine (Begley and Ellis, 2012), among others. Findings are usually considered as replicated if they are obtained in two or more</p>
<p>studies that differ from each other in some aspects (e.g. language, domain or genre in NLP).</p>
<p>The replicability analysis framework we employ (Benjamini and Heller, 2008; Benjamini et al., 2009) is based on partial conjunction testing. Particularly, these authors have shown that a lower bound on the number of false null hypotheses with a confidence level of $1-\alpha$ can be obtained by finding the largest $u$ for which we can reject the partial conjunction null hypothesis $H_{0}^{u / N}$ along with $H_{0}^{1 / N}, \ldots, H_{0}^{(u-1) / N}$ at a significance level $\alpha$. Since rejecting $H_{0}^{u / N}$ means that we see evidence in at least $u$ out of $N$ datasets, algorithm $A$ is superior to $B$. This lower bound on $k$ is taken as our answer to the Counting question of Section 1.</p>
<p>In line with the hypothesis testing framework of Section 3, the partial conjunction null, $H_{0}^{u / N}$, is rejected at level $\alpha$ if $p^{u / N} \leq \alpha$, where $p^{u / N}$ is the partial conjunction $p$-value. Based on the known methods for testing the global null hypothesis (see, e.g., Loughin (2004)), Benjamini and Heller (2008) proposed methods for combining the $p$-values $p_{1}, \ldots, p_{N}$ of $H_{01}, H_{02}, \ldots, H_{0 N}$ in order to obtain $p^{u / N}$. Below, we describe two such methods and their properties.</p>
<h3>4.1 The Partial Conjunction $p$-value</h3>
<p>The methods we focus on were developed by Benjamini and Heller (2008), and are based on Fisher's and Bonferroni's methods for testing the global null hypothesis. For brevity, we name them Bonferroni and Fisher. We choose them because they are valid in different setups that are frequently encountered in NLP (Section 6): Bonferroni for dependent datasets and both Fisher and Bonferroni for independent datasets. ${ }^{4}$</p>
<p>Bonferroni's method does not make any assumptions about the dependencies between the participating datasets and it is hence applicable in NLP tasks, since in NLP it is most often hard to determine the type of dependence between the datasets. Fisher's method, while assuming independence across the</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup>participating datasets, is often more powerful than Bonferroni's method (see Loughin (2004) and Benjamini and Heller (2008) for other methods and a comparison between them). Our recommendation is hence to use the Bonferroni's method when the datasets are dependent and to use the more powerful Fisher's method when the datasets are independent.</p>
<p>Let $p_{(i)}$ be the $i$-th smallest $p$-value among $p_{1}, \ldots, p_{N}$. The partial conjunction $p$-values are:</p>
<p>$$
\begin{aligned}
&amp; p_{\text {Bonferroni }}^{u / N}=(N-u+1) p_{(u)} \
&amp; p_{\text {Fisher }}^{u / N}=\mathbb{P}\left(\chi_{2(N-u+1)}^{2} \geq-2 \sum_{i=u}^{N} \ln p_{(i)}\right)
\end{aligned}
$$</p>
<p>where $\chi_{2(N-u+1)}^{2}$ denotes a chi-squared random variable with $2(N-u+1)$ degrees of freedom.</p>
<p>To understand the reasoning behind these methods, let us consider first the above $p$-values for testing the global null, i.e., for the case of $u=1$. Rejecting the global null hypothesis requires evidence that at least one null hypothesis is false. Intuitively, we would like to see one or more small $p$-values.</p>
<p>Both of the methods above agree with this intuition. Bonferroni's method rejects the global null if $p_{(1)} \leq \alpha / N$, i.e. if the minimum $p$-value is small enough, where the threshold guarantees that the significance level of the test is $\alpha$ for any dependency among the $p$-values $p_{1}, \ldots, p_{N}$. Fisher's method rejects the global null for large values of $-2 \sum_{i=1}^{N} \ln p_{(i)}$, or equivalently for small values of $\prod_{i=1}^{N} p_{i}$. That is, while both these methods are intuitive, they are different. Fisher's method requires a small enough product of $p$-values as evidence that at least one null hypothesis is false. Bonferroni's method, on the other hand, requires as evidence at least one small enough $p$-value.</p>
<p>For the case $u=N$, i.e., when the alternative states that all null hypotheses are false, both methods require that the maximal $p$-value is small enough for rejection of $H_{0}^{N / N}$. This is also intuitive because we expect that all the $p$-values will be small when all the null hypotheses are false. For other cases, where $1&lt;u&lt;N$, the reasoning is more complicated and is beyond the scope of this paper.</p>
<p>The partial conjunction test for a specific $u$ answers the question "Does algorithm A perform better than B on at least $u$ datasets?" The next step is</p>
<p>the estimation of the number of datasets for which algorithm $A$ performs better than $B$.</p>
<h3>4.2 Dataset Counting (Question 1)</h3>
<p>Recall that the number of datasets where algorithm $A$ outperforms algorithm $B$ (denoted with $k$ in Definition 1) is the true number of false null hypotheses in our problem. Benjamini and Heller (2008) proposed to estimate $k$ to be the largest $u$ for which $H_{0}^{u / N}$, along with $H_{0}^{1 / N}, \ldots, H_{0}^{(u-1) / N}$ is rejected. Specifically, the estimator $\hat{k}$ is defined as follows:</p>
<p>$$
\hat{k}=\max \left{u: p_{*}^{u / N} \leq \alpha\right}
$$</p>
<p>where $p_{<em>}^{u / N}=\max \left{p_{</em>}^{(u-1) / N}, p^{u / N}\right}, p^{1 / N}=p_{*}^{1 / N}$ and $\alpha$ is the desired upper bound on the probability to overestimate the true $k$. It is guaranteed that $\mathbb{P}(\hat{k}&gt;k) \leq \alpha$ as long as the $p$-value combination method used for constructing $p^{u / N}$ is valid for the given dependency across the test statistics. ${ }^{5}$ When $\hat{k}$ is based on $p_{\text {Bonferroni }}^{u / N}$ it is denoted with $\hat{k}<em _Fisher="{Fisher" _text="\text">{\text {Bonferroni }}$; when it is based on $p</em>$.}}^{u / N}$, it is denoted with $\hat{k}_{\text {Fisher }</p>
<p>A crucial practical consideration, when choosing between $\hat{k}<em _Fisher="{Fisher" _text="\text">{\text {Bonferroni }}$ and $\hat{k}</em>$, the same considerations hold when choosing between them.}}$, is the assumed dependency between the datasets. As discussed in Section 4.1, $p_{\text {Fisher }}^{u / N}$ is recommended when the participating datasets are assumed to be independent; when this assumption cannot be made, only $p_{\text {Bonferroni }}^{u / N}$ is appropriate. As the $\hat{k}$ estimators are based on the respective $p^{u / N} \mathrm{~s</p>
<p>With the $\hat{k}$ estimators, one can answer the counting question of Section 1, reporting that algorithm $A$ is better than algorithm $B$ in at least $\hat{k}$ out of $N$ datasets with a confidence level of $1-\alpha$. Regarding the identification question, a natural approach would be to declare the $\hat{k}$ datasets with the smallest $p$-values as those for which the effect holds. However, with $\hat{k}<em _Bonferroni="{Bonferroni" _text="\text">{\text {Fisher }}$ this approach does not guarantee control over type I errors. In contrast, for $\hat{k}</em>$, the above approach comes with such guarantees, as described in the next section.}</p>
<p><sup id="fnref5:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<h3>4.3 Dataset Identification (Question 2)</h3>
<p>As demonstrated in Section 3.2, identifying the datasets with $p$-value below the nominal significance level and declaring them as those where algorithm $A$ is better than $B$ may lead to a very high number of erroneous claims. A variety of methods exist for addressing this problem. A classical and very simple method for addressing this problem is named the Bonferroni's procedure, which compensates for the increased probability of making at least one type I error by testing each individual hypothesis at a significance level of $\alpha^{\prime}=\alpha / N$, where $\alpha$ is the predefined bound on this probability and $N$ is the number of hypotheses tested. ${ }^{6}$ While Bonferroni's procedure is valid for any dependency among the $p$-values, the probability of detecting a true effect using this procedure is often very low, because of its strict $p$-value threshold.</p>
<p>Many other procedures controlling the above or other error criteria, and having less strict $p$-value thresholds, have been proposed. Below we advocate one of these methods: the Holm procedure (Holm, 1979). This is a simple $p$-value based procedure that is concordant with the partial conjunction analysis when $p_{\text {Bonferroni }}^{u / N}$ is used in that analysis. Importantly for NLP applications, Holm controls the probability of making at least one type I error for any type of dependency between the participating datasets (see a demonstration in Section 6).</p>
<p>Let $\alpha$ be the desired upper bound on the probability that at least one false rejection occurs, let $p_{(1)} \leq$ $p_{(2)} \leq \ldots \leq p_{(N)}$ be the ordered $p$-values and let the associated hypotheses be $H_{(1)} \ldots H_{(N)}$. The Holm procedure for identifying the datasets with a significant effect is given below.</p>
<h2>Procedure Holm</h2>
<p>1) Let $k$ be the minimal index such that $p_{(k)}&gt;\frac{\alpha}{N+1-k}$.
2) Reject the null hypotheses $H_{(1)} \ldots H_{(k-1)}$ and do not reject $H_{(k)} \ldots H_{(N)}$. If no such $k$ exists, then reject all null hypotheses.</p>
<p>The output of the Holm procedure is a rejection</p>
<p><sup id="fnref:1"><a class="footnote-ref" href="#fn:1">2</a></sup></p>
<p>list of null hypotheses; the corresponding datasets are those we return in response to the identification question of Section 1. Note that the Holm procedure rejects a subset of hypotheses with p-value below $\alpha$. Each p-value is compared to a threshold which is smaller or equal to $\alpha$ and depends on the number of evaluation datasets $N$. The dependence of the thresholds on $N$ can be intuitively explained as follows: the probability of making one or more erroneous claims may increase with $N$, as demonstrated in Section 3.2. Therefore, in order to bound this probability by a pre-specified level $\alpha$, the thresholds for p -values should depend on $N$.</p>
<p>It can be shown that the Holm procedure at level $\alpha$ always rejects the $\hat{k}<em _Bonferroni="{Bonferroni" _text="\text">{\text {Bonferroni }}$ hypotheses with the smallest $p$-values, where $\hat{k}</em>}}$ is the lower bound for $k$ with a confidence level of $1-\alpha$. Therefore, $\hat{k<em _Bonferroni="{Bonferroni" _text="\text">{\text {Bonferroni }}$ corresponding to a confidence level of $1-\alpha$ is always smaller or equal to the number of datasets for which the difference between the compared algorithms is significant at level $\alpha$. This is not surprising in view of the fact that, without making any assumptions on the dependencies among the datasets, $\hat{k}</em>&gt;k)$ is bounded by $\alpha$, when simply counting the number of datasets with p -value below $\alpha$, the probability of making a too optimistic claim may be close to 1 , as demonstrated in Section 5.}}$ guarantees that the probability of making a too optimistic claim $(\hat{k</p>
<p>Framework Summary Following Section 4.2 we answer the counting question of Section 1 by reporting either $\hat{k}<em _Bonferroni="{Bonferroni" _text="\text">{\text {Fisher }}$ (when all datasets can be assumed to be independent) or $\hat{k}</em>$ (when such an independence assumption cannot be made). Based on Section 4.3 we suggest to answer the identification question of Section 1 by reporting the rejection list returned by the Holm procedure.}</p>
<p>Our proposed framework is based on certain assumptions regarding the experiments conducted in NLP setups. The most prominent of these assumptions states that for dependent datasets the type of dependency cannot be determined. Indeed, to the best of our knowledge, the nature of the dependency between dependent test sets in NLP work has not been analyzed before. In Section 7 we revisit our assumptions and point to alternative methods for answering our questions. These methods may be ap-
<img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: $\hat{k}$ histogram for the independent datasets simulation.
propriate under other assumptions that may become relevant in future.</p>
<p>We next demonstrate the value of the proposed replicability analysis through toy examples with synthetic data (Section 5) as well as analysis of state-of-the-art algorithms for four major NLP applications (Section 6). Our point of reference is the standard, yet statistically unjustified, counting method that sets its estimator, $\hat{k}<em _count="{count" _text="\text">{\text {count }}$, to the number of datasets for which the difference between the compared algorithms is significant with $p$-value $\leq \alpha\left(\right.$ i.e. $\left.\hat{k}</em>$}}=#\left{i: p_{i} \leq \alpha\right}\right){ }^{7</p>
<h2>5 Toy Examples</h2>
<p>For the examples of this section we synthesize $p$-values to emulate a test with $N=100$ hypotheses (domains), and set $\alpha$ to 0.05 . We start with a simulation of a scenario where algorithm $A$ is equivalent to $B$ for each domain, and the datasets representing these domains are independent. We sample the $100 p$-values from a standard uniform distribution, which is the $p$-value distribution under the null hypothesis, repeating the simulation 1,000 times.</p>
<p>Since all the null hypotheses are true then $k$, the number of false null hypotheses, is 0 . Figure 1 presents the histogram of $\hat{k}$ values from all 1,000 iterations according to $\hat{k}<em _Fisher="{Fisher" _text="\text">{\text {Bonferroni }}, \hat{k}</em>$.}}$ and $\hat{k}_{\text {count }</p>
<p>The figure clearly demonstrates that $\hat{k}<em _Bonferroni="{Bonferroni" _text="\text">{\text {count }}$ provides an overestimation of $k$ while $\hat{k}</em>}}$ and $\hat{k<em _count="{count" _text="\text">{\text {Fisher }}$ do much better. Indeed, the histogram yields the following probability estimates: $\hat{P}\left(\hat{k}</em>&gt;\right.$}</p>
<p><sup id="fnref6:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>$k)=0.963, \hat{P}\left(\hat{k}<em _Fisher="{Fisher" _text="\text">{\text {Bonferroni }}&gt;k\right)=0.001$ and $\hat{P}\left(\hat{k}</em>&gt;k\right)=0.021$ (only the latter two are lower than 0.05 ). This simulation strongly supports the theoretical results of Section 4.2.}</p>
<p>To consider a scenario where a dependency between the participating datasets does exist, we consider a second toy example. In this example we generate $N=100 p$-values corresponding to 34 independent normal test statistics, and two other groups of 33 positively correlated normal test statistics with $\rho=0.2$ and $\rho=0.5$, respectively. We again assume that all null hypotheses are true and thus all the $p$-values are distributed uniformly, repeating the simulation 1,000 times. To generate positively dependent $p$-values, we followed the process described in Section 6.1 of Benjamini et al. (2006).</p>
<p>We estimate the probability that $\hat{k}&gt;k=0$ for the three $\hat{k}$ estimators based on the 1000 repetitions and get the values of: $\hat{P}\left(\hat{k}<em _Bonferroni="{Bonferroni" _text="\text">{\text {count }}&gt;k\right)=0.943$, $\hat{P}\left(\hat{k}</em>&gt;\right.$ $k)=0.234$. This simulation demonstrates the importance of using Bonferroni's method rather than Fisher's method when the datasets are dependent, even if some of the datasets are independent.}}&gt;k\right)=0.046$ and $\hat{P}\left(\hat{k}_{\text {Fisher }</p>
<h2>6 NLP Applications</h2>
<p>In this section we demonstrate the potential impact of replicability analysis on the way experimental results are analyzed in NLP setups. We explore four NLP applications: (a) two where the datasets are independent: multi-domain dependency parsing and multilingual POS tagging; and (b) two where dependency between the datasets does exist: cross-domain sentiment classification and word similarity prediction with word embedding models.</p>
<h3>6.1 Data</h3>
<p>Dependency Parsing We consider a multidomain setup, analyzing the results reported in Choi et al. (2015). The authors compared ten state-of-the-art parsers from which we pick three: (a) Mate (Bohnet, 2010) ${ }^{8}$ that performed best on the majority of datasets; (b) Redshift (Honnibal et al., 2013) ${ }^{9}$ which demonstrated comparable, still somewhat lower, performance compared to Mate;</p>
<p><sup id="fnref7:0"><a class="footnote-ref" href="#fn:0">1</a></sup>and (c) SpaCy (Honnibal and Johnson, 2015) that was substantially outperformed by Mate.</p>
<p>All parsers were trained and tested on the English portion of the OntoNotes 5 corpus (Weischedel et al., 2011; Pradhan et al., 2013), a large multigenre corpus consisting of the following 7 genres: broadcasting conversations (BC), broadcasting news (BN), news magazine (MZ), newswire (NW), pivot text (PT), telephone conversations (TC) and web text (WB). Train and test set size (in sentences) range from 6672 to 34,492 and from 280 to 2327 , respectively (see Table 1 of Choi et al. (2015)). We copy the test set UAS results of Choi et al. (2015) and compute $p$-values using the data downloaded from http://amandastent.com/dependable/.</p>
<p>POS Tagging We consider a multilingual setup, analyzing the results reported in (Pinter et al., 2017). The authors compare their Mimick model with the model of Ling et al. (2015), denoted with CHAR $\rightarrow$ TAG. Evaluation is performed on 23 of the 44 languages shared by the Polyglot word embedding dataset (Al-Rfou et al., 2013) and the universal dependencies (UD) dataset (De Marneffe et al., 2014). Pinter et al. (2017) choose their languages so that they reflect a variety of typological, and particularly morphological, properties. The training/test split is the standard UD split. We copy the word level accuracy figures of Pinter et al. (2017) for the low resource training set setup, the focus setup of that paper. The authors kindly sent us their $p$-values.</p>
<p>Sentiment Classification In this task, an algorithm is trained on reviews from one domain and should classify the sentiment of reviews from another domain to the positive and negative classes. For replicability analysis we explore the results of Ziser and Reichart (2017) for the cross-domain sentiment classification task of Blitzer et al. (2007). The data in this task consists of Amazon product reviews from 4 domains: books (B), DVDs (D), electronic items (E), and kitchen appliances (K), for the total of 12 domain pairs, each domain having a 2000 review test set. ${ }^{10}$ Ziser and Reichart (2017) compared the accuracy of their AE-SCL-SR model to MSDA (Chen et al., 2011), a well known domain adaptation</p>
<p><sup id="fnref2:1"><a class="footnote-ref" href="#fn:1">2</a></sup></p>
<p>method, and kindly sent us the required $p$-values.
Word Similarity We compare two state-of-the-art word embedding collections: (a) word2vec CBOW (Mikolov et al., 2013) vectors, generated by the model titled the best "predict" model in Baroni et al. (2014); ${ }^{11}$ and (b) GloVe (Pennington et al., 2014) vectors generated by a model trained on a 42B token common web crawl. ${ }^{12}$ We employed the demo of Faruqui and Dyer (2014) to perform a Spearman correlation evaluation of these vector collections on 12 English word pair datasets: WS-353 (Finkelstein et al., 2001b), WS-353-SIM (Agirre et al., 2009), WS-353-REL (Agirre et al., 2009), MC-30 (Miller and Charles, 1991), RG-65 (Rubenstein and Goodenough, 1965), Rare-Word (Luong et al., 2013), MEN (Bruni et al., 2012), MTurk-287 (Radinsky et al., 2011), MTurk-771 (Halawi et al., 2012), YP-130 (Yang and Powers, ), SimLex-999 (Hill et al., 2016), and Verb-143 (Baker et al., 2014).</p>
<h3>6.2 Statistical Significance Tests</h3>
<p>We first calculate the $p$-values for each task and dataset according to the principals of $p$-values computation for NLP as discussed in Yeh (2000), BergKirkpatrick et al. (2012) and Søgaard et al. (2014).</p>
<p>For dependency parsing, we employ the aparametric paired bootstrap test (Efron and Tibshirani, 1994) that does not assume any distribution on the test statistics. We chose this test because the distribution of the values for the measures commonly applied in this task is unknown. We implemented the test as in (Berg-Kirkpatrick et al., 2012) with a bootstrap size of 500 and with $10^{5}$ repetitions.</p>
<p>For multilingual POS tagging, we employ the Wilcoxon signed-rank test (Wilcoxon, 1945) on the differences of the sentence level accuracy scores of the two compared models. This test is a nonparametric test for differences in measure, testing the null hypothesis that the difference has a symmetric distribution around zero. It is appropriate for tasks with paired continuous measures for each observation, which is the case when comparing sentence level accuracies.</p>
<p><sup id="fnref8:0"><a class="footnote-ref" href="#fn:0">1</a></sup>For sentiment classification we employ the McNemar test for paired nominal data (McNemar, 1947). This test is appropriate for binary classification tasks and since we compare the results of the algorithms when applied on the same datasets, we employ its paired version. Finally, for word similarity with its Spearman correlation evaluation, we choose the Steiger test (Steiger, 1980) for comparing elements in a correlation matrix.</p>
<p>We consider the case of $\alpha=0.05$ for all four applications. For the dependent datasets experiments (sentiment classification and word similarity prediction) with their generally lower $p$-values (see below), we also consider the case where $\alpha=0.01$.</p>
<h3>6.3 Results</h3>
<p>Table 1 summarizes the replicability analysis results while Table $2-5$ present task specific performance measures and $p$-values.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">$\bar{k}_{\text {count }}$</th>
<th style="text-align: center;">$\bar{k}_{\text {Bonf. }}$</th>
<th style="text-align: center;">$\bar{k}_{\text {Fish. }}$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Independent Datasets</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Dependency Parsing (7 datasets)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Mate-SpaCy</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">7</td>
</tr>
<tr>
<td style="text-align: center;">Mate-Redshift</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td style="text-align: center;">Multilingual POS Tagging (23 datasets)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Mimick-Char $\rightarrow$ Tag</td>
<td style="text-align: center;">11</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">16</td>
</tr>
<tr>
<td style="text-align: center;">Dependent Datasets</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Sentiment Classification (12 setups)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">AE-SCL-SR-MSDA <br> $(\alpha=0.05)$</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">10</td>
</tr>
<tr>
<td style="text-align: center;">AE-SCL-SR-MSDA <br> $(\alpha=0.01)$</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">8</td>
</tr>
<tr>
<td style="text-align: center;">Word Similarity (12 datasets)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">W2V-GloVe <br> $(\alpha=0.05)$</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">7</td>
</tr>
<tr>
<td style="text-align: center;">W2V-GloVe <br> $(\alpha=0.01)$</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">6</td>
</tr>
</tbody>
</table>
<p>Table 1: Replicability analysis results. The appropriate estimator for each scenario is in bold. For independent datasets $\alpha=0.05 . \bar{k}<em _Fisher="{Fisher" _text="\text">{\text {count }}$ is based on the current practice in the NLP literature and does not have statistical guarantees regarding overestimation of the true $k$. Likewise, $\bar{k}</em>$ does not provide statistical guarantees regarding the overestimation of the true $k$ for dependent datasets.}</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Model $\mid$ Data</th>
<th style="text-align: center;">BC</th>
<th style="text-align: center;">BN</th>
<th style="text-align: center;">MZ</th>
<th style="text-align: center;">NW</th>
<th style="text-align: center;">PT</th>
<th style="text-align: center;">TC</th>
<th style="text-align: center;">WB</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Mate</td>
<td style="text-align: center;">90.73</td>
<td style="text-align: center;">90.82</td>
<td style="text-align: center;">91.92</td>
<td style="text-align: center;">91.68</td>
<td style="text-align: center;">96.64</td>
<td style="text-align: center;">89.87</td>
<td style="text-align: center;">89.89</td>
</tr>
<tr>
<td style="text-align: center;">SpaCy</td>
<td style="text-align: center;">89.05</td>
<td style="text-align: center;">89.31</td>
<td style="text-align: center;">89.29</td>
<td style="text-align: center;">89.52</td>
<td style="text-align: center;">95.27</td>
<td style="text-align: center;">87.65</td>
<td style="text-align: center;">87.40</td>
</tr>
<tr>
<td style="text-align: center;">$p$-val (Mate,SpaCy)</td>
<td style="text-align: center;">$\left(10^{-4}\right)$</td>
<td style="text-align: center;">$\left(10^{-4}\right)$</td>
<td style="text-align: center;">$(0.0)$</td>
<td style="text-align: center;">$(0.0)$</td>
<td style="text-align: center;">$\left(2 \cdot 10^{-4}\right)$</td>
<td style="text-align: center;">$\left(9 \cdot 10^{-4}\right)$</td>
<td style="text-align: center;">$(0.0)$</td>
</tr>
<tr>
<td style="text-align: center;">Redshift</td>
<td style="text-align: center;">90.19</td>
<td style="text-align: center;">90.46</td>
<td style="text-align: center;">90.90</td>
<td style="text-align: center;">90.99</td>
<td style="text-align: center;">96.22</td>
<td style="text-align: center;">88.99</td>
<td style="text-align: center;">89.31</td>
</tr>
<tr>
<td style="text-align: center;">$p$-val (Mate,Redshift)</td>
<td style="text-align: center;">$(0.0979)$</td>
<td style="text-align: center;">$(0.1662)$</td>
<td style="text-align: center;">$(0.0046)$</td>
<td style="text-align: center;">$(0.0376)$</td>
<td style="text-align: center;">$(0.0969)$</td>
<td style="text-align: center;">$(0.0912)$</td>
<td style="text-align: center;">$(0.0823)$</td>
</tr>
</tbody>
</table>
<p>Table 2: UAS results for multi-domain dependency parsing. $p$-values are in parentheses.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Language</th>
<th style="text-align: center;">Mimick</th>
<th style="text-align: center;">Char $\rightarrow$ Tag</th>
<th style="text-align: center;">$p$-value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Kazakh</td>
<td style="text-align: center;">83.95</td>
<td style="text-align: center;">83.64</td>
<td style="text-align: center;">0.0944</td>
</tr>
<tr>
<td style="text-align: center;">Tamil*</td>
<td style="text-align: center;">81.55</td>
<td style="text-align: center;">84.97</td>
<td style="text-align: center;">0.0001</td>
</tr>
<tr>
<td style="text-align: center;">Latvian</td>
<td style="text-align: center;">84.32</td>
<td style="text-align: center;">84.49</td>
<td style="text-align: center;">0.0623</td>
</tr>
<tr>
<td style="text-align: center;">Vietnamese</td>
<td style="text-align: center;">84.22</td>
<td style="text-align: center;">84.85</td>
<td style="text-align: center;">0.0359</td>
</tr>
<tr>
<td style="text-align: center;">Hungarian*</td>
<td style="text-align: center;">88.93</td>
<td style="text-align: center;">85.83</td>
<td style="text-align: center;">$1.12 \mathrm{e}-08$</td>
</tr>
<tr>
<td style="text-align: center;">Turkish</td>
<td style="text-align: center;">85.60</td>
<td style="text-align: center;">84.23</td>
<td style="text-align: center;">0.1461</td>
</tr>
<tr>
<td style="text-align: center;">Greek</td>
<td style="text-align: center;">93.63</td>
<td style="text-align: center;">94.05</td>
<td style="text-align: center;">0.0104</td>
</tr>
<tr>
<td style="text-align: center;">Bulgarian</td>
<td style="text-align: center;">93.16</td>
<td style="text-align: center;">93.03</td>
<td style="text-align: center;">0.1957</td>
</tr>
<tr>
<td style="text-align: center;">Swedish</td>
<td style="text-align: center;">92.30</td>
<td style="text-align: center;">92.27</td>
<td style="text-align: center;">0.0939</td>
</tr>
<tr>
<td style="text-align: center;">Basque*</td>
<td style="text-align: center;">84.44</td>
<td style="text-align: center;">86.01</td>
<td style="text-align: center;">$3.87 \mathrm{e}-10$</td>
</tr>
<tr>
<td style="text-align: center;">Russian</td>
<td style="text-align: center;">89.72</td>
<td style="text-align: center;">88.65</td>
<td style="text-align: center;">0.0081</td>
</tr>
<tr>
<td style="text-align: center;">Danish</td>
<td style="text-align: center;">90.13</td>
<td style="text-align: center;">89.96</td>
<td style="text-align: center;">0.1016</td>
</tr>
<tr>
<td style="text-align: center;">Indonesian*</td>
<td style="text-align: center;">89.34</td>
<td style="text-align: center;">89.81</td>
<td style="text-align: center;">0.0008</td>
</tr>
<tr>
<td style="text-align: center;">Chinese*</td>
<td style="text-align: center;">85.69</td>
<td style="text-align: center;">81.84</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">Persian</td>
<td style="text-align: center;">93.58</td>
<td style="text-align: center;">93.53</td>
<td style="text-align: center;">0.4450</td>
</tr>
<tr>
<td style="text-align: center;">Hebrew</td>
<td style="text-align: center;">91.69</td>
<td style="text-align: center;">91.93</td>
<td style="text-align: center;">0.1025</td>
</tr>
<tr>
<td style="text-align: center;">Romanian</td>
<td style="text-align: center;">89.18</td>
<td style="text-align: center;">88.96</td>
<td style="text-align: center;">0.2198</td>
</tr>
<tr>
<td style="text-align: center;">English</td>
<td style="text-align: center;">88.45</td>
<td style="text-align: center;">88.89</td>
<td style="text-align: center;">0.0208</td>
</tr>
<tr>
<td style="text-align: center;">Arabic</td>
<td style="text-align: center;">90.58</td>
<td style="text-align: center;">90.49</td>
<td style="text-align: center;">0.0731</td>
</tr>
<tr>
<td style="text-align: center;">Hindi</td>
<td style="text-align: center;">87.77</td>
<td style="text-align: center;">87.92</td>
<td style="text-align: center;">0.0288</td>
</tr>
<tr>
<td style="text-align: center;">Italian</td>
<td style="text-align: center;">92.50</td>
<td style="text-align: center;">92.45</td>
<td style="text-align: center;">0.4812</td>
</tr>
<tr>
<td style="text-align: center;">Spanish</td>
<td style="text-align: center;">91.41</td>
<td style="text-align: center;">91.71</td>
<td style="text-align: center;">0.1176</td>
</tr>
<tr>
<td style="text-align: center;">Czech*</td>
<td style="text-align: center;">90.81</td>
<td style="text-align: center;">90.17</td>
<td style="text-align: center;">$2.91 \mathrm{e}-05$</td>
</tr>
</tbody>
</table>
<p>Table 3: Multilingual POS tagging accuracy for the MimICK and the Char $\rightarrow$ Tag models. * indicates languages identified by the Holm procedure with $\alpha=0.05$.</p>
<p>Independent Datasets Dependency parsing (Table 2) and multilingual POS tagging (Table 3) are our example tasks for this setup, where $\hat{k}_{\text {Fisher }}$ is our recommended valid estimator for the number of cases where one algorithm outperforms another.</p>
<p>For dependency parsing, we compare two scenarios: (a) where in most domains the differences between the compared algorithms are quite large and the $p$-values are small (Mate vs. SpaCy); and (b)</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Dataset</th>
<th style="text-align: center;">AE-SCL-SR</th>
<th style="text-align: center;">MSDA</th>
<th style="text-align: center;">$p$-value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">$B \rightarrow K$</td>
<td style="text-align: center;">0.8005</td>
<td style="text-align: center;">0.788</td>
<td style="text-align: center;">0.0268</td>
</tr>
<tr>
<td style="text-align: center;">$B \rightarrow D^{*}$</td>
<td style="text-align: center;">0.8105</td>
<td style="text-align: center;">0.783</td>
<td style="text-align: center;">0.0011</td>
</tr>
<tr>
<td style="text-align: center;">$B \rightarrow E$</td>
<td style="text-align: center;">0.7675</td>
<td style="text-align: center;">0.7455</td>
<td style="text-align: center;">0.0119</td>
</tr>
<tr>
<td style="text-align: center;">$K \rightarrow B^{*}$</td>
<td style="text-align: center;">0.7295</td>
<td style="text-align: center;">0.7</td>
<td style="text-align: center;">0.0038</td>
</tr>
<tr>
<td style="text-align: center;">$K \rightarrow D^{*,+}$</td>
<td style="text-align: center;">0.763</td>
<td style="text-align: center;">0.714</td>
<td style="text-align: center;">$1.9 \mathrm{e}-06$</td>
</tr>
<tr>
<td style="text-align: center;">$K \rightarrow E$</td>
<td style="text-align: center;">0.84</td>
<td style="text-align: center;">0.824</td>
<td style="text-align: center;">0.018</td>
</tr>
<tr>
<td style="text-align: center;">$D \rightarrow B$</td>
<td style="text-align: center;">0.773</td>
<td style="text-align: center;">0.7605</td>
<td style="text-align: center;">0.0186</td>
</tr>
<tr>
<td style="text-align: center;">$D \rightarrow K^{*}$</td>
<td style="text-align: center;">0.8025</td>
<td style="text-align: center;">0.774</td>
<td style="text-align: center;">0.0014</td>
</tr>
<tr>
<td style="text-align: center;">$D \rightarrow E^{*}$</td>
<td style="text-align: center;">0.781</td>
<td style="text-align: center;">0.75</td>
<td style="text-align: center;">0.0011</td>
</tr>
<tr>
<td style="text-align: center;">$E \rightarrow B$</td>
<td style="text-align: center;">0.7115</td>
<td style="text-align: center;">0.7185</td>
<td style="text-align: center;">0.4823</td>
</tr>
<tr>
<td style="text-align: center;">$E \rightarrow K$</td>
<td style="text-align: center;">0.8455</td>
<td style="text-align: center;">0.845</td>
<td style="text-align: center;">0.9507</td>
</tr>
<tr>
<td style="text-align: center;">$E \rightarrow D^{*,+}$</td>
<td style="text-align: center;">0.745</td>
<td style="text-align: center;">0.71</td>
<td style="text-align: center;">0.0003</td>
</tr>
</tbody>
</table>
<p>Table 4: Cross-domain sentiment classification accuracy for models taken from (Ziser and Reichart, 2017). In an $X \rightarrow Y$ setup, $X$ is the source domain and $Y$ is the target domain. * and + indicate domains identified by the Holm procedure with $\alpha=0.05$ and $\alpha=0.01$, respectively.
where in most domains the differences between the compared algorithms are smaller and the $p$-values are higher (Mate vs. Redshift). Our multilingual POS tagging scenario (Mimick vs. Char $\rightarrow$ Tag) is more similar to scenario (b) in terms of the differences between the participating algorithms.</p>
<p>Table 1 demonstrates the $\hat{k}$ estimators for the various tasks and scenarios. For dependency parsing, as expected, in scenario (a) where all the $p$-values are small, all estimators, even the error-prone $\hat{k}<em _Fisher="{Fisher" _text="\text">{\text {count }}$, provide the same information. In case (b) of dependency parsing, however, $\hat{k}</em>}}$ estimates the number of domains where Mate outperforms Redshift to be 5 , while $\hat{k<em _Bonferroni="{Bonferroni" _text="\text">{\text {count }}$ estimates this number to be 2 . This is a substantial difference given that the number of domains is 7 . The $\hat{k}</em>$ and its estimation is only 1.}}$ estimator, that is valid under arbitrary dependencies, is even more conservative than $\hat{k}_{\text {count }</p>
<p>Perhaps not surprisingly, the multilingual POS</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Dataset</th>
<th style="text-align: center;">W2V</th>
<th style="text-align: center;">GLOVE</th>
<th style="text-align: center;">$p$-val.</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">WS353 ${ }^{*,+}$</td>
<td style="text-align: center;">0.7362</td>
<td style="text-align: center;">0.629</td>
<td style="text-align: center;">$2 e^{-5}$</td>
</tr>
<tr>
<td style="text-align: center;">WS353-SIM ${ }^{*,+}$</td>
<td style="text-align: center;">0.7805</td>
<td style="text-align: center;">0.6979</td>
<td style="text-align: center;">0.0</td>
</tr>
<tr>
<td style="text-align: center;">WS353-REL</td>
<td style="text-align: center;">0.6814</td>
<td style="text-align: center;">0.5706</td>
<td style="text-align: center;">0.2123</td>
</tr>
<tr>
<td style="text-align: center;">MC-30 ${ }^{*,+}$</td>
<td style="text-align: center;">0.8221</td>
<td style="text-align: center;">0.7773</td>
<td style="text-align: center;">0.0001</td>
</tr>
<tr>
<td style="text-align: center;">RG-65</td>
<td style="text-align: center;">0.8348</td>
<td style="text-align: center;">0.8117</td>
<td style="text-align: center;">0.3053</td>
</tr>
<tr>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">0.4819</td>
<td style="text-align: center;">0.4144</td>
<td style="text-align: center;">0.2426</td>
</tr>
<tr>
<td style="text-align: center;">MEN $^{*}$</td>
<td style="text-align: center;">0.796</td>
<td style="text-align: center;">0.7362</td>
<td style="text-align: center;">0.0021</td>
</tr>
<tr>
<td style="text-align: center;">MTurk-287</td>
<td style="text-align: center;">0.671</td>
<td style="text-align: center;">0.6475</td>
<td style="text-align: center;">0.2076</td>
</tr>
<tr>
<td style="text-align: center;">MTurk-771</td>
<td style="text-align: center;">0.7116</td>
<td style="text-align: center;">0.6842</td>
<td style="text-align: center;">0.0425</td>
</tr>
<tr>
<td style="text-align: center;">YP-130 ${ }^{*,+}$</td>
<td style="text-align: center;">0.504</td>
<td style="text-align: center;">0.5315</td>
<td style="text-align: center;">0.0</td>
</tr>
<tr>
<td style="text-align: center;">SimLex999*</td>
<td style="text-align: center;">0.4621</td>
<td style="text-align: center;">0.3725</td>
<td style="text-align: center;">0.0015</td>
</tr>
<tr>
<td style="text-align: center;">$V e r b-143$</td>
<td style="text-align: center;">0.4479</td>
<td style="text-align: center;">0.3275</td>
<td style="text-align: center;">0.0431</td>
</tr>
</tbody>
</table>
<p>Table 5: Spearman's $\rho$ values for the best performing predict model (W2V-CBOW) of (Baroni et al., 2014) and the GLOVE model. * and + are as in Table 4.
tagging results are similar to case (b) of dependency parsing. Here, again, $\hat{k}<em _Fisher="{Fisher" _text="\text">{\text {count }}$ is too conservative, estimating the number of languages with effect to be 11 (out of 23) while $\hat{k}</em>}}$ estimates this number to be 16 (an increase of $5 / 23$ in the estimated number of languages with effect). $\hat{k<em _Fisher="{Fisher" _text="\text">{\text {Bonferroni }}$ is again more conservative, estimating the number of languages with effect to be only 6 , which is not very surprising given that it does not exploit the independence between the datasets. These two examples of case (b) demonstrate that when the differences between the algorithms are quite small, $\hat{k}</em>$ may be more sensitive than the current practice in NLP for discovering the number of datasets with effect.}</p>
<p>To complete the analysis, we would like to name the datasets with effect. As discussed in Section 4.2, while this can be straightforwardly done by naming the datasets with the $\hat{k}$ smallest $p$-values, in general, this approach does not control the probability of identifying at least one dataset erroneously. We thus employ the Holm procedure for the identification task, noticing that the number of datasets it identifies should be equal to the value of the $\hat{k}_{\text {Bonferroni }}$ estimator (Section 4.3).</p>
<p>Indeed, for dependency parsing in case (a), the Holm procedure identifies all seven domains as cases where Mate outperforms SpaCy, while in case (b) it identifies only the MZ domain as a case where Mate outperforms Redshift. For multilingual POS
tagging the Holm procedure identifies Tamil, Hungarian, Basque, Indonesian, Chinese and Czech as languages where Mimick outperforms Char $\rightarrow$ Tag. This analysis demonstrates that when the performance gap between two algorithms becomes narrower, inquiring for more information (i.e. identifying the domains with effect rather than just estimating their number), may result in weaker results. ${ }^{13}$</p>
<p>Dependent Datasets In cross-domain sentiment classification (Table 4) and word similarity prediction (Table 5), the involved datasets manifest mutual dependence. Particularly, each sentiment setup shares its test dataset with 2 other setups, while in word similarity WS-353 is the union of WS-353REL and WS-353-SIM. As discussed in Section 4, $\hat{k}_{\text {Bonferroni }}$ is the appropriate estimator of the number of cases one algorithm outperforms another.</p>
<p>The results in Table 1 manifest the phenomenon demonstrated by the second toy example in Section 5, which shows that when the datasets are dependent, $\hat{k}<em _count="{count" _text="\text">{\text {Fisher }}$ as well as the error-prone $\hat{k}</em>$ which controls the probability to overestimate the number of such datasets.}}$ may be too optimistic regarding the number of datasets with effect. This stands in contrast to $\hat{k}_{\text {Bonferroni }</p>
<p>Indeed, $\hat{k}<em _count="{count" _text="\text">{\text {Bonferroni }}$ is much more conservative, yielding values of $6(\alpha=0.05)$ and $2(\alpha=0.01)$ for sentiment, and of $6(\alpha=0.05)$ and $4(\alpha=$ 0.01 ) for word similarity. The differences from the conclusions that might have been drawn by $\hat{k}</em>}}$ are again quite substantial. The difference between $\hat{k<em _count="{count" _text="\text">{\text {Bonferroni }}$ and $\hat{k}</em>$ in sentiment classification is 4 , which accounts to $1 / 3$ of the 12 test setups. Even for word similarity, the difference between the two methods, which account to 2 for both $\alpha$ values, represents $1 / 6$ of the 12 test setups. The domains identified by the Holm procedure are marked in the tables.}</p>
<p>Results Overview Our goal in this section is to demonstrate that the approach of simply looking at the number of datasets for which the difference between the performance of the algorithms reaches a predefined significance level, gives different results</p>
<p><sup id="fnref9:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>from our suggested statistically sound analysis. This approach is denoted here with $\hat{k}<em _count="{count" _text="\text">{\text {count }}$ and shown to be statistically not valid in Sections 3.2 and 5. We observe that this happens especially in evaluation setups where the differences between the algorithms are small for most datasets. In some cases, when the datasets are independent, our analysis has the power to declare a larger number of datasets with effect than the number of individual significant test values ( $\hat{k}</em>$ is much too optimistic.}}$ ). In other cases, when the datasets are interdependent, $\hat{k}_{\text {count }</p>
<p>Our proposed analysis changes the observations that might have been made based on the papers where the results analyzed here were originally reported. For example, for the Mate-Redshift comparison (independent evaluation sets), we show that there is evidence that the number of datasets with effect is much higher than one would assume based on counting the significant sets ( 5 vs. 2 out of 7 evaluation sets), giving a stronger claim regarding the superiority of Mate. In multilingual POS tagging (again, a setup of independent evaluation sets) our analysis shows evidence for 16 sets with effect compared to only 11 of the erroneous count method - a difference in 5 out of 23 evaluation sets ( $21.7 \%$ ). Finally, in the cross-domain sentiment classification and the word similarity judgment tasks (dependent evaluation sets), the unjustified counting method may be too optimistic (e.g. 10 vs. 6 out of 12 evaluation sets, for $\alpha=0.05$ in the sentiment task), in favor of the new algorithms.</p>
<h2>7 Discussion and Future Directions</h2>
<p>We proposed a statistically sound replicability analysis framework for cases where algorithms are compared across multiple datasets. Our main contributions are: (a) analyzing the limitations of the current practice in NLP work; and (b) proposing a framework that addresses both the estimation of the number of datasets with effect and their identification.</p>
<p>The framework we propose addresses two different situations encountered in NLP: independent and dependent datasets. For dependent datasets, we assumed that the type of dependency cannot be determined. One could use more powerful methods if certain assumptions on the dependency between the test statistics could be made. For example, one could use
the partial conjunction p-value based on Simes test for the global null hypothesis (Simes, 1986), which was proposed by Benjamini and Heller (2008) for the case where the test statistics satisfy certain positive dependency properties (see Theorem 1 in (Benjamini and Heller, 2008)). Using this partial conjunction p-value rather than the one based on Bonferroni, one may obtain higher values of $\hat{k}$ with the same statistical guarantee. Similarly, for the identification question, if certain positive dependency properties hold, Holm's procedure could be replaced by Hochberg's or Hommel's procedures (Hochberg, 1988; Hommel, 1988) which are more powerful.</p>
<p>An alternative, more powerful multiple testing procedure for identification of datasets with effect, is the method in Benjamini and Hochberg (1995), that controls the false discovery rate (FDR), a less strict error criterion than the one considered here. This method is more appropriate in cases where one may tolerate some errors as long as the proportion of errors among all the claims made is small, as expected to happen when the number of datasets grows.</p>
<p>We note that the increase in the number of evaluation datasets may have positive and negative aspects. As noted in Section 2, we believe that multiple comparisons are integral to NLP research when aiming to develop algorithms that perform well across languages and domains. On the other hand, experimenting with multiple evaluation sets that reflect very similar linguistic phenomena may only complicate the comparison between alternative algorithms.</p>
<p>In fact, our analysis is useful mostly where the datasets are heterogeneous, coming from different languages or domains. When they are just technically different but could potentially be just combined into a one big dataset, then we believe the question of Demšar (2006), whether at least one dataset shows evidence for effect, is more appropriate.</p>
<h2>Acknowledgement</h2>
<p>The research of M. Bogomolov was supported by the Israel Science Foundation grant No. 1112/14. We thank Yuval Pinter for his great help with the multilingual experiments and for his useful feedback. We also thank Ruth Heller, Marten van Schijndel, Oren Tsur, Or Zuk and the ie@technion NLP group members for their useful comments.</p>
<h2>References</h2>
<p>Eneko Agirre, Enrique Alfonseca, Keith Hall, Jana Kravalova, Marius Paşca, and Aitor Soroa. 2009. A study on similarity and relatedness using distributional and WordNet-based approaches. In Proceedings of HLT-NAACL.
Rami Al-Rfou, Bryan Perozzi, and Steven Skiena. 2013. Polyglot: Distributed word representations for multilingual NLP. In Proceedings of CoNLL.
Simon Baker, Roi Reichart, and Anna Korhonen. 2014. An unsupervised model for instance level subcategorization acquisition. In Proceedings of EMNLP.
Marco Baroni, Georgiana Dinu, and Germán Kruszewski. 2014. Don't count, predict! a systematic comparison of context-counting vs. context-predicting semantic vectors. In Proceedings of ACL.
C. Glenn Begley and Lee M. Ellis. 2012. Drug development: Raise standards for preclinical cancer research. Nature, 483(7391):531-533.
Yoav Benjamini and Ruth Heller. 2008. Screening for partial conjunction hypotheses. Biometrics, 64(4):1215-1222.
Yoav Benjamini and Yosef Hochberg. 1995. Controlling the false discovery rate: A practical and powerful approach to multiple testing. Journal of the Royal Statistical Society. Series B (Methodological), pages 289300.</p>
<p>Yoav Benjamini, Abba M. Krieger, and Daniel Yekutieli. 2006. Adaptive linear step-up procedures that control the false discovery rate. Biometrika, pages 491-507.
Yoav Benjamini, Ruth Heller, and Daniel Yekutieli. 2009. Selective inference in complex research. Philosophical Transactions of the Royal Society of London A: Mathematical, Physical and Engineering Sciences, 367(1906):4255-4271.
Taylor Berg-Kirkpatrick, David Burkett, and Dan Klein. 2012. An empirical investigation of statistical significance in NLP. In Proceedings of EMNLP-CoNLL.
John Blitzer, Ryan McDonald, and Fernando Pereira. 2006. Domain adaptation with structural correspondence learning. In Proceedings of EMNLP.
John Blitzer, Mark Dredze, and Fernando Pereira. 2007. Biographies, Bollywood, boom-boxes and blenders: Domain adaptation for sentiment classification. In Proceedings of ACL.
Bernd Bohnet. 2010. Very high accuracy and fast dependency parsing is not a contradiction. In Proceedings of COLING.
Elia Bruni, Gemma Boleda, Marco Baroni, and NamKhanh Tran. 2012. Distributional semantics in technicolor. In Proceedings of ACL.</p>
<p>Elia Bruni, Nam-Khanh Tran, and Marco Baroni. 2014. Multimodal distributional semantics. Journal of Artificial Intelligence Research (JAIR), 49:1-47.
Sabine Buchholz and Erwin Marsi. 2006. CoNLL-x shared task on multilingual dependency parsing. In Proceedings of CoNLL.
Yee Seng Chan and Hwee Tou Ng. 2007. Domain adaptation with active learning for word sense disambiguation. In Proceedings of ACL.
Eugene Charniak. 2000. A maximum-entropy-inspired parser. In Proceedings of HLT-NAACL.
Minmin Chen, Yixin Chen, and Kilian Q. Weinberger. 2011. Automatic feature decomposition for single view co-training. In Proceedings of ICML.
Jinho D. Choi, Joel Tetreault, and Amanda Stent. 2015. It depends: Dependency parser comparison using a web-based evaluation tool. In Proceedings of ACL.
Open Science Collaboration. 2012. An open, largescale, collaborative effort to estimate the reproducibility of psychological science. Perspectives on Psychological Science, 7(6):657-660.
Michael Collins. 2003. Head-driven statistical models for natural language parsing. Computational linguistics, 29(4):589-637.
Hal Daumé III. 2007. Frustratingly easy domain adaptation. In Proceedings of ACL.
Marie-Catherine De Marneffe, Timothy Dozat, Natalia Silveira, Katri Haverinen, Filip Ginter, Joakim Nivre, and Christopher D. Manning. 2014. Stanford dependencies: A cross-linguistic typology. In Proceedings of LREC.
Janez Demšar. 2006. Statistical comparisons of classifiers over multiple data sets. Journal of Machine Learning Research, 7:1-30.
Thomas G. Dietterich. 1998. Approximate statistical tests for comparing supervised classification learning algorithms. Neural computation, 10(7):1895-1923.
Bradley Efron and Robert J. Tibshirani. 1994. An introduction to the bootstrap. CRC press.
Alessio Farcomeni. 2007. A review of modern multiple hypothesis testing, with particular attention to the false discovery proportion. Statistical Methods in Medical Research.
Manaal Faruqui and Chris Dyer. 2014. Community evaluation and exchange of word vectors at wordvectors.org. In Proceedings of the ACL: System Demonstrations.
Lev Finkelstein, Evgeniy Gabrilovich, Yossi Matias, Ehud Rivlin, Zach Solan, Gadi Wolfman, and Eytan Ruppin. 2001a. Placing search in context: The concept revisited. In Proceedings of WWW.
Lev Finkelstein, Evgeniy Gabrilovich, Yossi Matias, Ehud Rivlin, Zach Solan, Gadi Wolfman, and Eytan</p>
<p>Ruppin. 2001b. Placing search in context: The concept revisited. In Proceedings of WWW.
Honglei Guo, Huijia Zhu, Zhili Guo, Xiaoxun Zhang, Xian Wu, and Zhong Su. 2009. Domain adaptation with latent semantic association for named entity recognition. In Proceedings of HLT-NAACL.
Guy Halawi, Gideon Dror, Evgeniy Gabrilovich, and Yehuda Koren. 2012. Large-scale learning of word relatedness with constraints. In Proceedings of ACM SIGKDD.
Ruth Heller, Marina Bogomolov, and Yoav Benjamini. 2014. Deciding whether follow-up studies have replicated findings in a preliminary large-scale omics study. Proceedings of the National Academy of Sciences, 111(46):16262-16267.
Thomas Herndon, Michael Ash, and Robert Pollin. 2014. Does high public debt consistently stifle economic growth? a critique of Reinhart and Rogoff. Cambridge Journal of Economics, 38(2):257-279.
Felix Hill, Roi Reichart, and Anna Korhonen. 2015. Simlex-999: Evaluating semantic models with (genuine) similarity estimation. Computational Linguistics, 41(4):665-695.
Felix Hill, Roi Reichart, and Anna Korhonen. 2016. Simlex-999: Evaluating semantic models with (genuine) similarity estimation. Computational Linguistics.
Yosef Hochberg. 1988. A sharper Bonferroni procedure for multiple tests of significance. Biometrika, 75(4):800-802.
Sture Holm. 1979. A simple sequentially rejective multiple test procedure. Scandinavian Journal of Statistics, $6(2): 65-70$.
Gerhard Hommel. 1988. A stagewise rejective multiple test procedure based on a modified Bonferroni test. Biometrika, 75(2):383-386.
Matthew Honnibal and Mark Johnson. 2015. An improved non-monotonic transition system for dependency parsing. In Proceedings of EMNLP.
Matthew Honnibal, Yoav Goldberg, and Mark Johnson. 2013. A non-monotonic arc-eager transition system for dependency parsing. In Proceedings of CoNLL.
Philipp Koehn and Josh Schroeder. 2007. Experiments in domain adaptation for statistical machine translation. In Proceedings of the Second Workshop on Statistical Machine Translation.
Philipp Koehn. 2005. Europarl: A parallel corpus for statistical machine translation. In Proceedings of the tenth Machine Translation Summit.
Jeffrey T. Leek and Roger D Peng. 2015. Opinion: Reproducible research can still be wrong: Adopting a prevention approach. Proceedings of the National Academy of Sciences, 112(6):1645-1646.</p>
<p>Omer Levy and Yoav Goldberg. 2014. Dependencybased word embeddings. In Proceedings of ACL.
Wang Ling, Chris Dyer, Alan W. Black, Isabel Trancoso, Ramon Fermandez, Silvio Amir, Luis Marujo, and Tiago Luis. 2015. Finding function in form: Compositional character models for open vocabulary word representation. In Proceedings of EMNLP.
Thomas M. Loughin. 2004. A systematic comparison of methods for combining p-values from independent tests. Computational Statistics \&amp; Data Analysis, 47(3):467-485.
Minh-Thang Luong, Richard Socher, and Christopher D. Manning. 2013. Better word representations with recursive neural networks for morphology. In Proceedings of CoNLL.
Mitchell P. Marcus, Mary Ann Marcinkiewicz, and Beatrice Santorini. 1993. Building a large annotated corpus of English: The Penn Treebank. Computational linguistics, 19(2):313-330.
Edison Marrese-Taylor and Yutaka Matsuo. 2017. Replication issues in syntax-based aspect extraction for opinion mining. In Proceedings of the Student Research Workshop at EACL.
Quinn McNemar. 1947. Note on the sampling error of the difference between correlated proportions or percentages. Psychometrika, 12(2):153-157.
Tomas Mikolov, Ilya Sutskever, Kai Chen, Gregory S. Corrado, and Jeffrey Dean. 2013. Distributed representations of words and phrases and their compositionality. In Proceedings of NIPS.
George A. Miller and Walter G. Charles. 1991. Contextual correlates of semantic similarity. Language and cognitive processes, 6(1):1-28.
Ramal Moonesinghe, Muin J. Khoury, and A. Cecile J. W. Janssens. 2007. Most published research findings are false but a little replication goes a long way. PLoS Med, 4(2):e28.
Aurélie Névéol, Cyril Grouin, Kevin Bretonnel Cohen, and Aude Robert. 2016. Replicability of research in biomedical natural language processing: a pilot evaluation for a coding task. Proceedings of EMNLP.
Jens Nilsson, Sebastian Riedel, and Deniz Yuret. 2007. The CoNLL 2007 shared task on dependency parsing. In Proceedings of CoNLL.
Diarmuid Ó Séaghdha and Anna Korhonen. 2014. Probabilistic distributional semantics. Computational Linguistics, 40(3):587-631.
Prasad Patil, Roger D. Peng, and Jeffrey Leek. 2016. A statistical definition for reproducibility and replicability. bioRxiv.
Roger D. Peng. 2011. Reproducible research in computational science. Science, 334(6060):1226-1227.</p>
<p>Jeffrey Pennington, Richard Socher, and Christopher Manning. 2014. GloVe: Global vectors for word representation. In Proceedings of EMNLP.
Slav Petrov and Ryan McDonald. 2012. Overview of the 2012 shared task on parsing the web. In Notes of the First Workshop on Syntactic Analysis of NonCanonical Language (SANCL).
Yuval Pinter, Robert Guthrie, and Jacob Eisenstein. 2017. Mimicking word embeddings using subword RNNs. In Proceedings of EMNLP.
Sameer Pradhan, Alessandro Moschitti, Nianwen Xue, Hwee Tou Ng, Anders Björkelund, Olga Uryupina, Yuchen Zhang, and Zhi Zhong. 2013. Towards robust linguistic analysis using OntoNotes. In Proceedings of CoNLL.
Kira Radinsky, Eugene Agichtein, Evgeniy Gabrilovich, and Shaul Markovitch. 2011. A word at a time: Computing word relatedness using temporal semantic analysis. In Proceedings of WWW.
Herbert Rubenstein and John B. Goodenough. 1965. Contextual correlates of synonymy. Communications of the ACM, 8(10):627-633.
Roy Schwartz, Roi Reichart, and Ari Rappoport. 2015. Symmetric pattern based word embeddings for improved word similarity prediction. In Proceedings of CoNLL.
Carina Silberer and Mirella Lapata. 2014. Learning grounded meaning representations with autoencoders. In Proceedings of ACL.
R. John Simes. 1986. An improved Bonferroni procedure for multiple tests of significance. Biometrika, pages 751-754.
Rion Snow, Brendan O'Connor, Daniel Jurafsky, and Andrew Y. Ng. 2008. Cheap and fast-but is it good?: Evaluating non-expert annotations for natural language tasks. In Proceedings of EMNLP.
Anders Søgaard, Anders Johannsen, Barbara Plank, Dirk Hovy, and Héctor Martínez Alonso. 2014. What's in a p-value in NLP ? In Proceedings of CoNLL.
Anders Søgaard. 2013. Estimating effect size across datasets. In Proceedings of HLT-NAACL.
James H. Steiger. 1980. Tests for comparing elements of a correlation matrix. Psychological Bulletin, 87(2):245-251.
Ralph Weischedel, Eduard Hovy, Mitchell Marcus, Martha Palmer, Robert Belvin, Sameer Pradhan, Lance Ramshaw, and Nianwen Xue. 2011. OntoNotes: A large training corpus for enhanced processing. Handbook of Natural Language Processing and Machine Translation. Springer.
Frank Wilcoxon. 1945. Individual comparisons by ranking methods. Biometrics bulletin, 1(6):80-83.</p>
<p>Dongqiang Yang and David M.W. Powers. Verb similarity on the taxonomy of WordNet. In Proceedings of the 3rd International WordNet Conference.
Alexander Yeh. 2000. More accurate tests for the statistical significance of result differences. In Proceedings of CoNLL.
Yftah Ziser and Roi Reichart. 2017. Neural structural correspondence learning for domain adaptation. In Proceedings of CoNLL.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{13}$ For completeness, we also performed the analysis for the independent dataset setups with $\alpha=0.01$. The results are $\left(k_{\text {count }}, \hat{k}<em _Fisher="{Fisher" _text="\text">{\text {Bonferroni }}, \hat{k}</em>\right)$ : Mate vs. SpaCy: $(7,7,7)$; Mate vs. Redshift (1,0,2); Mimick vs. Char $\rightarrow$ Tag: $(7,5,13)$. The patterns are very similar to those discussed in the text.&#160;}<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref5:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref6:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref7:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref8:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref9:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:1">
<p>${ }^{10}$ http://www.cs.jhu.edu/ mdredze/
datasets/sentiment&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 2 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:1" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>