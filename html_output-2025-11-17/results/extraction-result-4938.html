<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-4938 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-4938</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-4938</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-105.html">extraction-schema-105</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models using diverse versus similar reasoning methods to solve reasoning problems, including descriptions of the reasoning methods, tasks, performance, and any comparisons or findings about the effectiveness of diverse versus similar reasoning.</div>
                <p><strong>Paper ID:</strong> paper-760561c57f68044e2f1d089088df1da6c627b09a</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/760561c57f68044e2f1d089088df1da6c627b09a" target="_blank">On the Advance of Making Language Models Better Reasoners</a></p>
                <p><strong>Paper Venue:</strong> arXiv.org</p>
                <p><strong>Paper TL;DR:</strong> This paper conducts extensive experiments using the latest language model code-davinci-002 and demonstrates that D I - V E RS E can achieve new state-of-the-art performance on six out of eight reasoning benchmarks, out-performing the PaLM model with 540B parameters.</p>
                <p><strong>Cost:</strong> 0.016</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e4938.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e4938.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models using diverse versus similar reasoning methods to solve reasoning problems, including descriptions of the reasoning methods, tasks, performance, and any comparisons or findings about the effectiveness of diverse versus similar reasoning.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>DiVERSE (code-davinci-002,GSM8K)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>DiVERSE: Diverse Verifier on Reasoning Step (evaluation with code-davinci-002 on GSM8K)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>DiVERSE combines diverse prompts (multiple exemplar sets), sampling, a verifier that scores candidate reasoning paths, voting weighted by verifier scores, and an optional step-aware verifier that assigns correctness labels to individual steps; evaluated with code-davinci-002 on arithmetic benchmarks.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>code-davinci-002</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>OpenAI instruction-tuned model (exact parameter count not disclosed in paper); used with sampling temperature 0.5. The paper treats code-davinci-002 as a high-performance LLM in experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_method_name</strong></td>
                            <td>DiVERSE (diverse prompts + voting verifier + step-aware verifier)</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_method_type</strong></td>
                            <td>diverse</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_method_description</strong></td>
                            <td>Generate M = M1 * M2 candidate chain-of-thought reasoning paths by sampling from multiple different prompts (varying exemplars) and sampling decoding; use a fine-tuned verifier (deberta-v3-large backbone) to score each path; aggregate answers via weighted voting using verifier scores; optionally apply a step-aware loss and a verifier that scores individual reasoning steps to improve selection.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>GSM8K</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>GSM8K is a benchmark of grade-school math word problems requiring multi-step arithmetic reasoning; evaluation metric is answer accuracy.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>accuracy 82.3%</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other_method</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>performance_other_method</strong></td>
                            <td>Self-Consistency (sampling 100 paths + majority voting) accuracy 76.7% (code-davinci-002); Greedy decode single chain accuracy 55.3%</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>DiVERSE (diverse prompts + voting verifier) outperforms self-consistency (sampling-only + majority voting) on GSM8K with code-davinci-002 by 5.6 percentage points; combining diverse prompts (vary exemplars) with sampling yields better distinct reasoning paths and higher accuracy than sampling alone.</td>
                        </tr>
                        <tr>
                            <td><strong>counter_examples_or_negative_results</strong></td>
                            <td>The step-aware verifier variant slightly reduced performance for code-davinci-002 on GSM8K (DiVERSE without step: 82.3% vs with step: 81.5%), indicating that step-level supervision does not uniformly improve every model/task.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e4938.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e4938.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models using diverse versus similar reasoning methods to solve reasoning problems, including descriptions of the reasoning methods, tasks, performance, and any comparisons or findings about the effectiveness of diverse versus similar reasoning.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>DiVERSE (text-davinci-002,GSM8K)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>DiVERSE: Diverse Verifier on Reasoning Step (evaluation with text-davinci-002 on GSM8K)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Same DiVERSE pipeline evaluated with text-davinci-002, showing substantial gains over self-consistency and greedy decoding on GSM8K.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>text-davinci-002</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>OpenAI instruction-tuned model (parameter count hidden); used with sampling temperature 0.5 in experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_method_name</strong></td>
                            <td>DiVERSE (diverse prompts + voting verifier + step-aware verifier)</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_method_type</strong></td>
                            <td>diverse</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_method_description</strong></td>
                            <td>See DiVERSE description: multiple prompts (M1 different exemplar sets) × sampling (M2 paths per prompt), verifier scoring, and weighted voting; optional step-aware verifier labels individual reasoning steps.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>GSM8K</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Grade-school math word problems benchmark; metric: accuracy.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>accuracy 70.2%</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other_method</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>performance_other_method</strong></td>
                            <td>Self-Consistency (sampling 100 paths + majority voting) accuracy 58.2% (text-davinci-002); Greedy decode accuracy 37.1%</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>DiVERSE produced a large improvement over self-consistency (12.0 percentage points) with text-davinci-002 on GSM8K, supporting the hypothesis that inducing diverse reasoning paths via varying prompts plus verifier-weighted voting yields more robust answer selection.</td>
                        </tr>
                        <tr>
                            <td><strong>counter_examples_or_negative_results</strong></td>
                            <td>None reported for this model-task pair; step-aware verifier further improved performance (68.9% without step -> 70.2% with step).</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e4938.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e4938.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models using diverse versus similar reasoning methods to solve reasoning problems, including descriptions of the reasoning methods, tasks, performance, and any comparisons or findings about the effectiveness of diverse versus similar reasoning.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>DiVERSE (davinci,GSM8K)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>DiVERSE: Diverse Verifier on Reasoning Step (evaluation with davinci on GSM8K)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>DiVERSE applied to GPT-3 davinci model shows substantial gains over greedy or self-consistency baselines on GSM8K, though absolute accuracy remains lower than larger instruction-tuned variants.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>davinci (GPT-3)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>GPT-3 base 'davinci' model with 175B parameters (as cited in the paper for GPT-3 davinci); used as one of the evaluated LMs.</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_method_name</strong></td>
                            <td>DiVERSE (diverse prompts + voting verifier + step-aware verifier)</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_method_type</strong></td>
                            <td>diverse</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_method_description</strong></td>
                            <td>Generate multiple chain-of-thought paths from several distinct prompts and sampled decodings, score with a fine-tuned verifier, then aggregate by weighted voting; optionally incorporate step-level labeling to guide verifier.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>GSM8K</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Grade-school math word problems requiring multi-step arithmetic reasoning; measured by accuracy.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>accuracy 30.9%</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other_method</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>performance_other_method</strong></td>
                            <td>Self-Consistency (sampling 100 paths + majority voting) accuracy 18.9%; Greedy decode accuracy 8.7%</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>DiVERSE boosts a weaker model (davinci) considerably (+12.0% over self-consistency and +22.2% over greedy decoding on GSM8K), showing that diversity in prompts and verifier-weighted voting can recover correct answers that are minority outputs.</td>
                        </tr>
                        <tr>
                            <td><strong>counter_examples_or_negative_results</strong></td>
                            <td>Absolute performance remains far below stronger models; no instance where similar methods beat DiVERSE on this model/task in reported results.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e4938.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e4938.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models using diverse versus similar reasoning methods to solve reasoning problems, including descriptions of the reasoning methods, tasks, performance, and any comparisons or findings about the effectiveness of diverse versus similar reasoning.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Diverse prompts vs Sampling-only (majority voting)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Comparison of Diverse Prompts (varying exemplar sets) versus Sampling-only (single prompt, many samples) under majority voting</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Empirical comparison showing that using multiple different prompts (diverse exemplars) combined with sampling yields better diversity of reasoning paths and higher accuracy under majority voting than sampling-only from a single prompt.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>code-davinci-002 (example reported)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>OpenAI model (parameter count undisclosed in paper); experiments compare different M1 (number of distinct prompts) and M2 (samples per prompt) settings.</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_method_name</strong></td>
                            <td>Diverse prompts (M1>1) + sampling (M2) under majority voting vs Sampling-only (M1=1, M2 large)</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_method_type</strong></td>
                            <td>diverse versus similar</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_method_description</strong></td>
                            <td>Diverse prompts: for each question randomly select M1 different exemplar prompt templates and sample M2 reasoning paths per prompt (total M=M1*M2). Sampling-only: use a fixed prompt (M1=1) and sample many (M2 large) decodings. Both aggregated by majority voting over final answers.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>GSM8K (majority voting experiments)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Arithmetic reasoning benchmark; experiments evaluate majority-vote accuracy as M1/M2 vary.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>code-davinci-002 majority-vote accuracy: M1=1,M2=100 -> 76.7%; M1=5,M2=20 -> 80.0%; M1=10,M2=10 -> 79.8%; M1=100,M2=1 -> 73.0%</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other_method</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>performance_other_method</strong></td>
                            <td>Sampling-only (M1=1,M2=100) accuracy 76.7% (code-davinci-002)</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Combining diverse prompts (M1>1) with sampling (M2>1) yields higher majority-vote accuracy than pure sampling from a single prompt; the best balance observed was M1=5,M2=20 for code-davinci-002 (80.0%). Diverse prompts increase the number of distinct reasoning paths and distinct final answers, making correct outputs more distinguishable.</td>
                        </tr>
                        <tr>
                            <td><strong>counter_examples_or_negative_results</strong></td>
                            <td>Extremely many distinct prompts with only one sample each (M1=100,M2=1) performed worse (73.0%), indicating that both within-prompt sampling and across-prompt diversity are needed—neither extreme alone is optimal.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e4938.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e4938.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models using diverse versus similar reasoning methods to solve reasoning problems, including descriptions of the reasoning methods, tasks, performance, and any comparisons or findings about the effectiveness of diverse versus similar reasoning.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Voting Verifier vs Majority and Verifier-only</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Voting Verifier: weighted voting by verifier scores compared to majority voting and verifier-only selection</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>The voting verifier multiplies vote counts by verifier-produced probabilities to select the final answer; it outperforms plain majority voting and often improves over using the verifier alone.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>code-davinci-002 (reported example); also evaluated on text-davinci-002 and davinci</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>OpenAI models; experiments compare aggregation algorithms given the same pool of candidate reasoning paths.</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_method_name</strong></td>
                            <td>Voting Verifier (weighted voting by verifier scores)</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_method_type</strong></td>
                            <td>diverse (aggregation over diverse candidate paths)</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_method_description</strong></td>
                            <td>Compute for each candidate path a verifier score f(x_i,z_i,y_i) estimating probability path leads to correct answer; aggregate candidate answers by summing verifier scores for each distinct final answer and selecting argmax (weighted voting). Compared to majority voting (simple count) and verifier-only (choose single highest-scoring path).</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>GSM8K (example), CommonsenseQA, CLUTRR (reported)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Reasoning benchmarks across arithmetic, commonsense, and inductive reasoning; measure final-answer accuracy.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>code-davinci-002 on GSM8K: Voting (majority voting) 80.0%; Verifier-only 65.9%; Voting Verifier 82.3%. (Similar patterns reported on other models/tasks: e.g., text-davinci-002 GSM8K Voting 61.3% / Verifier 62.7% / Voting Verifier 68.9%)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other_method</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>performance_other_method</strong></td>
                            <td>Majority voting (self-consistency) and Verifier-only listed above</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Voting Verifier consistently and significantly boosts performance relative to majority voting; verifier-only can outperform majority voting in some cases, but combining both (voting verifier) gives the best results in many settings.</td>
                        </tr>
                        <tr>
                            <td><strong>counter_examples_or_negative_results</strong></td>
                            <td>On some tasks/models verifier-only already outperforms majority voting (e.g., verifier > voting), showing that majority voting can be fragile if many sampled paths are low-quality; but overall voting verifier usually adds additional gains.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e4938.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e4938.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models using diverse versus similar reasoning methods to solve reasoning problems, including descriptions of the reasoning methods, tasks, performance, and any comparisons or findings about the effectiveness of diverse versus similar reasoning.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Step-aware Verifier (effect)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Step-aware Voting Verifier: adding step-level supervision to the voting verifier</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Step-aware verifier extends the voting verifier by predicting a correctness label per reasoning step and using an auxiliary loss to improve verifier judgments and interpretability. Evaluated across models/tasks with mostly positive impact but with some exceptions.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>text-davinci-002, davinci, code-davinci-002 (evaluated)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>OpenAI models used in experiments; step-aware verifier is a fine-tuned DEBERTA-V3-LARGE with an auxiliary token-level head to score steps.</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_method_name</strong></td>
                            <td>Step-aware Voting Verifier</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_method_type</strong></td>
                            <td>diverse (applies to diverse candidate pools)</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_method_description</strong></td>
                            <td>Introduce step-level labels indicating which intermediate steps are correct by comparing negative paths to positive ones (or via NLI model for semantics); train verifier with an auxiliary BCE loss on step labels (controlled by hyperparameter alpha) so verifier can predict correctness of each step; use these predictions to inform weighted voting.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>GSM8K and CommonsenseQA (reported examples)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>GSM8K arithmetic reasoning and CommonsenseQA multiple-choice commonsense reasoning; evaluated by final-answer accuracy and human evaluation of intermediate steps.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>GSM8K: davinci DiVERSE without step 30.6% -> with step 30.9%; text-davinci-002 without step 68.9% -> with step 70.2%; code-davinci-002 without step 82.3% -> with step 81.5% (slight decrease). CommonsenseQA: davinci 75.0% -> 76.0%; text-davinci-002 79.2% -> 79.8%; code-davinci-002 78.8% -> 79.9%.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other_method</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>performance_other_method</strong></td>
                            <td>DiVERSE without step-aware verifier (see values above per model)</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Step-aware supervision generally improves selection quality and interpretability by helping the verifier detect where a reasoning path goes wrong and by increasing the number of correct intermediate steps in failed paths; improvements are modest and model-dependent. Human evaluation shows step-aware verifier reduces redundant steps and tends to produce more correct steps before errors occur.</td>
                        </tr>
                        <tr>
                            <td><strong>counter_examples_or_negative_results</strong></td>
                            <td>For code-davinci-002 on GSM8K the step-aware mechanism slightly lowered overall accuracy (82.3% -> 81.5%), suggesting more capable LMs may gain less or could be slightly harmed by imperfect step labeling or auxiliary supervision.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e4938.6">
                <h3 class="extraction-instance">Extracted Data Instance 6 (e4938.6)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models using diverse versus similar reasoning methods to solve reasoning problems, including descriptions of the reasoning methods, tasks, performance, and any comparisons or findings about the effectiveness of diverse versus similar reasoning.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Self-Consistency (PaLM mention)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Self-Consistency: sampling many chain-of-thought paths and selecting the most consistent final answer (PaLM reported results)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Self-consistency aggregates many sampled chain-of-thought outputs by majority voting on final answers; reported as a strong baseline (especially with PaLM-540B) in the literature and in this paper's comparisons.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Self-consistency improves chain of thought reasoning in language models</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>PaLM (reported; 540B)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>PaLM is a large Transformer-based language model with 540B parameters (Chowdhery et al., 2022); self-consistency results cited from prior work using PaLM.</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_method_name</strong></td>
                            <td>Self-Consistency (sampling + majority voting)</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_method_type</strong></td>
                            <td>similar (sampling many outputs from a fixed prompt)</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_method_description</strong></td>
                            <td>Generate many chain-of-thought reasoning paths by sampling from a fixed prompt (same exemplar set). Aggregate final answers by majority voting (the most frequent final answer among sampled outputs is chosen).</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>GSM8K (reported baseline)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Arithmetic word-problem benchmark used to evaluate chain-of-thought based methods.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>PaLM self-consistency reported accuracy 74.4% on GSM8K (cited from prior work)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other_method</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>performance_other_method</strong></td>
                            <td>DiVERSE (PaLM not run in this paper) but DiVERSE with code-davinci-002 reached 82.3% on GSM8K; paper compares DiVERSE results to PaLM self-consistency as a gold-standard prior result.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Self-consistency (sampling-only + majority voting) is a strong baseline; DiVERSE claims further improvements by introducing prompt-level diversity plus a verifier-weighted voting mechanism and step-aware supervision, surpassing self-consistency on many tasks even when applied to much smaller (public) models.</td>
                        </tr>
                        <tr>
                            <td><strong>counter_examples_or_negative_results</strong></td>
                            <td>Paper notes that self-consistency on PaLM still slightly outperforms DiVERSE on some commonsense multiple-choice tasks (DiVERSE was slightly lower by ~1.9% on average for the two commonsense tasks), potentially due to noise in pseudo exemplars.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Chain of thought prompting elicits reasoning in large language models <em>(Rating: 2)</em></li>
                <li>Self-consistency improves chain of thought reasoning in language models <em>(Rating: 2)</em></li>
                <li>PaLM: Scaling language modeling with pathways <em>(Rating: 1)</em></li>
                <li>Training verifiers to solve math word problems <em>(Rating: 1)</em></li>
                <li>Least-to-most prompting enables complex reasoning in large language models <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-4938",
    "paper_id": "paper-760561c57f68044e2f1d089088df1da6c627b09a",
    "extraction_schema_id": "extraction-schema-105",
    "extracted_data": [
        {
            "name_short": "DiVERSE (code-davinci-002,GSM8K)",
            "name_full": "DiVERSE: Diverse Verifier on Reasoning Step (evaluation with code-davinci-002 on GSM8K)",
            "brief_description": "DiVERSE combines diverse prompts (multiple exemplar sets), sampling, a verifier that scores candidate reasoning paths, voting weighted by verifier scores, and an optional step-aware verifier that assigns correctness labels to individual steps; evaluated with code-davinci-002 on arithmetic benchmarks.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "code-davinci-002",
            "model_description": "OpenAI instruction-tuned model (exact parameter count not disclosed in paper); used with sampling temperature 0.5. The paper treats code-davinci-002 as a high-performance LLM in experiments.",
            "reasoning_method_name": "DiVERSE (diverse prompts + voting verifier + step-aware verifier)",
            "reasoning_method_type": "diverse",
            "reasoning_method_description": "Generate M = M1 * M2 candidate chain-of-thought reasoning paths by sampling from multiple different prompts (varying exemplars) and sampling decoding; use a fine-tuned verifier (deberta-v3-large backbone) to score each path; aggregate answers via weighted voting using verifier scores; optionally apply a step-aware loss and a verifier that scores individual reasoning steps to improve selection.",
            "task_name": "GSM8K",
            "task_description": "GSM8K is a benchmark of grade-school math word problems requiring multi-step arithmetic reasoning; evaluation metric is answer accuracy.",
            "performance": "accuracy 82.3%",
            "comparison_with_other_method": true,
            "performance_other_method": "Self-Consistency (sampling 100 paths + majority voting) accuracy 76.7% (code-davinci-002); Greedy decode single chain accuracy 55.3%",
            "key_findings": "DiVERSE (diverse prompts + voting verifier) outperforms self-consistency (sampling-only + majority voting) on GSM8K with code-davinci-002 by 5.6 percentage points; combining diverse prompts (vary exemplars) with sampling yields better distinct reasoning paths and higher accuracy than sampling alone.",
            "counter_examples_or_negative_results": "The step-aware verifier variant slightly reduced performance for code-davinci-002 on GSM8K (DiVERSE without step: 82.3% vs with step: 81.5%), indicating that step-level supervision does not uniformly improve every model/task.",
            "uuid": "e4938.0"
        },
        {
            "name_short": "DiVERSE (text-davinci-002,GSM8K)",
            "name_full": "DiVERSE: Diverse Verifier on Reasoning Step (evaluation with text-davinci-002 on GSM8K)",
            "brief_description": "Same DiVERSE pipeline evaluated with text-davinci-002, showing substantial gains over self-consistency and greedy decoding on GSM8K.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "text-davinci-002",
            "model_description": "OpenAI instruction-tuned model (parameter count hidden); used with sampling temperature 0.5 in experiments.",
            "reasoning_method_name": "DiVERSE (diverse prompts + voting verifier + step-aware verifier)",
            "reasoning_method_type": "diverse",
            "reasoning_method_description": "See DiVERSE description: multiple prompts (M1 different exemplar sets) × sampling (M2 paths per prompt), verifier scoring, and weighted voting; optional step-aware verifier labels individual reasoning steps.",
            "task_name": "GSM8K",
            "task_description": "Grade-school math word problems benchmark; metric: accuracy.",
            "performance": "accuracy 70.2%",
            "comparison_with_other_method": true,
            "performance_other_method": "Self-Consistency (sampling 100 paths + majority voting) accuracy 58.2% (text-davinci-002); Greedy decode accuracy 37.1%",
            "key_findings": "DiVERSE produced a large improvement over self-consistency (12.0 percentage points) with text-davinci-002 on GSM8K, supporting the hypothesis that inducing diverse reasoning paths via varying prompts plus verifier-weighted voting yields more robust answer selection.",
            "counter_examples_or_negative_results": "None reported for this model-task pair; step-aware verifier further improved performance (68.9% without step -&gt; 70.2% with step).",
            "uuid": "e4938.1"
        },
        {
            "name_short": "DiVERSE (davinci,GSM8K)",
            "name_full": "DiVERSE: Diverse Verifier on Reasoning Step (evaluation with davinci on GSM8K)",
            "brief_description": "DiVERSE applied to GPT-3 davinci model shows substantial gains over greedy or self-consistency baselines on GSM8K, though absolute accuracy remains lower than larger instruction-tuned variants.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "davinci (GPT-3)",
            "model_description": "GPT-3 base 'davinci' model with 175B parameters (as cited in the paper for GPT-3 davinci); used as one of the evaluated LMs.",
            "reasoning_method_name": "DiVERSE (diverse prompts + voting verifier + step-aware verifier)",
            "reasoning_method_type": "diverse",
            "reasoning_method_description": "Generate multiple chain-of-thought paths from several distinct prompts and sampled decodings, score with a fine-tuned verifier, then aggregate by weighted voting; optionally incorporate step-level labeling to guide verifier.",
            "task_name": "GSM8K",
            "task_description": "Grade-school math word problems requiring multi-step arithmetic reasoning; measured by accuracy.",
            "performance": "accuracy 30.9%",
            "comparison_with_other_method": true,
            "performance_other_method": "Self-Consistency (sampling 100 paths + majority voting) accuracy 18.9%; Greedy decode accuracy 8.7%",
            "key_findings": "DiVERSE boosts a weaker model (davinci) considerably (+12.0% over self-consistency and +22.2% over greedy decoding on GSM8K), showing that diversity in prompts and verifier-weighted voting can recover correct answers that are minority outputs.",
            "counter_examples_or_negative_results": "Absolute performance remains far below stronger models; no instance where similar methods beat DiVERSE on this model/task in reported results.",
            "uuid": "e4938.2"
        },
        {
            "name_short": "Diverse prompts vs Sampling-only (majority voting)",
            "name_full": "Comparison of Diverse Prompts (varying exemplar sets) versus Sampling-only (single prompt, many samples) under majority voting",
            "brief_description": "Empirical comparison showing that using multiple different prompts (diverse exemplars) combined with sampling yields better diversity of reasoning paths and higher accuracy under majority voting than sampling-only from a single prompt.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "code-davinci-002 (example reported)",
            "model_description": "OpenAI model (parameter count undisclosed in paper); experiments compare different M1 (number of distinct prompts) and M2 (samples per prompt) settings.",
            "reasoning_method_name": "Diverse prompts (M1&gt;1) + sampling (M2) under majority voting vs Sampling-only (M1=1, M2 large)",
            "reasoning_method_type": "diverse versus similar",
            "reasoning_method_description": "Diverse prompts: for each question randomly select M1 different exemplar prompt templates and sample M2 reasoning paths per prompt (total M=M1*M2). Sampling-only: use a fixed prompt (M1=1) and sample many (M2 large) decodings. Both aggregated by majority voting over final answers.",
            "task_name": "GSM8K (majority voting experiments)",
            "task_description": "Arithmetic reasoning benchmark; experiments evaluate majority-vote accuracy as M1/M2 vary.",
            "performance": "code-davinci-002 majority-vote accuracy: M1=1,M2=100 -&gt; 76.7%; M1=5,M2=20 -&gt; 80.0%; M1=10,M2=10 -&gt; 79.8%; M1=100,M2=1 -&gt; 73.0%",
            "comparison_with_other_method": true,
            "performance_other_method": "Sampling-only (M1=1,M2=100) accuracy 76.7% (code-davinci-002)",
            "key_findings": "Combining diverse prompts (M1&gt;1) with sampling (M2&gt;1) yields higher majority-vote accuracy than pure sampling from a single prompt; the best balance observed was M1=5,M2=20 for code-davinci-002 (80.0%). Diverse prompts increase the number of distinct reasoning paths and distinct final answers, making correct outputs more distinguishable.",
            "counter_examples_or_negative_results": "Extremely many distinct prompts with only one sample each (M1=100,M2=1) performed worse (73.0%), indicating that both within-prompt sampling and across-prompt diversity are needed—neither extreme alone is optimal.",
            "uuid": "e4938.3"
        },
        {
            "name_short": "Voting Verifier vs Majority and Verifier-only",
            "name_full": "Voting Verifier: weighted voting by verifier scores compared to majority voting and verifier-only selection",
            "brief_description": "The voting verifier multiplies vote counts by verifier-produced probabilities to select the final answer; it outperforms plain majority voting and often improves over using the verifier alone.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "code-davinci-002 (reported example); also evaluated on text-davinci-002 and davinci",
            "model_description": "OpenAI models; experiments compare aggregation algorithms given the same pool of candidate reasoning paths.",
            "reasoning_method_name": "Voting Verifier (weighted voting by verifier scores)",
            "reasoning_method_type": "diverse (aggregation over diverse candidate paths)",
            "reasoning_method_description": "Compute for each candidate path a verifier score f(x_i,z_i,y_i) estimating probability path leads to correct answer; aggregate candidate answers by summing verifier scores for each distinct final answer and selecting argmax (weighted voting). Compared to majority voting (simple count) and verifier-only (choose single highest-scoring path).",
            "task_name": "GSM8K (example), CommonsenseQA, CLUTRR (reported)",
            "task_description": "Reasoning benchmarks across arithmetic, commonsense, and inductive reasoning; measure final-answer accuracy.",
            "performance": "code-davinci-002 on GSM8K: Voting (majority voting) 80.0%; Verifier-only 65.9%; Voting Verifier 82.3%. (Similar patterns reported on other models/tasks: e.g., text-davinci-002 GSM8K Voting 61.3% / Verifier 62.7% / Voting Verifier 68.9%)",
            "comparison_with_other_method": true,
            "performance_other_method": "Majority voting (self-consistency) and Verifier-only listed above",
            "key_findings": "Voting Verifier consistently and significantly boosts performance relative to majority voting; verifier-only can outperform majority voting in some cases, but combining both (voting verifier) gives the best results in many settings.",
            "counter_examples_or_negative_results": "On some tasks/models verifier-only already outperforms majority voting (e.g., verifier &gt; voting), showing that majority voting can be fragile if many sampled paths are low-quality; but overall voting verifier usually adds additional gains.",
            "uuid": "e4938.4"
        },
        {
            "name_short": "Step-aware Verifier (effect)",
            "name_full": "Step-aware Voting Verifier: adding step-level supervision to the voting verifier",
            "brief_description": "Step-aware verifier extends the voting verifier by predicting a correctness label per reasoning step and using an auxiliary loss to improve verifier judgments and interpretability. Evaluated across models/tasks with mostly positive impact but with some exceptions.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "text-davinci-002, davinci, code-davinci-002 (evaluated)",
            "model_description": "OpenAI models used in experiments; step-aware verifier is a fine-tuned DEBERTA-V3-LARGE with an auxiliary token-level head to score steps.",
            "reasoning_method_name": "Step-aware Voting Verifier",
            "reasoning_method_type": "diverse (applies to diverse candidate pools)",
            "reasoning_method_description": "Introduce step-level labels indicating which intermediate steps are correct by comparing negative paths to positive ones (or via NLI model for semantics); train verifier with an auxiliary BCE loss on step labels (controlled by hyperparameter alpha) so verifier can predict correctness of each step; use these predictions to inform weighted voting.",
            "task_name": "GSM8K and CommonsenseQA (reported examples)",
            "task_description": "GSM8K arithmetic reasoning and CommonsenseQA multiple-choice commonsense reasoning; evaluated by final-answer accuracy and human evaluation of intermediate steps.",
            "performance": "GSM8K: davinci DiVERSE without step 30.6% -&gt; with step 30.9%; text-davinci-002 without step 68.9% -&gt; with step 70.2%; code-davinci-002 without step 82.3% -&gt; with step 81.5% (slight decrease). CommonsenseQA: davinci 75.0% -&gt; 76.0%; text-davinci-002 79.2% -&gt; 79.8%; code-davinci-002 78.8% -&gt; 79.9%.",
            "comparison_with_other_method": true,
            "performance_other_method": "DiVERSE without step-aware verifier (see values above per model)",
            "key_findings": "Step-aware supervision generally improves selection quality and interpretability by helping the verifier detect where a reasoning path goes wrong and by increasing the number of correct intermediate steps in failed paths; improvements are modest and model-dependent. Human evaluation shows step-aware verifier reduces redundant steps and tends to produce more correct steps before errors occur.",
            "counter_examples_or_negative_results": "For code-davinci-002 on GSM8K the step-aware mechanism slightly lowered overall accuracy (82.3% -&gt; 81.5%), suggesting more capable LMs may gain less or could be slightly harmed by imperfect step labeling or auxiliary supervision.",
            "uuid": "e4938.5"
        },
        {
            "name_short": "Self-Consistency (PaLM mention)",
            "name_full": "Self-Consistency: sampling many chain-of-thought paths and selecting the most consistent final answer (PaLM reported results)",
            "brief_description": "Self-consistency aggregates many sampled chain-of-thought outputs by majority voting on final answers; reported as a strong baseline (especially with PaLM-540B) in the literature and in this paper's comparisons.",
            "citation_title": "Self-consistency improves chain of thought reasoning in language models",
            "mention_or_use": "mention",
            "model_name": "PaLM (reported; 540B)",
            "model_description": "PaLM is a large Transformer-based language model with 540B parameters (Chowdhery et al., 2022); self-consistency results cited from prior work using PaLM.",
            "reasoning_method_name": "Self-Consistency (sampling + majority voting)",
            "reasoning_method_type": "similar (sampling many outputs from a fixed prompt)",
            "reasoning_method_description": "Generate many chain-of-thought reasoning paths by sampling from a fixed prompt (same exemplar set). Aggregate final answers by majority voting (the most frequent final answer among sampled outputs is chosen).",
            "task_name": "GSM8K (reported baseline)",
            "task_description": "Arithmetic word-problem benchmark used to evaluate chain-of-thought based methods.",
            "performance": "PaLM self-consistency reported accuracy 74.4% on GSM8K (cited from prior work)",
            "comparison_with_other_method": true,
            "performance_other_method": "DiVERSE (PaLM not run in this paper) but DiVERSE with code-davinci-002 reached 82.3% on GSM8K; paper compares DiVERSE results to PaLM self-consistency as a gold-standard prior result.",
            "key_findings": "Self-consistency (sampling-only + majority voting) is a strong baseline; DiVERSE claims further improvements by introducing prompt-level diversity plus a verifier-weighted voting mechanism and step-aware supervision, surpassing self-consistency on many tasks even when applied to much smaller (public) models.",
            "counter_examples_or_negative_results": "Paper notes that self-consistency on PaLM still slightly outperforms DiVERSE on some commonsense multiple-choice tasks (DiVERSE was slightly lower by ~1.9% on average for the two commonsense tasks), potentially due to noise in pseudo exemplars.",
            "uuid": "e4938.6"
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Chain of thought prompting elicits reasoning in large language models",
            "rating": 2
        },
        {
            "paper_title": "Self-consistency improves chain of thought reasoning in language models",
            "rating": 2
        },
        {
            "paper_title": "PaLM: Scaling language modeling with pathways",
            "rating": 1
        },
        {
            "paper_title": "Training verifiers to solve math word problems",
            "rating": 1
        },
        {
            "paper_title": "Least-to-most prompting enables complex reasoning in large language models",
            "rating": 1
        }
    ],
    "cost": 0.01595,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Making Large Language Models Better Reasoners with Step-Aware Verifier</h1>
<p>Yifei $\mathbf{L i}^{1,2}$; Zeqi Lin ${ }^{2}$, Shizhuo Zhang ${ }^{2}$, Qiang $\mathbf{F u}^{2}$, Bei Chen ${ }^{2}$, Jian-Guang Lou ${ }^{2}$, Weizhu Chen ${ }^{2}$<br>${ }^{1}$ National Key Laboratory for Multimedia Information Processing, School of Computer Science, Peking University ${ }^{2}$ Microsoft Corporation<br>{yifeili, zeqi.lin, v-shizzhang, qifu, bei.chen, jlou, wzchen}@microsoft.com<br>liyifei@stu.pku.edu.cn</p>
<h4>Abstract</h4>
<p>Few-shot learning is a challenging task that requires language models to generalize from limited examples. Large language models like GPT-3 and PaLM have made impressive progress in this area, but they still face difficulties in reasoning tasks such as GSM8K, a benchmark for arithmetic problems. To improve their reasoning skills, previous work has proposed to guide the language model with prompts that elicit a series of reasoning steps before giving the final answer, achieving a significant improvement on GSM8K from $17.9 \%$ to $58.1 \%$ in problem-solving rate. In this paper, we present DiVERSE (Diverse Verifier on Reasoning Step), a novel approach that further enhances the reasoning capability of language models. DiVERSE has three main components: first, it generates diverse prompts to explore different reasoning paths for the same question; second, it uses a verifier to filter out incorrect answers based on a weighted voting scheme; and third, it verifies each reasoning step individually instead of the whole chain. We evaluate DiVERSE on the latest language model code-davinci-002 and show that it achieves new state-of-the-art results on six of eight reasoning benchmarks (e.g., GSM8K $74.4 \% \rightarrow 83.2 \%$ ).</p>
<h2>1 Introduction</h2>
<p>Large pretrained language models (PLMs) have shown remarkable performance on various natural language processing tasks, either by few-shot learning with prompts (Radford et al., 2019; Le Scao and Rush, 2021; Jin et al., 2022) or by fine-tuning (Houlsby et al., 2019; Hu et al., 2021; He et al., 2022). However, despite the increasing size and capacity of PLMs such as GPT-3 with 175B parameters (Brown et al., 2020) and PaLM with 540B parameters (Chowdhery et al., 2022), their reasoning abilities are still limited and often require mul-</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Our proposed method, DiVERSE (Diverse Verifier on Reasoning Step).
tiple steps to produce correct answers, especially for tasks involving arithmetic, commonsense, or inductive reasoning (Cobbe et al., 2021).</p>
<p>Recent works (Wei et al., 2022; Zhou et al., 2022; Kojima et al., 2022; Lampinen et al., 2022) have demonstrated that PLMs possess some latent reasoning capabilities, but they need carefully designed prompts to activate them. For instance, Wei et al. (2022) proposed chain-of-thought reasoning, which inserts multi-step reasoning paths before generating the final answers, and achieved significant improvement on the GSM8K arithmetic benchmark (Cobbe et al., 2021). Wang et al. (2022c) further introduced a voting mechanism to select the most consistent answer among different reasoning paths, and achieved state-of-the-art results on several reasoning benchmarks using the PaLM model (Chowdhery et al., 2022). Building on these successes, this paper continues this line of research and advances the reasoning capabilities of PLMs in three aspects, as illustrated in Figure 1.</p>
<p>First, we propose to increase the diversity of reasoning paths by not only sampling from a single prompt, but also varying the prompt itself. We hypothesize that different prompts can elicit different ways of thinking, while the correct answer should be robust to these variations. Second, we propose to use a verifier to score the quality of each reasoning path and guide the voting mechanism. We argue that not all reasoning paths are equally good</p>
<table>
<thead>
<tr>
<th>Chain Of-Thought Reasoning for GSM8K Math Word Problem</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Q: If there are 3 cars in the parking lot and 2 more</td>
<td></td>
</tr>
<tr>
<td>cars arrive, how many cars are in the parking lot?</td>
<td></td>
</tr>
<tr>
<td>A: There are 3 cars in the parking lot already. 2 more</td>
<td></td>
</tr>
<tr>
<td>arrive. Now there are $3+2=5$ cars. The answer is 5.</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>Q: Janet’s ducks lay 16 eggs per day. She eats three</td>
<td></td>
</tr>
<tr>
<td>for breakfast every morning and bakes muffins for her</td>
<td></td>
</tr>
<tr>
<td>friends every day with four. She sells the remainder</td>
<td></td>
</tr>
<tr>
<td>for \$2 per egg. How much does she make every day?</td>
<td></td>
</tr>
<tr>
<td>A: She has 16 - 3 - $4=9$ eggs left. So she makes</td>
<td></td>
</tr>
<tr>
<td>$2 * 9=18$ per day. The answer is 18.</td>
<td></td>
</tr>
</tbody>
</table>
<p>Figure 2: Chain-of-thought reasoning for GSM8K math word problem. The prompt is colored black and the reasoning path produced by the language model is colored teal. This reasoning path contains two reasoning steps.
or reliable, and some may contain errors or inconsistencies that can be detected by the verifier. Third, we propose to assign a fine-grained label to each step of the reasoning path and use a step-aware verifier to attribute the correctness or wrongness of the final answer to each step. We conjecture that some steps may be correct but followed by wrong steps or vice versa, and identifying these cases can help diagnose and improve the reasoning process.</p>
<p>We name our method as DiVERSE (diverse verifier on reasoning step) and evaluate it on eight reasoning benchmarks that require different types of reasoning skills. We use three OpenAI PLMs (davinci, text-davinci-002, and code-davinci-002) and compare our results with recent state-of-the-art methods. We find that DiVERSE can consistently and significantly improve the performance of PLMs on these tasks, and achieve new state-of-the-art results on six of them ${ }^{1}$ : GSM8K $(74.4 \% \rightarrow 83.2 \%)$, AsDiv $(81.9 \% \rightarrow 88.7 \%)$, MultiArith $(99.3 \% \rightarrow$ $99.8 \%)$, SVAMP $(86.6 \% \rightarrow 87.0 \%)$, SingleEq $(79.5 \% \rightarrow 94.9 \%)$, and CLUTRR $(67.0 \% \rightarrow$ $95.9 \%)$.</p>
<p>Our data is publicly available at https://github. com/microsoft/DiVeRSe.</p>
<h2>2 Diverse Verifier on Reasoning Step</h2>
<p>Figure 1 shows the overview of DiVERSE. The key insights are three-fold: (1) leveraging diverse prompts to induce more diverse reasoning paths from the language models (Section 2.1); (2) train-</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup>ing a voting verifier to better derive the final answers from multiple reasoning paths (Section 2.2); (3) leveraging step correctness to further boost the voting verifier (Section 2.3).</p>
<h3>2.1 Diverse Prompts</h3>
<p>To reason effectively, it is beneficial to explore diverse reasoning paths, following the idea that "All Roads lead to Rome". Wang et al. (2022c) proposed to generate various reasoning paths from language models by sampling decoding. However, their method relies on a fixed set of exemplars for all prompts, which may introduce bias and limit the diversity of the generated reasoning paths. To address this issue, we randomly select $M_{1}$ different prompts for each question, and then sample $M_{2}$ reasoning paths for each prompt using sampling decoding. This way, we obtain $M=M_{1} \times M_{2}$ diverse reasoning paths for each question. ${ }^{2}$</p>
<h3>2.2 Voting Verifier</h3>
<p>Verifier. The verifier takes a question and a candidate reasoning path as input, and outputs the probability that the reasoning path leads to the correct answer. We use debería-v3-large (He et al., 2021) as the backbone model, with a small scalar head that outputs predictions on the $[\mathbf{C L S}]$ token.</p>
<p>Training the verifier. For each training question, we generate multiple candidate reasoning paths using chain-of-thought reasoning. We regard the reasoning paths that match the ground truth final answer as positive, and the others as negative.</p>
<p>Voting Verifier. Wang et al. (2022c) use majority voting to aggregate the predictions of different reasoning paths. This method may fail when the majority of the reasoning paths are misled, while the minority of the reasoning paths are reasonable. We propose voting verifier, which leverages both voting and verifier:</p>
<p>$$
\hat{\mathbf{y}}=\underset{\mathbf{y}}{\arg \max } \sum_{i=1}^{M} \mathbb{1}<em i="i">{\mathbf{y}</em>}=\mathbf{y}} \cdot f\left(\mathbf{x<em i="i">{i}, \mathbf{z}</em>\right)
$$}, \mathbf{y}_{i</p>
<p>where $\mathbb{1}<em i="i">{\mathbf{y}</em>$ (or not), and $f(\cdot)$ is the probability produced by the verifier.}=\mathbf{y}}$ is an indicator function that returns 1 (or 0 ) if $\mathbf{y}_{i}=\mathbf{y</p>
<h3>2.3 Step-aware Voting Verifier</h3>
<p>Each reasoning path consists of several steps. We hypothesize that not all the steps in an incorrect</p>
<p><sup id="fnref:1"><a class="footnote-ref" href="#fn:1">2</a></sup></p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 3: How step-level labels are extracted. This figure shows four reasoning paths for a math word problem: the first two are positive and the bottom two are negative. The path 7 → 9 → 18 means that the first step calculates 7, the second step calculates 9, and the third step calculates the final answer 18. For the last path, the third step (which calculates 8) has never occurred in any positive reasoning paths, thus we regard this step and all steps after it as negative steps.</p>
<p>Reasoning paths are equally wrong, and some steps may still be useful for reasoning. To exploit this, we extend the voting verifier to a step-aware voting verifier by introducing an extended loss function:</p>
<p>$$\mathcal{L} = \mathcal{L}_0 + \alpha \cdot \mathcal{L}_1,$$</p>
<p>$$\mathcal{L}<em i="1">1 = \sum</em>}^{|\hat{D}|} \sum_{j=1}^{|S_i|} \text{BCE}(\text{label<em i="i">{i,j}, f'(\text{input}</em>, j)).$$</p>
<p>α is a hyperparameter to balance the original loss $\mathcal{L}<em i_1="i,1">0$ and the step-level auxiliary loss $\mathcal{L}_1$; $S</em>}, S_{i,2}, ..., S_{i,|S_i|}$ are the steps in $\mathbf{z<em i_j="i,j">i$; $\text{label}</em>}$ indicates whether $S_{i,j}$ is correct or not; $f'(\text{input<em i_j="i,j">{i}, j)$ represents the probability of the positive label for $S</em>$<sup>3</sup>.</p>
<p>To obtain the step-level labels (i.e., $\text{label}_{i,j}$) for negative training data with wrong answers, we design an algorithm that compares intermediate results among steps in positive/negative reasoning paths. Figure 3 illustrates this algorithm. This algorithm can not only work on math word problems, but also generalize to other reasoning tasks: we use an off-the-shelf natural language inference model, <em>roberta-large-mnli</em> (Liu et al., 2019), to check whether two reasoning steps are semantically equivalent or not. Given a reasoning step, if we cannot find any semantically equivalent step in the positive reasoning paths, we label it and all the subsequent steps as negative steps.</p>
<h3>3 Experimental Setup</h3>
<h4>3.1 Reasoning Tasks</h4>
<p><strong>Arithmetic Reasoning.</strong> Following Wang et al. (2022c), we use AsDiv (Miao et al., 2020), SingleEq (Koncel-Kedziorski et al., 2015), MultiArith (Roy and Roth, 2015), SVAMP (Patel et al., 2021), and GSM8K (Cobbe et al., 2021).</p>
<p><strong>Commonsense Reasoning.</strong> Following Wang et al. (2022c), we use CommonsenseQA (Talmor et al., 2019) and StrategyQA (Geva et al., 2021).</p>
<p><strong>Inductive Reasoning.</strong> We use CLUTRR (Sinha et al., 2019), a diagnostic benchmark for inductive reasoning, requiring inferring kinship relations between characters in short stories.</p>
<h4>3.2 Details</h4>
<p><strong>Language Models.</strong> We use three OpenAI language models: <em>davinci</em>, <em>text-davinci-002</em> and <em>code-davinci-002</em>. We use the default parameters except a temperature of 0.5 in sampling.</p>
<p><strong>Exemplars.</strong> For arithmetic/commonsense/inductive reasoning, each prompt contains 5/7/7 exemplars. For DIVERSE, each question has 5 different prompts, and 20 reasoning paths are sampled from the language model for each prompt. For arithmetic reasoning, the exemplars are randomly sampled from the training dataset of GSM8K; for CLUTRR, the exemplars are sampled from its training dataset, with reasoning paths synthesized by handcraft rules (detailed settings for CLUTRR are listed in Appendix D); for StrategyQA and CommonsenseQA, their original datasets do not contain enough exemplars with well-annotated reasoning paths, so we construct 1,000 pseudo exemplars by "self-teaching" (the approach and the noise issue are discussed in Appendix B) from "seed" exemplars provided by Wei et al. (2022).</p>
<p><strong>Training Datasets.</strong> For each task, we sample 1,000 <question, answer> pairs from the training dataset to train the verifier.</p>
<p><strong>Verifier.</strong> We fine-tune <em>deberta-v3-large</em> (He et al., 2021) with learning rate 1 × 10<sup>−5</sup> and batch size 128. For the step-aware verifier, we select the best α among 0.0/0.1/0.2/0.3.</p>
<p><sup>3</sup>Specifically, $f'(\text{input}<em i_j="i,j">i, j)$ is predicted from the hidden state of the last token of $S</em>$ in DEBERTA-V3-LARGE, similar to token classification tasks.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>GSM8K</th>
<th>Ad5tr</th>
<th>MultiArith</th>
<th>SV6MP</th>
<th>SingleEq</th>
<th>CommonsenseQA</th>
<th>StrategyQA</th>
<th>CLUTER</th>
</tr>
</thead>
<tbody>
<tr>
<td>Previous SOTA (Fine-tuning)</td>
<td>$57^{\text {th }}$</td>
<td>$75.3^{\text {th }}$</td>
<td>$60.5^{\text {th }}$</td>
<td>$57.4^{\text {th }}$</td>
<td>$32.5^{\text {th }}$</td>
<td>$91.2^{\text {th }}$</td>
<td>$73.9^{\text {th }}$</td>
<td>$67.0^{\text {th }}$</td>
</tr>
<tr>
<td>9-12 year olds (Cobbe et al., 2021)</td>
<td>60</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>LaMDA [37B]</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Greedy Decode</td>
<td>17.1</td>
<td>49.0</td>
<td>51.8</td>
<td>38.9</td>
<td>56.6</td>
<td>57.9</td>
<td>65.4</td>
<td>-</td>
</tr>
<tr>
<td>Self-Consistency</td>
<td>27.7</td>
<td>58.2</td>
<td>75.7</td>
<td>53.3</td>
<td>-</td>
<td>63.1</td>
<td>67.8</td>
<td>-</td>
</tr>
<tr>
<td>PaLM [40B]</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Greedy Decode</td>
<td>56.5</td>
<td>74.0</td>
<td>94.7</td>
<td>79.0</td>
<td>79.5</td>
<td>79.0</td>
<td>75.3</td>
<td>-</td>
</tr>
<tr>
<td>Self-Consistency</td>
<td>74.4</td>
<td>81.9</td>
<td>99.3</td>
<td>86.6</td>
<td>-</td>
<td>80.7</td>
<td>81.6</td>
<td>-</td>
</tr>
<tr>
<td>GPT-3 davinci [175B]</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Greedy Decode</td>
<td>8.7</td>
<td>31.4</td>
<td>31.4</td>
<td>21.2</td>
<td>38.2</td>
<td>48.2</td>
<td>59.2</td>
<td>33.6</td>
</tr>
<tr>
<td>Self-Consistency</td>
<td>18.9</td>
<td>52.8</td>
<td>68.6</td>
<td>44.6</td>
<td>59.6</td>
<td>57.4</td>
<td>65.6</td>
<td>42.5</td>
</tr>
<tr>
<td>DiVERSE</td>
<td>30.9 (+12.0)</td>
<td>57.6 (+4.8)</td>
<td>87.6 (+19.0)</td>
<td>46.9 (+2.3)</td>
<td>65.1 (+5.5)</td>
<td>75.0 (+17.6)</td>
<td>66.3 (+0.7)</td>
<td>92.5 (+30.0)</td>
</tr>
<tr>
<td>text-davinci-002</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Greedy Decode</td>
<td>37.1</td>
<td>60.8</td>
<td>70.7</td>
<td>60.0</td>
<td>73.3</td>
<td>65.5</td>
<td>57.8</td>
<td>32.4</td>
</tr>
<tr>
<td>Self-Consistency</td>
<td>58.2</td>
<td>76.9</td>
<td>88.4</td>
<td>78.2</td>
<td>87.2</td>
<td>72.9</td>
<td>69.8</td>
<td>34.9</td>
</tr>
<tr>
<td>DiVERSE</td>
<td>70.2 (+12.0)</td>
<td>83.5 (+6.6)</td>
<td>96.4 (+8.0)</td>
<td>82.7 (+4.5)</td>
<td>86.5 (-0.7)</td>
<td>79.2 (+6.3)</td>
<td>74.8 (+5.0)</td>
<td>93.8 (+58.9)</td>
</tr>
<tr>
<td>code-davinci-002</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Greedy Decode</td>
<td>55.3</td>
<td>75.5</td>
<td>88.8</td>
<td>70.5</td>
<td>87.5</td>
<td>73.4</td>
<td>72.0</td>
<td>32.9</td>
</tr>
<tr>
<td>Self-Consistency</td>
<td>76.7</td>
<td>86.2</td>
<td>98.6</td>
<td>85.8</td>
<td>93.7</td>
<td>77.3</td>
<td>77.6</td>
<td>35.6</td>
</tr>
<tr>
<td>DiVERSE</td>
<td>82.3 (+5.6)</td>
<td>88.7 (+1.5)</td>
<td>99.8 (+1.2)</td>
<td>87.0 (+1.2)</td>
<td>94.9 (+1.2)</td>
<td>79.9 (+2.6)</td>
<td>78.6 (+1.0)</td>
<td>95.9 (+66.3)</td>
</tr>
</tbody>
</table>
<p>Table 1: The comparison of DiVERSE, Greedy Decode and Self-Consistency. The previous SOTA results (fine-tuned on non-gigantic pretrained transformers) are: $a$ : <em>Cobbe et al. (2021)</em>, $b$ : <em>Miao et al. (2020)</em>, $c$ : <em>Roy and Roth (2015)</em>, $d$ : <em>Pi et al. (2022)</em>, $e$ : <em>Hu et al. (2019a)</em>, $f$ : <em>Xu et al. (2021)</em>, $g$ : <em>Chowdhery et al. (2022)</em>, $h$ : <em>Sinha et al. (2019)</em>. The parameter number of either text-davinci-002 or code-davinci-002 is hidden to us.</p>
<table>
<thead>
<tr>
<th>Question</th>
<th>Self-Consistency</th>
<th>DiVERSE</th>
</tr>
</thead>
<tbody>
<tr>
<td>[GSM8K] <em>Mark decides to buy packs of old magic cards and open them to sell. He buys 3 packs for $\$ 1000$ each. He gets 1 card that is worth $\$ 4000$ and another card worth $\$ 1000$. There are 30 more cards worth an average of $\$ 50$ each. How much money profit did he make?</em></td>
<td>Mark bought 3 packs for $\$ 1800$ each for a total of $\$ 1800 * 3=5400$; 68.1% . He got 1 card worth $\$ 4000$ and another card worth $\$ 1000$ for a total of $\$ 4000+\$ 1000=\$ 5000$; 7.1% . There were 30 more cards worth an average of $\$ 50$ each for a total of $\$ 50 * 30=1500$; 63.7% . Mark made a profit of $\$ 5000+\$ 1500=6500$; 7.1% . The answer is 6500 . Answer: 6500 (Wrong)</td>
<td>The cheaper cards are worth a total of $30 * 50=1500$; 64.4% . So all the cards together are worth $1500+4000+1000=6500$; 7.1% . The cost for the cards was $1800 * 3=5400$; 6.1% . So he made a profit of $6500-5400=1100$; 0.0% . The answer is 1100 . Answer: 1100 (Correct)</td>
</tr>
</tbody>
</table>
<p>Table 2: A GSM8K example (code-davinci-002) with step-level scores given by the step-aware verifier. The scores can not only improve the performance but also help the understanding of where the reasoning paths start to be incorrect.</p>
<h2>4 Main Results</h2>
<p>Table 1 shows the overall experimental results. We mainly compare DiVERSE with two baselines: (1) greedily decoding a single reasoning path (Wei et al., 2022), referred to as Greedy Decode; (2) sampling 100 reasoning paths, then select the final answer via majority voting (Wang et al., 2022c), referred to as Self-Consistency.</p>
<h3>4.1 Effectiveness</h3>
<p>Experimental results clearly demonstrate that DiVERSE can bring significant and consistent improvements over recent strong baselines. The improvements are across different models (davinci, text-davinci-002 and code-davinci-002) as well as different reasoning skills (eight tasks in three reasoning skills). Taking GSM8K as an example, compared to Greedy Decoding and Self-Consistency, DiVERSE brings improvements of $22.2 \% / 12.0 \%$ on davinci, $33.1 \% / 12.0 \%$ on text-davinci-002, and $27.0 \% / 5.6 \%$ on code-davinci-002. Compared to</p>
<p>Self-Consistency, DiVERSE achieves average improvements of $5.6 \% / 5.1 \% / 54.3 \%$ on the three reasoning skills, respectively.</p>
<h3>4.2 Comparing to Previous SOTAs</h3>
<p>In Table 1, we also compare DiVERSE with: (1) previous SOTA results based on fine-tuning; (2) recent SOTA results (Wei et al., 2022) based on PaLM (Chowdhery et al., 2022), a gigantic language model with 540 billion parameters.</p>
<p>On all the five arithmetic reasoning tasks, DiVERSE (with code-davinci-002) achieves new SOTA results, with an average improvement of $6.2 \%$. On the two commonsense reasoning tasks, the performance of DiVERSE is slightly lower $(-1.9 \%)$ than that of PaLM-based self-consistency. We speculate that the reason might be: these two commonsense reasoning tasks are multiple-choice tasks rather than open-ended generation tasks, re-</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<table>
<thead>
<tr>
<th>Method</th>
<th>GSM8K</th>
<th>CQA</th>
<th>CLUTRR</th>
</tr>
</thead>
<tbody>
<tr>
<td>davinci:</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$M_{1}=1,M_{2}=100$</td>
<td>18.9</td>
<td>57.4</td>
<td>42.5</td>
</tr>
<tr>
<td>$M_{1}=5,M_{2}=20$</td>
<td>21.3</td>
<td>57.5</td>
<td>45.9</td>
</tr>
<tr>
<td>text-davinci-002:</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$M_{1}=1,M_{2}=100$</td>
<td>58.2</td>
<td>72.9</td>
<td>34.9</td>
</tr>
<tr>
<td>$M_{1}=5,M_{2}=20$</td>
<td>61.3</td>
<td>77.3</td>
<td>35.6</td>
</tr>
<tr>
<td>code-davinci-002:</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$M_{1}=1,M_{2}=100$</td>
<td>76.7</td>
<td>77.3</td>
<td>35.6</td>
</tr>
<tr>
<td>$M_{1}=5,M_{2}=20$</td>
<td>80.0</td>
<td>78.8</td>
<td>43.8</td>
</tr>
</tbody>
</table>
<p>Table 3: The effectiveness of diverse prompts ( $\langle 5,20\rangle$ ) compared to pure sampling decoding (Wang et al., 2022c), under majority voting.</p>
<table>
<thead>
<tr>
<th>$\left\langle M_{1}, M_{2}\right\rangle$</th>
<th>GSM8K</th>
</tr>
</thead>
<tbody>
<tr>
<td>$M_{1}=1,M_{2}=100$</td>
<td>76.7</td>
</tr>
<tr>
<td>$M_{1}=5,M_{2}=20$</td>
<td>80.0</td>
</tr>
<tr>
<td>$M_{1}=10,M_{2}=10$</td>
<td>79.8</td>
</tr>
<tr>
<td>$M_{1}=100,M_{2}=1$</td>
<td>73.0</td>
</tr>
</tbody>
</table>
<p>Table 4: GSM8K majority voting results for different $\left\langle M_{1}, M_{2}\right\rangle$ settings on code-davinci-002.
sulting in more false-positive exemplars in the pseudo exemplar base (Details will be discussed in Section B.2). Regarding inductive reasoning, DIVERSE achieves a surprisingly good performance of $95.9\%$ on the CLUTRR task, outperforming $(+28.9\%)$ previous SOTA result with fine-tuning (Sinha et al., 2019).</p>
<h2>5 Case Study</h2>
<p>Table 2 shows an example of step-level scores given by the step-aware verifier. Steps in the correct reasoning path have relatively high scores, while the scores in the wrong reasoning path show where the path starts to be wrong. This indicates that besides improving the performance, the step-aware verifier can also bring interpretability to show the step-level correctness. We also show some extra examples of majority-voting in Table 10.</p>
<h2>6 Analysis</h2>
<p>We also conduct ablation experiments and analysis to investigate the keys to the success of DIVERSE.</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 4: Diverse prompts increase the diversity of GSM8K reasoning paths and their final answers. This is beneficial for the voting verifier. Left: the average number of distinct reasoning paths per question (we consider two reasoning paths to be the same if they have the same intermediate result chain as shown in Figure 3). Right: the average number of distinct final answers per question.</p>
<h3>6.1 The Effectiveness of Diverse Prompts</h3>
<p>By diversifying both prompts and reasoning paths ( $\left\langle M_{1}=5, M_{2}=20\right\rangle$ ), we consistently improve performance over the sampling decoding approach ( $\left\langle M_{1}=1, M_{2}=100\right\rangle$ ) of Wang et al. (2022c), as shown in Table 3. Both methods use majority voting. Table 4 further reveals that neither only using diverse prompts nor only using sampling is optimal. In other words, the best performance is achieved by combining diverse prompts and sampling. Moreover, Figure 4 demonstrates that diverse prompts lead to more diverse reasoning paths. We hypothesize that this diversity contributes to the performance improvement by: (1) making correct results more distinguishable from varied errors during inference; and (2) providing more diverse negative samples for enhancing the verifier's generalizability during training.</p>
<h3>6.2 The Effectiveness of Voting Verifier</h3>
<p>We compare three algorithms to conclude the agreement from diverse reasoning paths: majority voting, verifier, and voting verifier. Table 5 shows the results. Compared to majority voting, our voting verifier can significantly and consistently boost reasoning performance across different tasks and different language models. Verifier without voting often outperforms majority voting, but extending it to voting verifier can further boost the performance.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>GSM8K</th>
<th>CQA</th>
<th>CLUTRR</th>
</tr>
</thead>
<tbody>
<tr>
<td>davinci:</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Voting</td>
<td>21.3</td>
<td>57.4</td>
<td>45.9</td>
</tr>
<tr>
<td>Verifier</td>
<td>27.0</td>
<td>74.1</td>
<td>93.2</td>
</tr>
<tr>
<td>Voting Verifier</td>
<td>30.6</td>
<td>75.0</td>
<td>92.5</td>
</tr>
<tr>
<td>text-davinci-002:</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Voting</td>
<td>61.3</td>
<td>77.3</td>
<td>35.6</td>
</tr>
<tr>
<td>Verifier</td>
<td>62.7</td>
<td>77.9</td>
<td>93.8</td>
</tr>
<tr>
<td>Voting Verifier</td>
<td>68.9</td>
<td>79.2</td>
<td>93.8</td>
</tr>
<tr>
<td>code-davinci-002:</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Voting</td>
<td>80.0</td>
<td>75.4</td>
<td>43.8</td>
</tr>
<tr>
<td>Verifier</td>
<td>65.9</td>
<td>78.8</td>
<td>95.9</td>
</tr>
<tr>
<td>Voting Verifier</td>
<td>82.3</td>
<td>78.8</td>
<td>95.9</td>
</tr>
</tbody>
</table>
<p>Table 5: The effectiveness of voting verifier. All exepri-
ments in this table use $\left\langle M_{1},M_{2}\right\rangle=\langle 5,20\rangle$.</p>
<p><img alt="img-3.jpeg" src="img-3.jpeg" />
(a) The number of correct rea-
soning paths containing re-
dundant steps.
(b) With the step-aware mech-
anism, incorrect paths contain
more correct steps.</p>
<p>Figure 5: Human evaluation on GSM8K shows the effectiveness of the step-aware mechanism for verifier.</p>
<h3>6.3 The Effectiveness of Step-aware Verifier</h3>
<p>We evaluate the impact of incorporating step-level information into the voting verifier of DiVERSE. Table 6 shows the performance of DiVERSE with and without the step-aware mechanism on both the GSM8K and the CommonsenseQA datasets. We find that using the step-aware verifier improves the performance in most of the experiments. The only exception is code-davinci-002 on GSM8K, where the step-aware verifier slightly lowers the performance. We hypothesize that code-davinci-002 is more capable of generating high-quality reasoning paths, and thus does not benefit much from the step-level information.</p>
<p>Detailed Human Evaluation of Reasoning Steps. We further analyze the quality of generated reasoning steps, by asking human annotators to judge</p>
<p><img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 6: The distribution of error types in incorrect reasoning steps.</p>
<p>whether the GSM8K reasoning steps produced by DiVERSE (with/without step-aware mechanism) are good or not. Here "good" means not only correct formulas and calculation results but also textual fluency and logical coherence.</p>
<p>We further examine the quality of the reasoning steps generated by DiVERSE (with/without step-aware mechanism) for GSM8K, by asking human annotators to rate them based on correctness, fluency, and coherence. For each test question, we compare three reasoning paths produced by code-davinci-002: the one with the highest verifier score, the one with the highest step-aware verifier score, and a randomly chosen one. The annotators (master students) label any incorrect or unsatisfactory reasoning steps in each path (single-blind) and explain why. We collect annotations for 200 test questions, half of which have correct final answers from all three paths, and half of which have incorrect final answers from all three paths.</p>
<p>We find that all the reasoning paths with correct final answers are also correct in every intermediate step, which shows that code-davinci-002 can reliably generate accurate reasoning steps, not just lucky guesses. However, we also find that many of the correct reasoning paths have unnecessary steps. Figure 5(a) shows that $40\%$ of the random paths have redundant steps, and the verifier can lower this percentage to $31\%$. We also find that the step-aware verifier can further eliminate redundant reasoning steps from $31\%$ to $20\%$.</p>
<p>Furthermore, for the incorrect reasoning paths, we find that the step-aware mechanism helps produce more correct steps before making mistakes. For each failed test question, we compare the number of correct steps in the path with the highest verifier score and the path with the highest step-aware verifier score (by human evaluation). Figure 5(b)</p>
<table>
<thead>
<tr>
<th></th>
<th>GSM8K</th>
<th>CommonsenseQA</th>
</tr>
</thead>
<tbody>
<tr>
<td>davinci:</td>
<td></td>
<td></td>
</tr>
<tr>
<td>DiverSe (without step)</td>
<td>30.6</td>
<td>75.0</td>
</tr>
<tr>
<td>DiverSe (with step)</td>
<td>30.9</td>
<td>76.0</td>
</tr>
<tr>
<td>text-davinci-002:</td>
<td></td>
<td></td>
</tr>
<tr>
<td>DiverSe (without step)</td>
<td>68.9</td>
<td>79.2</td>
</tr>
<tr>
<td>DiverSe (with step)</td>
<td>70.2</td>
<td>79.8</td>
</tr>
<tr>
<td>code-davinci-002:</td>
<td></td>
<td></td>
</tr>
<tr>
<td>DiverSe (without step)</td>
<td>82.3</td>
<td>78.8</td>
</tr>
<tr>
<td>DiverSe (with step)</td>
<td>81.5</td>
<td>79.9</td>
</tr>
</tbody>
</table>
<p>Table 6: The effectiveness of step-aware voting verifier, with $\left\langle M_{1}, M_{2}\right\rangle=\langle 5,20\rangle$.
shows that for $33 \%$ of $17 \%$ of the failed test cases, the step-aware verifier generates more/fewer correct steps than the verifier without the step-aware mechanism.</p>
<p>Step Error Types. Figure 6 shows the distribution of error types in the incorrect reasoning steps. We see that $95 \%$ of the errors are caused by incorrect formulations (i.e., using wrong intermediate results or operators and generating invalid formulas, which lead to incorrect answers). We also see that, although code-davinci-002 often makes division calculation errors (e.g., $10 / 3=3$ ), both the verifier and the step-aware verifier can effectively assign low scores to such paths, thus improving the performance.</p>
<h3>6.4 How Many Diverse Outputs Do We Need?</h3>
<p>Figure 7 shows the accuracy at different $M$ values, where $M$ is the number of reasoning paths sampled from the 100 generated paths for each question. We observe that: (1) the accuracy increases with more reasoning paths, but the improvement becomes marginal at $M \geq 50$; (2) DiverSe outperforms self-consistency significantly and consistently at different $M$ values.</p>
<h3>6.5 How Many Training Data Do We Need?</h3>
<p>DIVERSE requires a dataset with reasoning paths for training the verifier. Figure 8 shows how the size of this dataset affects the performance. We observe that: the performance is only reduced by about $2 \%$, even if the size of training data is cut by $75 \%$ (from 1,000 to 250 ). With the same reasoning paths, voting verifier performs better than majority voting, while verifier without voting causes significant performance drops.
<img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>Figure 7: GSM8K accuracy at different $M$ values (how many reasoning paths are used for each question).</p>
<h3>6.6 The Impact of the Number of Exemplars</h3>
<p>We conduct experiments for $k=3 / 5 / 8$ ( $k$ is the number of exemplars used in each prompt) on GSM8K. Figure 9 shows the results. We observe that: using 8 exemplars in each prompt can further boost the accuracy of GSM8K to $83.2 \%$.</p>
<h2>7 Related Work</h2>
<p>Reasoning Skills. Researchers in the literature have proposed many benchmarks requiring various reasoning skills, including commonsense reasoning (Zellers et al., 2018; Talmor et al., 2019; Bhagavatula et al., 2019; Geva et al., 2021) numerical reasoning (Dua et al., 2019), multi-hop reasoning (Yang et al., 2018), arithmetic reasoning (KoncelKedziorski et al., 2015; Roy and Roth, 2015; Miao et al., 2020; Patel et al., 2021; Cobbe et al., 2021), logical reasoning (Liu et al., 2020; Yu et al., 2020), inductive reasoning (Sinha et al., 2019) and tabular reasoning (Chen et al., 2020; Zhu et al., 2021).</p>
<p>Reasoning with Symbolic Systems. Much research in the literature enhances the reasoning capabilities of machine learning systems by exploiting symbolic systems, including knowledge graphs (Mihaylov and Frank, 2018; Bauer et al., 2018; Kundu et al., 2019; Wang et al., 2019; Lin et al., 2019; Ding et al., 2019; Feng et al., 2020; Wang et al., 2022b), or question taxonomies (Dua et al., 2019; Andor et al., 2019; Hu et al., 2019b; Wang et al., 2022a). Although these methods work well on specific benchmarks, they usually require domain-specific designs and human efforts, thus limiting the generalizability.</p>
<p>Reasoning via Language Models. This line of work aims to address reasoning tasks in a general sequence-to-sequence manner, empowered by reasoning-aware pre-training or fine-tuning of language models. For example, Deng et al. (2021)</p>
<p><img alt="img-6.jpeg" src="img-6.jpeg" /></p>
<p>Figure 8: DIVERSE performance (code-davinci-002) on GSM8K with different sizes of the training dataset (without labeled reasoning paths).</p>
<p>proposed to train the language model with crawled data from the internet; <em>Asai and Hajishirzi (2020)</em> proposed a logic-guided data augmentation method to pre-train the language model; <em>Shen et al. (2021)</em>; <em>Cobbe et al. (2021)</em> proposed to train a verifier to rank solutions sampled from fine-tuned language models; <em>Geva et al. (2020)</em>; <em>Yoran et al. (2022)</em>; <em>Campagna et al. (2020)</em>; <em>Wang et al. (2022a)</em> proposed to equip language models with reasoning abilities by generating training examples with human-designed templates; <em>Pi et al. (2022)</em> proposed to inject reasoning capabilities into language models by continual pre-training on program execution data.</p>
<h3>Reasoning via Prompting Gigantic Language Models</h3>
<p>Gigantic language models like GPT-3 <em>Brown et al. (2020)</em> have demonstrated impressive few-shot learning capabilities in many tasks and have attracted many research interests on making gigantic language models better few-shot learners <em>Zhao et al. (2021); Holtzman et al. (2021); Min et al. (2021); Liu et al. (2022); Lu et al. (2021); Rubin et al. (2021); Min et al. (2022)</em>. However, these methods struggle to address tasks requiring reasoning skills. To mitigate this, recently there is a line of research that focuses on unleashing the reasoning capabilities of gigantic language models via better prompting strategies. <em>Wei et al. (2022)</em> proposed chain-of-thought reasoning, of which the key insight is the insertion of multi-step reasoning paths before generating the final answers; <em>Wang et al. (2022c)</em> proposed to improve chain-of-thought reasoning via self-consistency, of which the key insight is to conclude the most consistent answer from different reasoning paths sampled from the language model; <em>Zhou et al. (2022)</em>; <em>Creswell et al. (2022)</em></p>
<p><img alt="img-7.jpeg" src="img-7.jpeg" /></p>
<p>Figure 9: DIVERSE performance (code-davinci-002) on GSM8K when each prompt contains 3/5/8 exemplars.</p>
<p>proposed to leverage gigantic language models to decompose questions into sub-questions, thereby addressing them in an iterative manner; <em>Kojima et al. (2022)</em> proposed that gigantic language models can even be good zero-shot reasoners, by designing prompts that can induce language models to do reasoning step-by-step; <em>Lampinen et al. (2022)</em> proposed building a prompt by selecting examples and explanations together, thus substantially improving performance over selecting examples alone. Despite their great successes, these works come with their limitations. This paper is a continuation of this line of research, focusing on diverse verifier on reasoning steps.</p>
<h2>8 Conclusion and Future Work</h2>
<p>In this paper, we present DIVERSE, a novel and general method to enhance the reasoning abilities of large language models. Our method builds on the idea of prompting language models with multistep reasoning paths, but introduces three key innovations: diverse prompts, voting verifier, and stepwise verifier. The latter is especially novel and effective, as it verifies each reasoning step separately and we provides a detailed analysis of the model's behavior in each step. We demonstrate the superiority of DIVERSE through extensive experiments. For instance, using code-davinci-002, our method achieves state-of-the-art performance on most reasoning tasks, surpassing the 540B PaLM model with previous prompting techniques.</p>
<p>There are many directions for our future work. (1) As discussed in Appendix B.2, we will continue to investigate how to reduce or recognize false positive pseudo exemplars. (2) We plan to investigate mechanisms to produce better diverse prompts than</p>
<p>simple sampling. (3) We will extend DiVERSE to other tasks and continue to design better prompting techniques to elicit the power of gigantic language models.</p>
<h2>9 Limitations</h2>
<p>Computing Resources. Despite the surprising performance it achieves, our framework needs to be applied to large language models like GPT3 or PaLM. Inference with these models costs more time and budgets than fine-tuning models like RoBERTa (Liu et al., 2019).</p>
<p>Faithfulness. Although DiVERSE can significantly improve the accuracy of final answers, we still cannot guarantee that the reasoning paths produced by the language models are 100 percent faithful. This is the key challenge and future direction for this line of research (chain-of-thought reasoning).</p>
<p>More Training Data. DiVERSE needs more labeled data with well-annotated reasoning paths to construct diverse prompts, and it also needs a training dataset for supervising the verifier. However, from another point of view, this limitation can also be regarded as a contribution that studies how chain-of-thought reasoning can be further improved if we have more training data than just a few exemplars.</p>
<p>Human Evaluation of Reasoning Steps. We use human evaluation to measure the quality of the intermediate steps in reasoning paths since few current works provide reliable frameworks to evaluate the quality of reasoning steps.</p>
<h2>References</h2>
<p>Daniel Andor, Luheng He, Kenton Lee, and Emily Pitler. 2019. Giving BERT a calculator: Finding operations and arguments with reading comprehension. In Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing and the 9th International Joint Conference on Natural Language Processing (EMNLPIJCNLP), pages 5947-5952, Hong Kong, China. Association for Computational Linguistics.</p>
<p>Akari Asai and Hannaneh Hajishirzi. 2020. Logicguided data augmentation and regularization for consistent question answering. In Proceedings of the 58th Annual Meeting of the Association for Computational Linguistics, pages 5642-5650,</p>
<p>Online. Association for Computational Linguistics.</p>
<p>Lisa Bauer, Yicheng Wang, and Mohit Bansal. 2018. Commonsense for generative multi-hop question answering tasks. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 4220-4230, Brussels, Belgium. Association for Computational Linguistics.</p>
<p>Chandra Bhagavatula, Ronan Le Bras, Chaitanya Malaviya, Keisuke Sakaguchi, Ari Holtzman, Hannah Rashkin, Doug Downey, Scott Wen-tau Yih, and Yejin Choi. 2019. Abductive commonsense reasoning.</p>
<p>Tom Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared D Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, et al. 2020. Language models are few-shot learners. Advances in neural information processing systems, 33:1877-1901.</p>
<p>Giovanni Campagna, Agata Foryciarz, Mehrad Moradshahi, and Monica Lam. 2020. Zero-shot transfer learning with synthesized data for multidomain dialogue state tracking. In Proceedings of the 58th Annual Meeting of the Association for Computational Linguistics, pages 122-132, Online. Association for Computational Linguistics.</p>
<p>Wenhu Chen, Hanwen Zha, Zhiyu Chen, Wenhan Xiong, Hong Wang, and William Yang Wang. 2020. HybridQA: A dataset of multi-hop question answering over tabular and textual data. In Findings of the Association for Computational Linguistics: EMNLP 2020, pages 1026-1036, Online. Association for Computational Linguistics.</p>
<p>Aakanksha Chowdhery, Sharan Narang, Jacob Devlin, Maarten Bosma, Gaurav Mishra, Adam Roberts, Paul Barham, Hyung Won Chung, Charles Sutton, Sebastian Gehrmann, et al. 2022. Palm: Scaling language modeling with pathways. arXiv preprint arXiv:2204.02311.</p>
<p>Karl Cobbe, Vineet Kosaraju, Mohammad Bavarian, Jacob Hilton, Reiichiro Nakano, Christopher Hesse, and John Schulman. 2021. Training verifiers to solve math word problems. arXiv preprint arXiv:2110.14168.</p>
<p>Antonia Creswell, Murray Shanahan, and Irina Higgins. 2022. Selection-inference: Exploiting large language models for interpretable logical reasoning.</p>
<p>Xiang Deng, Yu Su, Alyssa Lees, You Wu, Cong Yu, and Huan Sun. 2021. ReasonBERT: Pretrained to reason with distant supervision. In Proceedings of the 2021 Conference on Empirical Methods in Natural Language Processing, pages 6112-6127, Online and Punta Cana, Dominican Republic. Association for Computational Linguistics.</p>
<p>Ming Ding, Chang Zhou, Qibin Chen, Hongxia Yang, and Jie Tang. 2019. Cognitive graph for multi-hop reading comprehension at scale. In Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics, pages 2694-2703, Florence, Italy. Association for Computational Linguistics.</p>
<p>Dheeru Dua, Yizhong Wang, Pradeep Dasigi, Gabriel Stanovsky, Sameer Singh, and Matt Gardner. 2019. DROP: A reading comprehension benchmark requiring discrete reasoning over paragraphs. In Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long and Short Papers), pages 2368-2378, Minneapolis, Minnesota. Association for Computational Linguistics.</p>
<p>Yanlin Feng, Xinyue Chen, Bill Yuchen Lin, Peifeng Wang, Jun Yan, and Xiang Ren. 2020. Scalable multi-hop relational reasoning for knowledge-aware question answering.</p>
<p>Mor Geva, Ankit Gupta, and Jonathan Berant. 2020. Injecting numerical reasoning skills into language models. In Proceedings of the 58th Annual Meeting of the Association for Computational Linguistics, pages 946-958, Online. Association for Computational Linguistics.</p>
<p>Mor Geva, Daniel Khashabi, Elad Segal, Tushar Khot, Dan Roth, and Jonathan Berant. 2021. Did aristotle use a laptop? a question answering benchmark with implicit reasoning strategies. Transactions of the Association for Computational Linguistics, 9:346-361.</p>
<p>Junxian He, Chunting Zhou, Xuezhe Ma, Taylor Berg-Kirkpatrick, and Graham Neubig. 2022.</p>
<p>Towards a unified view of parameter-efficient transfer learning. In International Conference on Learning Representations.</p>
<p>Pengcheng He, Xiaodong Liu, Jianfeng Gao, and Weizhu Chen. 2021. Deberta: Decodingenhanced bert with disentangled attention. In International Conference on Learning Representations.</p>
<p>Ari Holtzman, Peter West, Vered Shwartz, Yejin Choi, and Luke Zettlemoyer. 2021. Surface form competition: Why the highest probability answer isn't always right.</p>
<p>Neil Houlsby, Andrei Giurgiu, Stanislaw Jastrzebski, Bruna Morrone, Quentin De Laroussilhe, Andrea Gesmundo, Mona Attariyan, and Sylvain Gelly. 2019. Parameter-efficient transfer learning for nlp. In International Conference on Machine Learning, pages 2790-2799. PMLR.</p>
<p>Edward J Hu, Yelong Shen, Phillip Wallis, Zeyuan Allen-Zhu, Yuanzhi Li, Shean Wang, Lu Wang, and Weizhu Chen. 2021. Lora: Low-rank adaptation of large language models. arXiv preprint arXiv:2106.09685.</p>
<p>Minghao Hu, Yuxing Peng, Zhen Huang, and Dongsheng Li. 2019a. A multi-type multi-span network for reading comprehension that requires discrete reasoning. In Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing and the 9th International Joint Conference on Natural Language Processing (EMNLP-IJCNLP), pages 1596-1606.</p>
<p>Minghao Hu, Yuxing Peng, Zhen Huang, and Dongsheng Li. 2019b. A multi-type multi-span network for reading comprehension that requires discrete reasoning. In Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing and the 9th International Joint Conference on Natural Language Processing (EMNLP-IJCNLP), pages 1596-1606, Hong Kong, China. Association for Computational Linguistics.</p>
<p>Woojeong Jin, Yu Cheng, Yelong Shen, Weizhu Chen, and Xiang Ren. 2022. A good prompt is worth millions of parameters: Low-resource prompt-based learning for vision-language models. In Proceedings of the 60th Annual Meeting</p>
<p>of the Association for Computational Linguistics (Volume 1: Long Papers), pages 2763-2775, Dublin, Ireland. Association for Computational Linguistics.</p>
<p>Takeshi Kojima, Shixiang Shane Gu, Machel Reid, Yutaka Matsuo, and Yusuke Iwasawa. 2022. Large language models are zero-shot reasoners.</p>
<p>Rik Koncel-Kedziorski, Hannaneh Hajishirzi, Ashish Sabharwal, Oren Etzioni, and Siena Dumas Ang. 2015. Parsing algebraic word problems into equations. Transactions of the Association for Computational Linguistics, 3:585-597.</p>
<p>Souvik Kundu, Tushar Khot, Ashish Sabharwal, and Peter Clark. 2019. Exploiting explicit paths for multi-hop reading comprehension. In Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics, pages 2737-2747, Florence, Italy. Association for Computational Linguistics.</p>
<p>Andrew K Lampinen, Ishita Dasgupta, Stephanie CY Chan, Kory Matthewson, Michael Henry Tessler, Antonia Creswell, James L McClelland, Jane X Wang, and Felix Hill. 2022. Can language models learn from explanations in context? arXiv preprint arXiv:2204.02329.</p>
<p>Teven Le Scao and Alexander M Rush. 2021. How many data points is a prompt worth? In Proceedings of the 2021 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, pages 2627-2636.</p>
<p>Bill Yuchen Lin, Xinyue Chen, Jamin Chen, and Xiang Ren. 2019. KagNet: Knowledge-aware graph networks for commonsense reasoning. In Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing and the 9th International Joint Conference on Natural Language Processing (EMNLPIJCNLP), pages 2829-2839, Hong Kong, China. Association for Computational Linguistics.</p>
<p>Jiachang Liu, Dinghan Shen, Yizhe Zhang, Bill Dolan, Lawrence Carin, and Weizhu Chen. 2022. What makes good in-context examples for GPT3? In Proceedings of Deep Learning Inside Out (DeeLIO 2022): The 3rd Workshop on Knowledge Extraction and Integration for Deep Learn-
ing Architectures, pages 100-114, Dublin, Ireland and Online. Association for Computational Linguistics.</p>
<p>Jian Liu, Leyang Cui, Hanmeng Liu, Dandan Huang, Yile Wang, and Yue Zhang. 2020. Logiqa: A challenge dataset for machine reading comprehension with logical reasoning.</p>
<p>Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Danqi Chen, Omer Levy, Mike Lewis, Luke Zettlemoyer, and Veselin Stoyanov. 2019. Roberta: A robustly optimized bert pretraining approach. arXiv preprint arXiv:1907.11692.</p>
<p>Yao Lu, Max Bartolo, Alastair Moore, Sebastian Riedel, and Pontus Stenetorp. 2021. Fantastically ordered prompts and where to find them: Overcoming few-shot prompt order sensitivity.</p>
<p>Shen-Yun Miao, Chao-Chun Liang, and Keh-Yih Su. 2020. A diverse corpus for evaluating and developing english math word problem solvers. In Proceedings of the 58th Annual Meeting of the Association for Computational Linguistics, pages 975-984.</p>
<p>Todor Mihaylov and Anette Frank. 2018. Knowledgeable reader: Enhancing cloze-style reading comprehension with external commonsense knowledge. In Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 821832, Melbourne, Australia. Association for Computational Linguistics.</p>
<p>Sewon Min, Mike Lewis, Luke Zettlemoyer, and Hannaneh Hajishirzi. 2021. Metaicl: Learning to learn in context.</p>
<p>Sewon Min, Xinxi Lyu, Ari Holtzman, Mikel Artetxe, Mike Lewis, Hannaneh Hajishirzi, and Luke Zettlemoyer. 2022. Rethinking the role of demonstrations: What makes in-context learning work?</p>
<p>Arkil Patel, Satwik Bhattamishra, and Navin Goyal. 2021. Are nlp models really able to solve simple math word problems? In Proceedings of the 2021 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, pages 2080-2094.</p>
<p>Xinyu Pi, Qian Liu, Bei Chen, Morteza Ziyadi, Zeqi Lin, Yan Gao, Qiang Fu, Jian-Guang Lou, and Weizhu Chen. 2022. Reasoning like program executors. arXiv preprint arXiv:2201.11473.</p>
<p>Alec Radford, Jeffrey Wu, Rewon Child, David Luan, Dario Amodei, Ilya Sutskever, et al. 2019. Language models are unsupervised multitask learners. OpenAI blog, 1(8):9.</p>
<p>Subhro Roy and Dan Roth. 2015. Solving general arithmetic word problems. In Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing, pages 1743-1752.</p>
<p>Ohad Rubin, Jonathan Herzig, and Jonathan Berant. 2021. Learning to retrieve prompts for in-context learning.</p>
<p>Jianhao Shen, Yichun Yin, Lin Li, Lifeng Shang, Xin Jiang, Ming Zhang, and Qun Liu. 2021. Generate \&amp; rank: A multi-task framework for math word problems. In Findings of the Association for Computational Linguistics: EMNLP 2021, pages 2269-2279.</p>
<p>Koustuv Sinha, Shagun Sodhani, Jin Dong, Joelle Pineau, and William L Hamilton. 2019. Clutrr: A diagnostic benchmark for inductive reasoning from text. In Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing and the 9th International Joint Conference on Natural Language Processing (EMNLP-IJCNLP), pages 4506-4515.</p>
<p>Alon Talmor, Jonathan Herzig, Nicholas Lourie, and Jonathan Berant. 2019. Commonsenseqa: A question answering challenge targeting commonsense knowledge. In Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long and Short Papers), pages 4149-4158.</p>
<p>Siyuan Wang, Wanjun Zhong, Duyu Tang, Zhongyu Wei, Zhihao Fan, Daxin Jiang, Ming Zhou, and Nan Duan. 2022a. Logic-driven context extension and data augmentation for logical reasoning of text. In Findings of the Association for Computational Linguistics: ACL 2022, pages 1619-1629, Dublin, Ireland. Association for Computational Linguistics.</p>
<p>Xiaoyan Wang, edu Kapanipathi, Ryan Musa, Mo Yu, Kartik Talamadupula, Ibrahim Abdelaziz, Maria Chang, Achille Fokoue, Bassem Makni, Nicholas Mattei, and Michael Witbrock. 2019. Improving natural language inference using external knowledge in the science questions domain. In Proceedings of the Thirty-Third AAAI Conference on Artificial Intelligence and Thirty-First Innovative Applications of Artificial Intelligence Conference and Ninth AAAI Symposium on Educational Advances in Artificial Intelligence, AAAI'19/IAAI'19/EAAI'19. AAAI Press.</p>
<p>Xiting Wang, Kunpeng Liu, Dongjie Wang, Le Wu, Yanjie Fu, and Xing Xie. 2022b. Multi-level recommendation reasoning over knowledge graphs with reinforcement learning. In The Web Conference 2022.</p>
<p>Xuezhi Wang, Jason Wei, Dale Schuurmans, Quoc Le, Ed Chi, Sharan Narang, Aakanksha Chowdhery, and Denny Zhou. 2022c. Self-consistency improves chain of thought reasoning in language models.</p>
<p>Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Ed Chi, Quoc Le, and Denny Zhou. 2022. Chain of thought prompting elicits reasoning in large language models. arXiv preprint arXiv:2201.11903.</p>
<p>Yichong Xu, Chenguang Zhu, Shuohang Wang, Siqi Sun, Hao Cheng, Xiaodong Liu, Jianfeng Gao, Pengcheng He, Michael Zeng, and Xuedong Huang. 2021. Human parity on commonsenseqa: Augmenting self-attention with external attention. arXiv preprint arXiv:2112.03254.</p>
<p>Zhilin Yang, Peng Qi, Saizheng Zhang, Yoshua Bengio, William Cohen, Ruslan Salakhutdinov, and Christopher D. Manning. 2018. HotpotQA: A dataset for diverse, explainable multi-hop question answering. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 2369-2380, Brussels, Belgium. Association for Computational Linguistics.</p>
<p>Ori Yoran, Alon Talmor, and Jonathan Berant. 2022. Turning tables: Generating examples from semistructured tables for endowing language models with reasoning skills. In Proceedings of the 60th</p>
<p>Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 6016-6031, Dublin, Ireland. Association for Computational Linguistics.</p>
<p>Weihao Yu, Zihang Jiang, Yanfei Dong, and Jiashi Feng. 2020. Reclor: A reading comprehension dataset requiring logical reasoning.</p>
<p>Eric Zelikman, Yuhuai Wu, and Noah D Goodman. 2022. Star: Bootstrapping reasoning with reasoning. arXiv preprint arXiv:2203.14465.</p>
<p>Rowan Zellers, Yonatan Bisk, Roy Schwartz, and Yejin Choi. 2018. SWAG: A large-scale adversarial dataset for grounded commonsense inference. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 93-104, Brussels, Belgium. Association for Computational Linguistics.</p>
<p>Tony Z. Zhao, Eric Wallace, Shi Feng, Dan Klein, and Sameer Singh. 2021. Calibrate before use: Improving few-shot performance of language models.</p>
<p>Denny Zhou, Nathanael Schärli, Le Hou, Jason Wei, Nathan Scales, Xuezhi Wang, Dale Schuurmans, Olivier Bousquet, Quoc Le, and Ed Chi. 2022. Least-to-most prompting enables complex reasoning in large language models.</p>
<p>Fengbin Zhu, Wenqiang Lei, Youcheng Huang, Chao Wang, Shuo Zhang, Jiancheng Lv, Fuli Feng, and Tat-Seng Chua. 2021. Tat-qa: A question answering benchmark on a hybrid of tabular and textual content in finance.</p>
<p>[STRATEGYQA] Yes or no: Could a llama birth twice during War in Vietnam (1945-46)? $\triangleright$ The War in Vietnam was 6 months. The gestation period for a llama is 11 months. So a llama could not give birth twice during the War in Vietnam. The answer is no.
[CLUTRR] Roy was eating lunch with his son John and his wife Mary. What kind of relative is John to Mary? $\triangleright$ John is the son of Roy. Roy is the husband of Mary. Thus, John is the son of Mary. The answer is son.</p>
<p>Table 7: Besides arithmetic reasoning, we also investigate commonsense and inductive reasoning.</p>
<p>This is the Appendix for the paper: "On the Advance of Making Language Models Better Reasoners".</p>
<h2>A Preliminaries</h2>
<p>Prompting. Prompting means prepending a few exemplars to the task input $\mathbf{x}$ and generating the output $\mathbf{y}$ from the pretrained language model:</p>
<p>$$
p(\mathbf{y} \mid C, \mathbf{x})=\prod_{t=1}^{|\mathbf{y}|} p_{\mathrm{LM}}\left(y_{t} \mid C, \mathbf{x}, y_{&lt;t}\right)
$$</p>
<p>where $C$ is the concatenation of $K$ exemplars:</p>
<p>$$
C=\left(\overline{\mathbf{x}}<em 1="1">{1}, \overline{\mathbf{y}}</em>}\right) ;\left(\overline{\mathbf{x}<em 2="2">{2}, \overline{\mathbf{y}}</em>}\right) ; \ldots ;\left(\overline{\mathbf{x}<em K="K">{K}, \overline{\mathbf{y}}</em>\right)
$$</p>
<p>We denote prompt as the concatenation of the exemplars $C$ and the input $\mathbf{x}$.</p>
<p>Reasoning Paths. For reasoning tasks that aim to generate an answer $\mathbf{y}$ for a question $\mathbf{x}$, Wei et al. (2022) proposed the insertion of a reasoning path $\mathbf{z}$ before generating the answer $\mathbf{y}$ :</p>
<p>$$
C^{\prime}=\left(\overline{\mathbf{x}}<em 1="1">{1}, \overline{\mathbf{z}}</em>}, \overline{\mathbf{y}<em K="K">{1}\right) ; \ldots ;\left(\overline{\mathbf{x}}</em>}, \overline{\mathbf{z}<em K="K">{K}, \overline{\mathbf{y}}</em>\right)
$$</p>
<p>where $\mathbf{z}<em i="i">{i}$ is a text reasoning path of how the answer $\mathbf{y}</em>$.}$ is reasoned step-by-step for question $\mathbf{x}_{i</p>
<p>Then, during inference, a reasoning path $\mathbf{z}$ will be generated before the answer $\mathbf{y}$ :</p>
<p>$$
p\left(\mathbf{y} \mid C^{\prime}, \mathbf{x}\right)=p\left(\mathbf{z} \mid C^{\prime}, \mathbf{x}\right) \cdot p\left(\mathbf{y} \mid C^{\prime}, \mathbf{x}, \mathbf{z}\right)
$$</p>
<p>Figure 10 demonstrates this idea in arithmetic reasoning (GSM8K), and Table 7 demonstrates this idea in commonsense reasoning (StrategyQA) and inductive reasoning (CLUTRR).</p>
<h2>Prompt \&amp; Samples</h2>
<p>Q: If there are 3 cars in the parking lot and 2 more cars arrive, how many cars are in the parking lot?
A: There are 3 cars in the parking lot already. 2 more arrive. Now there are $3+2=5$ cars. The answer is 5 .</p>
<p>Q: Janet's ducks lay 16 eggs per day. She eats three for breakfast every morning and bakes muffins for her friends every day with four. She sells the remainder for $\$ 2$ per egg. How much does she make every day? A:
[Sample 1] She has $16-3-4=9$ eggs left. So she makes $2 * 9=18$ per day. The answer is 18. $(\checkmark)$
[Sample 2] This means she uses $3+4=7$ eggs every day. So in total she sells $7 * 2=14$ per day. The answer is 14. $(\boldsymbol{x})$
[Sample 3] She eats 3 for breakfast, so she has $16-3$ $=13$ left. Then she bakes muffins, so $13-4=9$ eggs left. She makes $9 * \$ 2=\$ 18$. The answer is 18. $(\checkmark)$</p>
<p>Figure 10: Prompting large language models to generate different reasoning paths, then selecting the final answer via majority voting (Wang et al., 2022c).</p>
<h2>B Boosting Reasoning Paths via Self-Teaching</h2>
<p>In this section, we first introduce self-teaching, the method we use to construct a larger exemplar base when the original dataset does not contain enough data with well-annotated reasoning paths (Appendix B.1). We then discuss the noise issue when facing multiple-choice tasks (Appendix B.2).</p>
<h2>B. 1 Self Teaching</h2>
<p>A critical issue of DiVERSE is how to provide diverse prompts. ${ }^{6}$ Supposing that there is an exemplar base $E$, we can sample $K$ exemplars from it to construct a prompt, and repeat this $M_{1}$ times independently to construct $M_{1}$ prompts with diverse exemplars.</p>
<p>For scenarios that do not have sufficient exemplars (i.e., $|E|&lt;K * M_{1}$ ), we propose to bootstrap the diversity of prompts by "self-teaching", i.e., generating pseudo reasoning paths from a few exemplars and some 〈question, answer〉 pairs without reasoning paths. ${ }^{7}$ Suppose that $D$ is a dataset without reasoning paths, consisting of</p>
<p><sup id="fnref5:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<table>
<thead>
<tr>
<th>Dataset</th>
<th>$N$</th>
<th>Example Question</th>
</tr>
</thead>
<tbody>
<tr>
<td>GSM8K</td>
<td>1319</td>
<td>James decides to run 3 sprints 3 times a week. He runs 60 meters each <br> sprint. How many total meters does he run a week?</td>
</tr>
<tr>
<td>AsDiv</td>
<td>2096</td>
<td>Seven red apples and two green apples are in the basket. How many <br> apples are in the basket?</td>
</tr>
<tr>
<td>MultiArith</td>
<td>600</td>
<td>The school cafeteria ordered 42 red apples and 7 green apples for students <br> lunches. But, if only 9 students wanted fruit, how many extra did the <br> cafeteria end up with?</td>
</tr>
<tr>
<td>SVAMP</td>
<td>1000</td>
<td>Paco had 26 salty cookies and 17 sweet cookies. He ate 14 sweet cookies <br> and 9 salty cookies. How many salty cookies did Paco have left?</td>
</tr>
<tr>
<td>SingleEq</td>
<td>508</td>
<td>Terez has 44 cows on his farm. 50 percent of the cows are female, and 50 <br> percent of the females are pregnant. How many pregnant female cows <br> does Terez have?</td>
</tr>
<tr>
<td>CommonsenseQA</td>
<td>3387</td>
<td>Sammy wanted to go to where the people were. Where might he go? <br> Options: (a) race track (b) populated areas (c) desert (d) apartment (e) <br> roadblock</td>
</tr>
<tr>
<td>StrategyQA</td>
<td>2280</td>
<td>Could you go to New York Public Library and the Six Flags Great Escape <br> in the same day?</td>
</tr>
<tr>
<td>CLUTRR</td>
<td>447</td>
<td>Kelly and her mother Ernest made breakfast together. Constance and her <br> husband Ernest wanted a child badly What kind of relative is Kelly to <br> Constance? The possible relationships are: sister, son, aunt, <br> granddaughter, father, grandfather, grandmother, mother-in-law, uncle, <br> niece, mother, brother, daughter, nephew, grandson, son-in-law, <br> father-in-law, daughter-in-law.</td>
</tr>
</tbody>
</table>
<p>Table 8: Reasoning benchmarks we use in this paper with examples. $N$ means the number of test cases.
$\left(\mathbf{x}, \mathbf{y}^{<em>}\right)$ pairs. Given the small exemplar base $E$, for each $\left(\mathbf{x}, \mathbf{y}^{</em>}\right) \in D$, we can use prompting to generate a reasoning path $\mathbf{z}$ and the predicted answer $\mathbf{y}$. We define the pseudo exemplar base $E^{\prime}$ as:</p>
<p>$$
E^{\prime}=\left{(\mathbf{x}, \mathbf{z}, \mathbf{y}) \mid\left(\mathbf{x}, \mathbf{y}^{<em>}\right) \in D, \mathbf{y}=\mathbf{y}^{</em>}\right}
$$</p>
<p>then $E \cup E^{\prime}$ can be regarded as the new exemplar base for generating diverse prompts.</p>
<h2>B. 2 Noises in Multiple Choice Tasks</h2>
<p>In our experimental setup, StrategyQA and CommonsenseQA are more challenging than other tasks, as they use pseudo exemplars generated through "self-teaching" (Appendix B.1).
"Self-teaching" may lead to bad exemplars, whose reasoning paths are invalid but happen to yield answers coinciding with the ground truth. Questions in StrategyQA/CommonsenseQA are two-choice/four-choice questions, respectively. Therefore, such noise would be more serious in StrategyQA than in CommonsenseQA. This somehow explains why DiVERSE can achieve comparable performance $(-0.8 \%)$ as the PaLM-based SOTA on CommonsenseQA, while it sees a $3.0 \%$ performance decline to PaLM on StrategyQA, which has only two choices. In other words, it is easier for StrategyQA to yield a right answer but a misleading reasoning path.</p>
<h2>C Data Statistics</h2>
<p>Table 8 shows the reasoning benchmarks we use in this paper with examples. We use the same test sets as Wei et al. (2022) for GSM8K, AsDiv, MultiArith, SVAMP, SingleEq, and CommonsenseQA.</p>
<p>For StrategyQA, there are 2, 290 test cases (i.e., questions paired with TRUE/FALSE labels), but there is no other case that can be leveraged by DiVERSE to construct diverse exemplars (as introduced in Section 2.1). To address this problem, we randomly divide these 2,290 test cases into two equal parts (denoted as $T_{1}$ and $T_{2}$ ). For each Di-</p>
<p>VERSE experiment of SQA, we conduct two runs: using $T_{1}$ to construct diverse exemplars and $T_{2}$ as the test set, and vice versa. The final reported solve rate is the average solve rate of these two runs.</p>
<p>For CLUTRR, Sinha et al. (2019) provided several versions: clean, supporting, irrelevant, and disconnected. The clean version is the basic dataset, while the others are the perturbed variations of it. Our experiments are conducted on the clean version.</p>
<h2>D Our Changes to CLUTRR</h2>
<p>In our experiments, two changes are applied to the CLUTRR benchmark: (1) appending candidate answers to each question; (2) constructing reasoning paths based on rules. Table 9 shows an example of CLUTRR data after our modification.</p>
<p>Candidate Answers. Besides the original questions (e.g., "Mary, a female, took her husband who is a male, Roy, out for lunch. Ernest bought to dress for his father Roy. What kind of relative is Ernest to Mary?"), we also provide all the candidate answers (i.e., "The possible relationships are: sister, son, aunt, granddaughter, father, grandfather, grandmother, mother-in-law, uncle, niece, mother, brother, daughter, nephew, grandson, son-in-law, father-in-law, daughter-in-law") in the input sequence. Our preliminary experiments show that, the gigantic language models cannot reach more than $50 \%$ accuracy without the sequence of candidate answers.</p>
<p>Reasoning Paths. For each question, Sinha et al. (2019) also provided a knowledge graph that formulates the relations directly mentioned in the question. Each knowledge graph consists of several $\left\langle e_{1}, r, e_{2}\right\rangle$ triplets, which means there is a relation $r$ from $e_{1}$ to $e_{2}$. Take the aforementioned question as an example, the knowledge graph consists of two triplets: $\langle$ Mary, husband, Roy $\rangle$ and $\langle$ Ernest, father, Roy $\rangle$.</p>
<p>For each question, we construct the reasoning path based on its knowledge graph. We first topologically sort all triplets in the knowledge graph. For each triplet, we convert it to a reasoning step using the template " $\left{e_{2}\right}$ is the ${r}$ of $\left{e_{1}\right}$ ". After that, we can get the reasoning path by concatenating these reasoning steps. Take the aforementioned question as an example, the reasoning path is: "Roy is the husband of Mary. Roy is the father of Ernest. Thus, Ernest is the son of Mary."</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Variant</th>
<th style="text-align: center;">Input Example</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">CLUTRR <br> for NLI <br> (Original)</td>
<td style="text-align: center;">Input: Story: Kelly and her mother Ernest made <br> breakfast together. Constance and her husband <br> Ernest wanted a child badly. Query: Kelly, Con- <br> stance <br> Output: daughter</td>
</tr>
<tr>
<td style="text-align: center;">CLUTRR <br> for NLG <br> (Ours)</td>
<td style="text-align: center;">Input: Kelly and her mother Ernest made break- <br> fast together. Constance and her husband Ernest <br> wanted a child badly. What kind of relative is Kelly <br> to Constance? The possible relationships are: sis- <br> ter, son, aunt, granddaughter, father, grandfather, <br> grandmother, mother-in-law, uncle, niece, mother, <br> brother, daughter, nephew, grandson, son-in-law, <br> father-in-law, daughter-in-law. <br> Output: Kelly is the daughter of Ernest. Ernest is <br> the husband of Constance. Thus, Kelly is the <br> daughter of Constance. So the answer is daughter.</td>
</tr>
</tbody>
</table>
<p>Table 9: Examples of the original and our constructed CLUTRR data. In our experiments, we concatenated the class information (marked with red) after the input question as the input, and constructed reasoning paths (marked with blue) via a simple text template as the output.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Question</th>
<th style="text-align: center;">Self-Consistency</th>
<th style="text-align: center;">DiVERSE</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">[GSM8K] Siobhan has 2 fewer jewels than Aaron. Aaron has 5 more jewels than half of Raymond's jewels. If Raymond has 40 jewels, how many jewels does Siobhan have?</td>
<td style="text-align: center;">Aaron has 2 more jewels than half of Raymond's jewels. So Aaron has $40 / 2+2=22$ jewels. Siobhan has 2 fewer jewels than Aaron so she has $22-2$ $=20$ jewels. So the answer is 20 . <br> Answer: 20 (Wrong) Count: 33</td>
<td style="text-align: center;">Raymond has 40 jewels. Half of Raymond's jewels is $40 / 2=20$. Aaron has 5 more jewels than half of Raymond's jewels, so he has $20+5=25$ jewels. Siobhan has 2 fewer jewels than Aaron, so she has $25-2=23$ jewels. So the answer is 23 . <br> Answer: 23 (Correct) Count: 32</td>
</tr>
<tr>
<td style="text-align: center;">[StrategyQA] Could you go to New York Public Library and the Six Flags Great Escape in the same day?</td>
<td style="text-align: center;">The New York Public Library is in Manhattan. The Six Flags Great Escape is in Queensbury. Manhattan and Queensbury are too far apart to go to both in a single day. Thus, you could not go to New York Public Library and the Six Flags Great Escape in the same day. So the answer is no. <br> Answer: no (Wrong) Count: 62</td>
<td style="text-align: center;">The New York Public Library is in New York City. The Six Flags Great Escape is in Queensbury, New York. Queensbury is about 3.5 hours away from New York City by car. Thus, you could go to the New York Public Library and the Six Flags Great Escape in the same day. So the answer is yes. <br> Answer: yes (Correct) Count: 38</td>
</tr>
</tbody>
</table>
<p>Table 10: Examples of code-davinci-002 on GSM8K. Compared to self-consistency (majority voting), DiVERSE can select the correct-but-not-most answer out of the sampled candidates, thus improving the reasoning performance.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{6}$ Wang et al. (2022c) tried an ensemble-based approach, i.e., to permutate exemplars in the original prompt. However, this strategy does not increase diversity in terms of exemplars.
${ }^{7}$ This is motivated by Zelikman et al. (2022).&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref5:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:1">
<p>${ }^{2}$ Our main experiments use $M_{1}=5$ and $M_{2}=20$.&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>