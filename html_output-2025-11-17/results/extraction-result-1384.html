<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-1384 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-1384</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-1384</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-27.html">extraction-schema-27</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of world models used in AI systems, including details about their fidelity, interpretability, computational efficiency, and task-specific utility.</div>
                <p><strong>Paper ID:</strong> paper-f0b9dc64f6df004d3f776031050317f0a7fb1bdc</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/f0b9dc64f6df004d3f776031050317f0a7fb1bdc" target="_blank">On Learning to Think: Algorithmic Information Theory for Novel Combinations of Reinforcement Learning Controllers and Recurrent Neural World Models</a></p>
                <p><strong>Paper Venue:</strong> arXiv.org</p>
                <p><strong>Paper TL;DR:</strong> This paper addresses the general problem of reinforcement learning (RL) in partially observable environments, and describes RNN-based AIs (RNNAIs) designed to do the same, guided by algorithmic information theory.</p>
                <p><strong>Paper Abstract:</strong> This paper addresses the general problem of reinforcement learning (RL) in partially observable environments. In 2013, our large RL recurrent neural networks (RNNs) learned from scratch to drive simulated cars from high-dimensional video input. However, real brains are more powerful in many ways. In particular, they learn a predictive model of their initially unknown environment, and somehow use it for abstract (e.g., hierarchical) planning and reasoning. Guided by algorithmic information theory, we describe RNN-based AIs (RNNAIs) designed to do the same. Such an RNNAI can be trained on never-ending sequences of tasks, some of them provided by the user, others invented by the RNNAI itself in a curious, playful fashion, to improve its RNN-based world model. Unlike our previous model-building RNN-based RL machines dating back to 1990, the RNNAI learns to actively query its model for abstract reasoning and planning and decision making, essentially "learning to think." The basic ideas of this report can be applied to many other cases where one RNN-like system exploits the algorithmic information content of another. They are taken from a grant proposal submitted in Fall 2014, and also explain concepts such as "mirror neurons." Experimental results will be described in separate papers.</p>
                <p><strong>Cost:</strong> 0.017</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e1384.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e1384.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of world models used in AI systems, including details about their fidelity, interpretability, computational efficiency, and task-specific utility.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>M</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Gradient-based RNN World Model (M)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An RNN (typically LSTM-based, optionally with CNN/FNN preprocessing) trained by gradient-based unsupervised learning to predict next sensory inputs and compress the agent's entire interaction history; frozen while the controller C learns to query and exploit its internal program.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>M (Gradient-Based RNN World Model)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Recurrent neural network (recommended LSTM) that receives sensory inputs and actions and produces pred(t+1), a prediction of next sensory input; trained to compress the lifelong history by minimizing a combination of prediction error and model complexity (bits_M + bits_H). Optionally preceded by a CNN/FNN autoencoder that compresses individual frames; the RNN predicts compressed codes rather than raw pixels. Training uses replay of stored history, BPTT, sequential network construction (adding/pruning units), and a minimum-description-length style regularizer.</td>
                        </tr>
                        <tr>
                            <td><strong>model_type</strong></td>
                            <td>neural predictive world model (RNN/LSTM with optional CNN/FNN preprocessor)</td>
                        </tr>
                        <tr>
                            <td><strong>task_domain</strong></td>
                            <td>Partially observable reinforcement learning tasks with high-dimensional sensory input (e.g., video-based control, simulated driving, robotic manipulation, general sequence prediction and planning)</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_metric</strong></td>
                            <td>Prediction error E(t)=Σ_{τ=1}^{t-1} ||pred(τ+1) - sense(τ+1)||^2 (MSE-style), and compression-based metric bits_M + bits_H where bits_H uses -log P_e(error) for prediction errors and bits_M encodes model description (weight encoding or prior on weights); overall objective is to minimize bits_M + bits_H (a time-bounded Kolmogorov-complexity proxy).</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>interpretability_assessment</strong></td>
                            <td>Partially interpretable: hidden units develop high-level, abstract spatio-temporal feature detectors (potentially long-lasting activations). Not a fully transparent symbolic model; interpretability can be improved if M is self-modularizing (winner-take-all) so one can track which modules encode which parts of the history; mirror-neuron-like shared detectors emerge as by-products of compression.</td>
                        </tr>
                        <tr>
                            <td><strong>interpretability_method</strong></td>
                            <td>Inspection/analysis of hidden unit activations and feature detectors; modularization (self-modularizing, winner-take-all RNN) to track which parts of M encode particular data; no formal symbolic extraction method is specified.</td>
                        </tr>
                        <tr>
                            <td><strong>computational_cost</strong></td>
                            <td>Qualitative: training uses BPTT on replayed lifelong history and sequential network construction (adding/pruning units), may require storing full interaction history (holy data); per-time-step M runtime bounded by fixed number of elementary computations; no numerical compute budgets or parameter counts provided.</td>
                        </tr>
                        <tr>
                            <td><strong>efficiency_comparison</strong></td>
                            <td>Qualitative claim: using M to expose algorithmic information to the (smaller) controller C reduces C's search space and can dramatically accelerate learning compared to learning from scratch or naive model-free RL; no quantitative speedups presented in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>task_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_utility_analysis</strong></td>
                            <td>Paper argues that perfect prediction is not necessary; M approximates conditional expectations and compresses regularities useful for decision making. The world model's learned abstractions (high-level feature detectors) are expected to be more useful to C for planning than raw low-level fidelity; thus task-relevant compressed representations can be more beneficial than minimizing pixel-wise error alone.</td>
                        </tr>
                        <tr>
                            <td><strong>tradeoffs_observed</strong></td>
                            <td>Trade-offs discussed qualitatively: (1) bits_M + bits_H formalizes a trade-off between model complexity and residual error (MDL); (2) higher model complexity (more bits_M) can reduce bits_H but costs storage/compute; (3) predicting raw high-dimensional inputs is expensive, so using preprocessors reduces compute at possible cost to raw fidelity; (4) making M modular improves verification/interpretability but may limit global compression if not well designed.</td>
                        </tr>
                        <tr>
                            <td><strong>design_choices</strong></td>
                            <td>Use LSTM RNN for M (handles long-range dependencies); optionally use CNN/FNN autoencoder hierarchies to compress raw frames before RNN prediction; objective is minimize bits_M + bits_H (regularized prediction loss); store full lifelong history and use replay for training; sequential network construction to grow/prune M; freeze M during controller (C) training; optionally make M self-modularizing (winner-take-all) to enable tracking and cheaper verification.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_alternatives</strong></td>
                            <td>Compared qualitatively to: (a) naive step-by-step Monte-Carlo simulation on a learned model (more expensive and less likely to produce hierarchical abstractions), (b) early RNN-based CM systems that simulated futures but lacked mechanisms for C to directly query M's internal programs, and (c) model-free RL (which must learn from scratch). The paper argues M+direct-query C is asymptotically and practically superior in many partially observable tasks, but provides no empirical numeric comparisons.</td>
                        </tr>
                        <tr>
                            <td><strong>optimal_configuration</strong></td>
                            <td>Paper recommends balancing model description size and residual error (minimize bits_M + bits_H) as the operational optimum; use LSTM for long-term dependencies, CNN/FNN preprocessing for high-dimensional inputs, and modular M architectures to allow efficient verification and interpretability. No specific hyperparameters or numeric guidelines are given.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'On Learning to Think: Algorithmic Information Theory for Novel Combinations of Reinforcement Learning Controllers and Recurrent Neural World Models', 'publication_date_yy_mm': '2015-11'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1384.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e1384.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of world models used in AI systems, including details about their fidelity, interpretability, computational efficiency, and task-specific utility.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>CNN/FNN Preprocessor</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Built-in FNN/CNN Autoencoder Preprocessor for the World Model</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A feedforward neural network (often convolutional autoencoder hierarchy) that separately compresses each high-dimensional sensory frame into compact codes which are then fed to the RNN world model M; M predicts the compressed codes and the decoded predictions are used to evaluate overall compression.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>CNN/FNN Preprocessor (Autoencoder hierarchy)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Convolutional or other feedforward autoencoder(s) that compress each sensory frame independently to a lower-dimensional code; M is trained to predict the sequence of these codes instead of raw inputs; the decoder(s) are used to reconstruct frames to measure bits_M + bits_H for the combined FNN-RNN system.</td>
                        </tr>
                        <tr>
                            <td><strong>model_type</strong></td>
                            <td>neural encoder (part of hybrid world model: FNN/CNN encoder + RNN predictive model)</td>
                        </tr>
                        <tr>
                            <td><strong>task_domain</strong></td>
                            <td>High-dimensional sensory domains (video, images) feeding into RL tasks and predictive compression for planning (e.g., driving from pixels, vision-based robotics).</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_metric</strong></td>
                            <td>Reconstruction loss of autoencoder (e.g., MSE on reconstructed frames or negative log-likelihood), prediction error on compressed codes as part of bits_M + bits_H compression metric.</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>interpretability_assessment</strong></td>
                            <td>Compressed latent codes can be inspected but are typically less directly interpretable than symbolic representations; autoencoder features may correspond to useful visual features but no systematic interpretability claims are made.</td>
                        </tr>
                        <tr>
                            <td><strong>interpretability_method</strong></td>
                            <td>None specific beyond standard inspection/visualization of learned features; paper does not propose dedicated disentangling or symbolic extraction methods for the preprocessor.</td>
                        </tr>
                        <tr>
                            <td><strong>computational_cost</strong></td>
                            <td>Adds extra training and inference cost for encoder and decoder networks; overall reduces the RNN input dimensionality (trading encoder cost for cheaper RNN training). No numerical compute or parameter-count figures are provided.</td>
                        </tr>
                        <tr>
                            <td><strong>efficiency_comparison</strong></td>
                            <td>Qualitative: preprocessing raw high-dimensional inputs with autoencoders reduces redundancy and lowers the load on the RNN predictor, facilitating faster learning and better compression than predicting raw pixels directly; no quantitative comparison numbers provided.</td>
                        </tr>
                        <tr>
                            <td><strong>task_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_utility_analysis</strong></td>
                            <td>Preprocessing priorities task-relevant compressed features over raw reconstruction fidelity; this can improve M's ability to learn predictive abstractions that are useful for C, at the potential cost of losing some pixel-level detail.</td>
                        </tr>
                        <tr>
                            <td><strong>tradeoffs_observed</strong></td>
                            <td>Trade-off between compression/efficiency and fidelity of raw reconstructions: smaller latent codes improve efficiency but may drop details; decoding is required to evaluate overall compression cost (bits_M + bits_H), which couples encoder size to final objective.</td>
                        </tr>
                        <tr>
                            <td><strong>design_choices</strong></td>
                            <td>Use autoencoder hierarchies or CNN-based encoders to produce compact codes per frame; train encoder+RNN jointly or evaluate combined bits_M + bits_H; predict compressed codes rather than raw inputs to reduce RNN size.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_alternatives</strong></td>
                            <td>Compared qualitatively to direct prediction of raw pixels (raw-pixel RNN): preprocessor reduces dimensionality and redundancy and thus is expected to be more efficient for large images; no empirical measures given.</td>
                        </tr>
                        <tr>
                            <td><strong>optimal_configuration</strong></td>
                            <td>Recommend compressing frames into less redundant sensory codes appropriate for the RNN predictor; no explicit dimensionalities or architectural hyperparameters are prescribed.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'On Learning to Think: Algorithmic Information Theory for Novel Combinations of Reinforcement Learning Controllers and Recurrent Neural World Models', 'publication_date_yy_mm': '2015-11'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1384.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e1384.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of world models used in AI systems, including details about their fidelity, interpretability, computational efficiency, and task-specific utility.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Early predictive RNN world models (1990)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Early RNN Controller/Model (C/M) Systems (circa 1990)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Historical RNN-based controller/model systems where an RNN world model M learned to predict sensory inputs and reward and was used as a surrogate environment to train a controller C via gradient-based planning in M-simulated trials; these early systems did not use modern architectures like LSTM and relied on step-by-step simulation of futures.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Early RNN predictive world models (1990 CM systems)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>RNNs trained to predict next inputs and rewards from histories; M's outputs served as inputs to C during simulated trials so that C could be trained by gradient descent in model-generated rollouts; planning was done by simulating many full step-by-step futures in M.</td>
                        </tr>
                        <tr>
                            <td><strong>model_type</strong></td>
                            <td>neural predictive world model (early RNN without modern gating; surrogate environment simulator)</td>
                        </tr>
                        <tr>
                            <td><strong>task_domain</strong></td>
                            <td>Partially observable control tasks (examples: early sequential active vision, simple RL domains), used historically for planning and active vision.</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_metric</strong></td>
                            <td>Prediction error (conditional expectation approximations); cumulative prediction error used indirectly through simulated rollouts; sensitivity to noise noted (M learns conditional expectations which can be suboptimal in noisy settings).</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>interpretability_assessment</strong></td>
                            <td>Black-box neural predictors; limited interpretability and limited ability to produce hierarchical/abstract plans because planning relied on explicit time-step simulation rather than accessing internal abstractions.</td>
                        </tr>
                        <tr>
                            <td><strong>interpretability_method</strong></td>
                            <td>None described for extracting abstractions; approach relied on simulated rollouts and gradient signals.</td>
                        </tr>
                        <tr>
                            <td><strong>computational_cost</strong></td>
                            <td>High: planning required simulating many entire alternative futures time step by time step (computationally expensive), especially problematic for high-dimensional inputs.</td>
                        </tr>
                        <tr>
                            <td><strong>efficiency_comparison</strong></td>
                            <td>Less efficient than the paper's proposed method (letting C directly query/internalize M) because of the need for many simulated rollouts; problematic in noisy environments where Monte Carlo methods must be used on M.</td>
                        </tr>
                        <tr>
                            <td><strong>task_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_utility_analysis</strong></td>
                            <td>Useful in near-deterministic settings; performance degrades in noisy environments due to M's tendency to learn conditional expectations rather than full stochastic dynamics; planning via many rollouts scales poorly.</td>
                        </tr>
                        <tr>
                            <td><strong>tradeoffs_observed</strong></td>
                            <td>Trade-off between fidelity of simulation and computational cost: accurate, high-fidelity simulation requires expensive computation; naive simulation does not exploit higher-level abstractions and thus can be inefficient.</td>
                        </tr>
                        <tr>
                            <td><strong>design_choices</strong></td>
                            <td>Simulate whole futures step-by-step in M and train C within those simulated rollouts; use gradient-based training for C while keeping M fixed; did not include mechanisms for C to query M internal programs directly or use LSTM-like gating.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_alternatives</strong></td>
                            <td>Paper contrasts these early systems with the proposed CM architecture where C can directly query and exploit M's internal program and abstractions, enabling hierarchical planning and more efficient search.</td>
                        </tr>
                        <tr>
                            <td><strong>optimal_configuration</strong></td>
                            <td>The paper argues improvements come from (a) using architectures capable of long-term abstractions (LSTM), (b) allowing C to directly access M internals rather than only simulating whole futures, and (c) using compression-based objectives (bits_M + bits_H) to guide model construction.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'On Learning to Think: Algorithmic Information Theory for Novel Combinations of Reinforcement Learning Controllers and Recurrent Neural World Models', 'publication_date_yy_mm': '2015-11'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Learning to forget: Continual prediction with LSTM <em>(Rating: 2)</em></li>
                <li>Connectionist temporal classification: Labelling unsegmented sequence data with recurrent neural nets <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-1384",
    "paper_id": "paper-f0b9dc64f6df004d3f776031050317f0a7fb1bdc",
    "extraction_schema_id": "extraction-schema-27",
    "extracted_data": [
        {
            "name_short": "M",
            "name_full": "Gradient-based RNN World Model (M)",
            "brief_description": "An RNN (typically LSTM-based, optionally with CNN/FNN preprocessing) trained by gradient-based unsupervised learning to predict next sensory inputs and compress the agent's entire interaction history; frozen while the controller C learns to query and exploit its internal program.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "M (Gradient-Based RNN World Model)",
            "model_description": "Recurrent neural network (recommended LSTM) that receives sensory inputs and actions and produces pred(t+1), a prediction of next sensory input; trained to compress the lifelong history by minimizing a combination of prediction error and model complexity (bits_M + bits_H). Optionally preceded by a CNN/FNN autoencoder that compresses individual frames; the RNN predicts compressed codes rather than raw pixels. Training uses replay of stored history, BPTT, sequential network construction (adding/pruning units), and a minimum-description-length style regularizer.",
            "model_type": "neural predictive world model (RNN/LSTM with optional CNN/FNN preprocessor)",
            "task_domain": "Partially observable reinforcement learning tasks with high-dimensional sensory input (e.g., video-based control, simulated driving, robotic manipulation, general sequence prediction and planning)",
            "fidelity_metric": "Prediction error E(t)=Σ_{τ=1}^{t-1} ||pred(τ+1) - sense(τ+1)||^2 (MSE-style), and compression-based metric bits_M + bits_H where bits_H uses -log P_e(error) for prediction errors and bits_M encodes model description (weight encoding or prior on weights); overall objective is to minimize bits_M + bits_H (a time-bounded Kolmogorov-complexity proxy).",
            "fidelity_performance": null,
            "interpretability_assessment": "Partially interpretable: hidden units develop high-level, abstract spatio-temporal feature detectors (potentially long-lasting activations). Not a fully transparent symbolic model; interpretability can be improved if M is self-modularizing (winner-take-all) so one can track which modules encode which parts of the history; mirror-neuron-like shared detectors emerge as by-products of compression.",
            "interpretability_method": "Inspection/analysis of hidden unit activations and feature detectors; modularization (self-modularizing, winner-take-all RNN) to track which parts of M encode particular data; no formal symbolic extraction method is specified.",
            "computational_cost": "Qualitative: training uses BPTT on replayed lifelong history and sequential network construction (adding/pruning units), may require storing full interaction history (holy data); per-time-step M runtime bounded by fixed number of elementary computations; no numerical compute budgets or parameter counts provided.",
            "efficiency_comparison": "Qualitative claim: using M to expose algorithmic information to the (smaller) controller C reduces C's search space and can dramatically accelerate learning compared to learning from scratch or naive model-free RL; no quantitative speedups presented in this paper.",
            "task_performance": null,
            "task_utility_analysis": "Paper argues that perfect prediction is not necessary; M approximates conditional expectations and compresses regularities useful for decision making. The world model's learned abstractions (high-level feature detectors) are expected to be more useful to C for planning than raw low-level fidelity; thus task-relevant compressed representations can be more beneficial than minimizing pixel-wise error alone.",
            "tradeoffs_observed": "Trade-offs discussed qualitatively: (1) bits_M + bits_H formalizes a trade-off between model complexity and residual error (MDL); (2) higher model complexity (more bits_M) can reduce bits_H but costs storage/compute; (3) predicting raw high-dimensional inputs is expensive, so using preprocessors reduces compute at possible cost to raw fidelity; (4) making M modular improves verification/interpretability but may limit global compression if not well designed.",
            "design_choices": "Use LSTM RNN for M (handles long-range dependencies); optionally use CNN/FNN autoencoder hierarchies to compress raw frames before RNN prediction; objective is minimize bits_M + bits_H (regularized prediction loss); store full lifelong history and use replay for training; sequential network construction to grow/prune M; freeze M during controller (C) training; optionally make M self-modularizing (winner-take-all) to enable tracking and cheaper verification.",
            "comparison_to_alternatives": "Compared qualitatively to: (a) naive step-by-step Monte-Carlo simulation on a learned model (more expensive and less likely to produce hierarchical abstractions), (b) early RNN-based CM systems that simulated futures but lacked mechanisms for C to directly query M's internal programs, and (c) model-free RL (which must learn from scratch). The paper argues M+direct-query C is asymptotically and practically superior in many partially observable tasks, but provides no empirical numeric comparisons.",
            "optimal_configuration": "Paper recommends balancing model description size and residual error (minimize bits_M + bits_H) as the operational optimum; use LSTM for long-term dependencies, CNN/FNN preprocessing for high-dimensional inputs, and modular M architectures to allow efficient verification and interpretability. No specific hyperparameters or numeric guidelines are given.",
            "uuid": "e1384.0",
            "source_info": {
                "paper_title": "On Learning to Think: Algorithmic Information Theory for Novel Combinations of Reinforcement Learning Controllers and Recurrent Neural World Models",
                "publication_date_yy_mm": "2015-11"
            }
        },
        {
            "name_short": "CNN/FNN Preprocessor",
            "name_full": "Built-in FNN/CNN Autoencoder Preprocessor for the World Model",
            "brief_description": "A feedforward neural network (often convolutional autoencoder hierarchy) that separately compresses each high-dimensional sensory frame into compact codes which are then fed to the RNN world model M; M predicts the compressed codes and the decoded predictions are used to evaluate overall compression.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "CNN/FNN Preprocessor (Autoencoder hierarchy)",
            "model_description": "Convolutional or other feedforward autoencoder(s) that compress each sensory frame independently to a lower-dimensional code; M is trained to predict the sequence of these codes instead of raw inputs; the decoder(s) are used to reconstruct frames to measure bits_M + bits_H for the combined FNN-RNN system.",
            "model_type": "neural encoder (part of hybrid world model: FNN/CNN encoder + RNN predictive model)",
            "task_domain": "High-dimensional sensory domains (video, images) feeding into RL tasks and predictive compression for planning (e.g., driving from pixels, vision-based robotics).",
            "fidelity_metric": "Reconstruction loss of autoencoder (e.g., MSE on reconstructed frames or negative log-likelihood), prediction error on compressed codes as part of bits_M + bits_H compression metric.",
            "fidelity_performance": null,
            "interpretability_assessment": "Compressed latent codes can be inspected but are typically less directly interpretable than symbolic representations; autoencoder features may correspond to useful visual features but no systematic interpretability claims are made.",
            "interpretability_method": "None specific beyond standard inspection/visualization of learned features; paper does not propose dedicated disentangling or symbolic extraction methods for the preprocessor.",
            "computational_cost": "Adds extra training and inference cost for encoder and decoder networks; overall reduces the RNN input dimensionality (trading encoder cost for cheaper RNN training). No numerical compute or parameter-count figures are provided.",
            "efficiency_comparison": "Qualitative: preprocessing raw high-dimensional inputs with autoencoders reduces redundancy and lowers the load on the RNN predictor, facilitating faster learning and better compression than predicting raw pixels directly; no quantitative comparison numbers provided.",
            "task_performance": null,
            "task_utility_analysis": "Preprocessing priorities task-relevant compressed features over raw reconstruction fidelity; this can improve M's ability to learn predictive abstractions that are useful for C, at the potential cost of losing some pixel-level detail.",
            "tradeoffs_observed": "Trade-off between compression/efficiency and fidelity of raw reconstructions: smaller latent codes improve efficiency but may drop details; decoding is required to evaluate overall compression cost (bits_M + bits_H), which couples encoder size to final objective.",
            "design_choices": "Use autoencoder hierarchies or CNN-based encoders to produce compact codes per frame; train encoder+RNN jointly or evaluate combined bits_M + bits_H; predict compressed codes rather than raw inputs to reduce RNN size.",
            "comparison_to_alternatives": "Compared qualitatively to direct prediction of raw pixels (raw-pixel RNN): preprocessor reduces dimensionality and redundancy and thus is expected to be more efficient for large images; no empirical measures given.",
            "optimal_configuration": "Recommend compressing frames into less redundant sensory codes appropriate for the RNN predictor; no explicit dimensionalities or architectural hyperparameters are prescribed.",
            "uuid": "e1384.1",
            "source_info": {
                "paper_title": "On Learning to Think: Algorithmic Information Theory for Novel Combinations of Reinforcement Learning Controllers and Recurrent Neural World Models",
                "publication_date_yy_mm": "2015-11"
            }
        },
        {
            "name_short": "Early predictive RNN world models (1990)",
            "name_full": "Early RNN Controller/Model (C/M) Systems (circa 1990)",
            "brief_description": "Historical RNN-based controller/model systems where an RNN world model M learned to predict sensory inputs and reward and was used as a surrogate environment to train a controller C via gradient-based planning in M-simulated trials; these early systems did not use modern architectures like LSTM and relied on step-by-step simulation of futures.",
            "citation_title": "",
            "mention_or_use": "mention",
            "model_name": "Early RNN predictive world models (1990 CM systems)",
            "model_description": "RNNs trained to predict next inputs and rewards from histories; M's outputs served as inputs to C during simulated trials so that C could be trained by gradient descent in model-generated rollouts; planning was done by simulating many full step-by-step futures in M.",
            "model_type": "neural predictive world model (early RNN without modern gating; surrogate environment simulator)",
            "task_domain": "Partially observable control tasks (examples: early sequential active vision, simple RL domains), used historically for planning and active vision.",
            "fidelity_metric": "Prediction error (conditional expectation approximations); cumulative prediction error used indirectly through simulated rollouts; sensitivity to noise noted (M learns conditional expectations which can be suboptimal in noisy settings).",
            "fidelity_performance": null,
            "interpretability_assessment": "Black-box neural predictors; limited interpretability and limited ability to produce hierarchical/abstract plans because planning relied on explicit time-step simulation rather than accessing internal abstractions.",
            "interpretability_method": "None described for extracting abstractions; approach relied on simulated rollouts and gradient signals.",
            "computational_cost": "High: planning required simulating many entire alternative futures time step by time step (computationally expensive), especially problematic for high-dimensional inputs.",
            "efficiency_comparison": "Less efficient than the paper's proposed method (letting C directly query/internalize M) because of the need for many simulated rollouts; problematic in noisy environments where Monte Carlo methods must be used on M.",
            "task_performance": null,
            "task_utility_analysis": "Useful in near-deterministic settings; performance degrades in noisy environments due to M's tendency to learn conditional expectations rather than full stochastic dynamics; planning via many rollouts scales poorly.",
            "tradeoffs_observed": "Trade-off between fidelity of simulation and computational cost: accurate, high-fidelity simulation requires expensive computation; naive simulation does not exploit higher-level abstractions and thus can be inefficient.",
            "design_choices": "Simulate whole futures step-by-step in M and train C within those simulated rollouts; use gradient-based training for C while keeping M fixed; did not include mechanisms for C to query M internal programs directly or use LSTM-like gating.",
            "comparison_to_alternatives": "Paper contrasts these early systems with the proposed CM architecture where C can directly query and exploit M's internal program and abstractions, enabling hierarchical planning and more efficient search.",
            "optimal_configuration": "The paper argues improvements come from (a) using architectures capable of long-term abstractions (LSTM), (b) allowing C to directly access M internals rather than only simulating whole futures, and (c) using compression-based objectives (bits_M + bits_H) to guide model construction.",
            "uuid": "e1384.2",
            "source_info": {
                "paper_title": "On Learning to Think: Algorithmic Information Theory for Novel Combinations of Reinforcement Learning Controllers and Recurrent Neural World Models",
                "publication_date_yy_mm": "2015-11"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Learning to forget: Continual prediction with LSTM",
            "rating": 2
        },
        {
            "paper_title": "Connectionist temporal classification: Labelling unsegmented sequence data with recurrent neural nets",
            "rating": 1
        }
    ],
    "cost": 0.01664,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>On Learning to Think: Algorithmic Information Theory for Novel Combinations of Reinforcement Learning Controllers and Recurrent Neural World Models</h1>
<p>Technical Report<br>Jürgen Schmidhuber<br>The Swiss AI Lab<br>Istituto Dalle Molle di Studi sull'Intelligenza Artificiale (IDSIA)<br>Università della Svizzera italiana (USI)<br>Scuola universitaria professionale della Svizzera italiana (SUPSI)<br>Galleria 2, 6928 Manno-Lugano, Switzerland</p>
<p>30 November 2015</p>
<h4>Abstract</h4>
<p>This paper addresses the general problem of reinforcement learning (RL) in partially observable environments. In 2013, our large RL recurrent neural networks (RNNs) learned from scratch to drive simulated cars from high-dimensional video input. However, real brains are more powerful in many ways. In particular, they learn a predictive model of their initially unknown environment, and somehow use it for abstract (e.g., hierarchical) planning and reasoning. Guided by algorithmic information theory, we describe RNN-based AIs (RNNAIs) designed to do the same. Such an RNNAI can be trained on never-ending sequences of tasks, some of them provided by the user, others invented by the RNNAI itself in a curious, playful fashion, to improve its RNN-based world model. Unlike our previous model-building RNN-based RL machines dating back to 1990, the RNNAI learns to actively query its model for abstract reasoning and planning and decision making, essentially "learning to think." The basic ideas of this report can be applied to many other cases where one RNN-like system exploits the algorithmic information content of another. They are taken from a grant proposal submitted in Fall 2014, and also explain concepts such as "mirror neurons." Experimental results will be described in separate papers.</p>
<h1>Contents</h1>
<p>1 Introduction to Reinforcement Learning (RL) with Recurrent Neural Networks (RNNs) in Partially Observable Environments ..... 2
1.1 RL through Direct and Indirect Search in RNN Program Space ..... 3
1.2 Deep Learning in NNs: Supervised \&amp; Unsupervised Learning (SL \&amp; UL) ..... 3
1.3 Gradient Descent-Based NNs for RL ..... 4
1.3.1 Early RNN Controllers with Predictive RNN World Models ..... 5
1.3.2 Early Predictive RNN World Models Combined with Traditional RL ..... 5
1.4 Hierarchical \&amp; Multitask RL and Algorithmic Transfer Learning ..... 6
2 Algorithmic Information Theory (AIT) for RNN-based AIs ..... 6
2.1 Basic AIT Argument ..... 7
2.2 One RNN-Like System Actively Learns to Exploit Algorithmic Information of Another ..... 7
2.3 Consequences of the AIT Argument for Model-Building Controllers ..... 8
3 The RNNAI and its Holy Data ..... 8
3.1 Standard Activation Spreading in Typical RNNs ..... 9
3.2 Alternating Training Phases for Controller $\boldsymbol{C}$ and World Model $\boldsymbol{M}$ ..... 9
4 The Gradient-Based World Model $M$ ..... 10
4.1 $M$ 's Compression Performance on the History so far ..... 10
4.2 $M$ 's Training ..... 11
4.3 $M$ may have a Built-In FNN Preprocessor ..... 11
5 The Controller $\boldsymbol{C}$ Learning to Exploit RNN World Model $\boldsymbol{M}$ ..... 11
5.1 $\boldsymbol{C}$ as a Standard RL Machine whose States are $\boldsymbol{M}$ 's Activations ..... 12
5.2 $\boldsymbol{C}$ as an Evolutionary RL (R)NN whose Inputs are $\boldsymbol{M}$ 's Activations ..... 12
5.3 $\boldsymbol{C}$ Learns to Think with $\boldsymbol{M}$ : High-Level Plans and Abstractions ..... 12
5.4 Incremental / Hierarchical / Multitask Learning of $\boldsymbol{C}$ with $\boldsymbol{M}$ ..... 14
6 Exploration: Rewarding $\boldsymbol{C}$ for Experiments that Improve $\boldsymbol{M}$ ..... 14
7 Conclusion ..... 15</p>
<h2>1 Introduction to Reinforcement Learning (RL) with Recurrent Neural Networks (RNNs) in Partially Observable Environments ${ }^{1}$</h2>
<p>General Reinforcement Learning (RL) agents must discover, without the aid of a teacher, how to interact with a dynamic, initially unknown, partially observable environment in order to maximize their expected cumulative reward signals, e.g., [123, 272, 310]. There may be arbitrary, a priori unknown delays between actions and perceivable consequences. The RL problem is as hard as any problem of computer science, since any task with a computable description can be formulated in the RL framework, e.g., [109].</p>
<p>To become a general problem solver that is able to run arbitrary problem-solving programs, the controller of a robot or an artificial agent must be a general-purpose computer [67, 35, 282, 194].</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>Artificial recurrent neural networks (RNNs) fit this bill. A typical RNN consists of many simple, connected processors called neurons, each producing a sequence of real-valued activations. Input neurons get activated through sensors perceiving the environment, other neurons get activated through weighted connections or wires from previously active neurons, and some neurons may affect the environment by triggering actions. Learning or credit assignment is about finding real-valued weights that make the NN exhibit desired behavior, such as driving a car. Depending on the problem and how the neurons are connected, such behavior may require long causal chains of computational stages, where each stage transforms the aggregate activation of the network, often in a non-linear manner.</p>
<p>Unlike feedforward NNs (FNNs; [95, 23]) and Support Vector Machines (SVMs; [287, 253]), RNNs can in principle interact with a dynamic partially observable environment in arbitrary, computable ways, creating and processing memories of sequences of input patterns [258]. The weight matrix of an RNN is its program. Without a teacher, reward-maximizing programs of an RNN must be learned through repeated trial and error.</p>
<h1>1.1 RL through Direct and Indirect Search in RNN Program Space</h1>
<p>It is possible to train small RNNs with a few 100 or 1000 weights using evolutionary algorithms [200, $255,105,56,68$ ] to search the space of NN weights [165, 307, 44, 321, 180, 259, 320, 164, 173, $69,71,187,121,313,66,270,269,305]$, or through policy gradients (PGs) [314, 315, 316, 274, $18,1,63,128,313,210,192,191,256,85,312,190,82,93][245$, Sec. 6.6]. For example, our evolutionary algorithms outperformed traditional, Dynamic Programming [20]-based RL methods [272][245, Sec. 6.2] in partially observable environments, e.g., [72]. However, these techniques by themselves are insufficient for solving complex control problems involving high-dimensional sensory inputs such as video, from scratch. The program search space for networks of the size required for these tasks is simply too large.</p>
<p>However, the search space can often be reduced dramatically by evolving compact encodings of neural networks (NNs), e.g., through Lindenmeyer Systems [115], graph rewriting [127], Cellular Encoding [83], HyperNEAT [268], and other techniques [245, Sec. 6.7]. In very general early work, we used universal assembler-like languages to encode NNs [235], later coefficients of a Discrete Cosine Transform (DCT) [132]. The latter method, Compressed RNN Search [132], was used to successfully evolve RNN controllers with over a million weights (the largest ever evolved) to drive a simulated car in a video game, based solely on a high-dimensional video stream [132]-learning both control and visual processing from scratch, without unsupervised pre-training of a vision system. This was the first published Deep Learner to learn control policies directly from high-dimensional sensory input using RL.</p>
<p>One can further facilitate the learning task of controllers through certain types of supervised learning (SL) and unsupervised learning (UL) based on gradient descent techniques. In particular, UL/SL can be used to compress the search space, and to build predictive world models to accelerate RL, as will be discussed later. But first let us review the relevant NN algorithms for SL and UL.</p>
<h3>1.2 Deep Learning in NNs: Supervised \&amp; Unsupervised Learning (SL \&amp; UL)</h3>
<p>The term Deep Learning was first introduced to Machine Learning in 1986 [49] and to NNs in 2000 [3, 244]. The first deep learning NNs, however, date back to the 1960s [113, 245] (certain more recent developments are covered in a survey [139]).</p>
<p>To maximize differentiable objective functions of SL and UL, NN researchers almost invariably use backpropagation (BP) [125, 30, 52] in discrete graphs of nodes with differentiable activation functions [151, 265][245, Sec. 5.5]. Typical applications include BP in FNNs [297], or BP through time (BPTT) and similar methods in RNNs, e.g., [299, 317, 208][245]. BP and BPTT suffer from the</p>
<p>Fundamental Deep Learning Problem first discovered and analyzed in my lab in 1991: with standard activation functions, cumulative backpropagated error signals decay exponentially in the number of layers, or they explode [98, 99]. Hence most early FNNs [297, 211] had few layers. Similarly, early RNNs [245, Sec. 5.6.1] could not generalize well under both short and long time lags between relevant events. Over the years, several ways of overcoming the Fundamental Deep Learning Problem have been explored. For example, deep stacks of unsupervised RNNs [228] or FNNs [13, 96, 139] help to accelerate subsequent supervised learning through BPTT [228, 230] or BP [96]. One can also "distill" or compress the knowledge of a teacher RNN into a student RNN by forcing the student to predict the hidden units of the teacher [228, 230].</p>
<p>Long Short-Term Memory (LSTM; [101, 61, 77]) alleviates the Fundamental Deep Learning Problem, and was the first RNN architecture to win international contests (in connected handwriting), e.g., [79, 247][245]. Connectionist Temporal Classification (CTC) [76] is a widely used gradient-based method for finding RNN weights that maximize the probability of teacher-provided label sequences, given (typically much longer and more high-dimensional) streams of real-valued input vectors. For example, CTC was used by Baidu to break an important speech recognition record [88]. Many recent state-of-the-art results in sequence processing are based on LSTM, which learned to control robots [159], and was used to set benchmark records in prosody contour prediction [55] (IBM), text-to-speech synthesis [54] (Microsoft), large vocabulary speech recognition [213] (Google), and machine translation [271] (Google). CTC-trained LSTM greatly improved Google Voice [214] and is now available to over a billion smartphone users. Nevertheless, at least in some applications, other RNNs may sometimes yield better results than gradient-based LSTM [158, 217, 323, 116, 250, 186, 133]. Alternative NNs with differentiable memory have been proposed [229, 47, 175, 232, 231, 103, 80, 303].</p>
<p>Today's faster computers, such as GPUs, mitigate the Fundamental Deep Learning Problem for FNNs [181, 34, 198, 38, 40]. In particular, many recent computer vision contests were won by fully supervised Max-Pooling Convolutional NNs (MPCNNs), which consist of alternating convolutional [58, 19] and max-pooling [296] layers topped off by standard fully connected output layers. All weights are trained by backpropagation [140, 199, 220, 245]. Ensembles [218, 28] of GPUbased MPCNNs [40, 41] achieved dramatic improvements of long-standing benchmark records, e.g., MNIST (2011), won numerous competitions [247, 38, 41, 39, 161, 42, 36, 134, 322, 37, 245], and achieved the first human-competitive or even superhuman results on well-known benchmarks, e.g., [247, 42, 245]. There are many recent variations and improvements [64, 74, 124, 75, 277, 266, 245]. Supervised Transfer Learning from one dataset to another [32, 43] can speed up learning. A combination of Convolutional NNs (CNNs) and LSTM led to best results in automatic image caption generation [288].</p>
<h1>1.3 Gradient Descent-Based NNs for RL</h1>
<p>Perhaps the most well-known RL application is Tesauro's backgammon player [280] from 1994 which learned to achieve the level of human world champions, by playing against itself. It uses a reactive (memory-free) policy based on the simplifying assumption of Markov Decision Processes: the current input of the RL agent conveys all information necessary to compute an optimal next output event or decision. The policy is implemented as a gradient-based FNN trained by the method of temporal differences [272][245, Sec. 6.2]. During play, the FNN learns to map board states to predictions of expected cumulative reward, and selects actions leading to states with maximal predicted reward. A very similar approach (also based on over 20-year-old methods) employed a CNN (see Sec. 1.2) to play several Atari video games directly from $84 \times 84$ pixel 60 Hz video input [167], using Neural Fitted Q-Learning (NFQ) [201] based on experience replay (1991) [149]. Even better results were</p>
<p>achieved by using (slow) Monte Carlo tree planning to train comparatively fast deep NNs [86].
Such FNN approaches cannot work in realistic partially observable environments where memories of previous inputs have to be stored for a priori unknown time intervals. This triggered work on partially observable Markov decision problems (POMDPs) [223, 222, 227, 204, 205, 206, 316, 148, 278, 122, 152, 25, 114, 160, 126, 308, 309, 183]. Traditional RL techniques [272][245, Sec. 6.2] based on Dynamic Programming [20] can be combined with gradient descent methods to train an RNN as a value-function approximator that maps entire event histories to predictions of expected cumulative reward [227, 148]. LSTM [101, 61, 189, 78, 77] (see Sec. 1.2) was used in this way for RL robots [12].</p>
<p>Gradient-based UL may be used to reduce an RL controller's search space by feeding it only compact codes of high-dimensional inputs [118, 142, 46][245, Sec. 6.4]. For example, NFQ [201] was applied to real-world control tasks [138, 202] where purely visual inputs were compactly encoded in hidden layers of deep autoencoders [245, Sec. 5.7 and and 5.15]. RL combined with unsupervised learning based on Slow Feature Analysis [318, 131] enabled a humanoid robot to learn skills from raw video streams [154]. A RAAM RNN [193] was employed as a deep unsupervised sequence encoder for RL [65].</p>
<h1>1.3.1 Early RNN Controllers with Predictive RNN World Models</h1>
<p>One important application of gradient-based UL is to obtain a predictive world model, $M$, that a controller, $C$, may use to achieve its goals more efficiently, e.g., through cheap, "mental" $M$-based trials, as opposed to expensive trials in the real world [301, 273]. The first combination of an RL RNN $C$ and an UL RNN $M$ was ours and dates back to 1990 [223, 222, 226, 227], generalizing earlier similar controller/model systems ( $C M$ systems) based on FNNs [298, 179]; compare related work [177, 119, 301, 300, 209, 120, 178, 302, 73, 45, 144, 166, 153, 196, 60][245, Sec. 6.1]. $M$ tries to learn to predict $C$ 's inputs (including reward signals) from previous inputs and actions. $M$ is also temporarily used as a surrogate for the environment: $M$ and $C$ form a coupled RNN where $M$ 's outputs become inputs of $C$, whose outputs (actions) in turn become inputs of $M$. Now a gradient descent technique <a href="see Sec. 1.2">299, 317, 208</a> can be used to learn and plan ahead by training $C$ in a series of $M$-simulated trials to produce output action sequences achieving desired input events, such as high real-valued reward signals (while the weights of $M$ remain fixed). An RL active vision system, from 1991 [249], used this basic principle to learn sequential shifts (saccades) of a fovea to detect targets in a visual scene, thus learning a rudimentary version of selective attention.</p>
<p>Those early $C M$ systems, however, did not yet use powerful RNNs such as LSTM. A more fundamental problem is that if the environment is too noisy, $M$ will usually only learn to approximate the conditional expectations of predicted values, given parts of the history. In certain noisy environments, Monte Carlo Tree Sampling (MCTS; [29]) and similar techniques may be applied to $M$ to plan successful future action sequences for $C$. All such methods, however, are about simulating possible futures time step by time step, without profiting from human-like hierarchical planning or abstract reasoning, which often ignores irrelevant details.</p>
<h3>1.3.2 Early Predictive RNN World Models Combined with Traditional RL</h3>
<p>In the early 1990s, an RNN $M$ as in Sec. 1.3.1 was also combined [227, 150] with traditional temporal difference methods [122, 272][245, Sec. 6.2] based on the Markov assumption (Sec. 1.3). While $M$ is processing the history of actions and observations to predict future inputs and rewards, the internal states of $M$ are used as inputs to a temporal difference-based predictor of cumulative predicted reward, to be maximized through appropriate action sequences. One of our systems described in 1991 [227] actually collapsed the cumulative reward predictor into the predictive world model, $M$.</p>
<h1>1.4 Hierarchical \&amp; Multitask RL and Algorithmic Transfer Learning</h1>
<p>Work on NN-based Hierarchical RL (HRL) without predictive world models has been published since the early 1990s. In particular, gradient-based subgoal discovery with RNNs decomposes RL tasks into subtasks for submodules [225]. Numerous alternative HRL techniques have been proposed [204, 206, 117, 279, 295, 171, 195, 50, 162, 51, 15, 215, 11, 260]. While HRL frameworks such as Feudal $R L[48]$ and options $[275,16,261]$ do not directly address the problem of automatic subgoal discovery, HQ-Learning [309] automatically decomposes problems in partially observable environments into sequences of simpler subtasks that can be solved by memoryless policies learnable by reactive subagents. Related methods include incremental NN evolution [70], hierarchical evolution of NNs [306, 285], and hierarchical Policy Gradient algorithms [63]. Recent HRL organizes potentially deep NNbased RL sub-modules into self-organizing, 2-dimensional motor control maps [203] inspired by neurophysiological findings [81]. The methods above, however, assign credit in hierarchical fashion by limited fixed schemes that are not themselves improved or adapted in problem-specific ways. The next sections will describe novel $C M$ systems that overcome such drawbacks of above-mentioned methods.</p>
<p>General methods for incremental multitask RL and algorithmic transfer learning that are not NN-specific include the evolutionary ADATE system [182], the Success-Story Algorithm for SelfModifying Policies running on general-purpose computers [233, 252, 251], and the Optimal Ordered Problem Solver [238], which learns algorithmic solutions to new problems by inspecting and exploiting (in arbitrary computable fashion) solutions to old problems, in a way that is asymptotically time-optimal. And POWERPLAY [243, 267] incrementally learns to become a more and more general algorithmic problem solver, by continually searching the space of possible pairs of new tasks and modifications of the current solver, until it finds a more powerful solver that, unlike the unmodified solver, solves all previously learned tasks plus the new one, or at least simplifies/compresses/speeds up previous solutions, without forgetting any.</p>
<h2>2 Algorithmic Information Theory (AIT) for RNN-based AIs</h2>
<p>Our early RNN-based $C M$ systems (1990) mentioned in Sec. 1.3.1 learn a predictive model of their initially unknown environment. Real brains seem to do so too, but are still far superior to present artificial systems in many ways. They seem to exploit the model in smarter ways, e.g., to plan action sequences in hierarchical fashion, or through other types of abstract reasoning, continually building on earlier acquired skills, becoming increasingly general problem solvers able to deal with a large number of diverse and complex tasks. Here we describe RNN-based Artificial Intelligences (RNNAIs) designed to do the same by "learning to think."</p>
<p>While FNNs are traditionally linked [23] to concepts of statistical mechanics and information theory [24, 257, 136], the programs of general computers such as RNNs call for the framework of Algorithmic Information Theory (AIT) [263, 130, 33, 145, 264, 147] (own AIT work: [234, 235, 236, 237, 238]). Given some universal programming language [67, 35, 282, 194] for a universal computer, the algorithmic information content or Kolmogorov complexity of some computable object is the length of the shortest program that computes it. Since any program for one computer can be translated into a functionally equivalent program for a different computer by a compiler program of constant size, the Kolmogorov complexity of most objects hardly depends on the particular computer used. Most computable objects of a given size, however, are hardly compressible, since there are only relatively few programs that are much shorter. Similar observations hold for practical variants</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>of Kolmogorov complexity that explicitly take into account program runtime [146, 6, 291, 147, 235, 237]. Our RNNAIs are inspired by the following argument.</p>
<h1>2.1 Basic AIT Argument</h1>
<p>According to AIT, given some universal computer, $U$, whose programs are encoded as bit strings, the mutual information between two programs $p$ and $q$ is expressed as $K(q \mid p)$, the length of the shortest program $\bar{w}$ that computes $q$, given $p$, ignoring an additive constant of $O(1)$ depending on $U$ (in practical applications the computation will be time-bounded [147]). That is, if $p$ is a solution to problem $P$, and $q$ is a fast (say, linear time) solution to problem $Q$, and if $K(q \mid p)$ is small, and $\bar{w}$ is both fast and much shorter than $q$, then asymptotically optimal universal search [146, 238] for a solution to $Q$, given $p$, will generally find $\bar{w}$ first (to compute $q$ and solve $Q$ ), and thus solve $Q$ much faster than search for $q$ from scratch [238].</p>
<h3>2.2 One RNN-Like System Actively Learns to Exploit Algorithmic Information of Another</h3>
<p>The AIT argument 2.1 above has broad applicability. Let both $C$ and $M$ be RNNs or similar general parallel-sequential computers [229, 47, 175, 232, 231, 103, 80, 303]. M's vector of learnable realvalued parameters $w_{M}$ is trained by any SL or UL or RL algorithm to perform a certain well-defined task in some environment. Then $w_{M}$ is frozen. Now the goal is to train $C$ 's parameters $w_{C}$ by some learning algorithm to perform another well-defined task whose solution may share mutual algorithmic information with the solution to $M$ 's task. To facilitate this, we simply allow $C$ to learn to actively inspect and reuse (in essentially arbitrary computable fashion) the algorithmic information conveyed by $M$ and $w_{M}$.</p>
<p>Let us consider a trial during which $C$ makes an attempt to solve its given task within a series of discrete time steps $t=t_{a}, t_{a}+1, \ldots, t_{b}$. C's learning algorithm may use the experience gathered during the trial to modify $w_{C}$ in order to improve $C$ 's performance in later trials. During the trial, we give $C$ an opportunity to explore and exploit or ignore $M$ by interacting with it. In what follows, $C(t), M(t)$, sense $(t), \operatorname{act}(t), \operatorname{query}(t), \operatorname{answer}(t), w_{M}, w_{C}$ denote vectors of real values; $f_{C}, f_{M}$ denote computable [67, 35, 282, 194] functions.</p>
<p>At any time $t, C(t)$ and $M(t)$ denote $C$ 's and $M$ 's current states, respectively. They may represent current neural activations or fast weights [229, 232, 231] or other dynamic variables that may change during information processing. sense $(t)$ is the current input from the environment (including reward signals if any); a part of $C(t)$ encodes the current output $\operatorname{act}(t)$ to the environment, another a memory of previous events (if any). Parts of $C(t)$ and $M(t)$ intersect in the sense that both $C(t)$ and $M(t)$ also encode $C$ 's current query $(t)$ to $M$, and $M$ 's current answer $(t)$ to $C$ (in response to previous queries), thus representing an interface between $C$ and $M$.
$M\left(t_{a}\right)$ and $C\left(t_{a}\right)$ are initialized by default values. For $t_{a} \leq t&lt;t_{b}$,</p>
<p>$$
C(t+1)=f_{C}\left(w_{C}, C(t), M(t), \operatorname{sense}(t), w_{M}\right)
$$</p>
<p>with learnable parameters $w_{C} ; \operatorname{act}(t)$ is a computable function of $C(t)$ and may influence in $(t+1)$, and $M(t+1)=f_{M}\left(C(t), M(t), w_{M}\right)$ with fixed parameters $w_{M}$. So both $M(t+1)$ and $C(t+1)$ are computable functions of previous events including queries and answers transmitted through the learnable $f_{C}$.</p>
<p>According to the AIT argument, provided that $M$ conveys substantial algorithmic information about $C$ 's task, and the trainable interface $f_{C}$ between $C$ and $M$ allows $C$ to address and extract and exploit this information quickly, and $w_{C}$ is small compared to the fixed $w_{M}$, the search space of $C$ 's</p>
<p>learning algorithm (trying to find a good $w_{C}$ through a series of trials) should be much smaller than the one of a similar competing system $C^{\prime}$ that has no opportunity to query $M$ but has to learn the task from scratch.</p>
<p>For example, suppose that $M$ has learned to represent (e.g., through predictive coding [228, 248]) videos of people placing toys in boxes, or to summarize such videos through textual outputs. Now suppose $C$ 's task is to learn to control a robot that places toys in boxes. Although the robot's actuators may be quite different from human arms and hands, and although videos and video-describing texts are quite different from desirable trajectories of robot movements, $M$ is expected to convey algorithmic information about $C$ 's task, perhaps in form of connected high-level spatio-temporal feature detectors representing typical movements of hands and elbows independent of arm size. Learning a $w_{C}$ that addresses and extracts this information from $M$ and partially reuses it to solve the robot's task may be much faster than learning to solve the task from scratch without access to $M$.</p>
<p>The setups of Sec. 5.3 are special cases of the general scheme in the present Sec. 2.2.</p>
<h1>2.3 Consequences of the AIT Argument for Model-Building Controllers</h1>
<p>The simple AIT insight above suggests that in many partially observable environments it should be possible to greatly speed up the program search of an RL RNN, $C$, by letting it learn to access, query, and exploit in arbitrary computable ways the program of a typically much bigger gradient-based UL RNN, $M$, used to model and compress the RL agent's entire growing interaction history of all failed and successful trials.</p>
<p>Note that the $\bar{w}$ of Sec. 2.1 may implement all kinds of well-known, computable types of reasoning, e.g., by hierarchical reuse of subprograms of $p$ [238], by analogy, etc. That is, we may perhaps even expect $C$ to learn to exploit $M$ for human-like abstract thought.</p>
<p>Such novel $C M$ systems will be a central topic of Sec. 5. Sec. 6 will also discuss exploration based on efficiently improving $M$ through $C$-generated experiments.</p>
<h2>3 The RNNAI and its Holy Data</h2>
<p>In what follows, let $m, n, o$ denote positive integer constants, and $i, k, h, t, \tau$ positive integer variables assuming ranges implicit in the given contexts. The $i$-th component of any real-valued vector, $v$, is denoted by $v_{i}$. Let the RNNAI's life span a discrete sequence of time steps, $t=1,2, \ldots, t_{\text {death }}$.</p>
<p>At the beginning of a given time step, $t$, there is a "normal" sensory input vector, $i n(t) \in \mathbb{R}^{m}$, and a reward input vector, $r(t) \in \mathbb{R}^{n}$. For example, parts of $i n(t)$ may represent the pixel intensities of an incoming video frame, while components of $r(t)$ may reflect external positive rewards, or negative values produced by pain sensors whenever they measure excessive temperature or pressure. Let $\operatorname{sense}(t) \in \mathbb{R}^{m+n}$ denote the concatenation of the vectors $i n(t)$ and $r(t)$. The total reward at time $t$ is $R(t)=\sum_{i=1}^{n} r_{i}(t)$. The total cumulative reward up to time $t$ is $C R(t)=\sum_{\tau=1}^{t} R(\tau)$. During time step $t$, the RNNAI produces an output action vector, $\operatorname{out}(t) \in \mathbb{R}^{o}$, which may influence the environment and thus future $\operatorname{sense}(\tau)$ for $\tau&gt;t$. At any given time, the RNNAI's goal is to maximize $C R\left(t_{\text {death }}\right)$.</p>
<p>Let $\operatorname{all}(t) \in \mathbb{R}^{m+n+o}$ denote the concatenation of $\operatorname{sense}(t)$ and $\operatorname{out}(t)$. Let $H(t)$ denote the sequence $(\operatorname{all}(1), \operatorname{all}(2), \ldots, \operatorname{all}(t))$ up to time $t$.</p>
<p>To be able to retrain its components on all observations ever made, the RNNAI stores its entire, growing, lifelong sensory-motor interaction history $H(\cdot)$ including all inputs and actions and reward signals observed during all successful and failed trials [239, 240], including what initially looks like noise but later may turn out to be regular. This is normally not done, but is feasible today.</p>
<p>That is, all data is "holy", and never discarded, in line with what mathematically optimal general problem solvers should do [109, 237]. Remarkably, even human brains may have enough storage capacity to store 100 years of sensory input at a reasonable resolution [240].</p>
<h1>3.1 Standard Activation Spreading in Typical RNNs</h1>
<p>Many RNN-like models can be used to build general computers, e.g., neural pushdown automata [47, 175], NNs with quickly modifiable, differentiable external memory based on fast weights [229], or closely related RNN-based meta-learners [232, 231, 103, 219]. Using sloppy but convenient terminology, we refer to all of them as RNNs. A typical implementation of $M$ uses an LSTM network (see Sec. 1.2). If there are large 2-dimensional inputs such as video images, then they can be first filtered through a CNN (compare Sec. 1.2 and 4.3) before fed into the LSTM. Such a CNN-LSTM combination is still an RNN.</p>
<p>Here we briefly summarize information processing in standard RNNs. Using notation similar to the one of a previous survey [245, Sec. 2], let $i, k, s$ denote positive integer variables assuming ranges implicit in the given contexts. Let $n_{u}, n_{w}, T$ also denote positive integers.</p>
<p>At any given moment, an RNN (such as the $M$ of Sec. 4) can be described as a connected graph with $n_{u}$ units (or nodes or neurons) in a set $N=\left{u_{1}, u_{2}, \ldots, u_{n_{u}}\right}$ and a set $H \subseteq N \times N$ of directed edges or connections between nodes. The input layer is the set of input units, a subset of $N$. In fully connected RNNs, all units have connections to all non-input units.</p>
<p>The RNN's behavior or program is determined by $n_{w}$ real-valued, possibly modifiable, parameters or weights, $w_{i}\left(i=1, \ldots, n_{w}\right)$. During an episode of information processing (e.g., during a trial of Sec. 3.2), there is a partially causal sequence $x_{s}(s=1, \ldots, T)$ of real values called events. Here the index $s$ is used in a way that is much more fine-grained than the one of the index $t$ in Sec. 3, 4, 5: a single time step may involve numerous events. Each $x_{s}$ is either an input set by the environment, or the activation of a unit that may directly depend on other $x_{k}(k<s)$ through a current NN topology-dependent set, $i n_{s}$, of indices $k$ representing incoming causal connections or links. Let the function $v$ encode topology information, and map such event index pairs, $(k, s)$, to weight indices. For example, in the non-input case we may have $x_{s}=f_{s}\left(n e t_{s}\right)$ with real-valued $n e t_{s}=\sum_{k \in i n_{s}} x_{k} w_{v(k, s)}$ (additive case) or $n e t_{s}=\prod_{k \in i n_{s}} x_{k} w_{v(k, s)}$ (multiplicative case), where $f_{s}$ is a typically nonlinear real-valued activation function such as tanh. Other net functions combine additions and multiplications [113, 112]; many other activation functions are possible. The sequence, $x_{s}$, may directly affect certain $x_{k}(k>s)$ through outgoing connections or links represented through a current set, out $<em k="k">{s}$, of indices $k$ with $s \in i n</em>$. Some of the non-input events are called output events.</p>
<p>Many of the $x_{s}$ may refer to different, time-varying activations of the same unit, e.g., in RNNs. During the episode, the same weight may get reused over and over again in topology-dependent ways. Such weight sharing across space and/or time may greatly reduce the NN's descriptive complexity, which is the number of bits of information required to describe the NN (Sec. 4). Training algorithms for the RNNs of our RNNAIs will be discussed later.</p>
<h3>3.2 Alternating Training Phases for Controller $C$ and World Model $M$</h3>
<p>Several novel implementations of $C$ are described in Sec. 5. All of them make use of a variable size RNN called the world model, $M$, which learns to compactly encode the growing history, for example, through predictive coding, trying to predict (the expected value of) each input component, given the history of actions and observations. $M$ 's goal is to discover algorithmic regularities in the data so far by learning a program that compresses the data better in a lossless manner. Example details will be specified in Sec. 4.</p>
<div class="codehilite"><pre><span></span><code><span class="n">Algorithm</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">Train</span><span class="w"> </span>\<span class="p">(</span><span class="n">C</span>\<span class="p">)</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span>\<span class="p">(</span><span class="n">M</span>\<span class="p">)</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">Alternating</span><span class="w"> </span><span class="n">Fashion</span>
<span class="w">    </span><span class="mf">1.</span><span class="w"> </span><span class="n">Initialize</span><span class="w"> </span>\<span class="p">(</span><span class="n">C</span>\<span class="p">)</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span>\<span class="p">(</span><span class="n">M</span>\<span class="p">)</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">their</span><span class="w"> </span><span class="n">weights</span><span class="o">.</span>
<span class="w">    </span><span class="mf">2.</span><span class="w"> </span><span class="n">Freeze</span><span class="w"> </span>\<span class="p">(</span><span class="n">M</span>\<span class="p">)</span><span class="w"> </span><span class="s1">&#39;s weights such that they cannot change while \(C\) learns.</span>
<span class="w">    </span><span class="mf">3.</span><span class="w"> </span><span class="n">Execute</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">trial</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">generating</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">finite</span><span class="w"> </span><span class="n">action</span><span class="w"> </span><span class="n">sequence</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">prolongs</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">history</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">actions</span>
<span class="w">    </span><span class="ow">and</span><span class="w"> </span><span class="n">observations</span><span class="o">.</span><span class="w"> </span><span class="n">Actions</span><span class="w"> </span><span class="n">may</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">due</span><span class="w"> </span><span class="n">to</span><span class="w"> </span>\<span class="p">(</span><span class="n">C</span>\<span class="p">)</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="n">may</span><span class="w"> </span><span class="n">exploit</span><span class="w"> </span>\<span class="p">(</span><span class="n">M</span>\<span class="p">)</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">various</span><span class="w"> </span><span class="n">ways</span><span class="w"> </span><span class="p">(</span><span class="n">see</span><span class="w"> </span><span class="n">Sec</span><span class="o">.</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="o">.</span>
<span class="w">    </span><span class="n">Train</span><span class="w"> </span>\<span class="p">(</span><span class="n">C</span>\<span class="p">)</span><span class="w"> </span><span class="s1">&#39;s weights on the prolonged (and recorded) history to generate action sequences with higher</span>
<span class="w">    </span><span class="n">expected</span><span class="w"> </span><span class="n">reward</span><span class="p">,</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">methods</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">Sec</span><span class="o">.</span><span class="w"> </span><span class="mf">5.</span>
<span class="w">    </span><span class="mf">4.</span><span class="w"> </span><span class="n">Unfreeze</span><span class="w"> </span>\<span class="p">(</span><span class="n">M</span>\<span class="p">)</span><span class="w"> </span><span class="s1">&#39;s weights, and re-train \(M\) in a &quot;sleep phase&quot; to better predict/compress the pro-</span>
<span class="w">    </span><span class="n">longed</span><span class="w"> </span><span class="n">history</span><span class="p">;</span><span class="w"> </span><span class="n">see</span><span class="w"> </span><span class="n">Sec</span><span class="o">.</span><span class="w"> </span><span class="mf">4.</span>
<span class="w">    </span><span class="mf">5.</span><span class="w"> </span><span class="n">If</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">stopping</span><span class="w"> </span><span class="n">criterion</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">met</span><span class="p">,</span><span class="w"> </span><span class="n">goto</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">.</span>
</code></pre></div>

<p>Both $C$ and $M$ have real-valued parameters or weights that can be modified to improve performance. To avoid instabilities, $C$ and $M$ are trained in alternating fashion, as in Algorithm 1.</p>
<h1>4 The Gradient-Based World Model $M$</h1>
<p>A central objective of unsupervised learning is to compress the observed data [14, 228]. $M$ 's goal is to compress the RL agent's entire growing interaction history of all failed and successful trials [239, 241], e.g., through predictive coding [228, 248]. $M$ has $m+n+o$ input units to receive all $(t)$ at time $t&lt;t_{\text {death }}$, and $m+n$ output units to produce a prediction $\operatorname{pred}(t+1) \in \mathbb{R}^{m+n}$ of $\operatorname{sense}(t+1)$ [223, 226, 222, 227].</p>
<h2>4.1 $M$ 's Compression Performance on the History so far</h2>
<p>Let us address details of training $M$ in a "sleep phase" of step 4 in algorithm 1. (The training of $C$ will be discussed in Sec. 5.) Consider some $M$ with given (typically suboptimal) weights and a default initialization of all unit activations. One example way of making $M$ compress the history (but not the only one) is the following. Given $H(t)$, we can train $M$ by replaying [149] $H(t)$ in semi-offline training, sequentially feeding all $(1), \operatorname{all}(2), \ldots$ all $(t)$ into $M$ 's input units in standard RNN fashion (Sec. 1.2, 3.1). Given $H(\tau)(\tau&lt;t), M$ calculates $\operatorname{pred}(\tau+1)$, a prediction of $\operatorname{sense}(\tau+1)$. A standard error function to be minimized by gradient descent in $M$ 's weights (Sec. 1.2) would be $E(t)=\sum_{\tau=1}^{t-1}|\operatorname{pred}(\tau+1)-\operatorname{sense}(\tau+1)|^{2}$, the sum of the deviations of the predictions from the observations so far.</p>
<p>However, $M$ 's goal is not only to minimize the total prediction error, $E$. Instead, to avoid the erroneous "discovery" of "regular patterns" in irregular noise, we use AIT's sound way of dealing with overfitting [263, 130, 289, 207, 147, 84], and measure $M$ 's compression performance by the number of bits required to specify $M$, plus the bits needed to encode the observed deviations from $M$ 's predictions [239, 241]. For example, whenever $M$ incorrectly predicts certain input pixels of a perceived video frame, those pixel values will have to be encoded separately, which will cost storage space. (In typical applications, $M$ can only execute a fixed number of elementary computations per time step to compress and decompress data, which usually has to be done online. That is, in general $M$ will not reflect the data's true Kolmogorov complexity [263, 130], but at best a time-bounded variant thereof [147].)</p>
<p>Let integer variables, bits $<em H="H">{M}$ and bits $</em>$, denote estimates of the number of bits required to encode (by a fixed algorithmic scheme) the current $M$, and the deviations of $M$ 's predictions from the observations on the current history, respectively. For example, to obtain bits $<em e="e">{H}$, we may naively assume some simple, bell-shaped, zero-centered probability distribution $P</em>$ on the finite number of possible</p>
<p>real-valued prediction errors $e_{i, \tau}=\left(\operatorname{pred}<em i="i">{i}(\tau)-\operatorname{sense}</em>\right)$ bits [108, 257]. That is, large errors are considered unlikely and cost more bits than small ones. To obtain bits $}(\tau)\right)^{2}$ (in practical applications the errors will be given with limited precision), and encode each $e_{i, \tau}$ by $-\log P_{e}\left(e_{i, \tau<em w="w">{M}$, we may naively multiply the current number of $M$ 's non-zero modifiable weights by a small integer constant reflecting the weight precision. Alternatively, we may assume some simple, bell-shaped, zero-centered probability distribution, $P</em>\right)$ bits. That is, large absolute weight values are considered unlikely and cost more bits than small ones [91, 294, 135, 97]. Both alternatives ignore the possibility that $M$ 's entire weight matrix might be computable by a short computer program [235, 132], but have the advantage of being easy to calculate. Moreover, since $M$ is a general computer itself, at least in principle it has a chance of learning equivalents of such short programs.}$, on the finite number of possible weight values (given with limited precision), and encode each $w_{i}$ by $-\log P_{w}\left(w_{i</p>
<h1>4.2 $M$ 's Training</h1>
<p>To decrease bits $<em H="H">{M}+$ bits $</em>$, we add a regularizing term to $E$, to punish excessive complexity [4, 5, $91,294,155,135,97,170,169,104,290,7,290,87,286,319,100,102]$.</p>
<p>Step 1 of algorithm 1 starts with a small $M$. As the history grows, to find an $M$ with small bits $<em H="H">{M}+$ bits $</em>$, step 4 uses sequential network construction: it regularly changes $M$ 's size by adding or pruning units and connections $[111,112,8,168,59,107,304,176,141,92,143,204,53,296$, $106,31,57,185,283]$. Whenever this helps (after additional training with BPTT of $M$-see Sec. 1.2) to improve bits $<em H="H">{M}+$ bits $</em>$ on the history so far, the changes are kept, otherwise they are discarded. (Note that even animal brains grow and prune neurons.)</p>
<p>Given history $H(t)$, instead of re-training $M$ in a sleep phase (step 4 of algorithm 1) on all of $H(t)$, we may re-train it on parts thereof, by selecting trials randomly or otherwise from $H(t)$, and replay them to retrain $M$ in standard fashion (Sec. 1.2). To do this, however, all of $M$ 's unit activations need to be stored at the beginning of each trial. ( $M$ 's hidden unit activations, however, do not have to be stored if they are reset to zero at the beginning of each trial.)</p>
<h2>$4.3 M$ may have a Built-In FNN Preprocessor</h2>
<p>To facilitate $M$ 's task in certain environments, each frame of the sensory input stream (video, etc.) can first be separately compressed through autoencoders [211] or autoencoder hierarchies [13, 21] based on CNNs or other FNNs (see Sec. 1.2) [42] used as sensory preprocessors to create less redundant sensory codes [118, 138, 142, 46]. The compressed codes are then fed into an RNN trained to predict not the raw inputs, but their compressed codes. Those predictions have to be decompressed again by the FNN, to evaluate the total compression performance, bits $<em H="H">{M}+$ bits $</em>$, of the FNN-RNN combination representing $M$.</p>
<h2>5 The Controller $\boldsymbol{C}$ Learning to Exploit RNN World Model $\boldsymbol{M}$</h2>
<p>Here we describe ways of using the world model, $M$, of Sec. 4 to facilitate the task of the RL controller, $C$. Especially the systems of Sec. 5.3 overcome drawbacks of early $C M$ systems mentioned in Sec. 1.3.1, 1.3.2. Some of the setups of the present Sec. 5 can be viewed as special cases of the general scheme in Sec. 2.2.</p>
<h1>5.1 $C$ as a Standard RL Machine whose States are $M$ 's Activations</h1>
<p>We start with details of an approach whose principles date back to the early 1990s [227, 150] (Sec. 1.3.2). Given an RNN or RNN-like $M$ as in Sec. 4, we implement $C$ as a traditional RL machine [272][245, Sec. 6.2] based on the Markov assumption (Sec. 1.3). While $M$ is processing the history of actions and observations to predict future inputs, the internal states of $M$ are used as inputs to a predictor of cumulative expected future reward.</p>
<p>More specifically, in step 3 of algorithm 1 , consider a trial lasting from time $t_{a} \geq 1$ to $t_{b} \leq t_{\text {death }}$. $M$ is used as a preprocessor for $C$ as follows. At the beginning of a given time step, $t$, of the trial $\left(t_{a} \leq\right.$ $t&lt;t_{b}$ ), let hidden $(t) \in \mathbb{R}^{h}$ denote the vector of $M$ 's current hidden unit activations (those units that are neither input nor output units). Let state $(t) \in \mathbb{R}^{2 m+2 n+h}$ denote the concatenation of sense $(t)$, hidden $(t)$ and $\operatorname{pred}(t)$. (In cases where $M$ 's activations are reset after each trial, hidden $\left(t_{a}\right)$ and $\operatorname{pred}\left(t_{a}\right)$ are initialized by default values, e.g., zero vectors.)
$C$ is an RL machine with $2 m+2 n+h$-dimensional inputs and $o$-dimensional outputs. At time $t$, state $(t)$ is fed into $C$, which then computes action out $(t)$. Then $M$ computes from sense $(t)$, hidden $(t)$ and out $(t)$ the values hidden $(t+1)$ and $\operatorname{pred}(t+1)$. Then out $(t)$ is executed in the environment, to obtain the next input sense $(t+1)$.</p>
<p>The parameters or weights of $C$ are trained to maximize reward by a standard RL method such as Q-learning or similar methods $[17,292,293,172,254,212,262,10,122,188,157,281,26,216$, 197, 272, 311, 9, 163, 174, 22, 27, 2, 137, 276, 156, 284]. Note that most of these methods evaluate not only input events but pairs of input and output (action) events.</p>
<p>In one of the simplest cases, $C$ is just a linear perceptron FNN (instead of an RNN like in the early system [227]). The fact that $C$ has no built-in memory in this case is not a fundamental restriction since $M$ is recurrent, and has been trained to predict not only normal sensory inputs, but also reward signals. That is, the state of $M$ must contain all the historic information relevant to maximize future expected reward, provided the data history so far already contains the relevant experience, and $M$ has learned to compactly extract and represent its regular aspects.</p>
<p>This approach is different from other, previous combinations of traditional RL [272][245, Sec. 6.2] and RNNs [227, 148, 12] which use RNNs only as value function approximators that directly predict cumulative expected reward, instead of trying to predict all sensations time step by time step. The $C M$ system in the present section separates the hard task of prediction in partially observable environments from the comparatively simple task of RL under the Markovian assumption that the current input to $C$ (which is $M$ 's state) contains all information relevant for achieving the goal.</p>
<h2>$5.2 C$ as an Evolutionary RL (R)NN whose Inputs are $M$ 's Activations</h2>
<p>This approach is essentially the same as the one of Sec. 5.1, except that $C$ is now an FNN or RNN trained by evolutionary algorithms [200, 255, 105, 56, 68] applied to NNs [165, 321, 180, 259, 72, $90,89,110,94]$, or by policy gradient methods [314, 315, 316, 274, 18, 1, 63, 128, 313, 210, 192, 191, 256, 85, 312, 190, 82, 93][245, Sec. 6.6], or by Compressed NN Search; see Sec. 1. $C$ has $2 m+2 n+h$ input units and $o$ output units. At time $t$, state $(t)$ is fed into $C$, which computes out $(t)$; then $M$ computes hidden $(t+1)$ and $\operatorname{pred}(t+1)$; then out $(t)$ is executed to obtain sense $(t+1)$.</p>
<h2>$5.3 C$ Learns to Think with $M$ : High-Level Plans and Abstractions</h2>
<p>Our RNN-based $C M$ systems of the early 1990s <a href="Sec. 1.3.1">223, 226</a> could in principle plan ahead by performing numerous fast mental experiments on a predictive RNN world model, $M$, instead of time-consuming real experiments, extending earlier work on reactive systems without memory [301, 273]. However, this can work well only in (near-)deterministic environments, and, even there, $M$</p>
<p>would have to simulate many entire alternative futures, time step by time step, to find an action sequence for $C$ that maximizes reward. This method seems very different from the much smarter hierarchical planning methods of humans, who apparently can learn to identify and exploit a few relevant problem-specific abstractions of possible future events; reasoning abstractly, and efficiently ignoring irrelevant spatio-temporal details.</p>
<p>We now describe a $C M$ system that can in principle learn to plan and reason like this as well, according to the AIT argument (Sec. 2.1). This should be viewed as a main contribution of the present paper. See Figure 1.</p>
<p>Consider an RNN $C$ (with typically rather small feasible search space) as in Sec. 5.2. We add standard and/or multiplicative learnable connections (Sec. 3.1) from some of the units of $C$ to some of the units of the typically huge unsupervised $M$, and from some of the units of $M$ to some of the units of $C$. The new connections are said to belong to $C . C$ and $M$ now collectively form a new RNN called $C M$, with standard activation spreading as in Sec. 3.1. The activations of $M$ are initialized to default values at the beginning of each trial. Now $C M$ is trained on RL tasks in line with step 3 of algorithm 1, using search methods such as those of Sec. 5.2 (compare Sec. 1). The (typically many) connections of $M$, however, do not change-only the (typically relatively few) connections of $C$ do.</p>
<p>What does that mean? It means that now $C$ 's relatively small candidate programs are given time to "think" by feeding sequences of activations into $M$, and reading activations out of $M$, before and while interacting with the environment. Since $C$ and $M$ are general computers, $C$ 's programs may query, edit or invoke subprograms of $M$ in arbitrary, computable ways through the new connections. Given some RL problem, according to the AIT argument (Sec. 2.1), this can greatly accelerate $C$ 's search for a problem-solving weight vector $\hat{w}$, provided the (time-bounded [147]) mutual algorithmic information between $\hat{w}$ and $M$ 's program is high, as is to be expected in many cases since $M$ 's environment-modeling program should reflect many regularities useful not only for prediction and coding, but also for decision making. ${ }^{3}$</p>
<p>This simple but novel approach is much more general than previous computable, but restricted, ways of letting a feedforward $C$ use a model $M$ (Sec. 1.3.1)[301, 273][245, Sec. 6.1], by simulating entire possible futures step by step, then propagating error signals or temporal difference errors backwards (see Section 1.3.1). Instead, we give $C$ 's program search an opportunity to discover sophisticated computable ways of exploiting $M$ 's code, such as abstract hierarchical planning and analogybased reasoning. For example, to represent previous observations, an $M$ implemented as an LSTM network (Sec. 1.2) will develop high-level, abstract, spatio-temporal feature detectors that may be active for thousands of time steps, as long as those memories are useful to predict (and thus compress) future observations [62, 61, 189, 79]. However, $C$ may learn to directly invoke the corresponding "abstract" units in $M$ by inserting appropriate pattern sequences into $M . C$ might then short-cut from there to typical subsequent abstract representations, ignoring the long input sequences normally required to invoke them in $M$, thus quickly anticipating a few possible positive outcomes to be pursued (plus computable ways of achieving them), or negative outcomes to be avoided.</p>
<p>Note that $M$ (and by extension $M$ ) does not at all have to be a perfect predictor. For example, it won't be able to predict noise. Instead $M$ will have learned to approximate conditional expectations of future inputs, given the history so far. A naive way of exploiting $M$ 's probabilistic knowledge would be to plan ahead through naive step-by-step Monte-Carlo simulations of possible $M$-predicted futures, to find and execute action sequences that maximize expected reward predicted by those simulations. However, we won't limit the system to this naive approach. Instead it will be the task of $C$ to learn to address useful problem-specific parts of the current $M$, and reuse them for problem solving. Sure,</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>$C$ will have to intelligently exploit $M$, which will cost bits of information (and thus search time for appropriate weight changes of $C$ ), but this is often still much cheaper in the AIT sense than learning a good $C$ program from scratch, as in our previous non-RNN AIT-based work on algorithmic transfer learning [238], where self-invented recursive code for previous solutions sped up the search for code for more complex tasks by a factor of 1000 .</p>
<p>Numerous topologies are possible for the adaptive connections from $C$ to $M$, and back. Although in some applications $C$ may find it hard to exploit $M$, and might prefer to ignore $M$ (by setting connections to and from $M$ to zero), in some environments under certain $C M$ topologies, $C$ can greatly profit from $M$.</p>
<p>While $M$ 's weights are frozen in step 3 of algorithm 1 , the weights of $C$ can learn when to make $C$ attend to history information represented by $M$ 's state, and when to ignore such information, and instead use $M$ 's innards in other computable ways. This can be further facilitated by introducing a special unit, $\hat{u}$, to $C$, where $\hat{u}(t) a l l(t)$ instead of $a l l(t)$ is fed into $M$ at time $t$, such that $C$ can easily (by setting $\hat{u}(t)=0$ ) force $M$ to completely ignore environmental inputs, to use $M$ for "thinking" in other ways.</p>
<p>Should $M$ later grow (or shrink) in step 4 of algorithm 1, in line with Sec. 4.2, $C$ may in turn grow additional connections to and from $M$ (or lose some) in the next incarnation of step 3.</p>
<h1>5.4 Incremental / Hierarchical / Multitask Learning of $C$ with $M$</h1>
<p>A variant of the approach in Sec. 5.3 incrementally trains $C$ on a never-ending series of tasks, continually building on solutions to previous problems, instead of learning each new problem from scratch. In principle, this can be done through incremental NN evolution [70], hierarchical NN evolution [306, 285], hierarchical Policy Gradient algorithms [63], or asymptotically optimal ways of algorithmic transfer learning [238].</p>
<p>Given a new task and a $C$ trained on several previous tasks, such hierarchical/incremental methods may freeze the current weights of $C$, then enlarge $C$ by adding new units and connections which are trained on the new task. This process reduces the size of the search space for the new task, giving the new weights the opportunity to learn to use the frozen parts of $C$ as subprograms.</p>
<p>Incremental variants of Compressed RNN Search [132] (Sec. 1) do not directly search in C's potentially large weight space, but in the frequency domain by representing the weight matrix as a small set of Fourier-type coefficients. By searching for new coefficients to be added to already learned set responsible for solving previous problems, $C$ 's weight matrix is fine tuned incrementally and indirectly (through superpositions). Given a current problem, in AIT-based OOPS style [238], we may impose growing run time limits on programs tested on $C$, until a solution is found.</p>
<h2>6 Exploration: Rewarding $C$ for Experiments that Improve $M$</h2>
<p>Humans, even as infants, invent their own tasks in a curious and creative fashion, continually increasing their problem solving repertoire even without an external reward or teacher. They seem to get intrinsic reward for creating experiments leading to observations that obey a previously unknown law that allows for better compression of the observations-corresponding to the discovery of a temporarily interesting, subjectively novel regularity [224, 239, 241] (compare also [261, 184]).</p>
<p>For example, a video of 100 falling apples can be greatly compressed via predictive coding once the law of gravity is discovered. Likewise, the video-like image sequence perceived while moving through an office can be greatly compressed by constructing an internal 3D model of the office space [243]. The 3D model allows for re-computing the entire high-resolution video from a compact</p>
<p>sequence of very low-dimensional eye coordinates and eye directions. The model itself can be specified by far fewer bits of information than needed to store the raw pixel data of a long video. Even if the 3D model is not precise, only relatively few extra bits will be required to encode the observed deviations from the predictions of the model.</p>
<p>Even mirror neurons [129] are easily explained as by-products of history compression as in Sec. 3 and 4. They fire both when an animal acts and when the animal observes the same action performed by another. Due to mutual algorithmic information shared by perceptions of similar actions performed by various animals, efficient RNN-based predictive coding (Sec. 3, 4) profits from using the same feature detectors (neurons) to encode the shared information, thus saving storage space.</p>
<p>Given the $C-M$ combinations of Sec. 5, we motivate $C$ to become an efficient explorer and an artificial scientist, by adding to its standard external reward (or fitness) for solving user-given tasks another intrinsic reward for generating novel action sequences ( $=$ experiments) that allow $M$ to improve its compression performance on the resulting data [239, 241].</p>
<p>At first glance, repeatedly evaluating $M$ 's compression performance on the entire history seems impractical. A heuristic to overcome this is to focus on $M$ 's improvements on the most recent trial, while regularly re-training $M$ on randomly selected previous trials, to avoid catastrophic forgetting.</p>
<p>A related problem is that $C$ 's incremental program search may find it difficult to identify (and assign credit to) those parts of $C$ responsible for improvements of a huge, black box-like, monolithic $M$. But we can implement $M$ as a self-modularizing, computation cost-minimizing, winner-take-all RNN [221, 242, 267]. Then it is possible to keep track of which parts of $M$ are used to encode which parts of the history. That is, to evaluate weight changes of $M$, only the affected parts of the stored history have to be re-tested [243]. Then $C$ 's search can be facilitated by tracking which parts of $C$ affected those parts of $M$. By penalizing $C$ 's programs for the time consumed by such tests, the search for $C$ is biased to prefer programs that conduct experiments causing data yielding quickly verifiable compression progress of $M$. That is, the program search will prefer to change weights of $M$ that are not used to compress large parts of the history that are expensive to verify [242, 243]. The first implementations of this simple principle were described in our work on the PowerPlay framework [243, 267], which incrementally searches the space of possible pairs of new tasks and modifications of the current program, until it finds a more powerful program that, unlike the unmodified program, solves all previously learned tasks plus the new one, or simplifies/compresses/speeds up previous solutions, without forgetting any. Under certain conditions this can accelerate the acquisition of external reward specified by user-defined tasks.</p>
<h1>7 Conclusion</h1>
<p>We introduced novel combinations of a reinforcement learning (RL) controller, $C$, and an RNN-based predictive world model, $M$. The most general $C M$ systems implement principles of algorithmic [263, 130, 147] as opposed to traditional [24, 257] information theory. Here both $M$ and $C$ are RNNs or RNN-like systems. $M$ is actively exploited in arbitrary computable ways by $C$, whose program search space is typically much smaller, and which may learn to selectively probe and reuse $M$ 's internal programs to plan and reason. The basic principles are not limited to RL, but apply to all kinds of active algorithmic transfer learning from one RNN to another. By combining gradient-based RNNs and RL RNNs, we create a qualitatively new type of self-improving, general purpose, connectionist control architecture. This RNNAI may continually build upon previously acquired problem solving procedures, some of them self-invented in a way that resembles a scientist's search for novel data with unknown regularities, preferring still-unsolved but quickly learnable tasks over others.</p>
<h1>References</h1>
<p>[1] D. Aberdeen. Policy-Gradient Algorithms for Partially Observable Markov Decision Processes. PhD thesis, Australian National University, 2003.
[2] J. Abounadi, D. Bertsekas, and V. S. Borkar. Learning algorithms for Markov decision processes with average cost. SIAM Journal on Control and Optimization, 40(3):681-698, 2002.
[3] I. Aizenberg, N. N. Aizenberg, and J. Vandewalle. Multi-Valued and Universal Binary Neurons: Theory, Learning and Applications. Springer Science \&amp; Business Media, 2000.
[4] H. Akaike. Statistical predictor identification. Ann. Inst. Statist. Math., 22:203-217, 1970.
[5] H. Akaike. A new look at the statistical model identification. IEEE Transactions on Automatic Control, 19(6):716-723, 1974.
[6] A. Allender. Application of time-bounded Kolmogorov complexity in complexity theory. In O. Watanabe, editor, Kolmogorov complexity and computational complexity, pages 6-22. EATCS Monographs on Theoretical Computer Science, Springer, 1992.
[7] S. Amari and N. Murata. Statistical theory of learning curves under entropic loss criterion. Neural Computation, 5(1):140-153, 1993.
[8] T. Ash. Dynamic node creation in backpropagation neural networks. Connection Science, 1(4):365-375, 1989.
[9] L. Baird and A. W. Moore. Gradient descent for general reinforcement learning. In Advances in neural information processing systems 12 (NIPS), pages 968-974. MIT Press, 1999.
[10] L. C. Baird. Residual algorithms: Reinforcement learning with function approximation. In International Conference on Machine Learning, pages 30-37, 1995.
[11] B. Bakker and J. Schmidhuber. Hierarchical reinforcement learning based on subgoal discovery and subpolicy specialization. In F. G. et al., editor, Proc. 8th Conference on Intelligent Autonomous Systems IAS-8, pages 438-445, Amsterdam, NL, 2004. IOS Press.
[12] B. Bakker, V. Zhumatiy, G. Gruener, and J. Schmidhuber. A robot that reinforcement-learns to identify and memorize important previous observations. In Proceedings of the 2003 IEEE/RSJ International Conference on Intelligent Robots and Systems, IROS 2003, pages 430-435, 2003.
[13] D. H. Ballard. Modular learning in neural networks. In Proc. AAAI, pages 279-284, 1987.
[14] H. B. Barlow, T. P. Kaushal, and G. J. Mitchison. Finding minimum entropy codes. Neural Computation, 1(3):412-423, 1989.
[15] A. G. Barto and S. Mahadevan. Recent advances in hierarchical reinforcement learning. Discrete Event Dynamic Systems, 13(4):341-379, 2003.
[16] A. G. Barto, S. Singh, and N. Chentanez. Intrinsically motivated learning of hierarchical collections of skills. In Proceedings of International Conference on Developmental Learning (ICDL), pages 112-119. MIT Press, Cambridge, MA, 2004.
[17] A. G. Barto, R. S. Sutton, and C. W. Anderson. Neuronlike adaptive elements that can solve difficult learning control problems. IEEE Transactions on Systems, Man, and Cybernetics, SMC-13:834-846, 1983.</p>
<p>[18] J. Baxter and P. L. Bartlett. Infinite-horizon policy-gradient estimation. J. Artif. Int. Res., 15(1):319-350, 2001.
[19] S. Behnke. Hierarchical Neural Networks for Image Interpretation, volume LNCS 2766 of Lecture Notes in Computer Science. Springer, 2003.
[20] R. Bellman. Dynamic Programming. Princeton University Press, Princeton, NJ, USA, 1st edition, 1957.
[21] Y. Bengio, A. Courville, and P. Vincent. Representation learning: A review and new perspectives. Pattern Analysis and Machine Intelligence, IEEE Transactions on, 35(8):1798-1828, 2013.
[22] D. P. Bertsekas. Dynamic Programming and Optimal Control. Athena Scientific, 2001.
[23] C. M. Bishop. Pattern Recognition and Machine Learning. Springer, 2006.
[24] L. Boltzmann. In F. Hasenöhrl, editor, Wissenschaftliche Abhandlungen (collection of Boltzmann's articles in scientific journals). Barth, Leipzig, 1909.
[25] C. Boutilier and D. Poole. Computing optimal policies for partially observable Markov decision processes using compact representations. In Proceedings of the AAAI, Portland, OR, 1996.
[26] S. J. Bradtke, A. G. Barto, and L. P. Kaelbling. Linear least-squares algorithms for temporal difference learning. In Machine Learning, pages 22-33, 1996.
[27] R. I. Brafman and M. Tennenholtz. R-MAX—a general polynomial time algorithm for nearoptimal reinforcement learning. Journal of Machine Learning Research, 3:213-231, 2002.
[28] L. Breiman. Bagging predictors. Machine Learning, 24:123-140, 1996.
[29] C. B. Browne, E. Powley, D. Whitehouse, S. M. Lucas, P. I. Cowling, P. Rohlfshagen, S. Tavener, D. Perez, S. Samothrakis, and S. Colton. A survey of monte carlo tree search methods. IEEE Transactions on Computational Intelligence and AI in Games, 4(1):1-43, 2012.
[30] A. E. Bryson. A gradient method for optimizing multi-stage allocation processes. In Proc. Harvard Univ. Symposium on digital computers and their applications, 1961.
[31] N. Burgess. A constructive algorithm that converges for real-valued input patterns. International Journal of Neural Systems, 5(1):59-66, 1994.
[32] R. Caruana. Multitask learning. Machine Learning, 28(1):41-75, 1997.
[33] G. J. Chaitin. On the length of programs for computing finite binary sequences. Journal of the ACM, 13:547-569, 1966.
[34] K. Chellapilla, S. Puri, and P. Simard. High performance convolutional neural networks for document processing. In International Workshop on Frontiers in Handwriting Recognition, 2006.
[35] A. Church. An unsolvable problem of elementary number theory. American Journal of Mathematics, 58:345-363, 1936.
[36] D. C. Ciresan, A. Giusti, L. M. Gambardella, and J. Schmidhuber. Deep neural networks segment neuronal membranes in electron microscopy images. In Advances in Neural Information Processing Systems (NIPS), pages 2852-2860, 2012.</p>
<p>[37] D. C. Ciresan, A. Giusti, L. M. Gambardella, and J. Schmidhuber. Mitosis detection in breast cancer histology images with deep neural networks. In Proc. MICCAI, volume 2, pages 411418, 2013.
[38] D. C. Ciresan, U. Meier, L. M. Gambardella, and J. Schmidhuber. Deep big simple neural nets for handwritten digit recogntion. Neural Computation, 22(12):3207-3220, 2010.
[39] D. C. Ciresan, U. Meier, L. M. Gambardella, and J. Schmidhuber. Convolutional neural network committees for handwritten character classification. In 11th International Conference on Document Analysis and Recognition (ICDAR), pages 1250-1254, 2011.
[40] D. C. Ciresan, U. Meier, J. Masci, L. M. Gambardella, and J. Schmidhuber. Flexible, high performance convolutional neural networks for image classification. In Intl. Joint Conference on Artificial Intelligence IJCAI, pages 1237-1242, 2011.
[41] D. C. Ciresan, U. Meier, J. Masci, and J. Schmidhuber. A committee of neural networks for traffic sign classification. In International Joint Conference on Neural Networks (IJCNN), pages 1918-1921, 2011.
[42] D. C. Ciresan, U. Meier, and J. Schmidhuber. Multi-column deep neural networks for image classification. In IEEE Conference on Computer Vision and Pattern Recognition CVPR 2012, 2012. Long preprint arXiv:1202.2745v1 [cs.CV].
[43] D. C. Ciresan, U. Meier, and J. Schmidhuber. Transfer learning for Latin and Chinese characters with deep neural networks. In International Joint Conference on Neural Networks (IJCNN), pages 1301-1306, 2012.
[44] D. T. Cliff, P. Husbands, and I. Harvey. Evolving recurrent dynamical networks for robot control. In Artificial Neural Nets and Genetic Algorithms, pages 428-435. Springer, 1993.
[45] A. Cochocki and R. Unbehauen. Neural networks for optimization and signal processing. John Wiley \&amp; Sons, Inc., 1993.
[46] G. Cuccu, M. Luciw, J. Schmidhuber, and F. Gomez. Intrinsically motivated evolutionary search for vision-based reinforcement learning. In Proceedings of the 2011 IEEE Conference on Development and Learning and Epigenetic Robotics IEEE-ICDL-EPIROB, volume 2, pages 1-7. IEEE, 2011.
[47] S. Das, C. Giles, and G. Sun. Learning context-free grammars: Capabilities and limitations of a neural network with an external stack memory. In Proceedings of the The Fourteenth Annual Conference of the Cognitive Science Society, Bloomington, 1992.
[48] P. Dayan and G. Hinton. Feudal reinforcement learning. In D. S. Lippman, J. E. Moody, and D. S. Touretzky, editors, Advances in Neural Information Processing Systems (NIPS) 5, pages 271-278. Morgan Kaufmann, 1993.
[49] R. Dechter. Learning while searching in constraint-satisfaction problems. In Proceedings of AAAI-86, 1986.
[50] T. G. Dietterich. Hierarchical reinforcement learning with the MAXQ value function decomposition. J. Artif. Intell. Res. (JAIR), 13:227-303, 2000.
[51] K. Doya, K. Samejima, K. ichi Katagiri, and M. Kawato. Multiple model-based reinforcement learning. Neural Computation, 14(6):1347-1369, 2002.</p>
<p>[52] S. E. Dreyfus. The numerical solution of variational problems. Journal of Mathematical Analysis and Applications, 5(1):30-45, 1962.
[53] S. E. Fahlman. The recurrent cascade-correlation learning algorithm. In R. P. Lippmann, J. E. Moody, and D. S. Touretzky, editors, Advances in Neural Information Processing Systems (NIPS) 3, pages 190-196. Morgan Kaufmann, 1991.
[54] Y. Fan, Y. Qian, F. Xie, and F. K. Soong. TTS synthesis with bidirectional LSTM based recurrent neural networks. In Proc. Interspeech, 2014.
[55] R. Fernandez, A. Rendel, B. Ramabhadran, and R. Hoory. Prosody contour prediction with Long Short-Term Memory, bi-directional, deep recurrent neural networks. In Proc. Interspeech, 2014.
[56] L. Fogel, A. Owens, and M. Walsh. Artificial Intelligence through Simulated Evolution. Wiley, New York, 1966.
[57] B. Fritzke. A growing neural gas network learns topologies. In G. Tesauro, D. S. Touretzky, and T. K. Leen, editors, NIPS, pages 625-632. MIT Press, 1994.
[58] K. Fukushima. Neural network model for a mechanism of pattern recognition unaffected by shift in position - Neocognitron. Trans. IECE, J62-A(10):658-665, 1979.
[59] S. I. Gallant. Connectionist expert systems. Communications of the ACM, 31(2):152-169, 1988.
[60] S. Ge, C. C. Hang, T. H. Lee, and T. Zhang. Stable adaptive neural network control. Springer, 2010.
[61] F. A. Gers, J. Schmidhuber, and F. Cummins. Learning to forget: Continual prediction with LSTM. Neural Computation, 12(10):2451-2471, 2000.
[62] F. A. Gers, N. Schraudolph, and J. Schmidhuber. Learning precise timing with LSTM recurrent networks. Journal of Machine Learning Research, 3:115-143, 2002.
[63] M. Ghavamzadeh and S. Mahadevan. Hierarchical policy gradient algorithms. In Proceedings of the Twentieth Conference on Machine Learning (ICML-2003), pages 226-233, 2003.
[64] R. Girshick, J. Donahue, T. Darrell, and J. Malik. Rich feature hierarchies for accurate object detection and semantic segmentation. Technical Report arxiv.org/abs/1311.2524, UC Berkeley and ICSI, 2013.
[65] L. Gisslen, M. Luciw, V. Graziano, and J. Schmidhuber. Sequential constant size compressor for reinforcement learning. In Proc. Fourth Conference on Artificial General Intelligence (AGI), Google, Mountain View, CA, pages 31-40. Springer, 2011.
[66] T. Glasmachers, T. Schaul, Y. Sun, D. Wierstra, and J. Schmidhuber. Exponential natural evolution strategies. In Proceedings of the Genetic and Evolutionary Computation Conference (GECCO), pages 393-400. ACM, 2010.
[67] K. Gödel. Über formal unentscheidbare Sätze der Principia Mathematica und verwandter Systeme I. Monatshefte für Mathematik und Physik, 38:173-198, 1931.
[68] D. E. Goldberg. Genetic Algorithms in Search, Optimization and Machine Learning. AddisonWesley, Reading, MA, 1989.</p>
<p>[69] F. J. Gomez. Robust Nonlinear Control through Neuroevolution. PhD thesis, Department of Computer Sciences, University of Texas at Austin, 2003.
[70] F. J. Gomez and R. Miikkulainen. Incremental evolution of complex general behavior. Adaptive Behavior, 5:317-342, 1997.
[71] F. J. Gomez and R. Miikkulainen. Active guidance for a finless rocket using neuroevolution. In Proc. GECCO 2003, Chicago, 2003.
[72] F. J. Gomez, J. Schmidhuber, and R. Miikkulainen. Accelerated neural evolution through cooperatively coevolved synapses. Journal of Machine Learning Research, 9(May):937-965, 2008.
[73] H. Gomi and M. Kawato. Neural network control for a closed-loop system using feedback-error-learning. Neural Networks, 6(7):933-946, 1993.
[74] I. J. Goodfellow, Y. Bulatov, J. Ibarz, S. Arnoud, and V. Shet. Multi-digit number recognition from street view imagery using deep convolutional neural networks. arXiv preprint arXiv:1312.6082 v4, 2014.
[75] I. J. Goodfellow, D. Warde-Farley, M. Mirza, A. Courville, and Y. Bengio. Maxout networks. In International Conference on Machine Learning (ICML), 2013.
[76] A. Graves, S. Fernandez, F. J. Gomez, and J. Schmidhuber. Connectionist temporal classification: Labelling unsegmented sequence data with recurrent neural nets. In ICML'06: Proceedings of the 23rd International Conference on Machine Learning, pages 369-376, 2006.
[77] A. Graves, M. Liwicki, S. Fernandez, R. Bertolami, H. Bunke, and J. Schmidhuber. A novel connectionist system for improved unconstrained handwriting recognition. IEEE Transactions on Pattern Analysis and Machine Intelligence, 31(5), 2009.
[78] A. Graves and J. Schmidhuber. Framewise phoneme classification with bidirectional LSTM and other neural network architectures. Neural Networks, 18(5-6):602-610, 2005.
[79] A. Graves and J. Schmidhuber. Offline handwriting recognition with multidimensional recurrent neural networks. In Advances in Neural Information Processing Systems (NIPS) 21, pages 545-552. MIT Press, Cambridge, MA, 2009.
[80] A. Graves, G. Wayne, and I. Danihelka. Neural Turing machines. Preprint arXiv:1410.5401, 2014.
[81] M. Graziano. The Intelligent Movement Machine: An Ethological Perspective on the Primate Motor System. Oxford University Press, USA, 2009.
[82] I. Grondman, L. Busoniu, G. A. D. Lopes, and R. Babuska. A survey of actor-critic reinforcement learning: Standard and natural policy gradients. Systems, Man, and Cybernetics, Part C: Applications and Reviews, IEEE Transactions on, 42(6):1291-1307, Nov 2012.
[83] F. Gruau, D. Whitley, and L. Pyeatt. A comparison between cellular encoding and direct encoding for genetic neural networks. NeuroCOLT Technical Report NC-TR-96-048, ESPRIT Working Group in Neural and Computational Learning, NeuroCOLT 8556, 1996.
[84] P. D. Grünwald, I. J. Myung, and M. A. Pitt. Advances in minimum description length: Theory and applications. MIT Press, 2005.</p>
<p>[85] M. Grüttner, F. Sehnke, T. Schaul, and J. Schmidhuber. Multi-Dimensional Deep Memory Atari-Go Players for Parameter Exploring Policy Gradients. In Proceedings of the International Conference on Artificial Neural Networks ICANN, pages 114-123. Springer, 2010.
[86] X. Guo, S. Singh, H. Lee, R. Lewis, and X. Wang. Deep learning for real-time Atari game play using offline Monte-Carlo tree search planning. In Advances in Neural Information Processing Systems 27 (NIPS). 2014.
[87] I. Guyon, V. Vapnik, B. Boser, L. Bottou, and S. A. Solla. Structural risk minimization for character recognition. In D. S. Lippman, J. E. Moody, and D. S. Touretzky, editors, Advances in Neural Information Processing Systems (NIPS) 4, pages 471-479. Morgan Kaufmann, 1992.
[88] A. Hannun, C. Case, J. Casper, B. Catanzaro, G. Diamos, E. Elsen, R. Prenger, S. Satheesh, S. Sengupta, A. Coates, and A. Y. Ng. DeepSpeech: Scaling up end-to-end speech recognition. Preprint arXiv:1412.5567, 2014.
[89] N. Hansen, S. D. Müller, and P. Koumoutsakos. Reducing the time complexity of the derandomized evolution strategy with covariance matrix adaptation (CMA-ES). Evolutionary Computation, 11(1):1-18, 2003.
[90] N. Hansen and A. Ostermeier. Completely derandomized self-adaptation in evolution strategies. Evolutionary Computation, 9(2):159-195, 2001.
[91] S. J. Hanson and L. Y. Pratt. Comparing biases for minimal network construction with backpropagation. In D. S. Touretzky, editor, Advances in Neural Information Processing Systems (NIPS) 1, pages 177-185. San Mateo, CA: Morgan Kaufmann, 1989.
[92] B. Hassibi and D. G. Stork. Second order derivatives for network pruning: Optimal brain surgeon. In D. S. Lippman, J. E. Moody, and D. S. Touretzky, editors, Advances in Neural Information Processing Systems 5, pages 164-171. Morgan Kaufmann, 1993.
[93] N. Heess, D. Silver, and Y. W. Teh. Actor-critic reinforcement learning with energy-based policies. In Proc. European Workshop on Reinforcement Learning, pages 43-57, 2012.
[94] V. Heidrich-Meisner and C. Igel. Neuroevolution strategies for episodic reinforcement learning. Journal of Algorithms, 64(4):152-168, 2009.
[95] J. Hertz, A. Krogh, and R. Palmer. Introduction to the Theory of Neural Computation. AddisonWesley, Redwood City, 1991.
[96] G. Hinton and R. Salakhutdinov. Reducing the dimensionality of data with neural networks. Science, 313(5786):504-507, 2006.
[97] G. E. Hinton and D. van Camp. Keeping neural networks simple. In Proceedings of the International Conference on Artificial Neural Networks, Amsterdam, pages 11-18. Springer, 1993.
[98] S. Hochreiter. Untersuchungen zu dynamischen neuronalen Netzen. Diploma thesis, Institut für Informatik, Lehrstuhl Prof. Brauer, Technische Universität München, 1991. Advisor: J. Schmidhuber.
[99] S. Hochreiter, Y. Bengio, P. Frasconi, and J. Schmidhuber. Gradient flow in recurrent nets: the difficulty of learning long-term dependencies. In S. C. Kremer and J. F. Kolen, editors, A Field Guide to Dynamical Recurrent Neural Networks. IEEE Press, 2001.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{3}$ An alternative way of letting $C$ learn to access the program of $M$ is to add $C$-owned connections from the weights of $M$ to units of $C$, treating the current weights of $M$ as additional real-valued inputs to $C$. This, however, will typically result in a much larger search space for $C$. There are many other variants of the general scheme described in Sec. 2.2.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>