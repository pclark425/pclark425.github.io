<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-4742 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-4742</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-4742</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-102.html">extraction-schema-102</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, performance, and failure modes.</div>
                <p><strong>Paper ID:</strong> paper-0427110f0e79f41e69a8eb00a3ec8868bac26a4f</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/0427110f0e79f41e69a8eb00a3ec8868bac26a4f" target="_blank">Do NLP Models Know Numbers? Probing Numeracy in Embeddings</a></p>
                <p><strong>Paper Venue:</strong> Conference on Empirical Methods in Natural Language Processing</p>
                <p><strong>Paper TL;DR:</strong> This work investigates the numerical reasoning capabilities of a state-of-the-art question answering model on the DROP dataset and finds this model excels on questions that require numerical reasoning, i.e., it already captures numeracy.</p>
                <p><strong>Paper Abstract:</strong> The ability to understand and work with numbers (numeracy) is critical for many complex reasoning tasks. Currently, most NLP models treat numbers in text in the same way as other tokens—they embed them as distributed vectors. Is this enough to capture numeracy? We begin by investigating the numerical reasoning capabilities of a state-of-the-art question answering model on the DROP dataset. We find this model excels on questions that require numerical reasoning, i.e., it already captures numeracy. To understand how this capability emerges, we probe token embedding methods (e.g., BERT, GloVe) on synthetic list maximum, number decoding, and addition tasks. A surprising degree of numeracy is naturally present in standard embeddings. For example, GloVe and word2vec accurately encode magnitude for numbers up to 1,000. Furthermore, character-level embeddings are even more precise—ELMo captures numeracy the best for all pre-trained methods—but BERT, which uses sub-word units, is less exact.</p>
                <p><strong>Cost:</strong> 0.019</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e4742.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e4742.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, performance, and failure modes.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>NAQANet</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Numerically-augmented QANet (NAQANet)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A reading-comprehension model based on QANet with four output branches (passage span, question span, count, addition/subtraction). Uses concatenated GloVe and Char-CNN token representations and is trained end-to-end on DROP.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>DROP: A reading comprehension benchmark requiring discrete reasoning over paragraphs</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>NAQANet</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>QANet-based RC model augmented with four answer-type branches (passage span, question span, count, add/subtract). Inputs are token embeddings = [GloVe; Char-CNN]. Trained on the DROP dataset (question-answer supervision only).</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>binary comparisons, non-binary greater-than comparisons, list maximum/minimum (superlative number answers), argmax (superlative span answers), addition/subtraction branch (present but not the main focus here).</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_hypothesis</strong></td>
                            <td>Numerical ability emerges from two components: (1) numeracy encoded in token embeddings (Char-CNN and GloVe) that contain magnitude/order signals, and (2) the model learning comparison/selection algorithms end-to-end from QA supervision (no explicit numeric module).</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>High accuracy on DROP comparative/superlative questions (e.g., 89.0 F1 on binary comparatives; 69.2 F1 on superlative number answers) despite no explicit numeric module. Ablation shows the Char-CNN alone (without GloVe) still provides numeracy. Probing experiments show embeddings used by NAQANet contain magnitude/order information.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_against_mechanism</strong></td>
                            <td>Stress tests where passage numbers are scaled or converted to word form show large performance drops, indicating the learned behavior does not robustly generalize beyond training-number distributions. Extrapolation tests show poor accuracy on held-out numeric ranges.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Full validation F1 49.2; Comparative overall F1 76.4; Binary (either-or) comparative F1 89.0; Non-binary comparative F1 49.8; Superlative overall F1 67.7; Superlative number answers F1 69.2; Superlative span answers F1 66.3. Stress tests: Add[21,100] overall -7.8 F1 drop (superlative -27.3); Multiply[11,100] overall -10.4 F1 (superlative -35.7). Probing (interpolation) decoding RMSE [0,99]=2.99, addition RMSE [0,99]=1.11.</td>
                        </tr>
                        <tr>
                            <td><strong>probing_or_intervention_results</strong></td>
                            <td>Ablation removing GloVe (leaving Char-CNN) still yields strong numeracy; stress-test interventions (adding/multiplying numbers in paragraphs; digits->words) reveal extrapolation weakness; probing models trained on embeddings show that embeddings themselves encode numeracy but probing models (and NAQANet) fail to extrapolate outside trained ranges.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_and_failure_modes</strong></td>
                            <td>Fails to extrapolate to numbers outside training range (large drops when numbers are scaled up or converted to larger word-forms). Reliant on embedding representations; no explicit arithmetic reasoning module so generalization is limited.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_models</strong></td>
                            <td>Outperforms naive baselines on DROP numeric questions and benefits from character-level encoders; however, learned Char-CNNs and ELMo (char-based) often encode numeracy even better in probing tasks, and pure character-trained probes generalize better in extrapolation tests.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Do NLP Models Know Numbers? Probing Numeracy in Embeddings', 'publication_date_yy_mm': '2019-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e4742.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e4742.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, performance, and failure modes.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>GloVe</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>GloVe: Global Vectors for Word Representation</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>300-dimensional pre-trained word vectors learned from global co-occurrence statistics; used as fixed token embeddings in experiments probing numeracy.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>GloVe: Global vectors for word representation</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>GloVe</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>300-d static word embeddings trained on large corpora (Pennington et al.). Used concatenated with Char-CNN in NAQANet and as fixed inputs to probing models.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>list maximum (5-class), decoding (regress numeric value), addition (sum of two numbers).</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_hypothesis</strong></td>
                            <td>Magnitude/order information is implicitly encoded in a linear subspace or non-linear mapping of co-occurrence-derived vectors, enabling comparisons and small-range decoding.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>Interpolation probing: list maximum accuracy [0,99]=0.90, [0,999]=0.78, [0,9999]=0.72; decoding RMSE [0,99]=2.23, [0,999]=13.77, [0,9999]=174.21; addition RMSE [0,99]=0.80, [0,999]=16.51, [0,9999]=180.31. Linear probes competitive on small ranges, indicating a linear magnitude subspace for small values.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_against_mechanism</strong></td>
                            <td>Poor extrapolation performance to test ranges outside training (e.g., list-maximum extrapolation accuracies low in Table 7). Decoding/addition errors blow up for large ranges (RMSE large for [0,9999]).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>See 'evidence_for_mechanism' section (numerical values from Table 4).</td>
                        </tr>
                        <tr>
                            <td><strong>probing_or_intervention_results</strong></td>
                            <td>Fixed GloVe embeddings used as input to LSTM and MLP probes; performance degrades with larger numeric ranges and in extrapolation settings. Ablation in NAQANet shows Char-CNN-only variant can match or exceed GloVe+Char-CNN for some probing tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_and_failure_modes</strong></td>
                            <td>Captures numeracy for small-to-moderate ranges but fails to extrapolate; out-of-vocabulary for floats/negatives in some settings (not evaluated on floats/negatives in this paper).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_models</strong></td>
                            <td>Word-level vectors (GloVe, word2vec) perform well for small ranges but are outperformed by character-level methods (ELMo, Char-CNN) on fine-grained numeracy and extrapolation.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Do NLP Models Know Numbers? Probing Numeracy in Embeddings', 'publication_date_yy_mm': '2019-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e4742.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e4742.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, performance, and failure modes.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>word2vec</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Advances in pre-training distributed word representations (word2vec vectors as used)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Pre-trained word vectors (word2vec-style) used as fixed embeddings in probes; capture numeracy for moderate ranges but degrade for large values and extrapolation.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Advances in pre-training distributed word representations</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>word2vec</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Static word vectors (as in Mikolov et al./subsequent releases) used as fixed token embeddings in probing experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>list maximum, decoding, addition (same synthetic probes as other embeddings).</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_hypothesis</strong></td>
                            <td>Embedding geometry learned from co-occurrence statistics induces a mapping correlated with numeric magnitude for commonly seen numeric tokens.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>Interpolation probing: list maximum [0,99]=0.90, [0,999]=0.78, [0,9999]=0.71; decoding RMSE [0,99]=2.34, [0,999]=18.77, [0,9999]=333.47; addition RMSE [0,99]=0.75, [0,999]=21.23, [0,9999]=210.07.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_against_mechanism</strong></td>
                            <td>Strong degradation when tested on larger ranges and poor extrapolation behaviour; different failure modes on extrapolation (predictions can trend opposite to magnitude).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>See 'evidence_for_mechanism' (Table 4 values).</td>
                        </tr>
                        <tr>
                            <td><strong>probing_or_intervention_results</strong></td>
                            <td>Probes trained on word2vec embeddings generalize within training ranges but fail to extrapolate; performance worse than char-based learned embeddings on large ranges.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_and_failure_modes</strong></td>
                            <td>Limited to in-vocabulary tokens; large RMSE on large ranges and poor extrapolation.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_models</strong></td>
                            <td>Comparable to GloVe on interpolation but inferior to char-level methods (ELMo, Char-CNN) for fine-grained numeracy and extrapolation.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Do NLP Models Know Numbers? Probing Numeracy in Embeddings', 'publication_date_yy_mm': '2019-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e4742.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e4742.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, performance, and failure modes.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>ELMo</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Deep Contextualized Word Representations (ELMo)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Contextualized token representations built from a character-level CNN feeding a biLM; captures numeracy strongly due to character-level encoding.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Deep contextualized word representations</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>ELMo</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Contextualized embeddings derived from a deep bidirectional language model; internal token representation includes character-level convolutions (size 1–7) with pooling.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>list maximum, decoding, addition; also evaluated on floats and negatives.</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_hypothesis</strong></td>
                            <td>Character-level convolutional encoder provides an architectural prior that maps string forms of numbers to magnitude-structured vectors, enabling decoding and relative ordering.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>Interpolation probing: list maximum [0,99]=0.98, [0,999]=0.88, [0,9999]=0.76; decoding RMSE [0,99]=2.35, [0,999]=13.48, [0,9999]=62.20; addition RMSE [0,99]=0.94, [0,999]=15.50, [0,9999]=45.71. Extrapolation is better than word-level vectors (Table 7: list-max extrapolation 0.65/0.57/0.38 on test ranges).</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_against_mechanism</strong></td>
                            <td>Despite strong interpolation performance, ELMo still struggles to extrapolate to values far outside the training set; decoding/addition RMSE rises with range.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>See 'evidence_for_mechanism' for numerical values from Table 4 and extrapolation Table 7.</td>
                        </tr>
                        <tr>
                            <td><strong>probing_or_intervention_results</strong></td>
                            <td>Probing with fixed ELMo embeddings shows strong numeracy; extracting the character-conv layer vs. full contextual vector showed little difference in this paper's experiments (they tested both).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_and_failure_modes</strong></td>
                            <td>Fails to reliably extrapolate to ranges outside training; contextualization may not overcome range generalization limits.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_models</strong></td>
                            <td>Among pre-trained methods, ELMo is one of the best at capturing numeracy, outperforming word-level (GloVe/word2vec) and sub-word (BERT) models on many probes, attributed to its char-CNN prior.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Do NLP Models Know Numbers? Probing Numeracy in Embeddings', 'publication_date_yy_mm': '2019-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e4742.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e4742.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, performance, and failure modes.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>BERT</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>BERT</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A sub-word-piece based Transformer (BERT-base, uncased) whose subword tokenization appears to hinder fine-grained numeric encoding compared to character-level methods.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>BERT: pre-training of deep bidirectional transformers for language understanding</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>BERT (base, uncased, 30k pieces)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Transformer-based contextualized model using WordPiece/sub-word tokenization. Extracted fixed token vectors used as inputs to probes.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>list maximum, decoding, addition; floats and negatives also evaluated.</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_hypothesis</strong></td>
                            <td>Subword segmentation leads to inconsistent representations for numerically-similar tokens, reducing capacity to encode numeric magnitude linearly; any numeracy arises indirectly from token-piece cooccurrence patterns rather than a clean char-to-magnitude mapping.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>Interpolation probing: list maximum [0,99]=0.95, [0,999]=0.62, [0,9999]=0.52; decoding RMSE [0,99]=3.21, [0,999]=29.00, [0,9999]=431.78; addition RMSE [0,99]=4.56, [0,999]=67.81, [0,9999]=454.78. BERT also struggles more on floats than ELMo/Char-CNN.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_against_mechanism</strong></td>
                            <td>Although BERT shows some numeracy at small ranges, the sharp degradation as range grows and poor extrapolation (Table 7: 0.35/0.11/0.14 on test ranges) point to limitations of subword encodings for numeric magnitude.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>See 'evidence_for_mechanism' (Table 4).</td>
                        </tr>
                        <tr>
                            <td><strong>probing_or_intervention_results</strong></td>
                            <td>Fixed BERT embeddings fed into the same probe architectures used for other embedders produce poorer decoding/addition results for large ranges; the authors attribute this to sub-word piece segmentation misaligning numerically-similar tokens.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_and_failure_modes</strong></td>
                            <td>Subword splits make numerically similar numbers have divergent tokenizations, harming encoding of magnitude, especially for large ranges and floats; poor extrapolation.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_models</strong></td>
                            <td>Underperforms character-level methods (ELMo, Char-CNN) on numeracy probes and extrapolation; better than random/untrained baselines but worse than most char-based learned embedders.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Do NLP Models Know Numbers? Probing Numeracy in Embeddings', 'publication_date_yy_mm': '2019-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e4742.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e4742.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, performance, and failure modes.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Char-CNN (learned)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Learned Character-level Convolutional Network (Char-CNN)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A character-level convolutional encoder trained on the probing tasks; strongest overall embedding method for numeracy and relatively robust in extrapolation.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Char-CNN (learned on probing tasks)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Character-level CNN encoder (with left padding trick) trained from scratch as a token embedder for numbers; used both as a learned embedding and as the Char-CNN component of NAQANet.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>list maximum, decoding, addition; tested on integers, floats, negatives.</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_hypothesis</strong></td>
                            <td>Inductive bias of convolution over character sequences yields a structured mapping from string representation of numbers to vector encodings that preserve magnitude and ordering, enabling both decoding and arithmetic operations.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>Interpolation probing: list maximum [0,99]=0.97, [0,999]=0.93, [0,9999]=0.88; decoding RMSE [0,99]=2.50, [0,999]=4.92, [0,9999]=11.57; addition RMSE [0,99]=1.19, [0,999]=7.75, [0,9999]=15.09. Extrapolation: list-max accuracies 0.81/0.75/0.73 on test ranges (Table 7), outperforming many pre-trained embedders.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_against_mechanism</strong></td>
                            <td>Although strong, it does not perfectly extrapolate; performance still declines for very large ranges though much less severely than for word/subword models.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>See 'evidence_for_mechanism' (Table 4 and Table 7 numbers).</td>
                        </tr>
                        <tr>
                            <td><strong>probing_or_intervention_results</strong></td>
                            <td>Learned Char-CNNs trained on the synthetic tasks perform best overall; an untrained/random Char-CNN is also surprisingly competitive, pointing to a powerful architectural prior.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_and_failure_modes</strong></td>
                            <td>While far better at extrapolation than pre-trained static vectors and BERT, it still shows degraded accuracy on ranges far outside training; training data augmentation can further help.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_models</strong></td>
                            <td>Best-performing embedding class in these probes; outperforms Char-LSTM, ELMo, GloVe, word2vec, and BERT on most numeracy metrics and extrapolation tests.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Do NLP Models Know Numbers? Probing Numeracy in Embeddings', 'publication_date_yy_mm': '2019-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e4742.6">
                <h3 class="extraction-instance">Extracted Data Instance 6 (e4742.6)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, performance, and failure modes.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Char-LSTM (learned)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Learned Character-level LSTM (Char-LSTM)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A character-level LSTM encoder trained on the probing tasks; captures numeracy but generally underperforms Char-CNN on some tasks and ranges.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Char-LSTM (learned on probing tasks)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Character-level LSTM encoder trained from scratch as a token embedder for numbers; uses left padding.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>list maximum, decoding, addition; tested on integers, floats, negatives.</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_hypothesis</strong></td>
                            <td>Sequential character processing maps digit sequences to magnitude-aware vectors, but recurrent inductive bias is less effective than convolution for capturing fine-grained numeric structure in these tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>Interpolation probing: list maximum [0,99]=0.98, [0,999]=0.92, [0,9999]=0.76; decoding/addition RMSEs (Table 4) show strong performance though typically slightly worse than Char-CNN on large ranges. Extrapolation results (Table 7) show Char-LSTM achieves the best list-max extrapolation in that experiment (0.88/0.84/0.82 for certain ranges).</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_against_mechanism</strong></td>
                            <td>While strong, Char-LSTM is less consistent than Char-CNN on some interpolation tasks and shows increased RMSE on very large ranges.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Interpolation and extrapolation numbers summarized above (see Table 4 and Table 7).</td>
                        </tr>
                        <tr>
                            <td><strong>probing_or_intervention_results</strong></td>
                            <td>Learned Char-LSTM probes generalize within ranges and can be competitive or best in some extrapolation setups, indicating recurrent encoders can also capture numeracy but differently from CNNs.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_and_failure_modes</strong></td>
                            <td>Performance varies by task and range; still limited in absolute extrapolation, although in some extrapolation splits it outperformed Char-CNN.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_models</strong></td>
                            <td>Generally competitive with Char-CNN but slightly lower on some interpolation tasks; in some extrapolation splits it performed best (Table 7). Both char-based learned models outperform word/subword pre-trained embeddings on numeracy.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Do NLP Models Know Numbers? Probing Numeracy in Embeddings', 'publication_date_yy_mm': '2019-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e4742.7">
                <h3 class="extraction-instance">Extracted Data Instance 7 (e4742.7)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, performance, and failure modes.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Value Embedding</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Value Embedding (map token embedding to numeric value)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A baseline embedding that directly maps a numeric token to a vector equal to its scalar value (optionally log-scaled); intended to provide direct numeric signal to probing models.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Value Embedding</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Deterministic embedding that maps a numeric token's embedding to its numeric value (or log-value); used as an idealized baseline in probing experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>decoding, addition, list maximum (synthetic probes).</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_hypothesis</strong></td>
                            <td>Providing the scalar value directly should simplify decoding/addition, but training dynamics and scale/variance issues can still impede probe learning for large ranges.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>Performs well for small ranges on list-max and decoding (list-max [0,99]=0.99, decoding RMSE [0,99]=1.20, addition RMSE [0,99]=0.30), showing that direct numeric embeddings make probes easy in interpolation.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_against_mechanism</strong></td>
                            <td>Fails for large ranges despite encoding true values (decoding RMSE [0,9999]=275.50, addition RMSE [0,9999]=654.33). Authors note training instability and variance/magnitude issues; log-scaling helps but is not a panacea.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>See 'evidence_for_mechanism' and 'evidence_against_mechanism' values from Table 4.</td>
                        </tr>
                        <tr>
                            <td><strong>probing_or_intervention_results</strong></td>
                            <td>Tried normalizing values and log-scaling; log-scale improved performance but probes still struggled on large ranges; authors reference similar findings in Trask et al. (2018).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_and_failure_modes</strong></td>
                            <td>Training difficulties for large numeric ranges due to large magnitudes/variance; extreme RMSE in large-range tasks despite giving probes the ground-truth numeric signal.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_models</strong></td>
                            <td>Easier for probes on small ranges than learned/ pre-trained embeddings, but worse behavior for large ranges; demonstrates that probe architecture/training matters even with direct value embeddings.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Do NLP Models Know Numbers? Probing Numeracy in Embeddings', 'publication_date_yy_mm': '2019-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e4742.8">
                <h3 class="extraction-instance">Extracted Data Instance 8 (e4742.8)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, performance, and failure modes.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Random Vectors</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Random Token Vectors (untrained baseline)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Randomly initialized fixed token vectors used as a baseline; they do not encode numeracy and so probes fail to generalize.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Random Vectors (untrained)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Randomly sampled fixed token vectors; used as a baseline embedding to measure how much numeracy pre-trained or learned embeddings provide.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>list maximum, decoding, addition (same synthetic probes).</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_hypothesis</strong></td>
                            <td>No mechanism: random vectors have no systematic relation to numeric magnitude, so probes must memorize rather than generalize.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>Interpolation probing: near-chance list-max accuracies (~0.16-0.23) and very high decoding/addition RMSE (e.g., decoding RMSE [0,99]=29.86; addition RMSE [0,99]=42.03), indicating failure to capture numeracy.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_against_mechanism</strong></td>
                            <td>N/A (serves as negative control).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>List-max ~0.16-0.23 across ranges; decoding RMSE and addition RMSE large as in Table 4.</td>
                        </tr>
                        <tr>
                            <td><strong>probing_or_intervention_results</strong></td>
                            <td>Serves as lower bound: probes trained on random vectors cannot generalize because there is no systematic mapping between tokens and values.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_and_failure_modes</strong></td>
                            <td>By design, incapable of encoding numeracy.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_models</strong></td>
                            <td>Performs far worse than all pre-trained and learned embeddings, highlighting that numeracy in embeddings is non-trivial and beneficial.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Do NLP Models Know Numbers? Probing Numeracy in Embeddings', 'publication_date_yy_mm': '2019-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Neural arithmetic logic units <em>(Rating: 2)</em></li>
                <li>Numeracy for language models: Evaluating and improving their ability to predict numbers <em>(Rating: 2)</em></li>
                <li>Exploring numeracy in word embeddings <em>(Rating: 2)</em></li>
                <li>Analysing mathematical reasoning abilities of neural models <em>(Rating: 2)</em></li>
                <li>DROP: A reading comprehension benchmark requiring discrete reasoning over paragraphs <em>(Rating: 2)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-4742",
    "paper_id": "paper-0427110f0e79f41e69a8eb00a3ec8868bac26a4f",
    "extraction_schema_id": "extraction-schema-102",
    "extracted_data": [
        {
            "name_short": "NAQANet",
            "name_full": "Numerically-augmented QANet (NAQANet)",
            "brief_description": "A reading-comprehension model based on QANet with four output branches (passage span, question span, count, addition/subtraction). Uses concatenated GloVe and Char-CNN token representations and is trained end-to-end on DROP.",
            "citation_title": "DROP: A reading comprehension benchmark requiring discrete reasoning over paragraphs",
            "mention_or_use": "use",
            "model_name": "NAQANet",
            "model_description": "QANet-based RC model augmented with four answer-type branches (passage span, question span, count, add/subtract). Inputs are token embeddings = [GloVe; Char-CNN]. Trained on the DROP dataset (question-answer supervision only).",
            "arithmetic_task_type": "binary comparisons, non-binary greater-than comparisons, list maximum/minimum (superlative number answers), argmax (superlative span answers), addition/subtraction branch (present but not the main focus here).",
            "mechanism_hypothesis": "Numerical ability emerges from two components: (1) numeracy encoded in token embeddings (Char-CNN and GloVe) that contain magnitude/order signals, and (2) the model learning comparison/selection algorithms end-to-end from QA supervision (no explicit numeric module).",
            "evidence_for_mechanism": "High accuracy on DROP comparative/superlative questions (e.g., 89.0 F1 on binary comparatives; 69.2 F1 on superlative number answers) despite no explicit numeric module. Ablation shows the Char-CNN alone (without GloVe) still provides numeracy. Probing experiments show embeddings used by NAQANet contain magnitude/order information.",
            "evidence_against_mechanism": "Stress tests where passage numbers are scaled or converted to word form show large performance drops, indicating the learned behavior does not robustly generalize beyond training-number distributions. Extrapolation tests show poor accuracy on held-out numeric ranges.",
            "performance_metrics": "Full validation F1 49.2; Comparative overall F1 76.4; Binary (either-or) comparative F1 89.0; Non-binary comparative F1 49.8; Superlative overall F1 67.7; Superlative number answers F1 69.2; Superlative span answers F1 66.3. Stress tests: Add[21,100] overall -7.8 F1 drop (superlative -27.3); Multiply[11,100] overall -10.4 F1 (superlative -35.7). Probing (interpolation) decoding RMSE [0,99]=2.99, addition RMSE [0,99]=1.11.",
            "probing_or_intervention_results": "Ablation removing GloVe (leaving Char-CNN) still yields strong numeracy; stress-test interventions (adding/multiplying numbers in paragraphs; digits-&gt;words) reveal extrapolation weakness; probing models trained on embeddings show that embeddings themselves encode numeracy but probing models (and NAQANet) fail to extrapolate outside trained ranges.",
            "limitations_and_failure_modes": "Fails to extrapolate to numbers outside training range (large drops when numbers are scaled up or converted to larger word-forms). Reliant on embedding representations; no explicit arithmetic reasoning module so generalization is limited.",
            "comparison_to_other_models": "Outperforms naive baselines on DROP numeric questions and benefits from character-level encoders; however, learned Char-CNNs and ELMo (char-based) often encode numeracy even better in probing tasks, and pure character-trained probes generalize better in extrapolation tests.",
            "uuid": "e4742.0",
            "source_info": {
                "paper_title": "Do NLP Models Know Numbers? Probing Numeracy in Embeddings",
                "publication_date_yy_mm": "2019-09"
            }
        },
        {
            "name_short": "GloVe",
            "name_full": "GloVe: Global Vectors for Word Representation",
            "brief_description": "300-dimensional pre-trained word vectors learned from global co-occurrence statistics; used as fixed token embeddings in experiments probing numeracy.",
            "citation_title": "GloVe: Global vectors for word representation",
            "mention_or_use": "use",
            "model_name": "GloVe",
            "model_description": "300-d static word embeddings trained on large corpora (Pennington et al.). Used concatenated with Char-CNN in NAQANet and as fixed inputs to probing models.",
            "arithmetic_task_type": "list maximum (5-class), decoding (regress numeric value), addition (sum of two numbers).",
            "mechanism_hypothesis": "Magnitude/order information is implicitly encoded in a linear subspace or non-linear mapping of co-occurrence-derived vectors, enabling comparisons and small-range decoding.",
            "evidence_for_mechanism": "Interpolation probing: list maximum accuracy [0,99]=0.90, [0,999]=0.78, [0,9999]=0.72; decoding RMSE [0,99]=2.23, [0,999]=13.77, [0,9999]=174.21; addition RMSE [0,99]=0.80, [0,999]=16.51, [0,9999]=180.31. Linear probes competitive on small ranges, indicating a linear magnitude subspace for small values.",
            "evidence_against_mechanism": "Poor extrapolation performance to test ranges outside training (e.g., list-maximum extrapolation accuracies low in Table 7). Decoding/addition errors blow up for large ranges (RMSE large for [0,9999]).",
            "performance_metrics": "See 'evidence_for_mechanism' section (numerical values from Table 4).",
            "probing_or_intervention_results": "Fixed GloVe embeddings used as input to LSTM and MLP probes; performance degrades with larger numeric ranges and in extrapolation settings. Ablation in NAQANet shows Char-CNN-only variant can match or exceed GloVe+Char-CNN for some probing tasks.",
            "limitations_and_failure_modes": "Captures numeracy for small-to-moderate ranges but fails to extrapolate; out-of-vocabulary for floats/negatives in some settings (not evaluated on floats/negatives in this paper).",
            "comparison_to_other_models": "Word-level vectors (GloVe, word2vec) perform well for small ranges but are outperformed by character-level methods (ELMo, Char-CNN) on fine-grained numeracy and extrapolation.",
            "uuid": "e4742.1",
            "source_info": {
                "paper_title": "Do NLP Models Know Numbers? Probing Numeracy in Embeddings",
                "publication_date_yy_mm": "2019-09"
            }
        },
        {
            "name_short": "word2vec",
            "name_full": "Advances in pre-training distributed word representations (word2vec vectors as used)",
            "brief_description": "Pre-trained word vectors (word2vec-style) used as fixed embeddings in probes; capture numeracy for moderate ranges but degrade for large values and extrapolation.",
            "citation_title": "Advances in pre-training distributed word representations",
            "mention_or_use": "use",
            "model_name": "word2vec",
            "model_description": "Static word vectors (as in Mikolov et al./subsequent releases) used as fixed token embeddings in probing experiments.",
            "arithmetic_task_type": "list maximum, decoding, addition (same synthetic probes as other embeddings).",
            "mechanism_hypothesis": "Embedding geometry learned from co-occurrence statistics induces a mapping correlated with numeric magnitude for commonly seen numeric tokens.",
            "evidence_for_mechanism": "Interpolation probing: list maximum [0,99]=0.90, [0,999]=0.78, [0,9999]=0.71; decoding RMSE [0,99]=2.34, [0,999]=18.77, [0,9999]=333.47; addition RMSE [0,99]=0.75, [0,999]=21.23, [0,9999]=210.07.",
            "evidence_against_mechanism": "Strong degradation when tested on larger ranges and poor extrapolation behaviour; different failure modes on extrapolation (predictions can trend opposite to magnitude).",
            "performance_metrics": "See 'evidence_for_mechanism' (Table 4 values).",
            "probing_or_intervention_results": "Probes trained on word2vec embeddings generalize within training ranges but fail to extrapolate; performance worse than char-based learned embeddings on large ranges.",
            "limitations_and_failure_modes": "Limited to in-vocabulary tokens; large RMSE on large ranges and poor extrapolation.",
            "comparison_to_other_models": "Comparable to GloVe on interpolation but inferior to char-level methods (ELMo, Char-CNN) for fine-grained numeracy and extrapolation.",
            "uuid": "e4742.2",
            "source_info": {
                "paper_title": "Do NLP Models Know Numbers? Probing Numeracy in Embeddings",
                "publication_date_yy_mm": "2019-09"
            }
        },
        {
            "name_short": "ELMo",
            "name_full": "Deep Contextualized Word Representations (ELMo)",
            "brief_description": "Contextualized token representations built from a character-level CNN feeding a biLM; captures numeracy strongly due to character-level encoding.",
            "citation_title": "Deep contextualized word representations",
            "mention_or_use": "use",
            "model_name": "ELMo",
            "model_description": "Contextualized embeddings derived from a deep bidirectional language model; internal token representation includes character-level convolutions (size 1–7) with pooling.",
            "arithmetic_task_type": "list maximum, decoding, addition; also evaluated on floats and negatives.",
            "mechanism_hypothesis": "Character-level convolutional encoder provides an architectural prior that maps string forms of numbers to magnitude-structured vectors, enabling decoding and relative ordering.",
            "evidence_for_mechanism": "Interpolation probing: list maximum [0,99]=0.98, [0,999]=0.88, [0,9999]=0.76; decoding RMSE [0,99]=2.35, [0,999]=13.48, [0,9999]=62.20; addition RMSE [0,99]=0.94, [0,999]=15.50, [0,9999]=45.71. Extrapolation is better than word-level vectors (Table 7: list-max extrapolation 0.65/0.57/0.38 on test ranges).",
            "evidence_against_mechanism": "Despite strong interpolation performance, ELMo still struggles to extrapolate to values far outside the training set; decoding/addition RMSE rises with range.",
            "performance_metrics": "See 'evidence_for_mechanism' for numerical values from Table 4 and extrapolation Table 7.",
            "probing_or_intervention_results": "Probing with fixed ELMo embeddings shows strong numeracy; extracting the character-conv layer vs. full contextual vector showed little difference in this paper's experiments (they tested both).",
            "limitations_and_failure_modes": "Fails to reliably extrapolate to ranges outside training; contextualization may not overcome range generalization limits.",
            "comparison_to_other_models": "Among pre-trained methods, ELMo is one of the best at capturing numeracy, outperforming word-level (GloVe/word2vec) and sub-word (BERT) models on many probes, attributed to its char-CNN prior.",
            "uuid": "e4742.3",
            "source_info": {
                "paper_title": "Do NLP Models Know Numbers? Probing Numeracy in Embeddings",
                "publication_date_yy_mm": "2019-09"
            }
        },
        {
            "name_short": "BERT",
            "name_full": "BERT",
            "brief_description": "A sub-word-piece based Transformer (BERT-base, uncased) whose subword tokenization appears to hinder fine-grained numeric encoding compared to character-level methods.",
            "citation_title": "BERT: pre-training of deep bidirectional transformers for language understanding",
            "mention_or_use": "use",
            "model_name": "BERT (base, uncased, 30k pieces)",
            "model_description": "Transformer-based contextualized model using WordPiece/sub-word tokenization. Extracted fixed token vectors used as inputs to probes.",
            "arithmetic_task_type": "list maximum, decoding, addition; floats and negatives also evaluated.",
            "mechanism_hypothesis": "Subword segmentation leads to inconsistent representations for numerically-similar tokens, reducing capacity to encode numeric magnitude linearly; any numeracy arises indirectly from token-piece cooccurrence patterns rather than a clean char-to-magnitude mapping.",
            "evidence_for_mechanism": "Interpolation probing: list maximum [0,99]=0.95, [0,999]=0.62, [0,9999]=0.52; decoding RMSE [0,99]=3.21, [0,999]=29.00, [0,9999]=431.78; addition RMSE [0,99]=4.56, [0,999]=67.81, [0,9999]=454.78. BERT also struggles more on floats than ELMo/Char-CNN.",
            "evidence_against_mechanism": "Although BERT shows some numeracy at small ranges, the sharp degradation as range grows and poor extrapolation (Table 7: 0.35/0.11/0.14 on test ranges) point to limitations of subword encodings for numeric magnitude.",
            "performance_metrics": "See 'evidence_for_mechanism' (Table 4).",
            "probing_or_intervention_results": "Fixed BERT embeddings fed into the same probe architectures used for other embedders produce poorer decoding/addition results for large ranges; the authors attribute this to sub-word piece segmentation misaligning numerically-similar tokens.",
            "limitations_and_failure_modes": "Subword splits make numerically similar numbers have divergent tokenizations, harming encoding of magnitude, especially for large ranges and floats; poor extrapolation.",
            "comparison_to_other_models": "Underperforms character-level methods (ELMo, Char-CNN) on numeracy probes and extrapolation; better than random/untrained baselines but worse than most char-based learned embedders.",
            "uuid": "e4742.4",
            "source_info": {
                "paper_title": "Do NLP Models Know Numbers? Probing Numeracy in Embeddings",
                "publication_date_yy_mm": "2019-09"
            }
        },
        {
            "name_short": "Char-CNN (learned)",
            "name_full": "Learned Character-level Convolutional Network (Char-CNN)",
            "brief_description": "A character-level convolutional encoder trained on the probing tasks; strongest overall embedding method for numeracy and relatively robust in extrapolation.",
            "citation_title": "",
            "mention_or_use": "use",
            "model_name": "Char-CNN (learned on probing tasks)",
            "model_description": "Character-level CNN encoder (with left padding trick) trained from scratch as a token embedder for numbers; used both as a learned embedding and as the Char-CNN component of NAQANet.",
            "arithmetic_task_type": "list maximum, decoding, addition; tested on integers, floats, negatives.",
            "mechanism_hypothesis": "Inductive bias of convolution over character sequences yields a structured mapping from string representation of numbers to vector encodings that preserve magnitude and ordering, enabling both decoding and arithmetic operations.",
            "evidence_for_mechanism": "Interpolation probing: list maximum [0,99]=0.97, [0,999]=0.93, [0,9999]=0.88; decoding RMSE [0,99]=2.50, [0,999]=4.92, [0,9999]=11.57; addition RMSE [0,99]=1.19, [0,999]=7.75, [0,9999]=15.09. Extrapolation: list-max accuracies 0.81/0.75/0.73 on test ranges (Table 7), outperforming many pre-trained embedders.",
            "evidence_against_mechanism": "Although strong, it does not perfectly extrapolate; performance still declines for very large ranges though much less severely than for word/subword models.",
            "performance_metrics": "See 'evidence_for_mechanism' (Table 4 and Table 7 numbers).",
            "probing_or_intervention_results": "Learned Char-CNNs trained on the synthetic tasks perform best overall; an untrained/random Char-CNN is also surprisingly competitive, pointing to a powerful architectural prior.",
            "limitations_and_failure_modes": "While far better at extrapolation than pre-trained static vectors and BERT, it still shows degraded accuracy on ranges far outside training; training data augmentation can further help.",
            "comparison_to_other_models": "Best-performing embedding class in these probes; outperforms Char-LSTM, ELMo, GloVe, word2vec, and BERT on most numeracy metrics and extrapolation tests.",
            "uuid": "e4742.5",
            "source_info": {
                "paper_title": "Do NLP Models Know Numbers? Probing Numeracy in Embeddings",
                "publication_date_yy_mm": "2019-09"
            }
        },
        {
            "name_short": "Char-LSTM (learned)",
            "name_full": "Learned Character-level LSTM (Char-LSTM)",
            "brief_description": "A character-level LSTM encoder trained on the probing tasks; captures numeracy but generally underperforms Char-CNN on some tasks and ranges.",
            "citation_title": "",
            "mention_or_use": "use",
            "model_name": "Char-LSTM (learned on probing tasks)",
            "model_description": "Character-level LSTM encoder trained from scratch as a token embedder for numbers; uses left padding.",
            "arithmetic_task_type": "list maximum, decoding, addition; tested on integers, floats, negatives.",
            "mechanism_hypothesis": "Sequential character processing maps digit sequences to magnitude-aware vectors, but recurrent inductive bias is less effective than convolution for capturing fine-grained numeric structure in these tasks.",
            "evidence_for_mechanism": "Interpolation probing: list maximum [0,99]=0.98, [0,999]=0.92, [0,9999]=0.76; decoding/addition RMSEs (Table 4) show strong performance though typically slightly worse than Char-CNN on large ranges. Extrapolation results (Table 7) show Char-LSTM achieves the best list-max extrapolation in that experiment (0.88/0.84/0.82 for certain ranges).",
            "evidence_against_mechanism": "While strong, Char-LSTM is less consistent than Char-CNN on some interpolation tasks and shows increased RMSE on very large ranges.",
            "performance_metrics": "Interpolation and extrapolation numbers summarized above (see Table 4 and Table 7).",
            "probing_or_intervention_results": "Learned Char-LSTM probes generalize within ranges and can be competitive or best in some extrapolation setups, indicating recurrent encoders can also capture numeracy but differently from CNNs.",
            "limitations_and_failure_modes": "Performance varies by task and range; still limited in absolute extrapolation, although in some extrapolation splits it outperformed Char-CNN.",
            "comparison_to_other_models": "Generally competitive with Char-CNN but slightly lower on some interpolation tasks; in some extrapolation splits it performed best (Table 7). Both char-based learned models outperform word/subword pre-trained embeddings on numeracy.",
            "uuid": "e4742.6",
            "source_info": {
                "paper_title": "Do NLP Models Know Numbers? Probing Numeracy in Embeddings",
                "publication_date_yy_mm": "2019-09"
            }
        },
        {
            "name_short": "Value Embedding",
            "name_full": "Value Embedding (map token embedding to numeric value)",
            "brief_description": "A baseline embedding that directly maps a numeric token to a vector equal to its scalar value (optionally log-scaled); intended to provide direct numeric signal to probing models.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "Value Embedding",
            "model_description": "Deterministic embedding that maps a numeric token's embedding to its numeric value (or log-value); used as an idealized baseline in probing experiments.",
            "arithmetic_task_type": "decoding, addition, list maximum (synthetic probes).",
            "mechanism_hypothesis": "Providing the scalar value directly should simplify decoding/addition, but training dynamics and scale/variance issues can still impede probe learning for large ranges.",
            "evidence_for_mechanism": "Performs well for small ranges on list-max and decoding (list-max [0,99]=0.99, decoding RMSE [0,99]=1.20, addition RMSE [0,99]=0.30), showing that direct numeric embeddings make probes easy in interpolation.",
            "evidence_against_mechanism": "Fails for large ranges despite encoding true values (decoding RMSE [0,9999]=275.50, addition RMSE [0,9999]=654.33). Authors note training instability and variance/magnitude issues; log-scaling helps but is not a panacea.",
            "performance_metrics": "See 'evidence_for_mechanism' and 'evidence_against_mechanism' values from Table 4.",
            "probing_or_intervention_results": "Tried normalizing values and log-scaling; log-scale improved performance but probes still struggled on large ranges; authors reference similar findings in Trask et al. (2018).",
            "limitations_and_failure_modes": "Training difficulties for large numeric ranges due to large magnitudes/variance; extreme RMSE in large-range tasks despite giving probes the ground-truth numeric signal.",
            "comparison_to_other_models": "Easier for probes on small ranges than learned/ pre-trained embeddings, but worse behavior for large ranges; demonstrates that probe architecture/training matters even with direct value embeddings.",
            "uuid": "e4742.7",
            "source_info": {
                "paper_title": "Do NLP Models Know Numbers? Probing Numeracy in Embeddings",
                "publication_date_yy_mm": "2019-09"
            }
        },
        {
            "name_short": "Random Vectors",
            "name_full": "Random Token Vectors (untrained baseline)",
            "brief_description": "Randomly initialized fixed token vectors used as a baseline; they do not encode numeracy and so probes fail to generalize.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "Random Vectors (untrained)",
            "model_description": "Randomly sampled fixed token vectors; used as a baseline embedding to measure how much numeracy pre-trained or learned embeddings provide.",
            "arithmetic_task_type": "list maximum, decoding, addition (same synthetic probes).",
            "mechanism_hypothesis": "No mechanism: random vectors have no systematic relation to numeric magnitude, so probes must memorize rather than generalize.",
            "evidence_for_mechanism": "Interpolation probing: near-chance list-max accuracies (~0.16-0.23) and very high decoding/addition RMSE (e.g., decoding RMSE [0,99]=29.86; addition RMSE [0,99]=42.03), indicating failure to capture numeracy.",
            "evidence_against_mechanism": "N/A (serves as negative control).",
            "performance_metrics": "List-max ~0.16-0.23 across ranges; decoding RMSE and addition RMSE large as in Table 4.",
            "probing_or_intervention_results": "Serves as lower bound: probes trained on random vectors cannot generalize because there is no systematic mapping between tokens and values.",
            "limitations_and_failure_modes": "By design, incapable of encoding numeracy.",
            "comparison_to_other_models": "Performs far worse than all pre-trained and learned embeddings, highlighting that numeracy in embeddings is non-trivial and beneficial.",
            "uuid": "e4742.8",
            "source_info": {
                "paper_title": "Do NLP Models Know Numbers? Probing Numeracy in Embeddings",
                "publication_date_yy_mm": "2019-09"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Neural arithmetic logic units",
            "rating": 2
        },
        {
            "paper_title": "Numeracy for language models: Evaluating and improving their ability to predict numbers",
            "rating": 2
        },
        {
            "paper_title": "Exploring numeracy in word embeddings",
            "rating": 2
        },
        {
            "paper_title": "Analysing mathematical reasoning abilities of neural models",
            "rating": 2
        },
        {
            "paper_title": "DROP: A reading comprehension benchmark requiring discrete reasoning over paragraphs",
            "rating": 2
        }
    ],
    "cost": 0.0192465,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Do NLP Models Know Numbers? Probing Numeracy in Embeddings</h1>
<p>Eric Wallace ${ }^{<em> 1}$, Yizhong Wang ${ }^{</em> 2}$, Sujian Li ${ }^{2}$, Sameer Singh ${ }^{3}$, Matt Gardner ${ }^{1}$<br>${ }^{1}$ Allen Institute for Artificial Intelligence<br>${ }^{2}$ Peking University<br>${ }^{3}$ University of California, Irvine<br>{ericw, mattg}@allenai.org, {yizhong, lisujian}@pku.edu.cn, sameer@uci.edu</p>
<h4>Abstract</h4>
<p>The ability to understand and work with numbers (numeracy) is critical for many complex reasoning tasks. Currently, most NLP models treat numbers in text in the same way as other tokens-they embed them as distributed vectors. Is this enough to capture numeracy? We begin by investigating the numerical reasoning capabilities of a state-of-the-art question answering model on the DROP dataset. We find this model excels on questions that require numerical reasoning, i.e., it already captures numeracy. To understand how this capability emerges, we probe token embedding methods (e.g., BERT, GloVe) on synthetic list maximum, number decoding, and addition tasks. A surprising degree of numeracy is naturally present in standard embeddings. For example, GloVe and word2vec accurately encode magnitude for numbers up to 1,000. Furthermore, character-level embeddings are even more precise-ELMo captures numeracy the best for all pre-trained methods-but BERT, which uses sub-word units, is less exact.</p>
<h2>1 Introduction</h2>
<p>Neural NLP models have become the de-facto standard tool across language understanding tasks, even solving basic reading comprehension and textual entailment datasets (Yu et al., 2018; Devlin et al., 2019). Despite this, existing models are incapable of complex forms of reasoning, in particular, we focus on the ability to reason numerically. Recent datasets such as DROP (Dua et al., 2019), EQUATE (Ravichander et al., 2019), or Mathematics Questions (Saxton et al., 2019) test numerical reasoning; they contain examples which require comparing, sorting, and adding numbers in natural language (e.g., Figure 2).</p>
<p>The first step in performing numerical reasoning over natural language is numeracy: the abil-</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: We train a probing model to decode a number from its word embedding over a random $80 \%$ of the integers from $[-500,500]$, e.g., " 71 " $\rightarrow 71.0$. We plot the model's predictions for all numbers from [-2000, 2000]. The model accurately decodes numbers within the training range (in blue), i.e., pre-trained embeddings like GloVe and BERT capture numeracy. However, the probe fails to extrapolate to larger numbers (in red). The Char-CNN (e) and Char-LSTM (f) are trained jointly with the probing model.
ity to understand and work with numbers in either digit or word form (Spithourakis and Riedel, 2018). For example, one must understand that the string " 23 " represents a bigger value than "twentytwo". Once a number's value is (perhaps implicitly) represented, reasoning algorithms can then process the text, e.g., extracting the list of field goals and computing that list's maximum (first question in Figure 2). Learning to reason numerically over paragraphs with only question-answer supervision appears daunting for end-to-end models; our work seeks to understand if and how "out-of-the-box" neural NLP models already learn this.</p>
<p>We begin by analyzing the state-of-the-art NAQANet model (Dua et al., 2019) for DROPtesting it on a subset of questions that evaluate numerical reasoning (Section 2). To our surprise,</p>
<p>the model exhibits excellent numerical reasoning abilities. Amidst reading and comprehending natural language, the model successfully computes list maximums/minimums, extracts superlative entities (argmax reasoning), and compares numerical quantities. For instance, despite NAQANet achieving only 49 F 1 on the entire validation set, it scores 89 F 1 on numerical comparison questions. We also stress test the model by perturbing the validation paragraphs and find one failure mode: the model struggles to extrapolate to numbers outside its training range.</p>
<p>We are especially intrigued by the model's ability to learn numeracy, i.e., how does the model know the value of a number given its embedding? The model uses standard embeddings (GloVe and a Char-CNN) and receives no direct supervision for number magnitude/ordering. To understand how numeracy emerges, we probe token embedding methods (e.g., BERT, GloVe) using synthetic list maximum, number decoding, and addition tasks (Section 3).</p>
<p>We find that all widely-used pre-trained embeddings, e.g., ELMo (Peters et al., 2018), BERT (Devlin et al., 2019), and GloVe (Pennington et al., 2014), capture numeracy: number magnitude is present in the embeddings, even for numbers in the thousands. Among all embeddings, characterlevel methods exhibit stronger numeracy than word- and sub-word-level methods (e.g., ELMo excels while BERT struggles), and character-level models learned directly on the synthetic tasks are the strongest overall. Finally, we investigate why NAQANet had trouble extrapolating-was it a failure in the model or the embeddings? We repeat our probing tasks and test for model extrapolation, finding that neural models struggle to predict numbers outside the training range.</p>
<h2>2 Numeracy Case Study: DROP QA</h2>
<p>This section examines the state-of-the-art model for DROP by investigating its accuracy on questions that require numerical reasoning.</p>
<h3>2.1 DROP Dataset</h3>
<p>DROP is a reading comprehension dataset that tests numerical reasoning operations such as counting, sorting, and addition (Dua et al., 2019). The dataset's input-output format is a superset of SQuAD (Rajpurkar et al., 2016): the answers are paragraph spans, as well as question</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup>Figure 2: Three DROP questions that require numerical reasoning; the state-of-the-art NAQANet answers every question correct. Plausible answer candidates to the questions are underlined and the model's predictions are shown in bold.
spans, number answers (e.g., 35), and dates (e.g., 03/01/2014). The only supervision provided is the question-answer pairs, i.e., a model must learn to reason numerically while simultaneously learning to read and comprehend.</p>
<h3>2.2 NAQANet Model</h3>
<p>Modeling approaches for DROP include both semantic parsing (Krishnamurthy et al., 2017) and reading comprehension (Yu et al., 2018) models. We focus on the latter, specifically on Numerically-augmented QANet (NAQANet), the current state-of-the-art model (Dua et al., 2019). ${ }^{1}$ The model's core structure closely follows QANet (Yu et al., 2018) except that it contains four output branches, one for each of the four answer types (passage span, question span, count answer, or addition/subtraction of numbers.)</p>
<p>Words and numbers are represented as the concatenation of GloVe embeddings and the output of a character-level CNN. The model contains no auxiliary components for representing number magnitude or performing explicit comparisons. We refer readers to Yu et al. (2018) and Dua et al. (2019) for further details.</p>
<h3>2.3 Comparative and Superlative Questions</h3>
<p>We focus on questions that NAQANet requires numeracy to answer, namely Comparative and Superlative questions. ${ }^{2}$ Comparative questions</p>
<p><sup id="fnref:1"><a class="footnote-ref" href="#fn:1">2</a></sup></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Question Type</th>
<th style="text-align: left;">Example</th>
<th style="text-align: left;">Reasoning Required</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Comparative (Binary)</td>
<td style="text-align: left;">Which country is a bigger exporter, Brazil or Uruguay?</td>
<td style="text-align: left;">Binary Comparison</td>
</tr>
<tr>
<td style="text-align: left;">Comparative (Non-binary)</td>
<td style="text-align: left;">Which player had a touchdown longer than 20 yards?</td>
<td style="text-align: left;">Greater Than</td>
</tr>
<tr>
<td style="text-align: left;">Superlative (Number)</td>
<td style="text-align: left;">How many yards was the shortest field goal?</td>
<td style="text-align: left;">List Minimum</td>
</tr>
<tr>
<td style="text-align: left;">Superlative (Span)</td>
<td style="text-align: left;">Who kicked the longest field goal?</td>
<td style="text-align: left;">Argmax</td>
</tr>
</tbody>
</table>
<p>Table 1: We focus on DROP Comparative and Superlative questions which test NAQANet's numeracy.
probe a model's understanding of quantities or events that are "larger", "smaller", or "longer" than others. Certain comparative questions ask about "either-or" relations (e.g., first row of Table 1), which test binary comparison. Other comparative questions require more diverse comparative reasoning, such as greater than relationships (e.g., second row of Table 1).</p>
<p>Superlative questions ask about the "shortest", "largest", or "biggest" quantity in a passage. When the answer type is a number, superlative questions require finding the maximum or minimum of a list (e.g., third row of Table 1). When the answer type is a span, superlative questions usually require an argmax operation, i.e., one must find the superlative action or quantity and then extract the associated entity (e.g., fourth row of Table 1). We filter the validation set to comparative and superlative questions by writing templates to match words in the question.</p>
<h3>2.4 Emergent Numeracy in NAQANet</h3>
<p>NAQANet's accuracy on comparative and superlative questions is significantly higher than its average accuracy on the validation set (Table 2). ${ }^{3}$</p>
<p>NAQANet achieves 89.0 F1 on binary (eitheror) comparative questions, approximately 40 F 1 points higher than the average validation question and within 7 F 1 points of human test performance. The model achieves a lower, but respectable, accuracy on non-binary comparisons. These questions require multiple reasoning steps, e.g., the second question in Table 1 requires (1) extracting all the touchdown distances, (2) finding the distance that is greater than twenty, and (3) selecting the player associated with the touchdown of that distance.</p>
<p>We divide the superlative questions into questions that have number answers and questions with span answers according to the dataset's provided answer type. NAQANet achieves nearly 70 F1 on superlative questions with number answers, i.e., it can compute list maximum and minimums.</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup>| Question Type | Count | EM | F1 |
| :-- | :--: | :--: | :--: |
| Human (Test Set) | 9622 | 92.4 | 96.0 |
| Full Validation | 9536 | 46.2 | 49.2 |
| $\quad$ Number Answers | 5842 | 44.3 | 44.4 |
| Comparative | 704 | 73.6 | 76.4 |
| $\quad$ Binary (either-or) | 477 | 86.0 | 89.0 |
| $\quad$ Non-binary | 227 | 47.6 | 49.8 |
| Superlative Questions | 861 | 64.6 | 67.7 |
| $\quad$ Number Answers | 475 | 68.8 | 69.2 |
| $\quad$ Span Answers | 380 | 59.7 | 66.3 |</p>
<p>Table 2: NAQANet achieves higher accuracy on questions that require numerical reasoning (Superlative and Comparative) than on standard validation questions. Human performance is reported from Dua et al. (2019).</p>
<p>The model answers about two-thirds of superlative questions with span answers correctly ( 66.3 F 1 ), i.e., it can perform argmax reasoning.</p>
<p>Figure 2 shows examples of superlative questions answered correctly by NAQANet. The first two questions require computing the maximum/minimum of a list: the model must recognize which digits correspond to field goals and touchdowns passes, and then extract the maximum/minimum of the correct list. The third question requires argmax reasoning: the model must first compute the longest touchdown pass and then find the corresponding receiver "Chaz Schilens".</p>
<h3>2.5 Stress Testing NAQANet's Numeracy</h3>
<p>Just how far does the numeracy of NAQANet go? Here, we stress test the model by automatically modifying DROP validation paragraphs.</p>
<p>We test two phenomena: larger numbers and word-form numbers. For larger numbers, we generate a random positive integer and multiply or add that value to the numbers in each paragraph. For word forms, we replace every digit in the paragraph with its word form (e.g., " 75 " $\rightarrow$ "seventyfive"). Since word-form numbers are usually small in magnitude when they occur in DROP, we perform word replacements for integers in the range $[0,100]$. We guarantee the ground-truth answer is</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Stress Test Dataset</th>
<th style="text-align: left;">All Questions</th>
<th style="text-align: left;"></th>
<th style="text-align: left;">Superlative</th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">F1</td>
<td style="text-align: left;">$\Delta$</td>
<td style="text-align: left;">F1</td>
<td style="text-align: left;">$\Delta$</td>
</tr>
<tr>
<td style="text-align: left;">Original Validation Set</td>
<td style="text-align: left;">49.2</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">67.7</td>
<td style="text-align: left;">-</td>
</tr>
<tr>
<td style="text-align: left;">Add $[1,20]$</td>
<td style="text-align: left;">47.7</td>
<td style="text-align: left;">-1.5</td>
<td style="text-align: left;">64.1</td>
<td style="text-align: left;">-3.6</td>
</tr>
<tr>
<td style="text-align: left;">Add $[21,100]$</td>
<td style="text-align: left;">41.4</td>
<td style="text-align: left;">-7.8</td>
<td style="text-align: left;">40.4</td>
<td style="text-align: left;">-27.3</td>
</tr>
<tr>
<td style="text-align: left;">Multiply $[2,10]$</td>
<td style="text-align: left;">41.1</td>
<td style="text-align: left;">-8.1</td>
<td style="text-align: left;">39.3</td>
<td style="text-align: left;">-28.4</td>
</tr>
<tr>
<td style="text-align: left;">Multiply $[11,100]$</td>
<td style="text-align: left;">38.8</td>
<td style="text-align: left;">-10.4</td>
<td style="text-align: left;">32.0</td>
<td style="text-align: left;">-35.7</td>
</tr>
<tr>
<td style="text-align: left;">Digits to Words $[0,20]$</td>
<td style="text-align: left;">45.5</td>
<td style="text-align: left;">-3.7</td>
<td style="text-align: left;">63.8</td>
<td style="text-align: left;">-3.9</td>
</tr>
<tr>
<td style="text-align: left;">Digits to Words $[21,100]$</td>
<td style="text-align: left;">41.9</td>
<td style="text-align: left;">-7.3</td>
<td style="text-align: left;">46.1</td>
<td style="text-align: left;">-21.6</td>
</tr>
</tbody>
</table>
<p>Table 3: We stress test NAQANet's numeracy by manipulating the numbers in the validation paragraphs. Add or Multiply $[x, y]$ indicates adding or multiplying all of the numbers in the passage by a random integer in the range $[\mathrm{x}, \mathrm{y}]$. Digits $\rightarrow$ Words $[x, y]$ converts all integers in the passage within the range $[\mathrm{x}, \mathrm{y}]$ to their corresponding word form (e.g., " 75 " $\rightarrow$ "seventy-five").
still valid by only modifying NAQANet's internal representation (Appendix E).</p>
<p>Table 3 shows the results for different paragraph modifications. The model exhibits a tiny degradation in performance for small magnitude changes (e.g., NAQANet drops 1.5 F1 overall for Add [1,20]) but severely struggles on larger changes (e.g., NAQANet drops 35.7 F1 on superlative questions for Multiply [11,200]). Similar trends hold for word forms: the model exhibits small drops in accuracy when converting small numbers to words ( 3.9 degradation on Digits to Words [0,20]) but fails on larger magnitude word forms ( 21.6 F 1 drop over [21,100]). These results show that NAQANet has a strong understanding of numeracy for numbers in the training range, but, the model can fail to extrapolate to other values.</p>
<h3>2.6 Whence this behavior?</h3>
<p>NAQANet exhibits numerical reasoning capabilities that exceed our expectations. What enables this behavior? Aside from reading and comprehending the passage/question, this kind of numerical reasoning requires two components: numeracy (i.e., representing numbers) and comparison algorithms (i.e., computing the maximum of a list).</p>
<p>Although the natural emergence of comparison algorithms is surprising, previous results show neural models are capable of learning to count and sort synthetic lists of scalar values when given explicit supervision (Weiss et al., 2018; Vinyals et al., 2016). NAQANet demonstrates that a model can learn comparison algorithms while simultane-
ously learning to read and comprehend, even with only question-answer supervision.</p>
<p>How, then, does NAQANet know numeracy? The source of numerical information eventually lies in the token embeddings themselves, i.e., the character-level convolutions and GloVe embeddings of the NAQANet model. Therefore, we can understand the source of numeracy by isolating and probing these embeddings.</p>
<h2>3 Probing Numeracy of Embeddings</h2>
<p>We use synthetic numerical tasks to probe the numeracy of token embeddings.</p>
<h3>3.1 Probing Tasks</h3>
<p>We consider three synthetic tasks to evaluate numeracy (Figure 3). Appendix C provides further details on training and evaluation.</p>
<p>List Maximum Given a list of the embeddings for five numbers, the task is to predict the index of the maximum number. Each list consists of values of similar magnitude in order to evaluate fine-grained comparisons (see Appendix C). As in typical span selection models (Seo et al., 2017), an LSTM reads the list of token embeddings, and a weight matrix and softmax function assign a probability to each index using the model's hidden state. We use the negative log-likelihood of the maximum number as the loss function.</p>
<p>Decoding The decoding task probes whether number magnitude is captured (rather than the relative ordering of numbers as in list maximum). Given a number's embedding, the task is to regress to its value, e.g., the embedding for the string "five" has a target of 5.0. We consider a linear regression model and a three-layer fully-connected network with ReLU activations. The models are trained using a mean squared error (MSE) loss.</p>
<p>Addition The addition task requires number manipulation-given the embeddings of two numbers, the task is to predict their sum. Our model concatenates the two token embeddings and feeds the result through a three-layer fullyconnected network with ReLU activations, trained using MSE loss. Unlike the decoding task, the model needs to capture number magnitude internally without direct label supervision.</p>
<p>Training and Evaluation We focus on a numerical interpolation setting (we revisit extrapolation</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 3: Our probing setup. We pass numbers through a pre-trained embedder (e.g., BERT, GloVe) and train a probing model to solve numerical tasks such as finding a list's maximum, decoding a number, or adding two numbers. If the probing model generalizes to held-out numbers, the pre-trained embeddings must contain numerical information. We provide numbers as either words (shown here), digits ("9"), floats ("9.1"), or negatives ("-9").
in Section 3.4): the model is tested on values that are within the training range. We first pick a range (we vary the range in our experiments) and randomly shuffle the integers over it. We then split $80 \%$ of the numbers into a training set and $20 \%$ into a test set. We report the mean and standard deviation across five different random shuffles for a particular range, using the exact same shuffles across all embedding methods.</p>
<p>Numbers are provided as integers ("75"), single-word form ("seventy-five"), floats ("75.1"), or negatives ("-75"). We consider positive numbers less than 100 for word-form numbers to avoid multiple tokens. We report the classification accuracy for the list maximum task ( 5 classes), and the Root Mean Squared Error (RMSE) for decoding and addition. Note that larger ranges will naturally amplify the RMSE error.</p>
<h3>3.2 Embedding Methods</h3>
<p>We evaluate various token embedding methods.
Word Vectors We use 300-dimensional GloVe (Pennington et al., 2014) and word2vec vectors Mikolov et al., 2018). We ensure all values are in-vocabulary for word vectors.
Contextualized Embeddings We use ELMo (Peters et al., 2018) and BERT (Devlin et al., 2019) embeddings. ${ }^{4}$ ELMo uses character-level convo-</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup>lutions of size 1-7 with max pooling. BERT represents tokens via sub-word pieces; we use lowercased BERT-base with 30k pieces.</p>
<p>NAQANet Embeddings We extract the GloVe embeddings and Char-CNN from the NAQANet model trained on DROP. We also consider an ablation that removes the GloVe embeddings.
Learned Embeddings We use a character-level CNN (Char-CNN) and a character-Level LSTM (Char-LSTM). We use left character padding, which greatly improves numeracy for characterlevel CNNs (details in Appendix B).
Untrained Embeddings We consider two untrained baselines. The first baseline is random token vectors, which trivially fail to generalize (there is no pattern between train and test numbers). These embeddings are useful for measuring the improvement of pre-trained embeddings. We also consider a randomly initialized and untrained Char-CNN and Char-LSTM.</p>
<p>Number's Value as Embedding The final embedding method is simple: map a number's embedding directly to its value (e.g., "seventy-five" embeds to [75]). We found this strategy performs poorly for large ranges; using a base-10 logarithmic scale improves performance. We report this as Value Embedding in our results. ${ }^{5}$</p>
<p><sup id="fnref2:1"><a class="footnote-ref" href="#fn:1">2</a></sup></p>
<p>All pre-trained embeddings (all methods except the Char-CNN and Char-LSTM) are fixed during training. The probing models are trained on the synthetic tasks on top of these embeddings.</p>
<h3>3.3 Results: Embeddings Capture Numeracy</h3>
<p>We find that all pre-trained embeddings contain fine-grained information about number magnitude and order. We first focus on integers (Table 4).</p>
<p>Word Vectors Succeed Both word2vec and GloVe significantly outperform the random vector baseline and are among the strongest methods overall. This is particularly surprising given the training methodology for these embeddings, e.g., a continuous bag of words objective can teach finegrained number magnitude.</p>
<p>Character-level Methods Dominate Models which use character-level information have a clear advantage over word-level models for encoding numbers. This is reflected in our probing results: character-level CNNs are the best architecture for capturing numeracy. For example, the NAQANet model without GloVe (only using its Char-CNN) and ELMo (uses a Char-CNN) are the strongest pre-trained methods, and a learned Char-CNN is the strongest method overall. The strength of the character-level convolutions seems to lie in the architectural prior-an untrained Char-CNN is surprisingly competitive. Similar results have been shown for images (Saxe et al., 2011): random CNNs are powerful feature extractors.</p>
<p>Sub-word Models Struggle BERT struggles for large ranges (e.g., $52 \%$ accuracy for list maximum for $[0,9999])$. We suspect this results from subword pieces being a poor method to encode digits: two numbers which are similar in value can have very different sub-word divisions.</p>
<p>A Linear Subspace Exists For small ranges on the decoding task (e.g., $[0,99]$ ), a linear model is competitive, i.e., a linear subspace captures number magnitude (Appendix D). For larger ranges (e.g., $[0,999]$ ), the linear model's performance degrades, especially for BERT.</p>
<p>Value Embedding Fails The Value Embedding method fails for large ranges. This is surprising as the embedding directly provides a number's value, thus, the synthetic tasks should be easy to solve. However, we had difficulty training models for
large ranges, even when using numerous architecture variants (e.g., tiny networks with 10 hidden units and tanh activations) and hyperparameters. Trask et al. (2018) discuss similar problems and ameliorate them using new neural architectures.</p>
<p>Words, Floats, and Negatives are Captured Finally, we probe the embeddings on word-form numbers, floats, and negatives. We observe similar trends for these inputs as integers: pre-trained models exhibit natural numeracy and learned embeddings are strong (Tables 5, 6, and 10). The ordering of the different embedding methods according to performance is also relatively consistent across the different input types. One notable exception is that BERT struggles on floats, which is likely a result of its sub-word pieces. We do not test word2vec and GloVe on floats/negatives because they are out-of-vocabulary.</p>
<h3>3.4 Probing Models Struggle to Extrapolate</h3>
<p>Thus far, our synthetic experiments evaluate on held-out values within the same range as the training data (i.e., numerical interpolation). In Section 2.5, we found that NAQANet struggles to extrapolate to values outside the training range. Is this an idiosyncrasy of NAQANet or is it a more general problem? We investigate this using a numerical extrapolation setting: we train models on a specific integer range and test them on values greater than the largest training number and smaller than the smallest training number.</p>
<p>Extrapolation for Decoding and Addition For decoding and addition, models struggle to extrapolate. Figure 1 shows the predictions for models trained on $80 \%$ of the values from [-500,500] and tested on held-out numbers in the range [2000, 2000] for six embedding types. The embedding methods fail to extrapolate in different ways, e.g., predictions using word2vec decrease almost monotonically as the input increases, while predictions using BERT are usually near the highest training value. Trask et al. (2018) also observe that models struggle outside the training range; they attribute this to failures in neural models themselves.</p>
<p>Extrapolation for List Maximum For the list maximum task, accuracies are closer to those in the interpolation setting, however, they still fall short. Table 7 shows the accuracy for models trained on the integer range $[0,150]$ and tested on</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Interpolation</th>
<th style="text-align: center;">List Maximum (5-classes)</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Decoding (RMSE)</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Addition (RMSE)</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Integer Range</td>
<td style="text-align: center;">$[0,99]$</td>
<td style="text-align: center;">$[0,999]$</td>
<td style="text-align: center;">$[0,9999]$</td>
<td style="text-align: center;">$[0,99]$</td>
<td style="text-align: center;">$[0,999]$</td>
<td style="text-align: center;">$[0,9999]$</td>
<td style="text-align: center;">$[0,99]$</td>
<td style="text-align: center;">$[0,999]$</td>
<td style="text-align: center;">$[0,9999]$</td>
</tr>
<tr>
<td style="text-align: center;">Random Vectors</td>
<td style="text-align: center;">0.16</td>
<td style="text-align: center;">0.23</td>
<td style="text-align: center;">0.21</td>
<td style="text-align: center;">29.86</td>
<td style="text-align: center;">292.88</td>
<td style="text-align: center;">2882.62</td>
<td style="text-align: center;">42.03</td>
<td style="text-align: center;">410.33</td>
<td style="text-align: center;">4389.39</td>
</tr>
<tr>
<td style="text-align: center;">Untrained CNN</td>
<td style="text-align: center;">0.97</td>
<td style="text-align: center;">0.87</td>
<td style="text-align: center;">0.84</td>
<td style="text-align: center;">2.64</td>
<td style="text-align: center;">9.67</td>
<td style="text-align: center;">44.40</td>
<td style="text-align: center;">1.41</td>
<td style="text-align: center;">14.43</td>
<td style="text-align: center;">69.14</td>
</tr>
<tr>
<td style="text-align: center;">Untrained LSTM</td>
<td style="text-align: center;">0.70</td>
<td style="text-align: center;">0.66</td>
<td style="text-align: center;">0.55</td>
<td style="text-align: center;">7.61</td>
<td style="text-align: center;">46.5</td>
<td style="text-align: center;">210.34</td>
<td style="text-align: center;">5.11</td>
<td style="text-align: center;">45.69</td>
<td style="text-align: center;">510.19</td>
</tr>
<tr>
<td style="text-align: center;">Value Embedding</td>
<td style="text-align: center;">0.99</td>
<td style="text-align: center;">0.88</td>
<td style="text-align: center;">0.68</td>
<td style="text-align: center;">1.20</td>
<td style="text-align: center;">11.23</td>
<td style="text-align: center;">275.50</td>
<td style="text-align: center;">0.30</td>
<td style="text-align: center;">15.98</td>
<td style="text-align: center;">654.33</td>
</tr>
<tr>
<td style="text-align: center;">Pre-trained</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Word2Vec</td>
<td style="text-align: center;">0.90</td>
<td style="text-align: center;">0.78</td>
<td style="text-align: center;">0.71</td>
<td style="text-align: center;">2.34</td>
<td style="text-align: center;">18.77</td>
<td style="text-align: center;">333.47</td>
<td style="text-align: center;">0.75</td>
<td style="text-align: center;">21.23</td>
<td style="text-align: center;">210.07</td>
</tr>
<tr>
<td style="text-align: center;">GloVe</td>
<td style="text-align: center;">0.90</td>
<td style="text-align: center;">0.78</td>
<td style="text-align: center;">0.72</td>
<td style="text-align: center;">2.23</td>
<td style="text-align: center;">13.77</td>
<td style="text-align: center;">174.21</td>
<td style="text-align: center;">0.80</td>
<td style="text-align: center;">16.51</td>
<td style="text-align: center;">180.31</td>
</tr>
<tr>
<td style="text-align: center;">ELMo</td>
<td style="text-align: center;">0.98</td>
<td style="text-align: center;">0.88</td>
<td style="text-align: center;">0.76</td>
<td style="text-align: center;">2.35</td>
<td style="text-align: center;">13.48</td>
<td style="text-align: center;">62.20</td>
<td style="text-align: center;">0.94</td>
<td style="text-align: center;">15.50</td>
<td style="text-align: center;">45.71</td>
</tr>
<tr>
<td style="text-align: center;">BERT</td>
<td style="text-align: center;">0.95</td>
<td style="text-align: center;">0.62</td>
<td style="text-align: center;">0.52</td>
<td style="text-align: center;">3.21</td>
<td style="text-align: center;">29.00</td>
<td style="text-align: center;">431.78</td>
<td style="text-align: center;">4.56</td>
<td style="text-align: center;">67.81</td>
<td style="text-align: center;">454.78</td>
</tr>
<tr>
<td style="text-align: center;">Learned</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Char-CNN</td>
<td style="text-align: center;">0.97</td>
<td style="text-align: center;">0.93</td>
<td style="text-align: center;">0.88</td>
<td style="text-align: center;">2.50</td>
<td style="text-align: center;">4.92</td>
<td style="text-align: center;">11.57</td>
<td style="text-align: center;">1.19</td>
<td style="text-align: center;">7.75</td>
<td style="text-align: center;">15.09</td>
</tr>
<tr>
<td style="text-align: center;">Char-LSTM</td>
<td style="text-align: center;">0.98</td>
<td style="text-align: center;">0.92</td>
<td style="text-align: center;">0.76</td>
<td style="text-align: center;">2.55</td>
<td style="text-align: center;">8.65</td>
<td style="text-align: center;">18.33</td>
<td style="text-align: center;">1.21</td>
<td style="text-align: center;">15.11</td>
<td style="text-align: center;">25.37</td>
</tr>
<tr>
<td style="text-align: center;">DROP-trained</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">NAQANet</td>
<td style="text-align: center;">0.91</td>
<td style="text-align: center;">0.81</td>
<td style="text-align: center;">0.72</td>
<td style="text-align: center;">2.99</td>
<td style="text-align: center;">14.19</td>
<td style="text-align: center;">62.17</td>
<td style="text-align: center;">1.11</td>
<td style="text-align: center;">11.33</td>
<td style="text-align: center;">90.01</td>
</tr>
<tr>
<td style="text-align: center;">- GloVe</td>
<td style="text-align: center;">0.88</td>
<td style="text-align: center;">0.90</td>
<td style="text-align: center;">0.82</td>
<td style="text-align: center;">2.87</td>
<td style="text-align: center;">5.34</td>
<td style="text-align: center;">35.39</td>
<td style="text-align: center;">1.45</td>
<td style="text-align: center;">9.91</td>
<td style="text-align: center;">60.70</td>
</tr>
</tbody>
</table>
<p>Table 4: Interpolation with integers (e.g., "18"). All pre-trained embedding methods (e.g., GloVe and ELMo) surprisingly capture numeracy. The probing model is trained on a randomly shuffled $80 \%$ of the Integer Range and tested on the remaining $20 \%$. The probing model architecture and train/test splits are equivalent across all embeddings. We show the mean over 5 random shuffles (standard deviation in Appendix D).</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Interpolation</th>
<th style="text-align: left;">List Maximum (5-classes)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Float Range</td>
<td style="text-align: left;">$[0.0,99.9]$</td>
</tr>
<tr>
<td style="text-align: left;">Rand. Vectors</td>
<td style="text-align: left;">$0.18 \pm 0.03$</td>
</tr>
<tr>
<td style="text-align: left;">ELMo</td>
<td style="text-align: left;">$0.91 \pm 0.03$</td>
</tr>
<tr>
<td style="text-align: left;">BERT</td>
<td style="text-align: left;">$0.82 \pm 0.05$</td>
</tr>
<tr>
<td style="text-align: left;">Char-CNN</td>
<td style="text-align: left;">$0.87 \pm 0.04$</td>
</tr>
<tr>
<td style="text-align: left;">Char-LSTM</td>
<td style="text-align: left;">$0.81 \pm 0.05$</td>
</tr>
</tbody>
</table>
<p>Table 5: Interpolation with floats (e.g., "18.1") for list maximum. Pre-trained embeddings capture numeracy for float values. The probing model is trained on a randomly shuffled $80 \%$ of the Float Range and tested on the remaining $20 \%$. See the text for details on selecting decimal values. We show the mean alongside the standard deviation over 5 different random shuffles.
the ranges [151,160], [151,180], and [151,200]; all methods struggle, especially token vectors.</p>
<h2>Augmenting Data to Aid Extrapolation Of</h2>
<p>course, in many real-word tasks it is possible to ameliorate these extrapolation failures by augmenting the training data (i.e., turn extrapolation into interpolation). Here, we apply this idea to aid in training NAQANet for DROP. For each superlative and comparative example, we duplicate the example and modify the numbers in its paragraph using the Add and Multiply techniques de-</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Interpolation</th>
<th style="text-align: center;">List Maximum (5-classes)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Integer Range</td>
<td style="text-align: center;">$[-50,50]$</td>
</tr>
<tr>
<td style="text-align: left;">Rand. Vectors</td>
<td style="text-align: center;">$0.23 \pm 0.12$</td>
</tr>
<tr>
<td style="text-align: left;">Word2Vec</td>
<td style="text-align: center;">$0.89 \pm 0.02$</td>
</tr>
<tr>
<td style="text-align: left;">GloVe</td>
<td style="text-align: center;">$0.89 \pm 0.03$</td>
</tr>
<tr>
<td style="text-align: left;">ELMo</td>
<td style="text-align: center;">$0.96 \pm 0.01$</td>
</tr>
<tr>
<td style="text-align: left;">BERT</td>
<td style="text-align: center;">$0.94 \pm 0.02$</td>
</tr>
<tr>
<td style="text-align: left;">Char-CNN</td>
<td style="text-align: center;">$0.95 \pm 0.07$</td>
</tr>
<tr>
<td style="text-align: left;">Char-LSTM</td>
<td style="text-align: center;">$0.97 \pm 0.02$</td>
</tr>
</tbody>
</table>
<p>Table 6: Interpolation with negatives (e.g., " -18 ") on list maximum. Pre-trained embeddings capture numeracy for negative values.
scribed in Section 2.5. Table 11 shows that this data augmentation can improve both interpolation and extrapolation, e.g., the accuracy on superlative questions with large numbers can double.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Extrapolation</th>
<th style="text-align: center;">List Maximum (5-classes)</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Test Range</td>
<td style="text-align: center;">$[151,160]$</td>
<td style="text-align: center;">$[151,180]$</td>
<td style="text-align: center;">$[151,200]$</td>
</tr>
<tr>
<td style="text-align: left;">Rand. Vectors</td>
<td style="text-align: center;">0.17</td>
<td style="text-align: center;">0.22</td>
<td style="text-align: center;">0.15</td>
</tr>
<tr>
<td style="text-align: left;">Untrained CNN</td>
<td style="text-align: center;">0.80</td>
<td style="text-align: center;">0.47</td>
<td style="text-align: center;">0.41</td>
</tr>
<tr>
<td style="text-align: left;">Pre-trained</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">Word2Vec</td>
<td style="text-align: center;">0.14</td>
<td style="text-align: center;">0.16</td>
<td style="text-align: center;">0.11</td>
</tr>
<tr>
<td style="text-align: left;">GloVe</td>
<td style="text-align: center;">0.19</td>
<td style="text-align: center;">0.17</td>
<td style="text-align: center;">0.21</td>
</tr>
<tr>
<td style="text-align: left;">ELMo</td>
<td style="text-align: center;">0.65</td>
<td style="text-align: center;">0.57</td>
<td style="text-align: center;">0.38</td>
</tr>
<tr>
<td style="text-align: left;">BERT</td>
<td style="text-align: center;">0.35</td>
<td style="text-align: center;">0.11</td>
<td style="text-align: center;">0.14</td>
</tr>
<tr>
<td style="text-align: left;">Learned</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">Char-CNN</td>
<td style="text-align: center;">0.81</td>
<td style="text-align: center;">0.75</td>
<td style="text-align: center;">0.73</td>
</tr>
<tr>
<td style="text-align: left;">Char-LSTM</td>
<td style="text-align: center;">$\mathbf{0 . 8 8}$</td>
<td style="text-align: center;">$\mathbf{0 . 8 4}$</td>
<td style="text-align: center;">$\mathbf{0 . 8 2}$</td>
</tr>
<tr>
<td style="text-align: left;">DROP</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">NAQANet</td>
<td style="text-align: center;">0.31</td>
<td style="text-align: center;">0.29</td>
<td style="text-align: center;">0.25</td>
</tr>
<tr>
<td style="text-align: left;">- GloVe</td>
<td style="text-align: center;">0.58</td>
<td style="text-align: center;">0.53</td>
<td style="text-align: center;">0.48</td>
</tr>
</tbody>
</table>
<p>Table 7: Extrapolation on list maximum. The probing model is trained on the integer range $[0,150]$ and evaluated on integers from the Test Range. The probing model struggles to extrapolate when trained on the pre-trained embeddings.</p>
<h2>4 Discussion and Related Work</h2>
<p>An open question is how the training process elicits numeracy for word vectors and contextualized embeddings. Understanding this, perhaps by tracing numeracy back to the training data, is a fruitful direction to explore further (c.f., influence functions (Koh and Liang, 2017; Brunet et al., 2019)).</p>
<p>More generally, numeracy is one type of emergent knowledge. For instance, embeddings may capture the size of objects (Forbes and Choi, 2017), speed of vehicles, and many other "commonsense" phenomena (Yang et al., 2018). Vendrov et al. (2016) introduce methods to encode the order of such phenomena into embeddings for concepts such as hypernymy; our work and Yang et al. (2018) show that a relative ordering naturally emerges for certain concepts.</p>
<p>In concurrent work, Naik et al. (2019) also explore numeracy in word vectors. Their methodology is based on variants of nearest neighbors and cosine distance; we use neural network probing classifiers which can capture highly non-linear dependencies between embeddings. We also explore more powerful embedding methods such as ELMo, BERT, and learned embedding methods.</p>
<p>Probing Models Our probes of numeracy parallel work in understanding the linguistic capabilities (literacy) of neural models (Conneau et al., 2018; Liu et al., 2019). LSTMs can remember sentence length, word order, and which words were present in a sentence (Adi et al., 2017). Khandel-
wal et al. (2018) show how language models leverage context, while Linzen et al. (2016) demonstrate that language models understand subjectverb agreement.</p>
<p>Numerical Value Prediction Spithourakis and Riedel (2018) improve the ability of language models to predict numbers, i.e., they go beyond categorical predictions over a fixed-size vocabulary. They focus on improving models; our focus is probing embeddings. Kotnis and García-Durán (2019) predict numerical attributes in knowledge bases, e.g., they develop models that try to predict the population of Paris.</p>
<p>Synthetic Numerical Tasks Similar to our synthetic numerical reasoning tasks, other work considers sorting (Graves et al., 2014), counting (Weiss et al., 2018), or decoding tasks (Trask et al., 2018). They use synthetic tasks as a testbed to prove or design better models, whereas we use synthetic tasks as a probe to understand token embeddings. In developing the Neural Arithmetic Logic Unit, Trask et al. (2018) arrive at similar conclusions regarding extrapolation: neural models have difficulty outputting numerical values outside the training range.</p>
<h2>5 Conclusion</h2>
<p>How much do NLP models know about numbers? By digging into a surprisingly successful model on a numerical reasoning dataset (DROP), we discover that pre-trained token representations naturally encode numeracy.</p>
<p>We analyze the limits of this numeracy, finding that CNNs are a particularly good prior (and likely the cause of ELMo's superior numeracy compared to BERT) and that it is difficult for neural models to extrapolate beyond the values seen during training. There are still many fruitful areas for future research, including discovering why numeracy naturally emerges in embeddings, and what other properties are similarly emergent.</p>
<h2>Acknowledgements</h2>
<p>We thank Mark Neumann, Suchin Gururangan, Pranav Goel, Shi Feng, Nikhil Kandpal, Dheeru Dua, the members of AllenNLP and UCI NLP, and the reviewers for their valuable feedback.</p>
<h2>References</h2>
<p>Yossi Adi, Einat Kermany, Yonatan Belinkov, Ofer Lavi, and Yoav Goldberg. 2017. Finegrained analysis of sentence embeddings using auxiliary prediction tasks. In $I C L R$.</p>
<p>Marc-Etienne Brunet, Colleen Alkalay-Houlihan, Ashton Anderson, and Richard Zemel. 2019. Understanding the origins of bias in word embeddings. In ICML.</p>
<p>Alexis Conneau, German Kruszewski, Guillaume Lample, Loïc Barrault, and Marco Baroni. 2018. What you can cram into a single vector: Probing sentence embeddings for linguistic properties. In $A C L$.</p>
<p>Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2019. BERT: pre-training of deep bidirectional transformers for language understanding. In NAACL.</p>
<p>Dheeru Dua, Yizhong Wang, Pradeep Dasigi, Gabriel Stanovsky, Sameer Singh, and Matt Gardner. 2019. DROP: A reading comprehension benchmark requiring discrete reasoning over paragraphs. In NAACL.</p>
<p>Maxwell Forbes and Yejin Choi. 2017. Verb physics: Relative physical knowledge of actions and objects. In $A C L$.</p>
<p>Alex Graves, Greg Wayne, and Ivo Danihelka. 2014. Neural turing machines. arXiv preprint arXiv:1410.5401.</p>
<p>Urvashi Khandelwal, He He, Peng Qi, and Dan Jurafsky. 2018. Sharp nearby, fuzzy far away: How neural language models use context. In $A C L$.</p>
<p>Pang Wei Koh and Percy Liang. 2017. Understanding black-box predictions via influence functions. In ICML.</p>
<p>Bhushan Kotnis and Alberto García-Durán. 2019. Learning numerical attributes in knowledge bases. In $A K B C$.</p>
<p>Jayant Krishnamurthy, Pradeep Dasigi, and Matt Gardner. 2017. Neural semantic parsing with type constraints for semi-structured tables. In EMNLP.</p>
<p>Tal Linzen, Emmanuel Dupoux, and Yoav Goldberg. 2016. Assessing the ability of LSTMs to learn syntax-sensitive dependencies. In TACL.</p>
<p>Nelson F Liu, Matt Gardner, Yonatan Belinkov, Matthew Peters, and Noah A Smith. 2019. Linguistic knowledge and transferability of contextual representations. In NAACL.</p>
<p>Tomas Mikolov, Edouard Grave, Piotr Bojanowski, Christian Puhrsch, and Armand Joulin. 2018. Advances in pre-training distributed word representations. In LREC.</p>
<p>Aakanksha Naik, Abhilasha Ravichander, Carolyn Rose, and Eduard Hovy. 2019. Exploring numeracy in word embeddings. In $A C L$.</p>
<p>Jeffrey Pennington, Richard Socher, and Christopher D. Manning. 2014. GloVe: Global vectors for word representation. In EMNLP.</p>
<p>Matthew E. Peters, Mark Neumann, Mohit Iyyer, Matt Gardner, Christopher Clark, Kenton Lee, and Luke Zettlemoyer. 2018. Deep contextualized word representations. In North American Association for Computational Linguistics.</p>
<p>Pranav Rajpurkar, Jian Zhang, Konstantin Lopyrev, and Percy Liang. 2016. SQuAD: 100,000+ questions for machine comprehension of text. In EMNLP.</p>
<p>Abhilasha Ravichander, Aakanksha Naik, Carolyn Rose, and Eduard Hovy. 2019. EQUATE: A benchmark evaluation framework for quantitative reasoning in natural language inference. arXiv preprint arXiv:1901.03735.</p>
<p>Andrew M Saxe, Pang Wei Koh, Zhenghao Chen, Maneesh Bhand, Bipin Suresh, and Andrew Y Ng. 2011. On random weights and unsupervised feature learning. In ICML.</p>
<p>David Saxton, Edward Grefenstette, Felix Hill, and Pushmeet Kohli. 2019. Analysing mathematical reasoning abilities of neural models.</p>
<p>Min Joon Seo, Aniruddha Kembhavi, Ali Farhadi, and Hannaneh Hajishirzi. 2017. Bidirectional attention flow for machine comprehension. In $I C L R$.</p>
<p>Georgios Spithourakis and Sebastian Riedel. 2018. Numeracy for language models: Evaluating and improving their ability to predict numbers. In $A C L$.</p>
<p>Andrew Trask, Felix Hill, Scott Reed, Jack W. Rae, Chris Dyer, and Phil Blunsom. 2018. Neural arithmetic logic units. In NeurIPS.</p>
<p>Ivan Vendrov, Ryan Kiros, Sanja Fidler, and Raquel Urtasun. 2016. Order-embeddings of images and language. In $I C L R$.</p>
<p>Oriol Vinyals, Samy Bengio, and Manjunath Kudlur. 2016. Order matters: Sequence to sequence for sets. In $I C L R$.</p>
<p>Gail Weiss, Yoav Goldberg, and Eran Yahav. 2018. On the practical computational power of finite precision rnns for language recognition. In $A C L$.</p>
<p>Yiben Yang, Larry Birnbaum, Ji-Ping Wang, and Doug Downey. 2018. Extracting commonsense properties from embeddings with limited human guidance. In $A C L$.</p>
<p>Adams Wei Yu, David Dohan, Minh-Thang Luong, Rui Zhao, Kai Chen, Mohammad Norouzi, and Quoc V. Le. 2018. QANet: Combining local convolution with global self-attention for reading comprehension. In $I C L R$.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{4}$ Since our inputs are numbers, not natural sentences, language models may exhibit strange behavior. We experimented with extracting the context-independent feature vector immediately following the character convolutions for ELMo but found little difference in results.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:1">
<p>${ }^{5}$ We suspect the failures result from the raw values being too high in magnitude and/or variance for the model. We also experimented with normalizing the values to mean 0 and variance 1; a logarithmic scale performed better.&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 2 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:1" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>