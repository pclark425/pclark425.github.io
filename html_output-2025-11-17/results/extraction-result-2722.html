<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-2722 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-2722</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-2722</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-70.html">extraction-schema-70</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve text games, including details about the memory architecture, performance comparisons, and what makes memory effective or ineffective.</div>
                <p><strong>Paper ID:</strong> paper-211205094</p>
                <p><strong>Paper Title:</strong> <a href="https://arxiv.org/pdf/2002.08795v1.pdf" target="_blank">How To Avoid Being Eaten By a Grue: Exploration Strategies for Text-Adventure Agents</a></p>
                <p><strong>Paper Abstract:</strong> Text-based games -- in which an agent interacts with the world through textual natural language -- present us with the problem of combinatorially-sized action-spaces. Most current reinforcement learning algorithms are not capable of effectively handling such a large number of possible actions per turn. Poor sample efficiency, consequently, results in agents that are unable to pass bottleneck states, where they are unable to proceed because they do not see the right action sequence to pass the bottleneck enough times to be sufficiently reinforced. Building on prior work using knowledge graphs in reinforcement learning, we introduce two new game state exploration strategies. We compare our exploration strategies against strong baselines on the classic text-adventure game, Zork1, where prior agent have been unable to get past a bottleneck where the agent is eaten by a Grue.</p>
                <p><strong>Cost:</strong> 0.012</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e2722.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e2722.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve text games, including details about the memory architecture, performance comparisons, and what makes memory effective or ineffective.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>KG-A2C</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Knowledge Graph A2C</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An A2C-based reinforcement learning agent that augments its observation encoding with a continuously updated knowledge graph of extracted (subject, relation, object) triples to represent game state and constrain action selection in large natural-language action spaces.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Graph constrained reinforcement learning for natural language action spaces.</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>KG-A2C</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>An Advantage Actor-Critic (A2C) RL agent that uses a dual input: textual observation encoded by recurrent networks and a structured knowledge graph built from OpenIE plus game-specific rules; the graph is used to mask/constrain template-based action generation and as part of the state encoding.</td>
                        </tr>
                        <tr>
                            <td><strong>base_model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>game_benchmark_name</strong></td>
                            <td>Zork1 (via Jericho)</td>
                        </tr>
                        <tr>
                            <td><strong>game_description</strong></td>
                            <td>Classic text-adventure (interactive fiction) benchmark featuring partial observability, long-horizon quests, combinatorially large natural-language action space (template-based), and bottlenecks such as a dark cellar where a lamp must be lit to avoid death.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_memory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>graph-based memory (knowledge graph)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_structure</strong></td>
                            <td>A knowledge graph composed of 3-tuples (subject, relation, object); nodes for rooms, objects, and a special "you" node for inventory; edges indicate object-room membership, attributes, and affordances.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_content</strong></td>
                            <td>Discovered interactive objects, object attributes and affordances, which room objects are in, inferred relative positions of rooms (from navigation), and items in the agent's inventory.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_capacity</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_strategy</strong></td>
                            <td>Direct use of the current knowledge-graph snapshot as part of the state encoding and to constrain entity choices in template actions; also used as a cell representation for Go-Explore by taking a snapshot of the graph.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_update_strategy</strong></td>
                            <td>After each observation triples are extracted using Stanford OpenIE plus additional hand-crafted rules for interactive-fiction specifics (POS tagging to find candidate objects, examine-ability checks, and navigation inference); inventory items linked to "you" node; graph updated each turn.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_usage_purpose</strong></td>
                            <td>To mitigate partial observability by accumulating world knowledge, to constrain/compress the enormous template-entity action space (filter admissible entities), and to provide a richer cell/state representation for exploration algorithms.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>Qualitative: KG-A2C (with enhanced exploration in this paper) is able to pass the Zork1 bottleneck (lighting lamp in cellar) that corresponds to score ~40 and achieve higher final scores; earlier KG-A2C work reached score 40 in Zork1. (No detailed numeric averages beyond the score-40 bottleneck are reported in this paper.)</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td>Qualitative baseline: A2C (text-only recurrent encoding without knowledge graph) fails to pass the score-40 bottleneck; A2C-Explore reaches the bottleneck but cannot surpass it. (No precise numeric metrics reported beyond these descriptions.)</td>
                        </tr>
                        <tr>
                            <td><strong>has_memory_ablation</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_effectiveness_findings</strong></td>
                            <td>The knowledge graph is critical: it improves handling of partial observability and implicitly increases sample efficiency for bottleneck detection and targeted exploration; as a cell representation it better indicates promising states than raw textual encodings; however, the KG alone is insufficient without enhanced exploration strategies to pass bottlenecks.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_limitations</strong></td>
                            <td>The KG requires additional handcrafted rules because OpenIE alone misses semi-structured IF content; the graph representation alone does not guarantee passing bottlenecks (needs enhanced exploration); freezing policies based on KG-detected bottlenecks can lead to locally suboptimal policies unless backtracking is used.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other_memory_types</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>best_memory_configuration</strong></td>
                            <td>KG + policy chaining with backtracking (KG-A2C-chained) yielded the best sample efficiency and fastest convergence for passing the Zork1 bottleneck; KG used as a cell representation in Go-Explore (KG-A2C-Explore) also passes the bottleneck but is slower to converge.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'How To Avoid Being Eaten By a Grue: Exploration Strategies for Text-Adventure Agents', 'publication_date_yy_mm': '2020-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e2722.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e2722.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve text games, including details about the memory architecture, performance comparisons, and what makes memory effective or ineffective.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>KG-A2C-chained</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>KG-A2C with Policy Chaining and Backtracking</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A variant of KG-A2C that detects bottlenecks by monitoring score progress, freezes the policy that reached the locally highest score, and starts training a new policy from that state with a backtracking buffer to avoid freezing sub-optimal policies.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>KG-A2C-chained</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Extends KG-A2C by adding a bottleneck detection mechanism (patience parameter) that when triggered freezes the policy to reach the best-seen bottleneck state and then trains a new policy from that state; includes a backtracking buffer of prior states to restart exploration from earlier points if needed.</td>
                        </tr>
                        <tr>
                            <td><strong>base_model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>game_benchmark_name</strong></td>
                            <td>Zork1 (via Jericho)</td>
                        </tr>
                        <tr>
                            <td><strong>game_description</strong></td>
                            <td>Classic text-adventure with long-horizon dependencies and critical bottlenecks (e.g., need to light a lamp in a dark cellar to avoid death by grue).</td>
                        </tr>
                        <tr>
                            <td><strong>uses_memory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>graph-based memory (knowledge graph)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_structure</strong></td>
                            <td>Same knowledge graph structure as KG-A2C (3-tuple graph snapshot) used as the state from which policies are frozen and new policies are trained.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_content</strong></td>
                            <td>Same as KG-A2C: objects, attributes, affordances, room links, inventory, and inferred navigation relations.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_capacity</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_strategy</strong></td>
                            <td>Uses snapshots of the knowledge graph at bottleneck states as starting points for policy freezing and subsequent training; retrieval is essentially direct snapshot/lookup from the backtracking buffer.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_update_strategy</strong></td>
                            <td>Continued incremental updates via OpenIE plus rules on each observation; the chaining algorithm stores recent state snapshots/actions in a buffer of size n (hyperparameter) for backtracking.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_usage_purpose</strong></td>
                            <td>Used to define and store the state at which to freeze policies, to provide an efficient starting state for retraining and exploration after bottleneck detection, and to enable efficient backtracking.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>Qualitative: KG-A2C-chained consistently passes the Zork1 lamp/grue bottleneck (score ~40) and is significantly more sample-efficient and faster to converge than KG-A2C-Explore; reaches comparable final scores to KG-A2C-Explore within margin of error.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td>N/A for this variant (relies on KG); compared against A2C-chained (no KG) which fails to outperform baseline A2C.</td>
                        </tr>
                        <tr>
                            <td><strong>has_memory_ablation</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_effectiveness_findings</strong></td>
                            <td>Chaining policies with KG-based bottleneck detection and backtracking is particularly effective for acyclic, sequential decision structures like those in Zork1; KG improves efficiency of detecting bottlenecks and makes backtracking-based exploration more sample efficient.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_limitations</strong></td>
                            <td>Risk of freezing a globally sub-optimal policy which necessitates backtracking; KG alone without chaining is insufficient to reliably pass bottlenecks.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other_memory_types</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>best_memory_configuration</strong></td>
                            <td>This paper finds KG + chaining + backtracking the best configuration for sample efficiency and speed of convergence on Zork1 bottleneck problems.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'How To Avoid Being Eaten By a Grue: Exploration Strategies for Text-Adventure Agents', 'publication_date_yy_mm': '2020-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e2722.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e2722.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve text games, including details about the memory architecture, performance comparisons, and what makes memory effective or ineffective.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>KG-A2C-Explore</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>KG-A2C with Go-Explore Phase-1 (KG-informed Go-Explore)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A hybrid that runs Phase 1 of Go-Explore while using the KG-A2C agent in parallel; cell representations include snapshots of the knowledge graph plus game state, and KG-A2C is trained from sampled cells to expand promising trajectories.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>KG-A2C-Explore</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Combines KG-A2C state encoding with Phase-1 Go-Explore: Go-Explore keeps an archive of cells (here represented by KG snapshots and game state), samples promising cells (weighted by score), and runs KG-A2C from those cells for a fixed number of steps (cell step size) to discover higher-reward trajectories.</td>
                        </tr>
                        <tr>
                            <td><strong>base_model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>game_benchmark_name</strong></td>
                            <td>Zork1 (via Jericho)</td>
                        </tr>
                        <tr>
                            <td><strong>game_description</strong></td>
                            <td>Classic text-adventure with large template-action space and sparse rewards; exploration requires finding long-delayed actions (e.g., lighting a lamp much earlier or later) to pass bottlenecks.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_memory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>graph-based memory (knowledge graph) used as cell/state memory</td>
                        </tr>
                        <tr>
                            <td><strong>memory_structure</strong></td>
                            <td>Cells in the Go-Explore archive are encoded using snapshots of the knowledge graph combined with the last seen textual game state; the graph is therefore used as the representation of a cell.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_content</strong></td>
                            <td>Snapshots of the knowledge graph (objects, room links, inventory, attributes) plus the last observed textual state for that cell.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_capacity</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_strategy</strong></td>
                            <td>Cell selection in Go-Explore is weighted by score; when a cell is sampled its KG snapshot and last state are used to initialize KG-A2C for exploration from that state (i.e., retrieval is selection-by-cell).</td>
                        </tr>
                        <tr>
                            <td><strong>memory_update_strategy</strong></td>
                            <td>When KG-A2C runs from a cell it updates its KG incrementally as normal; after expanding a cell Go-Explore updates its archive with the new cell/state if better or new.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_usage_purpose</strong></td>
                            <td>To provide a richer, more discriminative cell representation for Go-Explore so that promising states are better identified and expanded; also to provide richer starting state for KG-A2C training during exploration.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>Qualitative: KG-A2C-Explore consistently passes the Zork1 bottleneck (lighting the lamp) and achieves comparable final scores to KG-A2C-chained, but it takes longer to converge (less sample-efficient) than KG-A2C-chained.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td>Compared to A2C-Explore (Go-Explore with recurrent-text cell encoding) the KG-informed version eventually passes the bottleneck while A2C-Explore converges faster but to a lower-reward trajectory that fails to pass the bottleneck.</td>
                        </tr>
                        <tr>
                            <td><strong>has_memory_ablation</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_effectiveness_findings</strong></td>
                            <td>Knowledge-graph-based cell representations are better indicators of promising states than recurrent-text encodings; integrating KG with Go-Explore improves the ability to pass long-horizon bottlenecks, though it is slower to converge than policy-chaining.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_limitations</strong></td>
                            <td>Slower convergence/sample inefficiency relative to KG-A2C-chained; relies on the efficacy of cell-weighting and periodic expansion—KG improves cell representation but does not overcome all exploration challenges alone.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other_memory_types</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>best_memory_configuration</strong></td>
                            <td>KG used as a cell representation in Go-Explore improves final performance (able to pass bottleneck) compared to text-only cell encodings, but KG + chaining/backtracking was found to be faster and more sample-efficient in this work.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'How To Avoid Being Eaten By a Grue: Exploration Strategies for Text-Adventure Agents', 'publication_date_yy_mm': '2020-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e2722.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e2722.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve text games, including details about the memory architecture, performance comparisons, and what makes memory effective or ineffective.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>A2C (baseline)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Advantage Actor-Critic (text-only) baseline</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A standard A2C RL agent using only textual observation encoding (recurrent networks) without a knowledge-graph state representation; used as a baseline to evaluate the effect of graph-based memory.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>A2C</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>A2C reinforcement learning agent that encodes observations using recurrent neural networks (text-only) and selects template-based actions without graph-constrained entity filtering.</td>
                        </tr>
                        <tr>
                            <td><strong>base_model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>game_benchmark_name</strong></td>
                            <td>Zork1 (via Jericho)</td>
                        </tr>
                        <tr>
                            <td><strong>game_description</strong></td>
                            <td>See above: classic text-adventure with sparse rewards, long-horizon dependencies, and bottlenecks.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_memory</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_structure</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_content</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_capacity</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_strategy</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_update_strategy</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_usage_purpose</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td>Baseline performance reported qualitatively: A2C fails to pass the score-40 bottleneck in Zork1; A2C-chained (policy chaining without KG) fails to outperform A2C; A2C-Explore (Go-Explore with text-only cells) converges faster but to a lower reward that does not pass the bottleneck.</td>
                        </tr>
                        <tr>
                            <td><strong>has_memory_ablation</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>memory_effectiveness_findings</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_limitations</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other_memory_types</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>best_memory_configuration</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'How To Avoid Being Eaten By a Grue: Exploration Strategies for Text-Adventure Agents', 'publication_date_yy_mm': '2020-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Graph constrained reinforcement learning for natural language action spaces. <em>(Rating: 2)</em></li>
                <li>Playing text-adventure games with graph-based deep reinforcement learning. <em>(Rating: 2)</em></li>
                <li>Exploration based language learning for text-based games. <em>(Rating: 2)</em></li>
                <li>Go-explore: a new approach for hard-exploration problems. <em>(Rating: 2)</em></li>
                <li>Textworld: A learning environment for text-based games. <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-2722",
    "paper_id": "paper-211205094",
    "extraction_schema_id": "extraction-schema-70",
    "extracted_data": [
        {
            "name_short": "KG-A2C",
            "name_full": "Knowledge Graph A2C",
            "brief_description": "An A2C-based reinforcement learning agent that augments its observation encoding with a continuously updated knowledge graph of extracted (subject, relation, object) triples to represent game state and constrain action selection in large natural-language action spaces.",
            "citation_title": "Graph constrained reinforcement learning for natural language action spaces.",
            "mention_or_use": "use",
            "agent_name": "KG-A2C",
            "agent_description": "An Advantage Actor-Critic (A2C) RL agent that uses a dual input: textual observation encoded by recurrent networks and a structured knowledge graph built from OpenIE plus game-specific rules; the graph is used to mask/constrain template-based action generation and as part of the state encoding.",
            "base_model_size": null,
            "game_benchmark_name": "Zork1 (via Jericho)",
            "game_description": "Classic text-adventure (interactive fiction) benchmark featuring partial observability, long-horizon quests, combinatorially large natural-language action space (template-based), and bottlenecks such as a dark cellar where a lamp must be lit to avoid death.",
            "uses_memory": true,
            "memory_type": "graph-based memory (knowledge graph)",
            "memory_structure": "A knowledge graph composed of 3-tuples (subject, relation, object); nodes for rooms, objects, and a special \"you\" node for inventory; edges indicate object-room membership, attributes, and affordances.",
            "memory_content": "Discovered interactive objects, object attributes and affordances, which room objects are in, inferred relative positions of rooms (from navigation), and items in the agent's inventory.",
            "memory_capacity": null,
            "memory_retrieval_strategy": "Direct use of the current knowledge-graph snapshot as part of the state encoding and to constrain entity choices in template actions; also used as a cell representation for Go-Explore by taking a snapshot of the graph.",
            "memory_update_strategy": "After each observation triples are extracted using Stanford OpenIE plus additional hand-crafted rules for interactive-fiction specifics (POS tagging to find candidate objects, examine-ability checks, and navigation inference); inventory items linked to \"you\" node; graph updated each turn.",
            "memory_usage_purpose": "To mitigate partial observability by accumulating world knowledge, to constrain/compress the enormous template-entity action space (filter admissible entities), and to provide a richer cell/state representation for exploration algorithms.",
            "performance_with_memory": "Qualitative: KG-A2C (with enhanced exploration in this paper) is able to pass the Zork1 bottleneck (lighting lamp in cellar) that corresponds to score ~40 and achieve higher final scores; earlier KG-A2C work reached score 40 in Zork1. (No detailed numeric averages beyond the score-40 bottleneck are reported in this paper.)",
            "performance_without_memory": "Qualitative baseline: A2C (text-only recurrent encoding without knowledge graph) fails to pass the score-40 bottleneck; A2C-Explore reaches the bottleneck but cannot surpass it. (No precise numeric metrics reported beyond these descriptions.)",
            "has_memory_ablation": true,
            "memory_effectiveness_findings": "The knowledge graph is critical: it improves handling of partial observability and implicitly increases sample efficiency for bottleneck detection and targeted exploration; as a cell representation it better indicates promising states than raw textual encodings; however, the KG alone is insufficient without enhanced exploration strategies to pass bottlenecks.",
            "memory_limitations": "The KG requires additional handcrafted rules because OpenIE alone misses semi-structured IF content; the graph representation alone does not guarantee passing bottlenecks (needs enhanced exploration); freezing policies based on KG-detected bottlenecks can lead to locally suboptimal policies unless backtracking is used.",
            "comparison_with_other_memory_types": true,
            "best_memory_configuration": "KG + policy chaining with backtracking (KG-A2C-chained) yielded the best sample efficiency and fastest convergence for passing the Zork1 bottleneck; KG used as a cell representation in Go-Explore (KG-A2C-Explore) also passes the bottleneck but is slower to converge.",
            "uuid": "e2722.0",
            "source_info": {
                "paper_title": "How To Avoid Being Eaten By a Grue: Exploration Strategies for Text-Adventure Agents",
                "publication_date_yy_mm": "2020-02"
            }
        },
        {
            "name_short": "KG-A2C-chained",
            "name_full": "KG-A2C with Policy Chaining and Backtracking",
            "brief_description": "A variant of KG-A2C that detects bottlenecks by monitoring score progress, freezes the policy that reached the locally highest score, and starts training a new policy from that state with a backtracking buffer to avoid freezing sub-optimal policies.",
            "citation_title": "here",
            "mention_or_use": "use",
            "agent_name": "KG-A2C-chained",
            "agent_description": "Extends KG-A2C by adding a bottleneck detection mechanism (patience parameter) that when triggered freezes the policy to reach the best-seen bottleneck state and then trains a new policy from that state; includes a backtracking buffer of prior states to restart exploration from earlier points if needed.",
            "base_model_size": null,
            "game_benchmark_name": "Zork1 (via Jericho)",
            "game_description": "Classic text-adventure with long-horizon dependencies and critical bottlenecks (e.g., need to light a lamp in a dark cellar to avoid death by grue).",
            "uses_memory": true,
            "memory_type": "graph-based memory (knowledge graph)",
            "memory_structure": "Same knowledge graph structure as KG-A2C (3-tuple graph snapshot) used as the state from which policies are frozen and new policies are trained.",
            "memory_content": "Same as KG-A2C: objects, attributes, affordances, room links, inventory, and inferred navigation relations.",
            "memory_capacity": null,
            "memory_retrieval_strategy": "Uses snapshots of the knowledge graph at bottleneck states as starting points for policy freezing and subsequent training; retrieval is essentially direct snapshot/lookup from the backtracking buffer.",
            "memory_update_strategy": "Continued incremental updates via OpenIE plus rules on each observation; the chaining algorithm stores recent state snapshots/actions in a buffer of size n (hyperparameter) for backtracking.",
            "memory_usage_purpose": "Used to define and store the state at which to freeze policies, to provide an efficient starting state for retraining and exploration after bottleneck detection, and to enable efficient backtracking.",
            "performance_with_memory": "Qualitative: KG-A2C-chained consistently passes the Zork1 lamp/grue bottleneck (score ~40) and is significantly more sample-efficient and faster to converge than KG-A2C-Explore; reaches comparable final scores to KG-A2C-Explore within margin of error.",
            "performance_without_memory": "N/A for this variant (relies on KG); compared against A2C-chained (no KG) which fails to outperform baseline A2C.",
            "has_memory_ablation": true,
            "memory_effectiveness_findings": "Chaining policies with KG-based bottleneck detection and backtracking is particularly effective for acyclic, sequential decision structures like those in Zork1; KG improves efficiency of detecting bottlenecks and makes backtracking-based exploration more sample efficient.",
            "memory_limitations": "Risk of freezing a globally sub-optimal policy which necessitates backtracking; KG alone without chaining is insufficient to reliably pass bottlenecks.",
            "comparison_with_other_memory_types": false,
            "best_memory_configuration": "This paper finds KG + chaining + backtracking the best configuration for sample efficiency and speed of convergence on Zork1 bottleneck problems.",
            "uuid": "e2722.1",
            "source_info": {
                "paper_title": "How To Avoid Being Eaten By a Grue: Exploration Strategies for Text-Adventure Agents",
                "publication_date_yy_mm": "2020-02"
            }
        },
        {
            "name_short": "KG-A2C-Explore",
            "name_full": "KG-A2C with Go-Explore Phase-1 (KG-informed Go-Explore)",
            "brief_description": "A hybrid that runs Phase 1 of Go-Explore while using the KG-A2C agent in parallel; cell representations include snapshots of the knowledge graph plus game state, and KG-A2C is trained from sampled cells to expand promising trajectories.",
            "citation_title": "here",
            "mention_or_use": "use",
            "agent_name": "KG-A2C-Explore",
            "agent_description": "Combines KG-A2C state encoding with Phase-1 Go-Explore: Go-Explore keeps an archive of cells (here represented by KG snapshots and game state), samples promising cells (weighted by score), and runs KG-A2C from those cells for a fixed number of steps (cell step size) to discover higher-reward trajectories.",
            "base_model_size": null,
            "game_benchmark_name": "Zork1 (via Jericho)",
            "game_description": "Classic text-adventure with large template-action space and sparse rewards; exploration requires finding long-delayed actions (e.g., lighting a lamp much earlier or later) to pass bottlenecks.",
            "uses_memory": true,
            "memory_type": "graph-based memory (knowledge graph) used as cell/state memory",
            "memory_structure": "Cells in the Go-Explore archive are encoded using snapshots of the knowledge graph combined with the last seen textual game state; the graph is therefore used as the representation of a cell.",
            "memory_content": "Snapshots of the knowledge graph (objects, room links, inventory, attributes) plus the last observed textual state for that cell.",
            "memory_capacity": null,
            "memory_retrieval_strategy": "Cell selection in Go-Explore is weighted by score; when a cell is sampled its KG snapshot and last state are used to initialize KG-A2C for exploration from that state (i.e., retrieval is selection-by-cell).",
            "memory_update_strategy": "When KG-A2C runs from a cell it updates its KG incrementally as normal; after expanding a cell Go-Explore updates its archive with the new cell/state if better or new.",
            "memory_usage_purpose": "To provide a richer, more discriminative cell representation for Go-Explore so that promising states are better identified and expanded; also to provide richer starting state for KG-A2C training during exploration.",
            "performance_with_memory": "Qualitative: KG-A2C-Explore consistently passes the Zork1 bottleneck (lighting the lamp) and achieves comparable final scores to KG-A2C-chained, but it takes longer to converge (less sample-efficient) than KG-A2C-chained.",
            "performance_without_memory": "Compared to A2C-Explore (Go-Explore with recurrent-text cell encoding) the KG-informed version eventually passes the bottleneck while A2C-Explore converges faster but to a lower-reward trajectory that fails to pass the bottleneck.",
            "has_memory_ablation": true,
            "memory_effectiveness_findings": "Knowledge-graph-based cell representations are better indicators of promising states than recurrent-text encodings; integrating KG with Go-Explore improves the ability to pass long-horizon bottlenecks, though it is slower to converge than policy-chaining.",
            "memory_limitations": "Slower convergence/sample inefficiency relative to KG-A2C-chained; relies on the efficacy of cell-weighting and periodic expansion—KG improves cell representation but does not overcome all exploration challenges alone.",
            "comparison_with_other_memory_types": true,
            "best_memory_configuration": "KG used as a cell representation in Go-Explore improves final performance (able to pass bottleneck) compared to text-only cell encodings, but KG + chaining/backtracking was found to be faster and more sample-efficient in this work.",
            "uuid": "e2722.2",
            "source_info": {
                "paper_title": "How To Avoid Being Eaten By a Grue: Exploration Strategies for Text-Adventure Agents",
                "publication_date_yy_mm": "2020-02"
            }
        },
        {
            "name_short": "A2C (baseline)",
            "name_full": "Advantage Actor-Critic (text-only) baseline",
            "brief_description": "A standard A2C RL agent using only textual observation encoding (recurrent networks) without a knowledge-graph state representation; used as a baseline to evaluate the effect of graph-based memory.",
            "citation_title": "",
            "mention_or_use": "use",
            "agent_name": "A2C",
            "agent_description": "A2C reinforcement learning agent that encodes observations using recurrent neural networks (text-only) and selects template-based actions without graph-constrained entity filtering.",
            "base_model_size": null,
            "game_benchmark_name": "Zork1 (via Jericho)",
            "game_description": "See above: classic text-adventure with sparse rewards, long-horizon dependencies, and bottlenecks.",
            "uses_memory": false,
            "memory_type": null,
            "memory_structure": null,
            "memory_content": null,
            "memory_capacity": null,
            "memory_retrieval_strategy": null,
            "memory_update_strategy": null,
            "memory_usage_purpose": null,
            "performance_with_memory": null,
            "performance_without_memory": "Baseline performance reported qualitatively: A2C fails to pass the score-40 bottleneck in Zork1; A2C-chained (policy chaining without KG) fails to outperform A2C; A2C-Explore (Go-Explore with text-only cells) converges faster but to a lower reward that does not pass the bottleneck.",
            "has_memory_ablation": false,
            "memory_effectiveness_findings": null,
            "memory_limitations": null,
            "comparison_with_other_memory_types": false,
            "best_memory_configuration": null,
            "uuid": "e2722.3",
            "source_info": {
                "paper_title": "How To Avoid Being Eaten By a Grue: Exploration Strategies for Text-Adventure Agents",
                "publication_date_yy_mm": "2020-02"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Graph constrained reinforcement learning for natural language action spaces.",
            "rating": 2,
            "sanitized_title": "graph_constrained_reinforcement_learning_for_natural_language_action_spaces"
        },
        {
            "paper_title": "Playing text-adventure games with graph-based deep reinforcement learning.",
            "rating": 2,
            "sanitized_title": "playing_textadventure_games_with_graphbased_deep_reinforcement_learning"
        },
        {
            "paper_title": "Exploration based language learning for text-based games.",
            "rating": 2,
            "sanitized_title": "exploration_based_language_learning_for_textbased_games"
        },
        {
            "paper_title": "Go-explore: a new approach for hard-exploration problems.",
            "rating": 2,
            "sanitized_title": "goexplore_a_new_approach_for_hardexploration_problems"
        },
        {
            "paper_title": "Textworld: A learning environment for text-based games.",
            "rating": 1,
            "sanitized_title": "textworld_a_learning_environment_for_textbased_games"
        }
    ],
    "cost": 0.011671,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>HOW TO AVOID BEING EATEN BY A GRUE: EXPLO- RATION STRATEGIES FOR TEXT-ADVENTURE AGENTS</p>
<p>Prithviraj Ammanabrolu raj.ammanabrolu@gatech.edu 
Georgia Institute of Technology</p>
<p>Ethan Tien etien@gatech.edu 
Georgia Institute of Technology</p>
<p>Zhaochen Luo zluo@gatech.edu 
Georgia Institute of Technology</p>
<p>Mark O Riedl riedl@gatech.edu 
Georgia Institute of Technology</p>
<p>HOW TO AVOID BEING EATEN BY A GRUE: EXPLO- RATION STRATEGIES FOR TEXT-ADVENTURE AGENTS</p>
<p>Text-based games-in which an agent interacts with the world through textual natural language-present us with the problem of combinatorially-sized actionspaces. Most current reinforcement learning algorithms are not capable of effectively handling such a large number of possible actions per turn. Poor sample efficiency, consequently, results in agents that are unable to pass bottleneck states, where they are unable to proceed because they do not see the right action sequence to pass the bottleneck enough times to be sufficiently reinforced. Building on prior work using knowledge graphs in reinforcement learning, we introduce two new game state exploration strategies. We compare our exploration strategies against strong baselines on the classic text-adventure game, Zork1, where prior agent have been unable to get past a bottleneck where the agent is eaten by a Grue.</p>
<p>INTRODUCTION AND BACKGROUND</p>
<p>Many reinforcement learning algorithms are designed for relatively small discrete or continuous action spaces and so have trouble scaling. Text-adventure games-or interaction fictions-are simulations in which both an agents' state and action spaces are in textual natural language. An example of a one turn agent interaction in the popular text-game Zork1 can be seen in Fig. 1a. Text-adventure games provide us with multiple challenges in the form of partial observability, commonsense reasoning, and a combinatorially-sized state-action space. Text-adventure games are structured as long puzzles or quests, interspersed with bottlenecks. The quests can usually be completed through multiple branching paths. However, games can also feature one or more bottlenecks. Bottlenecks are areas that an agent must pass through in order to progress to the next section of the game regardless of what path the agent has taken to complete that section of the quest (Stolle &amp; Precup, 2002). In this work, we focus on more effectively exploring this space and surpassing these bottlenecks-building on prior work that focuses on tackling the other problems.</p>
<p>Formally, we use the definition of text-adventure games as seen in Côté et al. (2018) and Hausknecht et al. (2019). These games are partially observable Markov decision processes (POMDPs), represented as a 7-tuple of S, T, A, Ω, O, R, γ representing the set of environment states, mostly deterministic conditional transition probabilities between states, the vocabulary or words used to compose text commands, observations returned by the game, observation conditional probabilities, reward function, and the discount factor respectively. For our purposes, understanding the exact state and action spaces we use in this work is critical and so we define each of these in relative depth.</p>
<p>Action-Space. To solve Zork1, the cannonical text-adventure games, requires the generation of actions consisting of up to five-words from a relatively modest vocabulary of 697 words recognized by the games parser. This results in O(697 5 ) = 1.64 × 10 14 possible actions at every step. To facilitate text-adventure game playing, Hausknecht et al. (2019) introduce Jericho 1 , a framework for interacting with text-games. They propose a template-based action space in which the agent first selects a template, consisting of an action verb and preposition, and then filling that in with relevant entities (e.g.</p>
<p>[get] [f rom] ). Zork1 has 237 templates, each with up to two blanks, yielding a template-action space of size O(237 × 697 2 ) = 1.15 × 10 8 . This space is still far larger than most used by previous approaches applying reinforcement learning to text-based games.</p>
<p>Observation: West of House You are standing in an open field west of a white house, with a boarded front door. There is a small mailbox here.</p>
<p>Action: Open mailbox</p>
<p>Observation: Opening the small mailbox reveals a leaflet.</p>
<p>Action: Read leaflet</p>
<p>Observation: (Taken) "WELCOME TO ZORK! ZORK is a game of adventure, danger, and low cunning. In it you will explore some of the most amazing territory ever seen by mortals. No computer should be without one!" (a) Excerpt from the initial stages of Zork1.  State-Representation. Prior work has shown that knowledge graphs are effective in terms of dealing with the challenges of partial observability (Ammanabrolu &amp; Riedl 2019a;2019b). A knowledge graph is a set of 3-tuples of the form subject, relation, object . These triples are extracted from the observations using Stanford's Open Information Extraction (OpenIE) (Angeli et al., 2015). Human-made text-adventure games often contain relatively complex semi-structured information that OpenIE is not designed to parse and so they add additional rules to ensure that the correct information is parsed. The graph itself is more or less a map of the world, with information about objects' affordances and attributes linked to the rooms that they are place in a map. The graph also makes a distinction with respect to items that are in the agent's possession or in their immediate surrounding environment. An example of what the knowledge graph looks like and specific implementation details can be found in Appendix A.2.</p>
<p>Ammanabrolu &amp; Hausknecht (2020) introduce the KG-A2C, 2 which uses a knowledge graph based state-representation to aid in the section of actions in a combinatorially-sized action-spacespecifically they use the knowledge graph to constrain the kinds of entities that can be filled in the blanks in the template action-space. They test their approach on Zork1, showing the combination of the knowledge graph and template action selection resulted in improvements over existing methods. They note that their approach reaches a score of 40 which corresponds to a bottleneck in Zork1 where the player is eaten by a "grue" (resulting in negative reward) if the player has not first lit a lamp. The lamp must be lit many steps after first being encountered, in a different section of the game; this action is necessary to continue exploring but doesnt immediately produce any positive reward. That is, there is a long term dependency between actions that is not immediately rewarded, as seen in Figure 1b. Others using artificially constrained action spaces also report an inability to pass through this bottleneck (Zahavy et al., 2018;Jain et al., 2019). They pose a significant challenge for these methods because the agent does not see the correct action sequence to pass the bottleneck enough times. This is in part due to the fact that for that sequence to be reinforced, the agent needs to reach the next possible reward beyond the bottleneck.</p>
<p>More efficient exploration strategies are required to pass bottlenecks. Our contributions are twofold. We first introduce a method that detects bottlenecks in text-games using the overall reward gained and the knowledge graph state. This method freezes the policy used to reach the bottleneck and restarts the training from there on out, additionally conducting a backtracking search to ensure that a sub-optimal policy has not been frozen. The second contribution explore how to leverage knowledge graphs to improve existing exploration algorithms for dealing with combinatorial actionspaces such as Go-Explore (Ecoffet et al., 2019). We additionally present a comparative ablation study analyzing the performance of these methods on the popular text-game Zork1.</p>
<p>EXPLORATION METHODS</p>
<p>In this section, we describe methods to explore combinatorially sized action spaces such as textgames-focusing especially on methods that can deal with their inherent bottleneck structure. We first describe our method that explicitly attempts to detect bottlenecks and then describe how an exploration algorithm such as Go Explore (Ecoffet et al., 2019) can leverage knowledge graphs.</p>
<p>KG-A2C-chained An example of a bottleneck can be seen in Figure 1b. We extend the KG-A2C algorithm as follows. First, we detect bottlenecks as states where the agent is unable to progress any further. We set a patience parameter and if the agent has not seen a higher score in patience steps, the agent assumes it has been limited by a bottleneck. Second, when a bottleneck is found, we freeze the policy that gets the agent to the state with the highest score. The agent then begins training a new policy from that particular state.</p>
<p>Simply freezing the policy that led to the bottleneck, however, can potentially result in a policy one that is globally sub-optimal. We therefore employ a backtracking strategy that restarts exploration from each of the n previous steps-searching for a more optimal policy that reaches that bottleneck. At each step, we keep track of a buffer of n states and admissible actions that led up to that locally optimal state. We force the agent to explore from this state to attempt to drive it out of the local optima. If it is further unable to find itself out of this local optima, we refresh the training process again, but starting at the state immediately before the agent reaches the local optima. If this continues to fail, we continue to iterate through this buffer of seen states states up to that local optima until we either find a more optimal state or we run out of states to refresh from, in which we terminate the training algorithm.</p>
<p>KG-A2C-Explore Go-Explore (Ecoffet et al., 2019) is an algorithm that is designed to keep track of sub-optimal and under-explored states in order to allow the agent to explore upon more optimal states that may be a result of sparse rewards. The Go-Explore algorithm consists of two phases, the first to continuously explore until a set of promising states and corresponding trajectories are found on the basis of total score, and the second to robustify this found policy against potential stochasticity in the game. Promising states are defined as those states when explored from will likely result in higher reward trajectories. Since the text games we are dealing with are mostly deterministic, with the exception of Zork in later stages, we only focus on using Phase 1 of the Go-Explore algorithm to find an optimal policy. Madotto et al. (2020) look at applying Go-Explore to text-games on a set of simpler games generated using the game generation framework TextWorld (Côté et al., 2018). Instead of training a policy network in parallel to generate actions used for exploration, they use a small set of "admissible actions"-actions guaranteed to change the world state at any given step during Phase 1-to explore and find high reward trajectories. This space of actions is relatively small (of the order of 10 2 per step) and so finding high reward trajectories in larger action-spaces such as in Zork would be infeasible Go-Explore maintains an archive of cells-defined as a set of states that map to a single representation-to keep track of promising states. Ecoffet et al. (2019) simply encodes each cell by keeping track of the agent's position and Madotto et al. (2020) use the textual observations encoded by recurrent neural network as a cell representation. We improve on this implementation by training the KG-A2C network in parallel, using the snapshot of the knowledge graph in conjunction with the game state to further encode the current state and use this as a cell representation. At each step, Go-Explore chooses a cell to explore at random (weighted by score to prefer more advanced cells). The KG-A2C will run for a number of steps, starting with the knowledge graph state and the last seen state of the game from the cell. This will generate a trajectory for the agent while further training the KG-A2C at each iteration, creating a new representation for the knowledge graph as well as a new game state for the cell. After expanding a cell, Go-Explore will continue to sample cells by weight to continue expanding its known states. At the same time, KG-A2C will benefit from the heuristics of selecting preferred cells and be trained on promising states more often.   </p>
<p>EVALUATION</p>
<p>We compare our two exploration strategies to the following baselines and ablations:</p>
<p>• KG-A2C This is the exact same method presented in Ammanabrolu &amp; Hausknecht (2020) with no modifications.</p>
<p>• A2C Represents the same approach as KG-A2C but with all the knowledge graph components removed. The state representation is text only encoded using recurrent networks.</p>
<p>• A2C-chained Is a variation on KG-A2C-chained where we use our policy chaining approach with the A2C method to train the agent instead of KG-A2C.</p>
<p>• A2C-Explore Uses A2C in addition to the exploration strategy seen in KG-A2C-Explore. The cell representations here are defined in terms of the recurrent network based encoding of the textual observation. Figure 2 shows that agents utilizing knowledge-graphs in addition to either enhanced exploration method far outperform the baseline A2C and KG-A2C. KG-A2C-chained and KG-A2C-Explore both pass the bottleneck of a score of 40, whereas A2C-Explore gets to the bottleneck but cannot surpass it.</p>
<p>There are a couple of key insights that can be drawn from these results The first is that the knowledge graph appears to be critical; it is theorized to help with partial observability. However the knowledge graph representation isn't sufficient in that the knowledge graph representation without enhanced exploration methods cannot surpass the bottleneck. A2C-chained-which explores without a knowledge graph-fails to even outperform the baseline A2C. We hypothesize that this is due to the knowledge graph aiding implicitly in the sample efficiency of bottleneck detection and subsequent exploration. That is, exploring after backtracking from a potentially detected bottleneck is much more efficient in the knowledge graph based agent.</p>
<p>The Go-Explore based exploration algorithm sees less of a difference between agents. A2C-Explore converges more quickly, but to a lower reward trajectory that fails to pass the bottleneck, whereas KG-A2C-Explore takes longer to reach a similar reward but consistently makes it through the bottleneck. The knowledge graph cell representation appears to thus be a better indication of what a promising state is as opposed to just the textual observation.</p>
<p>Comparing the advanced exploration methods when using the knowledge graph, we see that both agents successfully pass the bottleneck corresponding to entering the cellar and lighting the lamp and reach comparable scores within a margin of error. KG-A2C-chained is significantly more sample efficient and converges faster. We can infer that chaining policies by explicitly detecting bottlenecks lets us pass it more quickly than attempting to find promising cell representations with Go-Explore. This form of chained exploration with backtracking is particularly suited to sequential decision making problems that can be represented as acyclic directed graphs as in Figure 1b. The bottleneck seen at a score of around 40 is when the player first enters the cellar on the right side of the map. The cellar is dark and you need to immediately light the lamp to see anything.</p>
<p>Attempting to explore the cellar in the dark results in you being instantly killed by a monster known as a "grue".</p>
<p>A.2 KNOWLEDGE GRAPH RULES</p>
<p>We make no changes from the graph update rules used by Ammanabrolu &amp; Hausknecht (2020). Candidate interactive objects are identified by performing part-of-speech tagging on the current observation, identifying singular and proper nouns as well as adjectives, and are then filtered by checking if they can be examined using the command examine OBJ. Only the interactive objects not found in the inventory are linked to the node corresponding to the current room and the inventory items are linked to the "you" node. The only other rule applied uses the navigational actions performed by the agent to infer the relative positions of rooms, e.g. kitchen, down, cellar when the agent performs go down when in the kitchen to move to the cellar.</p>
<p>A.3 HYPERPARAMETERS</p>
<p>Hyperparameters used for our agents are given below. Patience and buffer size are used for the policy chaining method as described in Section 2. Cell step size is a parameter used for Go-Explore and describes how many steps are taken when exploring in a given cell state. Base hyperparameters for KG-A2C are taken from Ammanabrolu &amp; Hausknecht (2020) and the same parameters are used for A2C.</p>
<p>Agent</p>
<p>Hyperparameters A2C-chained patience=35 buffer size n=40 batch size=32 KG-A2C-chained patience=35 buffer size n=40 batch size=32 A2C-Explore cell step size=30 batch size=1 KG-A2C-Explore cell step size=30 batch size=1</p>
<p>of the quest structure as a directed acyclic graph in Zork1 demonstrating bottlenecks. Each node represents an action that needs to be taken to finish the quest. Green nodes represent potential positive rewards. By our definition, entering the kitchen and lighting the lamp after entering the cellar are likely bottleneck candidates.</p>
<p>Figure 1 :
1An overall example of an excerpt and quest structure of Zork1.</p>
<p>curves for select experiments. The dotted line represents the bottleneck of lighting the lamp.</p>
<p>Figure 2 :
2Ablation results on Zork1, averaged across 5 independent runs.</p>
<p>Figure 3 :
3Map of Zork1 annotated with rewards. These rewards correspond to the quest structure seen inFigure 1b. Taken from Ammanabrolu &amp; Hausknecht (is one of the first text-adventure games and heavily influences games released later in terms of narrative style and game structure. It is a dungeon crawler where the player must explore a vast world and collect a series of treasures. It was identified byHausknecht et al. (2019) as a moonshot game and has been the subject of much work in leaning agents(Yin &amp; May, 2019;Zahavy et al., 2018;Tessler et al., 2019;Jain et al., 2019). Rewards are given to the player when they collect treasures as well as when important intermediate milestones needed to further explore the world are passed.Figure 3andFigure 1bshow us a map of the world of Zork1 and the corresponding quest structure.
https://github.com/microsoft/jericho
https://github.com/rajammanabrolu/KG-A2C</p>
<p>Graph constrained reinforcement learning for natural language action spaces. Prithviraj Ammanabrolu, Matthew Hausknecht, International Conference on Learning Representations. Prithviraj Ammanabrolu and Matthew Hausknecht. Graph constrained reinforcement learning for natural language action spaces. In International Conference on Learning Representations, 2020. URL https://openreview.net/forum?id=B1x6w0EtwH.</p>
<p>Playing text-adventure games with graph-based deep reinforcement learning. Prithviraj Ammanabrolu, Mark O Riedl, Proceedings of 2019 Annual Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, NAACL-HLT 2019. 2019 Annual Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, NAACL-HLT 2019Prithviraj Ammanabrolu and Mark O. Riedl. Playing text-adventure games with graph-based deep reinforcement learning. In Proceedings of 2019 Annual Conference of the North American Chap- ter of the Association for Computational Linguistics: Human Language Technologies, NAACL- HLT 2019, 2019a.</p>
<p>Transfer in deep reinforcement learning using knowledge graphs. Prithviraj Ammanabrolu, Mark O Riedl, abs/1908.06556CoRRPrithviraj Ammanabrolu and Mark O. Riedl. Transfer in deep reinforcement learning using knowl- edge graphs. CoRR, abs/1908.06556, 2019b.</p>
<p>Leveraging Linguistic Structure For Open Domain Information Extraction. Gabor Angeli, Johnson Premkumar, Melvin Jose, Christopher D Manning, Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing. the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing1Gabor Angeli, Johnson Premkumar, Melvin Jose, and Christopher D. Manning. Leveraging Lin- guistic Structure For Open Domain Information Extraction. In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Confer- ence on Natural Language Processing (Volume 1: Long Papers), 2015.</p>
<p>Textworld: A learning environment for text-based games. Ákos Marc-Alexandre Côté, Xingdi Kádár, Ben Yuan, Tavian Kybartas, Emery Barnes, James Fine, Matthew Moore, Layla El Hausknecht, Mahmoud Asri, Wendy Adada, Adam Tay, Trischler, abs/1806.11532CoRRMarc-Alexandre Côté,Ákos Kádár, Xingdi Yuan, Ben Kybartas, Tavian Barnes, Emery Fine, James Moore, Matthew Hausknecht, Layla El Asri, Mahmoud Adada, Wendy Tay, and Adam Trischler. Textworld: A learning environment for text-based games. CoRR, abs/1806.11532, 2018.</p>
<p>Go-explore: a new approach for hard-exploration problems. Adrien Ecoffet, Joost Huizinga, Joel Lehman, Kenneth O Stanley, Jeff Clune, abs/1901.10995CoRRAdrien Ecoffet, Joost Huizinga, Joel Lehman, Kenneth O. Stanley, and Jeff Clune. Go-explore: a new approach for hard-exploration problems. CoRR, abs/1901.10995, 2019.</p>
<p>Interactive fiction games: A colossal adventure. Matthew Hausknecht, Prithviraj Ammanabrolu, Marc-Alexandre Côté, Xingdi Yuan, abs/1909.05398CoRRMatthew Hausknecht, Prithviraj Ammanabrolu, Marc-Alexandre Côté, and Xingdi Yuan. Interactive fiction games: A colossal adventure. CoRR, abs/1909.05398, 2019.</p>
<p>Algorithmic improvements for deep reinforcement learning applied to interactive fiction. CoRR, abs. Vishal Jain, William Fedus, Hugo Larochelle, Doina Precup, Marc G Bellemare, Vishal Jain, William Fedus, Hugo Larochelle, Doina Precup, and Marc G. Bellemare. Algo- rithmic improvements for deep reinforcement learning applied to interactive fiction. CoRR, abs/1911.12511, 2019.</p>
<p>Exploration based language learning for text-based games. Andrea Madotto, Mahdi Namazifar, Joost Huizinga, Piero Molino, Adrien Ecoffet, Huaixiu Zheng, Alexandros Papangelis, Dian Yu, Chandra Khatri, Gokhan Tur, abs/2001.08868CoRRAndrea Madotto, Mahdi Namazifar, Joost Huizinga, Piero Molino, Adrien Ecoffet, Huaixiu Zheng, Alexandros Papangelis, Dian Yu, Chandra Khatri, and Gokhan Tur. Exploration based language learning for text-based games. CoRR, abs/2001.08868, 2020.</p>
<p>Learning options in reinforcement learning. Martin Stolle, Doina Precup, Proceedings of the 5th International Symposium on Abstraction, Reformulation and Approximation. the 5th International Symposium on Abstraction, Reformulation and ApproximationBerlin, HeidelbergSpringer-Verlag212223ISBN 3540439412Martin Stolle and Doina Precup. Learning options in reinforcement learning. In Proceedings of the 5th International Symposium on Abstraction, Reformulation and Approximation, pp. 212223, Berlin, Heidelberg, 2002. Springer-Verlag. ISBN 3540439412.</p>
<p>Action assembly: Sparse imitation learning for text based games with combinatorial action spaces. Chen Tessler, Tom Zahavy, Deborah Cohen, J Daniel, Shie Mankowitz, Mannor, abs/1905.09700CoRRChen Tessler, Tom Zahavy, Deborah Cohen, Daniel J Mankowitz, and Shie Mannor. Action as- sembly: Sparse imitation learning for text based games with combinatorial action spaces. CoRR, abs/1905.09700, 2019.</p>
<p>Comprehensible context-driven text game playing. CoRR, abs. Xusen Yin, Jonathan May, Xusen Yin and Jonathan May. Comprehensible context-driven text game playing. CoRR, abs/1905.02265, 2019.</p>
<p>Learn what not to learn: Action elimination with deep reinforcement learning. Tom Zahavy, Matan Haroush, Nadav Merlis, J Daniel, Shie Mankowitz, Mannor, Advances in Neural Information Processing Systems. S. Bengio, H. Wallach, H. Larochelle, K. Grauman, N. Cesa-Bianchi, and R. GarnettCurran Associates, Inc31Tom Zahavy, Matan Haroush, Nadav Merlis, Daniel J Mankowitz, and Shie Mannor. Learn what not to learn: Action elimination with deep reinforcement learning. In S. Bengio, H. Wallach, H. Larochelle, K. Grauman, N. Cesa-Bianchi, and R. Garnett (eds.), Advances in Neural Infor- mation Processing Systems 31, pp. 3562-3573. Curran Associates, Inc., 2018.</p>            </div>
        </div>

    </div>
</body>
</html>