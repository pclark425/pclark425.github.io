<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-3502 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-3502</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-3502</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-78.html">extraction-schema-78</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing strict logical reasoning tasks, including the models used, logical reasoning tasks or benchmarks, methods or interventions applied to improve logical reasoning, performance results, comparisons to baselines, and any reported limitations or failure cases.</div>
                <p><strong>Paper ID:</strong> paper-9ef2e09a9e16e176e19c3fdc3b6ee22c5d3f3c97</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/9ef2e09a9e16e176e19c3fdc3b6ee22c5d3f3c97" target="_blank">HOList: An Environment for Machine Learning of Higher-Order Theorem Proving (extended version)</a></p>
                <p><strong>Paper Venue:</strong> arXiv.org</p>
                <p><strong>Paper TL;DR:</strong> This work provides an open-source framework based on the HOL Light theorem prover that can be used as a reinforcement learning environment and presents a deep reinforcement learning driven automated theorem provers, DeepHOL, with strong initial results on this benchmark.</p>
                <p><strong>Paper Abstract:</strong> We present an environment, benchmark, and deep learning driven automated theorem prover for higher-order logic. Higher-order interactive theorem provers enable the formalization of arbitrary mathematical theories and thereby present an interesting, open-ended challenge for deep learning. We provide an open-source framework based on the HOL Light theorem prover that can be used as a reinforcement learning environment. HOL Light comes with a broad coverage of basic mathematical theorems on calculus and the formal proof of the Kepler conjecture, from which we derive a challenging benchmark for automated reasoning. We also present a deep reinforcement learning driven automated theorem prover, DeepHOL, with strong initial results on this benchmark.</p>
                <p><strong>Cost:</strong> 0.013</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e3502.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e3502.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing strict logical reasoning tasks, including the models used, logical reasoning tasks or benchmarks, methods or interventions applied to improve logical reasoning, performance results, comparisons to baselines, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>DeepHOL</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>DeepHOL (deep reinforcement learning driven automated theorem prover)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A neural-network-based automated theorem prover built on top of HOL Light that predicts tactics and their theorem-argument lists from goal S-expressions using a two-tower encoder and is trained by supervised imitation of human proofs plus a distributed reinforcement-learning loop.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>DeepHOL</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>A neural theorem-proving system using a two-tower architecture: a goal tower that embeds the current goal and predicts a tactic (softmax over 41 tactics) and a premise tower that embeds candidate theorems; a combiner ranks premises (argument theorems) conditioned on goal and optionally on tactic. Encoders are WaveNet-style convolutional networks; the prover does breadth-first proof search with subgoal sharing, argument pruning, and uses supervised pretraining on human proof logs plus iterative reinforcement-learning rounds (distributed proof search producing new training examples). Inputs are normalized HOL S-expressions (strings); hypotheses are dropped before encoding.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>≈47M (reported for the deeper WaveNet variant used in ablation; other variants smaller)</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_name</strong></td>
                            <td>HOList/HOL Light theorem proving benchmark (core, complex, flyspeck)</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_description</strong></td>
                            <td>Strict higher-order logical reasoning: (1) predict the tactic and tactic-argument list used in human HOL Light proofs (imitation task) and (2) fully prove theorems from the supplied corpora (core, complex, flyspeck) in HOL Light by performing sequences of tactic applications that close all subgoals; this requires higher-order reasoning and premise (lemma) selection from a large library.</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_intervention</strong></td>
                            <td>Two-stage approach: supervised imitation learning on logged human proofs (predict tactic + args) followed by a distributed reinforcement-learning loop that (i) runs provers guided by the current model to generate new proof traces, (ii) prunes argument lists to obtain hard negatives, (iii) mixes fresh and historical examples during training. Architectural interventions: two-tower network (goal tower + premise tower), combiner network for premise ranking (tactic-conditioned or tactic-independent variants), WaveNet-style encoders, subgoal sharing in proof search, BFS proof search, greedy argument pruning to obtain minimal argument lists and hard negatives, normalization of generic variables/types, precomputation of premise embeddings for speed.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>Validation-set results on the complex corpus (3225 theorems): baseline ASM_MESON_TAC closed 6.1% (no args) and 9.2% (with argument-selection); supervised WaveNet encoder closed 31.72%; deeper WaveNet closed 32.65%; wider WaveNet closed 27.60%. Reinforcement-learning loop variants improved performance: 'Loop' 36.3%, 'Trained on loop output' 36.8%, and 'Loop tactic dependent' 38.9% (all reported as percentage of theorems closed on the validation set). On a 2000-theorem sample from flyspeck the 'Loop' checkpoint closed 752 proofs (37.0%). Additional training-set aggregate counts reported (examples): various loops closed between ~54%–58% of their sampled training-set theorems in some runs (see paper Table 4 for counts).</td>
                        </tr>
                        <tr>
                            <td><strong>baseline_performance</strong></td>
                            <td>ASM_MESON_TAC (built-in first-order prover in HOL Light): 6.1% (no arguments) and 9.2% (with learned argument selection) closed on complex validation set.</td>
                        </tr>
                        <tr>
                            <td><strong>improvement_over_baseline</strong></td>
                            <td>DeepHOL (supervised WaveNet) improved from ~6–9% baseline to ~31–33%; reinforcement-learning loops further improved to ~36–39% on the complex validation set — an absolute improvement of ~25–33 percentage points over the trivial ASM_MESON_TAC baseline and ~4–7 percentage points from supervised WaveNet to best RL variant.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failures</strong></td>
                            <td>Reported limitations and failure modes include: (1) the system currently only supports tactics taking theorem-lists as arguments and does not support tactics that take arbitrary term arguments; (2) goals are encoded after dropping hypotheses (information loss may hinder reasoning); (3) very long expressions (median ~300 tokens, mean ~500) and many unique generic names require normalization and limit embedding quality; (4) preliminary RL without human seed produced inferior models (seeding is helpful); (5) the 'Loop on subgoals' variant (aiming for solving subgoals separately to learn longer proofs) did not yield improvements in the authors' naive implementation; (6) computational cost is high (distributed proof search with many cores and per-step timeouts), which constrains experimentation; (7) argument lists are long and require greedy pruning (non-optimal); (8) timeouts and limits on explored proof states can prevent finding valid proofs; (9) model tactic-prediction accuracy is only ~38–42% so many choices remain incorrect.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_analysis</strong></td>
                            <td>Reported analyses and ablations: comparison of WaveNet encoder variants (narrow vs wider vs deeper): deeper WaveNet (4 blocks × 5 layers, ≈47M parameters) outperformed shallower/wider variants; narrow (128-filter) vs wider (256-filter) tradeoffs noted (128 filters often did better in some runs). Proxy metrics: tactic prediction accuracy ~38–42% across models; success rate of selecting a positive tactic argument vs random negative had ≈1% error. Experiments comparing tactic-dependent premise ranking vs tactic-independent ranking (tactic-dependent ranking led to the best RL 'Loop tactic dependent' validation result). Effectiveness of greedy argument pruning (reverse-score omission) to create short argument lists and hard negatives for training. Also tried 'Loop on subgoals' (curriculum-style) which did not improve in the implemented form. Training hyperparameters and regularization details (Adam optimizer, decaying LR starting at 1e-4, dropout rate 0.3, parameter averaging) are reported and used in ablations.</td>
                        </tr>
                        <tr>
                            <td><strong>notes</strong></td>
                            <td>All performance numbers refer to experiments as reported on the complex corpus validation set (the paper explicitly reports those percentages); models and proofs are checked within HOL Light's trusted kernel via compiled proof checker to ensure soundness.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'HOList: An Environment for Machine Learning of Higher-Order Theorem Proving (extended version)', 'publication_date_yy_mm': '2019-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3502.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e3502.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing strict logical reasoning tasks, including the models used, logical reasoning tasks or benchmarks, methods or interventions applied to improve logical reasoning, performance results, comparisons to baselines, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>WaveNet encoder</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>WaveNet-style convolutional encoder (adapted from Wavenet)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A stack of dilated convolutional blocks (WaveNet-style) adapted as a sequence encoder for HOL S-expressions; used as the primary encoder for both the goal tower and premise tower in DeepHOL with different depth/width variants evaluated.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Wavenet: A generative model for raw audio</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>WaveNet-style encoder</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Convolutional, dilated residual-block architecture adapted from WaveNet to encode long token sequences (HOL S-expressions). Variants: 'base' two WaveNet blocks of four layers each (filters 128 or 256), 'deeper' four blocks of five layers each (~47M parameters), and 'wider' variant with more filters. Used as encoders for both goal and premise towers.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>≈47M for the deeper variant (other variants smaller; exact total parameter counts vary by architecture)</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_name</strong></td>
                            <td>Same HOL Light HOList benchmark tasks (tactic prediction and theorem proving)</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_description</strong></td>
                            <td>Encode long higher-order logic S-expressions to produce embeddings used for tactic classification and premise ranking in higher-order theorem proving.</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_intervention</strong></td>
                            <td>Using WaveNet-style dilated convolutions as sequence encoders; tested variants (depth and width) and used dropout (0.3) and parameter averaging; used in both supervised and reinforcement-learning training regimes.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>Supervised WaveNet closed 31.72% on complex validation set; deeper WaveNet closed 32.65%; wider WaveNet closed 27.60% (Table 2). WaveNet encoders were the backbone for reinforcement-learning loops that reached up to 38.9% closed theorems on the validation set for the tactic-dependent loop.</td>
                        </tr>
                        <tr>
                            <td><strong>baseline_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>improvement_over_baseline</strong></td>
                            <td>Deeper WaveNet variant outperformed the base/wider variants by a few percentage points on the complex validation set (≈32.65% vs 31.72% and 27.60%). The WaveNet-based models substantially outperformed the trivial ASM_MESON_TAC baseline (6–9%).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failures</strong></td>
                            <td>Long expression lengths and many rare tokens required normalization; WaveNet variants differ in performance and capacity trade-offs (wider not necessarily better); encoding dropped hypotheses which may reduce available information; not explicitly modeling tree structure beyond token sequences.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_analysis</strong></td>
                            <td>Ablations across architectures: narrower (128-filter) vs wider (256-filter) and deeper vs shallower blocks; deeper (~47M) performed best in reported experiments; dropout and parameter averaging were used; reported tactic-classification accuracies (~38–42%) and premise-selection error (~1%) as proxy metrics for encoder effectiveness.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'HOList: An Environment for Machine Learning of Higher-Order Theorem Proving (extended version)', 'publication_date_yy_mm': '2019-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3502.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e3502.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing strict logical reasoning tasks, including the models used, logical reasoning tasks or benchmarks, methods or interventions applied to improve logical reasoning, performance results, comparisons to baselines, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>ASM_MESON_TAC</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>ASM_MESON_TAC (HOL Light built-in first-order automated tactic)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A built-in first-order automated tactic in HOL Light (calls a first-order MESON solver) used as a simple symbolic baseline for automated theorem proving on the benchmark.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>ASM_MESON_TAC (symbolic first-order prover tactic)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Symbolic built-in first-order tactic in HOL Light that attempts to close goals by invoking an automated first-order theorem prover (MESON). Used as a baseline with and without learned argument selection.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_name</strong></td>
                            <td>HOList/HOL Light theorem proving benchmark (core & complex corpora)</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_description</strong></td>
                            <td>Attempt to automatically close HOL Light goals using a first-order automation tactic (not higher-order reasoning); used to measure a trivial baseline on the strict logical theorem-proving task.</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_intervention</strong></td>
                            <td>Used as-is and also run with an argument list predicted by the learned argument-selection model to evaluate whether learned premise selection helps a first-order tactic.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>On the complex validation set: ASM_MESON_TAC with empty argument list closed 6.1% of theorems; with the learned argument-selection model it closed 9.2% (Table 2).</td>
                        </tr>
                        <tr>
                            <td><strong>baseline_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>improvement_over_baseline</strong></td>
                            <td>Providing learned argument-selection to ASM_MESON_TAC increased its closed-theorem rate from 6.1% to 9.2% (absolute improvement 3.1 percentage points), showing premise-selection helps even the symbolic baseline.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failures</strong></td>
                            <td>ASM_MESON_TAC is a first-order tactic and thus inherently limited on higher-order problems; even with learned premise selection it performs far worse than the DeepHOL neural approaches on these higher-order corpora.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_analysis</strong></td>
                            <td>Used as a trivial baseline; the main analytic finding is that learned argument selection yields modest gains for this symbolic first-order tactic, but not competitive with the neural prover on the higher-order tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'HOList: An Environment for Machine Learning of Higher-Order Theorem Proving (extended version)', 'publication_date_yy_mm': '2019-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>TacticToe: Learning to reason with hol4 tactics <em>(Rating: 2)</em></li>
                <li>GamePad: A learning environment for theorem proving <em>(Rating: 2)</em></li>
                <li>DeepMath: Deep sequence models for premise selection <em>(Rating: 2)</em></li>
                <li>HolStep: A machine learning dataset for higher-order logic theorem proving <em>(Rating: 2)</em></li>
                <li>Reinforcement learning of theorem proving <em>(Rating: 2)</em></li>
                <li>Holophrasm: a neural automated theorem prover for higher-order logic <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-3502",
    "paper_id": "paper-9ef2e09a9e16e176e19c3fdc3b6ee22c5d3f3c97",
    "extraction_schema_id": "extraction-schema-78",
    "extracted_data": [
        {
            "name_short": "DeepHOL",
            "name_full": "DeepHOL (deep reinforcement learning driven automated theorem prover)",
            "brief_description": "A neural-network-based automated theorem prover built on top of HOL Light that predicts tactics and their theorem-argument lists from goal S-expressions using a two-tower encoder and is trained by supervised imitation of human proofs plus a distributed reinforcement-learning loop.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "DeepHOL",
            "model_description": "A neural theorem-proving system using a two-tower architecture: a goal tower that embeds the current goal and predicts a tactic (softmax over 41 tactics) and a premise tower that embeds candidate theorems; a combiner ranks premises (argument theorems) conditioned on goal and optionally on tactic. Encoders are WaveNet-style convolutional networks; the prover does breadth-first proof search with subgoal sharing, argument pruning, and uses supervised pretraining on human proof logs plus iterative reinforcement-learning rounds (distributed proof search producing new training examples). Inputs are normalized HOL S-expressions (strings); hypotheses are dropped before encoding.",
            "model_size": "≈47M (reported for the deeper WaveNet variant used in ablation; other variants smaller)",
            "reasoning_task_name": "HOList/HOL Light theorem proving benchmark (core, complex, flyspeck)",
            "reasoning_task_description": "Strict higher-order logical reasoning: (1) predict the tactic and tactic-argument list used in human HOL Light proofs (imitation task) and (2) fully prove theorems from the supplied corpora (core, complex, flyspeck) in HOL Light by performing sequences of tactic applications that close all subgoals; this requires higher-order reasoning and premise (lemma) selection from a large library.",
            "method_or_intervention": "Two-stage approach: supervised imitation learning on logged human proofs (predict tactic + args) followed by a distributed reinforcement-learning loop that (i) runs provers guided by the current model to generate new proof traces, (ii) prunes argument lists to obtain hard negatives, (iii) mixes fresh and historical examples during training. Architectural interventions: two-tower network (goal tower + premise tower), combiner network for premise ranking (tactic-conditioned or tactic-independent variants), WaveNet-style encoders, subgoal sharing in proof search, BFS proof search, greedy argument pruning to obtain minimal argument lists and hard negatives, normalization of generic variables/types, precomputation of premise embeddings for speed.",
            "performance": "Validation-set results on the complex corpus (3225 theorems): baseline ASM_MESON_TAC closed 6.1% (no args) and 9.2% (with argument-selection); supervised WaveNet encoder closed 31.72%; deeper WaveNet closed 32.65%; wider WaveNet closed 27.60%. Reinforcement-learning loop variants improved performance: 'Loop' 36.3%, 'Trained on loop output' 36.8%, and 'Loop tactic dependent' 38.9% (all reported as percentage of theorems closed on the validation set). On a 2000-theorem sample from flyspeck the 'Loop' checkpoint closed 752 proofs (37.0%). Additional training-set aggregate counts reported (examples): various loops closed between ~54%–58% of their sampled training-set theorems in some runs (see paper Table 4 for counts).",
            "baseline_performance": "ASM_MESON_TAC (built-in first-order prover in HOL Light): 6.1% (no arguments) and 9.2% (with learned argument selection) closed on complex validation set.",
            "improvement_over_baseline": "DeepHOL (supervised WaveNet) improved from ~6–9% baseline to ~31–33%; reinforcement-learning loops further improved to ~36–39% on the complex validation set — an absolute improvement of ~25–33 percentage points over the trivial ASM_MESON_TAC baseline and ~4–7 percentage points from supervised WaveNet to best RL variant.",
            "limitations_or_failures": "Reported limitations and failure modes include: (1) the system currently only supports tactics taking theorem-lists as arguments and does not support tactics that take arbitrary term arguments; (2) goals are encoded after dropping hypotheses (information loss may hinder reasoning); (3) very long expressions (median ~300 tokens, mean ~500) and many unique generic names require normalization and limit embedding quality; (4) preliminary RL without human seed produced inferior models (seeding is helpful); (5) the 'Loop on subgoals' variant (aiming for solving subgoals separately to learn longer proofs) did not yield improvements in the authors' naive implementation; (6) computational cost is high (distributed proof search with many cores and per-step timeouts), which constrains experimentation; (7) argument lists are long and require greedy pruning (non-optimal); (8) timeouts and limits on explored proof states can prevent finding valid proofs; (9) model tactic-prediction accuracy is only ~38–42% so many choices remain incorrect.",
            "ablation_or_analysis": "Reported analyses and ablations: comparison of WaveNet encoder variants (narrow vs wider vs deeper): deeper WaveNet (4 blocks × 5 layers, ≈47M parameters) outperformed shallower/wider variants; narrow (128-filter) vs wider (256-filter) tradeoffs noted (128 filters often did better in some runs). Proxy metrics: tactic prediction accuracy ~38–42% across models; success rate of selecting a positive tactic argument vs random negative had ≈1% error. Experiments comparing tactic-dependent premise ranking vs tactic-independent ranking (tactic-dependent ranking led to the best RL 'Loop tactic dependent' validation result). Effectiveness of greedy argument pruning (reverse-score omission) to create short argument lists and hard negatives for training. Also tried 'Loop on subgoals' (curriculum-style) which did not improve in the implemented form. Training hyperparameters and regularization details (Adam optimizer, decaying LR starting at 1e-4, dropout rate 0.3, parameter averaging) are reported and used in ablations.",
            "notes": "All performance numbers refer to experiments as reported on the complex corpus validation set (the paper explicitly reports those percentages); models and proofs are checked within HOL Light's trusted kernel via compiled proof checker to ensure soundness.",
            "uuid": "e3502.0",
            "source_info": {
                "paper_title": "HOList: An Environment for Machine Learning of Higher-Order Theorem Proving (extended version)",
                "publication_date_yy_mm": "2019-04"
            }
        },
        {
            "name_short": "WaveNet encoder",
            "name_full": "WaveNet-style convolutional encoder (adapted from Wavenet)",
            "brief_description": "A stack of dilated convolutional blocks (WaveNet-style) adapted as a sequence encoder for HOL S-expressions; used as the primary encoder for both the goal tower and premise tower in DeepHOL with different depth/width variants evaluated.",
            "citation_title": "Wavenet: A generative model for raw audio",
            "mention_or_use": "use",
            "model_name": "WaveNet-style encoder",
            "model_description": "Convolutional, dilated residual-block architecture adapted from WaveNet to encode long token sequences (HOL S-expressions). Variants: 'base' two WaveNet blocks of four layers each (filters 128 or 256), 'deeper' four blocks of five layers each (~47M parameters), and 'wider' variant with more filters. Used as encoders for both goal and premise towers.",
            "model_size": "≈47M for the deeper variant (other variants smaller; exact total parameter counts vary by architecture)",
            "reasoning_task_name": "Same HOL Light HOList benchmark tasks (tactic prediction and theorem proving)",
            "reasoning_task_description": "Encode long higher-order logic S-expressions to produce embeddings used for tactic classification and premise ranking in higher-order theorem proving.",
            "method_or_intervention": "Using WaveNet-style dilated convolutions as sequence encoders; tested variants (depth and width) and used dropout (0.3) and parameter averaging; used in both supervised and reinforcement-learning training regimes.",
            "performance": "Supervised WaveNet closed 31.72% on complex validation set; deeper WaveNet closed 32.65%; wider WaveNet closed 27.60% (Table 2). WaveNet encoders were the backbone for reinforcement-learning loops that reached up to 38.9% closed theorems on the validation set for the tactic-dependent loop.",
            "baseline_performance": null,
            "improvement_over_baseline": "Deeper WaveNet variant outperformed the base/wider variants by a few percentage points on the complex validation set (≈32.65% vs 31.72% and 27.60%). The WaveNet-based models substantially outperformed the trivial ASM_MESON_TAC baseline (6–9%).",
            "limitations_or_failures": "Long expression lengths and many rare tokens required normalization; WaveNet variants differ in performance and capacity trade-offs (wider not necessarily better); encoding dropped hypotheses which may reduce available information; not explicitly modeling tree structure beyond token sequences.",
            "ablation_or_analysis": "Ablations across architectures: narrower (128-filter) vs wider (256-filter) and deeper vs shallower blocks; deeper (~47M) performed best in reported experiments; dropout and parameter averaging were used; reported tactic-classification accuracies (~38–42%) and premise-selection error (~1%) as proxy metrics for encoder effectiveness.",
            "uuid": "e3502.1",
            "source_info": {
                "paper_title": "HOList: An Environment for Machine Learning of Higher-Order Theorem Proving (extended version)",
                "publication_date_yy_mm": "2019-04"
            }
        },
        {
            "name_short": "ASM_MESON_TAC",
            "name_full": "ASM_MESON_TAC (HOL Light built-in first-order automated tactic)",
            "brief_description": "A built-in first-order automated tactic in HOL Light (calls a first-order MESON solver) used as a simple symbolic baseline for automated theorem proving on the benchmark.",
            "citation_title": "",
            "mention_or_use": "use",
            "model_name": "ASM_MESON_TAC (symbolic first-order prover tactic)",
            "model_description": "Symbolic built-in first-order tactic in HOL Light that attempts to close goals by invoking an automated first-order theorem prover (MESON). Used as a baseline with and without learned argument selection.",
            "model_size": null,
            "reasoning_task_name": "HOList/HOL Light theorem proving benchmark (core & complex corpora)",
            "reasoning_task_description": "Attempt to automatically close HOL Light goals using a first-order automation tactic (not higher-order reasoning); used to measure a trivial baseline on the strict logical theorem-proving task.",
            "method_or_intervention": "Used as-is and also run with an argument list predicted by the learned argument-selection model to evaluate whether learned premise selection helps a first-order tactic.",
            "performance": "On the complex validation set: ASM_MESON_TAC with empty argument list closed 6.1% of theorems; with the learned argument-selection model it closed 9.2% (Table 2).",
            "baseline_performance": null,
            "improvement_over_baseline": "Providing learned argument-selection to ASM_MESON_TAC increased its closed-theorem rate from 6.1% to 9.2% (absolute improvement 3.1 percentage points), showing premise-selection helps even the symbolic baseline.",
            "limitations_or_failures": "ASM_MESON_TAC is a first-order tactic and thus inherently limited on higher-order problems; even with learned premise selection it performs far worse than the DeepHOL neural approaches on these higher-order corpora.",
            "ablation_or_analysis": "Used as a trivial baseline; the main analytic finding is that learned argument selection yields modest gains for this symbolic first-order tactic, but not competitive with the neural prover on the higher-order tasks.",
            "uuid": "e3502.2",
            "source_info": {
                "paper_title": "HOList: An Environment for Machine Learning of Higher-Order Theorem Proving (extended version)",
                "publication_date_yy_mm": "2019-04"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "TacticToe: Learning to reason with hol4 tactics",
            "rating": 2
        },
        {
            "paper_title": "GamePad: A learning environment for theorem proving",
            "rating": 2
        },
        {
            "paper_title": "DeepMath: Deep sequence models for premise selection",
            "rating": 2
        },
        {
            "paper_title": "HolStep: A machine learning dataset for higher-order logic theorem proving",
            "rating": 2
        },
        {
            "paper_title": "Reinforcement learning of theorem proving",
            "rating": 2
        },
        {
            "paper_title": "Holophrasm: a neural automated theorem prover for higher-order logic",
            "rating": 1
        }
    ],
    "cost": 0.013319999999999999,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>HOList: An Environment for Machine Learning of Higher-Order Theorem Proving</h1>
<p>Preprint, compiled November 5, 2019</p>
<p>Kshitij Bansal ${ }^{\star}$, Sarah M. Loos ${ }^{\star}$, Markus N. Rabe ${ }^{\star}$, Christian Szegedy ${ }^{\star}$, and Stewart Wilcox ${ }^{\star}$<br>{kbk, smloos,mrabe,szegedy, stewbasic}@google.com<br>Google Research, Mountain View, California, USA</p>
<h4>Abstract</h4>
<p>We present an environment, benchmark, and deep learning driven automated theorem prover for higher-order logic. Higher-order interactive theorem provers enable the formalization of arbitrary mathematical theories and thereby present an interesting, open-ended challenge for deep learning. We provide an open-source framework based on the HOL Light theorem prover that can be used as a reinforcement learning environment. HOL Light comes with a broad coverage of basic mathematical theorems on calculus and the formal proof of the Kepler conjecture, from which we derive a challenging benchmark for automated reasoning. We also present a deep reinforcement learning driven automated theorem prover, DeepHOL, with strong initial results on this benchmark.</p>
<h2>1 Introduction</h2>
<p>Formalization of mathematics and the automated creation of new mathematical content is at the frontier of current AI techniques. Given the fundamental nature of mathematics and its importance for most scientific disciplines, the capability for high level formal mathematical reasoning is both an important practical task as well as one of the most challenging case studies in AI. However, traditional formal computer mathematics has been a fragmented domain, exploring various approaches for different logical foundations. This has led to a large number of incompatible theorem proving systems, which added extra challenges for AI researchers trying to push the limits of formal reasoning using machine learning.
Well-defined, large-scale benchmarks were instrumental for unifying disparate efforts in machine learning research: LibriSpeech [1] for speech recognition, the Netflix prize [2] for recommendation, ImageNet [3] for object recognition, MSCOCO [4] for object detection and segmentation, WMT [5] for machine translation, and SQuAD [6] for question answering - just to name a couple of examples. Benchmarks have fostered collaboration and competition and provide a means to measure progress, contributing significantly to accelerated progress and reproducible science.
This paper provides a benchmark and reinforcement learning environment for theorem proving. The long-term goal is to enable the automatic formalization of large theories, and hence we want to start with a theorem proving system that has a track-record of large-scale formalization efforts and includes a large corpus of foundational mathematics for benchmarking and learning. Our choice fell on HOL Light, the interactive theorem prover (ITP) in which the proof of the Kepler conjecture [7] has been formalized. The formalization of the proof of the Kepler conjecture has been a huge effort, taking over 20 person-years to complete, and required formalizing a significant part of arithmetic, linear algebra, and multivariate analysis. The resulting benchmark consists of 2199 definitions and 29462 theorems and lemmata, which capture a variety of interesting mathematics and should be a practical seed for new (auto-)formalization efforts.</p>
<p>To demonstrate the feasibility of the proposed learning task, we present an automated theorem prover powered by deep learning, called DeepHOL. Based on a simple solver architecture, DeepHOL learns to prove theorems based on imitating human proofs and improves itself using reinforcement learning. Given a proof goal (represented as a string) DeepHOL learns to predict the tactic (and its arguments) that leads to a successful proof. Thereby, DeepHOL achieves theorem proving capabilities that are comparable to much more complicated state-of-the-art automated theorem proving systems. In our open-source release, available at http://deephol.org, we expose the APIs of our modular theorem prover. This simplifies the development of new provers significantly and allows researchers to focus on the machine learning aspects.</p>
<p>The contributions of our work are the following:</p>
<ul>
<li>An instrumented, pre-packaged version of HOL Light that can be used as a reinforcement learning environment for theorem proving using our well-defined, stable Python API. Our solution comes with optimized startup capabilities for proof search, while allowing replay and strict verification of the produced proofs.</li>
<li>Proof export and import capabilities that allow for managing large theories programmatically from the Python interface.</li>
<li>A full-fledged, competitive automated neural theorem proving system that can automatize theorem proving in higher-order logic at tactic level directly.</li>
<li>A large scale reinforcement learning system that was used for training our prover.</li>
<li>Comparison of neural model architectures for theorem proving purposes.</li>
<li>Well-defined benchmarks on our HOL Light based environment to enable research and measuring progress of AI driven theorem proving in large theories.</li>
</ul>
<p>This paper is organized as follows. We discuss related work in Section 2 before we describe our theorem proving environment in Section 3. In Section 4 we present the organization of the</p>
<p>benchmark. The DeepHOL automated theorem prover is described in Section 5 and we discuss first experimental results for it in Section 6. Then we conclude in Section 7.</p>
<h2>2 Related Work</h2>
<p>The earliest work of applying machine learning on reasoning in large theories is [8]. The most most similar works to ours are TacticToe [9] and GamePad [10]. TacticToe is the first published result on machine learning tackling higher-order theorem proving at a relatively large scale at tactic level [9]. Although TacticToe is a great success that came with significant improvements over previous automated theorem proving systems, they do not propose an easy to use benchmark or environment for machine learning researchers. TacticToe does not employ deep learning nor reinforcement learning. They rely on the HOL4 [11] system that has a significantly less theorems with more complex human proof scripts with a larger number of more elementary tactics.</p>
<p>GamePad has very similar objectives to ours [10]. They also provide an easy-to-use Python API for an interactive theorem prover, and they present test and training sets. They chose to base their system on Coq [12], an interactive theorem prover based on the calculus of inductive constructions. While enabling automatic code extraction, it comes with a much smaller coverage of fundamental mathematics. Even including the formalization of the Feit-Thompson theorem, their benchmark comprises only 1602 theorems and lemmas, while ours features 29462 theorems and lemmas. Besides presenting a much larger data set, we also demonstrate the feasibility of achieving state-of-the-art prover performance based on our data and environment by presenting a deep learning based theorem prover. We also report the results as theorem proving performance instead of proxy metrics.</p>
<p>Other interactive theorem provers we could have based a learning environment on include Mizar [13], Isabelle [14], HOL4 [11], and Lean [15]. The Mizar mathematical library is probably the most comprehensive formalization effort, but its declarative style makes it hard to employ proof search, and its source code is not freely available. Like Coq and HOL Light, also Isabelle [14] was used for major formalization efforts, such as the formalization of the seL4 microkernel [16]. We are not aware of a comprehensive coverage of fundamental mathematics in Isabelle, HOL4, or Lean.</p>
<p>In closely related work, Kaliszyk and Urban [17] translate from HOL Light and Flyspeck to automated theorem provers and SMT solvers, for which they learn a premise selector. In contrast to our work, they use neither deep learning nor reinforcement learning. Similar methods for premise selection on the HOL Light corpora were proposed in [18].
The first use of deep neural networks for large scale theorem proving was proposed in [19]. They have used convolutional networks for premise selection in large theories, particularly on Mizar mathematical library [13]. Those methods were used as a pre-selection for applying the first order logic automated theorem prover E [20]. We have reused several ideas from that paper, including some aspects of our neural network architecture and the hard negative mining methodology.</p>
<p>Whalen [21] proposed a purely deep reinforcement learning based solution for theorem proving for the Metamath prover [22]. This work was moderately successful, finding mostly proofs for very simple theorems, especially in propositional logic. On the other hand, Metamath is not considered to be a serious contender for large scale mathematical formalization work.
Loos et al. [23] proposed deep neural networks to augment theorem prover E [20] to rank given clauses during proof search. Here, we propose a neural prover written from scratch, relying solely on a small set of preexisting tactics and neural networks for all high level decisions.
Kaliszyk et al. [24] proposed a machine learning benchmark for higher-order logic reasoning based on the HOL Light corpus. It features a few static datasets and it remains unclear how performance of machine learning models on this dataset relates to real world prover performance. [25] demonstrated the viability of reinforcement learning with XGBoost and LIBLINEAR [26] on hand engineered features in first order logic context using leanCoP [27] on Mizar mathematical library [13].
Earlier works on employing (non-deep) machine learning for theorem proving in general and for reasoning in large theories include $[28,29,30,31,32,33,34,35,36,37,38,39,40,41,42$, $43,44]$. Recently, Wang et al. [45] proposed a premise selection method utilizing deep graph embeddings.</p>
<h2>3 Architecture of the Environment</h2>
<p>Here we describe the architecture of the evaluation and training environment. The goal of the environment is to enable artificial agents to interact with the HOL Light interactive theorem prover (ITP) in a replicable manner.</p>
<h3>3.1 ITP Terminology</h3>
<p>In order to describe our changes to HOL Light, it is helpful to establish some common terminology. To prove a theorem in an ITP, the human user starts with entering the theorem's statement as the goal of a new proof. The ITP provides a small number of tactics to manipulate the goal. Tactics may have tactic arguments, which can be a previously proven theorem or a list of previously proven theorems. (There are also tactics that take terms as arguments, but we do not support them currently.) Applying a tactic to a goal can lead to a failure, when not all conditions are met, or is successful and produces a list of subgoals. The goal is only proven successfully, if all its subgoals are proven. In particular, if the goal is proven if the tactic application produces an empty list of subgoals. We refer to tactic applications sometimes also as proof steps.</p>
<p>We can think of proofs as trees, where goals are nodes and tactic applications are (hyper-)edges to other goals. In a successful proof, all leaves are goals with a tactic application that produced an empty list of subgoals.</p>
<h3>3.2 Instrumentation to HOL Light</h3>
<p>In order to create a stable, well-defined environment, we fix a particular version of HOL Light with a pre-selected subset of tactics and a fixed library of basic theorems, which are proved in one well-defined order. This is the ITP part of the environment</p>
<p>which is written in OCaml with a few additional C++ functions. Since it is non-trivial to find and build the exact correct set of libraries for this environment, we provide a prepackaged docker image. It can be used as a reliable black box for proof search and as reinforcement learning environment, communicated with using a simple API. We have also open sourced all the changes to the HOL Light system so that new modifications and forks are possible by third parties.</p>
<p>The prepackaged version we provide has the following additional instrumentation, which we describe below in detail:</p>
<ul>
<li>Logging of human-written proofs shipped with HOL Light.</li>
<li>A new API to interact with HOL Light for proof search.</li>
<li>Fast startup for distributed proof search.</li>
<li>A proof checker to remove the need to trust search algorithms.</li>
</ul>
<h3>3.3 Proof Logging for Human Proofs</h3>
<p>We want to utilize the existing human proofs for both training and evaluation. To that effect, we have instrumented the prove method in HOL Light with extra logging code. If HOL Light is executed in proof-dump mode, each invocation of the prove function dumps the proven theorems and their proofs into files. These proof logs can then be converted to training examples (see Section 4.1).</p>
<h3>3.4 Proof Assistant API</h3>
<p>The API provides two functions: (1) to apply tactics to goals and (2) to register theorems for future use in tactic applications. Tactic applications are completely stateless and contain the goal, the tactic to be applied, and the tactic arguments. The poof assistant (i.e. HOL Light in our implementation) returns the outcome of the tactic application, including the list of subgoals for successful applications. The stateless tactic application interface frees us from the strict order on subgoals that HOL Light enforces in the human interface, and allows us to easily implement more advanced proof search strategies.
The tactic arguments can consist of a list of theorems. Implemented naively, this list could make the tactic application request very large and could slow down the prover. In the argument list of tactics we therefore allow theorems to be referenced by a fingerprint number. The second API function allows us to register theorems such that HOL Light can resolve the fingerprints to theorems. The registration of theorems is hence stateful, in contrast to tactic applications.</p>
<h3>3.5 Fast Startup</h3>
<p>Starting HOL Light and loading all the potentially needed libraries can take a long time - we measured it at up to 20 minutes. This would be inhibitively long for proof search, especially in a distributed setting with thousands of workers and the startup time has to be paid for every worker. The Proof Assistant API allows us to load only a minimal core of HOL Light and register the remaining theorems from the libraries using the API. This brings the startup time of our HOL Light to mere seconds.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;">Definitions</th>
<th style="text-align: left;">Theorems</th>
<th style="text-align: left;">Proof states</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">core</td>
<td style="text-align: left;">239</td>
<td style="text-align: left;">2320</td>
<td style="text-align: left;">23512</td>
</tr>
<tr>
<td style="text-align: left;">complex</td>
<td style="text-align: left;">398</td>
<td style="text-align: left;">16623</td>
<td style="text-align: left;">509621</td>
</tr>
<tr>
<td style="text-align: left;">flyspeck</td>
<td style="text-align: left;">1563</td>
<td style="text-align: left;">10519</td>
<td style="text-align: left;">538540</td>
</tr>
<tr>
<td style="text-align: left;">all</td>
<td style="text-align: left;">2200</td>
<td style="text-align: left;">29462</td>
<td style="text-align: left;">1071673</td>
</tr>
</tbody>
</table>
<p>Table 1: The three corpora of the benchmark.</p>
<h3>3.6 Proof Checking</h3>
<p>Any bug in the implementation of a theorem prover could make its reasoning unsound, rendering the whole formalization effort futile. For that reason, HOL Light is designed around a small trusted core of about 400 lines of OCaml code that builds proofs from few very basic rules. OCaml's type system guarantees that a theorem object can only be constructed by this trusted core, and the rest of the HOL Light system can be seen as mere convenience features.
Our API allows researchers to implement proof search algorithms outside of OCaml. The correctness of any proof found through the API thus relies on the correctness of our API implementation and the proof search itself. We thus implemented a proof checker that avoids the need for trusting the proof search and even the API. The proof checker compiles proofs into OCaml code that can be loaded in HOL Light, where they have to pass through the trusted core.</p>
<h2>4 Benchmark</h2>
<p>We present three different corpora: "core", "complex", and "flyspeck." The core corpus contains the basic theorems that needed to define the tactics and the complex corpus consists of theorems of complex calculus. While proofs of core theorems are useful for training, we omit them in validation, since some tactics assume those theorems. Flyspeck contains most of the lemmas and theorems of the Kepler conjecture. Together these three corpora encompass almost 30k theorems and proofs (see Table 1).</p>
<p>We propose two tasks that can be measured on these benchmarks:</p>
<ul>
<li>Predict the tactic and tactic arguments that were employed in the human proof.</li>
<li>Prove each of the theorems in the corpora while utilizing only those theorems as tactic arguments that also humans had available. For that purpose, we provide all theorems in the three corpora in one unified list, in the order they were proven by humans.</li>
</ul>
<h3>4.1 Training Examples</h3>
<p>Our training examples consist of a goal, a tactic, an arglist, and a negarglist. The goal is a provable statement, i.e. it is either a theorem from one of the corpora or a subgoal of a successful proof. The tactic is the ID of one of a preselected small set of tactics (currently consisting of 41 tactics) that led to a successful proof. The arglist is the list of theorems that were passed to a tactic application as arguments. Additionally, there is a special argument signifying that the argument list was empty.</p>
<p>The negarglist is an optional list of non-arguments that is not actually necessary for any proof. negarglist consists of highscoring theorems that were not actually needed as arguments. They are collected during proof search in our reinforcement learning pipeline, and the list is empty for all the examples generated from the human proof logs.</p>
<h3>4.2 Splits</h3>
<p>Before training and evaluation, we have split the top level theorems into three subsets: training, validation and test set in a 60:20:20 ratio. Since the goals occurring in the proof of a theorem are likely correlated with the theorem itself, we assign them the same split as the theorem. The validation set can be used for continuous monitoring for proxy metrics of the model during training. The validation set is also occasionally used to measure the end-to-end prover performance of the models during training. The test set, on the other hand, must only be used extremely rarely for final assessment of a few models before publishing a paper alongside their validation set performance.</p>
<h3>4.3 Representation of Expressions</h3>
<p>All expressions are presented as S-expressions that have only few types of non-leaf nodes: function applications, abstractions (i.e. lambda functions), variables, constants, and function types. All other information, such as variable names, constant names, and type names, is given as leaf-nodes. For example, the expression $f(x)$ for a function $f: \mathbb{R} \rightarrow \mathbb{R}$ looks as follows: (a (v (fun (real) real) f) (v real x)). These S-expressions have a unique correspondence to terms in HOL Light and are easy to parse into a tree. However, our current models only observe the string version of these expressions. Expressions are quite long in this representation: The average number of tokens in the goals is around 500 , and the median is around 300 .
For many operations, HOL Light automatically invents new generic types (e.g. ?345882) and generic variables (e.g. GEN\%PVAR\%9675) on the fly. This leads to thousands of types and variables that often occur in only one (or a few) expressions, and hence would hardly get meaningful embeddings in typical deep learning approaches. Further, tokens that are shared only between few expressions bear the risk of unintentionally giving away information about the relations between these statements. We therefore decided to normalize the data sets by mapping generic types and generic variables to a much smaller set of names while maintaining the semantics of all expressions. After normalization, the number of distinct tokens is 1254 .</p>
<h2>5 DeepHOL Prover architecture</h2>
<p>In this section, we describe the high-level architecture of our reference neural prover. The intelligence is fully learned without any hand-crafted features, and with very simple data preprocessing. In particular, we have not implemented any tweaks for the particular logic or interactive theorem prover (ITP). All the engineering went into the neural network architecture, which is very generic, and into maintaining the proof search graph without any special regard for the particular ITP system. In other words, DeepHOL currently uses HOL Light and its logic (HOL),
but is not specialized to it. We believe that our solution would also work with other goal-tactic based prover like Coq [12], HOL4 [11], or Lean [15]. Here we describe the details of our reference prover solution in detail.</p>
<h3>5.1 Action Generator</h3>
<p>The most crucial part of our prover is the action generator that produces a list of tactic applications for a given goal. We have split this into two subtasks:</p>
<ul>
<li>To rank the tactics, and</li>
<li>to create an argument list for each of the tactics (comprised of a list of theorems).</li>
</ul>
<p>As noted earlier, DeepHOL is currently not using tactics that take arbitrary terms (formulas) as parameters.
For both subtasks, the action generator employs a neural network, which we describe in Section 5.4. The ranking of tactic applications it produces is used in the proof search (Section 5.3) to expand the proof search graph (Section 5.2).</p>
<h3>5.2 Proof Search Graph</h3>
<p>The proof search graph is our data structure that captures the state of the proof search, and allows us to detect when a proof for the original goal is available. The nodes of the proof search graph are the goals that we have seen in the proof search, including the original goal statement that we want to prove. Each goal can have multiple alternative tactic applications, each of which might result in multiple subgoals. That is, tactic applications are labelled hyperedges in the proof search graph.
The proof search graph provides some features that allow us to prune some subtrees of the search early: First, whenever a tactic application closes a subgoal, this information is traced back to the parent subgoals and each alternate tactic application (and its whole sub-branch) is marked as closed is discarded from the queue to be processed. If during this recursive process the root node is reached, then the proof is closed and the proof process stops. Second, when all tactic applications for a goal fail we mark that goal as unsuccessful. Similar to tracing closed goals, the proof search graph automatically traces the siblings of unsuccessful subgoals that become superflous, and mark them unsuccessful as well. Third, when tactic applications produce identical subgoals, we let them point to the same node in the proof search graph. We refer to this as subgoal sharing, and once a subgoal is newly shared, previously stored information about subgoals being closed or ignored is be propagated through the search graph.</p>
<h3>5.3 Proof Search</h3>
<p>Our proof search is a simple breadth first search. In each iteration, its expands all leaf nodes (i.e. goals that have not been expanded yet). To exand a goal, it calls the action generator to generate a list of tactic applications, and applies them in order. It stops applying tactics to a goal, when it reaches a maximum number of unsuccessful tactic applications or a minimum number of successful tactic applications. Whenever a complete proof is found for the top level goal, the proof search is stopped and</p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Two-tower neural architecture for ranking actions.
the whole proof search graph is serialized and stored as the result. Also, the proof search finishes if the search graph reaches a prescribed limit on the number of subgoals or the proof search times out.
Note that subgoal sharing, as explained in Section 5.2, is crucial for our proof search: Without subgoal sharing the search process could end up oscillating between two formulas by rewriting the same subterm back and forth using the same equation.</p>
<h3>5.4 Neural Architectures</h3>
<p>For the generation and ranking of actions in the action generator, we use a deep, two-tower neural network depicted in Figure 1. The predictions of the neural network are based on a single goal, represented as an S-expression of the HOL Light term (i.e. a string). (In HOL Light, each goal consists of a list of hypotheses and a conclusion, and we currently drop the hypotheses before we feed a goal to the neural network.)
The neural network has two separate prediction heads $S$ and $R$. The goal tower $G$ computes an embedding $G(g)$ of the current goal $g$ and infers a scoring vector $S(G(g))$ for the fixed set of tactics where the tactic classifier $S$ is a linear layer producing logits of a softmax classifier. The premise tower $P$ computes a fixed size embedding $P\left(t_{i}\right)$ of all possible tactic arguments $t_{i}$ in the scope of the goal to be proved. The ranking of the premises is performed by a combiner network $C$ that takes the concatenation of the goal embedding, the premise embedding and possibly that of the tactic $T_{j}$ to be applied: $r\left(t_{i}\right)=C\left(G(g), P\left(t_{i}\right), T_{j}\right)$, where $r\left(t_{i}\right)$ is the score of theorem $t_{i}$ for its being a useful tactic argument for transforming the current goal $g$ towards a closed proof. We have also tried the unconditioned setup, in which the ranking of the tactic arguments is independent of that of the tactic to be applied, that is $r\left(t_{i}\right)=C\left(G(g), P\left(t_{i}\right)\right)$. In essence, we propose a hybrid architecture that both predicts the correct tactic to be applied, as well as rank the premise parameters required for meaningful application of the tactics.</p>
<h3>5.5 Supervised Learning</h3>
<p>We started training DeepHOL in a supervised learning setup, for which we use the human proof logs. We have split our data into test, train, and validation set on the theorem level, as described in Section 4. We always report both validation and test set performance for the final result to verify that we did not over-fit on the validation set. Continuous measurements and ablation analyses are reported only on the validation or training set.</p>
<h3>5.6 Reinforcement Learning Loop</h3>
<p>In the reinforcement learning loop, we have both a trainer and multiple provers running continuously. The training is (optionally) seeded with training examples from existing (human/generated) proof logs. Then, we run the neural prover in rounds, each round trying to prove a random sample of theorems in the training set. Training examples extracted from successful proof logs of each round of our neural prover are mixed in continuously. Training examples of more recent rounds (fresh examples) can be weighed differently from older rounds (historical examples) during the training process.
To summarize, our loop works with the following four kinds of training example pools:</p>
<ol>
<li>(optional) Human training examples as seed.</li>
<li>(optional) Inherited computer generated examples as seed: in addition to using human training examples as seed, examples generated during any previous experiments with our prover can also be used as seed. In our current experiments, we used examples that were generated by a prover that was run on the whole training set utilizing a model that was trained in purely supervised manner.</li>
<li>Fresh generated loop examples (examples that were produced in the last $k$ rounds, where $k$ is a user-settable parameter).</li>
<li>Historical training loop examples (examples that were produced in all but the last $k$ rounds).</li>
</ol>
<p>During training, batches are filled with examples from each pool according to a prescribed split ratio. This means that the ratio of different kinds of examples the model is trained on does not shift as more examples are generated by the loop. Most importantly, it also ensures that examples from freshly constructed new proofs show up quickly and deterministically during the training process. Note that although we can make use of human and inherited proof traces, the system can learn without any supervision or initial seed data. However, preliminary experiments have shown that, in its current form, it learns inferior models compared to those that were seeded with human proofs.</p>
<h3>5.6.1 Proof Pruning</h3>
<p>The argument lists of tactic applications in the reinforcement learning loop are quite long, and they contain superfluous elements. In order to obtain high quality training data for tactic argument prediction, we prune the parameter list before using them for training. For all tactics that take a list of theorems as an argument, our current implementation generates a list of fixed length. For successful tactic applications, we then iterate over the arguments in reverse score order and greedily omit those arguments that do not change the outcome of the tactic application. While a non-greedy approach might yield even shorter argument lists, it would also take longer to compute. In practice, our approach produces short argument lists with minimal effort. Removed parameters are stored as "hard negatives" and utilized during training.</p>
<h2>6 Results and Comparisons</h2>
<p>In this section, we first present several baseline results based on imitation (i.e. fully supervised) learning. Then we come</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Description</th>
<th style="text-align: center;">Proof success</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">ASM_MESON_TAC</td>
<td style="text-align: center;">$6.1 \%$</td>
</tr>
<tr>
<td style="text-align: left;">ASM_MESON_TAC +</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">argument selection</td>
<td style="text-align: center;">$9.2 \%$</td>
</tr>
<tr>
<td style="text-align: left;">WaveNet</td>
<td style="text-align: center;">$31.72 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Deeper WaveNet</td>
<td style="text-align: center;">$32.65 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Wider WaveNet</td>
<td style="text-align: center;">$27.60 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Loop</td>
<td style="text-align: center;">$36.3 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Trained on loop output</td>
<td style="text-align: center;">$36.8 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Loop tactic dependent</td>
<td style="text-align: center;">$\mathbf{3 8 . 9 \%}$</td>
</tr>
</tbody>
</table>
<p>Table 2: Percentage of theorems closed using various models on the validation set of the complex corpus comprising of 3225 theorems. First two lines are trivial baselines that call HOL Light's built-in first order theorem prover with and without utilizing our argument selection model. The middle section shows results of models trained in a supervised scenario on human proofs. The last four lines report results using our reinforcement learning loops.
to our reinforcement learning results using a WaveNet [46] based encoder architecture, but with three different training methodologies.</p>
<h3>6.1 Model Training Hyperparameters</h3>
<p>All models were trained with the Adam optimizer [47] and exponentially decreasing learning rate starting at 0.0001 with decay rate 0.98 at every 100000 steps. For evaluation, we use moving exponential parameter averaging at a rate of 0.9999 per step [48, 49]. First, we established trivial baselines by running the built-in first-order theorem prover ASM_MESON_TAC on each theorem on the dataset with empty argument list and with an argument list predicted with our baseline WaveNet model. Next, we compare the performance of various WaveNet style architectures. Finally, we report our reinforcement learning experiments on the complex analysis corpus. Our final prover performance numbers are summarized in Table 2.</p>
<h3>6.2 Comparison of Model Architectures</h3>
<p>We trained and evaluated a large number of networks and present a sample of our findings. During our experiments, we looked at the following proxy metrics:</p>
<ol>
<li>Accuracy of tactic prediction out of the 41 possible tactics. (Ranging between $38 \%$ and $42 \%$ for most models.)</li>
<li>Success rate of selecting a positive tactic argument over a randomly selected negative argument. (Around $1 \%$ error rate).</li>
</ol>
<p>For the encoders, we have tried WaveNet [46] style networks with different hyper-parameters. The various results on the complex analysis corpus are based on imitation learning and the combination of imitation learning and reinforcement learning. In the base model we used two WaveNet blocks of four layers each. The number of filters in each block was either 128 or 256. As one can see in Table 2, the network with less filters did better. Then we tried a deeper variant with four blocks of five layers each, in this case with depth 128 . Here the deeper
<img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: This figure presents the cumulative number of proofs closed by the tactic dependent loop. The total number of theorems in the training set is 10199.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Maximum number of top tactics explored</th>
<th style="text-align: center;">$[6,16]$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Maximum successful tactic applications</td>
<td style="text-align: center;">$[3,6]$</td>
</tr>
<tr>
<td style="text-align: left;">Number of selected tactic arguments</td>
<td style="text-align: center;">$[1,32]$</td>
</tr>
</tbody>
</table>
<p>Table 3: Randomized proof search parameters and their ranges.
network with more blocks, which has 47 million parameters, turned out to be superior. Both architectures incorporate fully connected combiner layers with additional dropout layers before each of them. The ratio of dropped out neurons during training was 0.3 . Note that the reinforcement learning experiments was performed earlier and was ran with the narrow architecture (with 128 filters in each layer) and with two wavenet blocks.</p>
<h3>6.3 Reinforcement Learning</h3>
<p>In our reinforcement learning set up, the model training runs on a single GPU, while theorem proving is performed in a distributed manner: we attempt to prove 2000 randomly selected theorems from the training set of the union of the complex and core corpora in every round. At the start of each round, we fetch the latest trained model checkpoint and precompute the theorem argument embedding for each theorem in the complex and core libraries. This precomputation greatly accelerates the ranking of the tactic arguments. The proof search is distributed over 1000 cores and we set a computation limit of 100 explored proof states and a total timeout of 300 seconds. Each individual tactic application has a timeout of 5 seconds. Additionally, for each example, we pick prover options uniformly in the ranges described by Table 3, to increase the diversity of the generated proofs. This also increases the chance of finding a proof at all for harder statements.
Given the high computational cost of running the reinforcement learning loop, we have only tried a couple of variants. Each of our these experiments use the same version of WaveNet [46] architecture (with 128 filters in each layer). In our first loop experiment, "Loop", we trained a loop with tactic independent argument selection. That is, the tactic argument ranking was independent of the tactic chosen, and we pick only top level theorems to be proved by proof search in the reinforcement</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: center;">Theorems proved <br> (\% of training set)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Name</td>
<td style="text-align: center;">$5679(55.7 \%)$</td>
</tr>
<tr>
<td style="text-align: left;">Loop</td>
<td style="text-align: center;">$5518(54.1 \%)$</td>
</tr>
<tr>
<td style="text-align: left;">Loop tactic dependent</td>
<td style="text-align: center;">$1988(19.5 \%)$</td>
</tr>
<tr>
<td style="text-align: left;">Loop on subgoals</td>
<td style="text-align: center;">$5919(58.0 \%)$</td>
</tr>
<tr>
<td style="text-align: left;">Union</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>Table 4: Total count of proofs found by each loop.
<img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: Percentage of theorems proved in each round of the loop. Each round samples 2000 theorems from the training set.
learning scenario. Alongside our first loop, we trained a separate model "Trained on loop output" that was not used in the loop for proof search guidance, but did benefit from a curriculum-style learning, since it trained in parallel to the loop. In our second loop experiment, "Loop tactic dependent", we have trained a model in which the arguments ranking depends on the selected tactic. In our third loop experiment, "Loop on subgoals", the proof search can pick from any of the internal proof states from the training set of the joined core+complex corpus. This was motivated partially by the success of [50], we tried to run a reinforcement learning loop in which we train for solving each subgoal separately, hoping that it will help for learning longer proofs. This means, that we expected a bigger variety of theorems to be generated during proof search. However, our naive implementation did not seem to end up with improved results. Performance of each loop's final checkpoint on the validation set is presented in Table 2. We also ran the final checkpoint of the "Loop" on a sample of 2000 proofs from the flyspeck dataset; we closed $752(37.0 \%)$ of these proofs automatically.
While it was too computationally expensive to track the validation performance on every round of the loop, we did record the performance on the training set. In Fig. 2, we show the cumulative number of proofs closed by the tactic dependent loop at each round. Recall that in each round we sample theorems from the training set and use the most recent checkpoint to guide the proof search. In Fig. 3, we show the percentage of the sampled theorems that are proved in each round.</p>
<h2>7 Conclusion</h2>
<p>We presented a machine learning oriented open source environment for higher-order theorem proving as well as a neural network based automated prover, trained on a large-scale reinforcement learning system. We also suggest a benchmark for machine reasoning in higher-order logic on a relatively large and practically relevant corpus of theorems with varying complexity. Our benchmark includes purely neural network based baselines, which demonstrate strong automated reasoning capabilities, including premise selection from a large number of theorems. We hope that our initial effort fosters collaboration and paves the way for strong and practical AI systems that can learn to reason efficiently in large formal theories.</p>
<h2>Acknowledgements</h2>
<p>We would like to thank Alex Alemi, Geoffrey Irving, Cezary Kaliszyk, Thibault Gauthier, Ramana Kumar, Viktor Toman, and Josef Urban for their insightful comments and contributions to early versions of this work.</p>
<h2>References</h2>
<p>[1] Vassil Panayotov, Guoguo Chen, Daniel Povey, and Sanjeev Khudanpur. Librispeech: an asr corpus based on public domain audio books. In Acoustics, Speech and Signal Processing (ICASSP), 2015 IEEE International Conference on, pages 5206-5210. IEEE, 2015.
[2] James Bennett, Stan Lanning, et al. The netflix prize. In Proceedings of KDD cup and workshop, volume 2007, page 35. New York, NY, USA, 2007.
[3] Jia Deng, Wei Dong, Richard Socher, Li-Jia Li, Kai Li, and Li Fei-Fei. Imagenet: A large-scale hierarchical image database. In Computer Vision and Pattern Recognition, 2009. CVPR 2009. IEEE Conference on, pages 248-255. Ieee, 2009.
[4] Tsung-Yi Lin, Michael Maire, Serge Belongie, James Hays, Pietro Perona, Deva Ramanan, Piotr Dollár, and C Lawrence Zitnick. Microsoft coco: Common objects in context. In European conference on computer vision, pages 740-755. Springer, 2014.
[5] Ondrej Bojar, Christian Buck, Christian Federmann, Barry Haddow, Philipp Koehn, Johannes Leveling, Christof Monz, Pavel Pecina, Matt Post, Herve Saint-Amand, et al. Findings of the 2014 workshop on statistical machine translation. In Proceedings of the ninth workshop on statistical machine translation, pages 12-58, 2014.
[6] Pranav Rajpurkar, Jian Zhang, Konstantin Lopyrev, and Percy Liang. Squad: 100,000+ questions for machine comprehension of text. arXiv preprint arXiv:1606.05250, 2016.
[7] Thomas Hales, Mark Adams, Gertrud Bauer, Tat Dat Dang, John Harrison, Hoang Le Truong, Cezary Kaliszyk, Victor Magron, Sean McLaughlin, Tat Thang Nguyen, et al. A formal proof of the kepler conjecture. In Forum of Mathematics, Pi, volume 5. Cambridge University Press, 2017.</p>
<p>[8] Josef Urban, Geoff Sutcliffe, Petr Pudlák, and Jiří Vyskočil. Malarea sg1-machine learner for automated reasoning with semantic guidance. In International Joint Conference on Automated Reasoning, pages 441-456. Springer, 2008.
[9] Thibault Gauthier, Cezary Kaliszyk, and Josef Urban. Tactictoe: Learning to reason with hol4 tactics. In LPAR-21. 21st International Conference on Logic for Programming, Artificial Intelligence and Reasoning, volume 46, pages $125-143,2017$.
[10] Daniel Huang, Prafulla Dhariwal, Dawn Song, and Ilya Sutskever. Gamepad: A learning environment for theorem proving. arXiv preprint arXiv:1806.00608, 2018.
[11] Konrad Slind and Michael Norrish. A brief overview of hol4. In International Conference on Theorem Proving in Higher Order Logics, pages 28-32. Springer, 2008.
[12] Yves Bertot and Pierre Castéran. Interactive theorem proving and program development: Coq'Art: the calculus of inductive constructions. Springer Science \&amp; Business Media, 2013.
[13] Mizar. The Mizar Mathematical Library. URL http: //mizar.org. Accessed: 2018/01/18.
[14] Makarius Wenzel, Lawrence C. Paulson, and Tobias Nipkow. The isabelle framework. In Otmane Aït Mohamed, César A. Muñoz, and Sofiène Tahar, editors, Theorem Proving in Higher Order Logics, 21st International Conference, TPHOLs 2008, Montreal, Canada, August 18-21, 2008. Proceedings, volume 5170 of Lecture Notes in Computer Science, pages 33-38. Springer, 2008.
[15] Leonardo de Moura, Soonho Kong, Jeremy Avigad, Floris Van Doorn, and Jakob von Raumer. The lean theorem prover (system description). In International Conference on Automated Deduction, pages 378-388. Springer, 2015.
[16] Gerwin Klein, Kevin Elphinstone, Gernot Heiser, June Andronick, David Cock, Philip Derrin, Dhammika Elkaduwe, Kai Engelhardt, Rafal Kolanski, Michael Norrish, Thomas Sewell, Harvey Tuch, and Simon Winwood. sel4: Formal verification of an os kernel. In Proceedings of the ACM SIGOPS 22Nd Symposium on Operating Systems Principles, SOSP '09, pages 207-220, New York, NY, USA, 2009. ACM. ISBN 978-1-60558-752-3. doi: 10.1145/1629575.1629596. URL http://doi.acm.org/ $10.1145 / 1629575.1629596$.
[17] Cezary Kaliszyk and Josef Urban. Learning-assisted automated reasoning with flyspeck. Journal of Automated Reasoning, 53(2):173-213, 2014.
[18] Cezary Kaliszyk and Josef Urban. Initial experiments with external provers and premise selection on hol light corpora. 2012.
[19] Alexander A Alemi, François Chollet, Geoffrey Irving, Niklas Eén, Christian Szegedy, and Josef Urban. Deepmath-deep sequence models for premise selection. In Advances in Neural Information Processing Systems, pages 2235-2243, 2016.
[20] Stephan Schulz. E - A Brainiac Theorem Prover. AI Commun., 15(2-3):111-126, 2002.
[21] Daniel Whalen. Holophrasm: a neural automated theorem prover for higher-order logic. arXiv preprint arXiv:1608.02644, 2016.
[22] Norman Megill. Metamath: A computer language for pure mathematics. 1997.
[23] Sarah Loos, Geoffrey Irving, Christian Szegedy, and Cezary Kaliszyk. Deep network guided proof search. arXiv preprint arXiv:1701.06972, 2017.
[24] Cezary Kaliszyk, François Chollet, and Christian Szegedy. Holstep: A machine learning dataset for higher-order logic theorem proving. arXiv preprint arXiv:1703.00426, 2017.
[25] Cezary Kaliszyk, Josef Urban, Henryk Michalewski, and Mirek Olšák. Reinforcement learning of theorem proving. arXiv preprint arXiv:1805.07563, 2018.
[26] Rong-En Fan, Kai-Wei Chang, Cho-Jui Hsieh, Xiang-Rui Wang, and Chih-Jen Lin. Liblinear: A library for large linear classification. Journal of machine learning research, 9(Aug):1871-1874, 2008.
[27] Jens Otten and Wolfgang Bibel. leanCoP: lean connectionbased theorem proving. J. Symb. Comput., 36(1-2):139161, 2003.
[28] Stephan Schulz. Learning search control knowledge for equational deduction, volume 230 of DISKI. Infix Akademische Verlagsgesellschaft, 2000. ISBN 978-3-89838-230-4.
[29] Hazel Duncan, A Bundy, J Levine, A Storkey, and M Pollet. The use of data-mining for the automatic formation of tactics. 2004.
[30] Josef Urban, Jiří Vyskočil, and Petr Štěpánek. Malecop machine learning connection prover. In International Conference on Automated Reasoning with Analytic Tableaux and Related Methods, pages 263-277. Springer, 2011.
[31] Daniel Kühlwein, Twan van Laarhoven, Evgeni Tsivtsivadze, Josef Urban, and Tom Heskes. Overview and evaluation of premise selection techniques for large theory mathematics. In International Joint Conference on Automated Reasoning, pages 378-392. Springer, 2012.
[32] Cezary Kaliszyk and Josef Urban. Stronger automation for flyspeck by feature weighting and strategy evolution. 2013.
[33] Daniel Kühlwein, Jasmin Christian Blanchette, Cezary Kaliszyk, and Josef Urban. Mash: machine learning for sledgehammer. In International Conference on Interactive Theorem Proving, pages 35-50. Springer, 2013.
[34] Jesse Alama, Tom Heskes, Daniel Kühlwein, Evgeni Tsivtsivadze, and Josef Urban. Premise selection for mathematics by corpus analysis and kernel methods. Journal of Automated Reasoning, 52(2):191-213, 2014.
[35] James P. Bridge, Sean B. Holden, and Lawrence C. Paulson. Machine learning for first-order theorem proving. J. Autom. Reasoning, pages 1-32, 2014. ISSN 0168-7433. doi: 10. 1007/s10817-014-9301-5. URL http://dx.doi.org/ 10.1007/s10817-014-9301-5.
[36] Cezary Kaliszyk, Josef Urban, and Jiří Vyskočil. Machine learner for automated reasoning 0.4 and 0.5 . arXiv preprint arXiv:1402.2359, 2014.</p>
<p>[37] Cezary Kaliszyk, Lionel Mamane, and Josef Urban. Machine learning of coq proof guidance: First experiments. arXiv preprint arXiv:1410.5467, 2014.
[38] Michael Färber and Cezary Kaliszyk. Random forests for premise selection. In International Symposium on Frontiers of Combining Systems, pages 325-340. Springer, 2015.
[39] Cezary Kaliszyk and Josef Urban. Mizar 40 for mizar 40. Journal of Automated Reasoning, 55(3):245-256, 2015.
[40] Cezary Kaliszyk, Josef Urban, and Jirí Vyskocil. Efficient semantic features for automated reasoning over large theories. In IJCAI, 2015.
[41] Cezary Kaliszyk and Josef Urban. Femalecop: Fairly efficient machine learning connection prover. In Logic for Programming, Artificial Intelligence, and Reasoning, pages 88-96. Springer, 2015.
[42] Cezary Kaliszyk and Josef Urban. Learning-assisted theorem proving with millions of lemmas. Journal of symbolic computation, 69:109-128, 2015.
[43] Thibault Gauthier and Cezary Kaliszyk. Premise selection and external provers for hol4. In Proceedings of the 2015 Conference on Certified Programs and Proofs, pages 4957. ACM, 2015.
[44] Jasmin Christian Blanchette, David Greenaway, Cezary Kaliszyk, Daniel Kühlwein, and Josef Urban. A learningbased fact selector for isabelle/hol. Journal of Automated Reasoning, 57(3):219-244, 2016.
[45] Mingzhe Wang, Yihe Tang, Jian Wang, and Jia Deng. Premise selection for theorem proving by deep graph embedding. In Advances in Neural Information Processing Systems, pages 2786-2796, 2017.
[46] Aäron Van Den Oord, Sander Dieleman, Heiga Zen, Karen Simonyan, Oriol Vinyals, Alex Graves, Nal Kalchbrenner, Andrew Senior, and Koray Kavukcuoglu. Wavenet: A generative model for raw audio. CoRR abs/1609.03499, 2016.
[47] Diederik P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980, 2014.
[48] Boris Teodorovich Polyak. A new method of stochastic approximation type. Avtomatika i telemekhanika, 7:98107, 1990.
[49] Boris T Polyak and Anatoli B Juditsky. Acceleration of stochastic approximation by averaging. SIAM Journal on Control and Optimization, 30(4):838-855, 1992.
[50] Zsolt Zombori, Adrián Csiszárik, Henryk Michalewski, Cezary Kaliszyk, and Josef Urban. Curriculum learning and theorem proving. In AITP, 2019.</p>            </div>
        </div>

    </div>
</body>
</html>