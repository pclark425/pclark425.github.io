<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-1593 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-1593</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-1593</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-31.html">extraction-schema-31</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <p><strong>Paper ID:</strong> paper-32202511</p>
                <p><strong>Paper Title:</strong> <a href="https://arxiv.org/pdf/1709.05703v1.pdf" target="_blank">AI Programmer: Autonomously Creating Software Programs Using Genetic Algorithms</a></p>
                <p><strong>Paper Abstract:</strong> In this paper, we present the first-of-its-kind machine learning (ML) system, called AI Programmer, that can automatically generate full software programs requiring only minimal human guidance. At its core, AI Programmer uses genetic algorithms (GA) coupled with a tightly constrained programming language that minimizes the overhead of its ML search space. Part of AI Programmer's novelty stems from (i) its unique system design, including an embedded, hand-crafted interpreter for efficiency and security and (ii) its augmentation of GAs to include instruction-gene randomization bindings and programming language-specific genome construction and elimination techniques. We provide a detailed examination of AI Programmer's system design, several examples detailing how the system works, and experimental data demonstrating its software generation capabilities and performance using only mainstream CPUs.</p>
                <p><strong>Cost:</strong> 0.014</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e1593.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e1593.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>AI Programmer</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>AI Programmer: Autonomously Creating Software Programs Using Genetic Algorithms</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A GA-based system that evolves byte-level programs in a minimal, typeless 8-instruction language; genomes are floating-point arrays mapped to instructions, and programs are evolved via roulette selection, crossover and mutation and evaluated by user-defined fitness tests inside a sandboxed interpreter to ensure safety and executability.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>AI Programmer</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>AI Programmer represents programs as genomes: arrays of floating-point values in [0,1] where subranges map to 8 instructions of a minimal typeless language (brainfuck-like). A population of genomes is initialized randomly, evaluated by executing the decoded programs inside a sandboxed interpreter, and assigned fitness by user-defined fitness tests (byte-level output matching, internal-state checks, sequence/timing bonuses). Evolution proceeds with roulette (fitness-proportionate) selection, crossover to combine parent gene segments, and mutation to perturb gene values. The system includes execution-safety measures (sandbox interpreter, instruction-count limits, simulation of expensive instructions) and optional extended instruction sets to accelerate reaching high-level ASCII values.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs (byte-level programs in a minimal typeless language)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Selection uses roulette (fitness-proportionate) selection to choose parents. Offspring are produced by copying contiguous segments of parent genomes into children (illustrated as inheriting the first N instructions from a parent in the paper); the paper describes segment/contiguous inheritance (single-point/segment-style crossover as illustrated), allowing potentially beneficial instruction subsequences to be copied forward into children. Exact multi-parent protocol and crossover rates are not numerically specified.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Mutation is implemented by applying controlled random perturbations to specific floating-point gene values in the genome (i.e., altering a gene's float value so its mapped instruction may change). The paper describes mutation as random changes to gene values (either replacement or perturbation) but does not give a precise mutation distribution or per-gene mutation rate in numeric form.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td>No formal novelty metric is reported. The paper describes fitness-function driven heuristics to encourage diverse/novel behaviors: (1) adding a bonus proportional to the number of distinct memory registers (data cells) used (to encourage solutions using more memory), (2) recording and penalizing reuse of the same print instruction pointer to discourage repeated identical print sites, and (3) applying programmatic-sequence bonuses when I/O actions occur at correct times. Gene encoding uses uniform gene-range mapping to ensure each instruction has equal randomization probability.</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Executability/functionality is measured by user-defined fitness tests evaluating program output and internal behaviour: common measures include byte-level character closeness (per-character distances), exact-length bonuses, and aggregated target scores. Example: for exact string output 'Hello World' the target fitness = (number_of_characters * 256) = 11 * 256 = 2816; per-character contribution is computed as 256 - abs(generated_byte - target_byte). Other executability checks inspect interpreter internal state (data pointer usage, instruction pointers) and apply sequence/timing bonuses. Infinite or overlong executions are terminated by a configurable maximum instruction count and incur fitness penalties.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>Quantitative program-generation outcomes reported as generations (and sometimes wall-clock seconds). Representative results: 'hi' (successful) after ~5,700 generations; 'hello world' after ~580,900 generations; 'I love all humans' after ~6,057,200 generations; reverse-string program after ~2,600 generations; addition after ~92,400 generations; subtraction after ~177,900 generations; Fibonacci (up to 233) reported in ~151,900 generations (≈21,862 s). These show the system produced executable, functional programs across many small program synthesis tasks on commodity CPU hardware.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>No formal numerical diversity metric reported. Diversity is fostered via genetic operators (crossover + mutation) and fitness-based incentives: bonuses for increased distinct memory-register usage and penalties for reuse of identical print instruction pointers to encourage distinct program behaviors. The population-level diversity otherwise is not quantified (no genotypic/phenotypic entropy or distance statistics provided).</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Qualitative tradeoffs are discussed: maximizing fitness without execution constraints can promote behaviors harmful to practical executability (e.g., programs that run for extremely long times or enter infinite loops); to mitigate this, AI Programmer imposes instruction-count limits and fitness penalties for exceeded limits, trading off some raw fitness for guaranteed termination and safety. Another tradeoff: extended instruction sets speed generation (improve executability convergence) but produce programs incompatible with standard external interpreters (reduced portability/executability outside the sandbox). Also, working code segments can be followed by syntactic errors later in a genome without reducing fitness, so syntactic ‘novel’ garbage can coexist with executable subsequences.</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>program synthesis / code generation / automatic program induction</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>No direct experimental baseline comparisons reported in the paper (the paper does not experimentally compare to other program synthesis systems; related work references classical GP literature but presents no quantitative head-to-head baselines).</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>1) A strongly-constrained minimal instruction set (8 instructions) drastically reduces search space and makes GA-driven program generation tractable on commodity hardware. 2) Representing genomes as floats mapped uniformly to instruction ranges allows straightforward crossover/mutation and uniform initial sampling. 3) Roulette selection with crossover and mutation can discover fully functional programs (string output, arithmetic, conditionals, reverse-string, Fibonacci) given carefully designed fitness tests that score byte-level output and internal program state. 4) Sandboxed execution, instruction-count limits, and simulation of expensive operations are required to guarantee safety and practical execution times. 5) Fitness-function engineering (internal state checks, memory-usage bonuses, print-instruction penalties, sequence bonuses) is crucial to guide evolution toward non-trivial behaviors (e.g., conditionals); these serve as implicit novelty/diversity incentives though no formal novelty metric was used. 6) Extended instruction sets accelerate convergence but can reduce portability of generated programs to standard interpreters.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'AI Programmer: Autonomously Creating Software Programs Using Genetic Algorithms', 'publication_date_yy_mm': '2017-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1593.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e1593.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Koza GP (analog circuits)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Automated synthesis of analog electrical circuits by means of genetic programming</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Mentioned related work where genetic programming was used to automatically design analog circuits using evolutionary operators and human-constructed fitness tests.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Automated synthesis of analog electrical circuits by means of genetic programming</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Koza-style genetic programming for circuit synthesis</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Classic genetic programming approach evolving program-like representations (trees) to synthesize analog circuit topologies and parameter values; evolution guided by human-defined fitness functions specific to circuit behavior.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>circuit designs / program-like expressions (not code literatures)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>hardware design / analog circuit synthesis (related work)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Cited as related prior work demonstrating GP can produce human-competitive artifacts in specialized domains when guided by suitable fitness functions.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'AI Programmer: Autonomously Creating Software Programs Using Genetic Algorithms', 'publication_date_yy_mm': '2017-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1593.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e1593.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Ragaraja (Ling)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Ragaraja: An artificial life simulation library based on genetic algorithm, 3-character genetic code and biological hierarchy</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Mentioned related work that used a constrained esoteric language (3-character instructions) and GA-based evolution to simplify the search space in artificial life simulations, analogous to the minimal-language approach of AI Programmer.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>An artificial life simulation library based on genetic algorithm, 3-character genetic code and biological hierarchy</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Ragaraja (esoteric 3-character GA system)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>A genetic-algorithm-based artificial life simulator that encodes behavior in a highly-constrained 3-character instruction set, reducing programmatic search-space complexity and easing evolutionary operations like mutation and crossover.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>esoteric instruction sequences / agent programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>artificial life / simulation (related work)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Cited to support the benefit of constrained instruction sets to reduce computational search complexity in evolutionary program/agent generation.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'AI Programmer: Autonomously Creating Software Programs Using Genetic Algorithms', 'publication_date_yy_mm': '2017-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Automated synthesis of analog electrical circuits by means of genetic programming <em>(Rating: 2)</em></li>
                <li>Human-competitive results produced by genetic programming <em>(Rating: 2)</em></li>
                <li>An artificial life simulation library based on genetic algorithm, 3-character genetic code and biological hierarchy <em>(Rating: 2)</em></li>
                <li>Genetic Algorithms Plus Data Structures Equals Evolution Programs <em>(Rating: 1)</em></li>
                <li>An Introduction to Genetic Algorithms <em>(Rating: 1)</em></li>
                <li>Open issues in genetic programming <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-1593",
    "paper_id": "paper-32202511",
    "extraction_schema_id": "extraction-schema-31",
    "extracted_data": [
        {
            "name_short": "AI Programmer",
            "name_full": "AI Programmer: Autonomously Creating Software Programs Using Genetic Algorithms",
            "brief_description": "A GA-based system that evolves byte-level programs in a minimal, typeless 8-instruction language; genomes are floating-point arrays mapped to instructions, and programs are evolved via roulette selection, crossover and mutation and evaluated by user-defined fitness tests inside a sandboxed interpreter to ensure safety and executability.",
            "citation_title": "here",
            "mention_or_use": "use",
            "system_name": "AI Programmer",
            "system_description": "AI Programmer represents programs as genomes: arrays of floating-point values in [0,1] where subranges map to 8 instructions of a minimal typeless language (brainfuck-like). A population of genomes is initialized randomly, evaluated by executing the decoded programs inside a sandboxed interpreter, and assigned fitness by user-defined fitness tests (byte-level output matching, internal-state checks, sequence/timing bonuses). Evolution proceeds with roulette (fitness-proportionate) selection, crossover to combine parent gene segments, and mutation to perturb gene values. The system includes execution-safety measures (sandbox interpreter, instruction-count limits, simulation of expensive instructions) and optional extended instruction sets to accelerate reaching high-level ASCII values.",
            "input_type": "programs (byte-level programs in a minimal typeless language)",
            "crossover_operation": "Selection uses roulette (fitness-proportionate) selection to choose parents. Offspring are produced by copying contiguous segments of parent genomes into children (illustrated as inheriting the first N instructions from a parent in the paper); the paper describes segment/contiguous inheritance (single-point/segment-style crossover as illustrated), allowing potentially beneficial instruction subsequences to be copied forward into children. Exact multi-parent protocol and crossover rates are not numerically specified.",
            "mutation_operation": "Mutation is implemented by applying controlled random perturbations to specific floating-point gene values in the genome (i.e., altering a gene's float value so its mapped instruction may change). The paper describes mutation as random changes to gene values (either replacement or perturbation) but does not give a precise mutation distribution or per-gene mutation rate in numeric form.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": "No formal novelty metric is reported. The paper describes fitness-function driven heuristics to encourage diverse/novel behaviors: (1) adding a bonus proportional to the number of distinct memory registers (data cells) used (to encourage solutions using more memory), (2) recording and penalizing reuse of the same print instruction pointer to discourage repeated identical print sites, and (3) applying programmatic-sequence bonuses when I/O actions occur at correct times. Gene encoding uses uniform gene-range mapping to ensure each instruction has equal randomization probability.",
            "novelty_results": null,
            "executability_metric": "Executability/functionality is measured by user-defined fitness tests evaluating program output and internal behaviour: common measures include byte-level character closeness (per-character distances), exact-length bonuses, and aggregated target scores. Example: for exact string output 'Hello World' the target fitness = (number_of_characters * 256) = 11 * 256 = 2816; per-character contribution is computed as 256 - abs(generated_byte - target_byte). Other executability checks inspect interpreter internal state (data pointer usage, instruction pointers) and apply sequence/timing bonuses. Infinite or overlong executions are terminated by a configurable maximum instruction count and incur fitness penalties.",
            "executability_results": "Quantitative program-generation outcomes reported as generations (and sometimes wall-clock seconds). Representative results: 'hi' (successful) after ~5,700 generations; 'hello world' after ~580,900 generations; 'I love all humans' after ~6,057,200 generations; reverse-string program after ~2,600 generations; addition after ~92,400 generations; subtraction after ~177,900 generations; Fibonacci (up to 233) reported in ~151,900 generations (≈21,862 s). These show the system produced executable, functional programs across many small program synthesis tasks on commodity CPU hardware.",
            "diversity_metric": "No formal numerical diversity metric reported. Diversity is fostered via genetic operators (crossover + mutation) and fitness-based incentives: bonuses for increased distinct memory-register usage and penalties for reuse of identical print instruction pointers to encourage distinct program behaviors. The population-level diversity otherwise is not quantified (no genotypic/phenotypic entropy or distance statistics provided).",
            "diversity_results": null,
            "novelty_executability_tradeoff": "Qualitative tradeoffs are discussed: maximizing fitness without execution constraints can promote behaviors harmful to practical executability (e.g., programs that run for extremely long times or enter infinite loops); to mitigate this, AI Programmer imposes instruction-count limits and fitness penalties for exceeded limits, trading off some raw fitness for guaranteed termination and safety. Another tradeoff: extended instruction sets speed generation (improve executability convergence) but produce programs incompatible with standard external interpreters (reduced portability/executability outside the sandbox). Also, working code segments can be followed by syntactic errors later in a genome without reducing fitness, so syntactic ‘novel’ garbage can coexist with executable subsequences.",
            "frontier_characterization": null,
            "benchmark_or_domain": "program synthesis / code generation / automatic program induction",
            "comparison_baseline": "No direct experimental baseline comparisons reported in the paper (the paper does not experimentally compare to other program synthesis systems; related work references classical GP literature but presents no quantitative head-to-head baselines).",
            "key_findings": "1) A strongly-constrained minimal instruction set (8 instructions) drastically reduces search space and makes GA-driven program generation tractable on commodity hardware. 2) Representing genomes as floats mapped uniformly to instruction ranges allows straightforward crossover/mutation and uniform initial sampling. 3) Roulette selection with crossover and mutation can discover fully functional programs (string output, arithmetic, conditionals, reverse-string, Fibonacci) given carefully designed fitness tests that score byte-level output and internal program state. 4) Sandboxed execution, instruction-count limits, and simulation of expensive operations are required to guarantee safety and practical execution times. 5) Fitness-function engineering (internal state checks, memory-usage bonuses, print-instruction penalties, sequence bonuses) is crucial to guide evolution toward non-trivial behaviors (e.g., conditionals); these serve as implicit novelty/diversity incentives though no formal novelty metric was used. 6) Extended instruction sets accelerate convergence but can reduce portability of generated programs to standard interpreters.",
            "uuid": "e1593.0",
            "source_info": {
                "paper_title": "AI Programmer: Autonomously Creating Software Programs Using Genetic Algorithms",
                "publication_date_yy_mm": "2017-09"
            }
        },
        {
            "name_short": "Koza GP (analog circuits)",
            "name_full": "Automated synthesis of analog electrical circuits by means of genetic programming",
            "brief_description": "Mentioned related work where genetic programming was used to automatically design analog circuits using evolutionary operators and human-constructed fitness tests.",
            "citation_title": "Automated synthesis of analog electrical circuits by means of genetic programming",
            "mention_or_use": "mention",
            "system_name": "Koza-style genetic programming for circuit synthesis",
            "system_description": "Classic genetic programming approach evolving program-like representations (trees) to synthesize analog circuit topologies and parameter values; evolution guided by human-defined fitness functions specific to circuit behavior.",
            "input_type": "circuit designs / program-like expressions (not code literatures)",
            "crossover_operation": null,
            "mutation_operation": null,
            "uses_literature": false,
            "uses_code": false,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "hardware design / analog circuit synthesis (related work)",
            "comparison_baseline": null,
            "key_findings": "Cited as related prior work demonstrating GP can produce human-competitive artifacts in specialized domains when guided by suitable fitness functions.",
            "uuid": "e1593.1",
            "source_info": {
                "paper_title": "AI Programmer: Autonomously Creating Software Programs Using Genetic Algorithms",
                "publication_date_yy_mm": "2017-09"
            }
        },
        {
            "name_short": "Ragaraja (Ling)",
            "name_full": "Ragaraja: An artificial life simulation library based on genetic algorithm, 3-character genetic code and biological hierarchy",
            "brief_description": "Mentioned related work that used a constrained esoteric language (3-character instructions) and GA-based evolution to simplify the search space in artificial life simulations, analogous to the minimal-language approach of AI Programmer.",
            "citation_title": "An artificial life simulation library based on genetic algorithm, 3-character genetic code and biological hierarchy",
            "mention_or_use": "mention",
            "system_name": "Ragaraja (esoteric 3-character GA system)",
            "system_description": "A genetic-algorithm-based artificial life simulator that encodes behavior in a highly-constrained 3-character instruction set, reducing programmatic search-space complexity and easing evolutionary operations like mutation and crossover.",
            "input_type": "esoteric instruction sequences / agent programs",
            "crossover_operation": null,
            "mutation_operation": null,
            "uses_literature": false,
            "uses_code": false,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "artificial life / simulation (related work)",
            "comparison_baseline": null,
            "key_findings": "Cited to support the benefit of constrained instruction sets to reduce computational search complexity in evolutionary program/agent generation.",
            "uuid": "e1593.2",
            "source_info": {
                "paper_title": "AI Programmer: Autonomously Creating Software Programs Using Genetic Algorithms",
                "publication_date_yy_mm": "2017-09"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Automated synthesis of analog electrical circuits by means of genetic programming",
            "rating": 2,
            "sanitized_title": "automated_synthesis_of_analog_electrical_circuits_by_means_of_genetic_programming"
        },
        {
            "paper_title": "Human-competitive results produced by genetic programming",
            "rating": 2,
            "sanitized_title": "humancompetitive_results_produced_by_genetic_programming"
        },
        {
            "paper_title": "An artificial life simulation library based on genetic algorithm, 3-character genetic code and biological hierarchy",
            "rating": 2,
            "sanitized_title": "an_artificial_life_simulation_library_based_on_genetic_algorithm_3character_genetic_code_and_biological_hierarchy"
        },
        {
            "paper_title": "Genetic Algorithms Plus Data Structures Equals Evolution Programs",
            "rating": 1,
            "sanitized_title": "genetic_algorithms_plus_data_structures_equals_evolution_programs"
        },
        {
            "paper_title": "An Introduction to Genetic Algorithms",
            "rating": 1,
            "sanitized_title": "an_introduction_to_genetic_algorithms"
        },
        {
            "paper_title": "Open issues in genetic programming",
            "rating": 1,
            "sanitized_title": "open_issues_in_genetic_programming"
        }
    ],
    "cost": 0.013560749999999998,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>AI Programmer: Autonomously Creating Software Programs Using Genetic Algorithms
17 Sep 2017</p>
<p>Kory Becker kbecker@primaryobjects.com 
Justin Gottschlich justin.gottschlich@intel.com 
AI Programmer: Autonomously Creating Software Programs Using Genetic Algorithms
17 Sep 2017454F22B26418768D630CC56E4BF8BBBFarXiv:1709.05703v1[cs.AI]Genetic algorithmprogram synthesisgenetic programmingevolutionary computationartificial intelligencemachine learningprogramming languagescode generation and optimization
In this paper, we present the first-of-its-kind machine learning (ML) system, called AI Programmer, that can automatically generate full software programs requiring only minimal human guidance.At its core, AI Programmer uses genetic algorithms (GA) coupled with a tightly constrained programming language that minimizes the overhead of its ML search space.Part of AI Programmer's novelty stems from (i) its unique system design, including an embedded, hand-crafted interpreter for efficiency and security and (ii) its augmentation of GAs to include instruction-gene randomization bindings and programming language-specific genome construction and elimination techniques.We provide a detailed examination of AI Programmer's system design, several examples detailing how the system works, and experimental data demonstrating its software generation capabilities and performance using only mainstream CPUs.</p>
<p>Introduction</p>
<p>Since the invention of the computer, having the ability to correctly and efficiently develop software programs has been a principle challenge [6].To help address this, countless breakthroughs have been made in the field of software development.Some of these include safety and flexibility advances in static, dynamic, and gradual type systems [5,34]; simplification, safety, and robustness advances using automatic memory management and garbage collection systems [7,15]; generality and specificity progress in both general-purpose and domain specific languages [33,38];</p>
<p>[Copyright notice will appear here once 'preprint' option is removed.]and, of course, a plethora of tools aimed at assisting programmers in nearly every way [12,13,28].</p>
<p>Yet, simultaneous advances in hardware innovation have occurred with similar frequency, such as increasingly performant general purpose multi-core CPUs with advanced hardware extensions [22,41], low power system-on-chip (SoC) edge compute devices [17], high-performance pluggable coprocessors with near supercomputing performance of yesteryear [14], wide data-parallel graphics processing units (GPUs) [26], and application specific integrated circuits (ASICs) for deep neural networks and computer vision [4,37], to name a few.</p>
<p>While such hardware advances continue to broaden and deepen the space of what is computationally tractable, they have the fracturing side-effect of complicating and exacerbating the tension between the ease of developing software and the ability for humans to write maximally efficient code.In this paper we explore an alternative approach to traditional human-driven software development; one that autonomously creates software programs using genetic algorithms (GAs) requiring only minimal human guidance.</p>
<p>The Evolution of Programming Languages</p>
<p>Over the last several decades, programming languages (PLs) have followed a steady path of providing higher-level programming abstractions, aimed at reducing the challenge of human-driven software development [2].To this end, PLs, in general, have proliferated toward a design goal of simplifying human use.Although this trend is natural in an era where humans perform the majority of software development, as we will show, it is suboptimal in an environment where programming is performed predominantly by machines.</p>
<p>The ability for computers to automatically create their own software programs has been a long-standing goal of artificial intelligence [31].By largely removing humans from the time-intensive and error-prone process of software development and replacing them with artificial intelligence, computer software has the potential to be generated in a more streamlined, correct, and optimized fashion [8,20].</p>
<p>This paper makes the following technical contributions:</p>
<ol>
<li>
<p>We present AI Programmer the first-of-its-kind software generation framework, which constructs programs using genetic algorithms with novel enhancements coupled with a minimalistic programming language.</p>
</li>
<li>
<p>We present several critical observations, including an embedded interpreter and simulator solution, for security and optimization of ML-generated software.</p>
</li>
<li>
<p>We provide empirical results demonstrating the efficacy and efficiency of AI Programmer across several of its fully generated software programs on commodity hardware.</p>
</li>
</ol>
<p>Background</p>
<p>In this section we provide a brief synopsis of the challenges in using traditional programming languages for machinebased program generation.We also provide a brief introduction into genetic algorithms, the ML technique used by AI Programmer.</p>
<p>Programming Language Density</p>
<p>Most of today's programming languages were designed for human use [32].We refer to such languages as humanintended PLs (HIPLs).Although HIPLs are useful when humans perform the majority of programming and debugging, their design is usually counter to what is needed and appropriate for ML-based PLs (MLPLs).HIPLs often introduce unnecessary complexity and overhead for ML program generators due, in part, to the large number of language identifiers they include.The greater the number of legal language identifiers, the greater the ML computational search space.Moreover, type systems compound the challenge of creating legal programs because variable type bindings are intentionally restrictive to protect against human error, yet provide limited value for ML program generators [30].For these reasons, we chose to couple AI Programmer with a non-traditional programming language that is both constrained (i.e., using only eight identifiers) and typeless.We discuss this in more detail in Section 3.</p>
<p>Some instructions within any PL may be potentially harmful and, if used conjunction with an ML-based program generator, may cause irreversible damage.AI Programmer has specific measures in place to prevent the occurrence of such events.We discuss them in more detail in Section 3.4.</p>
<p>Programming with Genetic Algorithms</p>
<p>A genetic algorithm (GA) is a type of artificial intelligence, modeled after biological evolution, that begins with no knowledge of the subject, aside from an encoding of genes that represent a set of instructions or actions [9].In the concept of GA-driven computer programming, a series of programming instructions are selected at random to serve as an initial chain of DNA.The complete genome is executed as a program, with the resulting fitness score calcu-lated according to how well the program can solve a given task.This is performed with a sufficiently large population size.Those that have the best fitness are mated together to produce offspring.</p>
<p>Each generation of programs receive extra diversity from evolutionary techniques including roulette selection, crossover, and mutation [24].The process is repeated at each epoch with each child generation hopefully producing more favorable results than its parents' generation until a target solution is found.Through this process, applying GAs to computer programming automation enacts a survival of the fittest model for computer program generation [23].A deeper examination of these GA principles are provided in Section 3.</p>
<p>The Design of AI Programmer</p>
<p>In this section we provide a high-level overview of the AI Programmer software architecture.The AI Programmer's system design is shown in Figure 1.</p>
<p>Programming Language Selection and Challenges</p>
<p>We chose a typeless programming language that contains only eight instructions to drive AI Programmer's software generation [25].We briefly discuss the advantages of this approach and the modifications to the language that were required to integrate it into a GA solution.gene.Each gene within a program's genome corresponds to a single instruction from Table 1.AI Programmer binds a gene value range to each of its instructions across a continuous uniform distribution (or rectangular distribution) [3] (see Table 1), where each instruction's gene range is equal in size to each of the others.This was done so each instruction would have an equally random probability of being chosen at any location in a gene sequence when randomization was needed. 1implified Instruction Set.Each of AI Programmer's instructions manipulate a memory "tape" of byte values, ranging from 0-255.The language works by applying increment and decrement operations to the current memory cell, while shifting the memory cell up and down the tape, as instructed by the program.The values at the current memory pointer can be input from the user or output to the terminal.Primitive looping instructions also exist (e.g., '[' and ']'), offering a complete instruction set for creating software.An example program is shown in Figure 2.</p>
<p>The simplified instruction set reduces the search space in which a target program code can be found.As computational devices improve in speed, larger problem spaces can be searched.However, on less powerful devices, the search space needs to be constrained.As AI Programmer is intended for general purpose developers, limiting the programming instruction set to eight instructions enables the engine to execute in reasonable times on commodity hardware (see Section 5).</p>
<p>Genomes and Generations</p>
<p>To generate a software program using genetic algorithms, one must first create a genome.A genome is a set of genes that are grouped together as a single unit.For AI Programmer, the genome is encoded as an array of floating point values, with fixed value ranges per unique instruction ranging between 0 and 1, as shown in the Gene Range column of Table 1.</p>
<p>Once a genome is created, it is converted to a corresponding program, executed, and the resulting program is assigned a fitness score based on the program's output.The closer a generated program comes to solving the provided task, the greater its fitness score and, the more likely it is to continue to the next evolutionary generation.At each generation epoch, AI Programmer utilizes roulette selection, along with crossover and mutation, to create child programs that contain slight random perturbations, and potentially better, genomes than their parents for solving the target task.</p>
<p>Constructing a Genome Figure 3 demonstrates an example of constructing a genome from an array of floating point values.Each value range maps to a specific instruction in the programming language.Initially, these values are random (see the Random Gene Sequencer in Figure 1), resulting in generated programs that either won't function properly, throw errors, or simply fail2 .However, one or two are bound to run and execute, at a minimum, some number of valid instructions.The more successful a program is at executing, the more likely it is to continue on and produce offspring with code that achieves more successful results.Crossover and Mutation To create offspring, a parent genome contributes part of its genes to the child, a process called crossover, as shown in Figure 4.In addition to inheriting programming instructions from its parent, each child can also experience mutation, which is the process of adding controlled, but random perturbation, to specific genes.This results in modified behavior of the value of a particular gene, resulting in a change to the resulting programming instruction, and thus, the overall program.Crossover copies forward potentially beneficial parts of the parent, while mutation offers differing behaviors of instruction combinations, which may or may not, end up making the child programs more successful.</p>
<p>Survival of the Fittest Executable programs are ranked according to how well they have performed.As shown in Figure 5, a particular program that has failed is often imme-diately removed from the pool of genomes.However, programs that succeed are carried forward to produce child programs. 3igure 5. Programs are weighted by fitness, with the most successful used for child program generation.</p>
<p>The Fitness Test</p>
<p>To use GAs, a fitness test is needed to determine how well a generated solution performs.In the context of AI Programmer, this can involve scoring the byte-level output of the generated program, inspecting the generated program's internal state, or even analysis of intermediate state changes of the program throughout its execution.The score of the fitness test is calculated by analyzing these characteristics, and many others, and then comparing them against a userdefined target.</p>
<p>This concept is similar to test-driven development.When all unit tests pass, a program may be considered to be functionally correct.Likewise, a fitness test for a GA can be considered as a set of unit tests.In the case of AI Programmer, a fitness test typically contains a suite of tests for varying scenarios, which guide the genome selection, preserving only programs that evaluate well on the test suite.Further details about the construction of AI Programmer fitness tests are described in Section 4.</p>
<p>AI Programmer's Sandboxed Interpreter</p>
<p>Once a program has been generated, it must be executed so it can be evaluated against human created fitness tests.However, the execution of ML generated programs may include potential security risks as well as performance degradations.Because of this and the need for complex fitness tests (Section 3.3), we developed our own interpreter.This interpreter is sandboxed within the AI Programmer system to provide a secure, efficient, and GA-appropriate execution environment.We explain the challenges and benefits of this system in the following subsections.</p>
<p>Execution of Generated Programs in a Controlled Environment</p>
<p>As generated programs are executed to evaluate their fitness, the results can often be undesirable and potentially dangerous.Consider a program generated with I/O instructions, allowing for the modification of files on disk.A generated program could potentially overwrite critical system files, ren-dering the entire machine inoperable.Likewise, a program generated with instructions to support networking could inadvertently flood a computer network (e.g., denial of service attack [42]) or replicate itself across machines (e.g., worm [1]).Normally, these types of behaviors are malicious, yet ML software generators happen upon these situations in an attempt to satisfy fitness goals.By executing programs within our own secure interpreter, which includes instruction-level protection checks, AI Programmer can provide the additional security measures that are needed to prevent ML generated software from causing harmful behaviors.Non-ML generating interpreters and compilers do not generally include these types of checks because management of such issues are not usually within scope for HIPLs [39].</p>
<p>Termination of Infinite Loops</p>
<p>Automatically generated software has the potential to create infinite loops.This can occur from unsatisfied loop termination constraints or unexpected looping instructions.In our experiments, this type of behavior often arises in early program generations due to the GA maximizing the goal fitness score at the cost of program execution time.As a result, unterminated programs have the potential to halt the generation process, resulting in a failure of further program evaluations.</p>
<p>In an attempt to mitigate this, one can add fitness constraints to prefer programs with fewer instruction counts over larger ones.However, the generation of infinite loops, especially in early generations of programs, remains a possibility.AI Programmer's interpreter includes a customizable maximum instruction count per execution.Programs that exceed the instruction count are terminated.A fitness penalty can then be applied, reducing the likelihood of future generations of programs carrying forward the infinite loop constructs.With this addition, AI Programmer is guaranteed to terminate all infinite loops.</p>
<p>Simulation of Complex Instructions</p>
<p>Optimizing program execution is a principle concern for ML program generators.This is because such systems may generate and execute dozens to millions of programs before one with a high enough fitness score is found.While simple operations, such as add, load, store, jmp, may take a single clock cycle to complete, more complex operations can require many.Examples include disk I/O, networking, and peripheral device access.These types of operations can significantly increase program execution time, as they often rely on accessing services or devices with increased latency.</p>
<p>AI Programmer can simulate the execution of these complex instructions.In doing so, the GA-based programs it generates can execute more efficiently, while still retaining the ability to check the program's fitness goals.Moreover, such simulation protects the devices themselves from overuse by the plethora of programs that may attempt to access them during exploratory evolution of GA program generation.</p>
<p>Using AI Programmer</p>
<p>AI Programmer consists of a modular framework, designed in C# .NET.It includes an engine for running genetic algorithms, an encoder and decoder for genomes, a sandboxed interpreter for simulated program execution, and a compiler to transform code into binary executables.While the initial design of AI Programmer uses C#, it is important to note that the principles employed by it are not bound to C#. AI Programmer's software framework for fitness test construction is extensible and was developed so users can devise a myriad of customized fitness suites, which eventually guide the system's GA generation and evolution of software programs.</p>
<p>Specifying Requirements of a Program</p>
<p>To generate a program, AI Programmer must be provided with the requirements for the desired input and output of the target program.For example, if a program should prompt a user for a numerical input and then subsequently output a line of text, this must be specified in the form of training data to AI Programmer.The following subsections detail the step-by-step process of how a program is specified and generated with AI Programmer.</p>
<p>Creating Your First Program To begin, a user creates a C# class within the AI Programmer project, inheriting from the FitnessBase base class.This class includes all the necessary requirements for specifying a solution to be built by AI Programmer, including fitness scoring functionality, program termination rules, and program generation capabilities.</p>
<p>Specifying a Target Fitness Score Next, the user indicates a target fitness score which is specified in the constructor of the class as shown in Figure 6.The score is typically based upon characteristics of the desired program.For example, if the target program is intended to output a string, such as "Hello World", the fitness score might be the number of characters in the string (i.e., 11).However, since AI Programmer generates programming code at the byte level, the fitness score should account for incremental differences in output characters.In this case, one should multiply each target character in the output by 256, resulting in 2816 (e.g., 11 * 256) and use that as the resulting target fitness score.AI Programmer is designed to continue execution, generating incrementally better programs that satisfy the fitness conditions, until the current fitness score reaches its target.</p>
<p>Specifying Fitness Conditions Next, the user must specify the rules that are used to score each of the generated programs (i.e., the fitness test).At each generation epoch, AI Programmer will favor programs that have fitness scores that are closer to the target fitness score.Therefore, careful crafting of the fitness conditions are required so fitness scores accurately represent the desired goal of the program.</p>
<p>In the "Hello World" example, the user must specify that the output of the program should match the target string.To achieve this, one can add to the fitness score according to how close each character in the generated output string is to the target string.In particular, the fitness test can simply loop over the characters in the string "Hello World", and compare each one against the characters produced in the output of the generated program, adding or subtracting accordingly, as shown in Figure 7.After assigning a fitness score to each generated program within the current pool, a check is made to determine whether the target fitness score has been achieved by any of the generated programs.If so, AI Programmer halts and returns the solution program.Otherwise, it continues with the next generation of programs.</p>
<p>Specifying Conditions for Variable Output Previously, we presented an example on how to train AI Programmer to find an exact string.However, for more complex scenarios, such as variable outputs or calculated values, a series of training examples may be required.In such scenarios, training data can be created to serve as an initial set of examples to base the fitness score upon.Thereafter, AI Programmer can be guided with an evolutionary goal to generalize from the training data and provide correct results for new data.</p>
<p>As an example of variable output, consider the generation of a program to output the summation of two numbers.The target fitness score for this program would be the desired output, which, in this case, would be one byte, multiplied by the range of potential values (256).To construct the target fitness score, we can simply multiply the target fitness for a single result by the number of training examples.Therefore, in this case, the target fitness is trainingCount * 256.</p>
<p>After specifying the target fitness score, we can implement the actual fitness check for adding two numbers by looping over each training set combination (consisting of two numbers), inputting those values to our program, and checking the output for the correct sum.An example of this is shown in Figure 8.By   Programmatic Sequences of Action Because different programs require different sequences of actions (e.g., requesting input, outputting a result, etc.), AI Programmer provides users with a mechanism to specify the necessary programmatic sequence of actions within the fitness method.</p>
<p>Programmatic sequences can be provided in the form of a simple state machine within the fitness check method.When the generated program executes a command to request input from the user, a bonus score can be applied to the fitness if it is executed at the correct time in the sequence of actions.Likewise, when data is output, one can add or subtract from the fitness score according to the time the action is executed.</p>
<p>It is important for users to account for programmatic sequence bonuses when they are generating the initial target fitness.Doing so will ensure the generated solution will satisfy all required constraints, including sequences of events, before returning a viable solution program.</p>
<p>Results</p>
<p>Using AI Programmer, we were able to generate numerous complete software programs.A complete listing of these programs, their associated program generation time, and the total number of evolutionary generations used to build them are shown in Table 2.It is important to note that the number of evolutionary generations is not equivalent to the total computational time to generate a program.This is due, in large part, to varying genome size and fitness function computation, which is unique to each program.</p>
<p>Even though genetic algorithms are embarrassingly parallel and AI Programmer utilizes task-level parallelism for each generation's genome construction and fitness test evaluation, we limited our experimental study to commodity hardware only.All experiments were run on an Intel Quad-Core i7 CPU, 2.7GHz, containing 16GB ram with an x64-based processor utilizing up to 4-threads for the parallelism described above.We constrained our experiments in this manner to demonstrate the efficacy of AI Programmer for realworld autonomous software development.</p>
<p>For the remainder of this section, we highlight the details of some of the programs listed in Table 2 and discuss novel aspects that emerged when generating them.</p>
<p>Greetings</p>
<p>"Hello World" is usually one of the first programs human programmers create when they begin learning programming.As such, we found it fitting to guide AI Programmer to learn some basic greetings for its early programs.Rather than starting with "Hello World", we first had AI Programmer create a more simplistic program that simply output "hi."It was successfully after 5,700 generations and the generated code is shown in Figure 9.The generated program fulfilled its requirement to output the target text, but interestingly included subsequent random characters, which contained parsing errors, including nonmatching brackets.However, AI Programmer's interpreter computes results until the program fails.In this manner, the syntax error (which is later on in the code, after a solution is reached) does not negatively impact its fitness score, and thus offers a working solution.In fact, the generated code can be executed in almost any third-party interpreter as a valid working program (provided, warnings are ignored).
+[+++++-+&gt;++&gt;++-++++++&lt;&lt;]&gt;++.[+.]-.,-#&gt;&gt;]&lt;]
Next, we guided AI Programmer to generate the famous "hello world" output which was successfully constructed after 580,900 generations and consists of the code shown in Figure 10.</p>
<p>"I love all humans" As a humorous aside, we asked AI Programmer to create the program to output "I love all hu-
-&gt;&lt;[&gt;-&lt;+++]-&gt;&gt;++++[++++++++++++++++++&lt;+]&gt;.---. +-+++++++..+++.+&gt;+&lt;&gt;&lt;+[+&gt;&lt;&gt;&lt;&gt;+++++++++.+-&lt;-+++ +[++[.--------.+++.------],.-----]]
Figure 10.Generated program: "hello world" mans," which was successfully generated after 6,057,200 generations.It consists of the code shown in Figure 11.The fitness method for this example includes a check on the output string length to ensure an exact matching output, without extraneous text.</p>
<p>To ensure an exact output string, the fitness score includes not just a check on the output characters, but also a check on the length of the string.In this case, the target fitness included an additional 10 points, of which a percentage of this amount is added to the resulting fitness, depending on how close the length of the output string matches the length of the target.This forces the generation of a program that outputs the exact target string, without extraneous output instructions, as the generation process will not halt until the target fitness is reached, of which, 10 points comprise having the correct output length.Figure 12.A percentage of 10 points is added to the fitness, according to how exact the length of the output is to the target.
+[&gt;+&lt;+++]+&gt;------------.+&lt;+++++++++++++++++++ ++++++++++++.&gt;+++++++++++++++++++++++++++++++ +++.+++.+++++++.-----------------.--&lt;.&gt;--.+++ ++++++++..---&lt;.&gt;-.+++++++++++++.--------.---- --------.+++++++++++++.+++++.</p>
<p>Input-Output Computations</p>
<p>We next guided AI Programmer to generate programs that perform computations based on user input.In such programs, the user provides some input and the computer program then generates the appropriate output.</p>
<p>Reversing a String AI Programmer was able to generate the program to reverse any string after only 2,600 generations.The generated code is shown in Figure 13.When executed, the program prompts the user for input.The user then types one character at a time until a value of "0" is entered.A novelty of this program is that it is required to take variable size input first before performing the majority of its program logic.However, the program's internal memory state must manage the variable input, as the program must read all input first to locate the final character entered, which is the first character in the reversed string.The genetic algorithm was able to produce this logic automatically, based upon the fitness method.</p>
<p>Addition and Subtraction AI Programmer was able to generate programs for addition after 92,400 generations (Figure 14) and subtraction after 177,900 generations (Figure 15).</p>
<p>,&gt;,-[-&lt;+&gt;]&lt;+.If-Then Conditionals with User Input Generating programs involving more complex programming logic, such as the ability to perform if-then decisions and actions, requires a more advanced type of fitness function.However, as described in Section 3.4, AI Programmer's embedded interpreter provides significantly more access to program state than just its output, which is essential for generating a large variety of more complex programs.For example, AI Programmer was able to produce a program which prompts the user for input (e.g., 1, 2 or 3) and outputs text based on which value was entered, similar to selecting an option from a menu.By entering the value "1", the program would output "hi".Entering "2", resulted in the program output of "z".Entering "3", resulted in the output "bye".The program was generated in 446,200 generations.</p>
<p>The produced code was notably larger than previously generated programs, containing 650 instructions (although not all instructions are needed).The larger code was required, as the conditional branches are contained within individual blocks of the code.</p>
<p>Complexity in Fitness Functions</p>
<p>As the complexity of the target program grows, so too does the fitness function.After all, the fitness function needs to guide the engine in determining how well a particular child program matches the targeted solution.For conditionals and branching, successful program generation required more advanced techniques within the fitness function.</p>
<p>In particular, a check was needed to examine the interpreter's memory register (i.e., current data pointer via shift operations), where the distinct number of memory registers being used by the program was counted, providing a bonus to fitness to favor more memory register usage over less.This aided in inspiring diversity amongst child programs.Additionally, the instruction pointer used for each print command was recorded and weighed against the fitness score.A penalty was applied for reuse of the same print command.This helped to foster diversity and achieve a successful ifthen result.</p>
<p>Optimizing Program Generation</p>
<p>We noticed that the program generation time increased significantly as the length of the target output increased.Furthermore, the need to extend AI Programmer beyond the basic instruction set was deemed a necessity if we were to have it produce programs with more interesting features, such as file I/O and networking capabilities.</p>
<p>As such, we extended AI Programmer to use an extended programming instruction set, which reduced code generation time and improved code compression due to an increased range of instruction specificity (i.e., fewer instructions to achieve the same result).However, a disadvantage of utilizing the extended instruction set is that the generated programs would be difficult to test in standard interpreters.As the extended instruction set for AI Programmer deviated from the traditional programming language, standard interpreters would no longer be able to run the produced code.In our case, AI Programmer's internally developed interpreter was modified to support the extended instruction set, so this was not a practical obstacle.</p>
<p>Extended Instruction Set</p>
<p>Several extensions of the programming language used by AI Programmer exist, which are suitable to decrease program generation time.Specifically, the speed-enhancing extension set, Extended Type III [10], offers several programming instructions that aid generation.These instructions include the ability to immediately set the value of a particular cell to a multiple of 16, also called "fast cell initializers".This aids in allowing a generated program to quickly reach displayable ASCII range characters for output, thus, decreasing the number of individual increment programming instructions that would normally be required.</p>
<p>In addition to key instructions taken from Extended Type III, we added several new instructions to support calling functions from within a program, allowing for increasingly complex programs to be generated.Fibonacci sequence up to 233 4 , which was was generated in approximately six hours.The program prompts the user for input of the two starting values in the sequence.It then outputs the next digits in the Fibonacci sequence.The generated code for this, using the extended instruction set, is shown in Figure 16.</p>
<p>Advancing Complexity</p>
<p>The ability of the GA to generate a program for solving the Fibonacci sequence was a profound advancement.The solution program contains several distinct programming tasks, including prompting the user for input of two numbers at the beginning of execution, calculating the addition of values, determining the correct mathematical sequence, outputting the result, and looping to repeat the process for each value in the sequence.</p>
<p>This combination of tasks, spreading across a range of programming abilities, might typically be given to human programmers in order to evaluate their programming proficiency.The capability of the GA to automatically generate this type of program demonstrates the potential for future expansion of the system.</p>
<p>Related Work</p>
<p>Genetic programming has previously been applied in some restricted cases.A key limitation in their broader application has been in the computational density of the search space involved in program generation, which exponentially increases as programs grow in complexity [18].AI Programmer provides to novel mitigation of this inefficiency by using a minimalistic programming language, exploiting the natural parallelism of GAs, simulating complex instructions, and embedding an optimized interpreter for fast execution and fast-failure of defunct programs.</p>
<p>Genetic Algorithms in Other Domains</p>
<p>Somewhat related to our work, is the use of program synthesis driven by genetic programming in hardware-based niche fields.Koza et al. used an automated process for creating analog circuits, involving genetically evolved designs with evolutionary computation to produce circuit components that typically require human-level intelligence to construct [19].In addition, they used human constructed fitness methods to guide their circuit design.Although applied in different domains, the high-level machine learning approach of Koza et al.'s system is similar to AI Programmer.</p>
<p>One of the key components of our research is the usage of a minimalistic programming language to limit the com-putational complexity of generated programs.This approach been found useful in other areas of genetic programming, including the simulation of artificial life, as described in Ling's work [21].In a simulation library based on genetic algorithms and biological hierarchy, the system, called Ragaraja, uses biological concepts to form an esoteric programming language, consisting of a set of 3-character instructions.In this manner, the system is able to simplify the genetic algorithm generation and mutation process by limiting the number of possible instruction combinations.Although applied in a completely different domain, the affects of this approach are similar to AI Programmer, specifically for optimizing the generation time and limiting the complexity of generated solutions to a constrained set of instructions.</p>
<p>Different Approaches in Program Generation</p>
<p>AI Programmer has similarities to a program synthesis technique called sketching in that each approach attempts to automatically generate software by using some human guidance.However, the similarities between the two approaches ends there.On one hand, sketching is a program synthesis technique where a programmer provides only a minimalistic outline of an implementation and the compiler generates the remaining code [35,36].On the other hand, AI Programmerrequires no partial implementation, but instead requires human developers to design fitness tests which guide the evolutionary algorithm for the entire program construction.</p>
<p>Another slightly related work is verified lifting [16].Verified lifting aims to lift algorithms written in one language and place a formally verified equivalent in another language.The benefits of verified lifting are highly practical, especially when considering the need for such systems as real software systems often migrate from one programming language to another.However, verified lifting and AI Programmer are only loosely similar in that both systems perform automatic code generation, but do not possess any other similarities in their approaches.</p>
<p>Slow Acceptance of Genetic Algorithms</p>
<p>The potential capabilities of automated program generation using machine learning techniques have been considered for some time.Yet, these approaches have encountered obstacles inhibiting their practical application.Part of those obstacles were a lack of computational power and data movement throughout.Advances in these fields have had recent breakthroughs leading to the democratization of machine learning, especially in the area of deep learning, which requires complex neural networks and a large amount of training data [11].</p>
<p>Still, other challenges remain in automated programming, as explained by O'Neil et al. [27], which describes the slow growth of genetic programming, despite the successes that it has achieved in various real-world domains.To the best of our knowledge, AI Programmer is the first end-to-end GA system to demonstrate rapid progress in non-trivial program generation achieved entirely on commodity hardware.</p>
<p>Conclusion and Future Work</p>
<p>Traditional human-based computer programming is approaching a dramatic shift.With increasingly complex software and hardware advances and the growing challenges integrating the two, the craft of software development will inevitably surpass the capabilities of humans.As that time approaches, it will be necessary to have some form of automatic software generation to assist humans in software development beyond what exists today (e.g., compilers, higherlevel programming languages, etc.).</p>
<p>The results presented in this paper, provide early notions about the power that machine learning techniques, specifically genetic algorithms, may offer a partial solution for automatic program generation.We showed that fully functional programs can indeed be automatically generated, provided they are supplied with some human guidance in the way of input parameters and training data.While the initial set of programs generated by AI Programmer are similar in complexity to that a novice human programmer, the range of generated programs need not restricted to traditional means such as human time or human intellect.Instead, they are simply a function of fitness test complexity and computational resources.</p>
<p>In addition to correctness, efficient implementation of fitness methods are imperative to the practical application of AI Programmer.This is because each generated program is checked against the fitness method every time a new program is evaluated.An important open area of future work is the deep examination of how to implement fitness methods as efficiently as possible while still retaining a high degree of correctness.One possible solution is to build superoptimizers specifically for fitness test optimizations [29].</p>
<p>Another important open area in ML-based program generation is the need for specifically crafted programming languages that have strong alignment with the constraints of ML computation.The current programming languages we use today, for humans, are ill-suited for ML-based program generation.The approach we use for typical program language creation needs to be abandoned and rethought when considering a future of ML-driven program generation.Only once this is done, can we begin to envision a new future of computer software development, driven by artificial intelligence based systems, with human creativity and design guiding the way.</p>
<p>Figure 1 .
1
Figure 1.The AI Programmer Software Architecture.</p>
<p>Figure 2 .
2
Figure 2. A generated program that outputs "hello".</p>
<p>Figure 3 .
3
Figure 3. Decoding a genome as a program.</p>
<p>Figure 4 .
4
Figure 4.An example of crossover and mutation.The child genome inherits the first 5 instructions from its parent.One instruction is mutated.</p>
<p>publicFigure 6 .
6
Figure 6.Example target fitness score for "Hello World."</p>
<p>Figure 7 .
7
Figure 7. Adding and subtracting the fitness score based upon program output.</p>
<p>Figure 8 .
8
Figure 8. Calculating the fitness of adding two numbers.</p>
<p>Figure 9 .
9
Figure 9. Generated program: "hi"</p>
<p>Figure 11 .
11
Figure 11.Generated program: "I love all humans"</p>
<p>+Figure 13 .
13
Figure 13.Generated program for reversing a string.</p>
<p>Figure 14 .
14
Figure 14.Generated program for performing addition.</p>
<p>Figure 15 .
15
Figure 15.Generated program for performing subtraction.</p>
<p>FibonacciFigure 16 .
16
Figure 16.Generated program to output the Fibonacci sequence from two starting input values.</p>
<p>Table 1 .
1
AI Programmer Instruction Set and Gene Map
Instr Gene Range Operation&gt;(0, 0.125]Increment the pointer&lt;(0.125, 0.25] Decrement the pointer+(0.25, 0.375] Increment the byte at the pointer-(0.375, 0.5]Decrement the byte at the pointer.(0.5, 0.625]Output the byte at the pointer,(0.625, 0.75] Input a byte and store it at the ptr[(0.75, 0.875] Jump to matching ] if current 0](0.875, 1.0]Jump back to matching [ unless 0Turing Completeness. AI Programmer's programminglanguage, listed in Table 1, is Turing complete. A Turingcomplete programming language is theoretically capable ofcompleting any (single taped Turing machine) programmingtask given an unlimited amount of time and memory [40].In essence, a programming language with this characteristicis capable of implementations of a vast number of program-ming problems. Likewise, programs generated with AI Pro-grammer, are theoretically capable of expressing all tasksthat one might want to accomplished with computers.GA Engine and Uniform Gene Distributions. AI Pro-grammer's genetic algorithm engine represents each gen-erated program's instructions as an array of floating pointvalues, which, when considered as a unit, is its genome.Each individual location within a given genome is called a</p>
<p>providing varying training input values we can help foster the generalization of the solution program, rather than the generation of a program that only solves the exact training examples provided.
int val;if (Int32.TryParse(_console.ToString(), out val)) {Fit += 256 -Math.Abs(val -(input1 + input2));}</p>
<p>Table 2 .
2
AI Programmer Results
NameDuration (s) Generationshi525,700Hi!7,6441,219,400hello1,713252,000hello world7,702580,900reddit1,362195,000Keep Calm Keep Coding94421,400I love all humans36,0006,057,200hello {user}1,79342,800Addition2,69892,400Subtraction4,305177,900Multiply x26,353242,000Multiply x35,16587,200XOR2,095146,400Fibonacci21,862151,900If/then conditionals8,31346,200cats are evil10,209814,400Bottles of Beer on the Wall 2,95761,400Reverse string492,600CSV parse1739,000Extract in quotes6,478212,100Extract in quotes 29,996188,400Trim left of quote9,030341,700XML to JSON6,866820,900Warning countdown48900
2017/9/19
We did not examine the impact of weighted ranges for different programs, but note that it may be of interest as future work.
2017/9/19
Most initial programs in the gene pool fail immediately upon being executed. Others may result in endless loops. It is due to these reasons that exception handling and maximum iteration limits are imposed on the interpreter.
In Figure5, the bottom program is a valid running program that takes one byte for input, increments it, and then displays it twice as output.
2017/9/19
2017/9/19
2017/9/19
2017/9/19
2017/9/19
255 is the max value for a byte, with the next Fibonacci sequence value being 377.
2017/9/19
2017/9/19
2017/9/19</p>
<p>. Computer. </p>
<p>The 2017 top programming languages. </p>
<p>Uniform distribution. </p>
<p>Tensorflow: A system for large-scale machine learning. M Abadi, P Barham, J Chen, Z Chen, A Davis, J Dean, M Devin, S Ghemawat, G Irving, M Isard, M Kudlur, J Levenberg, R Monga, S Moore, D G Murray, B Steiner, P A Tucker, V Vasudevan, P Warden, M Wicke, Y Yu, X Zhang, CoRR, abs/1605.086952016</p>
<p>On understanding types, data abstraction, and polymorphism. L Cardelli, P Wegner, 10.1145/6041.6042ACM Comput. Surv. 0360-0300174Dec. 1985</p>
<p>T H Cormen, C Stein, R L Rivest, C E Leiserson, Introduction to Algorithms. McGraw-Hill Higher Education. 20012nd edition</p>
<p>On-the-fly garbage collection: An exercise in cooperation. E W Dijkstra, L Lamport, A J Martin, C S Scholten, E F M Steffens, 10.1145/359642.359655Commun. ACM. 0001-07822111Nov. 1978</p>
<p>Benchmarking optimization software with performance profiles. E D Dolan, J J Moré, Mathematical programming. 9122002</p>
<p>The Master Algorithm: How the Quest for the Ultimate Learning Machine Will Remake Our World. P Domingos, 2015</p>
<p>Extended type iii. Esolangs, Org, </p>
<p>Deep Learning. I Goodfellow, Y Bengio, A Courville, 2016Book in preparation for MIT Press</p>
<p>Visualizing transactional memory. J E Gottschlich, M P Herlihy, G A Pokam, J G Siek, 10.1145/2370816.2370842Proceedings of the 21st International Conference on Parallel Architectures and Compilation Techniques, PACT '12. the 21st International Conference on Parallel Architectures and Compilation Techniques, PACT '12New York, NY, USAACM2012</p>
<p>Gprof: A call graph execution profiler. SIGPLAN Not. S L Graham, P B Kessler, M K Mckusick, 10.1145/872726.806987June 198217</p>
<p>Intel Xeon Phi Coprocessor High Performance Programming. J Jeffers, J Reinders, Morgan Kaufmann Publishers Inc9780124104945San Francisco, CA, USA1st edition, 2013. ISBN 9780124104143</p>
<p>Garbage Collection: Algorithms for Automatic Dynamic Memory Management. R Jones, R Lins, 1996John Wiley &amp; Sons, IncNew York, NY, USA</p>
<p>Verified lifting of stencil computations. S Kamil, A Cheung, S Itzhaky, A Solar-Lezama, 10.1145/2908080.2908117Proceedings of the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI '16. the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI '16New York, NY, USA2016</p>
<p>Low Power Methodology Manual: For System-on-Chip Design. M Keating, D Flynn, R Aitken, A Gibbons, K Shi, Springer Publishing Company9780387718187Incorporated, 2007. ISBN 0387718184</p>
<p>Human-competitive results produced by genetic programming. J R Koza, Genetic Programming and Evolvable Machines. 113-42010</p>
<p>Automated synthesis of analog electrical circuits by means of genetic programming. J R Koza, F H Bennett, D Andre, M A Keane, F Dunlap, IEEE Transactions on evolutionary computation. 121997</p>
<p>Proving the correctness of multiprocess programs. L Lamport, IEEE transactions on software engineering. 21977</p>
<p>An artificial life simulation library based on genetic algorithm, 3-character genetic code and biological hierarchy. The Python Papers. M H Ling, 20127</p>
<p>Intel&reg; software guard extensions (intel&reg; sgx) support for dynamic memory management inside an enclave. F Mckeen, I Alexandrovich, I Anati, D Caspi, S Johnson, R Leslie-Hurd, C Rozas, 10.1145/2948618.2954331Proceedings of the Hardware and Architectural Support for Security and Privacy. the Hardware and Architectural Support for Security and PrivacyNew York, NY, USAACM2016. 20162016</p>
<p>Genetic Algorithms Plus Data Structures Equals Evolution Programs. Z Michalewicz, 1994Springer-VerlagNew York, Inc., Secaucus, NJ, USA2nd edition. ISBN 0387580905</p>
<p>An Introduction to Genetic Algorithms. M Mitchell, 1998. ISBN 0262631857MIT PressCambridge, MA, USA</p>
<p>Esoteric programming. U Müller, </p>
<p>Gpu Gems 3. H Nguyen, 2007Addison-Wesley Professionalfirst edition. ISBN 9780321545428</p>
<p>Open issues in genetic programming. M O'neill, L Vanneschi, S Gustafson, W Banzhaf, Genetic Programming and Evolvable Machines. 113-42010</p>
<p>Pinplay: A framework for deterministic replay and reproducible analysis of parallel programs. H Patil, C Pereira, M Stallcup, G Lueck, J Cownie, 10.1145/1772954.1772958Proceedings of the 8th Annual IEEE/ACM International Symposium on Code Generation and Optimization, CGO '10. the 8th Annual IEEE/ACM International Symposium on Code Generation and Optimization, CGO '10New York, NY, USAACM2010</p>
<p>Scaling up superoptimization. SIGPLAN Not. P M Phothilimthana, A Thakur, R Bodik, D Dhurjati, 10.1145/2954679.2872387Mar. 201651</p>
<p>Types and Programming Languages. B C Pierce, 2002The MIT Press97802621620981st edition</p>
<p>S J Russell, P Norvig, Artificial Intelligence: A Modern Approach. Pearson Education. 200301379039522 edition</p>
<p>Programming Language Pragmatics. M L Scott, 2000Morgan Kaufmann Publishers IncSan Francisco, CA, USA</p>
<p>Programming Language Pragmatics, Third Edition. M L Scott, Morgan Kaufmann Publishers Inc9780123745149San Francisco, CA, USA3rd edition, 2009. ISBN 0123745144</p>
<p>Gradual typing for functional languages. J G Siek, W Taha, IN SCHEME AND FUNCTIONAL PROGRAM-MING WORKSHOP. 2006</p>
<p>Programming by sketching for bit-streaming programs. SIG-PLAN Not. A Solar-Lezama, R Rabbah, R Bodík, K Ebcioglu, 10.1145/1064978.1065045June 200540</p>
<p>Combinatorial sketching for finite programs. A Solar-Lezama, L Tancau, R Bodik, S Seshia, V Saraswat, 10.1145/1168917.1168907SIGOPS Oper. Syst. Rev. 0163-5980405Oct. 2006</p>
<p>A computer vision system on a chip: a case study from the automotive domain. G P Stein, G Hayun, E Rushinek, A Shashua, IEEE Computer Society Conference on Computer Vision and Pattern Recognition Workshops. 2012. 2005</p>
<p>Delite: A compiler architecture for performance-oriented embedded domain-specific languages. A K Sujeeth, K J Brown, H Lee, T Rompf, H Chafi, M Odersky, K Olukotun, 10.1145/2584665ACM Trans. Embed. Comput. Syst. 1539-9087134sApr. 2014</p>
<p>Engineering A Compiler. L Torczon, K Cooper, 2011Morgan Kaufmann Publishers Inc012088478San Francisco, CA, USA2nd edition</p>
<p>Turing completeness. A Turing, </p>
<p>Performance evaluation of intel&reg; transactional synchronization extensions for high-performance computing. R M Yoo, C J Hughes, K Lai, R Rajwar, 10.1145/2503210.2503232Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC '13. the International Conference on High Performance Computing, Networking, Storage and Analysis, SC '13New York, NY, USAACM201319</p>
<p>A survey of defense mechanisms against distributed denial of service (ddos) flooding attacks. S T Zargar, J Joshi, D Tipper, IEEE Communications Surveys and Tutorials. 1542013</p>            </div>
        </div>

    </div>
</body>
</html>