<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-554 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-554</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-554</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-16.html">extraction-schema-16</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of experimental methods, techniques, or procedures being transferred, adapted, or applied from one scientific domain or context to another scientific domain or context, including details about the transfer process and outcomes.</div>
                <p><strong>Paper ID:</strong> paper-498bb0efad6ec15dd09d941fb309aa18d6df9f5f</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/498bb0efad6ec15dd09d941fb309aa18d6df9f5f" target="_blank">Open Information Extraction from the Web</a></p>
                <p><strong>Paper Venue:</strong> CACM</p>
                <p><strong>Paper TL;DR:</strong> Open IE (OIE), a new extraction paradigm where the system makes a single data-driven pass over its corpus and extracts a large set of relational tuples without requiring any human input, is introduced.</p>
                <p><strong>Paper Abstract:</strong> Traditionally, Information Extraction (IE) has focused on satisfying precise, narrow, pre-specified requests from small homogeneous corpora (e.g., extract the location and time of seminars from a set of announcements). Shifting to a new domain requires the user to name the target relations and to manually create new extraction rules or hand-tag new training examples. This manual labor scales linearly with the number of target relations. This paper introduces Open IE (OIE), a new extraction paradigm where the system makes a single data-driven pass over its corpus and extracts a large set of relational tuples without requiring any human input. The paper also introduces TEXTRUNNER, a fully implemented, highly scalable OIE system where the tuples are assigned a probability and indexed to support efficient extraction and exploration via user queries. We report on experiments over a 9,000,000 Web page corpus that compare TEXTRUNNER with KNOWITALL, a state-of-the-art Web IE system. TEXTRUNNER achieves an error reduction of 33% on a comparable set of extractions. Furthermore, in the amount of time it takes KNOWITALL to perform extraction for a handful of pre-specified relations, TEXTRUNNER extracts a far broader set of facts reflecting orders of magnitude more relations, discovered on the fly. We report statistics on TEXTRUNNER’s 11,000,000 highest probability tuples, and show that they contain over 1,000,000 concrete facts and over 6,500,000more abstract assertions.</p>
                <p><strong>Cost:</strong> 0.014</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e554.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e554.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of experimental methods, techniques, or procedures being transferred, adapted, or applied from one scientific domain or context to another scientific domain or context, including details about the transfer process and outcomes.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Self-Supervised Learner</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Self-Supervised Learner for Open Information Extraction (TextRunner)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A procedure that automatically labels its own training data by using a dependency parser to identify trustworthy and untrustworthy relation tuples, then trains a parser-independent Naive Bayes classifier on domain-independent features for large-scale, parser-free extraction.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>procedure_name</strong></td>
                            <td>Self-supervised training via parser-labeled examples</td>
                        </tr>
                        <tr>
                            <td><strong>procedure_description</strong></td>
                            <td>The system parses a small sample of sentences with a dependency parser to produce dependency graphs; it identifies base noun phrases and traverses parse paths between noun-phrase pairs to propose candidate relation tuples. Heuristic syntactic constraints mark tuples as positive (trustworthy) or negative. Each tuple is converted into a feature vector of parser-independent features (POS-tag sequences, token counts, stopword counts, surrounding POS tags, proper-noun flags, etc.). A Naive Bayes classifier is trained on these automatically labeled examples. The trained classifier is then applied corpus-wide during a single-pass extraction that uses only lightweight POS and chunking (no parser).</td>
                        </tr>
                        <tr>
                            <td><strong>procedure_type</strong></td>
                            <td>computational method / machine learning training protocol</td>
                        </tr>
                        <tr>
                            <td><strong>source_domain</strong></td>
                            <td>Deep syntactic parsing / computational linguistics (dependency parsing on curated corpora like newswire / Penn Treebank)</td>
                        </tr>
                        <tr>
                            <td><strong>target_domain</strong></td>
                            <td>Web-scale Information Extraction / Open IE (heterogeneous web text)</td>
                        </tr>
                        <tr>
                            <td><strong>transfer_type</strong></td>
                            <td>adapted/modified for new context</td>
                        </tr>
                        <tr>
                            <td><strong>modifications_made</strong></td>
                            <td>Parser use was limited to a small, pre-processing sample (not the full corpus) to avoid scale issues and parser brittleness on web text; syntactic constraints were relaxed to be tolerant of local parse errors; the parser-derived labels were converted to feature vectors containing only parser-independent features so the final extractor would not require the parser; a noise-tolerant learning algorithm (Naive Bayes) was used to recover from noisy auto-labels.</td>
                        </tr>
                        <tr>
                            <td><strong>transfer_success</strong></td>
                            <td>successful - produced a classifier that substantially outperformed an expert hand-built relation-independent classifier (authors report the hand-built baseline achieved roughly one third the accuracy of the Learner). Enabled extraction at scale without running a parser across the whole corpus.</td>
                        </tr>
                        <tr>
                            <td><strong>barriers_encountered</strong></td>
                            <td>Dependency parsers make many more errors on heterogeneous Web text than on newswire; parser-based labels are noisy; difficulty anticipating relation forms across diverse text; noun phrase boundary and argument truncation errors remain a significant source of error.</td>
                        </tr>
                        <tr>
                            <td><strong>facilitating_factors</strong></td>
                            <td>Availability of an accurate parser for smaller, cleaner corpora to bootstrap labels; redundancy and diversity of web text allowing enough training examples; use of domain-independent features and noise-tolerant learner; restricting parser use to a sampled training set reduced scale and brittleness issues.</td>
                        </tr>
                        <tr>
                            <td><strong>contextual_requirements</strong></td>
                            <td>A dependency parser and parsed sample of sentences; implementation of syntactic heuristics to auto-label tuples; feature extraction pipeline to map tuples to parser-independent features; compute for training classifier (small scale compared to full parsing).</td>
                        </tr>
                        <tr>
                            <td><strong>generalizability</strong></td>
                            <td>Moderately high — authors state the classifier is language-specific (needs language-specific POS/chunker and parser for the bootstrapping step) but contains no relation-specific lexical features, so the approach can be applied to other domains and languages where a parser and POS tools exist and a small parsed sample can be obtained.</td>
                        </tr>
                        <tr>
                            <td><strong>knowledge_type</strong></td>
                            <td>explicit procedural steps and technical skills (how to auto-label with a parser and train a parser-independent classifier); some tacit know-how in designing syntactic heuristics.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Open Information Extraction from the Web', 'publication_date_yy_mm': '2007-01'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e554.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e554.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of experimental methods, techniques, or procedures being transferred, adapted, or applied from one scientific domain or context to another scientific domain or context, including details about the transfer process and outcomes.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Dependency parser bootstrap</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Use of an off-the-shelf dependency parser (Klein & Manning 2003) for bootstrapping training labels</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Application of a dependency parser originally developed for curated corpora to automatically produce labeled training instances for an Open IE learner operating on noisy web text; parser outputs are used only in a limited training stage.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Accurate unlexicalized parsing</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>procedure_name</strong></td>
                            <td>Dependency parsing for auto-labeling training data</td>
                        </tr>
                        <tr>
                            <td><strong>procedure_description</strong></td>
                            <td>A dependency parser is run on several thousand sampled sentences to obtain dependency graphs. Base noun phrases are extracted; for each noun-phrase pair, the parse path connecting them is traversed to propose candidate relation strings. Heuristic syntactic constraints (path length limits, non-crossing sentence boundaries, excluding pronoun-only arguments) label tuples as positive or negative, producing training data for a Naive Bayes classifier that will be used for parser-free extraction across the full corpus.</td>
                        </tr>
                        <tr>
                            <td><strong>procedure_type</strong></td>
                            <td>computational method / data annotation/bootstrap technique</td>
                        </tr>
                        <tr>
                            <td><strong>source_domain</strong></td>
                            <td>Syntactic dependency parsing developed and validated on curated corpora (computational linguistics / parsing research)</td>
                        </tr>
                        <tr>
                            <td><strong>target_domain</strong></td>
                            <td>Large-scale, heterogeneous web information extraction</td>
                        </tr>
                        <tr>
                            <td><strong>transfer_type</strong></td>
                            <td>adapted/modified for new context</td>
                        </tr>
                        <tr>
                            <td><strong>modifications_made</strong></td>
                            <td>Parser usage confined to a small training sample rather than full-corpus; labeling heuristics were designed to be tolerant to local parse errors typical of web text; parser-derived information was transformed into parser-independent features so the production extractor does not require parsing.</td>
                        </tr>
                        <tr>
                            <td><strong>transfer_success</strong></td>
                            <td>partially successful - succeeded in producing training labels that enabled a high-performing, parser-free extractor; however parser errors remained a source of noisy labels, mitigated by noise-tolerant learning.</td>
                        </tr>
                        <tr>
                            <td><strong>barriers_encountered</strong></td>
                            <td>High parser error rates on heterogeneous web text compared to newswire; diversity of entity types and surface forms on the Web reduced parser reliability.</td>
                        </tr>
                        <tr>
                            <td><strong>facilitating_factors</strong></td>
                            <td>Using the parser only on a small sample reduced the impact of parser brittleness; careful syntactic heuristics and noise-tolerant learner compensated for labeling noise.</td>
                        </tr>
                        <tr>
                            <td><strong>contextual_requirements</strong></td>
                            <td>Access to a robust dependency parser and a representative small sample of sentences; implementation of syntactic constraints for labeling; compute to parse sample.</td>
                        </tr>
                        <tr>
                            <td><strong>generalizability</strong></td>
                            <td>Good for contexts where a parser exists for the target language and a small representative sample can be parsed; less applicable where no parser is available or where web text is extremely divergent from parser training genres.</td>
                        </tr>
                        <tr>
                            <td><strong>knowledge_type</strong></td>
                            <td>explicit procedural steps and instrumental/technical skills (running a parser, extracting parse-path features, defining syntactic heuristics).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Open Information Extraction from the Web', 'publication_date_yy_mm': '2007-01'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e554.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e554.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of experimental methods, techniques, or procedures being transferred, adapted, or applied from one scientific domain or context to another scientific domain or context, including details about the transfer process and outcomes.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Redundancy-based Assessor</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Probabilistic Redundancy-Based Assessor (Downey et al., 2005 model applied to TextRunner)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A probabilistic model that uses redundancy (number of distinct supporting sentences) to estimate the probability that an extracted tuple is correct; previously applied in KnowItAll and reused here to score Open IE tuples.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>A Probabilistic Model of Redundancy in Information Extraction</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>procedure_name</strong></td>
                            <td>Redundancy-based probabilistic assessment of extractions</td>
                        </tr>
                        <tr>
                            <td><strong>procedure_description</strong></td>
                            <td>After extraction and normalization (omitting non-essential modifiers, merging identical normalized relations), tuples are aggregated and the number of distinct supporting sentences for each tuple is counted. The redundancy model computes the posterior probability that a tuple is correct given it was extracted from k distinct sentences. These probabilities are used to filter/score extractions (e.g., retaining tuples with probability ≥ 0.8).</td>
                        </tr>
                        <tr>
                            <td><strong>procedure_type</strong></td>
                            <td>computational method / probabilistic scoring / data analysis technique</td>
                        </tr>
                        <tr>
                            <td><strong>source_domain</strong></td>
                            <td>Unsupervised web information extraction (KnowItAll system / IE probabilistic modeling)</td>
                        </tr>
                        <tr>
                            <td><strong>target_domain</strong></td>
                            <td>Open Information Extraction (TextRunner) / large-scale tuple ranking and filtering</td>
                        </tr>
                        <tr>
                            <td><strong>transfer_type</strong></td>
                            <td>direct application without major modification</td>
                        </tr>
                        <tr>
                            <td><strong>modifications_made</strong></td>
                            <td>Applied the existing redundancy model to normalized Open IE tuples after relation normalization and merging; counts are based on distinct sentences for normalized relations rather than relation-specific, hand-specified patterns. No fundamental change to the probabilistic model is described, but integration required tuple normalization and merging steps specific to Open IE.</td>
                        </tr>
                        <tr>
                            <td><strong>transfer_success</strong></td>
                            <td>successful - model produced robust probability estimates used to filter 11.3M high-probability tuples (prob ≥ 0.8); human evaluation on filtered set showed 80.4% correctness overall, supporting effectiveness of redundancy scoring.</td>
                        </tr>
                        <tr>
                            <td><strong>barriers_encountered</strong></td>
                            <td>Need to normalize relations and merge equivalent relation strings before counting support; some relations are overly general and require exclusion (top 0.1% by support).</td>
                        </tr>
                        <tr>
                            <td><strong>facilitating_factors</strong></td>
                            <td>High redundancy in Web text (multiple independent mentions of same fact) supports probabilistic estimation; prior demonstration of model efficacy in KnowItAll provided validation.</td>
                        </tr>
                        <tr>
                            <td><strong>contextual_requirements</strong></td>
                            <td>Large corpus with many redundant mentions of facts; ability to normalize relation strings and count distinct sentence-level supports; compute to aggregate and score tuples.</td>
                        </tr>
                        <tr>
                            <td><strong>generalizability</strong></td>
                            <td>High for other large, redundant corpora (Web-scale or news archives); less effective for sparse corpora that lack redundancy.</td>
                        </tr>
                        <tr>
                            <td><strong>knowledge_type</strong></td>
                            <td>theoretical principles and explicit procedural steps (probabilistic modeling of redundancy and its operationalization for scoring extractions).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Open Information Extraction from the Web', 'publication_date_yy_mm': '2007-01'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e554.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e554.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of experimental methods, techniques, or procedures being transferred, adapted, or applied from one scientific domain or context to another scientific domain or context, including details about the transfer process and outcomes.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Lightweight POS/NP Chunking (OpenNLP)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Maximum-entropy part-of-speech tagging and noun-phrase chunking (as implemented in OpenNLP)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Use of maximum-entropy POS tagging and base noun-phrase chunking to identify entities and relation spans cheaply and robustly across domains, replacing heavier parsing/NER in the extraction pipeline.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Maximum Entropy Models for Natural Language Ambiguity Resolution</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>procedure_name</strong></td>
                            <td>Lightweight POS tagging and base noun-phrase chunking for entity detection</td>
                        </tr>
                        <tr>
                            <td><strong>procedure_description</strong></td>
                            <td>Each sentence is POS-tagged using maximum-entropy models; a lightweight noun-phrase chunker identifies base noun phrases and provides probabilities that each word belongs to an entity. These probabilities are used to discard low-confidence entity detections. Relations are extracted by heuristically trimming the text between noun phrases (removing non-essential modifiers) and forming candidate tuples which are then classified.</td>
                        </tr>
                        <tr>
                            <td><strong>procedure_type</strong></td>
                            <td>computational method / preprocessing / NLP pipeline</td>
                        </tr>
                        <tr>
                            <td><strong>source_domain</strong></td>
                            <td>General NLP (POS tagging and chunking developed and validated on multiple corpora / computational linguistics)</td>
                        </tr>
                        <tr>
                            <td><strong>target_domain</strong></td>
                            <td>Web-scale Information Extraction / Open IE</td>
                        </tr>
                        <tr>
                            <td><strong>transfer_type</strong></td>
                            <td>direct application with pragmatic integration (replacement of heavy parsing)</td>
                        </tr>
                        <tr>
                            <td><strong>modifications_made</strong></td>
                            <td>Used POS/chunking as a lightweight substitute for full syntactic parsing and NER; integrated chunker-provided word-level entity probabilities into extraction filtering; heuristics applied to relation span trimming to remove overspecifying phrases.</td>
                        </tr>
                        <tr>
                            <td><strong>transfer_success</strong></td>
                            <td>successful - provided fast, robust entity detection enabling extraction at 0.036 CPU seconds per sentence (≈80x faster than dependency parsing), while retaining competitive accuracy (TextRunner matched or exceeded KnowItAll precision on sampled relations). Some errors remained, particularly in noun-phrase boundary detection and argument truncation.</td>
                        </tr>
                        <tr>
                            <td><strong>barriers_encountered</strong></td>
                            <td>Noun-phrase analysis errors (truncated arguments or stray words) remained a dominant error source; absence of full NER/type information made boundary detection and argument typing harder.</td>
                        </tr>
                        <tr>
                            <td><strong>facilitating_factors</strong></td>
                            <td>Maximum-entropy POS and chunking models are known to be relatively robust across domains; chunker-provided confidence scores enabled filtering of low-quality entity detections; the cheaper cost allowed scaling.</td>
                        </tr>
                        <tr>
                            <td><strong>contextual_requirements</strong></td>
                            <td>Availability of accurate POS tagger and NP chunker (language-specific); integration of chunker confidence into extraction heuristics; heuristics for trimming relation spans.</td>
                        </tr>
                        <tr>
                            <td><strong>generalizability</strong></td>
                            <td>High — the approach is applicable to many languages and domains where POS/tagging and chunking models exist; particularly useful where full parsing or NER is infeasible at scale.</td>
                        </tr>
                        <tr>
                            <td><strong>knowledge_type</strong></td>
                            <td>instrumental/technical skills and explicit procedural steps (how to replace parsing with POS/chunking and integrate confidence thresholds).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Open Information Extraction from the Web', 'publication_date_yy_mm': '2007-01'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e554.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e554.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of experimental methods, techniques, or procedures being transferred, adapted, or applied from one scientific domain or context to another scientific domain or context, including details about the transfer process and outcomes.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>DIRT-based synonym discovery (preliminary)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Data-driven relation synonym discovery based on DIRT (Lin & Pantel 2001)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Preliminary experiments adapting the DIRT unsupervised inference-rule/relation-discovery method to discover relation synonyms among Open IE relation strings.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Discovery of inference rules from text</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>procedure_name</strong></td>
                            <td>DIRT-style distributional inference for relation synonym discovery</td>
                        </tr>
                        <tr>
                            <td><strong>procedure_description</strong></td>
                            <td>DIRT discovers inference rules / similar relations by comparing dependency paths and distributional contexts; authors report preliminary experiments applying a DIRT-based, data-driven method to find synonymous relations among TextRunner's extracted relation strings to reduce redundancy.</td>
                        </tr>
                        <tr>
                            <td><strong>procedure_type</strong></td>
                            <td>computational method / unsupervised relation clustering / synonym discovery</td>
                        </tr>
                        <tr>
                            <td><strong>source_domain</strong></td>
                            <td>Distributional relation discovery / computational semantics (original DIRT work on smaller corpora)</td>
                        </tr>
                        <tr>
                            <td><strong>target_domain</strong></td>
                            <td>Open IE relation normalization and synonym detection on Web-scale tuples</td>
                        </tr>
                        <tr>
                            <td><strong>transfer_type</strong></td>
                            <td>adapted/modified for new context (preliminary)</td>
                        </tr>
                        <tr>
                            <td><strong>modifications_made</strong></td>
                            <td>Applied DIRT-style similarity measures to clusters of Open IE relation strings and tuples at web scale; details are preliminary and not fully described — authors note experiments confirmed hypothesis but did not integrate method at scale.</td>
                        </tr>
                        <tr>
                            <td><strong>transfer_success</strong></td>
                            <td>partially successful / preliminary - preliminary experiments confirmed feasibility of data-driven synonym discovery, but method was not fully integrated nor used in main reported results.</td>
                        </tr>
                        <tr>
                            <td><strong>barriers_encountered</strong></td>
                            <td>Scale and polysemy: relations have multiple senses depending on argument types, making unsupervised synonym detection without type information difficult; computational cost and need for argument-type checking limited integration.</td>
                        </tr>
                        <tr>
                            <td><strong>facilitating_factors</strong></td>
                            <td>Availability of large numbers of tuples with shared argument pairs aids distributional similarity; prior DIRT methodology provides a starting point.</td>
                        </tr>
                        <tr>
                            <td><strong>contextual_requirements</strong></td>
                            <td>Large corpus of tuples with sufficient co-occurrence statistics; mechanisms to cluster/compare dependency-like relation representations; possibly argument type information to disambiguate senses.</td>
                        </tr>
                        <tr>
                            <td><strong>generalizability</strong></td>
                            <td>Unclear — promising but requires additional components (entity resolution/type checking) to perform well across highly heterogeneous Web relations.</td>
                        </tr>
                        <tr>
                            <td><strong>knowledge_type</strong></td>
                            <td>theoretical principles and explicit computational procedures (distributional similarity and path comparison), noted here as preliminary/mentioned rather than fully implemented.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Open Information Extraction from the Web', 'publication_date_yy_mm': '2007-01'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Accurate unlexicalized parsing <em>(Rating: 2)</em></li>
                <li>A Probabilistic Model of Redundancy in Information Extraction <em>(Rating: 2)</em></li>
                <li>Maximum Entropy Models for Natural Language Ambiguity Resolution <em>(Rating: 2)</em></li>
                <li>Discovery of inference rules from text <em>(Rating: 2)</em></li>
                <li>Unsupervised named-entity extraction from the web: An experimental study <em>(Rating: 2)</em></li>
                <li>Preemptive information extraction using unrestricted relation discovery <em>(Rating: 1)</em></li>
                <li>On-demand information extraction <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-554",
    "paper_id": "paper-498bb0efad6ec15dd09d941fb309aa18d6df9f5f",
    "extraction_schema_id": "extraction-schema-16",
    "extracted_data": [
        {
            "name_short": "Self-Supervised Learner",
            "name_full": "Self-Supervised Learner for Open Information Extraction (TextRunner)",
            "brief_description": "A procedure that automatically labels its own training data by using a dependency parser to identify trustworthy and untrustworthy relation tuples, then trains a parser-independent Naive Bayes classifier on domain-independent features for large-scale, parser-free extraction.",
            "citation_title": "here",
            "mention_or_use": "use",
            "procedure_name": "Self-supervised training via parser-labeled examples",
            "procedure_description": "The system parses a small sample of sentences with a dependency parser to produce dependency graphs; it identifies base noun phrases and traverses parse paths between noun-phrase pairs to propose candidate relation tuples. Heuristic syntactic constraints mark tuples as positive (trustworthy) or negative. Each tuple is converted into a feature vector of parser-independent features (POS-tag sequences, token counts, stopword counts, surrounding POS tags, proper-noun flags, etc.). A Naive Bayes classifier is trained on these automatically labeled examples. The trained classifier is then applied corpus-wide during a single-pass extraction that uses only lightweight POS and chunking (no parser).",
            "procedure_type": "computational method / machine learning training protocol",
            "source_domain": "Deep syntactic parsing / computational linguistics (dependency parsing on curated corpora like newswire / Penn Treebank)",
            "target_domain": "Web-scale Information Extraction / Open IE (heterogeneous web text)",
            "transfer_type": "adapted/modified for new context",
            "modifications_made": "Parser use was limited to a small, pre-processing sample (not the full corpus) to avoid scale issues and parser brittleness on web text; syntactic constraints were relaxed to be tolerant of local parse errors; the parser-derived labels were converted to feature vectors containing only parser-independent features so the final extractor would not require the parser; a noise-tolerant learning algorithm (Naive Bayes) was used to recover from noisy auto-labels.",
            "transfer_success": "successful - produced a classifier that substantially outperformed an expert hand-built relation-independent classifier (authors report the hand-built baseline achieved roughly one third the accuracy of the Learner). Enabled extraction at scale without running a parser across the whole corpus.",
            "barriers_encountered": "Dependency parsers make many more errors on heterogeneous Web text than on newswire; parser-based labels are noisy; difficulty anticipating relation forms across diverse text; noun phrase boundary and argument truncation errors remain a significant source of error.",
            "facilitating_factors": "Availability of an accurate parser for smaller, cleaner corpora to bootstrap labels; redundancy and diversity of web text allowing enough training examples; use of domain-independent features and noise-tolerant learner; restricting parser use to a sampled training set reduced scale and brittleness issues.",
            "contextual_requirements": "A dependency parser and parsed sample of sentences; implementation of syntactic heuristics to auto-label tuples; feature extraction pipeline to map tuples to parser-independent features; compute for training classifier (small scale compared to full parsing).",
            "generalizability": "Moderately high — authors state the classifier is language-specific (needs language-specific POS/chunker and parser for the bootstrapping step) but contains no relation-specific lexical features, so the approach can be applied to other domains and languages where a parser and POS tools exist and a small parsed sample can be obtained.",
            "knowledge_type": "explicit procedural steps and technical skills (how to auto-label with a parser and train a parser-independent classifier); some tacit know-how in designing syntactic heuristics.",
            "uuid": "e554.0",
            "source_info": {
                "paper_title": "Open Information Extraction from the Web",
                "publication_date_yy_mm": "2007-01"
            }
        },
        {
            "name_short": "Dependency parser bootstrap",
            "name_full": "Use of an off-the-shelf dependency parser (Klein & Manning 2003) for bootstrapping training labels",
            "brief_description": "Application of a dependency parser originally developed for curated corpora to automatically produce labeled training instances for an Open IE learner operating on noisy web text; parser outputs are used only in a limited training stage.",
            "citation_title": "Accurate unlexicalized parsing",
            "mention_or_use": "use",
            "procedure_name": "Dependency parsing for auto-labeling training data",
            "procedure_description": "A dependency parser is run on several thousand sampled sentences to obtain dependency graphs. Base noun phrases are extracted; for each noun-phrase pair, the parse path connecting them is traversed to propose candidate relation strings. Heuristic syntactic constraints (path length limits, non-crossing sentence boundaries, excluding pronoun-only arguments) label tuples as positive or negative, producing training data for a Naive Bayes classifier that will be used for parser-free extraction across the full corpus.",
            "procedure_type": "computational method / data annotation/bootstrap technique",
            "source_domain": "Syntactic dependency parsing developed and validated on curated corpora (computational linguistics / parsing research)",
            "target_domain": "Large-scale, heterogeneous web information extraction",
            "transfer_type": "adapted/modified for new context",
            "modifications_made": "Parser usage confined to a small training sample rather than full-corpus; labeling heuristics were designed to be tolerant to local parse errors typical of web text; parser-derived information was transformed into parser-independent features so the production extractor does not require parsing.",
            "transfer_success": "partially successful - succeeded in producing training labels that enabled a high-performing, parser-free extractor; however parser errors remained a source of noisy labels, mitigated by noise-tolerant learning.",
            "barriers_encountered": "High parser error rates on heterogeneous web text compared to newswire; diversity of entity types and surface forms on the Web reduced parser reliability.",
            "facilitating_factors": "Using the parser only on a small sample reduced the impact of parser brittleness; careful syntactic heuristics and noise-tolerant learner compensated for labeling noise.",
            "contextual_requirements": "Access to a robust dependency parser and a representative small sample of sentences; implementation of syntactic constraints for labeling; compute to parse sample.",
            "generalizability": "Good for contexts where a parser exists for the target language and a small representative sample can be parsed; less applicable where no parser is available or where web text is extremely divergent from parser training genres.",
            "knowledge_type": "explicit procedural steps and instrumental/technical skills (running a parser, extracting parse-path features, defining syntactic heuristics).",
            "uuid": "e554.1",
            "source_info": {
                "paper_title": "Open Information Extraction from the Web",
                "publication_date_yy_mm": "2007-01"
            }
        },
        {
            "name_short": "Redundancy-based Assessor",
            "name_full": "Probabilistic Redundancy-Based Assessor (Downey et al., 2005 model applied to TextRunner)",
            "brief_description": "A probabilistic model that uses redundancy (number of distinct supporting sentences) to estimate the probability that an extracted tuple is correct; previously applied in KnowItAll and reused here to score Open IE tuples.",
            "citation_title": "A Probabilistic Model of Redundancy in Information Extraction",
            "mention_or_use": "use",
            "procedure_name": "Redundancy-based probabilistic assessment of extractions",
            "procedure_description": "After extraction and normalization (omitting non-essential modifiers, merging identical normalized relations), tuples are aggregated and the number of distinct supporting sentences for each tuple is counted. The redundancy model computes the posterior probability that a tuple is correct given it was extracted from k distinct sentences. These probabilities are used to filter/score extractions (e.g., retaining tuples with probability ≥ 0.8).",
            "procedure_type": "computational method / probabilistic scoring / data analysis technique",
            "source_domain": "Unsupervised web information extraction (KnowItAll system / IE probabilistic modeling)",
            "target_domain": "Open Information Extraction (TextRunner) / large-scale tuple ranking and filtering",
            "transfer_type": "direct application without major modification",
            "modifications_made": "Applied the existing redundancy model to normalized Open IE tuples after relation normalization and merging; counts are based on distinct sentences for normalized relations rather than relation-specific, hand-specified patterns. No fundamental change to the probabilistic model is described, but integration required tuple normalization and merging steps specific to Open IE.",
            "transfer_success": "successful - model produced robust probability estimates used to filter 11.3M high-probability tuples (prob ≥ 0.8); human evaluation on filtered set showed 80.4% correctness overall, supporting effectiveness of redundancy scoring.",
            "barriers_encountered": "Need to normalize relations and merge equivalent relation strings before counting support; some relations are overly general and require exclusion (top 0.1% by support).",
            "facilitating_factors": "High redundancy in Web text (multiple independent mentions of same fact) supports probabilistic estimation; prior demonstration of model efficacy in KnowItAll provided validation.",
            "contextual_requirements": "Large corpus with many redundant mentions of facts; ability to normalize relation strings and count distinct sentence-level supports; compute to aggregate and score tuples.",
            "generalizability": "High for other large, redundant corpora (Web-scale or news archives); less effective for sparse corpora that lack redundancy.",
            "knowledge_type": "theoretical principles and explicit procedural steps (probabilistic modeling of redundancy and its operationalization for scoring extractions).",
            "uuid": "e554.2",
            "source_info": {
                "paper_title": "Open Information Extraction from the Web",
                "publication_date_yy_mm": "2007-01"
            }
        },
        {
            "name_short": "Lightweight POS/NP Chunking (OpenNLP)",
            "name_full": "Maximum-entropy part-of-speech tagging and noun-phrase chunking (as implemented in OpenNLP)",
            "brief_description": "Use of maximum-entropy POS tagging and base noun-phrase chunking to identify entities and relation spans cheaply and robustly across domains, replacing heavier parsing/NER in the extraction pipeline.",
            "citation_title": "Maximum Entropy Models for Natural Language Ambiguity Resolution",
            "mention_or_use": "use",
            "procedure_name": "Lightweight POS tagging and base noun-phrase chunking for entity detection",
            "procedure_description": "Each sentence is POS-tagged using maximum-entropy models; a lightweight noun-phrase chunker identifies base noun phrases and provides probabilities that each word belongs to an entity. These probabilities are used to discard low-confidence entity detections. Relations are extracted by heuristically trimming the text between noun phrases (removing non-essential modifiers) and forming candidate tuples which are then classified.",
            "procedure_type": "computational method / preprocessing / NLP pipeline",
            "source_domain": "General NLP (POS tagging and chunking developed and validated on multiple corpora / computational linguistics)",
            "target_domain": "Web-scale Information Extraction / Open IE",
            "transfer_type": "direct application with pragmatic integration (replacement of heavy parsing)",
            "modifications_made": "Used POS/chunking as a lightweight substitute for full syntactic parsing and NER; integrated chunker-provided word-level entity probabilities into extraction filtering; heuristics applied to relation span trimming to remove overspecifying phrases.",
            "transfer_success": "successful - provided fast, robust entity detection enabling extraction at 0.036 CPU seconds per sentence (≈80x faster than dependency parsing), while retaining competitive accuracy (TextRunner matched or exceeded KnowItAll precision on sampled relations). Some errors remained, particularly in noun-phrase boundary detection and argument truncation.",
            "barriers_encountered": "Noun-phrase analysis errors (truncated arguments or stray words) remained a dominant error source; absence of full NER/type information made boundary detection and argument typing harder.",
            "facilitating_factors": "Maximum-entropy POS and chunking models are known to be relatively robust across domains; chunker-provided confidence scores enabled filtering of low-quality entity detections; the cheaper cost allowed scaling.",
            "contextual_requirements": "Availability of accurate POS tagger and NP chunker (language-specific); integration of chunker confidence into extraction heuristics; heuristics for trimming relation spans.",
            "generalizability": "High — the approach is applicable to many languages and domains where POS/tagging and chunking models exist; particularly useful where full parsing or NER is infeasible at scale.",
            "knowledge_type": "instrumental/technical skills and explicit procedural steps (how to replace parsing with POS/chunking and integrate confidence thresholds).",
            "uuid": "e554.3",
            "source_info": {
                "paper_title": "Open Information Extraction from the Web",
                "publication_date_yy_mm": "2007-01"
            }
        },
        {
            "name_short": "DIRT-based synonym discovery (preliminary)",
            "name_full": "Data-driven relation synonym discovery based on DIRT (Lin & Pantel 2001)",
            "brief_description": "Preliminary experiments adapting the DIRT unsupervised inference-rule/relation-discovery method to discover relation synonyms among Open IE relation strings.",
            "citation_title": "Discovery of inference rules from text",
            "mention_or_use": "mention",
            "procedure_name": "DIRT-style distributional inference for relation synonym discovery",
            "procedure_description": "DIRT discovers inference rules / similar relations by comparing dependency paths and distributional contexts; authors report preliminary experiments applying a DIRT-based, data-driven method to find synonymous relations among TextRunner's extracted relation strings to reduce redundancy.",
            "procedure_type": "computational method / unsupervised relation clustering / synonym discovery",
            "source_domain": "Distributional relation discovery / computational semantics (original DIRT work on smaller corpora)",
            "target_domain": "Open IE relation normalization and synonym detection on Web-scale tuples",
            "transfer_type": "adapted/modified for new context (preliminary)",
            "modifications_made": "Applied DIRT-style similarity measures to clusters of Open IE relation strings and tuples at web scale; details are preliminary and not fully described — authors note experiments confirmed hypothesis but did not integrate method at scale.",
            "transfer_success": "partially successful / preliminary - preliminary experiments confirmed feasibility of data-driven synonym discovery, but method was not fully integrated nor used in main reported results.",
            "barriers_encountered": "Scale and polysemy: relations have multiple senses depending on argument types, making unsupervised synonym detection without type information difficult; computational cost and need for argument-type checking limited integration.",
            "facilitating_factors": "Availability of large numbers of tuples with shared argument pairs aids distributional similarity; prior DIRT methodology provides a starting point.",
            "contextual_requirements": "Large corpus of tuples with sufficient co-occurrence statistics; mechanisms to cluster/compare dependency-like relation representations; possibly argument type information to disambiguate senses.",
            "generalizability": "Unclear — promising but requires additional components (entity resolution/type checking) to perform well across highly heterogeneous Web relations.",
            "knowledge_type": "theoretical principles and explicit computational procedures (distributional similarity and path comparison), noted here as preliminary/mentioned rather than fully implemented.",
            "uuid": "e554.4",
            "source_info": {
                "paper_title": "Open Information Extraction from the Web",
                "publication_date_yy_mm": "2007-01"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Accurate unlexicalized parsing",
            "rating": 2
        },
        {
            "paper_title": "A Probabilistic Model of Redundancy in Information Extraction",
            "rating": 2
        },
        {
            "paper_title": "Maximum Entropy Models for Natural Language Ambiguity Resolution",
            "rating": 2
        },
        {
            "paper_title": "Discovery of inference rules from text",
            "rating": 2
        },
        {
            "paper_title": "Unsupervised named-entity extraction from the web: An experimental study",
            "rating": 2
        },
        {
            "paper_title": "Preemptive information extraction using unrestricted relation discovery",
            "rating": 1
        },
        {
            "paper_title": "On-demand information extraction",
            "rating": 1
        }
    ],
    "cost": 0.014036,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Open Information Extraction from the Web</h1>
<p>Michele Banko, Michael J Cafarella, Stephen Soderland, Matt Broadhead and Oren Etzioni<br>Turing Center<br>Department of Computer Science and Engineering<br>University of Washington<br>Box 352350<br>Seattle, WA 98195, USA<br>{banko,mjc,soderlan,hastur,etzioni} @cs.washington.edu</p>
<h4>Abstract</h4>
<p>Traditionally, Information Extraction (IE) has focused on satisfying precise, narrow, pre-specified requests from small homogeneous corpora (e.g., extract the location and time of seminars from a set of announcements). Shifting to a new domain requires the user to name the target relations and to manually create new extraction rules or hand-tag new training examples. This manual labor scales linearly with the number of target relations. This paper introduces Open IE (OIE), a new extraction paradigm where the system makes a single data-driven pass over its corpus and extracts a large set of relational tuples without requiring any human input. The paper also introduces TextRUNNER, a fully implemented, highly scalable OIE system where the tuples are assigned a probability and indexed to support efficient extraction and exploration via user queries. We report on experiments over a 9,000,000 Web page corpus that compare TextRUNNER with KnowItAll, a state-of-the-art Web IE system. TextRunner achieves an error reduction of $33 \%$ on a comparable set of extractions. Furthermore, in the amount of time it takes KnowItAll to perform extraction for a handful of pre-specified relations, TextRunner extracts a far broader set of facts reflecting orders of magnitude more relations, discovered on the fly. We report statistics on TextRunner's 11,000,000 highest probability tuples, and show that they contain over 1,000,000 concrete facts and over 6,500,000 more abstract assertions.</p>
<h2>1 Introduction and Motivation</h2>
<p>This paper introduces Open Information Extraction (OIE)— a novel extraction paradigm that facilitates domainindependent discovery of relations extracted from text and readily scales to the diversity and size of the Web corpus. The sole input to an OIE system is a corpus, and its output is a set of extracted relations. An OIE system makes a single pass over its corpus guaranteeing scalability with the size of the corpus.</p>
<p>Information Extraction (IE) has traditionally relied on extensive human involvement in the form of hand-crafted extraction rules or hand-tagged training examples. Moreover, the user is required to explicitly pre-specify each relation of interest. While IE has become increasingly automated over time, enumerating all potential relations of interest for extraction by an IE system is highly problematic for corpora as large and varied as the Web. To make it possible for users to issue diverse queries over heterogeneous corpora, IE systems must move away from architectures that require relations to be specified prior to query time in favor of those that aim to discover all possible relations in the text.</p>
<p>In the past, IE has been used on small, homogeneous corpora such as newswire stories or seminar announcements. As a result, traditional IE systems are able to rely on "heavy" linguistic technologies tuned to the domain of interest, such as dependency parsers and Named-Entity Recognizers (NERs). These systems were not designed to scale relative to the size of the corpus or the number of relations extracted, as both parameters were fixed and small.</p>
<p>The problem of extracting information from the Web violates all of these assumptions. Corpora are massive and heterogeneous, the relations of interest are unanticipated, and their number can be large. Below, we consider these challenges in more detail.</p>
<p>Automation The first step in automating IE was moving from knowledge-based IE systems to trainable systems that took as input hand-tagged instances [Riloff, 1996] or document segments [Craven et al., 1999] and automatically learned domain-specific extraction patterns. DIPRE [Brin, 1998], SnowBALL [Agichtein and Gravano, 2000], and Webbased question answering systems [Ravichandran and Hovy, 2002] further reduced manual labor needed for relationspecific text extraction by requiring only a small set of tagged seed instances or a few hand-crafted extraction patterns, per relation, to launch the training process. Still, the creation of suitable training data required substantial expertise as well as non-trivial manual effort for every relation extracted, and the relations have to be specified in advance.</p>
<p>Corpus Heterogeneity Previous approaches to relation extraction have employed kernel-based methods [Bunescu</p>
<p>and Mooney, 2005], maximum-entropy models [Kambhatla, 2004], graphical models [Rosario and Hearst, 2004; Culotta et al., 2006], and co-occurrence statistics [Lin and Pantel, 2001; Ciaramita et al., 2005] over small, domain-specific corpora and limited sets of relations. The use of NERs as well as syntactic or dependency parsers is a common thread that unifies most previous work. But this rather "heavy" linguistic technology runs into problems when applied to the heterogeneous text found on the Web. While the parsers work well when trained and applied to a particular genre of text, such as financial news data in the Penn Treebank, they make many more parsing errors when confronted with the diversity of Web text. Moreover, the number and complexity of entity types on the Web means that existing NER systems are inapplicable [Downey et al., 2007].</p>
<p>Efficiency KNOWITALL [Etzioni et al., 2005] is a state-of-the-art Web extraction system that addresses the automation challenge by learning to label its own training examples using a small set of domain-independent extraction patterns. KnowItAll also addresses corpus heterogeneity by relying on a part-of-speech tagger instead of a parser, and by not requiring a NER. However, KnowItAll requires large numbers of search engine queries and Web page downloads. As a result, experiments using KnowItAll can take weeks to complete. Finally, KnowItAll takes relation names as input. Thus, the extraction process has to be run, and rerun, each time a relation of interest is identified. The OIE paradigm retains KnowItAll's benefits but eliminates its inefficiencies.</p>
<p>The paper reports on TextRunner, the first scalable, domain-independent OIE system. TextRunner is a fully implemented system that extracts relational tuples from text. The tuples are assigned a probability and indexed to support efficient extraction and exploration via user queries.</p>
<p>The main contributions of this paper are to:</p>
<ul>
<li>Introduce Open Information Extraction (OIE)—a new extraction paradigm that obviates relation specificity by automatically discovering possible relations of interest while making only a single pass over its corpus.</li>
<li>Introduce TextRunner, a fully implemented OIE system, and highlight the key elements of its novel architecture. The paper compares TextRunner experimentally with the state-of-the-art Web IE system, KnowItAll, and show that TextRunner achieves a 33\% relative error reduction for a comparable number of extractions.</li>
<li>Report on statistics over TextRunner's 11,000,000 highest probability extractions, which demonstrates its scalability, helps to assess the quality of its extractions, and suggests directions for future work.</li>
</ul>
<p>The remainder of the paper is organized as follows. Section 2 introduces TextRunner, focusing on the novel elements of its architecture. Section 3 reports on our experimental results. Section 4 considers related work, and the paper concludes with a discussion of future work.</p>
<h2>2 Open IE in TextRunner</h2>
<p>This section describes TextRunner's architecture focusing on its novel components, and then considers how TextRunner addresses each of the challenges outlined in Section 1. TextRunner's sole input is a corpus and its output is a set of extractions that are efficiently indexed to support exploration via user queries.</p>
<p>TextRunner consists of three key modules:</p>
<ol>
<li>Self-Supervised Learner: Given a small corpus sample as input, the Learner outputs a classifier that labels candidate extractions as "trustworthy" or not. The Learner requires no hand-tagged data.</li>
<li>Single-Pass Extractor: The Extractor makes a single pass over the entire corpus to extract tuples for all possible relations. The Extractor does not utilize a parser. The Extractor generates one or more candidate tuples from each sentence, sends each candidate to the classifier, and retains the ones labeled as trustworthy.</li>
<li>Redundancy-Based Assessor: The Assessor assigns a probability to each retained tuple based on a probabilistic model of redundancy in text introduced in [Downey et al., 2005].
Below, we describe each module in more detail, discuss TextRunner's ability to efficiently process queries over its extraction set, and analyze the system's time complexity and speed.</li>
</ol>
<h3>2.1 Self-Supervised Learner</h3>
<p>The Learner operates in two steps. First, it automatically labels its own training data as positive or negative. Second, it uses this labeled data to train a Naïve Bayes classifier, which is then used by the Extractor module.</p>
<p>While deploying a deep linguistic parser to extract relationships between objects is not practical at Web scale, we hypothesized that a parser can help to train an Extractor. Thus, prior to full-scale relation extraction, the Learner uses a parser [Klein and Manning, 2003] to automatically identify and label a set of trustworthy (and untrustworthy) extractions. These extractions are are used as positive (or negative) training examples to a Naive Bayes classifier. ${ }^{1}$ Our use of a noisetolerant learning algorithm helps the system recover from the errors made by the parser when applied to heterogeneous Web text.</p>
<p>Extractions take the form of a tuple $t=\left(e_{i}, r_{i, j}, e_{j}\right)$, where $e_{i}$ and $e_{j}$ are strings meant to denote entities, and $r_{i, j}$ is a string meant to denote a relationship between them. The trainer parses several thousand sentences to obtain their dependency graph representations. For each parsed sentence, the system finds all base noun phrase constituents $e_{i} .{ }^{2}$ For each pair of noun phrases $\left(e_{i}, e_{j}\right), i&lt;j$, the system traverses the parse structure connecting them to locate a sequence of words that becomes a potential relation $r_{i, j}$ in the tuple $t$. The Learner labels $t$ as a positive example if certain constraints</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>on the syntactic structure shared by $e_{i}$ and $e_{j}$ are met. These constraints seek to extract relationships that are likely to be correct even when the parse tree contains some local errors; if any constraint fails, $t$ is labeled as a negative instance. Some of the heuristics the system uses are:</p>
<ul>
<li>There exists a dependency chain between $e_{i}$ and $e_{j}$ that is no longer than a certain length.</li>
<li>The path from $e_{i}$ to $e_{j}$ along the syntax tree does not cross a sentence-like boundary (e.g. relative clauses).</li>
<li>Neither $e_{i}$ nor $e_{j}$ consist solely of a pronoun.</li>
</ul>
<p>Once the Learner has found and labeled a set of tuples of the form $t=\left(e_{i}, r_{i, j}, e_{j}\right)$, it maps each tuple to a feature vector representation. All features are domain independent, and can be evaluated at extraction time without the use of a parser. Examples of features include the presence of part-of-speech tag sequences in the relation $r_{i, j}$, the number of tokens in $r_{i, j}$, the number of stopwords in $r_{i, j}$, whether or not an object $e$ is found to be a proper noun, the part-of-speech tag to the left of $e_{i}$, the part-of-speech tag to the right of $e_{j}$. Following feature extraction, the Learner uses this set of automatically labeled feature vectors as input to a Naive Bayes classifier.</p>
<p>The classifier output by the Learner is language-specific but contains no relation-specific or lexical features. Thus, it can be used in a domain-independent manner.</p>
<p>Prior to using a learning approach, one of the authors invested several weeks in manually constructing a relationindependent extraction classifier. A first attempt at relation extraction took the entire string between two entities detected to be of interest. Not surprisingly, this permissive approach captured an excess of extraneous and incoherent information. At the other extreme, a strict approach that simply looks for verbs in relation to a pair of nouns resulted in a loss of other links of importance, such as those that specify noun or attribute-centric properties, for example, (Oppenheimer, professor of, theoretical physics) and (trade schools, similar to, colleges). A purely verb-centric method was prone to extracting incomplete relationships, for example, (Berkeley, located, Bay Area) instead of (Berkeley, located in, Bay Area). The heuristic-based approaches that were attempted exposed the difficulties involved in anticipating the form of a relation and its arguments in a general manner. At best, a final handbuilt classifier, which is a natural baseline for the learned one, achieved a mere one third of the accuracy of that obtained by the Learner.</p>
<h3>2.2 Single-Pass Extractor</h3>
<p>The Extractor makes a single pass over its corpus, automatically tagging each word in each sentence with its most probable part-of-speech. Using these tags, entities are found by identifying noun phrases using a lightweight noun phrase chunker. ${ }^{3}$ Relations are found by examining the text between</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup>the noun phrases and heuristically eliminating non-essential phrases, such as prepositional phrases that overspecify an entity (e.g."Scientists from many universities are studying ..." is analyzed as "Scientists are studying..."), or individual tokens, such as adverbs (e.g."definitely developed" is reduced to "developed").</p>
<p>For each noun phrase it finds, the chunker also provides the probability with which each word is believed to be part of the entity. These probabilities are subsequently used to discard tuples containing entities found with low levels of confidence. Finally, each candidate tuple $t$ is presented to the classifier. If the classifier labels $t$ as trustworthy, it is extracted and stored by TextRUNNER.</p>
<h3>2.3 Redundancy-based Assessor</h3>
<p>During the extraction process, TextRUNNER creates a normalized form of the relation that omits non-essential modifiers to verbs and nouns, e.g. was developed by as a normalized form of was originally developed by. After extraction has been performed over the entire corpus, TextRUNNER automatically merges tuples where both entities and normalized relation are identical and counts the number of distinct sentences from which each extraction was found.</p>
<p>Following extraction, the Assessor uses these counts to assign a probability to each tuple using the probabilistic model previously applied to unsupervised IE in the KnowItAll system. Without hand-tagged data, the model efficiently estimates the probability that a tuple $t=\left(e_{i}, r_{i, j}, e_{j}\right)$ is a correct instance of the relation $r_{i, j}$ between $e_{i}$ and $e_{j}$ given that it was extracted from $k$ different sentences. The model was shown to estimate far more accurate probabilities for IE than noisyor and pointwise mutual information based methods [Downey et al., 2005].</p>
<h3>2.4 Query Processing</h3>
<p>TextRUNNER is capable of responding to queries over millions of tuples at interactive speeds due to a inverted index distributed over a pool of machines. Each relation found during tuple extraction is assigned to a single machine in the pool. Every machine then computes an inverted index over the text of the locally-stored tuples, ensuring that each machine is guaranteed to store all of the tuples containing a reference to any relation assigned to that machine. ${ }^{4}$</p>
<p>The efficient indexing of tuples in TextRUNNER means that when a user (or application) wants to access a subset of tuples by naming one or more of its elements, the relevant subset can be retrieved in a manner of seconds, and irrelevant extractions remain unrevealed to the user. Since the relation names in TextRUNNER are drawn directly form the text, the intuitions that they implicitly use in formulating a search query are effective. Querying relational triples will be easier once TextRUNNER is able to know which relations are synonymous with others. However, asking the user to "guess the right word" is a problem that is shared by search engines, which suggests that it is manageable for naïve users.
niques enables TextRUNNER to be more robust to the highly diverse corpus of text on the Web.
${ }^{4}$ The inverted index itself is built using the Lucene open source search engine.</p>
<p>Finally, TextRunner's relation-centric index enables complex relational queries that are not currently possible using a standard inverted index used by today's search engines. These include relationship queries, unnamed-item queries, and multiple-attribute queries, each of which is described in detail in [Cafarella et al., 2006].</p>
<h3>2.5 Analysis</h3>
<p>Tuple extraction in TextRunner happens in $O(D)$ time, where $D$ is the number of documents in the corpus. It subsequently takes $O(T \log T)$ time to sort, count and assess the set of $T$ tuples found by the system. In contrast, each time a traditional IE system is asked to find instances of a new set of relations $R$ it may be forced to examine a substantial fraction of the documents in the corpus, making system run-time $O(R \cdot D)$. Thus, when $D$ and $R$ are large, as is typically the case on the Web, TextRunner's ability to extract information for all relations at once, without having them named explicitly in its input, results in a significant scalability advantage over previous IE systems (including KNOWITALL).</p>
<p>TEXTRUNNER extracts facts at an average speed of 0.036 CPU seconds per sentence. Compared to dependency parsers which take an average of 3 seconds to process a single sentence, TextRunner runs more than 80 times faster on our corpus. On average, a Web page in our corpus contains 18 sentences, making TextRunner's average processing speed per document 0.65 CPU seconds and the total CPU time to extract tuples from our 9 million Web page corpus less than 68 CPU hours. Because the corpus is easily divided into separate chunks, the total time for the process on our 20 machine cluster was less than 4 hours. It takes an additional 5 hours for TextRunner to merge and sort the extracted tuples. We compare the performance of TextRunner relative to a state-of-the-art Web IE system in Section 3.1.</p>
<p>The key to TextRunner's scalability is processing time that is linear in $D$ (and constant in $R$ ). But, as the above measurements show, TextRunner is not only scalable in theory, but also fast in practice.</p>
<h2>3 Experimental Results</h2>
<p>We first compare recall and error rate of TextRunner with that of a closed IE system on a set of relations in Section 3.1. We then turn to the fascinating challenge of characterizing the far broader set of facts and relations extracted by TextRunner in Section 3.2.</p>
<h3>3.1 Comparison with Traditional IE</h3>
<p>One means of evaluating Open IE is to compare its performance with a state-of-the-art Web IE system. For this comparison we used KnOWitAll [Etzioni et al., 2005], a unsupervised IE system capable of performing large-scale extraction from the Web. To control the experiments, both TextRunner and KnowItAll were tested on the task of extracting facts from our 9 million Web page corpus.</p>
<p>Since KnowitAll is a closed IE system, we needed to select a set of relations in advance. We randomly selected the following 10 relations that could be found in at least 1,000 sentences in the corpus, manually filtering out relations that were overly vague (e.g."includes"):</p>
<div class="codehilite"><pre><span></span><code>(&lt;proper noun&gt;, acquired, &lt;proper noun&gt;)
(&lt;proper noun&gt;, graduated from, &lt;proper noun&gt;)
(&lt;proper noun&gt;, is author of, &lt;proper noun&gt;)
(&lt;proper noun&gt;, is based in, &lt;proper noun&gt;)
(&lt;proper noun&gt;, studied, &lt;noun phrase&gt;)
(&lt;proper noun&gt;, studied at, &lt;proper noun&gt;)
(&lt;proper noun&gt;, was developed by, &lt;proper noun&gt;)
(&lt;proper noun&gt;, was formed in, &lt;year&gt;)
(&lt;proper noun&gt;, was founded by, &lt;proper noun&gt;)
(&lt;proper noun&gt;, worked with, &lt;proper noun&gt;)
</code></pre></div>

<p>Table 1 shows the average error rate over the ten relations and the total number of correct extractions for each of the two systems. TextRunner's average error rate is $33 \%$ lower than KnowitAll's, but it finds an almost identical number of correct extractions. TextRunner's improvement over KnowitAll can be largely attributed to its ability to better identify appropriate arguments to relations.</p>
<p>Still, a large proportion of the errors of both systems were from noun phrase analysis, where arguments were truncated or stray words added. It is difficult to find extraction boundaries accurately when the intended type of arguments such as company names, person names, or book titles is not specified to the system. This was particularly the case for the authorOf relation, where many arguments reflecting book titles were truncated and the error rate was was $32 \%$ for TextRunner and $47 \%$ for KnowitAll. With this outlier excluded, the average error rate is $10 \%$ for TextRunner and $16 \%$ for KnowitAll.</p>
<p>Even when extracting information for only ten relations, TextRunner's efficiency advantage is apparent. Even though they were run over the same 9 million page corpus, TextRunner's distributed extraction process took a total of 85 CPU hours, to perform extraction for all relations in the corpus at once, whereas KnowitAll, which analyzed all sentences in the corpus that potentially matched its rules, took an average of 6.3 hours per relation. In the amount of time that KnowitAll can extract data for 14 pre-specified relations, TextRunner discovers orders of magnitude more relations from the same corpus.</p>
<p>Beyond the ten relations sampled, there is a fundamental difference between the two systems. Standard IE systems can only operate on relations given to it a priori by the user, and are only practical for a relatively small number of relations. In contrast, Open IE operates without knowing the relations a priori, and extracts information from all relations at once. We consider statistics on TextRunner's extractions next.</p>
<h3>3.2 Global Statistics on Facts Learned</h3>
<p>Given a corpus of 9 million Web pages, containing 133 million sentences, TextRunner automatically extracted a set of 60.5 million tuples at an extraction rate of 2.2 tuples per sentence.</p>
<p>When analyzing the output of open IE system such as TextRunner, several question naturally arise: How many of the tuples found represent actual relationships with plausible arguments? What subset of these tuples is correct? How many of these tuples are distinct, as opposed to identical or synonymous? Answering these questions is challenging due to both the size and diversity of the tuple set. As explained</p>
<table>
<thead>
<tr>
<th></th>
<th>Average</th>
<th>Correct</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Error rate</td>
<td>Extractions</td>
</tr>
<tr>
<td>TextRunner</td>
<td>12%</td>
<td>11,476</td>
</tr>
<tr>
<td>KnowItAll</td>
<td>18%</td>
<td>11,631</td>
</tr>
</tbody>
</table>
<p>Table 1: Over a set of ten relations, TextRunner achieved a 33% lower error rate than KnowItAll, while finding approximately as many correct extractions.
below, we made a series of estimates and approximations in order to address the questions.</p>
<p>As a first step, we restricted our analysis to the subset of tuples that TextRunner extracted with high probability. Specifically, the tuples we evaluated met the following criteria: 1) TextRunner assigned a probability of at least 0.8 to the tuple; 2) The tuple's relation is supported by at least 10 distinct sentences in the corpus; 3) The tuple's relation is not found to be in the top $0.1 \%$ of relations by number of supporting sentences. (These relations were so general as to be nearly vacuous, such as (NP1, has, NP2)). This filtered set consists of 11.3 million tuples containing 278,085 distinct relation strings. This filtered set is the one used in all the measurements described in this section.</p>
<h2>Estimating the Correctness of Facts</h2>
<p>We randomly selected four hundred tuples from the filtered set as our sample. The measurements below are extrapolated based on hand tagging the sample. Three authors of this paper inspected the tuples in order to characterize the data extracted by TextRunner. Each evaluator first judged whether the relation was well-formed. A relation $r$ is considered to be well-formed if there is some pair of entities $X$ and $Y$ such that $(X, r, Y)$ is a relation between $X$ and $Y$. For example, (FCI, specializes in, software development) contains a wellformed relation, but (demands, of securing, border) does not. If a tuple was found to possess a well-formed relation, it was then judged to see if the arguments were reasonable for the relation. $X$ and $Y$ are well-formed arguments for the relation $r$ if $X$ and $Y$ are of a "type" of entity that can form a relation $(X, r, Y)$. An example of a tuple whose arguments are not well-formed is (29, dropped, instruments).</p>
<p>We further classified the tuples that met these criteria as either concrete or abstract. Concrete means that the truth of the tuple is grounded in particular entities, for example, (Tesla, invented, coil transformer). Abstract tuples are underspecified, such as (Einstein, derived, theory), or refer to entities specified elsewhere, but imply properties of general classes, such as (executive, hired by, company).</p>
<p>Finally, we judged each concrete or abstract tuple as true or false, based on whether it was consistent with the truth value of the sentence from which it was extracted. Figure 1 summarizes this analysis of the extracted tuples.</p>
<p>TextRunner finds 7.8 million facts having both a wellformed relation and arguments and probability at least 0.8 . Of those facts, $80.4 \%$ were deemed to be correct according to human reviewers. Within a given relation, an average of $14 \%$ of the tuples are concrete facts of which $88.1 \%$ are correct, and $86 \%$ are abstract facts of which $77.2 \%$ are correct. Concrete facts are potentially useful for information extraction or question answering, while abstract assertions are useful for
<img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Overview of the tuples extracted from 9 million Web page corpus. 7.8 million well-formed tuples are found having probability $\geq 0.8$. Of those, TextRunner finds 1 million concrete tuples with arguments grounded in particular real-world entities, $88.1 \%$ of which are correct, and 6.8 million tuples reflecting abstract assertions, $79.2 \%$ of which are correct.
ontology learning and other applications. Of course, only a small subset of the universe of tuples would be of interest in any particular application (e.g., the tuples corresponding to the relations in the experiment in Section 3.1).</p>
<h2>Estimating the Number of Distinct Facts</h2>
<p>Of the millions of tuples extracted by TextRunner, how many reflect distinct statements as opposed to reformulations of existing extractions? In order to answer this question, one needs to be able to detect when one relation is synonymous with another, as well as when an entity is referred to by multiple names. Both problems are very difficult in an unsupervised, domain-independent context with a very large number of relations and entities of widely varying types. In our measurements, we were only able to address relation synonymy, which means that the measurements reported below should be viewed as rough approximations.</p>
<p>In order to assess the number of distinct relations found by TextRunner, we further merged relations differing only in leading or trailing punctuation, auxiliary verbs, or in leading stopwords such as that, who and which. For example, "are consistent with" is merged with ", which is consistent with". We also merged relations differing only by their use of active and passive voice (e.g., invented is merged with was invented by). This procedure reduced the number of distinct relations to $91 \%$ of the number before merging.</p>
<p>Even after the above merge, the question remains: how many of the relation strings are synonymous? This is exceedingly difficult to answer because many of the relations that TextRunner finds have multiple senses. The relation developed, for example, may be a relation between a person and</p>
<p>an invention but also between a person and a disease. It is rare to find two distinct relations that are truly synonymous in all senses of each phrase unless domain-specific type checking is performed on one or both arguments. If the first argument is the name of a scientist, then developed is synonymous with invented and created, and is closely related to patented. Without such argument type checking, these relations will pick out overlapping, but quite distinct sets of tuples.</p>
<p>It is, however, easier for a human to assess similarity at the tuple level, where context in the form of entities grounding the relationship is available. In order to estimate the number of similar facts extracted by TextRunner, we began with our filtered set of 11.3 million tuples. For each tuple, we found clusters of concrete tuples of the form $\left(e_{1}, r, e_{2}\right),\left(e_{1}, q, e_{2}\right)$ where $r \neq q$, that is tuples where the entities match but the relation strings are distinct. We found that only one third of the tuples belonged to such "synonymy clusters".</p>
<p>Next, we randomly sampled 100 synonymy clusters and asked one author of this paper to determine how many distinct facts existed within each cluster. For example, the cluster of 4 tuples below describes 2 distinct relations $R_{1}$ and $R_{2}$ between Bletchley Park and Station $X$ as delineated below:</p>
<table>
<thead>
<tr>
<th style="text-align: left;">$R_{1}$</th>
<th style="text-align: left;">(Bletchley Park,</th>
<th style="text-align: left;">was location of</th>
<th style="text-align: left;">, Station X)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">$R_{2}$</td>
<td style="text-align: left;">(Bletchley Park,</td>
<td style="text-align: left;">being called</td>
<td style="text-align: left;">, Station X)</td>
</tr>
<tr>
<td style="text-align: left;">$R_{2}$</td>
<td style="text-align: left;">(Bletchley Park,</td>
<td style="text-align: left;">, known as</td>
<td style="text-align: left;">, Station X)</td>
</tr>
<tr>
<td style="text-align: left;">$R_{2}$</td>
<td style="text-align: left;">(Bletchley Park,</td>
<td style="text-align: left;">, codenamed</td>
<td style="text-align: left;">, Station X)</td>
</tr>
</tbody>
</table>
<p>Overall, we found that roughly one quarter of the tuples in our sample were reformulations of other tuples contained somewhere in the filtered set of 11.3 million tuples. Given our previous measurement that two thirds of the concrete fact tuples do not belong to synonymy clusters, we can compute that $\frac{2}{3}+\left(\frac{1}{3} \times \frac{3}{4}\right)$ or roughly $92 \%$ of the tuples found by TextRUNNER express distinct assertions. As pointed out earlier, this is an overestimate of the number of unique facts because we have not been able to factor in the impact of multiple entity names, which is a topic for future work.</p>
<h2>4 Related Work</h2>
<p>Traditional "closed" IE work was discussed in Section 1. Recent efforts [Pasca et al., 2006] seeking to undertake largescale extraction indicate a growing interest in the problem.</p>
<p>This year, Sekine [Sekine, 2006] proposed a paradigm for "on-demand information extraction," which aims to eliminate customization involved with adapting IE systems to new topics. Using unsupervised learning methods, the system automatically creates patterns and performs extraction based on a topic that has been specified by a user.</p>
<p>Also this year, Shinyama and Sekine [Shinyama and Sekine, 2006] described an approach to "unrestricted relation discovery" that was developed independently of our work, and tested on a collection of 28,000 newswire articles.</p>
<p>This work contains the important idea of avoiding relationspecificity, but does not scale to the Web as explained below.</p>
<p>Given a collection of documents, their system first performs clustering of the entire set of articles, partitioning the corpus into sets of articles believed to discuss similar topics. Within each cluster, named-entity recognition, co-reference resolution and deep linguistic parse structures are computed and then used to automatically identify relations between sets of entities. This use of "heavy" linguistic machinery would be problematic if applied to the Web.</p>
<p>Shinyama and Sekine's system, which uses pairwise vector-space clustering, initially requires an $O\left(D^{2}\right)$ effort where $D$ is the number of documents. Each document assigned to a cluster is then subject to linguistic processing, potentially resulting in another pass through the set of input documents. This is far more expensive for large document collections than TextRunner's $O(D+T \log T)$ runtime as presented earlier.</p>
<p>From a collection of 28,000 newswire articles, Shinyama and Sekine were able to discover 101 relations. While it is difficult to measure the exact number of relations found by TextRUNNER on its 9,000,000 Web page corpus, it is at least two or three orders of magnitude greater than 101.</p>
<h2>5 Conclusions</h2>
<p>This paper introduces Open IE from the Web, an unsupervised extraction paradigm that eschews relation-specific extraction in favor of a single extraction pass over the corpus during which relations of interest are automatically discovered and efficiently stored. Unlike traditional IE systems that repeatedly incur the cost of corpus analysis with the naming of each new relation, Open IE's one-time relation discovery procedure allows a user to name and explore relationships at interactive speeds.</p>
<p>The paper also introduces TextRunner, a fully implemented Open IE system, and demonstrates its ability to extract massive amounts of high-quality information from a nine million Web page corpus. We have shown that TextRunner is able to match the recall of the KnowItAll state-of-the-art Web IE system, while achieving higher precision.</p>
<p>In the future, we plan to integrate scalable methods for detecting synonyms and resolving multiple mentions of entities in TextRunner. The system would also benefit from the ability to learn the types of entities commonly taken by relations. This would enable the system to make a distinction between different senses of a relation, as well as better locate entity boundaries. Finally we plan to unify tuples output by TextRunner into a graph-based structure, enabling complex relational queries.</p>
<h2>Acknowledegments</h2>
<p>We thank the following people for helpful comments on previous drafts: Dan Weld, Eytan Adar, and Doug Downey.</p>
<p>This research was supported in part by NSF grants IIS-0535284 and IIS-0312988, DARPA contract NBCHD030010, ONR grant N00014-02-1-0324 as well as gifts from Google, and carried out at the University of</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>Washington's Turing Center. The first author of this paper received additional support thanks to a Google Anita Borg Memorial Scholarship.</p>
<h2>References</h2>
<p>[Agichtein and Gravano, 2000] E. Agichtein and L. Gravano. Snowball: Extracting relations from large plain-text collections. In Proceedings of the Fifth ACM International Conference on Digital Libraries, 2000.
[Brill and Ngai, 1999] E. Brill and G. Ngai. Man (and woman) vs. machine: a case study in base noun phrase learning. In Proceedings of the ACL, pages 65-72, 1999.
[Brin, 1998] S. Brin. Extracting Patterns and Relations from the World Wide Web. In WebDB Workshop at 6th International Conference on Extending Database Technology, EDBT'98, pages 172-183, Valencia, Spain, 1998.
[Bunescu and Mooney, 2005] R. Bunescu and R. Mooney. A shortest path dependency kernel for relation extraction. In Proc. of the HLT/EMLNP, 2005.
[Cafarella et al., 2006] Michael J. Cafarella, Michele Banko, and Oren Etzioni. Relational web search. Technical Report 06-04-02, University of Washington, 2006.
[Ciaramita et al., 2005] M. Ciaramita, A. Gangemi, E. Ratsch, J. Saric, and I. Rojas. Unsupervised learning of semantic relations between concepts of a molecular biology ontology. In Proceedings of IJCAI, 2005.
[Craven et al., 1999] M. Craven, D. DiPasquo, D. Freitag, A. McCallum, T. Mitchell, K. Nigam, and S. Slattery. Learning to construct knowledge bases from the world wide web. In Artificial Intelligence, 1999.
[Culotta et al., 2006] A. Culotta, A. McCallum, and J. Betz. Integrating probabilistic extraction models and relational data mining to discover relations and patterns in text. In Proceedings of HLT-NAACL, New York, NY, 2006.
[Downey et al., 2005] D. Downey, O. Etzioni, and S. Soderland. A Probabilistic Model of Redundancy in Information Extraction. In Proc. of IJCAI, 2005.
[Downey et al., 2007] D. Downey, M. Broadhead, and O. Etzioni. Locating Complex Named Entities in Web Text. In Proc. of IJCAI, 2007.
[Etzioni et al., 2005] O. Etzioni, M. Cafarella, D. Downey, S. Kok, A. Popescu, T. Shaked, S. Soderland, D. Weld, and A. Yates. Unsupervised named-entity extraction from the web: An experimental study. Artificial Intelligence, 165(1):91-134, 2005.
[Kambhatla, 2004] N. Kambhatla. Combining lexical, syntactic and semantic features with maximum entropy models. In Proceedings of ACL, 2004.
[Klein and Manning, 2003] Dan Klein and Christopher D. Manning. Accurate unlexicalized parsing. In Proceedings of the ACL, 2003.
[Lin and Pantel, 2001] D. Lin and P. Pantel. Discovery of inference rules from text. In Proceedings of KDD, 2001.
[Ngai and Florian, 2001] G. Ngai and R. Florian. Transformation-based learning in the fast lane. In Proceedings of the NAACL, pages 40-47, 2001.
[Pasca et al., 2006] M. Pasca, D. Lin, J. Bigham, A. Lifchits, and A. Jain. Names and similarities on the web: Fact extraction in the fast lane. In (To appear) Proc. of ACL/COLING 2006, 2006.
[Ratnaparkhi, 1998] A. Ratnaparkhi. Maximum Entropy Models for Natural Language Ambiguity Resolution. PhD thesis, University of Pennsylvania, 1998.
[Ravichandran and Hovy, 2002] D. Ravichandran and D. Hovy. Learning surface text patterns for a question answering system. In Proceedings of the ACL, pages 41-47, Philadelphia, Pennsylvania, 2002.
[Riloff, 1996] E. Riloff. Automatically constructing extraction patterns from untagged text. In Proc. of AAAI, 1996.
[Rosario and Hearst, 2004] B. Rosario and M. Hearst. Classifying semantic relations in bioscience text. In Proc. of ACL, 2004.
[Sekine, 2006] S. Sekine. On-demand information extraction. In Procs. of COLING, 2006.
[Shinyama and Sekine, 2006] Y. Shinyama and S. Sekine. Preemptive information extraction using unrestricted relation discovery. In Proc. of the HLT-NAACL, 2006.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{5}$ We carried out several preliminary experiments using a datadriven approach to synonym discovery based on DIRT [Lin and Pantel, 2001] that confirmed this hypothesis.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>