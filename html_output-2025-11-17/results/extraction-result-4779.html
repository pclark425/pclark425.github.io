<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-4779 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-4779</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-4779</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-103.html">extraction-schema-103</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details about the agent, the type of memory used, the tasks or benchmarks, performance with and without memory, comparisons, and any reported insights or limitations.</div>
                <p><strong>Paper ID:</strong> paper-248496374</p>
                <p><strong>Paper Title:</strong> <a href="https://arxiv.org/pdf/2205.00445v1.pdf" target="_blank">MRKL Systems: A modular, neuro-symbolic architecture that combines large language models, external knowledge sources and discrete reasoning</a></p>
                <p><strong>Paper Abstract:</strong> Huge language models (LMs) have ushered in a new era for AI, serving as a gateway to natural-language-based knowledge tasks. Although an essential element of modern AI, LMs are also inherently limited in a number of ways. We discuss these limitations and how they can be avoided by adopting a systems approach. Conceptualizing the challenge as one that involves knowledge and reasoning in addition to linguistic processing, we define a flexible architecture with multiple neural models, complemented by discrete knowledge and reasoning modules. We describe this neuro-symbolic architecture, dubbed the Modular Reasoning, Knowledge and Language (MRKL, pronounced"miracle") system, some of the technical challenges in implementing it, and Jurassic-X, AI21 Labs' MRKL system implementation.</p>
                <p><strong>Cost:</strong> 0.01</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e4779.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e4779.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details about the agent, the type of memory used, the tasks or benchmarks, performance with and without memory, comparisons, and any reported insights or limitations.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Jurassic-X</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Jurassic-X (AI21 Labs' MRKL system)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A MRKL-style, modular neuro-symbolic system that pairs a large language model (Jurassic-1 backbone) with discrete symbolic/external expert modules and a learned router to extract arguments and invoke tools (e.g., a calculator or external APIs) for precise, up-to-date, or proprietary knowledge and reasoning.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>Jurassic-X</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>A modular neuro-symbolic agent combining a general-purpose large LM (Jurassic-1) as backbone, a learned router (prompt-tuned) that maps natural-language inputs to expert modules, and symbolic/external expert modules (calculator, API connectors, databases). The router is trained to extract discrete arguments for symbolic modules so the LM handles language while experts handle exact computation or dynamic knowledge.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>external knowledge / tool access (retrieval-augmented via APIs and symbolic modules)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_description</strong></td>
                            <td>Implements 'memory' as external modules and knowledge sources: symbolic tools (a precise calculator), API/database connectors for dynamic or proprietary information, and other expert modules. The LM/router retrieves/extracts discrete parameters from text and invokes these external modules; outputs from external modules are used to form final answers.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Verbal arithmetic extraction + exact arithmetic solving (cross-format, cross-digit, multi-operation generalization)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Given natural-language descriptions of arithmetic problems (numbers as digits or words, multiple phrasings/formats, one- or two-operation expressions with/without brackets), extract the correct discrete operands and operators, invoke a symbolic calculator to compute exact answers, and generalize across digits, lexical forms, formats, and operation combinations.</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_name</strong></td>
                            <td>Custom synthetic arithmetic datasets (templated formats spanning 1-9 digit operands, five phrasing formats, 29 two-operation templates)</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>Very high: near-perfect extraction accuracy on single-operation problems (reported >0.99 accuracy on in-distribution single-operation settings). Strong generalization to numbers with 1–9 digits despite training on single-digit examples; two-operation results: in 22 of 29 two-operation templates accuracy exceeded 90%. Prompt-tuned router + calculator yields near-perfect overall system accuracy for many settings.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_with_without_memory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_comparison_summary</strong></td>
                            <td>Comparing Jurassic-X (LM + symbolic calculator/external modules) to LM-only approaches (e.g., GPT-3 without an external calculator) shows a large advantage: Jurassic-X achieves near-perfect extraction and exact arithmetic via the calculator, whereas LM-only approaches degrade dramatically as operand digit-length increases; prompt-tuned routing + tool use far outperforms few-shot LM-only prompting for robust extraction and generalization.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Errors arise primarily from incorrect extraction of arguments by the router (all calculation errors stem from wrong arguments passed to the calculator). Training the router to reliably extract discrete parameters is non-trivial and requires rigorous data augmentation and prompt-tuning. Some failure cases in generalization remain (specific two-operation templates such as add-mul, sub-mul, sub-div showed poor generalization). Division is notably harder to generalize to/from other operations in some experiments. The system requires curated training data for the router and careful evaluation; invoking external/proprietary APIs raises engineering and safety considerations.</td>
                        </tr>
                        <tr>
                            <td><strong>key_insights</strong></td>
                            <td>Using an explicit external symbolic module for exact computation (calculator) and training a router to extract discrete arguments combines the LM's language understanding with symbolic reliability, yielding robust, production-grade performance on tasks LMs alone struggle with (e.g., multi-digit arithmetic). Data augmentation and prompt-tuning of the router are crucial to reach near-perfect extraction; few-shot prompting is insufficient for robust generalization across lexical formats and digit lengths. The modular MRKL design enables extensibility (add experts without retraining large LMs), interpretability (showing which expert produced the result), and access to up-to-date/proprietary information via API connectors.</td>
                        </tr>
                        <tr>
                            <td><strong>additional_notes</strong></td>
                            <td>Experiments used J1-large (7B) with prompt-tuning for the router. Reported aggregate statistics (e.g., >0.99 accuracy, 22/29 templates >90%) come from the paper's experimental summaries rather than explicit full numeric tables in the provided excerpt.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e4779.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e4779.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details about the agent, the type of memory used, the tasks or benchmarks, performance with and without memory, comparisons, and any reported insights or limitations.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>GPT-3 (baseline)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>GPT-3 (Language Models are Few-Shot Learners)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A large pre-trained language model used in the paper as a representative LM-only baseline that does not use external symbolic calculators or dynamic knowledge APIs for arithmetic tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Language Models are Few-Shot Learners</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>GPT-3 (LM-only baseline)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>A general-purpose large LM evaluated in the literature (and cited here) as an approach that attempts to perform arithmetic internally without invoking symbolic tools; used as a representative of LM-only methods.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>none (no external tool/memory access in cited comparisons)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_description</strong></td>
                            <td>No external symbolic calculator or dynamic knowledge access in the baseline comparison; arithmetic is produced by the LM's internal parameters.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Arithmetic solving from natural language (LM-only)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Solve arithmetic problems phrased in natural language (various digit lengths and phrasings) using only the LM's internal learned capabilities, often evaluated in few-shot prompting setups.</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_name</strong></td>
                            <td>Same synthetic arithmetic templates used by Jurassic-X experiments (as reported comparatively)</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td>Reported to degrade dramatically as digit length increases (baseline GPT-3 few-shot performance on multi-digit arithmetic drops substantially compared to the MRKL approach); exact numeric values not provided in excerpt but described as a 'dramatic decrease' relative to the MRKL + calculator approach.</td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_with_without_memory</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>memory_comparison_summary</strong></td>
                            <td>LM-only (GPT-3) attempts to synthesize arithmetic capabilities from pretraining and few-shot examples, but performance falls off sharply with larger numbers of digits; the paper uses GPT-3 as an illustrative baseline to show the advantage of invoking an external symbolic calculator (as done by Jurassic-X). Prompt-tuning the router + tool invocation substantially outperforms the few-shot LM-only approach.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Intrinsic limitations in performing exact, multi-digit arithmetic; tokenization differences cause difficulty generalizing between digits and number-words; few-shot prompting is insufficient for robust extraction across formats and digit lengths.</td>
                        </tr>
                        <tr>
                            <td><strong>key_insights</strong></td>
                            <td>LMs without access to external symbolic modules struggle on tasks requiring exact discrete computation (multi-digit arithmetic), motivating architectures that let LMs handle language and external modules handle precise computation or dynamic knowledge.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Jurassic-1: Technical Details and Evaluation <em>(Rating: 2)</em></li>
                <li>Language Models are Few-Shot Learners <em>(Rating: 2)</em></li>
                <li>Language Models as Knowledge Bases? <em>(Rating: 2)</em></li>
                <li>How Can We Know What Language Models Know? <em>(Rating: 1)</em></li>
                <li>TimeLMs, Diachronic Language Models from Twitter <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-4779",
    "paper_id": "paper-248496374",
    "extraction_schema_id": "extraction-schema-103",
    "extracted_data": [
        {
            "name_short": "Jurassic-X",
            "name_full": "Jurassic-X (AI21 Labs' MRKL system)",
            "brief_description": "A MRKL-style, modular neuro-symbolic system that pairs a large language model (Jurassic-1 backbone) with discrete symbolic/external expert modules and a learned router to extract arguments and invoke tools (e.g., a calculator or external APIs) for precise, up-to-date, or proprietary knowledge and reasoning.",
            "citation_title": "here",
            "mention_or_use": "use",
            "agent_name": "Jurassic-X",
            "agent_description": "A modular neuro-symbolic agent combining a general-purpose large LM (Jurassic-1) as backbone, a learned router (prompt-tuned) that maps natural-language inputs to expert modules, and symbolic/external expert modules (calculator, API connectors, databases). The router is trained to extract discrete arguments for symbolic modules so the LM handles language while experts handle exact computation or dynamic knowledge.",
            "memory_type": "external knowledge / tool access (retrieval-augmented via APIs and symbolic modules)",
            "memory_description": "Implements 'memory' as external modules and knowledge sources: symbolic tools (a precise calculator), API/database connectors for dynamic or proprietary information, and other expert modules. The LM/router retrieves/extracts discrete parameters from text and invokes these external modules; outputs from external modules are used to form final answers.",
            "task_name": "Verbal arithmetic extraction + exact arithmetic solving (cross-format, cross-digit, multi-operation generalization)",
            "task_description": "Given natural-language descriptions of arithmetic problems (numbers as digits or words, multiple phrasings/formats, one- or two-operation expressions with/without brackets), extract the correct discrete operands and operators, invoke a symbolic calculator to compute exact answers, and generalize across digits, lexical forms, formats, and operation combinations.",
            "benchmark_name": "Custom synthetic arithmetic datasets (templated formats spanning 1-9 digit operands, five phrasing formats, 29 two-operation templates)",
            "performance_with_memory": "Very high: near-perfect extraction accuracy on single-operation problems (reported &gt;0.99 accuracy on in-distribution single-operation settings). Strong generalization to numbers with 1–9 digits despite training on single-digit examples; two-operation results: in 22 of 29 two-operation templates accuracy exceeded 90%. Prompt-tuned router + calculator yields near-perfect overall system accuracy for many settings.",
            "performance_without_memory": null,
            "has_performance_with_without_memory": true,
            "memory_comparison_summary": "Comparing Jurassic-X (LM + symbolic calculator/external modules) to LM-only approaches (e.g., GPT-3 without an external calculator) shows a large advantage: Jurassic-X achieves near-perfect extraction and exact arithmetic via the calculator, whereas LM-only approaches degrade dramatically as operand digit-length increases; prompt-tuned routing + tool use far outperforms few-shot LM-only prompting for robust extraction and generalization.",
            "limitations_or_challenges": "Errors arise primarily from incorrect extraction of arguments by the router (all calculation errors stem from wrong arguments passed to the calculator). Training the router to reliably extract discrete parameters is non-trivial and requires rigorous data augmentation and prompt-tuning. Some failure cases in generalization remain (specific two-operation templates such as add-mul, sub-mul, sub-div showed poor generalization). Division is notably harder to generalize to/from other operations in some experiments. The system requires curated training data for the router and careful evaluation; invoking external/proprietary APIs raises engineering and safety considerations.",
            "key_insights": "Using an explicit external symbolic module for exact computation (calculator) and training a router to extract discrete arguments combines the LM's language understanding with symbolic reliability, yielding robust, production-grade performance on tasks LMs alone struggle with (e.g., multi-digit arithmetic). Data augmentation and prompt-tuning of the router are crucial to reach near-perfect extraction; few-shot prompting is insufficient for robust generalization across lexical formats and digit lengths. The modular MRKL design enables extensibility (add experts without retraining large LMs), interpretability (showing which expert produced the result), and access to up-to-date/proprietary information via API connectors.",
            "additional_notes": "Experiments used J1-large (7B) with prompt-tuning for the router. Reported aggregate statistics (e.g., &gt;0.99 accuracy, 22/29 templates &gt;90%) come from the paper's experimental summaries rather than explicit full numeric tables in the provided excerpt.",
            "uuid": "e4779.0"
        },
        {
            "name_short": "GPT-3 (baseline)",
            "name_full": "GPT-3 (Language Models are Few-Shot Learners)",
            "brief_description": "A large pre-trained language model used in the paper as a representative LM-only baseline that does not use external symbolic calculators or dynamic knowledge APIs for arithmetic tasks.",
            "citation_title": "Language Models are Few-Shot Learners",
            "mention_or_use": "mention",
            "agent_name": "GPT-3 (LM-only baseline)",
            "agent_description": "A general-purpose large LM evaluated in the literature (and cited here) as an approach that attempts to perform arithmetic internally without invoking symbolic tools; used as a representative of LM-only methods.",
            "memory_type": "none (no external tool/memory access in cited comparisons)",
            "memory_description": "No external symbolic calculator or dynamic knowledge access in the baseline comparison; arithmetic is produced by the LM's internal parameters.",
            "task_name": "Arithmetic solving from natural language (LM-only)",
            "task_description": "Solve arithmetic problems phrased in natural language (various digit lengths and phrasings) using only the LM's internal learned capabilities, often evaluated in few-shot prompting setups.",
            "benchmark_name": "Same synthetic arithmetic templates used by Jurassic-X experiments (as reported comparatively)",
            "performance_with_memory": null,
            "performance_without_memory": "Reported to degrade dramatically as digit length increases (baseline GPT-3 few-shot performance on multi-digit arithmetic drops substantially compared to the MRKL approach); exact numeric values not provided in excerpt but described as a 'dramatic decrease' relative to the MRKL + calculator approach.",
            "has_performance_with_without_memory": false,
            "memory_comparison_summary": "LM-only (GPT-3) attempts to synthesize arithmetic capabilities from pretraining and few-shot examples, but performance falls off sharply with larger numbers of digits; the paper uses GPT-3 as an illustrative baseline to show the advantage of invoking an external symbolic calculator (as done by Jurassic-X). Prompt-tuning the router + tool invocation substantially outperforms the few-shot LM-only approach.",
            "limitations_or_challenges": "Intrinsic limitations in performing exact, multi-digit arithmetic; tokenization differences cause difficulty generalizing between digits and number-words; few-shot prompting is insufficient for robust extraction across formats and digit lengths.",
            "key_insights": "LMs without access to external symbolic modules struggle on tasks requiring exact discrete computation (multi-digit arithmetic), motivating architectures that let LMs handle language and external modules handle precise computation or dynamic knowledge.",
            "uuid": "e4779.1"
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Jurassic-1: Technical Details and Evaluation",
            "rating": 2
        },
        {
            "paper_title": "Language Models are Few-Shot Learners",
            "rating": 2
        },
        {
            "paper_title": "Language Models as Knowledge Bases?",
            "rating": 2
        },
        {
            "paper_title": "How Can We Know What Language Models Know?",
            "rating": 1
        },
        {
            "paper_title": "TimeLMs, Diachronic Language Models from Twitter",
            "rating": 1
        }
    ],
    "cost": 0.009575,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>MRKL Systems A modular, neuro-symbolic architecture that combines large language models, external knowledge sources and discrete reasoning
May 3, 2022</p>
<p>Ehud Karpas 
AI21 Labs</p>
<p>Omri Abend 
AI21 Labs</p>
<p>Yonatan Belinkov 
AI21 Labs</p>
<p>Barak Lenz 
AI21 Labs</p>
<p>Opher Lieber 
AI21 Labs</p>
<p>Nir Ratner 
AI21 Labs</p>
<p>Yoav Shoham 
AI21 Labs</p>
<p>Hofit Bata 
AI21 Labs</p>
<p>Yoav Levine 
AI21 Labs</p>
<p>Kevin Leyton-Brown 
AI21 Labs</p>
<p>Dor Muhlgay 
AI21 Labs</p>
<p>Noam Rozen 
AI21 Labs</p>
<p>Erez Schwartz 
AI21 Labs</p>
<p>Gal Shachaf 
AI21 Labs</p>
<p>Shai Shalev-Shwartz 
AI21 Labs</p>
<p>Amnon Shashua 
AI21 Labs</p>
<p>Moshe Tenenholtz 
AI21 Labs</p>
<p>MRKL Systems A modular, neuro-symbolic architecture that combines large language models, external knowledge sources and discrete reasoning
May 3, 2022
Huge language models (LMs) have ushered in a new era for AI, serving as a gateway to natural-language-based knowledge tasks. Although an essential element of modern AI, LMs are also inherently limited in a number of ways. We discuss these limitations and how they can be avoided by adopting a systems approach. Conceptualizing the challenge as one that involves knowledge and reasoning in addition to linguistic processing, we define a flexible architecture with multiple neural models, complemented by discrete knowledge and reasoning modules. We describe this neuro-symbolic architecture, dubbed the Modular Reasoning, Knowledge and Language (MRKL, pronounced "miracle") system, some of the technical challenges in implementing it, and Jurassic-X, AI21 Labs' MRKL system implementation.</p>
<p>Introduction</p>
<p>Huge language models (LMs) such as BERT [1], GPT-3 [2], Jurassic-1 [3], PaLM [4], and others [5][6][7][8][9], have taken AI by storm, with the promise of serving as versatile, general-purpose foundations for many applications. Indeed, partly for this reason, they have been rebranded by some as "foundation models" [10]. The term is meant broadly, covering language models as well as models that were trained on more than just text, and although such multimodal models are not the focus of this paper, there's another reason to take the term "language model" with a grain of salt. While LMs indeed model syntax, and other linguistic elements, their most striking feature is that they model the world, as described by the data on which they were trained.</p>
<p>And so really LMs serve as a textual gateway to the universe of knowledge [11,12], and perhaps should instead be called "language and knowledge" models.</p>
<p>When viewed this way, it becomes clear that, despite their value, current LMs have inherent limitations. While versatile and impressive, the output of even huge LMs is in many cases wrong, and often ridiculously so [13]. Here is a sample output of GPT-3 on some simple queries. (To be clear, this is not a critique of GPT-3 specifically, and other LMs -including our own Jurassic-1 -exhibit similar silliness.)</p>
<p>For example, LMs can struggle to understand that there are no US cities with more than 20m citizens, that a math teacher is a person, don't know what today's date is, nor can they engage in even simple (e.g., mathematical) reasoning.</p>
<p>When you look for the root cause, you realize the core limitations of LMs: They don't have access to all relevant knowledge, and neural models are ill-suited for certain types of calculation. More specifically:</p>
<ol>
<li>
<p>Lack of access to current information. Certain data constantly change -the exchange rate between the dollar and the Moroccan Dirham, current COVID numbers, the stock price of AAPL, the weather in Vancouver (OK, not so much), or even the current date. It's impossible, by their design, for pretrained language models to keep up with this dynamic information [14].</p>
</li>
<li>
<p>Lack of access to proprietary information sources. As an important special case of 1, the models don't have access to proprietary information, such as the client roster in a company's database or the state of an online game.</p>
</li>
<li>
<p>Lack of reasoning. Certain reasoning is beyond the reach of the neural approach, and requires a dedicated reasoning process. We saw above the classic example of arithmetic reasoning. GPT-3 and Jurassic-1 perform well on 2-digit addition, which is impressive, but confidently spit out nonsensical answers on 4-digit additions. With increased training time, better data, and larger models, the performance of LMs will improve, but will not reach the robustness of an HP calculator from the 1970s. And mathematical reasoning is just the tip of an iceberg.</p>
</li>
</ol>
<p>In addition to these shortcomings, there is another inherent problem with the traditional approach to deploying LMs: 4. Model explosion. Today's LM's zero-shot performance trails that of fine-tuned models. One can fine-tune the LM to a specific task, but then lose versatility. Contemporary efforts to mitigate the problem focus on training a huge LM jointly on many sets of curated NLP tasks in a massive multi-task setting (several leading studies reaching 100+ tasks) [6,7,15,16]. These formidable efforts are effective; the resulting models exhibit versatility and high performance when encountering inputs resembling those of the curated tasks. But the performance of these models on tasks that are not close enough to those included in the curated tasks can significantly deteriorate (for example, perplexity degrades significantly). It is not practical to fine-tune and serve multiple large models. Nor can one further tune a multi-task-trained LM [6,7,15,16] on a new task that hadn't been covered in its training; due to catastrophic forgetting, adding the new task necessitates retraining on the entire task set. Given the cost of training such models [17][18][19], this is clearly infeasible to do repeatedly.</p>
<p>Despite all these shortcomings, large language models are an essential backbone of any future AI system. So the question is how to have our cake and eat it too, enjoying the benefits of self-supervised deep language models without suffering these drawbacks. The solution we offer takes the form of a flexible architecture dubbed the Modular Reasoning, Knowledge and Language (MRKL, pronounced "miracle") system, whose high-level design is depicted below.</p>
<p>A Thus a MRKL system consists of an extendable set of modules, which we term 'experts', and a router that routes every incoming natural language input to a module that can best respond to the input (the output of that module can be the output of the MRKL system, or be routed to another module). These modules can be:</p>
<p>• Neural, including the general-purpose huge language model as well as other smaller, specialized LMs.</p>
<p>• Symbolic, for example a math calculator, a currency converter or an API call to a database.</p>
<p>MRKL systems enjoy important benefits when compared to fine-tuned multi-task models:</p>
<ol>
<li>
<p>Safe fallback: In case the input doesn't match any existing expert module, the router sends the input directly to the general-purpose huge LM.</p>
</li>
<li>
<p>Robust extensibility: Since each expert is trained independently we are able to cheaply add new capabilities while guaranteeing that they do not compromise the performance of existing ones. The only component that requires retraining is the router which is a relatively lightweight task.</p>
</li>
<li>
<p>Interpretability: When the router invokes a specific module, that often has the side benefit of providing a rationale for the MRKL system's output ("1 + 1 = 2 because the calculator said so"); such explanations are crucially lacking in existing language models.</p>
</li>
<li>
<p>Up-to-date information: The integration of external APIs allows the MRKL system to hook into dynamic knowledge bases, and correctly answer inputs that static models cannot.</p>
</li>
<li>
<p>Proprietary knowledge: Access to proprietary databases and other information sources.</p>
</li>
<li>
<p>Compositionality: By routing compounded multi-hop inputs to different experts we are able to naturally integrate their responses and correctly address complex inputs [20].</p>
</li>
</ol>
<p>2 Jurassic-X: AI21 Labs' MRKL system</p>
<p>We have implemented a MRKL system called Jurassic-X, which is being piloted by a few partners.</p>
<p>Jurassic-X will soon be available to developers; you can apply for early access here.</p>
<p>Meanwhile, you can experience Jurassic-X via a demo (link).</p>
<p>Crossing the neuro-symbolic chasm: A calculator test case</p>
<p>There are of course many details involved in implementing a MRKL system. In connection with avoiding model explosion, see our detailed discussion here. There is also an interesting challenge of how to intelligently route input among modules, which we leave for a separate discussion. Here we discuss one particularly interesting challenge, that of extracting from the text the formal arguments to symbolic reasoners.</p>
<p>Arithmetic as a test case for chasm crossing</p>
<p>The relation between neural and symbolic approaches to AI is guaranteed to raise heated discussions about their relative merits with neuro-skeptics on one extreme, neuro-diehards on the other, and the rest trying to have a rational conversation. Before discussing our technical approach we'd like to clarify our guiding ideology. We believe that neural LMs are essential; we didn't build Jurassic-1 [3] for no reason, and it serves as a backbone to our applications as well as those of developers using AI21 Studio. But as we've made clear, we also believe they have inherent shortcomings. We don't take a firm position on which types of computation are best relegated to the neural machinery, and which should be carved out to symbolic methods. That will surely be an evolving process. What we do firmly believe is that some tasks should be handled by discrete methods, and we should have a clear methodology for how to hand off the computation from the neural net to the symbolic procedure.</p>
<p>Once the router has made the decision of which module to call upon, it needs to pass the right information to it. The router is a specialized neural net and therefore invoking a neural module is easy since the neural-to-neural interface is natural. However, when a neural network needs to access a database, make an API call, or invoke another symbolic computation, it must extract from the text discrete parameters required by the module. The main message here is that there is no free lunch, but that lunch is in many cases affordable. The cost is in training the router to extract the arguments reliably, which must be done rigorously. We make the point by discussing how we trained Jurassic-X to extract basic arithmetic operations.</p>
<p>There are many ways to describe in language a situation that calls for performing arithmetic. The most straightforward way is to use mathematical notation, say "3 − 1 =? . Google search handles it well:</p>
<p>Not much harder is to express it in words, as in "How much is three minus 1". Google search does this well too:</p>
<p>But then it gets tricky. At the lexical level, one may use different synonyms that carry the same meaning: ("twelve", "12" and "a dozen"). But beyond simple lexical issues, there are phrases that require world knowledge to understand that there is an arithmetic exercise encoded in the text ("I lost one ball", "I dropped one ball", "One ball was taken from me") and what the specific exercise is. Here Google search starts to stumble: This is where language models come in. Note that we limit their role to extracting the right arguments for the symbolic calculator, not performing the calculation itself.</p>
<p>But we should approach even this task with sober expectations. As anyone knows from elementary school, it's harder to teach children to solve verbal math problems than to solve explicitly stated math problems. It's harder for adults too, and it's no different for the computer. At some point the machine will stumble (indeed, at some point humans will disagree about the underlying math problem). But when we decide to invoke a symbolic method we should expect reasonable robustness.</p>
<p>The solution is to train the router to extract the right input independently for each module, with rigorous evaluation of the performance. By way of example, here is how it was achieved simple, one-and two-operation arithmetics.</p>
<p>Training Jurassic-X to extract the arguments for basic arithmetic</p>
<p>Our goal here is not to show how we can extract the most complex mathematical expressions from text, but how we can extract simple expressions with high reliability, the sort of reliability one would need in a production-grade system. We found that while extensive pretraining does allow Jurassic-1 to extract the arithmetic operation in many cases in a few-shot setting, the performance is far from perfect. See Appendix A for a detailed comparison. Using a data augmentation methodology, based on generating examples from a structured example space, we show that the static pretrained LM can be made to achieve near perfect performance. We empirically investigate two related research questions:</p>
<ol>
<li>
<p>What is required in terms of data augmentation to achieve near-perfect performance in the case of basic mathematical operations?</p>
</li>
<li>
<p>How well can Jurassic-X generalize between math problems that vary in type or complexity?</p>
</li>
</ol>
<p>To answer these questions we evaluate the model's performance on cases where the test data is drawn from the same distribution as the training data, as well as on out-of-distribution test data (allowing us, for example, to train a model on addition problems and test it on multiplication problems).</p>
<p>Data Augmentation</p>
<p>We use a small set of templates to generate a set of training and test examples. Each example is characterized by the following dimensions:</p>
<ol>
<li>
<p>The numbers used in the arithmetic expression, henceforth the operands. The operands may be digits (e.g., 48) or numbers in word form (e.g., forty eight).</p>
</li>
<li>
<p>The number of digits in the operands. We explore numbers of 1-9 digits.</p>
</li>
<li>
<p>The type of operation. We explore addition, subtraction, multiplication and division.</p>
</li>
<li>
<p>The number of operations in the arithmetic expression. We explore the cases of one and two operations. 5. The placement or absence of brackets (in expressions with two operations). In some expressions the placement of brackets may change the result. We explore all logical possibilities for the case of two operations. Table 10 in the appendix details the templates we use in this set of experiments for the case of a single operation. In the case of two operations, there are 29 distinct combinations that have a natural formulation in natural language (see Table 12). The data can be found here.</p>
</li>
</ol>
<p>Experimental setup</p>
<p>We conducted our experiments with the 7B parameters J1-large model [3] using prompt-tuning [21] with 10 prompt tokens. Across all experiments, we set our learning rate to be lr = 0.3 and used linear decay. The batch size was set to 32 and we defined a short warm-up depending on the number of steps in each experiment.</p>
<p>Experiments 1 and 2 below were trained for 3000 steps, and the reported results here were the test accuracy evaluated on the final model. For the remaining experiments we used linear weight decay (0.001), which we found to be crucial for the model's performance, and selected the best checkpoint using a validation set. Each experiment was run 3-5 times, and results show mean ± standard deviation across these runs.</p>
<p>In all experiments we verified that there was no overlap between the problems included in the training set and those included in the test set. This also includes avoiding cases with the same underlying arithmetic expression, but using different wordings for training and testing. For a detailed description of the sizes of the data splits see Section C.</p>
<p>Results</p>
<p>In the following results we report the accuracy we achieve in different experiments, by which we mean the percent of problems in the relevant test set on which the system gave the correct answer. (We note again that, since the actual calculation is done by the calculator module, all errors are due to passing the wrong operations or operands to the calculator.) Experiment 1: Generalization across different number of digits in the operands. Inspired by the experiments reported by [2], we test Jurassic-X's ability to generalize to numbers it has not seen in the training data, including numbers with a different (and much larger) number of digits. At training time we expose the model only to single-digit numbers, while at test time we evaluate on numbers with 1 to 9 digits. In this section we experiment with simple problems, involving only numbers written as digits (and not numbers as words), one format (format 0 from Table 10), and a single operation. We explore two settings: one where that operation is addition, and one where it is multiplication. Table 1 presents our results, sliced by the number of digits, and compared to the results by GPT-3's approach [2] (as representative of all language models that don't have access to external calculator), reported on addition. We note that we trained on single-digit operations for all settings while GPT-3 was conditioned on examples with the same number of digits when answering a certain problem. Our results show that despite the fact that training was only done on numbers with a single digit, the model is able to generalize to all numbers of digits explored. This is in stark contrast to the approach of language models which attempt to synthesize arithmetic capabilities from the training data, and as a result display a dramatic decrease in performance as the number of digits increases.  Experiment 2: Generalization from digits to numbers as words and vice versa. In this set of experiments, we test the model's ability to generalize from arithmetic questions with digits to ones where the numbers are expressed with words, and vice versa. We note that this task is not trivial considering the fact that the tokenization of a number represented with digits is different than that when the same number is represented as words. For example, we train the model with examples such as "How much is 58 plus 12" and evaluate it on examples such as "How much is twenty seven plus thirteen", and vice versa. While we vary the lexical choice for specifying numbers using words or digits, we hold other dimensions of the arithmetic world fixed, including using only format 0 and holding the type of operation fixed at training and test time. (In the following paragraphs we examine these other dimensions.) Table 2 shows the accuracy for all combinations of training and testing on digits and on words. We notice that in-distribution performance (training and testing on the same type of input) is close to 100 % accuracy. We further observe that training on words generalizes well to digits. Interestingly, the inverse is not true and the performance is much lower, indicating the underlying difference in the representations of the numbers.  </p>
<p>Test</p>
<p>Experiment 3: Generalization across question formats.</p>
<p>A main challenge in constructing natural language interfaces to discrete reasoners like a calculator is in handling language variability. One of the most appealing characteristics of language models is their ability to abstract away from such variability. Here we test the ability of the model to generalize over formats of arithmetic problems. Experiments are for single-operation problems. We train on a single format (format 0 in Table 10), test on all formats, and break the results by format. We report results with all four operation types. Table  3 shows that the generalization across formats is perfect in most cases. Format 4, which is the only one not phrased as a question (see Table 10) appears to be the most challenging to generalize to. We note that there are numerous ways to phrase such questions, hence the ability to generalize across formats, even for the case where the model was trained only on one format, is critical for the model's success.  and evaluating on each of the 5 formats from Table 10.</p>
<p>Experiment 4: Generalization between operations. Next we explore whether a model that was trained on one type of arithmetic problems can generalize to other types. We conduct two types of experiments: one where we examine the generalization ability of Jurassic-X on single operation problems, and one with twooperation problems.</p>
<p>For the first set of experiments, we train with one operation at a time, using all formats with numbers as digits. Operands have between 1 and 9 digits. We test on all types of single-operation problems. The results are shown in in Table 4. Consistent with the previous experiments, training and evaluating on arithmetic problems with the same operations is consistently successful (accuracy &gt; 0.99 along the diagonal). Interestingly, we find strong generalization in many cross-operation cases (off the main diagonal in the table). For example, training on addition works almost perfectly when evaluated on subtraction and multiplication. The division operation is an exception, as models trained on it struggle with multiplication and subtraction (but perform reasonably on addition). Conversely, models trained on other operations do not generalize very well to division.  For the second set of experiments, we randomly partition the 29 possible twooperation arithmetic problems (Tables 11, 12) into subsets of 14 and 15 to be used for training and testing, respectively. We repeated this process for 10 random splits of the operations, assuring that only one of the training two-operation problems would include brackets. Other settings are as with the first set of experiments. Table 5 shows the average accuracy for each of the 29 types of two-operation problems. The results show that in 22 of the 29 combinations the accuracy exceeds 90%, indicating reasonable generalization capabilities for such a setting.</p>
<p>Experiment 5: Generalization across a different number of operations.</p>
<p>This final set of experiments explores the ability of the model to generalize from single-operation problems to two-operation problems.</p>
<p>As above, we use all formats (0-4), with operands of 1 to 9 digits (numbers written with digits), and train on examples from all four operation types (singleoperation problems only). We evaluate on examples with two operations, focusing on the situations that do not require bracketing -16 unique combinations in total. The results are shown in Table 6 and are organized by the first operation (rows) and second operation (columns) in the test problems.  In almost all cases, we observe excellent performance on solving two-operation problems, despite seeing only single-operation problems at training time. This result is also important for the systematic development of the capability since the number of possible formulae grows rapidly with the number of operations, rendering an exhaustive training of all combinations extremely challenging for multi-operation formulae. There are three exceptions of failure to generalize to two-operation problems: add-mul, sub-mul, and sub-div. In these three cases, the templates are of the form of two prefix phrasings (e.g., "what is the sum of 2 and the product of 4 and 8"), while other templates are relatively simpler (Table 12). However, we obtain pretty good performance on add-div, despite it having a similar template.  Table 6: Generalization from one operation to two operations. Accuracy when training on single-operation problems and testing on two-operation problems, presented for all operation pairs.</p>
<p>Discussion</p>
<p>This paper introduces the concept of Modular Reasoning, Knowledge and Language (MRKL) systems, which embraces large language models (LMs) and augments them with an easily extensible set of external knowledge and reasoning modules. This flexible, neuro-symbolic design retains all the advantages of modern LMs, but avoids their limitations: a lack of current and/or proprietary information, and an inability to reason symbolically when needed. We discussed some of the technical challenges in implementing a MRKL system, with a special focus on how to cross the neurosymbolic divide, which we did by looking at how Jurassic-X -AI21 Labs' implementation of a MRKL system -was trained to handle basic arithmetic reliably.</p>
<p>A Few-shot vs. prompt tuning</p>
<p>Performing these experiments in a few-shot setting might be a more natural choice that requires less effort in training these models. However, as the analysis below reveals, the performance of this approach is limited, demonstrating the need to follow a systematic approach.</p>
<p>Set up: In the few-shot experiments, 10 examples were drawn from the training sets and used as a prompt for the model. The performance was evaluated on the same test set for both the few-shot and the prompt-tuning approaches.</p>
<p>Changing the number of digits: Both methods easily generalize to varying the number of digits (see Table 7).</p>
<p>Num. digits  Writing the operands in words instead of digits: A clear difference appears as the few-shot approach is unable to handle this task and the performance greatly decreases with the number of digits (see Table 8).</p>
<p>Num. digits  </p>
<p>Different question formats:</p>
<p>We explored the ability to generalize to different question formats when training on one format (format 0). We note the generalization is much lower compared to following our prompt-tuning method (Table 9).    The equations for two-operation problems, for all combinations of placing the brackets, are shown in Table 11. Table 12 shows the phrasings for these 29 formulae.</p>
<p>Num. digits</p>
<p>B Question formats</p>
<p>C Amount of data in each experiment</p>
<p>Experiment 1 -number of digits: The training set included 40 single digits operand combinations. The test set for single digits included the remaining 41 combinations (discarding 0) and 50 randomly chosen combinations for all the cases with more then 1 digit. Experiment 2 -digits and words: 200 samples were randomly drawn for each number of digits (except for 1 and 2 digits) and data was split equally between train and test data. This was repeated for both digits and words. Experiment 3 -question formats:</p>
<p>The train set included 400 samples with format 0 and the dev and test set each included 200 samples from each format, randomly drawn with number of digits ranging between 1 and 9. Experiment 4 -generalization across operations: The train set included 635 samples across all formats and digits for each operation, while the dev and test set each included 315 samples for each operation. For the two-operation experiment we drew 120 samples for each of the 29 formats, which were divided equally between the train, dev and test sets.  Table 11: Two-operation formulae. All combinations of two-operation formulae, including operator precedence where relevant. See Table 12 for the phrasings corresponding to these formulae.</p>
<p>700 samples with a single operation were used for training the model, drawn randomly from all operations, formats, and number of digits. The dev and test set each included 210 samples drawn randomly for each of the 16 combinations of two operation formulas, analyzed up to 7 digits.</p>
<p>Experiment 5 -generalization across the number of operations:</p>
<p>Table 1 :
1Robustness to the number of digits in the operands. Accuracy vs. thenumber of digits in the test data for a model that was trained only on 1-digit operands 
(5 + 3, etc.). Results for GPT-3 were taken from [2]. </p>
<p>Table 2 :
2Robustness to wordings. Accuracy for all combination of training and testing on numbers written as digits and as words. Results are averaged across all the numbers of digits.</p>
<p>Table 3 :
3Robustness to phrasing. Accuracy when training with one format (format 0)</p>
<p>Table 4 :
4Generalization across operations for single-operation problems. Accuracy when training with one operation and evaluating on other operations.</p>
<p>Table 5 :
5Generalization for two-operation problems. Mean and standard deviation across 10 partitions of the formulae to train and test.</p>
<p>Table 7 :
7Number of digits: few-shot vs. prompt tuning. Results shown for addition.</p>
<p>Table 8 :
8Number of digits: few-shot vs. prompt tuning, when numbers are written as words. Results are shown for addition.</p>
<p>Table 9 :
9Generalization across formats: few-shot vs. prompt tuning. Results are shown for addition.</p>
<p>Table 10
10shows the five formats used for single-operation problems for all operations. What is the result of {x} times {y}? What is the result of {x} over {y}? 3 What is the product of {x} and {y}? What is the ratio between {x} and {y}? 4 The product of {x} and {y} is The ratio of {x} and {y} isFormat 
addition 
subtraction 
0 
How much is {x} plus {y}? 
How much is {x} minus {y}? 
1 
What is {x} plus {y}? 
What is {x} minus {y}? 
2 
What is the result of {x} plus {y}? 
What is the result of {x} minus {y}? 
3 
What is the sum of {x} and {y}? 
What is the difference between {x} and {y}? 
4 
The sum of {x} and {y} is 
The difference between {x} and {y} is </p>
<p>multiplication 
division 
0 
How much is {x} times {y}? 
How much is {x} over {y}? 
1 
What is {x} times {y}? 
What is {x} over {y}? 
2 </p>
<p>Table 10 :
10Question formats for single-operation problems. Five different formats for each type of operation in the case of single-operation expressions.
FormulaFormat f=((A+B)<em>C) Sum A and B and multiply by C f=(A+B</em>C)What is the sum of A and the product of B and C? f=((A-B)<em>C)What is the product of A minus B and C? f=(A/(B/C)) How much is A divided by the ratio between B and C? f=(A-B</em>C) What is the difference between A and the product of B and C? f=(A<em>(B-C)) How much is A times the difference between B and C? f=((A+B)/C) What is the ratio between A plus B and C?How much is A minus the diffrence between B and C? f=((A-B)/C) What is the ratio between A minus B and C? f=(A-B/C) What is the difference between A and the ratio between B and C? f=(A/(B+C)) How much is A divided bu the sum of B and C?How much is A divided by the difference between B and C? f=(A+B/C) what is the sum of A and the ratio between B and C? f=(A</em>(B/C)) How much is A times the ratio between B and C?f=(A<em>B+C) How much is the sum of A times B and C? f=(A</em>(B+C)) How much is A times the sum of B and C? f=(A/B+C) How much is the sum of A divided by B and C? f=(A/B/C) How much is A divided by B divided by C? f=(A/B-C)How much is the difference between A divided by B and C? f=(A/B<em>C)How much is A divided by B times C? f=(A-(B+C)) How much is A minus the sum of B and C? f=(A</em>B-C) How much is the difference between A times B and C? f=(A/(B<em>C)) How much is A divided by the product of B and C? f=(A-B+C) How much is A minus B plus C? f=(A+B+C) How much is A plus B plus C? f=(A-B-C) How much is A minus B minus C? f=(A</em>B/C) How much is A times B divided by C? f=(A+B-C) How much is A plus B minus C? f=(A<em>B</em>C) How much is A times B times C?Table 12: Formats of two-operation questions.
J Devlin, M.-W Chang, K Lee, K Toutanova, Bert, Pre-training of Deep Bidirectional Transformers for Language Understanding in Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies. Minneapolis, MinnesotaAssociation for Computational Linguistics1Devlin, J., Chang, M.-W., Lee, K. &amp; Toutanova, K. BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding in Proceedings of the 2019 Conference of the North American Chapter of the Association for Compu- tational Linguistics: Human Language Technologies, Volume 1 (Long and Short Papers) (Association for Computational Linguistics, Minneapolis, Minnesota, June 2019), 4171-4186. https://aclanthology.org/N19-1423.</p>
<p>Language Models are Few-Shot Learners. T B Brown, Brown, T. B. et al. Language Models are Few-Shot Learners 2020. https : //arxiv.org/abs/2005.14165.</p>
<p>Jurassic-1: Technical Details and Evaluation. O Lieber, O Sharir, B Lenz, Y Shoham, Lieber, O., Sharir, O., Lenz, B. &amp; Shoham, Y. Jurassic-1: Technical Details and Evaluation 2021. https://uploads-ssl.webflow.com/60fd4503684b466578c0d307/ 61138924626a6981ee09caf6_jurassic_tech_paper.pdf.</p>
<p>PaLM: Scaling Language Modeling with Pathways 2022. A Chowdhery, Chowdhery, A. et al. PaLM: Scaling Language Modeling with Pathways 2022. https://arxiv.org/abs/2204.02311.</p>
<p>Exploring the Limits of Transfer Learning with a Unified Textto-Text Transformer. C Raffel, Journal of Machine Learning Research. 21Raffel, C. et al. Exploring the Limits of Transfer Learning with a Unified Text- to-Text Transformer. Journal of Machine Learning Research 21, 1-67. http: //jmlr.org/papers/v21/20-074.html (2020).</p>
<p>Multitask Prompted Training Enables Zero-Shot Task Generaliza. V Sanh, International Conference on Learning Representations. Sanh, V. et al. Multitask Prompted Training Enables Zero-Shot Task Generaliza- tion in International Conference on Learning Representations (2022). https: //openreview.net/forum?id=9Vrb9D0WI4.</p>
<p>V Aribandi, Towards Extreme Multi-Task Scaling for Transfer Learning in International Conference on Learning Representations. Aribandi, V. et al. ExT5: Towards Extreme Multi-Task Scaling for Transfer Learning in International Conference on Learning Representations (2022). https: //openreview.net/forum?id=Vzh1BFUCiIX.</p>
<p>Y Liu, A Robustly Optimized BERT Pretraining Approach. Liu, Y. et al. RoBERTa: A Robustly Optimized BERT Pretraining Approach 2019. https://arxiv.org/abs/1907.11692.</p>
<p>Using DeepSpeed and Megatron to Train Megatron-Turing NLG 530B, A Large-Scale Generative Language Model 2022. S Smith, Smith, S. et al. Using DeepSpeed and Megatron to Train Megatron-Turing NLG 530B, A Large-Scale Generative Language Model 2022. https://arxiv.org/ abs/2201.11990.</p>
<p>On the Opportunities and Risks of Foundation Models. R Bommasani, Bommasani, R. et al. On the Opportunities and Risks of Foundation Models 2021. https://arxiv.org/abs/2108.07258.</p>
<p>Language Models as Knowledge Bases?. F Petroni, Petroni, F. et al. Language Models as Knowledge Bases? 2019. https://arxiv. org/abs/1909.01066.</p>
<p>How Can We Know What Language Models Know?. Z Jiang, F F Xu, J Araki, G Neubig, Jiang, Z., Xu, F. F., Araki, J. &amp; Neubig, G. How Can We Know What Language Models Know? 2019. https://arxiv.org/abs/1911.12543.</p>
<p>Understanding the Capabilities, Limitations, and Societal Impact of Large Language Models. A Tamkin, M Brundage, J Clark, D Ganguli, Tamkin, A., Brundage, M., Clark, J. &amp; Ganguli, D. Understanding the Ca- pabilities, Limitations, and Societal Impact of Large Language Models 2021. https://arxiv.org/abs/2102.02503.</p>
<p>D Loureiro, F Barbieri, L Neves, L E Anke, J Camacho-Collados, Timelms, Diachronic Language Models from Twitter 2022. Loureiro, D., Barbieri, F., Neves, L., Anke, L. E. &amp; Camacho-Collados, J. TimeLMs: Diachronic Language Models from Twitter 2022. https://arxiv. org/abs/2202.03829.</p>
<p>Finetuned Language Models Are Zero-Shot Learners. J Wei, Wei, J. et al. Finetuned Language Models Are Zero-Shot Learners 2021. https: //arxiv.org/abs/2109.01652.</p>
<p>S Min, M Lewis, L Zettlemoyer, H Hajishirzi, Metaicl, Learning to Learn In Context 2021. Min, S., Lewis, M., Zettlemoyer, L. &amp; Hajishirzi, H. MetaICL: Learning to Learn In Context 2021. https://arxiv.org/abs/2110.15943.</p>
<p>The Cost of Training NLP Models: A Concise Overview 2020. O Sharir, B Peleg, Y Shoham, Sharir, O., Peleg, B. &amp; Shoham, Y. The Cost of Training NLP Models: A Concise Overview 2020. https://arxiv.org/abs/2004.08900.</p>
<p>Sustainable AI: Environmental Implications, Challenges and Opportunities. C.-J Wu, Wu, C.-J. et al. Sustainable AI: Environmental Implications, Challenges and Opportunities 2021. https://arxiv.org/abs/2111.00364.</p>
<p>Energy and Policy Considerations for Deep Learning. E Strubell, A Ganesh, A Mccallum, NLP in Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics (Association for Computational Linguistics. Florence, ItalyStrubell, E., Ganesh, A. &amp; McCallum, A. Energy and Policy Considerations for Deep Learning in NLP in Proceedings of the 57th Annual Meeting of the Asso- ciation for Computational Linguistics (Association for Computational Linguis- tics, Florence, Italy, July 2019), 3645-3650. https://aclanthology.org/P19- 1355.</p>
<p>Break It Down: A Question Understanding Benchmark 2020. T Wolfson, Wolfson, T. et al. Break It Down: A Question Understanding Benchmark 2020. https://arxiv.org/abs/2001.11770.</p>
<p>The Power of Scale for Parameter-Efficient Prompt Tuning. B Lester, R Al-Rfou, N Constant, Lester, B., Al-Rfou, R. &amp; Constant, N. The Power of Scale for Parameter- Efficient Prompt Tuning 2021. https://arxiv.org/abs/2104.08691.</p>            </div>
        </div>

    </div>
</body>
</html>