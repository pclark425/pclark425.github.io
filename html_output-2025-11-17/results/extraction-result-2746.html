<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-2746 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-2746</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-2746</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-70.html">extraction-schema-70</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve text games, including details about the memory architecture, performance comparisons, and what makes memory effective or ineffective.</div>
                <p><strong>Paper ID:</strong> paper-f48ae425e2567be2d993efcaaf74c2274fc9d7c5</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/f48ae425e2567be2d993efcaaf74c2274fc9d7c5" target="_blank">COMET: Commonsense Transformers for Automatic Knowledge Graph Construction</a></p>
                <p><strong>Paper Venue:</strong> Annual Meeting of the Association for Computational Linguistics</p>
                <p><strong>Paper TL;DR:</strong> This investigation reveals promising results when implicit knowledge from deep pre-trained language models is transferred to generate explicit knowledge in commonsense knowledge graphs, and suggests that using generative commonsense models for automatic commonsense KB completion could soon be a plausible alternative to extractive methods.</p>
                <p><strong>Paper Abstract:</strong> We present the first comprehensive study on automatic knowledge base construction for two prevalent commonsense knowledge graphs: ATOMIC (Sap et al., 2019) and ConceptNet (Speer et al., 2017). Contrary to many conventional KBs that store knowledge with canonical templates, commonsense KBs only store loosely structured open-text descriptions of knowledge. We posit that an important step toward automatic commonsense completion is the development of generative models of commonsense knowledge, and propose COMmonsEnse Transformers (COMET) that learn to generate rich and diverse commonsense descriptions in natural language. Despite the challenges of commonsense modeling, our investigation reveals promising results when implicit knowledge from deep pre-trained language models is transferred to generate explicit knowledge in commonsense knowledge graphs. Empirical results demonstrate that COMET is able to generate novel knowledge that humans rate as high quality, with up to 77.5% (ATOMIC) and 91.7% (ConceptNet) precision at top 1, which approaches human performance for these resources. Our findings suggest that using generative commonsense models for automatic commonsense KB completion could soon be a plausible alternative to extractive methods.</p>
                <p><strong>Cost:</strong> 0.005</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <p class="empty-note">No extracted data.</p>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <p class="empty-note">No potentially relevant new papers extracted.</p>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-2746",
    "paper_id": "paper-f48ae425e2567be2d993efcaaf74c2274fc9d7c5",
    "extraction_schema_id": "extraction-schema-70",
    "extracted_data": [],
    "potentially_relevant_new_papers": [],
    "cost": 0.00476925,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>COMET@: Commonsense Transformers for Automatic Knowledge Graph Construction</h1>
<p>Antoine Bosselut ${ }^{\text {® }}$ Hannah Rashkin ${ }^{\text {® }}$ Maarten Sap ${ }^{\text {® }}$ Chaitanya Malaviya ${ }^{\text {® }}$ Asli Celikyilmaz ${ }^{\text {® }}$ Yejin Choi ${ }^{\circ}$<br>${ }^{\text {® }}$ Allen Institute for Artificial Intelligence, Seattle, WA, USA<br>${ }^{ \star}$ Paul G. Allen School of Computer Science \&amp; Engineering, Seattle, WA, USA<br>${ }^{ \star}$ Microsoft Research, Redmond, WA, USA</p>
<h4>Abstract</h4>
<p>We present the first comprehensive study on automatic knowledge base construction for two prevalent commonsense knowledge graphs: Atomic (Sap et al., 2019) and ConceptNet (Speer et al., 2017). Contrary to many conventional KBs that store knowledge with canonical templates, commonsense KBs only store loosely structured open-text descriptions of knowledge. We posit that an important step toward automatic commonsense completion is the development of generative models of commonsense knowledge, and propose COMmonsEnse Transformers (COMET@) that learn to generate rich and diverse commonsense descriptions in natural language. Despite the challenges of commonsense modeling, our investigation reveals promising results when implicit knowledge from deep pre-trained language models is transferred to generate explicit knowledge in commonsense knowledge graphs. Empirical results demonstrate that COMET is able to generate novel knowledge that humans rate as high quality, with up to $77.5 \%$ (ATOMIC) and $91.7 \%$ (ConceptNet) precision at top 1, which approaches human performance for these resources. Our findings suggest that using generative commonsense models for automatic commonsense KB completion could soon be a plausible alternative to extractive methods.</p>
<h2>1 Introduction</h2>
<p>When reading text, humans make commonsense inferences that frame their understanding of the narrative being presented. For machines to achieve this capability, they must be able to acquire relevant and correct commonsense for an unbounded set of situations. In this work, we cast commonsense acquisition as knowledge base construction and investigate whether large-scale language models can effectively learn to generate the knowledge
<img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: COMET@ learns from an existing knowledge base (solid lines) to be able to generate novel nodes and edges (dashed lines).
necessary to automatically construct a commonsense knowledge base (KB).</p>
<p>Automatic KB construction is a long-standing goal of artificial intelligence research due to the difficulty of achieving high concept coverage in high-precision curated KBs (Lenat, 1995; Miller, 1995). Previous work has developed models capable of reading and extracting semi-structured text (Suchanek et al., 2007; Hoffart et al., 2013; Auer et al., 2007; Bollacker et al., 2008) and unstructured text (Dong et al., 2014; Carlson et al., 2010; Nakashole et al., 2011, 2012; Niu, 2012) into relational schemas that can be queried for downstream applications. A common thread of these approaches, however, is the focus on encyclopedic knowledge, which lends itself to a well-defined space of entities and relations that can be modeled.</p>
<p>Commonsense knowledge, however, does not cleanly fit into a schema comparing two entities with a known relation, leading current approaches</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: Model diagram. (a) In the multi-headed attention module, the key, value, and query all pass through a head-specific projection before a scaled dot-product attention is computed between them. The outputs of the heads are concatenated and projected. (b) Inside the transformer block, the outputs of all the previous layer blocks from earlier time steps are input to the multi-headed attention with the preceding block for the current time step as the query. (c) Each token is an input to a first-layer block along with all preceding tokens. Dotted lines indicate outputs to all future blocks in the next layer and inputs from all preceding blocks in the previous layer.</p>
<p>to model "entities" as natural language phrases and relations as any concept that can link them (Li et al., 2016; Sap et al., 2019). OpenIE approaches display this property of open text entities and relations (Etzioni et al., 2011; Fader et al., 2011; Mausam et al., 2012), but being extractive, they only capture knowledge that is explicitly mentioned in text, limiting their applicability for capturing commonsense knowledge, which is often implicit (Gordon and Van Durme, 2013).</p>
<p>Meanwhile, recent progress in training deep contextualized language models (Peters et al., 2018; Radford et al., 2018; Devlin et al., 2018) provides an opportunity to explore beyond extractive methods as an avenue for commonsense KB construction. These large-scale language models display impressive performance when their underlying representations are tuned to solve end tasks, achieving state-of-the-art results on a variety of complex problems. In this work, we define the <em>COMmonxEnse Transformer</em> (COMET), which constructs commonsense KBs by using existing tuples as a seed set of knowledge on which to train. Using this seed set, a pre-trained language model learns to adapt its learned representations to knowledge generation, and produces novel tuples that are high quality.</p>
<p>We summarize our contributions in this work as follows. First, we develop a generative approach to knowledge base construction. A model must learn to produce new nodes and identify edges between existing nodes by generating phrases that coherently complete an existing seed phrase and relation type<sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup>. Second, we develop a framework for using large-scale transformer language models to learn to produce commonsense knowledge tuples<sup id="fnref:2"><a class="footnote-ref" href="#fn:2">2</a></sup>. Finally, we perform an empirical study on the quality, novelty, and diversity of the commonsense knowledge produced by our approach for two domains, ATOMIC and ConceptNet, as well as an efficiency study on the number of seed tuples needed to learn an effective knowledge model. The results indicate that COMET is able to produce high quality tuples as human judges find that 77.5% of generated tuples for ATOMIC events and 91.7% of generated tuples for ConceptNet relations are correct.</p>
<h2>2 Learning to Generate Commonsense</h2>
<p>COMET is an adaptation framework for constructing commonsense knowledge bases from language models by training the language model on a seed set of knowledge tuples. These tuples provide COMET with the KB structure and relations that must be learned, and COMET learns to adapt the language model representations learned from pretraining to add novel nodes and edges to the seed knowledge graph.</p>
<h3>2.1 Task</h3>
<p>More specifically, the problem assumes $\operatorname{COMET}$ is given a training knowledge base of natural language tuples in ${s, r, o}$ format, where $s$ is the phrase subject of the tuple, $r$ is the relation of the tuple, and $o$ is the phrase object of the tuple. For example, a ConceptNet tuple relating to "taking a nap" would be: ( $s=$ "take a nap", $r=$ Causes, $o=$ "have energy"). The task is to generate $o$ given $s$ and $r$ as inputs.</p>
<p>Notation We define $X^{s}=\left{x_{0}^{s}, \ldots, x_{|s|}^{s}\right}$ as the tokens that make up the subject of the relation, $X^{r}=\left{x_{0}^{r}, \ldots, x_{|r|}^{r}\right}$ as the tokens that make up the relation of the tuple, and $X^{o}=\left{x_{0}^{o}, \ldots, x_{|o|}^{o}\right}$ as the tokens that make up the object of the tuple. The embedding for any word $x$ is denoted as $e$.</p>
<h3>2.2 Transformer Language Model</h3>
<p>While COMET is agnostic to the language model with which it is initialized, in this work, we use the transformer language model architecture introduced in Radford et al. (2018) (GPT), which uses multiple transformer blocks of multi-headed scaled dot product attention and fully connected layers to encode input text (Vaswani et al., 2017). Figure 2 depicts different components of the GPT architecture and we define each component in more depth below.</p>
<p>Transformer Block As shown in Figure 2(b), each transformer layer $l$ contains an architecturally identical transformer block (though with unique trainable parameters) that applies the following transformations to the input to the block:</p>
<p>$$
\begin{aligned}
&amp; \hat{g}^{l}=\operatorname{MultiAtTN}\left(h^{l-1}\right) \
&amp; g^{l}=\operatorname{LAYER} \operatorname{NORM}\left(\hat{g}^{l}+h^{l-1}\right) \
&amp; \hat{h}^{l}=\operatorname{FFN}\left(g^{l}\right) \
&amp; h^{l}=\operatorname{LAYER} \operatorname{NORM}\left(\hat{h}^{l}+g^{l}\right)
\end{aligned}
$$</p>
<p>where MultiAttn is a multi-headed selfattention mechanism (defined below), FFN is a two-layer feed-forward network, and LAYERNORM represents a layer normalization (Ba et al., 2016) operation that is applied to the output of the self-attention and the feedforward network. Note that the inputs to the LAYERNORM operations contain a residual connection that sums the output of and input to the previous operation.</p>
<p>Multi-headed Attention The multi-headed attention module of each transformer block, shown in Figure 2(a), is identical to the one originally defined by Vaswani et al. (2017). The attention function receives three inputs, a query $Q$, key $K$, and value $V$. The attention is made of multiple heads that each compute a unique scaled dot product attention distribution over $V$ using $Q$ and $K$ :</p>
<p>$$
\operatorname{Attention}(Q, K, V)=\operatorname{softmax}\left(\frac{Q K^{T}}{\sqrt{d_{k}}}\right) V
$$</p>
<p>where $d_{k}$ is the dimensionality of the input vectors representing the query, key and value. For each of the heads, $Q, K$, and $V$ are uniquely projected prior to the attention being computed:</p>
<p>$$
H_{i}=\operatorname{Attention}\left(Q W_{i}^{Q}, K W_{i}^{K}, V W_{i}^{V}\right)
$$</p>
<p>where $H_{i}$ is the output of a single attention head and $W_{i}^{Q}, W_{i}^{K}$, and $W_{i}^{V}$ are head-specific projections for $Q, K$, and $V$, respectively. The outputs of the attention heads $H_{i}$ are then concatenated:</p>
<p>$$
\operatorname{MultiH}(\mathrm{Q}, \mathrm{~K}, \mathrm{~V})=\left[H_{1} ; \ldots ; H_{b}\right] W^{O}
$$</p>
<p>where $W^{O}$ is an output projection of the concatenated outputs of the attention heads. As shown in Figure 2(c), we follow Radford et al. (2018) and use the output of the previous layer's transformer block as the query input for the multi-headed attention of the next block. The keys and values are outputs of the previous layer's block for all preceding time steps:</p>
<p>$$
\operatorname{MultiAttn}\left(h_{t}^{l-1}\right)=\operatorname{MultiH}\left(h_{t}^{l-1}, \mathbf{h}<em t="t">{t}^{l-1}, \mathbf{h}</em>\right)
$$}^{l-1</p>
<p>where $\mathbf{h}<em _t="&lt;t">{t}^{l-1}=\left{h^{l-1}\right}</em>$ is the set of previous layer transformer block outputs for time steps preceding $t$.</p>
<p>Input Encoder As input to the model, we represent a knowledge tuple ${s, r, o}$ as a concatenated sequence of the words of each item of the tuple:</p>
<p>$$
\mathbf{X}=\left{X^{s}, X^{r}, X^{o}\right}
$$</p>
<p>Since the transformer (a self-attention model) has no concept of ordering of tokens, a position embedding $p_{t}$ is initialized for each absolute position in the sequence (Vaswani et al., 2017). For any input word $x_{t} \in \mathbf{X}$, our encoding of the input is</p>
<table>
<thead>
<tr>
<th style="text-align: center;">ATOMIC Input Template and ConceptNet Relation-only Input Template</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">a tokens</td>
<td style="text-align: center;">mask tokens</td>
<td style="text-align: center;">$r$ token</td>
<td style="text-align: center;">o tokens</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">PersonX goes to the mall [NASX] <xIntent></td>
<td style="text-align: center;">to buy clothes</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">ConceptNet Relation to Language Input Template</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">a tokens</td>
<td style="text-align: center;">mask tokens</td>
<td style="text-align: center;">$r$ tokens</td>
<td style="text-align: center;">mask tokens</td>
<td style="text-align: center;">o tokens</td>
</tr>
<tr>
<td style="text-align: center;">go to mall [NASX] [NASX] has prerequisite [NASX] have money</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>Figure 3: Input token setup for training configurations. For the Atomic dataset, the tokens of the subject, $X^{s}$ (e.g., PersonX goes to the mall) are followed by masking tokens, which is followed by a single relation token $X^{r}$ (e.g., xIntent), and then the object tokens $X^{o}$ (e.g., to buy clothes). The model receives the same input for ConceptNet, except that a second set of masking tokens separate $X^{r}$ and $X^{o}$ because $X^{r}$ can have a variable number of tokens for ConceptNet (§5.2)
the sum of its word embedding, $e_{t}$ with a position embedding encoding its absolute position in the sequence $\mathbf{X}$ :</p>
<p>$$
h_{t}^{0}=e_{t}+p_{t}
$$</p>
<p>where $p_{t}$ is the position embedding for time step $t$, and $h^{0}$ is the input to the first transformer layer.</p>
<h2>3 Training COMET</h2>
<p>COMET is trained to learn to produce the phrase object $o$ of a knowledge tuple given the tuple's phrase subject $s$ and relation $r$. More specifically, given the concatenation of the tokens of $s$ and $r$ : $\left[X^{s}, X^{r}\right]$ as input, the model must learn to generate the tokens of $o: X^{o}$ (See $\S 2.1$ for definitions of these variables).</p>
<p>Loss Function To achieve this goal, COMET is trained to maximize the conditional loglikelihood of predicting the phrase object tokens, $X^{o}$ :</p>
<p>$$
\mathcal{L}=-\sum_{t={s|+|r|}^{|s|+|r|+|o|} \log P\left(x_{t} \mid x_{&lt;t}\right)
$$</p>
<p>where $|s|,|r|$, and $|o|$ are the number of tokens in the subject phrase, relation, and object phrase, respectively. Figure 3 outlines how the tokens in $s$, $r$, and $o$ are organized for different training tasks.</p>
<p>Datasets COMET relies on a seed set of knowledge tuples from an existing KB to learn to produce commonsense knowledge. In this work, we use Atomic and ConceptNet as knowledge seed sets, but other commonsense knowledge resources could have been used as well as COMET is domain-agnostic.</p>
<p>Initialization Parameters are initialized to the final language model weights from Radford et al. (2018). Additional special tokens that are added to the vocabulary for fine tuning (e.g., relation embeddings such as oReact for Atomic and IsA for ConceptNet) are initialized by sampling from the standard normal distribution.</p>
<p>Hyperparameters Following Radford et al. (2018)'s design of the GPT model, we initialize COMET with 12 layers, 768-dimensional hidden states, and 12 attention heads. We use a dropout rate of 0.1 and use GeLU (Hendrycks and Gimpel, 2016) units as activation functions. During training, our batch size is 64 . Other dataset-specific hyperparameters are provided in Appendix A.1.</p>
<h2>4 Atomic Experiments</h2>
<p>The Atomic dataset ${ }^{3}$, released by Sap et al. (2019), contains 877 K tuples covering a variety of social commonsense knowledge around specific event prompts (e.g., " X goes to the store"). Specifically, Atomic distills its commonsense in nine dimensions, covering the event's causes (e.g., " X needs to drive there"), its effects on the agent (e.g., "to get food") and its effect on other direct (or implied) participants (e.g., "Others will be fed"). More details about Atomic can be found in Appendix D. For our experiments, Atomic events (e.g., " X goes to the store") are phrase subjects, $s$, the dimension (e.g., x Intent) is the phrase relation, $r$, and the causes/effects (e.g., "to get food") are phrase objects, $o$. We use the training splits from Sap et al. (2019), resulting in 710k training, 80 k development, and 87 k test tuples respectively.</p>
<h3>4.1 Setup</h3>
<p>Metrics Following Sap et al. (2019), we evaluate our method using BLEU-2 as an automatic evaluation metric. We also report the perplexity of the model on its gold generations. The remaining automatic metrics in Table 1 measure the proportion of generated tuples and generated objects which are not in the training set. We report the proportion of all generated tuples that are novel (\% N/T sro) and that have a novel object (\% N/T $o)^{4}$. To show that these novel objects are diverse (i.e., the same novel object is not the only one being generated), we also report the number of novel</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">3</a></sup></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: right;">PPL $^{5}$</th>
<th style="text-align: right;">BLEU-2</th>
<th style="text-align: right;">N/T $s r o^{6}$</th>
<th style="text-align: right;">N/T $o$</th>
<th style="text-align: right;">N/U $o$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">9ENC9DEC (Sap et al., 2019)</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">10.01</td>
<td style="text-align: right;">100.00</td>
<td style="text-align: right;">8.61</td>
<td style="text-align: right;">40.77</td>
</tr>
<tr>
<td style="text-align: left;">NearestNeighbor (Sap et al., 2019)</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">6.61</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
</tr>
<tr>
<td style="text-align: left;">Event2(IN)VOLUN (Sap et al., 2019)</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">9.67</td>
<td style="text-align: right;">100.00</td>
<td style="text-align: right;">9.52</td>
<td style="text-align: right;">45.06</td>
</tr>
<tr>
<td style="text-align: left;">Event2PERSONX/Y (Sap et al., 2019)</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">9.24</td>
<td style="text-align: right;">100.00</td>
<td style="text-align: right;">8.22</td>
<td style="text-align: right;">41.66</td>
</tr>
<tr>
<td style="text-align: left;">Event2PRE/POST (Sap et al., 2019)</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">9.93</td>
<td style="text-align: right;">100.00</td>
<td style="text-align: right;">7.38</td>
<td style="text-align: right;">41.99</td>
</tr>
<tr>
<td style="text-align: left;">COMET (- pretrain)</td>
<td style="text-align: right;">15.42</td>
<td style="text-align: right;">13.88</td>
<td style="text-align: right;">100.00</td>
<td style="text-align: right;">7.25</td>
<td style="text-align: right;">45.71</td>
</tr>
<tr>
<td style="text-align: left;">COMET</td>
<td style="text-align: right;">$\mathbf{1 1 . 1 4}$</td>
<td style="text-align: right;">$\mathbf{1 5 . 1 0}$</td>
<td style="text-align: right;">100.00</td>
<td style="text-align: right;">$\mathbf{9 . 7 1}$</td>
<td style="text-align: right;">$\mathbf{5 1 . 2 0}$</td>
</tr>
</tbody>
</table>
<p>Table 1: Automatic evaluations of quality and novelty for generations of Atomic commonsense. No novelty scores are reported for the NearestNeighbor baseline because all retrieved sequences are in the training set.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: right;">oEffect</th>
<th style="text-align: right;">oReact</th>
<th style="text-align: right;">oWant</th>
<th style="text-align: right;">xAttr</th>
<th style="text-align: right;">xEffect</th>
<th style="text-align: right;">xIntent</th>
<th style="text-align: right;">xNeed</th>
<th style="text-align: right;">xReact</th>
<th style="text-align: right;">xWant</th>
<th style="text-align: right;">Avg</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">9Enc9Dec (Sap et al., 2019)</td>
<td style="text-align: right;">22.92</td>
<td style="text-align: right;">32.92</td>
<td style="text-align: right;">35.50</td>
<td style="text-align: right;">52.20</td>
<td style="text-align: right;">47.52</td>
<td style="text-align: right;">51.70</td>
<td style="text-align: right;">48.74</td>
<td style="text-align: right;">63.57</td>
<td style="text-align: right;">51.56</td>
<td style="text-align: right;">45.32</td>
</tr>
<tr>
<td style="text-align: left;">Event2(In)voluntary (Sap et al., 2019)</td>
<td style="text-align: right;">$\underline{26.46}$</td>
<td style="text-align: right;">36.04</td>
<td style="text-align: right;">34.70</td>
<td style="text-align: right;">52.58</td>
<td style="text-align: right;">46.76</td>
<td style="text-align: right;">61.32</td>
<td style="text-align: right;">49.82</td>
<td style="text-align: right;">71.22</td>
<td style="text-align: right;">52.44</td>
<td style="text-align: right;">47.93</td>
</tr>
<tr>
<td style="text-align: left;">Event2PersonX/Y (Sap et al., 2019)</td>
<td style="text-align: right;">24.72</td>
<td style="text-align: right;">33.80</td>
<td style="text-align: right;">35.08</td>
<td style="text-align: right;">$\underline{52.98}$</td>
<td style="text-align: right;">48.86</td>
<td style="text-align: right;">53.93</td>
<td style="text-align: right;">54.05</td>
<td style="text-align: right;">66.42</td>
<td style="text-align: right;">54.04</td>
<td style="text-align: right;">46.41</td>
</tr>
<tr>
<td style="text-align: left;">Event2Pre/Post (Sap et al., 2019)</td>
<td style="text-align: right;">$\underline{26.26}$</td>
<td style="text-align: right;">34.48</td>
<td style="text-align: right;">35.78</td>
<td style="text-align: right;">52.20</td>
<td style="text-align: right;">46.78</td>
<td style="text-align: right;">57.77</td>
<td style="text-align: right;">47.94</td>
<td style="text-align: right;">72.22</td>
<td style="text-align: right;">47.94</td>
<td style="text-align: right;">46.76</td>
</tr>
<tr>
<td style="text-align: left;">COMET (- pretrain)</td>
<td style="text-align: right;">$\underline{25.90}$</td>
<td style="text-align: right;">$\underline{35.40}$</td>
<td style="text-align: right;">$\underline{40.76}$</td>
<td style="text-align: right;">48.04</td>
<td style="text-align: right;">47.20</td>
<td style="text-align: right;">58.88</td>
<td style="text-align: right;">59.16</td>
<td style="text-align: right;">64.52</td>
<td style="text-align: right;">65.66</td>
<td style="text-align: right;">49.50</td>
</tr>
<tr>
<td style="text-align: left;">COMET</td>
<td style="text-align: right;">$\mathbf{2 9 . 0 2}$</td>
<td style="text-align: right;">$\mathbf{3 7 . 6 8}$</td>
<td style="text-align: right;">$\mathbf{4 4 . 4 8}$</td>
<td style="text-align: right;">$\mathbf{5 7 . 4 8}$</td>
<td style="text-align: right;">$\mathbf{5 5 . 5 0}$</td>
<td style="text-align: right;">$\mathbf{6 8 . 3 2}$</td>
<td style="text-align: right;">$\mathbf{6 4 . 2 4}$</td>
<td style="text-align: right;">$\mathbf{7 6 . 1 8}$</td>
<td style="text-align: right;">$\mathbf{7 5 . 1 6}$</td>
<td style="text-align: right;">$\mathbf{5 6 . 4 5}$</td>
</tr>
</tbody>
</table>
<p>Table 2: Human score of generations of Atomic commonsense. We present comparisons to the baselines from Sap et al. (2019). Underlined results are those where COMET is not significantly better at $p&lt;0.05$
objects as a function of the set of unique objects produced for all test set events ( $\% \mathrm{~N} / \mathrm{U} o$ ).</p>
<p>Finally, we perform a human evaluation using workers from Amazon Mechanical Turk (AMT). Workers are asked to identify whether a model generation of Atomic commonsense adequately completes a plausible tuple of phrase subject, relation, and phrase object. Following the setup of Sap et al. (2019), we evaluate 100 randomly selected events from the test set. For each event and relation type, 10 candidates are generated using beam search and the full beam is evaluated by five different workers. Overall, $\mathrm{n}=5000$ ratings are produced per relation ( 100 events $\times 5$ workers $\times 10$ candidates). The reported Avg in Table 2 is an average of these scores, yielding $\mathrm{n}=45000$ total ratings for each model. We use Pitman's test (Noreen, 1989) with 100 k permutations to test for statistical significance. Because 50 different hypotheses are tested ( 9 relations + the total), the HolmBonferroni method (Holm, 1979) is used to correct significance thresholds. Example events from the development set and their generated phrase objects are available in Table 5.</p>
<p>Baselines We report the performance of our method against the models trained in Sap et al. (2019) that use LSTM sequence-to-sequence models (Sutskever et al., 2014) to encode the input subject and relation and produce an output object.</p>
<p>Ablations To evaluate how pre-training on a large corpus helps the model learn to produce knowledge, we train a version of COMET that is not initialized with pre-trained weights (COMET (pretrain)). We also evaluate the data efficiency of our method by training models on different proportions of the training data. Finally, because the ultimate goal of our method is to be able to perform high-quality, diverse knowledge base construction, we explore how various decoding schemes affect the quality of candidate knowledge tuples. We present the effect of the following generation strategies: argmax greedy decoding, beam search with beam sizes, $\mathrm{b}=2,5,10$, and top- $k$ sampling with $\mathrm{k}=5,10$. For each decoding method, we conduct the human evaluation on the number of final candidates produced by each method.</p>
<h3>4.2 Results</h3>
<p>Overall performance The BLEU-2 results in Table 1 indicate that COMET exceeds the performance of all baselines, achieving a $51 \%$ relative improvement over the top performing model of Sap et al. (2019). More interesting, however, is the result of the human evaluation, where COMET reported a statistically significant relative Avg performance increase of $18 \%$ over the top baseline,</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">3</a></sup></p>
<table>
<thead>
<tr>
<th style="text-align: left;">COMET Decoding method</th>
<th style="text-align: right;">oEffect</th>
<th style="text-align: right;">oReact</th>
<th style="text-align: right;">oWant</th>
<th style="text-align: right;">xAttr</th>
<th style="text-align: right;">xEffect</th>
<th style="text-align: right;">xIntent</th>
<th style="text-align: right;">xNeed</th>
<th style="text-align: right;">xReact</th>
<th style="text-align: right;">xWant</th>
<th style="text-align: right;">Avg</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Top-5 random sampling (n=2500 per relation)</td>
<td style="text-align: right;">34.60</td>
<td style="text-align: right;">44.04</td>
<td style="text-align: right;">35.56</td>
<td style="text-align: right;">64.56</td>
<td style="text-align: right;">55.68</td>
<td style="text-align: right;">58.84</td>
<td style="text-align: right;">46.68</td>
<td style="text-align: right;">80.96</td>
<td style="text-align: right;">58.52</td>
<td style="text-align: right;">53.27</td>
</tr>
<tr>
<td style="text-align: left;">Top-10 random sampling (n=5000 per relation)</td>
<td style="text-align: right;">25.20</td>
<td style="text-align: right;">37.42</td>
<td style="text-align: right;">27.34</td>
<td style="text-align: right;">49.20</td>
<td style="text-align: right;">47.34</td>
<td style="text-align: right;">47.06</td>
<td style="text-align: right;">38.24</td>
<td style="text-align: right;">72.60</td>
<td style="text-align: right;">48.10</td>
<td style="text-align: right;">43.61</td>
</tr>
<tr>
<td style="text-align: left;">Beam search - 2 beams (n=1000 per relation)</td>
<td style="text-align: right;">43.70</td>
<td style="text-align: right;">54.20</td>
<td style="text-align: right;">47.60</td>
<td style="text-align: right;">$\mathbf{8 4 . 0 0}$</td>
<td style="text-align: right;">51.10</td>
<td style="text-align: right;">73.80</td>
<td style="text-align: right;">50.70</td>
<td style="text-align: right;">85.80</td>
<td style="text-align: right;">78.70</td>
<td style="text-align: right;">63.29</td>
</tr>
<tr>
<td style="text-align: left;">Beam search - 5 beams (n=2500 per relation)</td>
<td style="text-align: right;">37.12</td>
<td style="text-align: right;">45.36</td>
<td style="text-align: right;">42.04</td>
<td style="text-align: right;">63.64</td>
<td style="text-align: right;">$\mathbf{6 1 . 7 6}$</td>
<td style="text-align: right;">63.60</td>
<td style="text-align: right;">57.60</td>
<td style="text-align: right;">78.64</td>
<td style="text-align: right;">68.40</td>
<td style="text-align: right;">57.57</td>
</tr>
<tr>
<td style="text-align: left;">Beam search - 10 beams (n=5000 per relation)</td>
<td style="text-align: right;">29.02</td>
<td style="text-align: right;">37.68</td>
<td style="text-align: right;">44.48</td>
<td style="text-align: right;">57.48</td>
<td style="text-align: right;">55.50</td>
<td style="text-align: right;">68.32</td>
<td style="text-align: right;">64.24</td>
<td style="text-align: right;">76.18</td>
<td style="text-align: right;">75.16</td>
<td style="text-align: right;">56.45</td>
</tr>
<tr>
<td style="text-align: left;">Greedy decoding (n=500 per relation)</td>
<td style="text-align: right;">$\mathbf{6 1 . 2 0}$</td>
<td style="text-align: right;">$\mathbf{6 9 . 8 0}$</td>
<td style="text-align: right;">$\mathbf{8 0 . 0 0}$</td>
<td style="text-align: right;">77.00</td>
<td style="text-align: right;">53.00</td>
<td style="text-align: right;">$\mathbf{8 9 . 6 0}$</td>
<td style="text-align: right;">$\mathbf{8 5 . 6 0}$</td>
<td style="text-align: right;">$\mathbf{9 2 . 2 0}$</td>
<td style="text-align: right;">$\mathbf{8 9 . 4 0}$</td>
<td style="text-align: right;">$\mathbf{7 7 . 5 3}$</td>
</tr>
<tr>
<td style="text-align: left;">Human validation of gold ATOMIC</td>
<td style="text-align: right;">84.62</td>
<td style="text-align: right;">86.13</td>
<td style="text-align: right;">83.12</td>
<td style="text-align: right;">78.44</td>
<td style="text-align: right;">83.92</td>
<td style="text-align: right;">91.37</td>
<td style="text-align: right;">81.98</td>
<td style="text-align: right;">95.18</td>
<td style="text-align: right;">90.90</td>
<td style="text-align: right;">86.18</td>
</tr>
</tbody>
</table>
<p>Table 3: Human evaluation testing effect of different decoding schemes on candidate tuple quality. The number of ratings made per relation for each decoding method is provided in the first column.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">\% train data</th>
<th style="text-align: center;">PPL</th>
<th style="text-align: center;">BLEU-2</th>
<th style="text-align: center;">N/T o</th>
<th style="text-align: center;">N/U o</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">$1 \%$ train</td>
<td style="text-align: center;">23.81</td>
<td style="text-align: center;">5.08</td>
<td style="text-align: center;">7.24</td>
<td style="text-align: center;">49.36</td>
</tr>
<tr>
<td style="text-align: center;">$10 \%$ train</td>
<td style="text-align: center;">13.74</td>
<td style="text-align: center;">12.72</td>
<td style="text-align: center;">$\mathbf{9 . 5 4}$</td>
<td style="text-align: center;">$\mathbf{5 8 . 3 4}$</td>
</tr>
<tr>
<td style="text-align: center;">$50 \%$ train</td>
<td style="text-align: center;">11.82</td>
<td style="text-align: center;">13.97</td>
<td style="text-align: center;">9.32</td>
<td style="text-align: center;">50.37</td>
</tr>
<tr>
<td style="text-align: center;">FULL ( - pretrain)</td>
<td style="text-align: center;">15.18</td>
<td style="text-align: center;">13.22</td>
<td style="text-align: center;">7.14</td>
<td style="text-align: center;">44.55</td>
</tr>
<tr>
<td style="text-align: center;">FULL train</td>
<td style="text-align: center;">$\mathbf{1 1 . 1 3}$</td>
<td style="text-align: center;">$\mathbf{1 4 . 3 4}$</td>
<td style="text-align: center;">9.51</td>
<td style="text-align: center;">50.05</td>
</tr>
</tbody>
</table>
<p>Table 4: Effect of amount of training data on automatic evaluation of commonsense generations</p>
<p>Event2IN(VOlun). This performance increase is consistent, as well, with an improvement being observed across every relation type. In addition to the quality improvements, Table 1 shows that COMET produces more novel tuple objects than the baselines, as well.</p>
<p>Learning knowledge from language Significant differences were also observed between the performance of the model whose weights were initialized with the pre-trained parameters from the GPT model of Radford et al. (2018) and a model with the same architecture that was trained from random initialization. This $14 \%$ relative improvement in overall human performance confirms that the language representations learned by the GPT model are transferable to generating natural language commonsense knowledge.</p>
<p>Effect of decoding algorithm In Table 3, we show the effect of different generation policies on knowledge quality. The most interesting result is that using greedy decoding to produce knowledge tuples only results in a $10 \%$ relative performance gap compared to a human evaluation of the ATOMIC test set, showing that the knowledge produced by the model approaches human performance. While producing more total candidates does lower overall performance, quality assess-</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Seed Concept</th>
<th style="text-align: center;">Relation</th>
<th style="text-align: center;">Generated</th>
<th style="text-align: center;">Plausible</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">X holds out X's hand to Y</td>
<td style="text-align: center;">xAttr</td>
<td style="text-align: center;">helpful</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: center;">X meets Y eyes</td>
<td style="text-align: center;">xAttr</td>
<td style="text-align: center;">intense</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: center;">X watches Y every</td>
<td style="text-align: center;">xAttr</td>
<td style="text-align: center;">observant</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: center;">X eats red meat</td>
<td style="text-align: center;">xEffect</td>
<td style="text-align: center;">gets fat</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: center;">X makes crafts</td>
<td style="text-align: center;">xEffect</td>
<td style="text-align: center;">gets dirty</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: center;">X turns X's phone</td>
<td style="text-align: center;">xEffect</td>
<td style="text-align: center;">gets a test</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">X pours $\qquad$ over Y's head</td>
<td style="text-align: center;">oEffect</td>
<td style="text-align: center;">gets hurt</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: center;">X takes Y's head off</td>
<td style="text-align: center;">oEffect</td>
<td style="text-align: center;">bleeds</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: center;">X plows on Y's bonfire</td>
<td style="text-align: center;">oEffect</td>
<td style="text-align: center;">gets burned</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">X spoils somebody rotten</td>
<td style="text-align: center;">xIntent</td>
<td style="text-align: center;">to be mean</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">X gives Y some pills</td>
<td style="text-align: center;">xIntent</td>
<td style="text-align: center;">to help</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: center;">X provides for Y's needs</td>
<td style="text-align: center;">xIntent</td>
<td style="text-align: center;">to be helpful</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: center;">X explains Y's reasons</td>
<td style="text-align: center;">xNeed</td>
<td style="text-align: center;">to know Y</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: center;">X fulfils X's needs</td>
<td style="text-align: center;">xNeed</td>
<td style="text-align: center;">to have a plan</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: center;">X gives Y everything</td>
<td style="text-align: center;">xNeed</td>
<td style="text-align: center;">to buy something</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: center;">X eats pancakes</td>
<td style="text-align: center;">xNeed</td>
<td style="text-align: center;">satisfied</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: center;">X makes $\qquad$ at work</td>
<td style="text-align: center;">xReact</td>
<td style="text-align: center;">proud</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: center;">X moves house</td>
<td style="text-align: center;">xReact</td>
<td style="text-align: center;">happy</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: center;">X gives birth to the Y</td>
<td style="text-align: center;">oReact</td>
<td style="text-align: center;">happy</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: center;">X gives Y's friend</td>
<td style="text-align: center;">oReact</td>
<td style="text-align: center;">grateful</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: center;">X goes $\qquad$ with friends</td>
<td style="text-align: center;">oReact</td>
<td style="text-align: center;">happy</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: center;">X gets all the supplies</td>
<td style="text-align: center;">xWant</td>
<td style="text-align: center;">to make a list</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: center;">X murders Y's wife</td>
<td style="text-align: center;">xWant</td>
<td style="text-align: center;">to hide the body</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: center;">X starts shopping</td>
<td style="text-align: center;">xWant</td>
<td style="text-align: center;">to go home</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: center;">X develops Y theory</td>
<td style="text-align: center;">oWant</td>
<td style="text-align: center;">to thank X</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: center;">X offer Y a position</td>
<td style="text-align: center;">oWant</td>
<td style="text-align: center;">to accept the job</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: center;">X takes $\qquad$ out for dinner</td>
<td style="text-align: center;">oWant</td>
<td style="text-align: center;">to eat</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
</tbody>
</table>
<p>Table 5: Generations that were randomly selected from a subset of novel generations from the ATOMIC development set. A novel generation is a sro tuple not found in the training set. Manual evaluation of each tuple indicates whether the tuple is considered plausible by a human annotator.
ments still hover around $55 \%^{7}$ for a beam size of 10. This result suggests that COMET could be effective with human evaluators in the loop to confirm the correctness of generated tuples.</p>
<p>Efficiency of learning from seed tuples Because not all domains will have large available commonsense KBs on which to train, we explore how varying the amount of training data available for learning affects the quality and novelty of the knowledge that is produced. Our results in Table 4 indicate that even with only $10 \%$ of the available training data, the model is still able to</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">3</a></sup></p>
<p>produce generations that are coherent, adequate, and novel. Using only $1 \%$ of the training data clearly diminishes the quality of the produced generations, with significantly lower observed results across both quality and novelty metrics. Interestingly, we note that training the model without pretrained weights performs comparably to training with $10 \%$ of the seed tuples, quantifying the impact of using pre-trained language representations.</p>
<h2>5 ConceptNet Experiments</h2>
<p>The ConceptNet dataset ${ }^{8}$, provided by Li et al. (2016), consists of tuples obtained from the Open Mind Common Sense (OMCS) entries in ConceptNet 5 (Speer et al., 2017). Tuples are in the standard sro form - (e.g., take a nap, Causes, have energy). The most confident 1200 tuples were used to create the test set, while the next 1200 tuples were used to create two development sets, which we combine in this work. The 100k version of the training set was used to train models, which contains 34 relation types.</p>
<h3>5.1 Setup</h3>
<p>Metrics We evaluate our models that generate ConceptNet relations using the following metrics. First, we report the perplexity of the gold relations in the test set (PPL). To evaluate the quality of generated knowledge, we also report the number of generated positive examples in the test set that are scored as correct by the pre-trained Bilinear AVG model developed by Li et al. (2016). ${ }^{9}$ For a given sro tuple, this model produces a probability for whether the tuple is correct. We threshold scores at $50 \%$ probability to identify positive predictions. On the completion task originally proposed in Li et al. (2016), this model achieved $92.5 \%$ accuracy on the test set, indicating that it is a strong proxy for automatically evaluating whether a generated tuple is correct. Finally, we report the same novelty metrics as for ATOMIC: N/T sro and N/T o.</p>
<p>Baselines As a baseline, we re-implement the BiLSTM model proposed by Saito et al. (2018) with minor modifications outlined in Appendix A.2. This model is trained to learn to encode knowledge in both directions: $s r \rightarrow o$ and</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">3</a></sup>| Model | PPL | Score | N/T sro | N/T o | Human |
| :-- | --: | --: | --: | --: | --: |
| LSTM - $s$ | - | 60.83 | $\mathbf{8 6 . 2 5}$ | 7.83 | 63.86 |
| CKBG (Saito et al., 2018) | - | 57.17 | $\mathbf{8 6 . 2 5}$ | $\mathbf{8 . 6 7}$ | 53.95 |
| COMET (- pretrain) | 8.05 | 89.25 | 36.17 | 6.00 | 83.49 |
| COMET - RELTOK | 4.39 | 95.17 | 56.42 | 2.62 | $\mathbf{9 2 . 1 1}$ |
| COMET | $\mathbf{4 . 3 2}$ | $\mathbf{9 5 . 2 5}$ | 59.25 | 3.75 | 91.69 |</p>
<p>Table 6: ConceptNet generation Results
$o r \rightarrow s$ to help augment a knowledge base completion model. It is only evaluated on the $s r \rightarrow o$ tuple generation task, however. For posterity, we also include the result from a LSTM model that is only trained on the $s r \rightarrow o$ task (LSTM - $s$ ).</p>
<p>Ablations We include the following ablations of our full model. First, we evaluate how pretraining on a large-scale corpus (Radford et al., 2018) helps performance by training a comparison model from scratch, denoted $\operatorname{COMET}$ ( - pretrain) in Table 6. Second, in our main model, we map relation names to natural language (e.g., IsA $\rightarrow$ "is a"; HasSubevent $\rightarrow$ "has subevent") so the model can learn to represent these concepts with language, as opposed to learning a special embedding from scratch for each relation (Levy et al., 2017). As an ablation, we train a model without converting relation tokens to natural language (e.g., IsA $\nrightarrow$ "is a"), which we denote COMET RELTOK.</p>
<h3>5.2 Results</h3>
<p>Quality Our results indicate that high-quality knowledge can be generated by the model: the low perplexity scores in Table 6 indicate high model confidence in its predictions, while the high classifier score ( $95.25 \%$ ) indicates that the KB completion model of Li et al. (2016) scores the generated tuples as correct in most of the cases. While adversarial generations could be responsible for this high score, a human evaluation (following the same design as for ATOMIC) scores $91.7 \%$ of greedily decoded tuples as correct. Randomly selected examples provided in Table 7 also point to the quality of knowledge produced by the model.</p>
<p>Novelty In addition to being high quality, the generated tuples from COMET are also novel, with $59.25 \%$ of the tuples not being present in the training set, showing that the model is capable of generating new edges between nodes, and even creating new nodes $-3.75 \%$ of $o$ nodes are novel to extend the size of the knowledge graph. One shortcoming, however, is that novel generations</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 4: The percentage of novel ConceptNet development set tuples per minimum edit distance from training tuples. In green: classifier-scored accuracy of each subset.</p>
<p>are sometimes simplified forms of tuples from the training set. In Table 7, for example, the tuple "doctor CapableOf save life" is not present in the training set, but "doctor CapableOf save person life" is. Many tuples, however, are completely novel, such as "bird bone HasProperty fragile" and "driftwood AtLocation beach", which have no related tuples in the training set.</p>
<p>To explore further, we investigate by how much novel tuples from the development set differ from training set phrase objects for the same <em>s, r</em> using minimum edit distance of phrase objects. We measure the edit distance of phrase object <em>odev</em> in the tuple (<em>s, r, odev</em>) to the <em>otrn</em> from the nearest training tuple (<em>s, r, otrn</em>). Edit distance is measured using word tokens (excluding stop words) and normalized by the maximum number of words in <em>odev</em> or <em>otrn</em>. The maximum edit distance is one (i.e., entirely different word sequences) and the minimum edit distance is zero (i.e., the same sequence excluding stopwords). Figure 4 shows the percentage of novel development set tuples that have an edit distance from the closest training set tuple of at least the value on the x-axis. Over 75% of the novel tuples have objects that are a normalized edit distance of &gt;= 0.5 from the training phrase objects, indicating that most of the novel phrase objects have significantly different word sequences from their closest analogues in the training set.</p>
<h3>Learning knowledge from language</h3>
<p>Similarly to Atomic, we explore how pre-training COMET on a large language corpus affects its ability to generalize commonsense. This effect is apparent in Table 6, with a clear improvement on automatic and human evaluations by the pretrained COMET over the randomly initialized</p>
<table>
<thead>
<tr>
<th>Seed</th>
<th>Relation</th>
<th>Completion</th>
<th>Plausible</th>
</tr>
</thead>
<tbody>
<tr>
<td>piece</td>
<td>PartOf</td>
<td>machine</td>
<td>✓</td>
</tr>
<tr>
<td>bread</td>
<td>IsA</td>
<td>food</td>
<td>✓</td>
</tr>
<tr>
<td>oldsmobile</td>
<td>IsA</td>
<td>car</td>
<td>✓</td>
</tr>
<tr>
<td>happiness</td>
<td>IsA</td>
<td>feel</td>
<td>✓</td>
</tr>
<tr>
<td>math</td>
<td>IsA</td>
<td>subject</td>
<td>✓</td>
</tr>
<tr>
<td>mango</td>
<td>IsA</td>
<td>fruit</td>
<td>✓</td>
</tr>
<tr>
<td>maine</td>
<td>IsA</td>
<td>state</td>
<td>✓</td>
</tr>
<tr>
<td>planet</td>
<td>AtLocation</td>
<td>space</td>
<td>✓</td>
</tr>
<tr>
<td>dust</td>
<td>AtLocation</td>
<td>fridge</td>
<td></td>
</tr>
<tr>
<td>puzzle</td>
<td>AtLocation</td>
<td>your mind</td>
<td></td>
</tr>
<tr>
<td>college</td>
<td>AtLocation</td>
<td>town</td>
<td>✓</td>
</tr>
<tr>
<td>dental chair</td>
<td>AtLocation</td>
<td>dentist</td>
<td>✓</td>
</tr>
<tr>
<td>finger</td>
<td>AtLocation</td>
<td>your finger</td>
<td></td>
</tr>
<tr>
<td>sing</td>
<td>Causes</td>
<td>you feel good</td>
<td>✓</td>
</tr>
<tr>
<td>doctor</td>
<td>CapableOf</td>
<td>save life</td>
<td>✓</td>
</tr>
<tr>
<td>post office</td>
<td>CapableOf</td>
<td>receive letter</td>
<td>✓</td>
</tr>
<tr>
<td>dove</td>
<td>SymbolOf</td>
<td>purity</td>
<td>✓</td>
</tr>
<tr>
<td>sun</td>
<td>HasProperty</td>
<td>big</td>
<td>✓</td>
</tr>
<tr>
<td>bird bone</td>
<td>HasProperty</td>
<td>fragile</td>
<td>✓</td>
</tr>
<tr>
<td>earth</td>
<td>HasA</td>
<td>many plant</td>
<td>✓</td>
</tr>
<tr>
<td>yard</td>
<td>UsedFor</td>
<td>play game</td>
<td>✓</td>
</tr>
<tr>
<td>get pay</td>
<td>HasPrerequisite</td>
<td>work</td>
<td>✓</td>
</tr>
<tr>
<td>print on printer</td>
<td>HasPrerequisite</td>
<td>get printer</td>
<td>✓</td>
</tr>
<tr>
<td>play game</td>
<td>HasPrerequisite</td>
<td>have game</td>
<td>✓</td>
</tr>
<tr>
<td>live</td>
<td>HasLastSubevent</td>
<td>die</td>
<td>✓</td>
</tr>
<tr>
<td>swim</td>
<td>HasSubevent</td>
<td>get wet</td>
<td>✓</td>
</tr>
<tr>
<td>sit down</td>
<td>MotivatedbyGoal</td>
<td>you be tire</td>
<td>✓</td>
</tr>
<tr>
<td>all paper</td>
<td>ReceivesAction</td>
<td>recycle</td>
<td>✓</td>
</tr>
<tr>
<td>chair</td>
<td>MadeOf</td>
<td>wood</td>
<td>✓</td>
</tr>
<tr>
<td>earth</td>
<td>DefinedAs</td>
<td>planet</td>
<td>✓</td>
</tr>
</tbody>
</table>
<p>Table 7: Randomly selected and novel generations from the ConceptNet development set. Novel generations are <em>sro</em> tuples not found in the training set. Manual evaluation of each tuple indicates whether the tuple is considered plausible by a human annotator.</p>
<p>model. Qualitatively, we observe this effect in Table 7 with the generated example tuple "mango IsA fruit", which is not present in the training set. The only tuple containing the "mango" entity in the training set is "mango UsedFor salsa", which is not informative enough. As confirmation, we observe that the output from COMET (- pretrain) is "mango IsA spice", which could be a reasonable inference given the information about "mango" in the seed set of knowledge.</p>
<h3>Representing relations with language</h3>
<p>While the automatic metrics point to insignificant differences when comparing models with symbol relations and those with natural language relations (Table 6), examples can provide qualitative insights into the benefits of representing relations as language. While the only non-ornithological reference to a "dove" in the ConceptNet training set is "dove CapableOf fly", our model learns to generalize to produce the tuple "dove SymbolOf purity". The model that uses symbol relation embeddings only manages to produce the relation "dove SymbolOf submarine", which seems to relate "submarine" to a more nautical (and unrelated) word sense of "dove".</p>
<h2>6 Related Work</h2>
<p>Knowledge base construction Previous work has looked at constructing knowledge bases as relational schemas using expert knowledge (Lenat, 1995; Bodenreider, 2004; Miller, 1995), semistructured text extraction (Suchanek et al., 2007; Hoffart et al., 2013; Auer et al., 2007; Bollacker et al., 2008) and unstructured text extraction (Dong et al., 2014; Carlson et al., 2010; Nakashole et al., 2011, 2012; Niu, 2012). In our work, we focus on construction of commonsense knowledge bases which require the use of open-text events rather than a well-defined relational schema structure. Other work in information extraction can also be applied to knowledge base construction with open-text entities (Soderland et al., 2010; Etzioni et al., 2011; Fader et al., 2011; Mausam et al., 2012; Fan et al., 2010; Cui et al., 2018), but these methods typically extract explicitly stated text relations. Conversely, our approach generates new knowledge that is often unstated in text, as commonsense information typically is (Gordon and Van Durme, 2013).</p>
<h2>Commonsense knowledge base completion</h2>
<p>Existing work on generation of novel commonsense knowledge has also used ConceptNet and ATOMIC as underlying KBs. Specifically, Li et al. (2016) proposed a set of neural network models for scoring tuples in ConceptNet. Our work differs from this approach as their models evaluate full tuples rather than learning to generate the phrases to make new nodes in the knowledge graph. Saito et al. (2018) builds upon this work by proposing a joint model for completion and generation of commonsense tuples. Their work, however, focuses on using tuple generation to augment their KB completion model, rather than to increase coverage in commonsense KB construction. Finally, Sap et al. (2019) use LSTM encoder-decoder models to generate commonsense knowledge about social situations. We use transformers and investigate the effect of using pre-trained language representations (Radford et al., 2018) to initialize them.</p>
<p>Transformers and pre-training Finally, our work builds on previous work on adapting pretrained language models for various sequence labeling, classification, and NLI end tasks (Radford et al., 2018; Peters et al., 2018; Devlin et al., 2018). Our research investigates how pre-trained language models can be used for large-scale com-
monsense KB construction by generating new graph nodes and edges between nodes.</p>
<h2>7 Conclusion</h2>
<p>We introduce COMmonsense Transformers (COMET) for automatic construction of commonsense knowledge bases. COMET is a framework for adapting the weights of language models to learn to produce novel and diverse commonsense knowledge tuples. Empirical results on two commonsense knowledge bases, ATOMIC and ConceptNet, show that COMET frequently produces novel commonsense knowledge that human evaluators deem to be correct. These positive results point to future work in extending the approach to a variety of other types of knowledge bases, as well as investigating whether COMET can learn to produce OpenIE-style knowledge tuples for arbitrary knowledge seeds.</p>
<h2>Acknowledgments</h2>
<p>We thank Thomas Wolf, Ari Holtzman, Chandra Bhagavatula, Peter Clark, Rob Dalton, Ronan Le Bras, Rowan Zellers and Scott Yih for helpful discussions over the course of this project, as well as the anonymous reviewers for their insightful comments. This research was supported in part by NSF (IIS-1524371, IIS-1714566, NRI-1525251), DARPA under the CwC program through the ARO (W911NF-15-1-0543), and Samsung Research. This material is based, in part, upon work supported by the National Science Foundation Graduate Research Fellowship Program under Grant No. DGE-1256082.</p>
<h2>References</h2>
<p>Sören Auer, Christian Bizer, Georgi Kobilarov, Jens Lehmann, Richard Cyganiak, and Zachary G. Ives. 2007. Dbpedia: A nucleus for a web of open data. In ISWC/ASWC.</p>
<p>Jimmy Ba, Ryan Kiros, and Geoffrey E. Hinton. 2016. Layer normalization. CoRR, abs/1607.06450.</p>
<p>Olivier Bodenreider. 2004. The unified medical language system (umls): Integrating biomedical terminology. Nucleic acids research, 32:D267-70.</p>
<p>Piotr Bojanowski, Edouard Grave, Armand Joulin, and Tomas Mikolov. 2017. Enriching word vectors with subword information. Transactions of the Association for Computational Linguistics, 5:135-146.</p>
<p>Kurt Bollacker, Colin Evans, Praveen Paritosh, Tim Sturge, and Jamie Taylor. 2008. Freebase: A collaboratively created graph database for structuring human knowledge. In Proceedings of the 2008 ACM SIGMOD International Conference on Management of Data, SIGMOD '08, pages 1247-1250, New York, NY, USA. ACM.</p>
<p>Andrew Carlson, Justin Betteridge, Bryan Kisiel, Burr Settles, Estevam R. Hruschka, Jr., and Tom M. Mitchell. 2010. Toward an architecture for neverending language learning. In Proceedings of the Twenty-Fourth AAAI Conference on Artificial Intelligence, AAAI'10, pages 1306-1313. AAAI Press.</p>
<p>Lei Cui, Furu Wei, and Ming Zhou. 2018. Neural open information extraction. In $A C L$.</p>
<p>Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2018. Bert: Pre-training of deep bidirectional transformers for language understanding. arXiv preprint arXiv:1810.04805.</p>
<p>Xin Dong, Evgeniy Gabrilovich, Geremy Heitz, Wilko Horn, Ni Lao, Kevin Murphy, Thomas Strohmann, Shaohua Sun, and Wei Zhang. 2014. Knowledge vault: A web-scale approach to probabilistic knowledge fusion. In Proceedings of the 20th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, KDD '14, pages 601610, New York, NY, USA. ACM.</p>
<p>Oren Etzioni, Anthony Fader, Janara Christensen, Stephen Soderland, and Mausam. 2011. Open information extraction: The second generation. In IJCAI.</p>
<p>Anthony Fader, Stephen Soderland, and Oren Etzioni. 2011. Identifying relations for open information extraction. In Proceedings of the conference on empirical methods in natural language processing, pages 1535-1545. Association for Computational Linguistics.</p>
<p>James Fan, David A. Ferrucci, David Gondek, and Aditya Kalyanpur. 2010. Prismatic: Inducing knowledge from a large scale lexicalized relation resource. In NAACL-HLT 2010.</p>
<p>Jonathan Gordon and Benjamin Van Durme. 2013. Reporting bias and knowledge acquisition. In Proceedings of the 2013 workshop on Automated knowledge base construction, pages 25-30. ACM.</p>
<p>Dan Hendrycks and Kevin Gimpel. 2016. Bridging nonlinearities and stochastic regularizers with gaussian error linear units. CoRR, abs/1606.08415.</p>
<p>Sepp Hochreiter and Jürgen Schmidhuber. 1997. Long short-term memory. Neural Computation, 9(8).</p>
<p>Johannes Hoffart, Fabian M. Suchanek, Klaus Berberich, and Gerhard Weikum. 2013. Yago2: A spatially and temporally enhanced knowledge base from wikipedia. Artificial Intelligence, 194:28 61. Artificial Intelligence, Wikipedia and SemiStructured Resources.</p>
<p>Sture Holm. 1979. A simple sequentially rejective multiple test procedure. Scandinavian Journal of Statistics, 6(2):65-70.</p>
<p>Douglas B Lenat. 1995. Cyc: A large-scale investment in knowledge infrastructure. Communications of the ACM, 38(11):33-38.</p>
<p>Omer Levy, Minjoon Seo, Eunsol Choi, and Luke S. Zettlemoyer. 2017. Zero-shot relation extraction via reading comprehension. In CoNLL.</p>
<p>Xiang Li, Aynaz Taheri, Lifu Tu, and Kevin Gimpel. 2016. Commonsense knowledge base completion. In $A C L$, volume 1, pages 1445-1455.</p>
<p>Mausam, Michael Schmitz, Stephen Soderland, Robert Bart, and Oren Etzioni. 2012. Open language learning for information extraction. In EMNLP-CoNLL.</p>
<p>George A. Miller. 1995. Wordnet: A lexical database for english. Commun. ACM, 38(11):39-41.</p>
<p>Ndapandula Nakashole, Martin Theobald, and Gerhard Weikum. 2011. Scalable knowledge harvesting with high precision and high recall. In Proceedings of the Fourth ACM International Conference on Web Search and Data Mining, WSDM '11, pages 227236, New York, NY, USA. ACM.</p>
<p>Ndapandula Nakashole, Gerhard Weikum, and Fabian Suchanek. 2012. Patty: A taxonomy of relational patterns with semantic types. In Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning, pages 1135-1145. Association for Computational Linguistics.</p>
<p>Feng Niu. 2012. Web-scale Knowledge-base Construction via Statistical Inference and Learning. Ph.D. thesis, Madison, WI, USA. AAI3524067.</p>
<p>Eric W Noreen. 1989. Computer intensive methods for hypothesis testing: An introduction. Wiley, NY.</p>
<p>Jeffrey Pennington, Richard Socher, and Christopher D. Manning. 2014. Glove: Global vectors for word representation. In EMNLP.</p>
<p>Matthew E. Peters, Mark Neumann, Mohit Iyyer, Matthew Gardner, Christopher Clark, Kenton Lee, and Luke S. Zettlemoyer. 2018. Deep contextualized word representations. CoRR, abs/1802.05365.</p>
<p>Alec Radford, Karthik Narasimhan, Tim Salimans, and Ilya Sutskever. 2018. Improving language understanding by generative pre-training. URL https://s3-us-west-2. amazonaws. com/openai-assets/researchcovers/languageunsupervised/language understanding paper. pdf.</p>
<p>Itsumi Saito, Kyosuke Nishida, Hisako Asano, and Junji Tomita. 2018. Commonsense knowledge base completion and generation. In Proceedings of the 22nd Conference on Computational Natural Language Learning, pages 141-150.</p>
<p>Maarten Sap, Ronan LeBras, Emily Allaway, Chandra Bhagavatula, Nicholas Lourie, Hannah Rashkin, Brendan Roof, Noah A Smith, and Yejin Choi. 2019. Atomic: An atlas of machine commonsense for ifthen reasoning. In $A A A I$.</p>
<p>Stephen Soderland, Brendan Roof, Bo Qin, Shi Xu, Mausam, and Oren Etzioni. 2010. Adapting open information extraction to domain-specific relations. AI Magazine, 31:93-102.</p>
<p>Robyn Speer, Joshua Chin, and Catherine Havasi. 2017. Conceptnet 5.5: An open multilingual graph of general knowledge. In Thirty-First AAAI Conference on Artificial Intelligence.</p>
<p>Fabian M. Suchanek, Gjergji Kasneci, and Gerhard Weikum. 2007. Yago: A core of semantic knowledge. In Proceedings of the 16th International Conference on World Wide Web, WWW '07, pages 697706, New York, NY, USA. ACM.</p>
<p>Ilya Sutskever, Oriol Vinyals, and Quoc V Le. 2014. Sequence to sequence learning with neural networks. In Advances in Neural Information Processing Systems.</p>
<p>Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser, and Illia Polosukhin. 2017. Attention is all you need. In NIPS.</p>
<h2>A Additional Training Details</h2>
<h2>A. 1 Training Hyperparameters</h2>
<p>Atomic For Atomic, we use a maximum learning rate of $6.25 \mathrm{e}-5$ with a warmup period of 100 minibatches. After, we decay the learning rate linearly until the end of training. We train for 50 k minibatches and use early stopping. We clip gradients when their norm is greater than 1. The remainder of our hyperparameters are the same as in Radford et al. (2018). We use the public HuggingFace implementation of the GPT model as a base for our experiments available at: https://github.com/huggingface/ pytorch-openai-transformer-lm.</p>
<p>ConceptNet For ConceptNet, we use a maximum learning rate of $1 \mathrm{e}-5$ and a warm-up period of 200 minibatches. The learning rate is decayed linearly until the end of training, which lasts for 100k minibatches. All other hyperparameters are the same as for training on the ATOMIC corpus.</p>
<h2>A. 2 ConceptNet baseline</h2>
<p>We train the ConceptNet baseline with a learning rate of $1 \mathrm{e}-4$ for 100 k minibatches. Early stopping is used with the validation loss. Similarly to Saito et al. (2018), we use 200-dimension hidden states and 200-dimensional word embeddings. We use a single-layer bidirectional LSTM (Hochreiter and Schmidhuber, 1997) to encode the first phrase and a single-layer unidirectional LSTM to decode the target phrase. Relation embeddings are concatenated with the word embeddings of the decoder before being input to the decoder LSTM. We set the dropout rate to 0.2 before the output projection layer and after the word embedding layers. We outline the following differences between our reimplementation of the model of Saito et al. (2018) and their original implementation and the reason for the change.</p>
<ol>
<li>We use Glove (Pennington et al., 2014) embeddings rather than fastText embeddings (Bojanowski et al., 2017) to initialize word embeddings. Because the model indicated that 200-dimensional word embeddings were used, we could not use the pretrained embeddings provided by the fastText group ${ }^{1}$. In Saito et al. (2018), the authors described training their fastText embeddings on
<sup id="fnref5:0"><a class="footnote-ref" href="#fn:0">3</a></sup>Wikipedia. With no reference to the precise corpus used, we opted to use Glove embeddings to initialize the word embeddings of the encoder and decoder instead.</li>
<li>We use the Adam optimizer with learning rate of 0.0001 , rather than SGD with a learning rate of 1.0 because after training both models, we found that the Adam-trained model performed better on development set perplexity. We also do not use weight decay, as this seemed to lower validation performance, as well.</li>
<li>We do not train the generation model jointly with the completion model. We only train an individual generator. The results of Saito et al. (2018) did not show a significant difference in generation performance between the two on the ConceptNet dataset.</li>
<li>We train a second baseline (LSTM - $s$ ) that does not learn to produce relations in both directions (i.e., $s r \rightarrow o$ and $o r \rightarrow s$ ). Instead if only learns parameters that can produce relations in the forward direction $(s r \rightarrow o)$</li>
<li>We do not decay the learning rate because it was unclear from the original paper what the exact learning rate schedule was.</li>
</ol>
<h2>B Additional Evaluation Details</h2>
<h2>B. 1 Human Evaluations</h2>
<p>We used Amazon Mechanical Turk to get ratings of model output accuracy. We selected seed concepts and relations from the test set and generated completions using each model to create $(s, r, o)$ tuples. For ATOMIC, we selected tuples by choosing all possible relations (9) for each of 100 randomly selected seed concepts ( 900 total $(s, r)$ pairs) following the procedure from Sap et al. (2019). For ConceptNet, we used the full test set (1200 total $(s, r)$ pairs).</p>
<p>For Beam-2/5/10 and top-5/10 sampling generations, we used the model to generate 2,5 , or 10 (respectively) possible completions (o) per $(s, r)$ pair. Workers were shown the full set and asked to select all of the $o$ that are valid completions for the $(s, r)$ pair. Each set of tuples was rated by 5 workers.</p>
<p>For greedy sampling generations, we used the model to generate one possible completion (o) per</p>
<p>$(s, r)$ pair. Workers were shown the completed tuple $(s, r, o)$ and asked whether it is valid or not. Each tuple was rated by 5 workers.</p>
<p>We measure accuracy as the percentage of distinct worker responses where the $(s, r, o)$ tuple is marked as valid (i.e., $\frac{# \text { valid }}{\% \mid(s, r, o))}$ ).</p>
<h2>C Example Outputs</h2>
<p>Additional examples can be seen in Figures 5, 6 , and 7 that are produced using the demo at https://mosaickg.apps.allenai. org.</p>
<h2>D Additional Training Experiments</h2>
<p>In addition to the more naive setups for knowledge graph completion, we explore various multitask and hierarchical learning setups on top of the taxonomy of commonsense relations given by Sap et al. (2019), which group together along various axes (e.g., related to agent/theme, related to causes/effects, etc.).</p>
<h3>D. 1 Multi-relation Training</h3>
<p>For the Atomic corpus, we experiment with multiple multi-task training setups, similar to Sap et al. (2019). First, we train an individual model for each relation type (oReact, oEffect, etc.), which we denote as COMET - 9LM in the Table 9. We also experiment with various informationsharing dataset configurations that organize different relations across common dimensions. We outline these dimensions and the makeup of each split in Table 9. For ConceptNet, all models are always trained on all relation types jointly. Results on automatic evaluation metrics are provided in Table 11. Because there did not seem to be significant differences between these performances and that of COMET - FULL, we did not run additional experiments on these ablations.</p>
<h2>D. 2 Concept Hierarchy Training</h2>
<p>Leveraging the prior knowledge that certain relation types in the Atomic knowledge graph are linked to each other, we explore providing these group identities as additional tokens in the relation. For example, when generating the completion of a xReact relation, the model would receive as input the following meta-tokens: <xReact>, <X>, <POST>, <Involuntary> - thereby providing common context with other relations that are part of the same groupings (e.g.,
generating a phrase for a xWant relation would receive the $&lt;\mathrm{X}&gt;$ and <POST> tokens as input, but not <Involuntary>). Depending on the relation for a particular training example (e.g., xReact), a set of meta-tokens are appended to the relation tokens, $X^{r}$, that provide hierarchical relational information, allowing the model to share information across relation types. We provide a more in-depth description of the category hierarchy training combinations in Table 10. Results on human evaluation metrics are provided in Table 12. Because the model with the hierarchical meta-tokens performed worse than the regular COMET, we did not run additional experiments on this ablations.</p>
<p><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 5: Example outputs for the event "PersonX gives PersonY a pep talk" from COMET trained on the ATOMIC knowledge graph</p>
<p><img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 6: Example outputs for the event "Eric wants to see a movie" from COMET trained on the ATOMIC knowledge graph. COMET is able to generalize beyond the templates of the ATOMIC knowledge graph (i.e., PersonX) and can be used directly with names.</p>
<p><img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>Figure 7: Example outputs for the event "Tom asked Jessica if he could use her car" from COMET trained on the ATOMIC knowledge graph</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Event</th>
<th style="text-align: center;">Description</th>
<th style="text-align: center;">Example Completion:</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Person X puts Person X's trust in Person Y</td>
</tr>
<tr>
<td style="text-align: center;">oEffect</td>
<td style="text-align: center;">The effect the event has on others besides Person X</td>
<td style="text-align: center;">is considered trustworthy <br> is believed <br> gains Person X's loyalty</td>
</tr>
<tr>
<td style="text-align: center;">oReact</td>
<td style="text-align: center;">The reaction of others besides Person X to the event</td>
<td style="text-align: center;">trusted <br> honored <br> trustworthy</td>
</tr>
<tr>
<td style="text-align: center;">oWant</td>
<td style="text-align: center;">What others besides Person X may want to do after the event</td>
<td style="text-align: center;">work with Person X partner with Person X to help Person X</td>
</tr>
<tr>
<td style="text-align: center;">xAttr</td>
<td style="text-align: center;">How Person X might be described given their part in the event</td>
<td style="text-align: center;">faithful <br> hopeful <br> trusting</td>
</tr>
<tr>
<td style="text-align: center;">xEffect</td>
<td style="text-align: center;">The effect that the event would have on Person X</td>
<td style="text-align: center;">gets relieved <br> stays faithful <br> Is betrayed</td>
</tr>
<tr>
<td style="text-align: center;">xIntent</td>
<td style="text-align: center;">The reason why X would cause the event</td>
<td style="text-align: center;">to be trusting his or her help/guidance/advice to be friends</td>
</tr>
<tr>
<td style="text-align: center;">xNeed</td>
<td style="text-align: center;">What Person X might need to do before the event</td>
<td style="text-align: center;">to be friends with Person Y to have heard a lot of good things about Person Y <br> to get to know Person Y</td>
</tr>
<tr>
<td style="text-align: center;">xReact</td>
<td style="text-align: center;">The reaction that Person X would have to the event</td>
<td style="text-align: center;">trusting <br> safe, not alone <br> understood</td>
</tr>
<tr>
<td style="text-align: center;">xWant</td>
<td style="text-align: center;">What Person X may want to do after the event</td>
<td style="text-align: center;">to rely on Person Y to go into business with Person Y to make sure that their heart feeling is right</td>
</tr>
</tbody>
</table>
<p>Table 8: Definitions of the relations in Atomic. Events in Atomic center around the personal situations of a central figure, Person X, with potentially more participants.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Organization</th>
<th style="text-align: center;">Description</th>
<th style="text-align: center;">Relations</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">PERSON <br> X/Y</td>
<td style="text-align: center;">The training set is split into relations for the subjects of the event (Person X) and relations for other participants in the event</td>
<td style="text-align: center;">$T_{1}={$ xAttr, xEffect, xIntent, xNeed, xReact, xWant $}$ <br> $T_{2}={$ oEffect, oReact, oWant $}$</td>
</tr>
<tr>
<td style="text-align: center;">Pre/Post</td>
<td style="text-align: center;">Event preconditions are jointly trained (i.e., intentions, needs). Event postconditions are jointly trained.</td>
<td style="text-align: center;">$T_{1}={$ xIntent, xNeed $}$ <br> $T_{2}={$ oEffect, oReact, oWant, <br> xEffect, xReact, xWant $}$</td>
</tr>
<tr>
<td style="text-align: center;">(IN) VOLUN</td>
<td style="text-align: center;">Involuntary relations are trained jointly, such as reactions and effects. Voluntary relations are trained jointly, such as needs, wants, and intents.</td>
<td style="text-align: center;">$T_{1}={$ oWant, xIntent, xNeed, xWant $}$ <br> $T_{2}={$ oEffect, oReact, xAttr, <br> xEffect, xReact $}$</td>
</tr>
<tr>
<td style="text-align: center;">Full</td>
<td style="text-align: center;">The training set is made up of all relations and the model is trained jointly on all of them</td>
<td style="text-align: center;">$T_{1}={$ oEffect, oReact, oWant, xAttr, xEffect, xIntent, xNeed, xReact, xWant $}$</td>
</tr>
</tbody>
</table>
<p>Table 9: Multi-relation training setups. Following Sap et al. (2019), the xAttr relation is not included in the Pre/Post training configuration</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Meta-Token</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Relations</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">$&lt;\mathrm{X}&gt;$</td>
<td style="text-align: left;">Appended to relations that describe an <br> attribute of Person X</td>
<td style="text-align: left;">xAttr, xEffect, xIntent, xNeed, <br> xReact, xWant</td>
</tr>
<tr>
<td style="text-align: left;">$&lt;\mathrm{Y}&gt;$</td>
<td style="text-align: left;">Appended to relations that describes an <br> attribute of a participant that is not Per- <br> son X</td>
<td style="text-align: left;">oEffect, oReact, oWant</td>
</tr>
<tr>
<td style="text-align: left;">$&lt;$ Pre&gt;</td>
<td style="text-align: left;">Appended to relations that correspond <br> to pre-conditions of the event</td>
<td style="text-align: left;">xIntent, xNeed</td>
</tr>
<tr>
<td style="text-align: left;">$&lt;$ Post&gt;</td>
<td style="text-align: left;">Appended to relations that correspond <br> to post-conditions of the event</td>
<td style="text-align: left;">oEffect, oReact, oWant, <br> xEffect, xReact, xWant</td>
</tr>
<tr>
<td style="text-align: left;"><Voluntary></td>
<td style="text-align: left;">Appended to relations that correspond <br> to voluntary dimensions of the situation</td>
<td style="text-align: left;">oWant, xIntent, xNeed, xWant</td>
</tr>
<tr>
<td style="text-align: left;"><Involuntary></td>
<td style="text-align: left;">Appended to relations that correspond <br> to involuntary dimensions of the situa- <br> tion</td>
<td style="text-align: left;">oEffect, oReact, xAttr, <br> xEffect, xReact</td>
</tr>
</tbody>
</table>
<p>Table 10: Category hierarchy meta-tokens, along with the description and the relations to which they are appended</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: center;">PPL $^{3}$</th>
<th style="text-align: center;">BLEU-2</th>
<th style="text-align: center;">N/T sro $^{4}$</th>
<th style="text-align: center;">N/T o</th>
<th style="text-align: center;">N/U o</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">COMET- 9LM</td>
<td style="text-align: center;">11.72</td>
<td style="text-align: center;">14.89</td>
<td style="text-align: center;">100.00</td>
<td style="text-align: center;">9.45</td>
<td style="text-align: center;">49.89</td>
</tr>
<tr>
<td style="text-align: left;">COMET- (IN)VOLUN</td>
<td style="text-align: center;">11.38</td>
<td style="text-align: center;">14.99</td>
<td style="text-align: center;">100.00</td>
<td style="text-align: center;">8.60</td>
<td style="text-align: center;">48.36</td>
</tr>
<tr>
<td style="text-align: left;">COMET- PERSONX/Y</td>
<td style="text-align: center;">11.30</td>
<td style="text-align: center;">15.21</td>
<td style="text-align: center;">100.00</td>
<td style="text-align: center;">9.12</td>
<td style="text-align: center;">49.59</td>
</tr>
<tr>
<td style="text-align: left;">COMET- PRE/POST</td>
<td style="text-align: center;">11.35</td>
<td style="text-align: center;">14.88</td>
<td style="text-align: center;">100.00</td>
<td style="text-align: center;">9.86</td>
<td style="text-align: center;">51.86</td>
</tr>
<tr>
<td style="text-align: left;">COMET- FULL (- pretrain)</td>
<td style="text-align: center;">15.42</td>
<td style="text-align: center;">13.88</td>
<td style="text-align: center;">100.00</td>
<td style="text-align: center;">7.25</td>
<td style="text-align: center;">45.71</td>
</tr>
<tr>
<td style="text-align: left;">COMET- FULL</td>
<td style="text-align: center;">11.14</td>
<td style="text-align: center;">15.10</td>
<td style="text-align: center;">100.00</td>
<td style="text-align: center;">9.71</td>
<td style="text-align: center;">51.20</td>
</tr>
<tr>
<td style="text-align: left;">COMET- FULL (+ hierarchy meta-tokens)</td>
<td style="text-align: center;">$\mathbf{1 0 . 9 8}$</td>
<td style="text-align: center;">$\mathbf{1 5 . 2 7}$</td>
<td style="text-align: center;">100.00</td>
<td style="text-align: center;">$\mathbf{1 0 . 0 3}$</td>
<td style="text-align: center;">$\mathbf{5 1 . 9 7}$</td>
</tr>
</tbody>
</table>
<p>Table 11: Automatic evaluations of quality and novelty for generations of ATOMIC commonsense that are trained with the training set split along different relation types. The training splits are outlined in Table 9.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: right;">oEffect</th>
<th style="text-align: right;">oReact</th>
<th style="text-align: right;">oWant</th>
<th style="text-align: right;">xAttr</th>
<th style="text-align: right;">xEffect</th>
<th style="text-align: right;">xIntent</th>
<th style="text-align: right;">xNeed</th>
<th style="text-align: right;">xReact</th>
<th style="text-align: right;">xWant</th>
<th style="text-align: right;">Total</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">COMET</td>
<td style="text-align: right;">$\mathbf{2 9 . 0 2}$</td>
<td style="text-align: right;">37.68</td>
<td style="text-align: right;">$\mathbf{4 4 . 4 8}$</td>
<td style="text-align: right;">$\mathbf{5 7 . 4 8}$</td>
<td style="text-align: right;">$\mathbf{5 5 . 5 0}$</td>
<td style="text-align: right;">$\mathbf{6 8 . 3 2}$</td>
<td style="text-align: right;">$\mathbf{6 4 . 2 4}$</td>
<td style="text-align: right;">$\mathbf{7 6 . 1 8}$</td>
<td style="text-align: right;">75.16</td>
<td style="text-align: right;">$\mathbf{5 6 . 4 5}$</td>
</tr>
<tr>
<td style="text-align: left;">COMET (+ hierarchy meta-tokens)</td>
<td style="text-align: right;">28.46</td>
<td style="text-align: right;">$\mathbf{3 8 . 9 6}$</td>
<td style="text-align: right;">43.64</td>
<td style="text-align: right;">51.90</td>
<td style="text-align: right;">50.84</td>
<td style="text-align: right;">63.00</td>
<td style="text-align: right;">63.98</td>
<td style="text-align: right;">66.20</td>
<td style="text-align: right;">$\mathbf{7 5 . 8 2}$</td>
<td style="text-align: right;">53.64</td>
</tr>
</tbody>
</table>
<p>Table 12: Human score of generations of ATOMIC commonsense for the regular COMET model and the COMET + category meta tokens</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>Demo is available at https://mosaickg.apps.allenai.org/&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>Code is available at https://github.com/atcbosselut/comet-commonsense&#160;<a class="footnote-backref" href="#fnref:2" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:0">
<p>${ }^{1}$ https://fasttext.cc/&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 3 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 3 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 3 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 3 in the text">&#8617;</a><a class="footnote-backref" href="#fnref5:0" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>