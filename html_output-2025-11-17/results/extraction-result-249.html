<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-249 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-249</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-249</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-14.html">extraction-schema-14</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic operations, including the types of arithmetic tasks, model properties, performance results, methods used, and any mechanistic insights about how the models solve arithmetic problems.</div>
                <p><strong>Paper ID:</strong> paper-260378835</p>
                <p><strong>Paper Title:</strong> <a href="https://export.arxiv.org/pdf/2308.01154v4.pdf" target="_blank">Arithmetic with Language Models: from Memorization to Computation</a></p>
                <p><strong>Paper Abstract:</strong> A better understanding of the emergent computation and problem-solving capabilities of recent large language models is of paramount importance to further improve them and broaden their applicability. This work investigates how a language model, trained to predict the next token, can perform arithmetic computations generalizing beyond training data. Binary addition and multiplication constitute a good testbed for this purpose, since they require a very small vocabulary and exhibit relevant input/output discontinuities making smooth input interpolation ineffective for novel data. We successfully trained a light language model to learn these tasks and ran a number of experiments to investigate the extrapolation capabilities and internal information processing. Our findings support the hypothesis that the language model works as an Encoding-Regression-Decoding machine where the computation takes place in the value space once the input token representation is mapped to an appropriate internal representation.</p>
                <p><strong>Cost:</strong> 0.012</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e249.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e249.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic operations, including the types of arithmetic tasks, model properties, performance results, methods used, and any mechanistic insights about how the models solve arithmetic problems.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>SmallEncDec-701K</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Small encoder-decoder Transformer trained from scratch (701K parameters)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A non-pretrained, small encoder-decoder Transformer (d_model=64, 6 encoder + 6 decoder layers, learned token embeddings, sinusoidal positional encodings) trained from scratch on exhaustive 7-bit binary addition and multiplication examples to investigate arithmetic computation and internal mechanisms.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Encoder-Decoder Transformer (this work)</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>701K</td>
                        </tr>
                        <tr>
                            <td><strong>model_architecture</strong></td>
                            <td>encoder-decoder transformer</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_operation_type</strong></td>
                            <td>binary addition and binary multiplication</td>
                        </tr>
                        <tr>
                            <td><strong>number_range_or_complexity</strong></td>
                            <td>operands A,B in [0,127] (7-bit binary), exhaustive 2^14 input/output combinations</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_intervention</strong></td>
                            <td>trained from scratch (no pretraining) on exhaustive dataset (12288 train / 4096 validation), fixed-length prompts with LSB-first (reverse/little-endian) representation, learned token embeddings, sinusoidal positional encoding, CrossEntropy loss, Adam optimizer, greedy decoding</td>
                        </tr>
                        <tr>
                            <td><strong>performance_result</strong></td>
                            <td>Addition: converged <50 epochs with essentially 100% sequence accuracy on train/validation (MAE=0 on validation). Multiplication: converged ≈250 epochs with near-perfect generalization (validation MAE ≈1.3; sequence accuracy close to 100%). In a control random-output task, memorization reached only 87.8% sequence accuracy on training after 1000 epochs with no validation improvement.</td>
                        </tr>
                        <tr>
                            <td><strong>mechanistic_insight</strong></td>
                            <td>Evidence supports an Encoding-Regression-Decoding (ERD) mechanism: input tokens are encoded into internal 'value' vectors, a regression-like computation is performed in that value space (central decoder layers), and outputs are decoded back to tokens; encoder layers show little computation role, decoder middle layers correlate with value-space distances, and ablating value information at decoder layer 3 (amnesic probing) collapses performance.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_scaling</strong></td>
                            <td>Performance degrades with operation complexity: multiplication requires substantially more training steps and has higher MAE than addition. Generalization depends on coverage of the value space (excluded contiguous value regions cause ~4–6 percentage point drop in sequence accuracy).</td>
                        </tr>
                        <tr>
                            <td><strong>failure_modes</strong></td>
                            <td>Poor extrapolation to validation regions excluded from the training set in value space (VS_v); multiplication harder to learn (slower convergence, higher residual error), the model approximates mappings piecewise which introduces discontinuities.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Compared against: (i) random-output control (memorization vs algorithmic/generalization), (ii) VS_t (token-space holdout) vs VS_v (value-space holdout) splits to probe interpolation vs extrapolation, (iii) ablated architectures with encoder squeezed/removed and other component removals.</td>
                        </tr>
                        <tr>
                            <td><strong>key_finding</strong></td>
                            <td>A small encoder-decoder Transformer can learn 7-bit binary addition and multiplication not by memorization but by learning an internal token→value encoding, performing regression-like computation in the value space (central decoder layers), and decoding back to tokens; generalization depends on training coverage of that value space.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Arithmetic with Language Models: from Memorization to Computation', 'publication_date_yy_mm': '2023-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e249.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e249.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic operations, including the types of arithmetic tasks, model properties, performance results, methods used, and any mechanistic insights about how the models solve arithmetic problems.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>nanoGPT-298K</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>nanoGPT decoder-only model (used as a second LM, 298K parameters)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A lightweight decoder-only GPT-style model (nanoGPT) used to replicate the main experiments and validate that findings generalize beyond the encoder-decoder architecture.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>nanoGPT (decoder-only) (this work)</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>298K</td>
                        </tr>
                        <tr>
                            <td><strong>model_architecture</strong></td>
                            <td>decoder-only transformer</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_operation_type</strong></td>
                            <td>binary addition and binary multiplication</td>
                        </tr>
                        <tr>
                            <td><strong>number_range_or_complexity</strong></td>
                            <td>operands A,B in [0,127] (7-bit binary), same exhaustive dataset setup</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_intervention</strong></td>
                            <td>trained from scratch on same dataset and representation (reverse LSB-first), CrossEntropy loss, AdamW optimizer (lr=0.001), greedy decoding</td>
                        </tr>
                        <tr>
                            <td><strong>performance_result</strong></td>
                            <td>Learned addition and multiplication efficiently; with random split reaches near-100% sequence accuracy. For VS_t (token-space holdout) it reaches ∼100% (addition) and 99.9% (multiplication); for VS_v (value-space holdout) performance drops substantially to ~82.0% (addition) and ~80.6% (multiplication), showing stronger sensitivity to value-space extrapolation than the encoder-decoder model.</td>
                        </tr>
                        <tr>
                            <td><strong>mechanistic_insight</strong></td>
                            <td>Replicates ERD-style evidence: token→value encoding and a regressor-like computation in internal representations; shows similar decoder-layer behavior and extrapolation sensitivity, supporting that the ERD phenomenon is architecture-agnostic (encoder-decoder vs decoder-only).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_scaling</strong></td>
                            <td>Same qualitative scaling: multiplication is harder and extrapolation failure to unseen value regions larger in magnitude (≈18–19% drop for VS_v), indicating sensitivity to value-space coverage rather than token-space coverage.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_modes</strong></td>
                            <td>Significant drop when validation excludes contiguous value-space region (VS_v). Multiplication shows more pronounced errors and slower learning.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Compared against encoder-decoder Transformer results (architecture ablation) and same VS_t / VS_v splits; ablation and control experiments mirrored those in the main model.</td>
                        </tr>
                        <tr>
                            <td><strong>key_finding</strong></td>
                            <td>A decoder-only GPT-style model reproduces the same ERD-like arithmetic solution and same vulnerability to value-space extrapolation, indicating the mechanism is not specific to encoder-decoder architectures.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Arithmetic with Language Models: from Memorization to Computation', 'publication_date_yy_mm': '2023-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e249.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e249.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic operations, including the types of arithmetic tasks, model properties, performance results, methods used, and any mechanistic insights about how the models solve arithmetic problems.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>ERD-hypothesis</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Encoding–Regression–Decoding (ERD) hypothesis</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A mechanistic hypothesis that LMs solve arithmetic by: (1) encoding token sequences into continuous value/magnitude vectors, (2) performing regression-like computations in that internal value space, and (3) decoding value vectors back to token outputs.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>applies to Transformers studied in this work</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_architecture</strong></td>
                            <td>proposed mechanism for transformer LMs (encoder-decoder and decoder-only)</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_operation_type</strong></td>
                            <td>general (demonstrated on binary addition and multiplication)</td>
                        </tr>
                        <tr>
                            <td><strong>number_range_or_complexity</strong></td>
                            <td>demonstrated on 7-bit operands (0–127), concept generalized to other numeric tasks in discussion</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_intervention</strong></td>
                            <td>inferred/validated via experiments: exhaustive training, interpolation vs extrapolation splits (VS_t vs VS_v), correlation analyses between token/value distances and intermediate embeddings, and amnesic probing</td>
                        </tr>
                        <tr>
                            <td><strong>performance_result</strong></td>
                            <td>Not a performance metric but a description of how near-perfect performance arises: when training covers value space, model achieves near-100% sequence accuracy; when value-space coverage omitted, performance drops, consistent with regression behavior.</td>
                        </tr>
                        <tr>
                            <td><strong>mechanistic_insight</strong></td>
                            <td>Core claim: LM learns token→value encoding in early/final decoder layers, central decoder layers implement a multi-layer regressor operating in value space; evidence includes: (i) decoder-layer distance correlations switch from token-like to value-like in middle layers, (ii) linear probes on decoder layer 3 predict numeric outputs with low RMSE (0.28), (iii) amnesic projection removing value-subspace kills performance, (iv) encoder layers show limited transformation role.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_scaling</strong></td>
                            <td>Explains scaling with difficulty: tasks that map to smooth continuous functions (e.g., sine) are easier to learn as regressors; non-smooth/discontinuous mappings (carries, multiplication) require more capacity/training and yield piecewise approximations.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_modes</strong></td>
                            <td>Predicts failure when models are asked to extrapolate to value-space regions not represented in training (numerical regressors generalization limits) and piecewise approximations introduce discontinuities for highly nonlinear mappings (multiplication).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Contrasts with a pure Symbolic Manipulation (SM) hypothesis (i.e., learning explicit discrete algorithms like ALU operations); ERD is supported by observed continuous-value representations, correlation patterns, and amnesic probing results.</td>
                        </tr>
                        <tr>
                            <td><strong>key_finding</strong></td>
                            <td>LMs can implement arithmetic by learning continuous value encodings and a regressor operating in that value space (ERD), rather than necessarily learning explicit symbolic algorithms or exhaustive memorization; this explains both strong generalization when value-space is covered and failures when extrapolating in value-space.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Arithmetic with Language Models: from Memorization to Computation', 'publication_date_yy_mm': '2023-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e249.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e249.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic operations, including the types of arithmetic tasks, model properties, performance results, methods used, and any mechanistic insights about how the models solve arithmetic problems.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>AmnesicProbing-Decoder3</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Amnesic probing on decoder-layer 3 embeddings</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A causal-style intervention that trains a linear probe to predict numeric output from decoder-layer 3 embeddings, computes the probe nullspace to remove value-related directions, and measures the impact on model behavior when projected embeddings replace originals.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>amnesic probing applied to decoder layer 3 of the trained Transformer (this work)</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_architecture</strong></td>
                            <td>method applied to encoder-decoder Transformer and conceptually to decoder-only model</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_operation_type</strong></td>
                            <td>binary addition (experiment reported); supports mechanistic claims for other arithmetic tasks</td>
                        </tr>
                        <tr>
                            <td><strong>number_range_or_complexity</strong></td>
                            <td>applied to 7-bit operands (A,B in [0,127])</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_intervention</strong></td>
                            <td>train simple linear regressor on dec3 embeddings to predict numeric output (X+Y), compute nullspace of regressor, project embeddings to nullspace (repeated twice), overwrite decoder-layer 3 embeddings and forward-pass to measure effect</td>
                        </tr>
                        <tr>
                            <td><strong>performance_result</strong></td>
                            <td>Linear regressor on dec3 achieves RMSE = 0.28 predicting X+Y. After projecting out value-related directions and overwriting dec3 embeddings, sequence accuracy for addition drops from 100% to 0.13%. Control projection along random directions of same dimensionality leaves accuracy at 100%.</td>
                        </tr>
                        <tr>
                            <td><strong>mechanistic_insight</strong></td>
                            <td>Direct causal evidence that value information encoded in decoder middle layers is necessary for correct numeric computation; removing the value subspace specifically (not arbitrary information) collapses arithmetic capability, supporting that central decoder embeddings carry the regressor-relevant value representation.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_scaling</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>failure_modes</strong></td>
                            <td>Demonstrates catastrophic failure (near-zero accuracy) when value subspace is removed; shows sensitivity to targeted removal but robustness to random-direction removal.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Control projection removing same amount of information along random directions (no effect) vs targeted removal via probe nullspace (severe effect).</td>
                        </tr>
                        <tr>
                            <td><strong>key_finding</strong></td>
                            <td>Amnesic probing provides causal evidence that removing value-related directions from intermediate decoder embeddings eliminates the model's ability to perform addition, supporting the ERD mechanistic account.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Arithmetic with Language Models: from Memorization to Computation', 'publication_date_yy_mm': '2023-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>How well do Large Language Models perform in Arithmetic tasks <em>(Rating: 2)</em></li>
                <li>Teaching Arithmetic to Small Transformers <em>(Rating: 2)</em></li>
                <li>Goat: Fine-tuned LLaMA Outperforms GPT-4 on Arithmetic Tasks <em>(Rating: 1)</em></li>
                <li>A Mechanistic Interpretation of Arithmetic Reasoning in Language Models using Causal Mediation Analysis <em>(Rating: 2)</em></li>
                <li>Progress measures for grokking via mechanistic interpretability <em>(Rating: 1)</em></li>
                <li>Amnesic Probing: Behavioral Explanation with Amnesic Counterfactuals <em>(Rating: 2)</em></li>
                <li>Do NLP Models Know Numbers? Probing Numeracy in Embeddings <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-249",
    "paper_id": "paper-260378835",
    "extraction_schema_id": "extraction-schema-14",
    "extracted_data": [
        {
            "name_short": "SmallEncDec-701K",
            "name_full": "Small encoder-decoder Transformer trained from scratch (701K parameters)",
            "brief_description": "A non-pretrained, small encoder-decoder Transformer (d_model=64, 6 encoder + 6 decoder layers, learned token embeddings, sinusoidal positional encodings) trained from scratch on exhaustive 7-bit binary addition and multiplication examples to investigate arithmetic computation and internal mechanisms.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "Encoder-Decoder Transformer (this work)",
            "model_size": "701K",
            "model_architecture": "encoder-decoder transformer",
            "arithmetic_operation_type": "binary addition and binary multiplication",
            "number_range_or_complexity": "operands A,B in [0,127] (7-bit binary), exhaustive 2^14 input/output combinations",
            "method_or_intervention": "trained from scratch (no pretraining) on exhaustive dataset (12288 train / 4096 validation), fixed-length prompts with LSB-first (reverse/little-endian) representation, learned token embeddings, sinusoidal positional encoding, CrossEntropy loss, Adam optimizer, greedy decoding",
            "performance_result": "Addition: converged &lt;50 epochs with essentially 100% sequence accuracy on train/validation (MAE=0 on validation). Multiplication: converged ≈250 epochs with near-perfect generalization (validation MAE ≈1.3; sequence accuracy close to 100%). In a control random-output task, memorization reached only 87.8% sequence accuracy on training after 1000 epochs with no validation improvement.",
            "mechanistic_insight": "Evidence supports an Encoding-Regression-Decoding (ERD) mechanism: input tokens are encoded into internal 'value' vectors, a regression-like computation is performed in that value space (central decoder layers), and outputs are decoded back to tokens; encoder layers show little computation role, decoder middle layers correlate with value-space distances, and ablating value information at decoder layer 3 (amnesic probing) collapses performance.",
            "performance_scaling": "Performance degrades with operation complexity: multiplication requires substantially more training steps and has higher MAE than addition. Generalization depends on coverage of the value space (excluded contiguous value regions cause ~4–6 percentage point drop in sequence accuracy).",
            "failure_modes": "Poor extrapolation to validation regions excluded from the training set in value space (VS_v); multiplication harder to learn (slower convergence, higher residual error), the model approximates mappings piecewise which introduces discontinuities.",
            "comparison_baseline": "Compared against: (i) random-output control (memorization vs algorithmic/generalization), (ii) VS_t (token-space holdout) vs VS_v (value-space holdout) splits to probe interpolation vs extrapolation, (iii) ablated architectures with encoder squeezed/removed and other component removals.",
            "key_finding": "A small encoder-decoder Transformer can learn 7-bit binary addition and multiplication not by memorization but by learning an internal token→value encoding, performing regression-like computation in the value space (central decoder layers), and decoding back to tokens; generalization depends on training coverage of that value space.",
            "uuid": "e249.0",
            "source_info": {
                "paper_title": "Arithmetic with Language Models: from Memorization to Computation",
                "publication_date_yy_mm": "2023-08"
            }
        },
        {
            "name_short": "nanoGPT-298K",
            "name_full": "nanoGPT decoder-only model (used as a second LM, 298K parameters)",
            "brief_description": "A lightweight decoder-only GPT-style model (nanoGPT) used to replicate the main experiments and validate that findings generalize beyond the encoder-decoder architecture.",
            "citation_title": "",
            "mention_or_use": "use",
            "model_name": "nanoGPT (decoder-only) (this work)",
            "model_size": "298K",
            "model_architecture": "decoder-only transformer",
            "arithmetic_operation_type": "binary addition and binary multiplication",
            "number_range_or_complexity": "operands A,B in [0,127] (7-bit binary), same exhaustive dataset setup",
            "method_or_intervention": "trained from scratch on same dataset and representation (reverse LSB-first), CrossEntropy loss, AdamW optimizer (lr=0.001), greedy decoding",
            "performance_result": "Learned addition and multiplication efficiently; with random split reaches near-100% sequence accuracy. For VS_t (token-space holdout) it reaches ∼100% (addition) and 99.9% (multiplication); for VS_v (value-space holdout) performance drops substantially to ~82.0% (addition) and ~80.6% (multiplication), showing stronger sensitivity to value-space extrapolation than the encoder-decoder model.",
            "mechanistic_insight": "Replicates ERD-style evidence: token→value encoding and a regressor-like computation in internal representations; shows similar decoder-layer behavior and extrapolation sensitivity, supporting that the ERD phenomenon is architecture-agnostic (encoder-decoder vs decoder-only).",
            "performance_scaling": "Same qualitative scaling: multiplication is harder and extrapolation failure to unseen value regions larger in magnitude (≈18–19% drop for VS_v), indicating sensitivity to value-space coverage rather than token-space coverage.",
            "failure_modes": "Significant drop when validation excludes contiguous value-space region (VS_v). Multiplication shows more pronounced errors and slower learning.",
            "comparison_baseline": "Compared against encoder-decoder Transformer results (architecture ablation) and same VS_t / VS_v splits; ablation and control experiments mirrored those in the main model.",
            "key_finding": "A decoder-only GPT-style model reproduces the same ERD-like arithmetic solution and same vulnerability to value-space extrapolation, indicating the mechanism is not specific to encoder-decoder architectures.",
            "uuid": "e249.1",
            "source_info": {
                "paper_title": "Arithmetic with Language Models: from Memorization to Computation",
                "publication_date_yy_mm": "2023-08"
            }
        },
        {
            "name_short": "ERD-hypothesis",
            "name_full": "Encoding–Regression–Decoding (ERD) hypothesis",
            "brief_description": "A mechanistic hypothesis that LMs solve arithmetic by: (1) encoding token sequences into continuous value/magnitude vectors, (2) performing regression-like computations in that internal value space, and (3) decoding value vectors back to token outputs.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "applies to Transformers studied in this work",
            "model_size": null,
            "model_architecture": "proposed mechanism for transformer LMs (encoder-decoder and decoder-only)",
            "arithmetic_operation_type": "general (demonstrated on binary addition and multiplication)",
            "number_range_or_complexity": "demonstrated on 7-bit operands (0–127), concept generalized to other numeric tasks in discussion",
            "method_or_intervention": "inferred/validated via experiments: exhaustive training, interpolation vs extrapolation splits (VS_t vs VS_v), correlation analyses between token/value distances and intermediate embeddings, and amnesic probing",
            "performance_result": "Not a performance metric but a description of how near-perfect performance arises: when training covers value space, model achieves near-100% sequence accuracy; when value-space coverage omitted, performance drops, consistent with regression behavior.",
            "mechanistic_insight": "Core claim: LM learns token→value encoding in early/final decoder layers, central decoder layers implement a multi-layer regressor operating in value space; evidence includes: (i) decoder-layer distance correlations switch from token-like to value-like in middle layers, (ii) linear probes on decoder layer 3 predict numeric outputs with low RMSE (0.28), (iii) amnesic projection removing value-subspace kills performance, (iv) encoder layers show limited transformation role.",
            "performance_scaling": "Explains scaling with difficulty: tasks that map to smooth continuous functions (e.g., sine) are easier to learn as regressors; non-smooth/discontinuous mappings (carries, multiplication) require more capacity/training and yield piecewise approximations.",
            "failure_modes": "Predicts failure when models are asked to extrapolate to value-space regions not represented in training (numerical regressors generalization limits) and piecewise approximations introduce discontinuities for highly nonlinear mappings (multiplication).",
            "comparison_baseline": "Contrasts with a pure Symbolic Manipulation (SM) hypothesis (i.e., learning explicit discrete algorithms like ALU operations); ERD is supported by observed continuous-value representations, correlation patterns, and amnesic probing results.",
            "key_finding": "LMs can implement arithmetic by learning continuous value encodings and a regressor operating in that value space (ERD), rather than necessarily learning explicit symbolic algorithms or exhaustive memorization; this explains both strong generalization when value-space is covered and failures when extrapolating in value-space.",
            "uuid": "e249.2",
            "source_info": {
                "paper_title": "Arithmetic with Language Models: from Memorization to Computation",
                "publication_date_yy_mm": "2023-08"
            }
        },
        {
            "name_short": "AmnesicProbing-Decoder3",
            "name_full": "Amnesic probing on decoder-layer 3 embeddings",
            "brief_description": "A causal-style intervention that trains a linear probe to predict numeric output from decoder-layer 3 embeddings, computes the probe nullspace to remove value-related directions, and measures the impact on model behavior when projected embeddings replace originals.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "amnesic probing applied to decoder layer 3 of the trained Transformer (this work)",
            "model_size": null,
            "model_architecture": "method applied to encoder-decoder Transformer and conceptually to decoder-only model",
            "arithmetic_operation_type": "binary addition (experiment reported); supports mechanistic claims for other arithmetic tasks",
            "number_range_or_complexity": "applied to 7-bit operands (A,B in [0,127])",
            "method_or_intervention": "train simple linear regressor on dec3 embeddings to predict numeric output (X+Y), compute nullspace of regressor, project embeddings to nullspace (repeated twice), overwrite decoder-layer 3 embeddings and forward-pass to measure effect",
            "performance_result": "Linear regressor on dec3 achieves RMSE = 0.28 predicting X+Y. After projecting out value-related directions and overwriting dec3 embeddings, sequence accuracy for addition drops from 100% to 0.13%. Control projection along random directions of same dimensionality leaves accuracy at 100%.",
            "mechanistic_insight": "Direct causal evidence that value information encoded in decoder middle layers is necessary for correct numeric computation; removing the value subspace specifically (not arbitrary information) collapses arithmetic capability, supporting that central decoder embeddings carry the regressor-relevant value representation.",
            "performance_scaling": null,
            "failure_modes": "Demonstrates catastrophic failure (near-zero accuracy) when value subspace is removed; shows sensitivity to targeted removal but robustness to random-direction removal.",
            "comparison_baseline": "Control projection removing same amount of information along random directions (no effect) vs targeted removal via probe nullspace (severe effect).",
            "key_finding": "Amnesic probing provides causal evidence that removing value-related directions from intermediate decoder embeddings eliminates the model's ability to perform addition, supporting the ERD mechanistic account.",
            "uuid": "e249.3",
            "source_info": {
                "paper_title": "Arithmetic with Language Models: from Memorization to Computation",
                "publication_date_yy_mm": "2023-08"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "How well do Large Language Models perform in Arithmetic tasks",
            "rating": 2,
            "sanitized_title": "how_well_do_large_language_models_perform_in_arithmetic_tasks"
        },
        {
            "paper_title": "Teaching Arithmetic to Small Transformers",
            "rating": 2,
            "sanitized_title": "teaching_arithmetic_to_small_transformers"
        },
        {
            "paper_title": "Goat: Fine-tuned LLaMA Outperforms GPT-4 on Arithmetic Tasks",
            "rating": 1,
            "sanitized_title": "goat_finetuned_llama_outperforms_gpt4_on_arithmetic_tasks"
        },
        {
            "paper_title": "A Mechanistic Interpretation of Arithmetic Reasoning in Language Models using Causal Mediation Analysis",
            "rating": 2,
            "sanitized_title": "a_mechanistic_interpretation_of_arithmetic_reasoning_in_language_models_using_causal_mediation_analysis"
        },
        {
            "paper_title": "Progress measures for grokking via mechanistic interpretability",
            "rating": 1,
            "sanitized_title": "progress_measures_for_grokking_via_mechanistic_interpretability"
        },
        {
            "paper_title": "Amnesic Probing: Behavioral Explanation with Amnesic Counterfactuals",
            "rating": 2,
            "sanitized_title": "amnesic_probing_behavioral_explanation_with_amnesic_counterfactuals"
        },
        {
            "paper_title": "Do NLP Models Know Numbers? Probing Numeracy in Embeddings",
            "rating": 1,
            "sanitized_title": "do_nlp_models_know_numbers_probing_numeracy_in_embeddings"
        }
    ],
    "cost": 0.011666,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>Arithmetic with Language Models: from Memorization to Computation ⋆
August 5, 2024</p>
<p>Davide Maltoni 
Department of computer science and engineering
University of Bologna
Italy</p>
<p>Matteo Ferrara 
Department of computer science and engineering
University of Bologna
Italy</p>
<p>Arithmetic with Language Models: from Memorization to Computation ⋆
August 5, 20246DEE070676EDA0FE16EEB276794449DBarXiv:2308.01154v4[cs.AI]⋆ The article has been accepted for publication in Elsevier Neural Networks journal. The final version is available on the Elsevier ScienceDirect platform. Preprint submitted to Neural NetworksLanguage ModelsAI ExplainabilityProbingInterpretabilityArithmetic
A better understanding of the emergent computation and problem-solving capabilities of recent large language models is of paramount importance to further improve them and broaden their applicability.This work investigates how a language model, trained to predict the next token, can perform arithmetic computations generalizing beyond training data.Binary addition and multiplication constitute a good testbed for this purpose, since they require a very small vocabulary and exhibit relevant input/output discontinuities making smooth input interpolation ineffective for novel data.We successfully trained a light language model to learn these tasks and ran a number of experiments to investigate the extrapolation capabilities and internal information processing.Our findings support the hypothesis that the language model works as an Encoding-Regression-Decoding machine where the computation takes place in the value space once the input token representation is mapped to an appropriate internal representation.</p>
<p>Introduction</p>
<p>Large Language Models (LLMs) based on Transformer architecture (Vaswani et al., 2017) have recently demonstrated surprising problem-solving capabilities that require logic reasoning, advanced information processing and common sense (Bubeck et al., 2023;Wei et al., 2023Wei et al., , 2022)).Their huge storage capacity combined with a massive training on terabytes of heterogeneous data could suggest that the memorization of an enormous amount of knowledge is enough to perform well on similar test data.However, validations on carefully selected Outof-Distribution (OoD) data proved their reasoning capabilities on novel examples requiring nontrivial generalizations.Unfortunately, the depth and width of such models is so high that decoding and understanding the internal information processing is very challenging.</p>
<p>Focusing on arithmetic calculations, some studies (Yuan et al., 2023) demonstrate that recent LLMs (such as GPT-4) can perform additions and multiplications with long-digit operands, for which the number of variants is so high to exclude the exhaustive memorization of the training set.Nevertheless, the computational approach put in place by LLMs, as well as the interpolation/extrapolation capabilities remain unexplained.</p>
<p>In this work we design some controlled experiments, consisting of simple computation tasks such as binary addition and multiplication, and solve them with two Language Models (LMs) based on Transformer architecture: (i) the original encoder-decoder architecture by Vaswani et al. (2017) and (ii) a more recent decoder-only architecture denoted as nanoGPT (Karpathy, 2022).In spite of their simplicity, these tasks cannot be solved by pure memorization or smooth interpolation and investigating how an LM learn them can improve our understanding of the underlying mechanisms.In particular, using a tiny vocabulary of just 5 tokens and a small training set allows to operate with a light (non-pretrained) LM and use interpretability techniques to investigate internal information processing.</p>
<p>Other studies addressed the ability of LLMs to perform arithmetic computation and train small LMs to learn these tasks from scratch (see related works in Section 2).However, our aim is different: we are not interested in finding the best LM architecture and setup to maximize accuracy on arithmetic operations, but we look for a simple architecture and setup that allow to effectively solve the task in order to be able to investigate the underlying computational approach.The main novelty and contribution of this work are the formalization of the hypothesis that our LM works as an Encoding-Regression-Decoding machine and the design of a number of experiments to support and validate this hypothesis (see Table 1).</p>
<p>After presentation of related works in Section 2, in Section 3 we introduce the experimental testbed and the architecture of the LM used.Section 4 presents the results achieved and introduces control experiments and elaborations to shed light on the computation approach used to solve the tasks.In Section 5 an ablation study is presented and, finally, in Section 6 we include a final discussion and draw some conclusions.</p>
<p>Amnesic probing</p>
<p>Prove that the "value" information is crucial to properly compute the output Appendix D</p>
<p>Related works</p>
<p>LM and LLM capabilities on arithmetic tasks</p>
<p>In Yuan et al. (2023) recent LLMs have been benchmarked in arithmetic tasks, including long-digits sum and multiplication, showing that LLMs such as ChatGPT and GPT-4 can perform reasonably well on these tasks even with no specific tuning.On the other hand, the accuracy of smaller models is markedly lower, and in general they are not able to work with long operands and generalize to OoD data.</p>
<p>Goat (Liu and Low, 2023) a LLaMA model specifically fine-tuned on arithmetic tasks performed even better than GPT-4 on large-number additions and subtractions, probably due to the consistent (digit level) tokenization of numbers in LLaMA models.However, it was able to perform multi-digits multiplication and division only forcing a Chain of Thought (CoT) (Wei et al., 2023) decomposition of such tasks during instruction tuning.Nogueira et al. (2021) tuned a T5-based pre-trained LM on additions and subtractions, and argued that tokenization and input representation are critical to achieve good accuracy.In particular, in their experiments character-based tokenization works better than sub-word tokenization, and making explicit the digit position in the input string (i.e., inserting after each digit a marker to denote its position in the sequence) generally leads to better accuracy.They also trained a vanilla non-pretrained LM on smaller numbers and found that classical sinusoidal-based positional embedding does not perform well, so they proposed a tailored position-wise masked embedding.Their paper contains other interesting findings such as the impact of the digit order (plain or reverse) and the size of the training set.Muffo et al. (2023) tuned pre-trained GPT-2 models on 5-digit additions and 2-digit multiplications.They also found that making explicit the digit position in the input sequence helps to improve accuracy.While good accuracy is reported for addition, the tuned models struggle to learn multiplication even on two-digit operands.Lee et al. (2023) trained small LMs to learn arithmetic tasks, mainly focusing on addition, but also experimenting with subtraction, multiplication, sine and square root.The authors carefully ablated different aspects of the training data to isolate the factors that contribute to the appearance of arithmetic capabilities.In particular, they studied the impact of the input order (plain or reverse) and the utility of providing intermediate information about the decomposition of the task in steps to promote CoT reasoning.Some results and findings included in Lee et al. (2023) will be further discussed throughout this paper.</p>
<p>All the above works provide useful contributions to understand the capabilities and limitations of large and small LMs to deal with arithmetic tasks, but none of them focus on the computational approach used to solve them, which is the main purpose of the present work (see Table 1).</p>
<p>Interpretability techniques</p>
<p>A large number of techniques can be used to investigate the internal working mode of deep neural networks, including Transformers and LMs: see Rauker et al. (2023) for a recent survey.Weights, single neurons, subnetworks/circuits, and activations can be the target of intrinsic approaches (implemented during training) or post-hoc approaches (implemented after training).</p>
<p>Probing is a common technique used to investigate the representations learned by pre-trained LMs: it typically involves training a simple model (denoted as probe) on top of the LM embeddings to predict a given property (Belinkov, 2022).Moreover, structural probing can be used to check whether internal representations encode discrete structures such as syntax trees (Hewitt and Manning, 2019), (White et al., 2021).However, a certain criticism emerged on probing analyses which is believed to disconnect the probing task from the original one and/or to reveal correlations instead of causations.Therefore, instead of focusing on the presence of information on internal encoding, some researchers proposed to check whether the removal of some knowledge from embeddings (e.g., amnesic probing (Elazar et al., 2021)) negatively influences the model ability to perform a task (Elazar et al., 2021), (Lasri et al., 2022).Other interesting approaches to interpretability are mechanistic interpretability (Elhage et al., 2021) and causal abstraction (Geiger et al., 2021): the former is aimed at reverse engineering the algorithm that a model uses to solve a task and to map it to neural circuits; the latter constructs an interpretable causal model and aligns it with neural representations.</p>
<p>In this work we use a mix of intrinsic and post-hoc interpretability techniques: in particular through the experiments we manipulate the training set, change the input representation and the architecture components, perform correlation analyses of embeddings and apply amnesic probing.</p>
<p>Interpretability of arithmetic reasoning with LMs</p>
<p>Stolfo et al. ( 2023) introduced a causal mediation analysis to point out the LM components (e.g., attention heads, Multi-Layer Perceptrons -MLPs) involved in the information processing of simple arithmetic operations, focusing on the flow of numerical information throughout the model layers/columns.The main outcomes of this study are that the model: (i) processes the representation of numbers and operators with the first layers; (ii) information is then conveyed (by attention heads) to the last part of the sequence (i.e., output column), where (iii) it is numerically processed by late MLPs.Nanda et al. (2023) carefully studied the algorithmic approach put in place by a small Transformer to implement modular addition of small numbers.They discovered that the internal algorithmic implementation is based on discrete Fourier transforms and trigonometric identities to convert addition to rotation on a circle.While the outcomes are somewhat surprising, here the term algorithm must be taken with care: even if the experiments prove that internal processing well approximates given equations, the approach is a numerical approximation (based on weight encoded values) that does not generalize to different moduli (as a symbolic implementation of the equations could do).</p>
<p>Both these studies adopted a simplified setting where numbers are presented as single token, and the output is expected at the last position of the sequence.So the models are not operated in autoregressive manner and the multi-token encoding/decoding stages are simplified.In Section 6 we discuss how the above findings are compatible with our findings.</p>
<p>Experiment design</p>
<p>The tasks</p>
<p>We focused on two simple computation tasks: binary addition and binary multiplication.Using binary encoding allows keeping the vocabulary very compact, since we need to encode only the symbols '0', '1' and a few other tokens.The selected tasks have other nice properties such as computing input similarities by Hamming distance and easily generating all combinations.Of course, a classical artificial neural network can be trained to learn to sum and multiply two integers or floating-point numbers, but adding/multiplying strings of tokens with an LM is trickier.</p>
<p>More formally, given two integers A, B (both in the range [0,127]) our input sequence (or prompt) is a 15-token string taking the form:
a 0 a 1 a 2 a 3 a 4 a 5 a 6 ⟨op⟩ b 0 b 1 b 2 b 3 b 4 b 5 b 6
where a i , b i ∈ {'0', '1'} are the symbols corresponding to bits in the i-th position in the binary representation of A and B respectively, and ⟨op⟩ can be either '+' or '×'.</p>
<p>The expected output string (or input completion) is:
R = r 0 r 1 ...r m−1
where r i is the i-th bit in the binary representation of A⟨op⟩B, and m is the number of bits of the expected output string R (8 and 14 for addition and multiplication, respectively).</p>
<p>It is worth noting that:</p>
<p>• we are using a fixed-length input/output representation (with zero padding for unused most significant bits) to make the digit positions more explicit.</p>
<p>• in both the input and output the Least Significant Bits (LSBs) are provided before the Most Significant Bits (MSBs) (a.k.a., reverse or little-endian order) since this was supposed to simplify the model learning1 .As discussed in Appendix C this assumption leads to a much faster training.</p>
<p>If we consider the sequence-to-sequence mapping underlying the proposed tasks we note that even in a simple binary addition a slight change in the input (i.e., a single bit) can produce a relevant change in the output because of the carries propagation.In the example below a single bit modification in the input produces an 8 bit modification in the output: 1000000 + 0111111 → 11111110 1000000 + 1111111 → 00000001 Such input-output discontinuity is made more explicit for addition in Appendix A.</p>
<p>The architecture</p>
<p>A non-pretrained encoder-decoder Transformer based on the original architecture introduced in Vaswani et al. (2017) was used as primary LM.Table 2 reports the model setup and parametrization.The small vocabulary used allows us to keep the model small (just 701K learnable parameters) and trainable from scratch with a limited number of examples.</p>
<p>The LM was trained to learn separately the addition/multiplication tasks.For both problems, we exhaustively generated all the 2 14 = 16384 input/output combinations, which were then randomly split into training (3/4 → 12288) and validation (1/4 → 4096) sets.In our experiments we do not need a separate dataset to tune hyperparameters so our validation set coincides with the test set.</p>
<p>An additional control experiment was run where the input sequences were the same of the addition experiment but the output completion was randomly generated (with the same length as the addition, i.e., 8 tokens).In this case, the lack of any dependencies between input and output makes it impossible to learn an algorithmic approach (or smooth mapping) to solve the problem and the only strategy to learn the training set is memorizing all the sequences.</p>
<p>When the trained LM is used in inference mode, we always pick the most probable token from the logit outputs (i.e., greedy decoding).Two metrics can be used to denote the LM accuracy: token accuracy refers to the probability of generating the next token correctly, while sequence accuracy refers to the probability of generating the whole output string correctly in autoregressive mode (i.e., generating one token at a time and appending it to the current prompt).Most of the experiments have been repeated with a second LM (nanoGPT by Karpathy ( 2022)) which is a good representative of the decoder-only family.Details are reported in Appendix E.</p>
<p>All the experiments included in this paper can be easily reproduced by running the code available at: (to be disclosed upon acceptance).</p>
<p>Results</p>
<p>Learning addition and multiplication</p>
<p>Figure 1 shows that our simple LM is able to learn addition in less than 50 epochs, and multiplication in about 250 epochs2 .As expected multiplication is more complex and requires more training: this is due to the high non-linearity of this operation (more on this later) and to the higher length of the output (14 vs 8 tokens).The accuracy on the validation set is very close to the training set, denoting almost perfect generalization on numbers never seen before.This is a somewhat surprising result, especially considering the limited size of the training data.No grokking3 was observed (Nanda et al., 2023).Similar results were obtained with nanoGPT (see  2021) (see their Appendix B for a similar setup), we were able to learn addition with the native sinusoidal positional encoding.Moreover, in Lee et al. (2023) additions can be effectively learnt by a simple LM, but to reach 100% accuracy the training set had to be balanced in terms of the operand magnitude (i.e., number of digits) and carry propagation.</p>
<p>The effectiveness of our training procedure is probably due to the lower complexity determined by a small vocabulary and fixed-length representation.As to multiplication, Muffo et al. (2023) were not able to effectively learn two (decimal) digits multiplication, while Lee et al. (2023) and Liu and Low (2023) had to provide extra intermediate steps in the prompt (denoted as detailed scratchpad) or during instruction tuning, respectively.On the contrary our model effectively learnt multiplication of 7 binary digit operands: again the simplified setup may have been the key.</p>
<p>On the workstation used (with a single Titan RTX GPU) training can be completed in just 8 and 46 minutes for addition and multiplication, respectively.An estimation of the training complexity C of an LLM in term of floating point operations is 6 × N × T (Kaplan et al., 2020), where N is the number of model parameters (about 701K as reported in Table 2) and T the number of training tokens.T can be obtained as the product of the training set size (12288 in our experiments -see Section 3.2), the sequence length in tokens (23 and 29 for addition and multiplication, respectively -see Section 3.1) and the number of epochs (50 and 250 for addition and multiplication, respectively).Hence, for addition T is 14M (12288 × 23 × 50) and therefore C is about 59 × 10 12 operations while for multiplication T is 89M (12288 × 29 × 250) and C is about 374 × 10 12 operations.</p>
<p>Control experiment: random output</p>
<p>If the output is randomly generated and therefore there is no relation with the input, the only possibility of learning the training set is by memorizing the whole data.Figure 2 shows the training results: a much larger number of epochs (i.e., 1000) were necessary to reach a sequence accuracy of 87.8%, and, as expected, the validation accuracy did not increase over the epochs.The difficulty of memorizing the training set (many more epochs) is due to the high discontinuity of the input-output mapping.In fact, because of the random output generation, very similar input sequences can be associated to completely different outputs.</p>
<p>Therefore, even if we only consider the accuracy on the training set, this result shows that an exhaustive memorization of the input is much more complex for the LM than solving the addition and multiplication tasks.This leads us to assume that, to efficiently solve the above computation tasks, the LM has found a computational approach (or algorithm) to simplify the output prediction.Now the question is: what is the approach?</p>
<p>The computational approach</p>
<p>Let us consider two alternative approaches: Symbolic Manipulation (SM): a first idea is that the LM could learn the binary integer addition/multiplication algorithms used by an ALU inside a CPU (see Appendix B for a short reminder).Indeed, the addition algorithm is not complex and can be solved by using a 3-bit truth table (to sum each pair of corresponding bits with the carry-in) and iterative carry-out propagations.However, multiplication (by iterative additions) is much more complex and trickier to learn by using a symbolic manipulation approach.Furthermore, as shown in Lee et al. (2023), a simple LM can also learn complex operations such as the sine function or the square root, whose mathematical (and algorithmic) decomposition is very complex since they require Taylor expansion and Newton method, respectively.</p>
<p>Encoding-Regression-Decoding (ERD): if we consider the model architecture (Transformer) used for the LM and the underlying word embedding by vector representations, it is more likely that the LM solves the problem by decomposing it in the following three phases:</p>
<ol>
<li>Encoding (token to value): maps the input sequence (i.e., a 0 a 1 a 2 a 3 a 4 a 5 a 6 ⟨op⟩ b 0 b 1 b 2 b 3 b 4 b 5 b 6 ) to a suitable vector representation.In principle, two vectors v A and v B representing the values (or magnitudes) of A and B are enough.2. Regression: learns the computation as a supervised regression problem in the vector space:</li>
</ol>
<p>v R = regress(v A , v B ). Actually this regression formulation is an oversimplification of the problem since in the next-token-prediction training the LM works incrementally.In Appendix C this discussion will be expanded.3. Decoding (value to token): maps the value vector v R back to token representation (i.e., r 0 r 1 ...r m ).</p>
<p>It is worth noting that the above Encoding and Decoding phases do not need to be mapped onto the Transformer encoder and decoder (more on this later).The experiments reported in Sections 4.4 and 4.5 support the ERD assumption.The capability of capturing number magnitudes by pretrained embedders was also investigated by Wallace et al. (2019) who successfully trained a simple external regressor to compute the sum of two numbers starting from their embeddings.Other interesting studies on capturing numeracy with embedding were carried out by Naik et al. (2019) and Sundararaman et al. (2020).</p>
<p>Interpolation vs extrapolation</p>
<p>The random training/validation split performed for the experiments reported in Section 4.1 constitutes a somewhat simplified testbed to learn the two tasks.In fact, random split leads to a complete (even if sparse) coverage of the input space by both the training and validation sets, where each example in the validation set has high chance to be close to a training set example, and interpolation is enough to fill the gaps.</p>
<p>Hereafter, we exploit the well-known difficulty of a numerical regressor to work in the extrapolation regime to get insights about the computational approach of the LM.In particular, we considered two different criteria to isolate specific portion of the input space for the validation set, in order to better investigate extrapolation capabilities:
• VS t = {(A, B)|(A, B) ∈ NN 4096 ((A * , B * ))}
where NN 4096 ((A * , B * )) is the set of 4096 pairs (A, B) which are the nearest neighbors to a centroid (A * , B * ) according to the Hamming distance between the corresponding token representations (i.e., number of different tokens at corresponding positions).As centroid (A * , B * ) in the token space we used: 1010101 ⟨op⟩ 0101010.
• VS v = {(A, B)|32 ≤ A &lt; 96 and 32 ≤ B &lt; 96}
here the centroid is located in the middle of the value space (64, 64), so VS v is a squared region (of side 64) centered in the value space.</p>
<p>Both VS t and VS v isolate a contiguous data region of 4096 samples to be included in the validation set, but in the former the samples are close in the token representation space, while in latter are close in the value space.Being such contiguous portions of space excluded from the training set, we can expect a worse generalization.From the results (see Figure 3) we note that VS t is very marginally affecting LM training and generalization while VS v has a major impact: in fact, in the second case, for both addition and multiplication the final sequence accuracy is from 4% to 6% points lower.This result strengthens the ERD hypothesis, since: (i) using VS v leads to the exclusion of a specific contiguous portion of value space during phase 2 and does not allow to properly train the regressor in this region; (ii) the encoding performed during phase 1 makes irrelevant the selection performed according to VS t because, after encoding, the corresponding data point remains scattered in the value space and the regressor can easily interpolate among them.Similar results were obtained with nanoGPT (see Figure E.8 in Appendix E.)</p>
<p>Looking at internal representations</p>
<p>Understanding the internal representation (embeddings in the vector space) in a trained Transformer is not an easy task.However, in the specific setting considered we can gain some hints by looking at the distances between the embedding of different data points (at different layers) and correlating them with the corresponding distances at input/output levels.</p>
<p>Given an LM trained on addition (or multiplication) we consider the dataset S including the 128 input pairs where the two operands have identical values4 : Results are averaged over five runs.VS t reaches 100% accuracy on additions (the same of Random split) and 97.5% accuracy on multiplication (just 1.4% less than random split); VS v reaches 93.7% on addition and 94.3% on multiplication (6.3% and 4.6% less than Random split, respectively).
S = {(A, A)|0 ≤ A &lt; 128}
At the input level (in) we can compute two ordered sets of 8128 (128×127/2) distances each:
d in,t = {hdist(X, Y)|(X, X), (Y, Y) ∈ S , X &lt; Y} d in,v = {|X − Y| |(X, X), (Y, Y) ∈ S , X &lt; Y}
where hdist(X, Y) is the Hamming distance between the token representation of X and Y, and the subscript letters t and v denote token and value levels, respectively.</p>
<p>At the output level (out) we can compute the two corresponding sets of distances as:
d out,t = {hdist(P, Q)|(X, X), (Y, Y) ∈ S , X &lt; Y} d out,v = {|P − Q| |(X, X), (Y, Y) ∈ S , X &lt; Y}
where (P = X + X and Q = Y + Y) for addition, and (P = X × X and Q = Y × Y) for multiplication.</p>
<p>Finally, for each intermediate level of the Transformer encoder (enc) or decoder (dec) we can compute the Euclidean distances among the corresponding embedding vectors.
d enc i = {∥enc i (X, X) − enc i (Y, Y)∥ |(X, X), (Y, Y) ∈ S , X &lt; Y} d dec i = {∥dec i (X, X) − dec i (Y, Y)∥ |(X, X), (Y, Y) ∈ S , X &lt; Y}
where enc i and dec i are the output vectors obtained by concatenating all the token embeddings (each of dimensionality 64) after the i-th encoder and decoder layer, respectively.For example enc i has dimensionality 960 = 64 × 15 where 15 is the number of tokens in the encoder.</p>
<p>Even if the distances in the different sets have different ranges, we can use correlation to find out similarities.If two sets of distances are correlated we can expect that the corresponding representations/embeddings are correlated as well.Since both Pearson and Spearman correlations (Schober et al., 2018) provided similar outputs, for simplicity in Figure 4 we report only Pearson correlations.</p>
<p>The yellow cells in the tables of Figure 4 confirm the low correlation between the token and value representation at both input and output level.The blue cells show that correlation remains quite similar across the encoder layers as if the encoder was not performing any significant computation (this is confirmed in Section 5 where we achieve similar results by totally removing all intermediate attention and MLP layers in the encoder).More interesting is the trend of correlations across the decoder layers (green cells).In particular, for the addition the token representation has high correlation with the first and last layers and low with central layers, while the value representation has an opposite trend (see also Figure 4.c).These results support the ERD hypothesis and in particular that the initial and final layers in the decoder transform from token to value representation (and vice versa) while the central layers perform regression in the value space.In particular, at layer 3, the correlation at token level is minimum while the correlation at value level is maximum.</p>
<p>For multiplication the low-high-low trend at value level is less evident (Figure 4.d orange curve), probably because the quadratic dependence of the output from the input (at value level) does not allow to learn a simple regressor smoothly working in the whole vector space, and the mapping is performed by piecewise linear approximation in different space regions, which introduces discontinuities that make global distances in the vector space unsuitable to quantify the representation similarity.</p>
<p>As discussed in Section 2.2, correlation analyses might be insufficient to prove that the presence of a certain information in the embeddings is really necessary to compute the output (direct causation).So to further strengthen our hypothesis we applied an amnesic probing technique (Elazar et al., 2021) and proved that, upon removal of value information from the embeddings, the LM is no longer capable of performing the right computation.Details are reported in Appendix D.</p>
<p>Ablation study</p>
<p>This section presents the results of an ablation study where the LM architecture was simplified, to understand which components are necessary to learn the addition/multiplication computation.Squeezing the encoder (i.e., removing all intermediate attention and MLP layers) does not have a relevant impact; this is consistent with other works claiming that a decoder only architecture (Liu et al., 2018) can achieve similar results with respect to an encoder-decoder Transformer, and further confirmed by the nanoGPT results presented in Appendix E. A simplification of the architecture in terms of (i) reduction of dimensionality; (ii) reduction of number of heads; (iii) removal of fully connected layers is well tolerated, while positional embedding and attention layers are mandatory for the LM in order to properly perform token to value transformation (and vice versa).Table 3 summarizes the results.</p>
<p>Table 3: Epochs necessary to reach 95% accuracy on the validation set.A dash is used when 95% accuracy is not achieved in 1K epochs: in such case the accuracy reached is reported within brackets.</p>
<p>Configuration</p>
<p>Addition Multiplication Full (see</p>
<p>Discussion and conclusions</p>
<p>In this paper we introduced a simplified setup to allow a light LM to learn binary addition and multiplication.Both the LM architectures considered easily learn the two tasks and generalizes well on unseen data, proving that memorization of the training data is neither necessary nor efficient.The experiments on the interpolation/extrapolation capabilities and correlation of input-output representations with internal embedding suggest that the model solves the computational task as a supervised regression problem in the value space after an initial encoding from token to values, and a final decoding from output value to tokens.Under this hypothesis: (i) any task that can be solved by a neural network regressor can be solved by an LM as well, with the extra burden of end-to-end learning decoding/encoding steps; (ii) when looking at interpolation/extrapolation capabilities of an LM applied to a mathematical task, we should not concentrate on the input token representation but on the internal representation after encoding, keeping in mind the difficulties of a numerical regressor to work on region spaces not covered by the training set; (iii) on a more speculative side, we could guess that modern LLMs learn the number encoding/decoding once and reuse it across different numerical tasks whereas a specific regressor is learned for each task.</p>
<p>Our ERD hypothesis could be questioned considering some recent findings from Lee et al. (2023) where providing in the prompt intermediate information (scratchpad) about the decomposition of arithmetic tasks improves the training efficiency and requires fewer examples.This could suggest that a symbolic manipulation approach is adopted to learn imitating step by step the proposed decomposition.However, in most of the cases their model was able to learn the same task (even if slowly) without scratchpad and/or with wrong scratchpads.As argued by the authors the higher efficiency is actually in terms of examples and not in terms of tokens since each scratchpad requires a large number of extra tokens, and we guess these could be used as extra features by the underlying regressor.Furthermore, scratchpad contribution is negligible for more complex operations such as sine and square root, but, unexpectedly, learning such complex operations was simpler than multiplication.This is not strange under the ERD hypothesis where a unary smooth operator like the sine can be learned by a supervised regressor independently of the mathematical method used for its computation.</p>
<p>The algorithmic interpretation that Nanda et al. (2023) provided for modular addition, could also suggest that their LM discovered and efficient symbolic manipulation approach; however, as discussed in Section 2.3, it is more likely that a regressor was learned to numerically approximate an efficient sparse Fourier decomposition, under regularization constraints favoring sparsity.Finally, the information flow described in Stolfo et al. (2023), points out that MLPs in the last layers are responsible for the numerical computation of the solution, which is compatible with the hypothesis of a multi-layer regressor.</p>
<p>Of course we are not claiming that all the capabilities of modern LLMs can be explained by regression, but regression is likely to be one of the internal tools that LLMs uses to predict the next token when numbers come into play.</p>
<p>As to future research we plan to: i) further investigate the generalization capabilities of LMs in arithmetic tasks with respect to the composition of the training and test sets (Feng et al., 2023;Keskar et al., 2017), ii) design simplified experiments/setups for tasks that cannot be easily mapped to regression problems such as chain of reasoning and logic deductions.current bits5 , then a two-output 3-bit truth table (Table B.5) can be used to generate the output bit o i and carry c i used when summing the next pair of bits:</p>
<p>Inputs</p>
<p>Outputs
a i b i c i−1 o i c i 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 0 1 1 0 1 1 0 0 1 0 1 0 1 0 1 1 1 0 0 1 1 1 1 1 1
A simple approach to execute binary multiplication is through iterative binary sums.Each bit b i of the second operand is multiplied by the whole first operand, but this inner multiplication is straightforward since it results either in a sequence of 0 (if b i = 0) or a copy of the first operand (if b i = 1).This intermediate result is then shifted left and summed to the current output.An example is reported in Figure B.5 below.</p>
<p>Appendix D. Amnesic probing results</p>
<p>The outcome of correlation analyses performed in Section 4.3 suggests that the embeddings in the central layers of the decoder contain information related to the value representation of the output (see Figure 4).However correlation does not mean causation, and here we investigate deeper.Amnesic probing was proposed in Elazar et al. (2021) building on the approach Ravfogel et al. (2020) to check to what extent a model output is affected by the removal of specific features or attributes in an intermediate level embeddings.Here we focus on addition and we try to remove some features from the decoder layer 3 embeddings (dec 3 (X, Y)).To this purpose a linear probe (a linear regressor in our case) was trained to predict the output value (X + Y) starting from the dec 3 (X, Y) embeddings and its nullspace is used to project the embeddings in a new space lacking output value information.According to Ravfogel et al. (2020), due to the simplicity of the linear regressor used, the procedure is repeated twice to remove more information.Our results show that:</p>
<p>1.A simple linear regressor trained on dec 3 (X, Y) embeddings can reach high accuracy in predicting X + Y (rmse = 0.28).2. If the projected embeddings are overwritten in the LM decoder at level 3, and a partial forward pass is performed thereafter, the addition sequence accuracy severely drops from 100% to 0.13%.3.As indicated in Elazar et al. (2021) since any information removal could hamper the model accuracy, a control test was performed by removing the same amount of information (but on random directions instead of the nullspace directions) and in this case the LM final sequence accuracy remained 100%.</p>
<p>This experiment provides further support to the hypothesis that the value information is not only present in the inspected embeddings but is also crucial for the output computation.</p>
<p>On the computational side, we argue that amnesic probing complexity is low because it relies on simple steps as linear regression and null space computation, with the former being the most demanding step.Linear regression complexity is O(nd 2 + d 3 ) where n is the number of training examples and d the dimensionality of the embeddings.</p>
<p>Appendix E. NanoGPT -a decoder-only LM</p>
<p>To demonstrate that our findings generalize beyond the encoder-decoder architecture of the original Transformer used in this work, the main experiments have been repeated using a second LM, that is the nanoGPT (Karpathy, 2022) decoder-only model.Table E.6 reports the details of the nanoGPT model adopted.Using the VS t subset, it reaches 100% and 99.9% accuracy on addition and multiplication, respectively (the same of Random split) while, using the VS v subset, it reaches 82.0% on addition and 80.6% on multiplication (18.0% and 19.4% less than Random split, respectively).Results are inline with those obtained in Section 4.4 but here the difference between VS t , and VS v is still more significant.</p>
<p>Figure E.7 in Appendix E.) Unlike Nogueira et al. (</p>
<p>Figure 1 :
1
Figure 1: Sequence accuracy.From the left: addition and multiplication.Results are averaged over five runs.Note that, training and validation curves are almost overlapped.At the end of training the Mean Absolute Error (MAE) on the validation set, between the real and generated operation results, is 0 and 1.3 for addition and multiplication, respectively.</p>
<p>Figure 2 :
2
Figure 2: Sequence accuracy using random output in the training set.Results are averaged over five runs.</p>
<p>Figure 3 :
3
Figure 3: Sequence accuracy on Random, VS t , and VS v validation subsets for addition (left) and multiplication (right).Results are averaged over five runs.VS t reaches 100% accuracy on additions (the same of Random split) and 97.5% accuracy on multiplication (just 1.4% less than random split); VS v reaches 93.7% on addition and 94.3% on multiplication (6.3% and 4.6% less than Random split, respectively).</p>
<p>Figure 4 :
4
Figure 4: Pearson correlation between ordered sets of distances for addition (a) and multiplication (b).Each cell denotes the correlation between the two ordered set of distances specified in the corresponding row and column.Note that since for addition in this experiment the output value is always twice the input, the correlation values (blue and green cells) are the same for d in, and d out, block of values.Graphs (c) and (d) show the correlations of output distances d out,t (at token level -blue curves) and d out,v (at value level -orange curves) with the embedding distances d dec i across the 6 decoder layers for addition and multiplication, respectively.</p>
<p>Figure B. 5 :
5
Figure B.5: Example of 4-digit binary multiplication.The sum can be performed incrementally with a two-operand adder.</p>
<p>Figure C. 6 :
6
Figure C.6: Sequence accuracy on validation set for reverse (default in this work) and plain order of the input and output representations.From left to right: addition and multiplication.</p>
<p>Figure E. 7
7
Figure E.7 shows that the nanoGPT model was able to learn addition and multiplication still more efficiently than the original Transformer (compare Figure 1 with Figure E.7).For the training, we used a minibatch size of 128, a standard CrossEntropy loss, the AdamW optimizer with a learning rate of 0.001 and betas = 0.9 and 0.98, and a gradient clipping to 1.0.</p>
<p>Figure E. 7 :
7
Figure E.7: Sequence accuracy of the nanoGPT model (refer to Section 4.1 for more details).From the left: addition and multiplication.Results are averaged over five runs.Note that, training and validation curves are almost overlapped.</p>
<p>Figure</p>
<p>Figure E.8 shows the sequence accuracy of the nanoGPT model on Random, VS t , and VS v validation subsets for addition and multiplication (see Section 4.4 for more details).Using the VS t subset, it reaches 100% and 99.9% accuracy on addition and multiplication, respectively (the same of Random split) while, using the VS v subset, it reaches 82.0% on addition and 80.6% on multiplication (18.0% and 19.4% less than Random split, respectively).Results are inline with those obtained in Section 4.4 but here the difference between VS t , and VS v is still more significant.</p>
<p>Figure E. 8 :
8
Figure E.8: Sequence accuracy of the nanoGPT model on Random, VS t , and VS v validation subsets for addition (left) and multiplication (right).Results are averaged over five runs.</p>
<p>Table 1 :
1
The main contributions of this work.</p>
<p>Table 2 :
2
Details of the LM model used in our experiments.The total number of learnable parameters is just 701K, which is several orders of magnitudes smaller than recent billion-parameters LLMs.
vocabulary size5vocabulary0: unused, 1: <start>, 2: '+' or '×', 3: '0', 4: '1'token embeddinglearnedpositional encodingfixed (sinusoidal)d model64d f fd model × 4num heads h8encoder layers6decoder layers6dropout0.1learnable parameters701K</p>
<p>Table 2
2)39137Squeezing the encoder (see main text)60426num heads h=125225Reduced dimensionality (d model = 32)66309No positional embedding-(2.4%)-(1.8%)No attention layers-(0.9%)-(1.7%)No fully connected layers56398</p>
<p>Table A .
A
4: Addition input-output discontinuities.</p>
<p>Table B .
B
5: Two-output 3-bit truth table for binary addition.</p>
<p>Table E .
E
6: Details of the nanoGPT model.
token embeddinglearnedpositional encodinglearnedd model64d f fd model × 4num heads h8decoder layers6dropout0.1learnable parameters298K
in binary arithmetic the addition/multiplication algorithms start processing the LSBs in order to correctly propagate the intermediate carries.
We used the standard CrossEntropy loss, the Adam optimizer with the learning rate of 0.0001 and betas = 0.9 and 0.98, and a minibatch size of 128.
Grooking refers to the case where validation accuracy, much smaller than training accuracy at initial stages, suddenly increases after a certain number of epochs.
since the input prompt contains two operands, we select only the cases with identical values (A = B) in order to easily determine the "magnitude" of the input, and thereafter compute meaningful distances.
when summing the LSBs (i = 0), there is no pending carry, so c −1 = 0
Appendix A. Addition input-output discontinuitiesGiven an input/output pair we consider the (2 14 ) variants obtained by perturbing (i.e., 0-1 swap) the input bits and counting the resulting changes in the output.These values, averaged over all possible input/output pairs (again 2 14 ) and normalized by row are inserted in the cells of A.4.So, for example the value in cell (row=2, column=3) means that in the 27.9% of the cases a perturbation of 2 (over 14) bits in the input leads to a change of 3 (over 8) bits in the output.Input-output discontinuities, which are further amplified in case of multiplications, make it very unlikely to solve these tasks by smooth interpolation of the input representation.Appendix B. Binary addition and multiplicationBinary addition can be executed by summing pairs of corresponding bits a i and b i , starting from the LSBs (a 0 and b 0 ) and propagating carries.Let c i−1 be the pending carry used to sum In Section 4.3 we argued that an arithmetic computation task can be decomposed into three steps whose central one is learning a regressor in the value space: v R = regress(v A , v B ).If we consider the autoregressive working mode of a Transformer and its predict-next-token training, the regressor must be able to work incrementally given the output produced so far.In particular, we can formulate the problem as:) where:are the value vectors of the two input operands, obtained as the concatenation of the value vectors of single tokens.Both are always fully available to the decoder.Note that, v a i and v b i are not the bits of the inputs, but correspond to their value vectors including also positional information.• i is the position of the token to be predicted (we can assume it is available through positional encoding).• c R i−1 = [c r 0 c r 1 ...c r i−1 ] is a value vector encoding the current context determined by the result produced so far (entering in the decoder from the bottom).• v r i is the value vector of the i-th token.In principle, the regressor could predict each v r i based on v A and v B alone, but we argue that the exploitation of the result produced so far c R i−1 can lead to higher training efficiency.To this purpose is interesting to evaluate the impact of the output ordering (plain or reverse).In both the addition and multiplication the i-th token of the result only depends on the tokens of the inputs at positions ≤ i (see Appendix B).Therefore, if reverse order is adopted, as we assumed until now,and c R i−1 are sufficient to predict v r i .Viceversa, if the output computation starts with the MSBs the regressor cannot leverage the above iterative decomposition and needs to learn the task as a global operation using whole vectors v A and v B with almost no support from the result produced so far.In FigureC.6 we note that with plain order both addition and multiplication require a much longer number of epochs to converge and the learning curve is less stable.Further experiments proved that, as expected, the order of the inputs (also reverse by default in this study) is irrelevant, since the LM can always access the whole input representations v A and v B .The advantages of using the reverse order are pointed out in other recent studies(Nogueira et al., 2021;Lee et al., 2023).In particular,Lee et al. (2023)reported a significant improvement with respect to plain order.
Y Belinkov, Probing Classifiers: Promises, Shortcomings, and Advances, Computational Linguistics. 202248</p>
<p>S Bubeck, V Chandrasekaran, R Eldan, J Gehrke, E Horvitz, E Kamar, P Lee, Y Lee, Y Li, S Lundberg, H Nori, H Palangi, M Ribeiro, Y Zhang, arXiv:2303.12712Sparks of Artificial General Intelligence: Early experiments with GPT-4. 2023</p>
<p>Amnesic Probing: Behavioral Explanation with Amnesic Counterfactuals. Y Elazar, S Ravfogel, A Jacovi, Y Goldberg, Transactions of The Association for Computational Linguisticss. 92021</p>
<p>. N Elhage, N Nanda, C Olsson, T Henighan, N Joseph, B Mann, A Askell, Y Bai, A Chen, T Conerly, N Dassarma, D Drain, D Ganguli, Z Hatfield-Dodds, D Hernandez, A Jones, J Kernion, L Lovitt, K Ndousse, D Amodei, T Brown, J Clark, J Kaplan, S Mccandlish, C Olah, A Mathematical Framework for Transformer Circuits. 2021</p>
<p>Activity-weight duality in feed-forward neural networks reveals two co-determinants for generalization. Y Feng, W Zhang, Y Tu, Nature Machine Intelligence. 52023</p>
<p>A Geiger, H Lu, T F Icard, C Potts, Causal Abstractions of Neural Networks, 35th Conference on Neural Information Processing Systems. NeurIPS 20212021</p>
<p>A Structural Probe for Finding Syntax in Word Representations. J Hewitt, C Manning, Conference of the North American Chapter. the Association for Computational Linguistics2019</p>
<p>J Kaplan, S Mccandlish, T Henighan, T B Brown, B Chess, R Child, S Gray, A Radford, J Wu, D Amodei, arXiv:2001.08361Scaling Laws for Neural Language Models. 2020</p>
<p>A Karpathy, N S Keskar, D Mudigere, J Nocedal, M Smelyanskiy, P T P Tang, On Large-Batch Training for Deep Learning: Generalization Gap and Sharp Minima, 5th International Conference on Learning Representations. 2022. 2017nanoGPT: a lightweight implementation of medium-sized GPTs</p>
<p>K Lasri, T Pimentel, A Lenci, T Poibeau, R Cotterell, Probing for the Usage of Grammatical Number, 60th Annual Meeting of The Association for Computational Linguistics. 2022</p>
<p>N Lee, K Sreenivasan, J Lee, K Lee, D Papailiopoulos, arXiv:2307.03381Teaching Arithmetic to Small Transformers. 2023</p>
<p>T Liu, B K H Low, arXiv:2305.14201Goat: Fine-tuned LLaMA Outperforms GPT-4 on Arithmetic Tasks. 2023</p>
<p>P Liu, M Saleh, E Pot, B Goodrich, R Sepassi, L Kaiser, N Shazeer, Generating Wikipedia by Summarizing Long Sequences, 6th International Conference on Learning Representations (ICLR). 2018</p>
<p>Evaluating Transformer Language Models on Arithmetic Operations Using Number Decomposition. M Muffo, A Cocco, E Bertino, 13th Conference on Language Resources and Evaluation (LREC). 2023</p>
<p>A Naik, A Ravichander, C Rose, E Hovy, Exploring Numeracy in Word Embeddings, 57th Annual Meeting of The Association for Computational Linguistics. 2019</p>
<p>N Nanda, L Chan, T Lieberum, J Smith, J Steinhardt, arXiv:2301.05217Progress measures for grokking via mechanistic interpretability. 2023</p>
<p>Investigating the Limitations of Transformers with Simple Arithmetic Tasks, 1st Mathematical Reasoning in. R Nogueira, Z Jiang, J Lin, General Artificial Intelligence Workshop @ (ICLR). 2021</p>
<p>T Räuker, A Ho, S Casper, D Hadfield-Menell, arXiv:2207.13243Toward Transparent AI: A Survey on Interpreting the Inner Structures of Deep Neural Networks. 2023</p>
<p>S Ravfogel, Y Elazar, H Gonen, M Twiton, Y Goldberg, Null It Out: Guarding Protected Attributes by Iterative Nullspace Projection, 58th Annual Meeting of the Association for Computational Linguistics. 2020</p>
<p>Correlation Coefficients: Appropriate Use and Interpretation. P Schober, C Boer, L Schwarte, 2018Anesthesia &amp; Analgesia126</p>
<p>A Mechanistic Interpretation of Arithmetic Reasoning in Language Models using Causal Mediation Analysis. A Stolfo, Y Belinkov, M Sachan, arXiv:2305.150542023</p>
<p>D Sundararaman, S Si, V Subramanian, G Wang, D Hazarika, L Carin, Methods for Numeracy-Preserving Word Embeddings, Conference on Empirical Methods in Natural Language Processing (EMNLP). 2020</p>
<p>Attention is All you Need. A Vaswani, N Shazeer, N Parmar, J Uszkoreit, L Jones, A Gomez, L Kaiser, I Polosukhin, Advances in Neural Information Processing Systems (NIPS). 201730</p>
<p>E Wallace, Y Wang, S Li, S Singh, M Gardner, arXiv:1909.07940Do NLP Models Know Numbers? Probing Numeracy in Embeddings. 2019</p>
<p>J Wei, Y Tay, R Bommasani, C Raffel, B Zoph, S Borgeaud, D Yogatama, M Bosma, D Zhou, D Metzler, E Chi, T Hashimoto, O Vinyals, P Liang, J Dean, W Fedus, Emergent Abilities of Large Language Models. TMLR2022</p>
<p>J Wei, X Wang, D Schuurmans, M Bosma, B Ichter, F Xia, E Chi, Q Le, D Zhou, arXiv:2201.11903Chain-of-Thought Prompting Elicits Reasoning in Large Language Models. 2022</p>
<p>J White, T Pimentel, N Saphra, R Cotterell, Non, Linear Structural Probe, Conference of the North American Chapter. the Association for Computational Linguistics2021</p>
<p>How well do Large Language Models perform in Arithmetic tasks. Z Yuan, H Yuan, C Tan, W Wang, S Huang, arXiv:2304.020152023</p>            </div>
        </div>

    </div>
</body>
</html>