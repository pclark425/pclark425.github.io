<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-4584 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-4584</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-4584</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-101.html">extraction-schema-101</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods, criteria, metrics, or frameworks for evaluating LLM-generated scientific theories, hypotheses, or explanations, including comparisons with human-generated theories.</div>
                <p><strong>Paper ID:</strong> paper-0885471c0215b3c0d31c82518066913f7f738128</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/0885471c0215b3c0d31c82518066913f7f738128" target="_blank">Phenomenal Yet Puzzling: Testing Inductive Reasoning Capabilities of Language Models with Hypothesis Refinement</a></p>
                <p><strong>Paper Venue:</strong> International Conference on Learning Representations</p>
                <p><strong>Paper TL;DR:</strong> This work conducts a systematic study of the inductive reasoning capabilities of LMs through iterative hypothesis refinement, a technique that more closely mirrors the human inductive process than standard input-output prompting.</p>
                <p><strong>Paper Abstract:</strong> The ability to derive underlying principles from a handful of observations and then generalize to novel situations -- known as inductive reasoning -- is central to human intelligence. Prior work suggests that language models (LMs) often fall short on inductive reasoning, despite achieving impressive success on research benchmarks. In this work, we conduct a systematic study of the inductive reasoning capabilities of LMs through iterative hypothesis refinement, a technique that more closely mirrors the human inductive process than standard input-output prompting. Iterative hypothesis refinement employs a three-step process: proposing, selecting, and refining hypotheses in the form of textual rules. By examining the intermediate rules, we observe that LMs are phenomenal hypothesis proposers (i.e., generating candidate rules), and when coupled with a (task-specific) symbolic interpreter that is able to systematically filter the proposed set of rules, this hybrid approach achieves strong results across inductive reasoning benchmarks that require inducing causal relations, language-like instructions, and symbolic concepts. However, they also behave as puzzling inductive reasoners, showing notable performance gaps between rule induction (i.e., identifying plausible rules) and rule application (i.e., applying proposed rules to instances), suggesting that LMs are proposing hypotheses without being able to actually apply the rules. Through empirical and human analyses, we further reveal several discrepancies between the inductive reasoning processes of LMs and humans, shedding light on both the potentials and limitations of using LMs in inductive reasoning tasks.</p>
                <p><strong>Cost:</strong> 0.022</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e4584.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e4584.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods, criteria, metrics, or frameworks for evaluating LLM-generated scientific theories, hypotheses, or explanations, including comparisons with human-generated theories.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Iterative Hypothesis Refinement</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Iterative Hypothesis Refinement (Propose-Select-Refine with symbolic interpreter)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A three-step, iterative framework where an LLM proposes multiple candidate textual hypotheses, a symbolic interpreter executes/validates them on exemplars to score and select the best candidate, and the LLM receives template-based feedback (incorrect exemplars) to refine the selected hypothesis across up to T iterations.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_method_name</strong></td>
                            <td>Iterative Hypothesis Refinement (Propose–Select–Refine)</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_method_description</strong></td>
                            <td>At each iteration t the LM samples N hypotheses h_i conditioned on the seen exemplars and prior feedback d^{t-1}. Each hypothesis h is 'compiled' by a task-specific interpreter I_tau into a function I_tau(h) that can be executed on seen inputs. Hypotheses are scored by accuracy on the seen examples: s(h,D^s)= (1/|D^s|) sum_{(x,y) in D^s} 1[I_tau(h)(x)=y]. The top hypothesis is selected (argmax s) and used to generate template feedback d^t containing the examples it mispredicted (input, expected output, tentative output). The LM uses d^t to refine hypotheses in the next iteration. The loop stops when the selected hypothesis perfectly fits seen examples or the maximum iterations T is reached. Final evaluation uses the interpreter-applied hypothesis on unseen examples (accuracy). Hyperparameters: N (hypotheses per iteration), T (max iterations), generation temperature; representation of h can be free-text or code (LM may also be asked to translate free text to code for I_tau).</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_criteria</strong></td>
                            <td>Precision (correctness on examples where hypothesis applies), coverage (portion of examples the hypothesis covers), generalization to unseen examples (unseen-set accuracy a_tau), task-level consistency (task accuracy c_t: fraction of tasks fully solved), interpretability (examining intermediate textual rules), and robustness/OOD behavior (performance under noise/representation shifts).</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>GPT-4 (primary); additional experiments with GPT-3.5, Claude-2, LLaMA2-70B</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>scientific_domain</strong></td>
                            <td>Cognitive science / inductive reasoning; tasks span causal induction, instruction induction, symbolic list operations, visual-concept transformations</td>
                        </tr>
                        <tr>
                            <td><strong>theory_type</strong></td>
                            <td>Rule-based hypotheses: causal rules, language-like instructions (grammars), symbolic operations (list functions), and visual/grid transformation rules</td>
                        </tr>
                        <tr>
                            <td><strong>human_comparison</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_results</strong></td>
                            <td>Iterative refinement (T=3, N=5) substantially outperformed standard IO prompting and other baselines on most datasets: Raw accuracy (T=3,N=5) — ACRE 82.5%, MiniSCAN 93.3%, List Functions 71.2%, MiniARC 18.7%. Task accuracy (fraction of tasks with perfect unseen accuracy) — ACRE 59.0%, MiniSCAN 85.0%, List Functions 61.2%, MiniARC 14.6%. By contrast IO prompting (baseline) raw accuracies: ACRE 64.0%, MiniSCAN 61.7%, List Fns 65.1%, MiniARC 33.1%; task accuracies much lower and more discrepant. Ablations show sampling more hypotheses and iterating with external feedback is critical; replacing the symbolic interpreter with the LM as interpreter (Self-Refine) substantially reduces performance. Iterative refinement also shows improved OOD robustness relative to IO prompting (smaller performance drop on longer lists / larger grids).</td>
                        </tr>
                        <tr>
                            <td><strong>automated_vs_human_evaluation</strong></td>
                            <td>Hybrid: automated execution and quantitative metrics (seen/unseen accuracy, task accuracy, OOD tests) are core; complementary human evaluations assessed the form/quality of induced rules (clarity/supportiveness) in selected datasets.</td>
                        </tr>
                        <tr>
                            <td><strong>validation_method</strong></td>
                            <td>Validated by (a) comparing to multiple baselines (IO prompting, self-consistency sampling, self-refine), (b) ablation over hyperparameters (N, T), (c) cross-dataset performance, (d) OOD generalization experiments (longer lists, larger grids), and (e) human studies comparing LM-induced vs human-induced rules for interpretability metrics.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_challenges</strong></td>
                            <td>Relies on availability of a task-specific symbolic interpreter (I_tau) that correctly implements hypothesis semantics; interpreters may be imperfect. Scoring is based on seen examples and can overfit (select non-generalizable hypotheses). LMs can propose plausible rules but often cannot apply them (LM-as-interpreter performance drop). Results are on synthetic / constrained tasks (possible pretraining contamination); limited context length restricts T and number of exemplars; brittleness to noisy or unfamiliar exemplar encodings; translation errors when converting free-form rules to code.</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_dataset</strong></td>
                            <td>Evaluated on four benchmark domains assembled for this work: ACRE (Abstract Causal REasoning; causal induction), MiniSCAN (few-shot compositional instruction mapping), List Functions (symbolic list operation induction), MiniARC (5x5 ARC-like visual concept transformations).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Phenomenal Yet Puzzling: Testing Inductive Reasoning Capabilities of Language Models with Hypothesis Refinement', 'publication_date_yy_mm': '2023-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e4584.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e4584.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods, criteria, metrics, or frameworks for evaluating LLM-generated scientific theories, hypotheses, or explanations, including comparisons with human-generated theories.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Raw vs Task Accuracy</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Raw Accuracy and Task Accuracy (per-task perfect accuracy indicator)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Two complementary quantitative metrics: raw accuracy averages correct predictions across unseen examples, while task accuracy measures the fraction of tasks for which the induced rule is perfectly correct on all unseen examples.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_method_name</strong></td>
                            <td>Raw accuracy (c) and Task accuracy (c_t)</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_method_description</strong></td>
                            <td>Per task τ, compute unseen-example accuracy a_τ = (1/|D^u_τ|) Σ_{(x,y)∈D^u_τ} 1[I_τ(h)(x)=y]. Raw accuracy c = (1/|T|) Σ_τ a_τ (average unseen-example correctness across tasks). Task accuracy c_t = (1/|T|) Σ_τ 1[a_τ = 1] (fraction of tasks fully solved on all unseen examples). Raw accuracy measures average predictive performance; task accuracy measures whether a single induced rule fully captures a task (consistency across examples).</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_criteria</strong></td>
                            <td>Empirical adequacy on unseen examples (a_τ), consistency of a rule across all unseen instances (task-level completeness), and sensitivity to spurious correct example-level predictions.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>GPT-4 (used in computations of these metrics in experiments)</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>scientific_domain</strong></td>
                            <td>Inductive reasoning / machine evaluation of rule induction</td>
                        </tr>
                        <tr>
                            <td><strong>theory_type</strong></td>
                            <td>Predictive rule/hypothesis evaluation (measures generalization of induced rules)</td>
                        </tr>
                        <tr>
                            <td><strong>human_comparison</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_results</strong></td>
                            <td>Paper reports notable discrepancies between raw and task accuracy for baselines: e.g., IO prompting sometimes attains nontrivial raw accuracy but near-zero task accuracy, indicating many correct example-level predictions were not produced by a consistent rule. Iterative rule-based prompting reduces that discrepancy (higher task accuracies). Example numbers: IO prompting (across datasets) yields lower task accuracy than iterative refinement (see Table 1); iterative refinement (T=3,N=5) achieved task accuracy ACRE 59.0% vs IO 28.0%; MiniSCAN task accuracy 85.0% vs IO 0.0%.</td>
                        </tr>
                        <tr>
                            <td><strong>automated_vs_human_evaluation</strong></td>
                            <td>Automated: both metrics are computed from interpreter outputs on unseen examples; human studies were used separately to evaluate rule clarity/supportiveness, not these metrics directly.</td>
                        </tr>
                        <tr>
                            <td><strong>validation_method</strong></td>
                            <td>Empirical analysis across methods and datasets showing that task accuracy better reflects consistent rule induction and less spurious per-example correctness; comparisons with baselines and OOD experiments reinforce metric behaviors.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_challenges</strong></td>
                            <td>Raw accuracy can conflate spurious correct outputs with genuine rule-based generalization. Task accuracy is a strict 0/1 per task measure and can be harsh when few unseen examples exist (sensitive to dataset size). Both metrics depend on correct functioning of I_tau (interpreter).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Phenomenal Yet Puzzling: Testing Inductive Reasoning Capabilities of Language Models with Hypothesis Refinement', 'publication_date_yy_mm': '2023-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e4584.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e4584.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods, criteria, metrics, or frameworks for evaluating LLM-generated scientific theories, hypotheses, or explanations, including comparisons with human-generated theories.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Seen-example Scoring</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Seen-example Accuracy Scoring Function s(h, D^s)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A hypothesis ranking function that scores candidate hypotheses by their accuracy on the provided seen exemplars and selects the hypothesis with highest seen-example coverage for refinement.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_method_name</strong></td>
                            <td>Seen-example scoring (s(h, D^s) = accuracy on seen examples)</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_method_description</strong></td>
                            <td>For each candidate hypothesis h, compute s(h,D^s) = (1/|D^s|) Σ_{(x,y) in D^s} 1[I_τ(h)(x)=y]. Use this score to rank and select the best hypothesis at each iteration (argmax s). The selected hypothesis is then used to construct feedback consisting of the exemplars it mispredicts, which is fed back to the LM for refinement.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_criteria</strong></td>
                            <td>Maximizes empirical fit to provided exemplars (coverage+precision on D^s) as proxy for generalizability; implicitly trades off fitting seen examples vs potential overfitting.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>GPT-4 (used to generate hypotheses that are scored); interpreter executes hypotheses</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>scientific_domain</strong></td>
                            <td>Inductive rule-learning evaluation</td>
                        </tr>
                        <tr>
                            <td><strong>theory_type</strong></td>
                            <td>Rule selection for induced hypotheses</td>
                        </tr>
                        <tr>
                            <td><strong>human_comparison</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_results</strong></td>
                            <td>This scoring enabled effective hypothesis selection: iterative pipelines using this scorer achieved the best performance in most tasks. However, the authors observed overfitting in some settings (e.g., MiniSCAN) where high seen-example accuracy did not translate to unseen accuracy; configurations with different N,T show the effect (e.g., sometimes T=3,N=1 outperformed T=3,N=5 in MiniSCAN due to overfitting to exemplars).</td>
                        </tr>
                        <tr>
                            <td><strong>automated_vs_human_evaluation</strong></td>
                            <td>Fully automated (scoring by interpreter execution on seen examples).</td>
                        </tr>
                        <tr>
                            <td><strong>validation_method</strong></td>
                            <td>Ablation studies varying N and T, and cross-dataset comparisons showing where seen-example scoring led to non-generalizable selections (analysis and footnotes).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_challenges</strong></td>
                            <td>Overfitting to seen exemplars (selecting hypotheses that maximize seen accuracy but are not general); depends on fidelity of interpreter I_τ (wrong interpreter behavior undermines scoring); scoring ignores explicit simplicity/parsimony priors and may prefer complex hypotheses that fit examples.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Phenomenal Yet Puzzling: Testing Inductive Reasoning Capabilities of Language Models with Hypothesis Refinement', 'publication_date_yy_mm': '2023-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e4584.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e4584.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods, criteria, metrics, or frameworks for evaluating LLM-generated scientific theories, hypotheses, or explanations, including comparisons with human-generated theories.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Symbolic Interpreter Hybrid</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Neuro–Symbolic Hybrid: LM Proposer + Task-Specific Symbolic Interpreter</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A hybrid evaluation framework where the LM generates textual hypotheses and a separate symbolic interpreter (grammar parser, code runner, or custom deterministic function) compiles and executes those hypotheses to provide deterministic feedback and final application.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_method_name</strong></td>
                            <td>Neuro-symbolic evaluation via executable interpreters (I_tau)</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_method_description</strong></td>
                            <td>Each free-form or constrained hypothesis h is translated (or directly provided) into a representation executable by an interpreter I_tau, which maps Σ* (text) to a function in F (X→Y). The interpreter deterministically applies the hypothesized rule to inputs to produce outputs, enabling exact scoring on seen/unseen examples, selection, and refinement. Interpreters used include grammar parsers for MiniSCAN, ML-generated Python programs (LM-translated then executed) for List Functions and MiniARC, and deterministic set-based checks for ACRE.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_criteria</strong></td>
                            <td>Accuracy of applied rule on unseen examples, interpretability of induced textual hypotheses (human-readability), and ability to reuse a single hypothesis across many instances (task-level consistency).</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>LMs used as hypothesis proposers: GPT-4 primarily; symbolic interpreters are deterministic (parsers, Python runtimes).</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>scientific_domain</strong></td>
                            <td>Inductive reasoning, program induction, symbolic concept learning</td>
                        </tr>
                        <tr>
                            <td><strong>theory_type</strong></td>
                            <td>Executable rule/hypothesis evaluation (programmatic hypotheses, grammar rules, indicator functions)</td>
                        </tr>
                        <tr>
                            <td><strong>human_comparison</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_results</strong></td>
                            <td>Using symbolic interpreters to apply LM-proposed hypotheses yields strong improvements: iterative refinement with symbolic interpreters attained substantially higher task accuracies vs using the LM as interpreter. When the LM itself was used as the interpreter, performance often dropped precipitously (e.g., in MiniSCAN task accuracy dropped from >80% with symbolic interpreter to almost 0% with LM-as-interpreter). The hybrid approach also provided better OOD generalization and interpretability than IO prompting.</td>
                        </tr>
                        <tr>
                            <td><strong>automated_vs_human_evaluation</strong></td>
                            <td>Primarily automated (deterministic execution of compiled hypotheses); human evaluation used separately to assess rule clarity and supportiveness.</td>
                        </tr>
                        <tr>
                            <td><strong>validation_method</strong></td>
                            <td>Direct comparison of results when applying the same LM-induced rules via symbolic interpreters vs via the LM (tables and plots), plus ablation on hypothesis representation (natural language vs Python) to measure translation impact.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_challenges</strong></td>
                            <td>Not all hypotheses are trivially compilable; translating free-form natural language rules to executable code can introduce errors; requires designing task-specific interpreters (limits generality); interpreters might not reflect how humans would apply rules; reliance on interpreters masks the LM's inability to apply its own rules.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Phenomenal Yet Puzzling: Testing Inductive Reasoning Capabilities of Language Models with Hypothesis Refinement', 'publication_date_yy_mm': '2023-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e4584.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e4584.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods, criteria, metrics, or frameworks for evaluating LLM-generated scientific theories, hypotheses, or explanations, including comparisons with human-generated theories.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Human Rule Evaluation (Clarity & Supportiveness)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Human Pairwise Evaluation using Clarity and Supportiveness</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A human evaluation framework where crowdworkers write hypotheses for tasks and other annotators perform pairwise comparisons of LM-induced vs human-induced rules using metrics 'clarity' and 'supportiveness'.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_method_name</strong></td>
                            <td>Human pairwise rule evaluation with Clarity & Supportiveness</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_method_description</strong></td>
                            <td>For a sampled set of tasks (50 tasks each for List Functions and MiniARC), three annotators wrote rules and a separate set of annotators (three per rule pair) compared LM-induced and human-induced rules. Each comparison used a 4-label pairwise choice: 'LM-induced rule is better', 'human-induced rule is better', 'equally good', or 'equally bad'. Clarity measures whether the rule provides a clear explanation of the transformation; supportiveness measures how well the rule aligns with the provided examples.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_criteria</strong></td>
                            <td>Clarity (readability and communicative quality), supportiveness (agreement with exemplars), and qualitative differences such as pragmatic strategies, use of commonsense, algebraic succinctness.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>scientific_domain</strong></td>
                            <td>Human-machine comparative evaluation of induced explanations/rules</td>
                        </tr>
                        <tr>
                            <td><strong>theory_type</strong></td>
                            <td>Qualitative/communicative properties of induced rule descriptions (interpretative theories/explanations)</td>
                        </tr>
                        <tr>
                            <td><strong>human_comparison</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_results</strong></td>
                            <td>Qualitative and pairwise results: On List Functions (where LM performance was strong), LM-induced rules were often comparable or even better than human-induced rules in many cases, though some LM rules mis-explained patterns. On MiniARC, human-induced rules were generally clearer and more pragmatic (using high-level actions, commonsense descriptions), while LM rules were verbose and harder to interpret. Exact numeric pairwise tallies are not provided in the main text; the study showed systematic qualitative differences.</td>
                        </tr>
                        <tr>
                            <td><strong>automated_vs_human_evaluation</strong></td>
                            <td>Human-based (crowdworker authorship and human pairwise judgments).</td>
                        </tr>
                        <tr>
                            <td><strong>validation_method</strong></td>
                            <td>Multiple annotators for writing (3 per task) and for evaluation (3 per rule pair) to obtain redundancy; metrics follow precedents in prior work (Saha et al., Chen et al.).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_challenges</strong></td>
                            <td>Study covered a subset of tasks (50 per dataset) and not all LM experiments; annotators found separating supportiveness from generalizability difficult; no reported inter-rater reliability statistics in main text; crowdworker judgments can be subjective and dependent on prompt framing.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Phenomenal Yet Puzzling: Testing Inductive Reasoning Capabilities of Language Models with Hypothesis Refinement', 'publication_date_yy_mm': '2023-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e4584.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e4584.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods, criteria, metrics, or frameworks for evaluating LLM-generated scientific theories, hypotheses, or explanations, including comparisons with human-generated theories.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>OOD Robustness Tests</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Out-of-Distribution and Robustness Evaluations (Noise Injection & Representation Familiarity)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Experimental protocols to assess how induced hypotheses generalize under distributional shifts: (1) inject noise into exemplar outputs at different rates, and (2) vary familiarity by replacing tokens with pseudowords or different output vocabularies; also evaluate longer sequences / larger grids as OOD tests.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_method_name</strong></td>
                            <td>OOD robustness: exemplar-noise perturbation & familiarity/representation shift tests</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_method_description</strong></td>
                            <td>Two main manipulations: (A) Noisiness — randomly perturb 1–2 elements in a fraction (12.5%, 25%, 50%) of the seen exemplars (List Functions with 8 exemplars) and measure drop in raw/task accuracy. (B) Familiarity — change representation/vocabulary of outputs (MiniSCAN) to English words vs pseudowords and measure accuracy change; (C) structural OOD — evaluate on longer lists (List Functions) or larger grids (MiniARC) while holding seen exemplars fixed. Comparisons are made between iterative refinement and IO prompting, and between symbolic interpreter and LM-as-interpreter.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_criteria</strong></td>
                            <td>Sensitivity of induced-rule generalization to exemplar noise and representational familiarity, measured by absolute and relative drops in raw and task accuracy; robustness across model types and prompting configurations.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>GPT-4 (primary), with comparative experiments using GPT-3.5 and Claude-2</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>scientific_domain</strong></td>
                            <td>Inductive reasoning robustness and generalization</td>
                        </tr>
                        <tr>
                            <td><strong>theory_type</strong></td>
                            <td>Stability of induced rules/explanations under noisy or unfamiliar data</td>
                        </tr>
                        <tr>
                            <td><strong>human_comparison</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_results</strong></td>
                            <td>LM performance degrades substantially even with a single noisy example; for GPT-4 (T=1,N=1) on List Functions raw accuracy dropped from 51.6% (0% noise) to 49.6% (12.5% noise), 36.7% (25%), and 23.1% (50%) with similar task-accuracy declines. Familiarity tests (MiniSCAN) show raw accuracy declines when the output representation deviates from LM pretraining: GPT-4 raw 77.0% (English outputs) vs 72.0% (pseudowords); task accuracy 46.0% vs 38.0%. IO prompting shows larger OOD degradation than rule prompting; LM-as-interpreter also performs worse.</td>
                        </tr>
                        <tr>
                            <td><strong>automated_vs_human_evaluation</strong></td>
                            <td>Automated metric-based evaluation augmented by a human study comparing relative robustness drops for humans vs LMs.</td>
                        </tr>
                        <tr>
                            <td><strong>validation_method</strong></td>
                            <td>Cross-model experiments and ablations (different T,N), OOD structural tests, and a small human study showing both humans and LMs degrade but LMs degrade more.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_challenges</strong></td>
                            <td>Limited exemplar counts can make perturbations render tasks ill-defined; some performance drops may be dataset-specific; human study coverage limited; representation familiarity conflates pretraining exposure and true abstraction capability.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Phenomenal Yet Puzzling: Testing Inductive Reasoning Capabilities of Language Models with Hypothesis Refinement', 'publication_date_yy_mm': '2023-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e4584.6">
                <h3 class="extraction-instance">Extracted Data Instance 6 (e4584.6)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods, criteria, metrics, or frameworks for evaluating LLM-generated scientific theories, hypotheses, or explanations, including comparisons with human-generated theories.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Baseline Prompting Methods</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Baseline Prompting Methods: Input–Output (IO) Prompting, Self-Consistency (SC), Self-Refine (SR)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Comparative baseline frameworks used to evaluate LLM inductive capabilities: IO prompting directly predicts outputs per example; SC samples multiple outputs and picks the majority (self-consistency); SR uses the LM as both proposer and interpreter with iterative self-feedback.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_method_name</strong></td>
                            <td>Baselines: IO prompting, Self-Consistency sampling, Self-Refine (LM-as-interpreter iterative)</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_method_description</strong></td>
                            <td>IO prompting: LM is prompted with exemplars and asked to predict unseen outputs directly. Self-Consistency: sample multiple LM outputs (N=5) and take the majority-vote answer. Self-Refine: LM iteratively generates outputs and self-feedback using itself as the interpreter (no symbolic interpreter). These baselines are used to contrast performance, consistency, and interpretability against the proposed iterative hypothesis refinement with symbolic execution.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_criteria</strong></td>
                            <td>Unseen-example raw accuracy, task accuracy, consistency (raw vs task discrepancy), and ability to produce interpretable intermediate rules.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>GPT-4 (evaluated with these baselines), also GPT-3.5, Claude-2, LLaMA2-70B</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>scientific_domain</strong></td>
                            <td>LLM evaluation methods for inductive/predictive tasks</td>
                        </tr>
                        <tr>
                            <td><strong>theory_type</strong></td>
                            <td>Direct IO prediction & self-sampling baselines vs rule-induction frameworks</td>
                        </tr>
                        <tr>
                            <td><strong>human_comparison</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_results</strong></td>
                            <td>IO prompting sometimes attains competitive raw accuracy (e.g., MiniARC raw accuracy 33.1% IO vs 18.7% rule prompting) but exhibits much lower task accuracy and worse OOD generalization; SC provides limited gains and can be harmed by sampling incorrect predictions; SR (LM as interpreter) underperforms relative to the hybrid symbolic approach (e.g., SR T=3,N=5 raw acc ACRE 70.0% vs iterative rule prompting 82.5%). The iterative rule+symbolic method outperforms these baselines on the majority of datasets.</td>
                        </tr>
                        <tr>
                            <td><strong>automated_vs_human_evaluation</strong></td>
                            <td>Automated metric-based comparisons across methods (raw/task accuracies, OOD tests).</td>
                        </tr>
                        <tr>
                            <td><strong>validation_method</strong></td>
                            <td>Direct head-to-head experiments reported in tables, ablations varying T and N and interpreter choices.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_challenges</strong></td>
                            <td>IO prompting lacks interpretability of intermediate rules and can produce spurious correct outputs; self-consistency is sensitive to sampling temperature and may produce many incorrect variants; SR highlights the LM's weakness at being a reliable interpreter for its own rules.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Phenomenal Yet Puzzling: Testing Inductive Reasoning Capabilities of Language Models with Hypothesis Refinement', 'publication_date_yy_mm': '2023-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Hypothesis search: Inductive reasoning with language models <em>(Rating: 2)</em></li>
                <li>Instruction induction: From few examples to natural language task descriptions <em>(Rating: 2)</em></li>
                <li>How to grow a mind: Statistics, structure, and abstraction <em>(Rating: 2)</em></li>
                <li>Abstract Causal REasoning: Beyond Covariation (ACRE) <em>(Rating: 2)</em></li>
                <li>Human-level concept learning through probabilistic program induction <em>(Rating: 1)</em></li>
                <li>Self-refine: Iterative refinement with self-feedback <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-4584",
    "paper_id": "paper-0885471c0215b3c0d31c82518066913f7f738128",
    "extraction_schema_id": "extraction-schema-101",
    "extracted_data": [
        {
            "name_short": "Iterative Hypothesis Refinement",
            "name_full": "Iterative Hypothesis Refinement (Propose-Select-Refine with symbolic interpreter)",
            "brief_description": "A three-step, iterative framework where an LLM proposes multiple candidate textual hypotheses, a symbolic interpreter executes/validates them on exemplars to score and select the best candidate, and the LLM receives template-based feedback (incorrect exemplars) to refine the selected hypothesis across up to T iterations.",
            "citation_title": "here",
            "mention_or_use": "use",
            "evaluation_method_name": "Iterative Hypothesis Refinement (Propose–Select–Refine)",
            "evaluation_method_description": "At each iteration t the LM samples N hypotheses h_i conditioned on the seen exemplars and prior feedback d^{t-1}. Each hypothesis h is 'compiled' by a task-specific interpreter I_tau into a function I_tau(h) that can be executed on seen inputs. Hypotheses are scored by accuracy on the seen examples: s(h,D^s)= (1/|D^s|) sum_{(x,y) in D^s} 1[I_tau(h)(x)=y]. The top hypothesis is selected (argmax s) and used to generate template feedback d^t containing the examples it mispredicted (input, expected output, tentative output). The LM uses d^t to refine hypotheses in the next iteration. The loop stops when the selected hypothesis perfectly fits seen examples or the maximum iterations T is reached. Final evaluation uses the interpreter-applied hypothesis on unseen examples (accuracy). Hyperparameters: N (hypotheses per iteration), T (max iterations), generation temperature; representation of h can be free-text or code (LM may also be asked to translate free text to code for I_tau).",
            "evaluation_criteria": "Precision (correctness on examples where hypothesis applies), coverage (portion of examples the hypothesis covers), generalization to unseen examples (unseen-set accuracy a_tau), task-level consistency (task accuracy c_t: fraction of tasks fully solved), interpretability (examining intermediate textual rules), and robustness/OOD behavior (performance under noise/representation shifts).",
            "model_name": "GPT-4 (primary); additional experiments with GPT-3.5, Claude-2, LLaMA2-70B",
            "model_size": null,
            "scientific_domain": "Cognitive science / inductive reasoning; tasks span causal induction, instruction induction, symbolic list operations, visual-concept transformations",
            "theory_type": "Rule-based hypotheses: causal rules, language-like instructions (grammars), symbolic operations (list functions), and visual/grid transformation rules",
            "human_comparison": true,
            "evaluation_results": "Iterative refinement (T=3, N=5) substantially outperformed standard IO prompting and other baselines on most datasets: Raw accuracy (T=3,N=5) — ACRE 82.5%, MiniSCAN 93.3%, List Functions 71.2%, MiniARC 18.7%. Task accuracy (fraction of tasks with perfect unseen accuracy) — ACRE 59.0%, MiniSCAN 85.0%, List Functions 61.2%, MiniARC 14.6%. By contrast IO prompting (baseline) raw accuracies: ACRE 64.0%, MiniSCAN 61.7%, List Fns 65.1%, MiniARC 33.1%; task accuracies much lower and more discrepant. Ablations show sampling more hypotheses and iterating with external feedback is critical; replacing the symbolic interpreter with the LM as interpreter (Self-Refine) substantially reduces performance. Iterative refinement also shows improved OOD robustness relative to IO prompting (smaller performance drop on longer lists / larger grids).",
            "automated_vs_human_evaluation": "Hybrid: automated execution and quantitative metrics (seen/unseen accuracy, task accuracy, OOD tests) are core; complementary human evaluations assessed the form/quality of induced rules (clarity/supportiveness) in selected datasets.",
            "validation_method": "Validated by (a) comparing to multiple baselines (IO prompting, self-consistency sampling, self-refine), (b) ablation over hyperparameters (N, T), (c) cross-dataset performance, (d) OOD generalization experiments (longer lists, larger grids), and (e) human studies comparing LM-induced vs human-induced rules for interpretability metrics.",
            "limitations_challenges": "Relies on availability of a task-specific symbolic interpreter (I_tau) that correctly implements hypothesis semantics; interpreters may be imperfect. Scoring is based on seen examples and can overfit (select non-generalizable hypotheses). LMs can propose plausible rules but often cannot apply them (LM-as-interpreter performance drop). Results are on synthetic / constrained tasks (possible pretraining contamination); limited context length restricts T and number of exemplars; brittleness to noisy or unfamiliar exemplar encodings; translation errors when converting free-form rules to code.",
            "benchmark_dataset": "Evaluated on four benchmark domains assembled for this work: ACRE (Abstract Causal REasoning; causal induction), MiniSCAN (few-shot compositional instruction mapping), List Functions (symbolic list operation induction), MiniARC (5x5 ARC-like visual concept transformations).",
            "uuid": "e4584.0",
            "source_info": {
                "paper_title": "Phenomenal Yet Puzzling: Testing Inductive Reasoning Capabilities of Language Models with Hypothesis Refinement",
                "publication_date_yy_mm": "2023-10"
            }
        },
        {
            "name_short": "Raw vs Task Accuracy",
            "name_full": "Raw Accuracy and Task Accuracy (per-task perfect accuracy indicator)",
            "brief_description": "Two complementary quantitative metrics: raw accuracy averages correct predictions across unseen examples, while task accuracy measures the fraction of tasks for which the induced rule is perfectly correct on all unseen examples.",
            "citation_title": "here",
            "mention_or_use": "use",
            "evaluation_method_name": "Raw accuracy (c) and Task accuracy (c_t)",
            "evaluation_method_description": "Per task τ, compute unseen-example accuracy a_τ = (1/|D^u_τ|) Σ_{(x,y)∈D^u_τ} 1[I_τ(h)(x)=y]. Raw accuracy c = (1/|T|) Σ_τ a_τ (average unseen-example correctness across tasks). Task accuracy c_t = (1/|T|) Σ_τ 1[a_τ = 1] (fraction of tasks fully solved on all unseen examples). Raw accuracy measures average predictive performance; task accuracy measures whether a single induced rule fully captures a task (consistency across examples).",
            "evaluation_criteria": "Empirical adequacy on unseen examples (a_τ), consistency of a rule across all unseen instances (task-level completeness), and sensitivity to spurious correct example-level predictions.",
            "model_name": "GPT-4 (used in computations of these metrics in experiments)",
            "model_size": null,
            "scientific_domain": "Inductive reasoning / machine evaluation of rule induction",
            "theory_type": "Predictive rule/hypothesis evaluation (measures generalization of induced rules)",
            "human_comparison": true,
            "evaluation_results": "Paper reports notable discrepancies between raw and task accuracy for baselines: e.g., IO prompting sometimes attains nontrivial raw accuracy but near-zero task accuracy, indicating many correct example-level predictions were not produced by a consistent rule. Iterative rule-based prompting reduces that discrepancy (higher task accuracies). Example numbers: IO prompting (across datasets) yields lower task accuracy than iterative refinement (see Table 1); iterative refinement (T=3,N=5) achieved task accuracy ACRE 59.0% vs IO 28.0%; MiniSCAN task accuracy 85.0% vs IO 0.0%.",
            "automated_vs_human_evaluation": "Automated: both metrics are computed from interpreter outputs on unseen examples; human studies were used separately to evaluate rule clarity/supportiveness, not these metrics directly.",
            "validation_method": "Empirical analysis across methods and datasets showing that task accuracy better reflects consistent rule induction and less spurious per-example correctness; comparisons with baselines and OOD experiments reinforce metric behaviors.",
            "limitations_challenges": "Raw accuracy can conflate spurious correct outputs with genuine rule-based generalization. Task accuracy is a strict 0/1 per task measure and can be harsh when few unseen examples exist (sensitive to dataset size). Both metrics depend on correct functioning of I_tau (interpreter).",
            "uuid": "e4584.1",
            "source_info": {
                "paper_title": "Phenomenal Yet Puzzling: Testing Inductive Reasoning Capabilities of Language Models with Hypothesis Refinement",
                "publication_date_yy_mm": "2023-10"
            }
        },
        {
            "name_short": "Seen-example Scoring",
            "name_full": "Seen-example Accuracy Scoring Function s(h, D^s)",
            "brief_description": "A hypothesis ranking function that scores candidate hypotheses by their accuracy on the provided seen exemplars and selects the hypothesis with highest seen-example coverage for refinement.",
            "citation_title": "here",
            "mention_or_use": "use",
            "evaluation_method_name": "Seen-example scoring (s(h, D^s) = accuracy on seen examples)",
            "evaluation_method_description": "For each candidate hypothesis h, compute s(h,D^s) = (1/|D^s|) Σ_{(x,y) in D^s} 1[I_τ(h)(x)=y]. Use this score to rank and select the best hypothesis at each iteration (argmax s). The selected hypothesis is then used to construct feedback consisting of the exemplars it mispredicts, which is fed back to the LM for refinement.",
            "evaluation_criteria": "Maximizes empirical fit to provided exemplars (coverage+precision on D^s) as proxy for generalizability; implicitly trades off fitting seen examples vs potential overfitting.",
            "model_name": "GPT-4 (used to generate hypotheses that are scored); interpreter executes hypotheses",
            "model_size": null,
            "scientific_domain": "Inductive rule-learning evaluation",
            "theory_type": "Rule selection for induced hypotheses",
            "human_comparison": false,
            "evaluation_results": "This scoring enabled effective hypothesis selection: iterative pipelines using this scorer achieved the best performance in most tasks. However, the authors observed overfitting in some settings (e.g., MiniSCAN) where high seen-example accuracy did not translate to unseen accuracy; configurations with different N,T show the effect (e.g., sometimes T=3,N=1 outperformed T=3,N=5 in MiniSCAN due to overfitting to exemplars).",
            "automated_vs_human_evaluation": "Fully automated (scoring by interpreter execution on seen examples).",
            "validation_method": "Ablation studies varying N and T, and cross-dataset comparisons showing where seen-example scoring led to non-generalizable selections (analysis and footnotes).",
            "limitations_challenges": "Overfitting to seen exemplars (selecting hypotheses that maximize seen accuracy but are not general); depends on fidelity of interpreter I_τ (wrong interpreter behavior undermines scoring); scoring ignores explicit simplicity/parsimony priors and may prefer complex hypotheses that fit examples.",
            "uuid": "e4584.2",
            "source_info": {
                "paper_title": "Phenomenal Yet Puzzling: Testing Inductive Reasoning Capabilities of Language Models with Hypothesis Refinement",
                "publication_date_yy_mm": "2023-10"
            }
        },
        {
            "name_short": "Symbolic Interpreter Hybrid",
            "name_full": "Neuro–Symbolic Hybrid: LM Proposer + Task-Specific Symbolic Interpreter",
            "brief_description": "A hybrid evaluation framework where the LM generates textual hypotheses and a separate symbolic interpreter (grammar parser, code runner, or custom deterministic function) compiles and executes those hypotheses to provide deterministic feedback and final application.",
            "citation_title": "here",
            "mention_or_use": "use",
            "evaluation_method_name": "Neuro-symbolic evaluation via executable interpreters (I_tau)",
            "evaluation_method_description": "Each free-form or constrained hypothesis h is translated (or directly provided) into a representation executable by an interpreter I_tau, which maps Σ* (text) to a function in F (X→Y). The interpreter deterministically applies the hypothesized rule to inputs to produce outputs, enabling exact scoring on seen/unseen examples, selection, and refinement. Interpreters used include grammar parsers for MiniSCAN, ML-generated Python programs (LM-translated then executed) for List Functions and MiniARC, and deterministic set-based checks for ACRE.",
            "evaluation_criteria": "Accuracy of applied rule on unseen examples, interpretability of induced textual hypotheses (human-readability), and ability to reuse a single hypothesis across many instances (task-level consistency).",
            "model_name": "LMs used as hypothesis proposers: GPT-4 primarily; symbolic interpreters are deterministic (parsers, Python runtimes).",
            "model_size": null,
            "scientific_domain": "Inductive reasoning, program induction, symbolic concept learning",
            "theory_type": "Executable rule/hypothesis evaluation (programmatic hypotheses, grammar rules, indicator functions)",
            "human_comparison": true,
            "evaluation_results": "Using symbolic interpreters to apply LM-proposed hypotheses yields strong improvements: iterative refinement with symbolic interpreters attained substantially higher task accuracies vs using the LM as interpreter. When the LM itself was used as the interpreter, performance often dropped precipitously (e.g., in MiniSCAN task accuracy dropped from &gt;80% with symbolic interpreter to almost 0% with LM-as-interpreter). The hybrid approach also provided better OOD generalization and interpretability than IO prompting.",
            "automated_vs_human_evaluation": "Primarily automated (deterministic execution of compiled hypotheses); human evaluation used separately to assess rule clarity and supportiveness.",
            "validation_method": "Direct comparison of results when applying the same LM-induced rules via symbolic interpreters vs via the LM (tables and plots), plus ablation on hypothesis representation (natural language vs Python) to measure translation impact.",
            "limitations_challenges": "Not all hypotheses are trivially compilable; translating free-form natural language rules to executable code can introduce errors; requires designing task-specific interpreters (limits generality); interpreters might not reflect how humans would apply rules; reliance on interpreters masks the LM's inability to apply its own rules.",
            "uuid": "e4584.3",
            "source_info": {
                "paper_title": "Phenomenal Yet Puzzling: Testing Inductive Reasoning Capabilities of Language Models with Hypothesis Refinement",
                "publication_date_yy_mm": "2023-10"
            }
        },
        {
            "name_short": "Human Rule Evaluation (Clarity & Supportiveness)",
            "name_full": "Human Pairwise Evaluation using Clarity and Supportiveness",
            "brief_description": "A human evaluation framework where crowdworkers write hypotheses for tasks and other annotators perform pairwise comparisons of LM-induced vs human-induced rules using metrics 'clarity' and 'supportiveness'.",
            "citation_title": "here",
            "mention_or_use": "use",
            "evaluation_method_name": "Human pairwise rule evaluation with Clarity & Supportiveness",
            "evaluation_method_description": "For a sampled set of tasks (50 tasks each for List Functions and MiniARC), three annotators wrote rules and a separate set of annotators (three per rule pair) compared LM-induced and human-induced rules. Each comparison used a 4-label pairwise choice: 'LM-induced rule is better', 'human-induced rule is better', 'equally good', or 'equally bad'. Clarity measures whether the rule provides a clear explanation of the transformation; supportiveness measures how well the rule aligns with the provided examples.",
            "evaluation_criteria": "Clarity (readability and communicative quality), supportiveness (agreement with exemplars), and qualitative differences such as pragmatic strategies, use of commonsense, algebraic succinctness.",
            "model_name": null,
            "model_size": null,
            "scientific_domain": "Human-machine comparative evaluation of induced explanations/rules",
            "theory_type": "Qualitative/communicative properties of induced rule descriptions (interpretative theories/explanations)",
            "human_comparison": true,
            "evaluation_results": "Qualitative and pairwise results: On List Functions (where LM performance was strong), LM-induced rules were often comparable or even better than human-induced rules in many cases, though some LM rules mis-explained patterns. On MiniARC, human-induced rules were generally clearer and more pragmatic (using high-level actions, commonsense descriptions), while LM rules were verbose and harder to interpret. Exact numeric pairwise tallies are not provided in the main text; the study showed systematic qualitative differences.",
            "automated_vs_human_evaluation": "Human-based (crowdworker authorship and human pairwise judgments).",
            "validation_method": "Multiple annotators for writing (3 per task) and for evaluation (3 per rule pair) to obtain redundancy; metrics follow precedents in prior work (Saha et al., Chen et al.).",
            "limitations_challenges": "Study covered a subset of tasks (50 per dataset) and not all LM experiments; annotators found separating supportiveness from generalizability difficult; no reported inter-rater reliability statistics in main text; crowdworker judgments can be subjective and dependent on prompt framing.",
            "uuid": "e4584.4",
            "source_info": {
                "paper_title": "Phenomenal Yet Puzzling: Testing Inductive Reasoning Capabilities of Language Models with Hypothesis Refinement",
                "publication_date_yy_mm": "2023-10"
            }
        },
        {
            "name_short": "OOD Robustness Tests",
            "name_full": "Out-of-Distribution and Robustness Evaluations (Noise Injection & Representation Familiarity)",
            "brief_description": "Experimental protocols to assess how induced hypotheses generalize under distributional shifts: (1) inject noise into exemplar outputs at different rates, and (2) vary familiarity by replacing tokens with pseudowords or different output vocabularies; also evaluate longer sequences / larger grids as OOD tests.",
            "citation_title": "here",
            "mention_or_use": "use",
            "evaluation_method_name": "OOD robustness: exemplar-noise perturbation & familiarity/representation shift tests",
            "evaluation_method_description": "Two main manipulations: (A) Noisiness — randomly perturb 1–2 elements in a fraction (12.5%, 25%, 50%) of the seen exemplars (List Functions with 8 exemplars) and measure drop in raw/task accuracy. (B) Familiarity — change representation/vocabulary of outputs (MiniSCAN) to English words vs pseudowords and measure accuracy change; (C) structural OOD — evaluate on longer lists (List Functions) or larger grids (MiniARC) while holding seen exemplars fixed. Comparisons are made between iterative refinement and IO prompting, and between symbolic interpreter and LM-as-interpreter.",
            "evaluation_criteria": "Sensitivity of induced-rule generalization to exemplar noise and representational familiarity, measured by absolute and relative drops in raw and task accuracy; robustness across model types and prompting configurations.",
            "model_name": "GPT-4 (primary), with comparative experiments using GPT-3.5 and Claude-2",
            "model_size": null,
            "scientific_domain": "Inductive reasoning robustness and generalization",
            "theory_type": "Stability of induced rules/explanations under noisy or unfamiliar data",
            "human_comparison": true,
            "evaluation_results": "LM performance degrades substantially even with a single noisy example; for GPT-4 (T=1,N=1) on List Functions raw accuracy dropped from 51.6% (0% noise) to 49.6% (12.5% noise), 36.7% (25%), and 23.1% (50%) with similar task-accuracy declines. Familiarity tests (MiniSCAN) show raw accuracy declines when the output representation deviates from LM pretraining: GPT-4 raw 77.0% (English outputs) vs 72.0% (pseudowords); task accuracy 46.0% vs 38.0%. IO prompting shows larger OOD degradation than rule prompting; LM-as-interpreter also performs worse.",
            "automated_vs_human_evaluation": "Automated metric-based evaluation augmented by a human study comparing relative robustness drops for humans vs LMs.",
            "validation_method": "Cross-model experiments and ablations (different T,N), OOD structural tests, and a small human study showing both humans and LMs degrade but LMs degrade more.",
            "limitations_challenges": "Limited exemplar counts can make perturbations render tasks ill-defined; some performance drops may be dataset-specific; human study coverage limited; representation familiarity conflates pretraining exposure and true abstraction capability.",
            "uuid": "e4584.5",
            "source_info": {
                "paper_title": "Phenomenal Yet Puzzling: Testing Inductive Reasoning Capabilities of Language Models with Hypothesis Refinement",
                "publication_date_yy_mm": "2023-10"
            }
        },
        {
            "name_short": "Baseline Prompting Methods",
            "name_full": "Baseline Prompting Methods: Input–Output (IO) Prompting, Self-Consistency (SC), Self-Refine (SR)",
            "brief_description": "Comparative baseline frameworks used to evaluate LLM inductive capabilities: IO prompting directly predicts outputs per example; SC samples multiple outputs and picks the majority (self-consistency); SR uses the LM as both proposer and interpreter with iterative self-feedback.",
            "citation_title": "here",
            "mention_or_use": "use",
            "evaluation_method_name": "Baselines: IO prompting, Self-Consistency sampling, Self-Refine (LM-as-interpreter iterative)",
            "evaluation_method_description": "IO prompting: LM is prompted with exemplars and asked to predict unseen outputs directly. Self-Consistency: sample multiple LM outputs (N=5) and take the majority-vote answer. Self-Refine: LM iteratively generates outputs and self-feedback using itself as the interpreter (no symbolic interpreter). These baselines are used to contrast performance, consistency, and interpretability against the proposed iterative hypothesis refinement with symbolic execution.",
            "evaluation_criteria": "Unseen-example raw accuracy, task accuracy, consistency (raw vs task discrepancy), and ability to produce interpretable intermediate rules.",
            "model_name": "GPT-4 (evaluated with these baselines), also GPT-3.5, Claude-2, LLaMA2-70B",
            "model_size": null,
            "scientific_domain": "LLM evaluation methods for inductive/predictive tasks",
            "theory_type": "Direct IO prediction & self-sampling baselines vs rule-induction frameworks",
            "human_comparison": false,
            "evaluation_results": "IO prompting sometimes attains competitive raw accuracy (e.g., MiniARC raw accuracy 33.1% IO vs 18.7% rule prompting) but exhibits much lower task accuracy and worse OOD generalization; SC provides limited gains and can be harmed by sampling incorrect predictions; SR (LM as interpreter) underperforms relative to the hybrid symbolic approach (e.g., SR T=3,N=5 raw acc ACRE 70.0% vs iterative rule prompting 82.5%). The iterative rule+symbolic method outperforms these baselines on the majority of datasets.",
            "automated_vs_human_evaluation": "Automated metric-based comparisons across methods (raw/task accuracies, OOD tests).",
            "validation_method": "Direct head-to-head experiments reported in tables, ablations varying T and N and interpreter choices.",
            "limitations_challenges": "IO prompting lacks interpretability of intermediate rules and can produce spurious correct outputs; self-consistency is sensitive to sampling temperature and may produce many incorrect variants; SR highlights the LM's weakness at being a reliable interpreter for its own rules.",
            "uuid": "e4584.6",
            "source_info": {
                "paper_title": "Phenomenal Yet Puzzling: Testing Inductive Reasoning Capabilities of Language Models with Hypothesis Refinement",
                "publication_date_yy_mm": "2023-10"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Hypothesis search: Inductive reasoning with language models",
            "rating": 2
        },
        {
            "paper_title": "Instruction induction: From few examples to natural language task descriptions",
            "rating": 2
        },
        {
            "paper_title": "How to grow a mind: Statistics, structure, and abstraction",
            "rating": 2
        },
        {
            "paper_title": "Abstract Causal REasoning: Beyond Covariation (ACRE)",
            "rating": 2
        },
        {
            "paper_title": "Human-level concept learning through probabilistic program induction",
            "rating": 1
        },
        {
            "paper_title": "Self-refine: Iterative refinement with self-feedback",
            "rating": 1
        }
    ],
    "cost": 0.021991999999999998,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Phenomenal Yet Puzzling: Testing Inductive Reasoning Capabilities of Language Models with Hypothesis Refinement</h1>
<p>Linlu Qiu ${ }^{1}$; Liwei Jiang ${ }^{2,3}$, Ximing Lu ${ }^{2,3}$, Melanie Sclar ${ }^{3}$, Valentina Pyatkin ${ }^{2,3}$, Chandra Bhagavatula ${ }^{2}$, Bailin Wang ${ }^{1}$, Yoon Kim ${ }^{1}$, Yejin Choi ${ }^{2,3}$, Nouha Dziri ${ }^{2}$, Xiang Ren ${ }^{2,4}$<br>${ }^{1}$ Massachusetts Institute of Technology, ${ }^{2}$ Allen Institute for Artificial Intelligence<br>${ }^{3}$ University of Washington, ${ }^{4}$ University of Southern California<br>linluqiu@mit.edu</p>
<h4>Abstract</h4>
<p>The ability to derive underlying principles from a handful of observations and then generalize to novel situations-known as inductive reasoning-is central to human intelligence. Prior work suggests that language models (LMs) often fall short on inductive reasoning, despite achieving impressive success on research benchmarks. In this work, we conduct a systematic study of the inductive reasoning capabilities of LMs through iterative hypothesis refinement, a technique that more closely mirrors the human inductive process than standard input-output prompting. Iterative hypothesis refinement employs a three-step process: proposing, selecting, and refining hypotheses in the form of textual rules. By examining the intermediate rules, we observe that LMs are phenomenal hypothesis proposers (i.e., generating candidate rules), and when coupled with a (task-specific) symbolic interpreter that is able to systematically filter the proposed set of rules, this hybrid approach achieves strong results across inductive reasoning benchmarks that require inducing causal relations, language-like instructions, and symbolic concepts. However, they also behave as puzzling inductive reasoners, showing notable performance gaps between rule induction (i.e., identifying plausible rules) and rule application (i.e., applying proposed rules to instances), suggesting that LMs are proposing hypotheses without being able to actually apply the rules. Through empirical and human analyses, we further reveal several discrepancies between the inductive reasoning processes of LMs and humans, shedding light on both the potentials and limitations of using LMs in inductive reasoning tasks. ${ }^{1}$</p>
<h2>1 INTRODUCTION</h2>
<p>Inductive reasoning, i.e., the ability to identify common patterns and form high-level abstractions from limited observations, is considered key to human intelligence (Lake et al., 2017; Chollet, 2019). For instance, humans can quickly identify the generalizable list operation rule "selecting the first item" based on only a few observations (Figure 1, top). Although the precise cognitive mechanisms behind inductive reasoning remain unknown, one compelling hypothesis in cognitive science posits that humans approach this challenge through an iterative process that involves proposing hypotheses, testing them against observations, and refining them accordingly (Heit, 2000; Fränken et al., 2022). Returning to the above example, while the hypothesis "selecting the smallest item" may seem plausible based on the first two examples, applying this rule to the final example reveals the need for refinement, ultimately favoring "selecting the first item" as a more accurate hypothesis.</p>
<p>With the increasing power of state-of-the-art LMs (OpenAI, 2023; Anthropic, 2023), there is growing interest in exploring these models' reasoning capabilities vis-à-vis human inductive reasoning. How are their performances and underlying mechanisms similar to (and contrasted with) those of humans? This work investigates LMs' inductive reasoning capabilities through the lens of iterative</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: An overview of the iterative hypothesis refinement approach. We generate $N$ hypotheses per iteration and iterate up to the maximum number of iterations $T$ (top). Example instances and representative good and bad rules for each task (bottom).
hypothesis refinement: hypotheses generation, selection, and refinement. Specifically, we use an LM to propose a set of free-form or constrained hypotheses based on observations. The proposed hypotheses are then verified against observations via off-the-shelf symbolic interpreters ${ }^{2}$, e.g., grammar parsers or code interpreters, which can determine if an hypothesis applies to specific instances. The hypothesis that covers most number of observations is then selected to be further refined by the LM. This process is repeated to induce the final hypothesis.</p>
<p>Results across four distinct tasks, including inducing causal relations (Zhang et al., 2021), languagelike compositional instructions (Lake et al., 2019), symbolic operations (Rule, 2020), and visual concepts (Kim et al., 2022b), show that this iterative hypothesis refinement process significantly improves upon standard input-output (IO) prompting. We find that LMs are particularly good at generating candidate rules, and when coupled with a symbolic interpreter that can provide accurate feedback with which to refine hypotheses, this hybrid induction approach is effective.</p>
<p>However, a closer inspection of the refinement pipeline reveals a more nuanced view of the putative inductive reasoning process of LMs. Despite being able to generate plausible candidate rules, LMs display a range of puzzling counterintuitive behaviors. For one, while we might expect humans to be able to apply the rules they propose, we find that LMs are often unable to correctly apply their own proposed rules (§4.1). Moreover, while humans can make robust inductions by abstracting away from small perturbations present in examples (e.g., different representational forms of examples), we observe LMs to be highly brittle in the face of even minor perturbations (§4.2). Finally, a human study reveals that rules induced by LMs generally have different content and form compared to rules generated by humans. LMs often provide verbose descriptions of patterns but fail to leverage pragmatic communication strategies commonly seen in human induction (§4.3).</p>
<p>Our study unveils the paradoxical inductive capabilities of LMs: they are simultaneously phenomenal hypothesis proposers and puzzling inductive reasoners. Our paper connects to classical approaches for concept induction (Tenenbaum et al., 2011; Ellis et al., 2023, i.a.), latent language optimization (Andreas et al., 2018; Mu et al., 2020, i.a.), and instruction induction (Honovich et al., 2023). While similar in spirit to recent work on exploring inductive reasoning with LMs (Wang et al., 2023a), our work offers a nuanced exploration of both the potentials and limitations of LMs.</p>
<h1>2 Inductive Reasoning with LMs: Experimental Setup</h1>
<p>We consider the rule induction problem of inferring a function $f: \mathcal{X} \rightarrow \mathcal{Y}$ that maps an input $x \in \mathcal{X}$ to an output $y \in \mathcal{Y}$. The rule, $f$, can take various forms, such as mathematical operations, grammar,</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>and even natural language descriptions (see Appendix D for examples). For each task $\tau$, we have a set of examples $\mathcal{D}<em _tau="\tau">{\tau}$ consisting of input-output pairs $(x, y)$. We further divide $\mathcal{D}</em>}$ into seen examples, $\mathcal{D<em _tau="\tau">{\tau}^{s}$, and unseen examples, $\mathcal{D}</em>}^{u}$. The goal is to induce the $f$ that best describes $\mathcal{D<em _tau="\tau">{\tau}$ using only $\mathcal{D}</em>}^{s}$. A good rule thus requires a balance between precision and coverage, i.e., it should be simultaneously expressive enough to capture $\mathcal{D<em _tau="\tau">{\tau}^{s}$ and generalizable to $\mathcal{D}</em>$.}^{u</p>
<p>We assess an LM’s ability to induce rules through prompting. Let $h \in \Sigma^{<em>}$ be a rule generated by an LM, where $\Sigma$ is the LM’s vocabulary. Since we cannot directly apply $h$ to $x$ ( $h$ is just a piece of text), we make use of an interpreter $I_{\tau}: \Sigma^{</em>} \rightarrow \mathcal{F}$ for each task $\tau$ where $\mathcal{F}$ is the space of all functions from $\mathcal{X}$ to $\mathcal{Y}$ (i.e., $f \in \mathcal{F}$ ). That is, the interpreter $I_{\tau}$ "compiles" $h$ into a function that can be applied to $x$. ${ }^{3}$ The quality of rules is evaluated based on their performance on unseen examples. Given an induced rule $h$ and $n$ unseen examples $\mathcal{D}<em 1="1">{\tau}^{u}=\left{\left(x</em>$,}, y_{1}\right), \ldots,\left(x_{n}, y_{n}\right)\right}$, we derive outputs $y_{i}^{\prime}$ by applying $I_{\tau}(h)$ to input $x_{i</p>
<p>$$
y_{i}^{\prime}=I_{\tau}(h)\left(x_{i}\right)
$$</p>
<p>Although it is ideal to have interpreters that can correctly apply $h$, such perfect interpreters might not always be available. Importantly, interpreters have no access to $\mathcal{D}_{\tau}^{s}$, and thus, the rule must contain sufficient information for interpreters to achieve strong performance when applying the rule.</p>
<p>We evaluate the quality of a rule $h$ using accuracy. More formally, for a task $\tau$ containing a set of unseen examples $\mathcal{D}_{\tau}^{u}$, we first define the accuracy for this particular task as</p>
<p>$$
a_{\tau}=\frac{1}{\left|\mathcal{D}<em _in="\in" _mathcal_D="\mathcal{D" _x_="(x," y_="y)">{\tau}^{u}\right|} \sum</em><em _tau="\tau">{\tau}^{u}} \mathbb{1}\left[I</em>(h)(x)=y\right]
$$</p>
<p>Let $\mathcal{T}$ denotes the set of all tasks within a dataset. We define raw accuracy $c$ and task accuracy $c_{t}$ as</p>
<p>$$
c=\frac{1}{|\mathcal{T}|} \sum_{\tau \in \mathcal{T}} a_{\tau} \quad c_{t}=\frac{1}{|\mathcal{T}|} \sum_{\tau \in \mathcal{T}} \mathbb{1}\left[a_{\tau}=1\right]
$$</p>
<p>While raw accuracy is the standard metric used in prior work, task accuracy could better estimate an LM's induction capability: a model should ideally consistently solve examples within a task. We use GPT-4 (gpt-4-0613; OpenAI, 2023) for all experiments and analyses. We include additional results of other models, including GPT-3.5 (gpt-3.5-turbo-0613), Claude-2 (Anthropic, 2023), and LLaMA2-70B (Touvron et al., 2023) in Appendix B.</p>
<h1>2.1 Iterative Hypothesis Refinement</h1>
<p>We consider an iterative approach to induce rules from LMs. We use LMs to propose a set of rules (i.e., hypotheses). We then select the best rule based on scores calculated using the interpreter function. We provide feedback to LMs for further refinement. See Figure 1 for an overview.</p>
<p>Specifically, given $k$ exemplars $\mathcal{D}<em 1="1">{\tau}^{s}=\left{\left(x</em>\right}$, from a prompted LM,}, y_{1}\right), \ldots,\left(x_{k}, y_{k}\right)\right}$, at iteration $t$, we sample $N$ hypotheses of rules, $H^{t}=\left{h_{1}^{t}, \ldots, h_{N}^{t</p>
<p>$$
h^{t} \sim P_{\mathrm{LM}}\left(\cdot \mid d^{t-1}, x_{1}, y_{1}, \ldots, x_{k}, y_{k}\right)
$$</p>
<p>where $d^{t-1}$ is the feedback from previous iterations and which is set to be an empty string at the initial iteration. Each hypothesis is re-ranked based on a scoring function $s\left(h, \mathcal{D}_{\tau}^{s}\right)$. We use accuracy over seen examples as the scoring function,</p>
<p>$$
s\left(h, \mathcal{D}<em _tau="\tau">{\tau}^{s}\right)=\frac{1}{\left|\mathcal{D}</em>}^{s}\right|} \sum_{(x, y) \in \mathcal{D<em _tau="\tau">{\tau}^{s}} \mathbb{1}\left[I</em>(h)(x)=y\right]
$$</p>
<p>The best hypothesis is selected via,</p>
<p>$$
h^{t^{*}}=\underset{h^{\prime} \in H^{t}}{\arg \max } s\left(h^{\prime}, \mathcal{D}_{\tau}^{s}\right)
$$</p>
<p>We then obtain feedback $d^{t}$ by passing the best hypothesis to a template-based feedback generator. The feedback $d^{t}$ is a concatenation of exemplars with incorrect predictions, formatted as input, expected output, and tentative output. The iteration stops if the interpreter produces correct outputs for all exemplars using the current hypothesis or if the maximum iteration $T$ is reached. In all experiments, we consider a combination of maximum number of iterations $T \in{1,3}$ and number of hypotheses per iteration $N \in{1,5}$. We use greedy decoding when generating a single hypothesis and set the temperature to 0.7 when generating multiple hypotheses following Wang et al. (2023b).</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<h1>2.2 DATASETS</h1>
<p>The above framework requires three specifications: the rule function $f$, the representation (i.e., the format and content) of $h$, and the interpreter $I$. We evaluate on 4 datasets (where each dataset consists of multiple tasks) and formulate these specifications as follows (see examples in Figure 1). We show the full dataset details in Appendix A.</p>
<p>ACRE. The Abstract Causal REasoning (ACRE; Zhang et al., 2021) is a diagnostic dataset designed to evaluate causal induction ability. It requires identifying a set of "Blicket" objects that will trigger a special machine. We can view $f$ as an indicator function s.t. $f(x ; B)=\mathbb{1}[B \cap x]$ where $B$ is the set of Blickets and $x$ is the presented objects. We constrain $h$ to classify each object into one of three categories: a Blicket, not a Blicket, or undetermined. $I(h)(x)$ is thus a deterministic function that checks the intersections between current objects and predicted Blickets.</p>
<p>MiniSCAN. Lake et al. (2019) developed a sequence-to-sequence task with only 14 training examples to measure few-shot concept learning ability. We refer to this as MiniSCAN following Nye et al. (2020). ${ }^{4}$ Similar to SCAN (Lake \&amp; Baroni, 2018), MiniSCAN requires translating an input command $x$ to an output action sequence $y$. We consider $f$ as a set of grammar rules that map the input symbols to the corresponding meaning representations. We use a quasi-synchronous context free grammar (Smith \&amp; Eisner, 2006) as our formalism for $h$ and use a parser as our interpreter $I(h)$.</p>
<p>List Functions. The List Functions dataset (Rule, 2020) is designed to evaluate human and machine concept learning ability. It requires identifying a function that maps the input list to its corresponding output list. Here $f$ is a primitive or compositional list operation. We represent $h$ as natural language description and implement the interpreter $I$ using a two-stage process. First, we ask an LM to translate the natural language hypothesis $h$ into a Python program. Then we execute this program to produce the corresponding outputs for given inputs. ${ }^{5}$</p>
<p>MiniARC. The Abstract Reasoning Corpus (ARC; Chollet, 2019) and its variants (Kim et al., 2022b; Acquaviva et al., 2022; Xu et al., 2023b; Moskvichev et al., 2023) aim to evaluate visual abstract reasoning over broad concepts. The $f$ here involves a transformation between input and output 2D grids, such as moving an object or swapping colors. We use natural language hypotheses $h$ and similarly interpret the hypotheses using a Python interpreter. Given the extensive grid size of the original ARC tasks and the limited context length of LMs, we consider MiniARC (Kim et al., 2022b), a 5x5 compact version of the ARC.</p>
<h2>3 LMS ARE PHENOMENAL HYPOTHESIS PROPOSERS</h2>
<p>Main Results. We compare hypothesis refinement with standard input-output (IO) prompting, self-consistency prompting (SC; Wang et al., 2023b), and self-refine (SR; Madaan et al., 2023). ${ }^{6}$ SC samples multiple outputs and selects the most consistent one by taking a majority vote. SR uses the same LM as an interpreter and provides feedback to itself, and is a "pure LM" baseline that does not utilize a symbolic interpreter. The results are shown in Table 1 (see Appendix C for existing human performance). Iterative hypothesis refinement achieves the strongest performance on 3 out of 4 datasets, demonstrating the effectiveness of this approach. However, it lags behind the baselines on raw accuracy of MiniARC, potentially because some tasks in MiniARC are heavily dependent on pattern matching, for which IO prompting might be more effective (Mirchandani et al., 2023). Additionally, due to the limited visual understanding capabilities inherent in text-only models, the performance on MiniARC is still far from optimal for all methods, in comparison to other datasets. ${ }^{7}$
Similar to prior work (Chen et al., 2023a; Olausson et al., 2023; Peng et al., 2023, i.a.), sampling more hypotheses and using iterative refinement with external feedback significantly boost LM per-</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>Table 1: Iterative hypothesis refinement results. $T$ refers to the maximum number of iterations. $N$ refers to the number of candidate hypotheses per iteration.</p>
<p>|  | Raw Accuracy |  |  |  | Task Accuracy |  |  |  |
| Method | ACRE | MiniSCAN | List Fns | MiniARC | ACRE | MiniSCAN | List Fns | MiniARC |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| IO | 64.0 | 61.7 | 65.1 | 33.1 | 28.0 | 0.0 | 39.6 | 13.8 |
| SC (N=5) | 65.0 | 61.1 | 65.0 | 31.3 | 29.0 | 0.0 | 38.0 | 13.1 |
| SR (T=3, N=5) | 70.0 | 46.3 | 67.4 | 15.1 | 32.0 | 0.0 | 52.0 | 9.2 |
| T=1, N=1 | 78.2 | 77.0 | 51.6 | 5.9 | 45.0 | 46.0 | 42.4 | 3.8 |
| T=1, N=5 | 79.8 | 86.6 | 62.4 | 12.8 | 48.0 | 70.0 | 52.4 | 9.2 |
| T=3, N=1 | 77.8 | 98.2 | 61.7 | 10.1 | 47.0 | 95.0 | 52.8 | 6.9 |
| T=3, N=5 | 82.5 | 93.3 | 71.2 | 18.7 | 59.0 | 85.0 | 61.2 | 14.6 |</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: Results for IID and OOD examples. For OOD evaluations, we sample longer lists for List Functions and annotate larger grids for MiniARC. IO prompting generally experiences more significant performance degradation compared to rule prompting (i.e., iterative hypothesis refinement).
formance, leading to the best accuracy on the majority of datasets. ${ }^{8}$ It is important to emphasize that both iterative refinement and external feedback are essential. Simply sampling more predictions and taking a majority vote (as SC prompting), does not necessarily improve performance. This might due to the fact that increasing the temperature for sampling results in many incorrect predictions. In contrast, increasing the number of hypotheses performs better due to the hypotheses selection process. An iterative approach that uses the LM itself as an interpreter (i.e., SR) is also insufficient. We observe performance substantially degrades when replacing the symbolic interpreter with an LM, suggesting that the LM can excel as a hypothesis proposer but performs poorly as an interpreter.</p>
<p>We also observe a significant discrepancy between raw accuracy and task accuracy, especially for IO prompting and SC prompting. Since these evaluations directly predict output for each individual example, there is no guarantee that the LM is solving the task following the underlying rules. In fact, the mismatch between raw accuracy and task accuracy indicates some correct predictions might be generated without using the expected computation. In contrast, rule prompting (i.e., applying the LM-proposed rules) suffers less from this issue as it re-uses the same rule across all examples.</p>
<p>OOD Generalization and Interpretability. In addition to strong performance, iterative hypothesis refinement also enables out-of-distribution (OOD) generalization and improves interpretability of models. For OOD evaluations, we sample longer examples from the ground-truth programs for List Functions, ${ }^{9}$ and annotate examples with a larger grid for MiniARC. We evaluate performance on these OOD examples while fixing the seen examples. We show the results in Figure 2. We observe a significant performance drop for OOD examples when using IO prompting. However, the degradation is less severe for rule prompting except task accuracy on MiniARC, suggesting the LM likely solves the task using generalizable operations. While IO prompting still achieves better raw accuracy on MiniARC in OOD evaluations, the performance gap between it and rule prompting is reduced. Rule prompting also allows us to examine the intermediate operations, thus improving the interpretability of models. We show examples of LM-induced rules in Table 2 and Table 12.</p>
<p><sup id="fnref5:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<h1>4 LMS ARE PUZZLING INDUCTIVE REASONERS</h1>
<p>Despite the strong performance of iterative refinement on inductive reasoning, we identify several puzzling behaviors of LMs that seems to differ from human intuition (Fukushima, 1986; Heit, 2000). We include related human studies and human evaluations in Appendix C. ${ }^{10}$</p>
<h3>4.1 LMS STRUGGLE WITH APPLYING THEIR PROPOSED RULES</h3>
<p>Previous results demonstrate that LMs perform as effective hypothesis proposers but poor interpreters. Here we examine the extent to which LMs "understand" the rules they propose. Specifically, given the rules induced from previous experiments, we test whether LMs can apply these rules to novel examples. We should expect comparable performance if LMs understand their own proposed rules. Results are shown in Figure 3. We observe a consistent performance drop when using the LM interpreter as opposed to the symbolic interpreter. This issue is especially significant on datasets like MiniSCAN, where rule application involves complex and recursive operations.
This performance inconsistency between rule induction and rule application reveals a counterintuitive behavior of LMs on inductive reasoning. Intuitively, once humans have induced a rule, they can use this rule in novel scenarios. However, LMs struggle with applying the rule, even if the rule was derived from themselves. Note that prior work has provided evidence suggesting that LMs might fall short on solving symbolic tasks (Dziri et al., 2023), and we do not claim that we should expect using an LM as the interpreter perform as effectively as a symbolic interpreter. However, the gaps are often so large (e.g., task accuracy dropping from more than $80 \%$ to almost-zero in MiniSCAN) that they are still nonetheless strong indicators of LMs' puzzling behaviors. ${ }^{11}$ In particular, LMs are able to generate meaningful hypotheses and improve them iteratively, but simultaneously fail to understand their proposed rules. This observation can be loosely related to other inconsistencies observed between generation and recognition in existing LMs (West et al., 2023). For instance, while LMs can identify errors in their own generations (Agrawal et al., 2023; Zhang et al., 2023b), they may also fail to validate a correct answer generated by themselves (Li et al., 2023).
<img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: Raw accuracy (left) and task accuracy (right) when applying the LM's proposed rules using symbolic interpreters or the LM itself as the interpreter.</p>
<h3>4.2 LMS ARE BRITTLE TO EXAMPLE PERTURBATIONS</h3>
<p>Our experiments so far only consider well-formed input-output pairs: we assume there always exists at least one ground-truth $f$ such that applying $f$ to the inputs will yield the corresponding outputs. We also assume examples are presented in the format that close to LM's pre-training distribution. However, in practice, low-quality examples are ubiquitous. Humans can often reason robustly despite a certain level of noise, such as disregarding typos or a few erroneous examples (Fukushima, 1986; Heit, 2000). We now investigate if LMs can similarly make robust inductions. We use iterative hypothesis refinement with $T=3$ and $N=5$, which has the strongest performance in our main experiments. We include results using other models and configurations in Appendix B.3.
Noisiness of Exemplars. We first study LMs' robustness to noisy examples. Specifically, we use List Functions and introduce noise into a certain percentage of exemplars by randomly replacing 1-2</p>
<p><sup id="fnref6:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>elements with other numbers in the outputs. We perturb 12.5%, 25%, and 50% of the examples, out of a total of 8 exemplars. We show results in Figure 4a. We find the LM performs substantially worse even with a single noisy example, and its performance consistently decreases as the amount of noise increases. Although explicitly instructing the LM to consider noisy examples (dashed line) mitigates this issue, the performance degradation remains significant (see Table 17 for the exact instructions). This brittleness raises another concerns about their otherwise promising performance. ${ }^{12}$
Familiarity of Exemplars. Next we study if LMs are robust to example representation. We examine this by varying the familiarity of exemplars, i.e., how well the examples are represented in the LMs' pre-training data. As rules represent higher-level abstraction, ideally we should expect LMs' performance to be independent of their specific instantiations (Newell, 1980). We use MiniSCAN dataset and re-generate new examples using the same grammar rules but with varied output vocabularies. We consider two variants: the first involves pseudowords as inputs with abstract English concepts as outputs (e.g., dax $\rightarrow$ RED), as the original setup in Lake et al. (2019). The second uses pseudowords for both inputs and outputs (e.g., dax $\rightarrow$ zup). The results are shown in Figure 4b. LMs' performance drops when the output representation deviates from their pre-training distribution. In such case, even an iterative approach cannot compensate for this degradation. ${ }^{13}$
<img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 4: (a) Varying example noisiness by perturbing a certain percentage of exemplars on List Functions. Dashed lines refer to results where we explicitly instruct LMs to consider noisy examples. (b) Varying example familiarity by using English words or pseudo-words as outputs on MiniSCAN.</p>
<h1>4.3 LM-INDUCED RULES VS. HUMAN-INDUCED RULES</h1>
<p>We have provided empirical evidence suggesting some discrepancies between inductive reasoning of LMs and humans. We now qualitatively examine if LM-induced rules are distinguishable from human-induced rules. We conduct analysis on List Functions and MiniARC, as they contain various concepts and represent tasks where the LM succeeds and fails, respectively. We randomly sample 50 tasks per dataset and conduct similar human studies by asking crowdworkers to write the rules.
We show example LM-induced rules and human-induced rules in Table 2. For List Functions where the LM achieves strong performance, the LM can often induce rules that are comparable to or even better than those from humans, with some exceptions where it incorrectly explains the pattern. On MiniARC, however, it tends to generate rules that are difficult to interpret, often involving verbose and complex descriptions. In contrast, similar to Acquaviva et al. (2022), we find that humans often use pragmatic communication strategies that go beyond pattern descriptions. For instance, they frequently draw upon physical commonsense knowledge (e.g., "drop or lift an object", "fill in each box"), use high-level actions (e.g., "copy or extend the block", "mirror the group"), and connect to real-world concepts (e.g., "staircase", "Tetris"). They also pose questions (e.g., "which color is more common in a row and by how many?") and utilize algebraic expressions (e.g., "if a number is repeated $n$ times then only output $n-1$ times") to facilitate effective communications.</p>
<p><sup id="fnref7:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>Table 2: Comparison between LM-induced rules and human-induced rules on List Functions (top) and MiniARC (bottom). 0 maps to black, 1 maps to blue, and 4 maps to yellow.</p>
<table>
<thead>
<tr>
<th>Examples</th>
<th>LM-induced Rule</th>
<th>Human-induced Rules</th>
</tr>
</thead>
<tbody>
<tr>
<td>$[97,97,97,97] \rightarrow[97,97,97]$</td>
<td>Remove the last occurrence of each unique</td>
<td>Annotator 1: Keep the order of the original</td>
</tr>
<tr>
<td>$[4,4,4] \rightarrow[4,4]$</td>
<td>number from the input list, but if a number</td>
<td>list but only include integers that are duplicates</td>
</tr>
<tr>
<td>$[33,0,6,1,2,24,66] \rightarrow[]$</td>
<td>appears more than twice, keep all instances</td>
<td>rom earlier in the list.</td>
</tr>
<tr>
<td>$[76,62,17,76,17] \rightarrow[76,17]$</td>
<td>except the last.</td>
<td>Annotator 2: Output only the repeated</td>
</tr>
<tr>
<td>$\ldots$</td>
<td></td>
<td>numbers. If a number is repeated n times</td>
</tr>
<tr>
<td></td>
<td></td>
<td>then output only n-1 times.</td>
</tr>
</tbody>
</table>
<p><img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>If an element in the input array is 4, replace it with 0 . If the element is 1 and its left and right neighboring elements are 0 , replace it with 1 . If the element is 1 and positioned in the last row of the array, replace it with 1. In all other cases, replace the element with 0 .</p>
<p>[10]*</p>
<p>[10]*</p>
<p>[10]*</p>
<p>[10]*</p>
<p>We further investigate how LMs refine their hypotheses. While we observe performance improvement over iterations (see Figure 5), we also notice that they tend to make minor modifications, typically by adding exceptions for a specific example, rather than starting from entirely new hypotheses. We observe several cases where the LM adds an "if-else" statement to the rules over iterations. For instance, the LM generates "Remove the value 2 from the input list." in the first iteration and refines it to "Remove the value 6 if it is present in the input list. If not, remove the value 2" in the subsequent iteration. This results in its failure to induce the correct rules if the initial hypothesis is entirely off.</p>
<h1>5 LIMITATIONS AND DISCUSSIONS</h1>
<p>Tasks. Humans perform inductive reasoning in everyday situations (Hume, 1904). However, our experiments mainly focus on synthetic and symbolic tasks, differing from the typical scenarios in which humans perform inductions. We chose our datasets based on two concerns. First, we interact with LMs using prompting. This restricts the number of seen examples due to LMs' limited context lengths. We selected our tasks because they are relatively constrained and well-defined, making it feasible to induce rules from only a few observations. ${ }^{14}$ Second, the inaccessibility of the training data complicates the evaluation of LMs' inductive learning abilities. It is challenging to distinguish whether LMs truly induce rules from observed examples or simply recall the fact from their prior knowledge. Therefore, we chose more synthetic and symbolic tasks, as we hypothesize that they are less likely to be present in the pre-training data, thus making inducing rules from observations necessary. Nonetheless, this confounding factor remains unless we fully inspect the training corpus.</p>
<p>Hyperparameters. The goal of this paper is to explore the potentials and limitations of LMs in inductive reasoning, rather than to improve the performance on specific inductive reasoning tasks. Therefore, we did not exhaustively tune hyperparameters $(T$ and $N$ ) or prompt templates. Our experiments use a maximum iteration $T=3$ due to the LMs' limited context lengths and a maximum number of hypotheses per iteration $N=5$. Our results demonstrate the correlations between model performance and these two hyperparameters. We expect improved performance when increasing these two hyperparameters, as suggested by Table 1 and recent work by Wang et al. (2023a).</p>
<p>Future Directions. Our study demonstrates the effectiveness of using LMs as hypothesis proposers. We show that, when paired with symbolic interpreters, LMs can achieve strong performance</p>
<p><sup id="fnref8:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>through iterative hypothesis refinement. However, out-of-the-box LMs struggle to solve inductive tasks on their own. This strengthens the need to explore neuro-symbolic approaches to utilize the strengths of both components (Ni et al., 2023; Wong et al., 2023, i.a.). Our study also only focuses on a fixed set of exemplars. Future work could explore methods to dynamically select the best exemplars. Additionally, our analyses identify several counter-intuitive model behaviors, highlighting the importance of understanding model behaviors and improving their robustness as future work.</p>
<h1>6 RELATED WORK</h1>
<p>Inductive Reasoning with LMs. Existing studies on inductive reasoning capabilities of pretrained large LMs (Gendron et al., 2023; Yang et al., 2022; Moskvichev et al., 2023; Mirchandani et al., 2023; Tang et al., 2023; Xu et al., 2023a; Han et al., 2023; Xu et al., 2023b; Alet et al., 2021; Webb et al., 2023) primarily use IO prompting. They focus on evaluating the accuracy of unseen examples but often overlook any intermediate operations. As we argue in our study, this evaluation lacks interpretability and can conflate with LMs' rule application abilities. We instead investigate an alternative evaluation by inducing rules from LMs. Similarly, Honovich et al. (2023) uses LMs to induce instructions from examples, but it only studies dataset-level instructions for simple tasks. Concurrent work (Wang et al., 2023a) that proposes hypothesis search is closest to ours, but we focus on understanding the potentials and limitations of LMs rather than improving LMs' performance.</p>
<p>Language Hypotheses Optimization. Many studies have explored the optimization of hypotheses over the space of natural language. Prior work on latent language for concept learning has mostly focused on few-shot image classification, and often involves training models (Andreas et al., 2018; Mu et al., 2020). Vong \&amp; Lake (2022) uses a pre-trained LM, but does not involve refining hypotheses iteratively. Some studies adopt similar iterative frameworks but focus on describing differences between text distributions (Zhong et al., 2022; 2023) or data patterns (Singh et al., 2022). While these hypotheses are relatively coarse-grained, our tasks require fine-grained hypotheses with high precision. Our study shows that, in such cases, a symbolic interpreter is essential to ensure the quality of hypotheses. Additionally, the iterative refinement approach is also related to a line of work on iterative prompting with execution feedback for synthesizing programs (Chen et al., 2023a; Olausson et al., 2023; Haluptzok et al., 2022; Key et al., 2022; Jiang et al., 2023; Zhang et al., 2023a). However, most of these studies use natural language descriptions, sometimes supplemented with optional examples, while ours only use input-output specifications.</p>
<p>Bayesian Concept Learning. Classical approaches to induction primarily follow a Bayesian paradigm: they start with a hypothesis space, compute the posterior distribution using Bayes' Rule, and update beliefs based on observations (Tenenbaum et al., 2011; Lake et al., 2015; Xu \&amp; Tenenbaum, 2007; Tenenbaum, 1999; Thaker et al., 2017; Kemp \&amp; Tenenbaum, 2009). The main challenge of these methods is the trade-off between expressiveness of hypothesis space and computational cost of posterior inference. Therefore, many of them resolve on searching over a constrained rule-based hypothesis space, such as probabilistic programs (Nosofsky et al., 1994; Piantadosi et al., 2016; Goodman et al., 2008; Bramley et al., 2018; Ellis et al., 2022; 2023). However, a domainspecific formulation of Language of Thought (Fodor, 1975; Erdogan et al., 2015; Saad et al., 2019; Tian et al., 2020; Sablé-Meyer et al., 2022) is often limited. Ellis (2023) addresses this by performing Bayesian inference over natural language. Our approach shares similar spirits of Bayesian models, but instead leverages LMs to generate and refine hypotheses via iterative prompting.</p>
<h2>7 CONCLUSION</h2>
<p>In this paper, we study the inductive reasoning capabilities of LMs and how their inductive reasoning behaviors differ from those of humans. We conduct this investigation through iterative hypothesis refinement, an approach that closely mirrors human inductive process. Iterative refinement operates as a three-step process: hypotheses generation, selection, and refinement. Through our experiments, we find that LMs excel as hypothesis proposers, achieving strong performance on most datasets when coupled with symbolic interpreters. However, we also identify several counter-intuitive behaviors, suggesting that LMs simultaneously behave as puzzling inductive reasoners. For instance, they struggle with applying their own proposed rules and are brittle to minor perturbations. Our study reveals the paradoxical inductive capabilities of LMs and sheds light on both the potentials and limitations of LMs in inductive reasoning tasks.</p>
<h1>ACKNOWLEDGMENTS</h1>
<p>We thank Jiangjie Chen, Peter Hase, Aniruddha Nrusimha, Kyle Richardson, Zhaofeng Wu, and AI2 Mosaic team for helpful comments and discussions. We thank Jena Hwang, Yufei Tian, and Huirong Wen for the help with human study and data annotation. This work was supported in-part by DARPA MCS program through NIWC Pacific (N66001-19-2-4031) and NSF (DMS-2134012). LQ, BW, and YK were partially supported by MIT-IBM Watson AI and an Amazon award. XR's research is supported in part by the Office of the Director of National Intelligence (ODNI), Intelligence Advanced Research Projects Activity (IARPA), via the HIATUS Program contract #2022-22072200006, the Defense Advanced Research Projects Agency with award HR00112220046, and NSF IIS 2048211.</p>
<h2>REFERENCES</h2>
<p>Sam Acquaviva, Yewen Pu, Marta Kryven, Theodoros Sechopoulos, Catherine Wong, Gabrielle Ecanow, Maxwell Nye, Michael Tessler, and Josh Tenenbaum. Communicating natural programs to humans and machines. Advances in Neural Information Processing Systems, 35:3731-3743, 2022.</p>
<p>Ayush Agrawal, Lester Mackey, and Adam Tauman Kalai. Do language models know when they're hallucinating references? ArXiv preprint, abs/2305.18248, 2023. URL https://arxiv. org/abs/2305.18248.</p>
<p>Ekin Akyurek and Jacob Andreas. Lexicon learning for few shot sequence modeling. In Proceedings of the 59th Annual Meeting of the Association for Computational Linguistics and the 11th International Joint Conference on Natural Language Processing (Volume 1: Long Papers), pp. 4934-4946, Online, August 2021. Association for Computational Linguistics. doi: 10.18653/v1/ 2021.acl-long.382. URL https://aclanthology.org/2021.acl-long.382.</p>
<p>Ferran Alet, Javier Lopez-Contreras, James Koppel, Maxwell I. Nye, Armando Solar-Lezama, Tomás Lozano-Pérez, Leslie Pack Kaelbling, and Joshua B. Tenenbaum. A large-scale benchmark for few-shot program induction and synthesis. In Marina Meila and Tong Zhang (eds.), Proceedings of the 38th International Conference on Machine Learning, ICML 2021, 18-24 July 2021, Virtual Event, volume 139 of Proceedings of Machine Learning Research, pp. 175-186. PMLR, 2021. URL http://proceedings.mlr.press/v139/alet21a.html.</p>
<p>Jacob Andreas, Dan Klein, and Sergey Levine. Learning with latent language. In Proceedings of the 2018 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long Papers), pp. 2166-2179, New Orleans, Louisiana, June 2018. Association for Computational Linguistics. doi: 10.18653/v1/N18-1197. URL https://aclanthology.org/N18-1197.</p>
<p>Anthropic. Claude 2, 2023. URL https://www.anthropic.com/index/claude-2.
BIG bench authors. Beyond the imitation game: Quantifying and extrapolating the capabilities of language models. Transactions on Machine Learning Research, 2023. ISSN 2835-8856. URL https://openreview.net/forum?id=uyTL5Bvos 3 .</p>
<p>Neil Bramley, Anselm Rothe, Josh Tenenbaum, Fei Xu, and Todd Gureckis. Grounding compositional hypothesis generation in specific instances. In Proceedings of the 40th annual conference of the cognitive science society, 2018.</p>
<p>Wenhu Chen, Xueguang Ma, Xinyi Wang, and William W Cohen. Program of thoughts prompting: Disentangling computation from reasoning for numerical reasoning tasks. ArXiv preprint, abs/2211.12588, 2022. URL https://arxiv.org/abs/2211.12588.</p>
<p>Xinyun Chen, Maxwell Lin, Nathanael Schärli, and Denny Zhou. Teaching large language models to self-debug. ArXiv preprint, abs/2304.05128, 2023a. URL https://arxiv.org/abs/ 2304.05128 .</p>
<p>Yanda Chen, Ruiqi Zhong, Narutatsu Ri, Chen Zhao, He He, Jacob Steinhardt, Zhou Yu, and Kathleen McKeown. Do models explain themselves? counterfactual simulatability of natural language explanations. ArXiv preprint, abs/2307.08678, 2023b. URL https://arxiv.org/abs/ 2307.08678 .</p>
<p>François Chollet. On the measure of intelligence. ArXiv preprint, abs/1911.01547, 2019. URL https://arxiv.org/abs/1911.01547.</p>
<p>Ishita Dasgupta, Andrew K Lampinen, Stephanie CY Chan, Antonia Creswell, Dharshan Kumaran, James L McClelland, and Felix Hill. Language models show human-like content effects on reasoning. ArXiv preprint, abs/2207.07051, 2022. URL https://arxiv.org/abs/2207. 07051 .</p>
<p>Jesse Dodge, Maarten Sap, Ana Marasović, William Agnew, Gabriel Ilharco, Dirk Groeneveld, Margaret Mitchell, and Matt Gardner. Documenting large webtext corpora: A case study on the colossal clean crawled corpus. In Proceedings of the 2021 Conference on Empirical Methods in Natural Language Processing, pp. 1286-1305, Online and Punta Cana, Dominican Republic, November 2021. Association for Computational Linguistics. doi: 10.18653/v1/2021.emnlp-main. 98. URL https://aclanthology.org/2021.emnlp-main. 98.</p>
<p>Nouha Dziri, Ximing Lu, Melanie Sclar, Xiang Lorraine Li, Liwei Jian, Bill Yuchen Lin, Peter West, Chandra Bhagavatula, Ronan Le Bras, Jena D Hwang, et al. Faith and fate: Limits of transformers on compositionality. ArXiv preprint, abs/2305.18654, 2023. URL https://arxiv.org/ abs/2305.18654.</p>
<p>Kevin Ellis. Modeling human-like concept learning with bayesian inference over natural language. ArXiv preprint, abs/2306.02797, 2023. URL https://arxiv.org/abs/2306.02797.</p>
<p>Kevin Ellis, Adam Albright, Armando Solar-Lezama, Joshua B Tenenbaum, and Timothy J O’Donnell. Synthesizing theories of human language with bayesian program induction. Nature communications, 13(1):5024, 2022.</p>
<p>Kevin Ellis, Lionel Wong, Maxwell Nye, Mathias Sable-Meyer, Luc Cary, Lore Anaya Pozo, Luke Hewitt, Armando Solar-Lezama, and Joshua B Tenenbaum. Dreamcoder: growing generalizable, interpretable knowledge with wake-sleep bayesian program learning. Philosophical Transactions of the Royal Society A, 381(2251):20220050, 2023.</p>
<p>Goker Erdogan, Ilker Yildirim, and Robert A Jacobs. From sensory signals to modality-independent conceptual representations: A probabilistic language of thought approach. PLoS computational biology, 11(11):e1004610, 2015.</p>
<p>Jonathan St BT Evans and Jodie Curtis-Holmes. Rapid responding increases belief bias: Evidence for the dual-process theory of reasoning. Thinking \&amp; Reasoning, 11(4):382-389, 2005.</p>
<p>Jerry A Fodor. The language of thought, volume 5. Harvard university press, 1975.
Jan-Philipp Fränken, Nikos C Theodoropoulos, and Neil R Bramley. Algorithms of adaptation in inductive inference. Cognitive Psychology, 137:101506, 2022.</p>
<p>Kunihiko Fukushima. A neural network model for selective attention in visual pattern recognition. Biological Cybernetics, 55(1):5-15, 1986.</p>
<p>Luyu Gao, Aman Madaan, Shuyan Zhou, Uri Alon, Pengfei Liu, Yiming Yang, Jamie Callan, and Graham Neubig. Pal: Program-aided language models. In International Conference on Machine Learning, pp. 10764-10799. PMLR, 2023.</p>
<p>Gaël Gendron, Qiming Bao, Michael Witbrock, and Gillian Dobbie. Large language models are not abstract reasoners. ArXiv preprint, abs/2305.19555, 2023. URL https : //arxiv.org/abs/ 2305.19555 .</p>
<p>Noah D Goodman, Joshua B Tenenbaum, Jacob Feldman, and Thomas L Griffiths. A rational analysis of rule-based concept learning. Cognitive science, 32(1):108-154, 2008.</p>
<p>Alison Gopnik, David M Sobel, Laura E Schulz, and Clark Glymour. Causal learning mechanisms in very young children: two-, three-, and four-year-olds infer causal relations from patterns of variation and covariation. Developmental psychology, 37(5):620, 2001.</p>
<p>Patrick Haluptzok, Matthew Bowers, and Adam Tauman Kalai. Language models can teach themselves to program better. In The Eleventh International Conference on Learning Representations, 2022.</p>
<p>Simon Jerome Han, Keith J Ransom, Andrew Perfors, and Charles Kemp. Inductive reasoning in humans and large language models. Cognitive Systems Research, pp. 101155, 2023.</p>
<p>Evan Heit. Properties of inductive reasoning. Psychonomic Bulletin \&amp; Review, 7:569-592, 2000.
Or Honovich, Uri Shaham, Samuel R. Bowman, and Omer Levy. Instruction induction: From few examples to natural language task descriptions. In Proceedings of the 61st Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pp. 1935-1952, Toronto, Canada, 2023. Association for Computational Linguistics. doi: 10.18653/v1/2023.acl-long.108. URL https://aclanthology.org/2023.acl-long. 108.</p>
<p>Yi Hu, Haotong Yang, Zhouchen Lin, and Muhan Zhang. Code prompting: a neural symbolic method for complex reasoning in large language models. ArXiv preprint, abs/2305.18507, 2023. URL https://arxiv.org/abs/2305.18507.</p>
<p>David Hume (ed.). Enquiry Concerning Human Understanding. Clarendon Press, 1904.
Shuyang Jiang, Yuhao Wang, and Yu Wang. Selfevolve: A code evolution framework via large language models. ArXiv preprint, abs/2306.02907, 2023. URL https://arxiv.org/abs/ 2306.02907.</p>
<p>Aysja Johnson, Wai Keen Vong, Brenden M Lake, and Todd M Gureckis. Fast and flexible: Human program induction in abstract reasoning tasks. arXiv preprint arXiv:2103.05823, 2021.</p>
<p>Charles Kemp and Joshua B Tenenbaum. Structured statistical models of inductive reasoning. Psychological review, 116(1):20, 2009.</p>
<p>Darren Key, Wen-Ding Li, and Kevin Ellis. I speak, you verify: Toward trustworthy neural program synthesis. ArXiv preprint, abs/2210.00848, 2022. URL https://arxiv.org/abs/2210. 00848 .</p>
<p>Najoung Kim, Tal Linzen, and Paul Smolensky. Uncontrolled lexical exposure leads to overestimation of compositional generalization in pretrained models. ArXiv preprint, abs/2212.10769, 2022a. URL https://arxiv.org/abs/2212.10769.</p>
<p>Subin Kim, Prin Phunyaphibarn, Donghyun Ahn, and Sundong Kim. Playgrounds for abstraction and reasoning. In NeurIPS 2022 Workshop on Neuro Causal and Symbolic AI (nCSI), 2022b. URL https://openreview.net/forum?id=F4RNpByoqP.</p>
<p>Takeshi Kojima, Shixiang Shane Gu, Machel Reid, Yutaka Matsuo, and Yusuke Iwasawa. Large language models are zero-shot reasoners. Advances in neural information processing systems, $35: 22199-22213,2022$.</p>
<p>Brenden M. Lake and Marco Baroni. Generalization without systematicity: On the compositional skills of sequence-to-sequence recurrent networks. In Jennifer G. Dy and Andreas Krause (eds.), Proceedings of the 35th International Conference on Machine Learning, ICML 2018, Stockholmsmässan, Stockholm, Sweden, July 10-15, 2018, volume 80 of Proceedings of Machine Learning Research, pp. 2879-2888. PMLR, 2018. URL http://proceedings.mlr. press/v80/lake18a.html.</p>
<p>Brenden M Lake, Ruslan Salakhutdinov, and Joshua B Tenenbaum. Human-level concept learning through probabilistic program induction. Science, 350(6266):1332-1338, 2015.</p>
<p>Brenden M. Lake, Tomer D. Ullman, Joshua B. Tenenbaum, and Samuel J. Gershman. Building machines that learn and think like people. Behavioral and Brain Sciences, 40:e253, 2017. doi: 10.1017/S0140525X16001837.</p>
<p>Brenden M. Lake, Tal Linzen, and Marco Baroni. Human few-shot learning of compositional instructions. In Annual Meeting of the Cognitive Science Society, 2019. URL https://api. semanticscholar.org/CorpusID:58006558.</p>
<p>Xiang Lisa Li, Vaishnavi Shrivastava, Siyan Li, Tatsunori Hashimoto, and Percy Liang. Benchmarking and improving generator-validator consistency of language models. ArXiv preprint, abs/2310.01846, 2023. URL https://arxiv.org/abs/2310.01846.</p>
<p>Aman Madaan, Niket Tandon, Prakhar Gupta, Skyler Hallinan, Luyu Gao, Sarah Wiegreffe, Uri Alon, Nouha Dziri, Shrimai Prabhumoye, Yiming Yang, et al. Self-refine: Iterative refinement with self-feedback. ArXiv preprint, abs/2303.17651, 2023. URL https://arxiv.org/abs/ 2303.17651.</p>
<p>Inbal Magar and Roy Schwartz. Data contamination: From memorization to exploitation. In Proceedings of the 60th Annual Meeting of the Association for Computational Linguistics (Volume 2: Short Papers), pp. 157-165, Dublin, Ireland, May 2022. Association for Computational Linguistics. doi: 10.18653/v1/2022.acl-short.18. URL https://aclanthology.org/2022. acl-short. 18 .</p>
<p>Suvir Mirchandani, Fei Xia, Pete Florence, Brian Ichter, Danny Driess, Montserrat Gonzalez Arenas, Kanishka Rao, Dorsa Sadigh, and Andy Zeng. Large language models as general pattern machines. ArXiv preprint, abs/2307.04721, 2023. URL https://arxiv.org/abs/2307. 04721 .</p>
<p>Melanie Mitchell, Alessandro B Palmarini, and Arseny Moskvichev. Comparing humans, gpt-4, and gpt-4v on abstraction and reasoning tasks. arXiv preprint arXiv:2311.09247, 2023.</p>
<p>Arseny Moskvichev, Victor Vikram Odouard, and Melanie Mitchell. The conceptarc benchmark: Evaluating understanding and generalization in the arc domain. ArXiv preprint, abs/2305.07141, 2023. URL https://arxiv.org/abs/2305.07141.</p>
<p>Jesse Mu, Percy Liang, and Noah Goodman. Shaping visual representations with language for few-shot classification. In Proceedings of the 58th Annual Meeting of the Association for Computational Linguistics, pp. 4823-4830, Online, July 2020. Association for Computational Linguistics. doi: 10.18653/v1/2020.acl-main.436. URL https://aclanthology.org/2020. acl-main. 436 .</p>
<p>Allen Newell. Physical symbol systems. Cognitive science, 4(2):135-183, 1980.
Ansong Ni, Srini Iyer, Dragomir Radev, Veselin Stoyanov, Wen-tau Yih, Sida Wang, and Xi Victoria Lin. Lever: Learning to verify language-to-code generation with execution. In International Conference on Machine Learning, pp. 26106-26128. PMLR, 2023.</p>
<p>Robert M Nosofsky, Thomas J Palmeri, and Stephen C McKinley. Rule-plus-exception model of classification learning. Psychological review, 101(1):53, 1994.</p>
<p>Maxwell Nye, Anders Johan Andreassen, Guy Gur-Ari, Henryk Michalewski, Jacob Austin, David Bieber, David Dohan, Aitor Lewkowycz, Maarten Bosma, David Luan, et al. Show your work: Scratchpads for intermediate computation with language models. arXiv preprint arXiv:2112.00114, 2021.</p>
<p>Maxwell I. Nye, Armando Solar-Lezama, Josh Tenenbaum, and Brenden M. Lake. Learning compositional rules via neural program synthesis. In Hugo Larochelle, Marc'Aurelio Ranzato, Raia Hadsell, Maria-Florina Balcan, and Hsuan-Tien Lin (eds.), Advances in Neural Information Processing Systems 33: Annual Conference on Neural Information Processing Systems 2020, NeurIPS 2020, December 6-12, 2020, virtual, 2020. URL https://proceedings.neurips.cc/ paper/2020/hash/7a685d9edd95508471a9d3d6fcace432-Abstract.html.</p>
<p>Theo X Olausson, Jeevana Priya Inala, Chenglong Wang, Jianfeng Gao, and Armando SolarLezama. Demystifying gpt self-repair for code generation. ArXiv preprint, abs/2306.09896, 2023. URL https://arxiv.org/abs/2306.09896.</p>
<p>OpenAI. Gpt-4 technical report, 2023.
Daniel N. Osherson, Ormond Wilkie, Edward E. Smith, Alejandro López, and Eldar Shafir. Category-based induction. Psychological Review, 97(2):185-200, 1990. ISSN 0033-295X. doi: 10.1037/0033-295X.97.2.185.</p>
<p>Arkil Patel, Satwik Bhattamishra, Phil Blunsom, and Navin Goyal. Revisiting the compositional generalization abilities of neural sequence models. In Proceedings of the 60th Annual Meeting of the Association for Computational Linguistics (Volume 2: Short Papers), pp. 424-434, Dublin, Ireland, May 2022. Association for Computational Linguistics. doi: 10.18653/v1/2022.acl-short. 46. URL https://aclanthology.org/2022.acl-short. 46.</p>
<p>Baolin Peng, Michel Galley, Pengcheng He, Hao Cheng, Yujia Xie, Yu Hu, Qiuyuan Huang, Lars Liden, Zhou Yu, Weizhu Chen, et al. Check your facts and try again: Improving large language models with external knowledge and automated feedback. ArXiv preprint, abs/2302.12813, 2023. URL https://arxiv.org/abs/2302.12813.</p>
<p>Steven T Piantadosi, Joshua B Tenenbaum, and Noah D Goodman. The logical primitives of thought: Empirical foundations for compositional cognitive models. Psychological review, 123(4):392, 2016.</p>
<p>Joshua Stewart Rule. The child as hacker: building more human-like models of learning. PhD thesis, Massachusetts Institute of Technology, 2020.</p>
<p>Feras A Saad, Marco F Cusumano-Towner, Ulrich Schaechte, Martin C Rinard, and Vikash K Mansinghka. Bayesian synthesis of probabilistic programs for automatic data modeling. Proceedings of the ACM on Programming Languages, 3(POPL):1-32, 2019.</p>
<p>Mathias Sablé-Meyer, Kevin Ellis, Josh Tenenbaum, and Stanislas Dehaene. A language of thought for the mental representation of geometric shapes. Cognitive Psychology, 139:101527, 2022.</p>
<p>Swarnadeep Saha, Peter Hase, Nazneen Rajani, and Mohit Bansal. Are hard examples also harder to explain? a study with human and model-generated explanations. In Proceedings of the 2022 Conference on Empirical Methods in Natural Language Processing, pp. 2121-2131, Abu Dhabi, United Arab Emirates, 2022. Association for Computational Linguistics. URL https://aclanthology.org/2022.emnlp-main. 137.</p>
<p>Chandan Singh, John X Morris, Jyoti Aneja, Alexander M Rush, and Jianfeng Gao. Explaining patterns in data with language models via interpretable autoprompting. ArXiv preprint, abs/2210.01848, 2022. URL https://arxiv.org/abs/2210.01848.</p>
<p>David Smith and Jason Eisner. Quasi-synchronous grammars: Alignment by soft projection of syntactic dependencies. In Proceedings on the Workshop on Statistical Machine Translation, pp. 23-30, New York City, June 2006. Association for Computational Linguistics. URL https: //aclanthology.org/W06-3104.</p>
<p>David M Sobel, Joshua B Tenenbaum, and Alison Gopnik. Children's causal inferences from indirect evidence: Backwards blocking and bayesian reasoning in preschoolers. Cognitive science, 28(3):303-333, 2004.</p>
<p>Xiaojuan Tang, Zilong Zheng, Jiaqi Li, Fanxu Meng, Song-Chun Zhu, Yitao Liang, and Muhan Zhang. Large language models are in-context semantic reasoners rather than symbolic reasoners. ArXiv preprint, abs/2305.14825, 2023. URL https://arxiv.org/abs/2305.14825.</p>
<p>Joshua Tenenbaum. Rules and similarity in concept learning. Advances in neural information processing systems, 12, 1999.</p>
<p>Joshua B. Tenenbaum, Charles Kemp, Thomas L. Griffiths, and Noah D. Goodman. How to grow a mind: Statistics, structure, and abstraction. Science, 331(6022):1279-1285, 2011. doi: 10.1126/ science.1192788. URL https://www.science.org/doi/abs/10.1126/science. 1192788 .</p>
<p>Pratiksha Thaker, Joshua B Tenenbaum, and Samuel J Gershman. Online learning of symbolic concepts. Journal of Mathematical Psychology, 77:10-20, 2017.</p>
<p>Lucas Y. Tian, Kevin Ellis, Marta Kryven, and Josh Tenenbaum. Learning abstract structure for drawing by efficient motor program induction. In Hugo Larochelle, Marc'Aurelio Ranzato, Raia Hadsell, Maria-Florina Balcan, and Hsuan-Tien Lin (eds.),</p>
<p>Advances in Neural Information Processing Systems 33: Annual Conference on Neural Information Processing Systems 2020, NeurIPS 2020, December 6-12, 2020, virtual, 2020. URL https://proceedings.neurips.cc/paper/2020/hash/ 1c104b9c0accfca52ef21728eaf01453-Abstract.html.</p>
<p>Hugo Touvron, Louis Martin, Kevin Stone, Peter Albert, Amjad Almahairi, Yasmine Babaei, Nikolay Bashlykov, Soumya Batra, Prajjwal Bhargava, Shruti Bhosale, et al. Llama 2: Open foundation and fine-tuned chat models. arXiv preprint arXiv:2307.09288, 2023.</p>
<p>Wai Keen Vong and Brenden M. Lake. Few-shot image classification by generating natural language rules. In ACL Workshop on Learning with Natural Language Supervision, 2022. URL https: //openreview.net/forum?id=BxfpZP2sZq.</p>
<p>Ruocheng Wang, Eric Zelikman, Gabriel Poesia, Yewen Pu, Nick Haber, and Noah D Goodman. Hypothesis search: Inductive reasoning with language models. ArXiv preprint, abs/2309.05660, 2023a. URL https://arxiv.org/abs/2309.05660.</p>
<p>Xuezhi Wang, Jason Wei, Dale Schuurmans, Quoc Le, Ed Chi, Sharan Narang, Aakanksha Chowdhery, and Denny Zhou. Self-consistency improves chain of thought reasoning in language models. In The Eleventh International Conference on Learning Representations, ICLR 2023, Kigali, Rwanda, May 1-5, 2023, 2023b. URL https://openreview.net/pdf?id= 1PL1NIMMrw.</p>
<p>Taylor Webb, Keith J Holyoak, and Hongjing Lu. Emergent analogical reasoning in large language models. Nature Human Behaviour, 7(9):1526-1541, 2023.</p>
<p>Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Fei Xia, Ed Chi, Quoc V Le, Denny Zhou, et al. Chain-of-thought prompting elicits reasoning in large language models. Advances in Neural Information Processing Systems, 35:24824-24837, 2022.</p>
<p>Peter West, Ximing Lu, Nouha Dziri, Faeze Brahman, Linjie Li, Jena D Hwang, Liwei Jiang, Jillian Fisher, Abhilasha Ravichander, Khyathi Chandu, et al. The generative ai paradox: "what it can create, it may not understand". In The Twelfth International Conference on Learning Representations, 2023.</p>
<p>Lionel Wong, Gabriel Grand, Alexander K Lew, Noah D Goodman, Vikash K Mansinghka, Jacob Andreas, and Joshua B Tenenbaum. From word models to world models: Translating from natural language to the probabilistic language of thought. ArXiv preprint, abs/2306.12672, 2023. URL https://arxiv.org/abs/2306.12672.</p>
<p>Fangzhi Xu, Qika Lin, Jiawei Han, Tianzhe Zhao, Jun Liu, and Erik Cambria. Are large language models really good logical reasoners? a comprehensive evaluation from deductive, inductive and abductive views. ArXiv preprint, abs/2306.09841, 2023a. URL https://arxiv.org/abs/ 2306.09841 .</p>
<p>Fei Xu and Joshua B Tenenbaum. Word learning as bayesian inference. Psychological review, 114 (2):245, 2007.</p>
<p>Yudong Xu, Wenhao Li, Pashootan Vaezipoor, Scott Sanner, and Elias B Khalil. Llms and the abstraction and reasoning corpus: Successes, failures, and the importance of object-based representations. ArXiv preprint, abs/2305.18354, 2023b. URL https://arxiv.org/abs/2305. 18354 .</p>
<p>Zonglin Yang, Li Dong, Xinya Du, Hao Cheng, Erik Cambria, Xiaodong Liu, Jianfeng Gao, and Furu Wei. Language models as inductive reasoners. ArXiv preprint, abs/2212.10923, 2022. URL https://arxiv.org/abs/2212.10923.</p>
<p>Chi Zhang, Baoxiong Jia, Mark Edmonds, Song-Chun Zhu, and Yixin Zhu. ACRE: abstract causal reasoning beyond covariation. In IEEE Conference on Computer Vision and Pattern Recognition, CVPR 2021, virtual, June 19-25, 2021, pp. 10643-10653. Computer Vision Foundation / IEEE, 2021. doi: 10.1109/CVPR46437.2021.01050. URL https://openaccess.thecvf. com/content/CVPR2021/html/Zhang_ACRE_Abstract_Causal_REasoning_ Beyond_Covariation_CVPR_2021_paper.html.</p>
<p>Kexun Zhang, Danqing Wang, Jingtao Xia, William Yang Wang, and Lei Li. Algo: Synthesizing algorithmic programs with generated oracle verifiers. ArXiv preprint, abs/2305.14591, 2023a. URL https://arxiv.org/abs/2305.14591.</p>
<p>Muru Zhang, Ofir Press, William Merrill, Alisa Liu, and Noah A Smith. How language model hallucinations can snowball. ArXiv preprint, abs/2305.13534, 2023b. URL https://arxiv. org/abs/2305.13534.</p>
<p>Ruiqi Zhong, Charlie Snell, Dan Klein, and Jacob Steinhardt. Describing differences between text distributions with natural language. In Kamalika Chaudhuri, Stefanie Jegelka, Le Song, Csaba Szepesvári, Gang Niu, and Sivan Sabato (eds.), International Conference on Machine Learning, ICML 2022, 17-23 July 2022, Baltimore, Maryland, USA, volume 162 of Proceedings of Machine Learning Research, pp. 27099-27116. PMLR, 2022. URL https://proceedings.mlr. press/v162/zhong22a.html.</p>
<p>Ruiqi Zhong, Peter Zhang, Steve Li, Jinwoo Ahn, Dan Klein, and Jacob Steinhardt. Goal driven discovery of distributional differences via language descriptions. ArXiv preprint, abs/2302.14233, 2023. URL https://arxiv.org/abs/2302.14233.</p>
<h1>A DATASET DETAILS</h1>
<p>We show the dataset statistics in Table 3 and include the full dataset details below.</p>
<p>ACRE Following Gendron et al. (2023), we use textual representations of the original images by representing each object with its corresponding natural language description. We also experimented with a symbolic representation in which each object is represented as an integer, but observed similar performance. We sampled 100 tasks from the original dataset for our experiments.</p>
<p>Table 3: The number of tasks per dataset, the numbers of seen examples per task, and unseen examples per task.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Dataset</th>
<th style="text-align: center;"># Tasks</th>
<th style="text-align: center;"># Seen</th>
<th style="text-align: center;"># Unseen</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">ACRE</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">4</td>
</tr>
<tr>
<td style="text-align: left;">MiniSCAN</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">14</td>
<td style="text-align: center;">10</td>
</tr>
<tr>
<td style="text-align: left;">List Functions</td>
<td style="text-align: center;">250</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">8</td>
</tr>
<tr>
<td style="text-align: left;">MiniARC</td>
<td style="text-align: center;">130</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">3</td>
</tr>
</tbody>
</table>
<p>MiniSCAN We use examples from Lake et al. (2019), but randomly sample pseudowords for the inputs. We did not consider English words because of potential issues of data contamination (Dodge et al., 2021; Magar \&amp; Schwartz, 2022, i.a.) and uncontrolled lexical exposure (Kim et al., 2022a). The outputs use color names following Akyurek \&amp; Andreas (2021); Nye et al. (2020); Patel et al. (2022). We generated a total of 100 tasks for our experiments.</p>
<p>List Functions We use the original dataset (Rule, 2020), which consists of a total of 250 tasks. Due to the limited context lengths of LMs, we only use the first 16 examples from BIG-Bench (bench authors, 2023): 8 for seen examples and 8 for unseen examples. We manually examined the exemplars and found 8 examples are generally sufficient to describe the pattern. Our preliminary experiments also indicated that adding more examples did not improve performance.</p>
<p>MiniARC We use the data from Kim et al. (2022b). Although the original release contains 149 tasks, we heuristically filter out tasks that require heavy pattern matching, such as mapping one specific shape to another. Such tasks are typically difficult to describe in natural language at an abstract level. Therefore, we did not consider them for our evaluations. As we only evaluate textonly models, we use textual representations of the original visual grids by mapping each cell to a corresponding integer (Gendron et al., 2023; Moskvichev et al., 2023).</p>
<h2>B ADDITIONAL RESULTS</h2>
<h2>B. 1 OTHER LANGUAGE MODELS</h2>
<p>We use GPT-4 for the main experiments, but our observations remain consistent across other LMs, as shown in Table 4. We evaluate GPT-4, GPT-3.5, Claude-2, and LLaMA2-70B using IO prompting and iterative hypothesis refinement, as they are best representatives of two different evaluations.</p>
<p>For GPT-3.5 and Claude-2, we observe similar trends except both models underperform GPT-4. Rule prompting achieves higher accuracy than IO prompting on ACRE and MiniSCAN and shows better consistency between raw accuracy and task accuracy. However, these models sometimes lag behind the baseline on tasks involving complex rules, such as List Functions and MiniARC. For LLaMA2-70B, we only observe improvement using rule prompting on ACRE. For tasks where we constrain hypothesis representations, some models' rules appear ill-formed. Many responses from GPT-3.5 and LLaMA2-70B are also truncated due to their limited context length. This suggests that iterative hypothesis refinement is most effective when coupled with an LM that is capable of proposing meaningful hypotheses and tracking long context.</p>
<p>Table 4: Results on IO prompting and rule prompting (i.e., hypothesis refinement) using different models. We use $\mathrm{T}=3, \mathrm{~N}=5$ configuration for iterative hypothesis refinement.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Model</th>
<th style="text-align: center;">Method</th>
<th style="text-align: center;">Raw Accuracy</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Task Accuracy</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">ACRE</td>
<td style="text-align: center;">MiniSCAN</td>
<td style="text-align: center;">List Fns</td>
<td style="text-align: center;">MiniARC</td>
<td style="text-align: center;">ACRE</td>
<td style="text-align: center;">MiniSCAN</td>
<td style="text-align: center;">List Fns</td>
<td style="text-align: center;">MiniARC</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">IO</td>
<td style="text-align: center;">64.0</td>
<td style="text-align: center;">61.7</td>
<td style="text-align: center;">65.1</td>
<td style="text-align: center;">33.1</td>
<td style="text-align: center;">28.0</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">39.6</td>
<td style="text-align: center;">13.8</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Rule</td>
<td style="text-align: center;">82.5</td>
<td style="text-align: center;">93.3</td>
<td style="text-align: center;">71.2</td>
<td style="text-align: center;">18.7</td>
<td style="text-align: center;">59.0</td>
<td style="text-align: center;">85.0</td>
<td style="text-align: center;">61.2</td>
<td style="text-align: center;">14.6</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">IO</td>
<td style="text-align: center;">56.2</td>
<td style="text-align: center;">14.3</td>
<td style="text-align: center;">55.1</td>
<td style="text-align: center;">18.6</td>
<td style="text-align: center;">12.0</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">27.6</td>
<td style="text-align: center;">8.5</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Rule</td>
<td style="text-align: center;">71.5</td>
<td style="text-align: center;">29.3</td>
<td style="text-align: center;">42.2</td>
<td style="text-align: center;">4.6</td>
<td style="text-align: center;">44.0</td>
<td style="text-align: center;">8.0</td>
<td style="text-align: center;">35.6</td>
<td style="text-align: center;">3.8</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">IO</td>
<td style="text-align: center;">51.7</td>
<td style="text-align: center;">23.4</td>
<td style="text-align: center;">51.4</td>
<td style="text-align: center;">24.7</td>
<td style="text-align: center;">6.0</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">24.4</td>
<td style="text-align: center;">10.8</td>
</tr>
<tr>
<td style="text-align: center;">Claude-2</td>
<td style="text-align: center;">Rule</td>
<td style="text-align: center;">79.2</td>
<td style="text-align: center;">41.2</td>
<td style="text-align: center;">42.8</td>
<td style="text-align: center;">7.2</td>
<td style="text-align: center;">55.0</td>
<td style="text-align: center;">13.0</td>
<td style="text-align: center;">36.0</td>
<td style="text-align: center;">6.2</td>
</tr>
<tr>
<td style="text-align: center;">LLaMA2-70B</td>
<td style="text-align: center;">IO</td>
<td style="text-align: center;">51.7</td>
<td style="text-align: center;">6.8</td>
<td style="text-align: center;">30.5</td>
<td style="text-align: center;">9.0</td>
<td style="text-align: center;">10.0</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">8.4</td>
<td style="text-align: center;">1.5</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Rule</td>
<td style="text-align: center;">64.5</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">9.2</td>
<td style="text-align: center;">2.1</td>
<td style="text-align: center;">29.0</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">6.0</td>
<td style="text-align: center;">0.8</td>
</tr>
</tbody>
</table>
<p>Similar to experiments in $\S 4$, we show the comparisons between symbolic interpreters and LMs as interpreters for rule application using other models in Table 5. We show results on varying example distribution using different models and configurations in Table 6 and Table 7. All results remain consistent with the findings in the main experiments.</p>
<p>Table 5: Results on applying the LM's proposed rules using symbolic interpreters or the LM itself as the interpreter using different models.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Model</th>
<th style="text-align: center;">Interpreter</th>
<th style="text-align: center;">Raw Accuracy</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Task Accuracy</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">ACRE</td>
<td style="text-align: center;">MiniSCAN</td>
<td style="text-align: center;">List Fns</td>
<td style="text-align: center;">MiniARC</td>
<td style="text-align: center;">ACRE</td>
<td style="text-align: center;">MiniSCAN</td>
<td style="text-align: center;">List Fns</td>
<td style="text-align: center;">MiniARC</td>
</tr>
<tr>
<td style="text-align: center;">GPT-3.5</td>
<td style="text-align: center;">Symbolic</td>
<td style="text-align: center;">71.5</td>
<td style="text-align: center;">29.3</td>
<td style="text-align: center;">42.2</td>
<td style="text-align: center;">4.6</td>
<td style="text-align: center;">44.0</td>
<td style="text-align: center;">8.0</td>
<td style="text-align: center;">35.6</td>
<td style="text-align: center;">3.8</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">LM</td>
<td style="text-align: center;">65.0</td>
<td style="text-align: center;">3.0</td>
<td style="text-align: center;">36.8</td>
<td style="text-align: center;">3.1</td>
<td style="text-align: center;">25.0</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">24.0</td>
<td style="text-align: center;">1.5</td>
</tr>
<tr>
<td style="text-align: center;">Claude-2</td>
<td style="text-align: center;">Symbolic</td>
<td style="text-align: center;">79.2</td>
<td style="text-align: center;">41.2</td>
<td style="text-align: center;">42.8</td>
<td style="text-align: center;">7.2</td>
<td style="text-align: center;">55.0</td>
<td style="text-align: center;">13.0</td>
<td style="text-align: center;">36.0</td>
<td style="text-align: center;">6.2</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">LM</td>
<td style="text-align: center;">75.8</td>
<td style="text-align: center;">4.0</td>
<td style="text-align: center;">36.0</td>
<td style="text-align: center;">3.1</td>
<td style="text-align: center;">43.0</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">24.8</td>
<td style="text-align: center;">0.0</td>
</tr>
<tr>
<td style="text-align: center;">LLaMA2-70B</td>
<td style="text-align: center;">Symbolic</td>
<td style="text-align: center;">64.5</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">9.2</td>
<td style="text-align: center;">2.1</td>
<td style="text-align: center;">29.0</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">6.0</td>
<td style="text-align: center;">0.8</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">LM</td>
<td style="text-align: center;">59.2</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">7.1</td>
<td style="text-align: center;">1.7</td>
<td style="text-align: center;">12.0</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">2.0</td>
<td style="text-align: center;">0.0</td>
</tr>
</tbody>
</table>
<p>Table 6: Results on varying example noisiness using different models and configurations. We introduce noise by perturbing a certain percentage of exemplars on List Functions.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Model</th>
<th style="text-align: center;">Configuration</th>
<th style="text-align: center;">Raw Accuracy</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Task Accuracy</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">$0 \%$</td>
<td style="text-align: center;">$12.5 \%$</td>
<td style="text-align: center;">$25 \%$</td>
<td style="text-align: center;">$50 \%$</td>
<td style="text-align: center;">$0 \%$</td>
<td style="text-align: center;">$12.5 \%$</td>
<td style="text-align: center;">$25 \%$</td>
<td style="text-align: center;">$50 \%$</td>
</tr>
<tr>
<td style="text-align: center;">GPT-4</td>
<td style="text-align: center;">$\mathrm{T}=1, \mathrm{~N}=1$</td>
<td style="text-align: center;">51.6</td>
<td style="text-align: center;">49.6</td>
<td style="text-align: center;">36.7</td>
<td style="text-align: center;">23.1</td>
<td style="text-align: center;">42.4</td>
<td style="text-align: center;">38.8</td>
<td style="text-align: center;">23.6</td>
<td style="text-align: center;">12.4</td>
</tr>
<tr>
<td style="text-align: center;">GPT-3.5</td>
<td style="text-align: center;">$\mathrm{T}=3, \mathrm{~N}=5$</td>
<td style="text-align: center;">42.2</td>
<td style="text-align: center;">27.0</td>
<td style="text-align: center;">23.2</td>
<td style="text-align: center;">20.6</td>
<td style="text-align: center;">35.6</td>
<td style="text-align: center;">15.6</td>
<td style="text-align: center;">12.8</td>
<td style="text-align: center;">12.0</td>
</tr>
<tr>
<td style="text-align: center;">Claude-2</td>
<td style="text-align: center;">$\mathrm{T}=3, \mathrm{~N}=5$</td>
<td style="text-align: center;">42.8</td>
<td style="text-align: center;">25.9</td>
<td style="text-align: center;">19.8</td>
<td style="text-align: center;">15.4</td>
<td style="text-align: center;">36.0</td>
<td style="text-align: center;">13.2</td>
<td style="text-align: center;">8.0</td>
<td style="text-align: center;">4.4</td>
</tr>
</tbody>
</table>
<p>Table 7: Results on varying example familiarity using different models and configurations. We use English words or pseudo-words as outputs on MiniSCAN.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Model</th>
<th style="text-align: center;">Configuration</th>
<th style="text-align: center;">Raw Accuracy</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Task Accuracy</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">English</td>
<td style="text-align: center;">Pseudo</td>
<td style="text-align: center;">English</td>
<td style="text-align: center;">Pseudo</td>
</tr>
<tr>
<td style="text-align: center;">GPT-4</td>
<td style="text-align: center;">$\mathrm{T}=1, \mathrm{~N}=1$</td>
<td style="text-align: center;">77.0</td>
<td style="text-align: center;">72.0</td>
<td style="text-align: center;">46.0</td>
<td style="text-align: center;">38.0</td>
</tr>
<tr>
<td style="text-align: center;">GPT-3.5</td>
<td style="text-align: center;">$\mathrm{T}=3, \mathrm{~N}=5$</td>
<td style="text-align: center;">29.3</td>
<td style="text-align: center;">19.5</td>
<td style="text-align: center;">8.0</td>
<td style="text-align: center;">3.0</td>
</tr>
<tr>
<td style="text-align: center;">Claude-2</td>
<td style="text-align: center;">$\mathrm{T}=3, \mathrm{~N}=5$</td>
<td style="text-align: center;">41.2</td>
<td style="text-align: center;">41.0</td>
<td style="text-align: center;">13.0</td>
<td style="text-align: center;">9.0</td>
</tr>
</tbody>
</table>
<p>Table 8: Results on MiniARC using GPT-4V. We show the results of IO prompting and rule prompting, as well as the results when applying the model's proposed rules using the symbolic interpreter or GPT-4V as the interpreter. We use a $\mathrm{T}=3, \mathrm{~N}=5$ configuration for iterative hypothesis refinement.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
<th style="text-align: center;">Raw Accuracy</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Task Accuracy</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Method</td>
<td style="text-align: left;">Interpreter</td>
<td style="text-align: center;">Color</td>
<td style="text-align: center;">Number</td>
<td style="text-align: center;">Color</td>
<td style="text-align: center;">Number</td>
</tr>
<tr>
<td style="text-align: left;">IO</td>
<td style="text-align: left;">-</td>
<td style="text-align: center;">1.3</td>
<td style="text-align: center;">12.2</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">3.8</td>
</tr>
<tr>
<td style="text-align: left;">Rule</td>
<td style="text-align: left;">Symbolic</td>
<td style="text-align: center;">6.0</td>
<td style="text-align: center;">9.7</td>
<td style="text-align: center;">4.6</td>
<td style="text-align: center;">8.5</td>
</tr>
<tr>
<td style="text-align: left;">Rule</td>
<td style="text-align: left;">GPT-4V</td>
<td style="text-align: center;">0.5</td>
<td style="text-align: center;">3.1</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">0.8</td>
</tr>
</tbody>
</table>
<h1>B. 2 Multimodal Model</h1>
<p>Since the MiniARC dataset requires visual understanding, evaluating text-only models using textual representations may not be optimal. Therefore, we also evaluate the performance of the multimodal model that allows visual inputs. We use GPT-4V (gpt-4-vision-preview), which was released in November 2023, for our experiments. We consider two representations of the visual grids: color and number. We use an individual image for each input and output (see Table 18 for prompts and examples). For iterative hypothesis refinement, we use GPT-4 to translate hypotheses due to the rate limit of GPT-4V. For IO prompting and rule application, we ask the model to generate the textual representation of the visual grid, representing each cell as an integer. ${ }^{15}$ We show results in Table 8. The performance of GPT-4V is significantly worse than that of GPT-4, which is consistent with the results in Mitchell et al. (2023). Performance with color representation lags behind when compared to numerical representation. Similarly, we find that using GPT-4V as a rule interpreter consistently underperforms using the symbolic interpreter.</p>
<h2>B. 3 Ablations</h2>
<p>Prompting Techniques for Rule Application. We only use standard prompting for rule application in $\S 4.1$. Here, we study whether more advanced prompting techniques improve LMs' rule application performance. We consider two alternatives: self-consistency prompting (SC; Wang et al., 2023b) and zero-shot chain-of-thought prompting (0-CoT; Kojima et al., 2022; Nye et al., 2021; Wei et al., 2022). Similar to our main experiments, SC selects the most consistent output from multiple responses by taking a majority vote. Following Kojima et al. (2022), 0-CoT adds "Let's think step by step." at the end to encourage LMs to reason. We show results in Table 9. We do not observe significant performance differences across these methods, except on ACRE, where 0-CoT underperforms other methods in task accuracy. This could potentially be attributed to the possibility that LMs do not truly understand their own proposed rules; therefore, encouraging reasoning might result in worse performance.</p>
<p>Table 9: Results on using LMs as interpreters for rule application with different prompting techniques. We compare standard prompting, zero-shot chain-of-thought ( $0-\mathrm{CoT}$ ) that adds "Let's think step by step" at the end, and self-consistency (SC) that selects the output by taking a majority vote.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: center;">Raw Accuracy</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Task Accuracy</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Method</td>
<td style="text-align: center;">ACRE</td>
<td style="text-align: center;">MiniSCAN</td>
<td style="text-align: center;">List Fns</td>
<td style="text-align: center;">MiniARC</td>
<td style="text-align: center;">ACRE</td>
<td style="text-align: center;">MiniSCAN</td>
<td style="text-align: center;">List Fns</td>
<td style="text-align: center;">MiniARC</td>
</tr>
<tr>
<td style="text-align: left;">Standard</td>
<td style="text-align: center;">77.8</td>
<td style="text-align: center;">67.6</td>
<td style="text-align: center;">65.8</td>
<td style="text-align: center;">10.8</td>
<td style="text-align: center;">47.0</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">50.0</td>
<td style="text-align: center;">5.4</td>
</tr>
<tr>
<td style="text-align: left;">0 -CoT</td>
<td style="text-align: center;">73.2</td>
<td style="text-align: center;">65.5</td>
<td style="text-align: center;">61.2</td>
<td style="text-align: center;">12.1</td>
<td style="text-align: center;">25.0</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">48.4</td>
<td style="text-align: center;">6.9</td>
</tr>
<tr>
<td style="text-align: left;">SC (N=5)</td>
<td style="text-align: center;">77.0</td>
<td style="text-align: center;">67.5</td>
<td style="text-align: center;">66.3</td>
<td style="text-align: center;">9.7</td>
<td style="text-align: center;">46.0</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">50.8</td>
<td style="text-align: center;">4.6</td>
</tr>
</tbody>
</table>
<p>Representation of Hypothesis. We investigate how the representation of hypothesis affects rule induction. We use programming language hypotheses for List Functions and MiniARC. We consider this alternative as existing studies have shown that prompting LMs to generate programs improves the model's performance on complex reasoning task (Gao et al., 2023; Chen et al., 2022; Hu et al.,</p>
<p><sup id="fnref9:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>2023, i.a.). Directly using programming language hypotheses also eliminates the potential issue of mistranslation between natural language and code. As shown in Table 10, both programming language and natural language hypotheses achieve comparable performance, suggesting programming language can be a powerful alternative for these tasks.</p>
<p>Table 10: Results on using alternative hypothesis representation. We compare natural language hypotheses (NL) and programming hypotheses (Python) on List Functions and MiniARC.</p>
<table>
<thead>
<tr>
<th></th>
<th>Raw Accuracy</th>
<th></th>
<th>Task Accuracy</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Hypothesis</td>
<td>List Fns</td>
<td>MiniARC</td>
<td>List Fns</td>
<td>MiniARC</td>
</tr>
<tr>
<td>NL</td>
<td>71.2</td>
<td>18.7</td>
<td>61.2</td>
<td>14.6</td>
</tr>
<tr>
<td>Python</td>
<td>72.5</td>
<td>18.1</td>
<td>65.6</td>
<td>13.8</td>
</tr>
</tbody>
</table>
<p>Task-specific Heuristics. One reason why humans can learn new concepts from limited examples is their strong inductive biases or prior knowledge (Lake et al., 2017). We evaluate whether imposing task-specific heuristics influences LMs' inductive reasoning behaviors. Specifically, we use the MiniARC dataset, which involves visual understanding, and thus object-related heuristics could potentially be beneficial. Similar to Wang et al. (2023a), we provide explicit task-specific heuristics ${ }^{16}$ in the prompt for hypothesis generation, as shown in Table 11. We observe that the LM-induced rules become more human-readable. The LM starts to use visual concepts (e.g., "square", "rectangle", "L-shape", "U-shape") and common transformations (e.g., "reflection", "mirror", "rotate the grid 90 degrees clockwise"). We show example LM-induced rules in Table 12. However, this behavior appears only in a fraction of examples, and the rules induced by LMs are still generally distinguishable from those induced by humans. It is possible that incorporating additional guidance or adding human-induced rules as few-shot examples could encourage LMs to use pragmatic communication strategies. We leave exploring these alternatives as future work.</p>
<p>Importantly, imposing task-specific heuristics does not necessarily improve performance. Iterative hypothesis refinement with $T=3$ and $N=5$ achieves a raw accuracy of $17.8 \%$ and task accuracy of $14.6 \%$, comparable to results without task-specific heuristics. One possible reason is the integercolor mapping introducing additional overhead, as LMs frequently refer to both simultaneously in the rule (e.g., "if a pixel is green (3), then change it to red (2)"). This could also potentially be explained by observations in Acquaviva et al. (2022): human communication is expressive yet ambiguous. Therefore, the more human-readable rules might require extra efforts to ensure precision and improve performance.</p>
<h1>B. 4 ANALYSIS</h1>
<p>Our main experiments demonstrate the effectiveness of the iterative approach. In Figure 5, we show the changes of accuracy over iterations. We observe consistent performance improvements across all datasets, indicating that LMs are capable of refining their hypotheses iteratively. For tasks where LMs achieve strong performance, such as ACRE and MiniSCAN, a limited number of iterations is already sufficient. For tasks like MiniARC, where LMs perform poorly, the trends remain positive after the maximum number of iterations. This suggests potential for further improvements with more iterations when using LMs with longer context lengths.</p>
<h2>B. 5 COSTS</h2>
<p>We show the average number of API calls and the average cost per task in Table 13. For GPT-4, the cost is computed using $\$ 0.03 / 1 \mathrm{~K}$ tokens for input and $\$ 0.06 / 1 \mathrm{~K}$ tokens for output. For GPT-3.5, the cost is computed using $\$ 0.0015 / 1 \mathrm{~K}$ tokens for input and $\$ 0.002 / 1 \mathrm{~K}$ tokens for output. Iterative hypothesis refinement, when augmented with a symbolic interpreter, is more cost-efficient than SR, as it reduces the number of API calls required to apply hypotheses. It is also more cost efficient for</p>
<p><sup id="fnref10:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>Table 11: Task-specific hypothesis generation prompt for MiniARC.</p>
<div class="codehilite"><pre><span></span><code><span class="nt">Generate</span><span class="w"> </span><span class="nt">a</span><span class="w"> </span><span class="nt">rule</span><span class="w"> </span><span class="nt">that</span><span class="w"> </span><span class="nt">maps</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">following</span><span class="w"> </span><span class="nt">inputs</span><span class="w"> </span><span class="nt">to</span><span class="w"> </span><span class="nt">their</span><span class="w"> </span><span class="nt">corresponding</span><span class="w"> </span><span class="nt">outputs</span><span class="o">.</span>
<span class="nt">Both</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">input</span><span class="w"> </span><span class="nt">and</span><span class="w"> </span><span class="nt">output</span><span class="w"> </span><span class="nt">are</span><span class="w"> </span><span class="nt">5x5</span><span class="w"> </span><span class="nt">grids</span><span class="w"> </span><span class="nt">of</span><span class="w"> </span><span class="nt">integers</span><span class="o">,</span><span class="w"> </span><span class="nt">with</span><span class="w"> </span><span class="nt">each</span><span class="w"> </span><span class="nt">integer</span>
<span class="nt">representing</span><span class="w"> </span><span class="nt">a</span><span class="w"> </span><span class="nt">colored</span><span class="w"> </span><span class="nt">pixel</span><span class="w"> </span><span class="nt">in</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">visual</span><span class="w"> </span><span class="nt">grid</span><span class="o">.</span><span class="w"> </span><span class="nt">The</span><span class="w"> </span><span class="nt">integers</span><span class="w"> </span><span class="nt">can</span><span class="w"> </span><span class="nt">be</span><span class="w"> </span><span class="nt">mapped</span><span class="w"> </span><span class="nt">to</span>
<span class="nt">colors</span><span class="w"> </span><span class="nt">as</span><span class="w"> </span><span class="nt">follows</span><span class="o">:</span>
<span class="nt">0</span><span class="o">:</span><span class="w"> </span><span class="nt">Black</span><span class="o">;</span><span class="w"> </span><span class="nt">1</span><span class="o">:</span><span class="w"> </span><span class="nt">Blue</span><span class="o">;</span><span class="w"> </span><span class="nt">2</span><span class="o">:</span><span class="w"> </span><span class="nt">Red</span><span class="o">;</span><span class="w"> </span><span class="nt">3</span><span class="o">:</span><span class="w"> </span><span class="nt">Green</span><span class="o">;</span><span class="w"> </span><span class="nt">4</span><span class="o">:</span><span class="w"> </span><span class="nt">Yellow</span><span class="o">;</span><span class="w"> </span><span class="nt">5</span><span class="o">:</span><span class="w"> </span><span class="nt">Grey</span><span class="o">;</span><span class="w"> </span><span class="nt">6</span><span class="o">:</span><span class="w"> </span><span class="nt">Fuchsia</span><span class="o">;</span>
<span class="nt">7</span><span class="o">:</span><span class="w"> </span><span class="nt">Orange</span><span class="o">;</span><span class="w"> </span><span class="nt">8</span><span class="o">:</span><span class="w"> </span><span class="nt">Teal</span><span class="o">;</span><span class="w"> </span><span class="nt">9</span><span class="o">:</span><span class="w"> </span><span class="nt">Brown</span><span class="o">.</span>
<span class="nt">The</span><span class="w"> </span><span class="nt">black</span><span class="w"> </span><span class="nt">cells</span><span class="w"> </span><span class="nt">represent</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">background</span><span class="o">.</span>
<span class="nt">Hints</span><span class="o">:</span><span class="w"> </span><span class="nt">The</span><span class="w"> </span><span class="nt">transformations</span><span class="w"> </span><span class="nt">might</span><span class="w"> </span><span class="nt">include</span><span class="o">,</span><span class="w"> </span><span class="nt">but</span><span class="w"> </span><span class="nt">are</span><span class="w"> </span><span class="nt">not</span><span class="w"> </span><span class="nt">limited</span><span class="w"> </span><span class="nt">to</span><span class="o">:</span>
<span class="nt">-</span><span class="w"> </span><span class="nt">Movement</span><span class="o">:</span><span class="w"> </span><span class="nt">Flipping</span><span class="o">,</span><span class="w"> </span><span class="nt">rotation</span><span class="o">,</span><span class="w"> </span><span class="nt">reflection</span><span class="o">,</span><span class="w"> </span><span class="nt">etc</span><span class="o">.</span>
<span class="nt">-</span><span class="w"> </span><span class="nt">Color</span><span class="o">:</span><span class="w"> </span><span class="nt">Swapping</span><span class="w"> </span><span class="nt">and</span><span class="w"> </span><span class="nt">rotating</span><span class="w"> </span><span class="nt">colors</span><span class="w"> </span><span class="nt">between</span><span class="w"> </span><span class="nt">objects</span><span class="o">,</span><span class="w"> </span><span class="nt">etc</span><span class="o">.</span>
<span class="nt">-</span><span class="w"> </span><span class="nt">Object</span><span class="o">:</span><span class="w"> </span><span class="nt">Moving</span><span class="w"> </span><span class="nt">and</span><span class="w"> </span><span class="nt">copying</span><span class="w"> </span><span class="nt">objects</span><span class="o">,</span><span class="w"> </span><span class="nt">etc</span><span class="o">.</span>
<span class="nt">-</span><span class="w"> </span><span class="nt">Number</span><span class="o">:</span><span class="w"> </span><span class="nt">Counting</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">number</span><span class="w"> </span><span class="nt">of</span><span class="w"> </span><span class="nt">colors</span><span class="o">,</span><span class="w"> </span><span class="nt">comparing</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">number</span><span class="w"> </span><span class="nt">of</span><span class="w"> </span><span class="nt">two</span><span class="w"> </span><span class="nt">colors</span><span class="o">,</span><span class="w"> </span><span class="nt">etc</span><span class="o">.</span>
<span class="nt">-</span><span class="w"> </span><span class="nt">Geometry</span><span class="o">:</span><span class="w"> </span><span class="nt">Aligning</span><span class="w"> </span><span class="nt">or</span><span class="w"> </span><span class="nt">completing</span><span class="w"> </span><span class="nt">objects</span><span class="o">,</span><span class="w"> </span><span class="nt">etc</span><span class="o">.</span>
<span class="nt">-</span><span class="w"> </span><span class="nt">Common</span><span class="w"> </span><span class="nt">sense</span><span class="o">:</span><span class="w"> </span><span class="nt">Finding</span><span class="w"> </span><span class="nt">mazes</span><span class="w"> </span><span class="nt">paths</span><span class="o">,</span><span class="w"> </span><span class="nt">playing</span><span class="w"> </span><span class="nt">Tetris</span><span class="o">,</span><span class="w"> </span><span class="nt">simulating</span><span class="w"> </span><span class="nt">raindrops</span><span class="o">,</span><span class="w"> </span><span class="nt">etc</span><span class="o">.</span>
<span class="nt">Please</span><span class="w"> </span><span class="nt">format</span><span class="w"> </span><span class="nt">your</span><span class="w"> </span><span class="nt">rule</span><span class="w"> </span><span class="nt">as</span><span class="w"> </span><span class="nt">follows</span><span class="o">:</span>
<span class="nt">Rule</span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="nt">Your</span><span class="w"> </span><span class="nt">rule</span><span class="o">&gt;</span>
</code></pre></div>

<p>Table 12: Comparison between LM-induced rules on MiniARC with and without task-specific heuristics. We show examples where heuristics are helpful (top) and not helpful (bottom) for rule induction. 0 maps to black.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Examples</th>
<th style="text-align: center;">w/o Heuristics</th>
<th style="text-align: center;">w/ Heuristics</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><img alt="img-5.jpeg" src="img-5.jpeg" /></td>
<td style="text-align: center;">For each row in the input array, the corresponding output row is generated by taking the first element from the current row, the second element from the first row, the third element from the current row, the fourth element from the second row and the fifth element from the first row. If the first element of the current row is 0 , then the entire output row becomes 0 .</td>
<td style="text-align: center;">The input grid is mirrored along its main diagonal, i.e., the diagonal from the top-left corner to the bottom-right corner. The color mapping remains the same.</td>
</tr>
<tr>
<td style="text-align: center;"><img alt="img-6.jpeg" src="img-6.jpeg" /></td>
<td style="text-align: center;">For a given 5x5 matrix, copy the first two values of the first row to the third and fourth positions of the fourth row and the first two values of the second row to the third and fourth positions of the third row. Then, copy the second value of the second row to the last position of the last row. Leave all the other positions unchanged.</td>
<td style="text-align: center;">The output grid is formed by taking the existing colored cells (non-zero numbers) from the topleft corner of the input grid, and creating a mirror image of this pattern in the bottom-right corner. This mirror image involves not only flipping the pattern along the central vertical and horizontal axes, but also rotating the position of the colors one position to the right in each cell. The rest of the cells remain black (0).</td>
</tr>
</tbody>
</table>
<p>tasks with a larger number of test examples, e.g., MiniSCAN, as it re-uses the same rule across all examples.</p>
<p><img alt="img-7.jpeg" src="img-7.jpeg" /></p>
<p>Figure 5: Raw accuracy and task accuracy over iterations.
Table 13: The average number of API calls and the average cost per task.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Model</th>
<th style="text-align: center;">Method</th>
<th style="text-align: center;"># API Calls</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Cost (cent)</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">ACRE</td>
<td style="text-align: center;">MiniSCAN</td>
<td style="text-align: center;">List Fns</td>
<td style="text-align: center;">MiniARC</td>
<td style="text-align: center;">ACRE</td>
<td style="text-align: center;">MiniSCAN</td>
<td style="text-align: center;">List Fns</td>
<td style="text-align: center;">MiniARC</td>
</tr>
<tr>
<td style="text-align: center;">GPT-4</td>
<td style="text-align: center;">IO</td>
<td style="text-align: center;">4.0</td>
<td style="text-align: center;">10.0</td>
<td style="text-align: center;">8.0</td>
<td style="text-align: center;">3.0</td>
<td style="text-align: center;">2.0</td>
<td style="text-align: center;">7.9</td>
<td style="text-align: center;">9.1</td>
<td style="text-align: center;">6.4</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">$\mathrm{SC}(\mathrm{N}=5)$</td>
<td style="text-align: center;">19.8</td>
<td style="text-align: center;">50.0</td>
<td style="text-align: center;">40.0</td>
<td style="text-align: center;">14.8</td>
<td style="text-align: center;">2.0</td>
<td style="text-align: center;">7.9</td>
<td style="text-align: center;">9.1</td>
<td style="text-align: center;">6.4</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">SR (T=3, N=5)</td>
<td style="text-align: center;">16.5</td>
<td style="text-align: center;">31.6</td>
<td style="text-align: center;">22.2</td>
<td style="text-align: center;">31.0</td>
<td style="text-align: center;">6.5</td>
<td style="text-align: center;">26.7</td>
<td style="text-align: center;">8.1</td>
<td style="text-align: center;">28.1</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">$\mathrm{T}=3, \mathrm{~N}=5$</td>
<td style="text-align: center;">8.2</td>
<td style="text-align: center;">6.3</td>
<td style="text-align: center;">17.4</td>
<td style="text-align: center;">27.2</td>
<td style="text-align: center;">2.3</td>
<td style="text-align: center;">4.5</td>
<td style="text-align: center;">12.0</td>
<td style="text-align: center;">36.5</td>
</tr>
<tr>
<td style="text-align: center;">GPT-3.5</td>
<td style="text-align: center;">IO</td>
<td style="text-align: center;">4.0</td>
<td style="text-align: center;">10.0</td>
<td style="text-align: center;">8.0</td>
<td style="text-align: center;">3.0</td>
<td style="text-align: center;">0.1</td>
<td style="text-align: center;">0.5</td>
<td style="text-align: center;">0.5</td>
<td style="text-align: center;">0.3</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">$\mathrm{T}=3, \mathrm{~N}=5$</td>
<td style="text-align: center;">9.8</td>
<td style="text-align: center;">11.2</td>
<td style="text-align: center;">21.4</td>
<td style="text-align: center;">27.4</td>
<td style="text-align: center;">0.1</td>
<td style="text-align: center;">0.7</td>
<td style="text-align: center;">0.8</td>
<td style="text-align: center;">1.6</td>
</tr>
<tr>
<td style="text-align: center;">Claude-2</td>
<td style="text-align: center;">IO</td>
<td style="text-align: center;">4.0</td>
<td style="text-align: center;">10.0</td>
<td style="text-align: center;">8.0</td>
<td style="text-align: center;">3.0</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">$\mathrm{T}=3, \mathrm{~N}=5$</td>
<td style="text-align: center;">8.7</td>
<td style="text-align: center;">14.4</td>
<td style="text-align: center;">20.2</td>
<td style="text-align: center;">26.2</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
</tbody>
</table>
<h1>C Human Studies</h1>
<h2>C. 1 Existing Human Performance</h2>
<p>Our experiments are largely motivated by cognitive science literature. Here, we collect results from existing human studies to better calibrate the performance of LMs and humans. It is important to note that the exact setups, data, and evaluations in these studies might differ from ours. Therefore, the reported human performance can only be used as a reference but not for direct comparison.</p>
<p>For ACRE, Gopnik et al. (2001) and Sobel et al. (2004) found that 3-4 year-old children are able to identify if an object is a Blicket within 2 trials. For MiniSCAN, Lake et al. (2019) conducted similar human experiments and found humans achieve around $80 \%$ average accuracy, with the lowest performance at around $65 \%$ and the highest at $88 \%$. For List Functions, Rule (2020) reported the average human performance of $45.9 \% .{ }^{17}$ For MiniARC, Kim et al. (2022b) did not provide any human experiment results. However, Johnson et al. (2021) evaluated a subset of tasks from ARC (Chollet, 2019) and found that human participants can solve $80 \%$ of the tasks, with $65 \%$ of tasks being solved by more than $80 \%$ of participants. Moskvichev et al. (2023) evaluated human participants on ConceptARC, a variant of ARC, and reported an average human performance of $90.9 \%$ in solving test examples. Additionally, Acquaviva et al. (2022) found that human annotators were able to write correct instructions for $88 \%$ of the ARC tasks.</p>
<h2>C. 2 SETUP</h2>
<p>We randomly sample 50 tasks for List Functions and MiniARC and ask crowdworkers to write and evaluate rules. For each task, we ask 3 annotators to write the rule, and for each rule pair, we ask another 3 annotators to evaluate them. For rule evaluation, following prior work (Saha et al., 2022; Chen et al., 2023b), we consider two metrics: clarity and supportiveness. Clarity evaluates whether the rule provides a clear explanation of the transformation from input to output. Supportivenss measures how well the rule align with examples. ${ }^{18}$ We use pairwise comparison with 4 labels: LM-induced rule is better, human-induced rule is better, equally good, and equally bad.</p>
<p><sup id="fnref11:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{17}$ The human performance was obtained by asking human participants to play a guessing game. It only requires solving unseen examples and did not involve writing rules. See Rule (2020) for details.
${ }^{18}$ Saha et al. (2022) use three metrics for evaluation: clarity, supportiveness, and generalizability. We did not consider generalizability as we directly evaluate on unseen examples. Our pilot experiments also suggest that crowdworkers found it challenging to distinguish between supportiveness and generalizability.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref5:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref6:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref7:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref8:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref9:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref10:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref11:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>