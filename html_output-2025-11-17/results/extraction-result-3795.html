<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-3795 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-3795</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-3795</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-90.html">extraction-schema-90</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of large language models (LLMs) being used to distill, extract, or discover quantitative laws, equations, or mathematical relationships from large numbers of scholarly input papers, including details of the methods, domains, results, benchmarks, and challenges.</div>
                <p><strong>Paper ID:</strong> paper-3ee45877f7f14c8ee4872a7249f74eef7dc2255f</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/3ee45877f7f14c8ee4872a7249f74eef7dc2255f" target="_blank">Deep symbolic regression: Recovering mathematical expressions from data via risk-seeking policy gradients</a></p>
                <p><strong>Paper Venue:</strong> International Conference on Learning Representations</p>
                <p><strong>Paper TL;DR:</strong> The proposed framework uses a recurrent neural network to emit a distribution over tractable mathematical expressions, and employs reinforcement learning to train the network to generate better-fitting expressions, which significantly outperforms standard genetic programming-based symbolic regression in its ability to exactly recover symbolic expressions.</p>
                <p><strong>Paper Abstract:</strong> Discovering the underlying mathematical expressions describing a dataset is a core challenge for artificial intelligence. This is the problem of $\textit{symbolic}$ $\textit{regression.}$ Despite recent advances in training neural networks to solve complex tasks, deep learning approaches to symbolic regression are underexplored. We propose a framework that combines deep learning with symbolic regression via a simple idea: use a large model to search the space of small models. More specifically, we use a recurrent neural network to emit a distribution over tractable mathematical expressions, and employ reinforcement learning to train the network to generate better-fitting expressions. Our algorithm significantly outperforms standard genetic programming-based symbolic regression in its ability to exactly recover symbolic expressions on a series of benchmark problems, both with and without added noise. More broadly, our contributions include a framework that can be applied to optimize hierarchical, variable-length objects under a black-box performance metric, with the ability to incorporate a priori constraints in situ, and a risk-seeking policy gradient formulation that optimizes for best-case performance instead of expected performance.</p>
                <p><strong>Cost:</strong> 0.007</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <p class="empty-note">No extracted data.</p>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <p class="empty-note">No potentially relevant new papers extracted.</p>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-3795",
    "paper_id": "paper-3ee45877f7f14c8ee4872a7249f74eef7dc2255f",
    "extraction_schema_id": "extraction-schema-90",
    "extracted_data": [],
    "potentially_relevant_new_papers": [],
    "cost": 0.00743375,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>DEEP SYMBOLIC REGRESSION: RECOVERING MATHEMATICAL EXPRESSIONS FROM DATA VIA RISK-SEEKING POLICY GRADIENTS</h1>
<p>Brenden K. Petersen*<br>Lawrence Livermore National Laboratory<br>Livermore, CA, USA<br>bp@llnl.gov</p>
<p>T. Nathan Mundhenk<br>Lawrence Livermore National Laboratory<br>Livermore, CA, USA<br>mundhenk1@llnl.gov</p>
<p>Soo K. Kim<br>Lawrence Livermore National Laboratory<br>Livermore, CA, USA<br>kim79@llnl.gov</p>
<h2>Mikel Landajuela Larma</h2>
<p>Lawrence Livermore National Laboratory Livermore, CA, USA
landajuelala1@llnl.gov</p>
<h2>Claudio P. Santiago</h2>
<p>Lawrence Livermore National Laboratory Livermore, CA, USA
santiago10@llnl.gov</p>
<p>Joanne T. Kim<br>Lawrence Livermore National Laboratory<br>Livermore, CA, USA<br>kim102@llnl.gov</p>
<h4>Abstract</h4>
<p>Discovering the underlying mathematical expressions describing a dataset is a core challenge for artificial intelligence. This is the problem of symbolic regression. Despite recent advances in training neural networks to solve complex tasks, deep learning approaches to symbolic regression are underexplored. We propose a framework that leverages deep learning for symbolic regression via a simple idea: use a large model to search the space of small models. Specifically, we use a recurrent neural network to emit a distribution over tractable mathematical expressions and employ a novel risk-seeking policy gradient to train the network to generate better-fitting expressions. Our algorithm outperforms several baseline methods (including Eureqa, the gold standard for symbolic regression) in its ability to exactly recover symbolic expressions on a series of benchmark problems, both with and without added noise. More broadly, our contributions include a framework that can be applied to optimize hierarchical, variable-length objects under a blackbox performance metric, with the ability to incorporate constraints in situ, and a risk-seeking policy gradient formulation that optimizes for best-case performance instead of expected performance.</p>
<h2>1 INTRODUCTION</h2>
<p>Understanding the mathematical relationships among variables in a physical system is an integral component of the scientific process. Symbolic regression aims to identify these relationships by searching over the space of tractable (i.e. concise, closed-form) mathematical expressions to best fit a dataset. Specifically, given a dataset $(X, y)$, where each point $X_{i} \in \mathbb{R}^{n}$ and $y_{i} \in \mathbb{R}$, symbolic regression aims to identify a function $f: \mathbb{R}^{n} \rightarrow \mathbb{R}$ that best fits the dataset, where the functional form of $f$ is a short mathematical expression. The resulting expression can be readily interpreted and/or provide useful scientific insights simply by inspection. In contrast, conventional regression imposes a single model structure that is fixed during training, often chosen to be expressive (e.g. a neural network) at the expense of being easily interpretable.</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>Symbolic regression exhibits several unique features that make it an excellent test problem for benchmarking automated machine learning (AutoML) and program synthesis methods: (1) there exist well-established, challenging benchmark problems with stringent success criteria (White et al., 2013); (2) there exist well-established baseline methods (most notably, the Eureqa algorithm (Schmidt \&amp; Lipson, 2009)); and (3) the reward function is computationally expedient, allowing sufficient experiment replicates to achieve statistical significance. Most other AutoML tasks, e.g. neural architecture search (NAS), do not exhibit these features; in fact, even simply evaluating the efficiency of the discrete search itself is a known challenge within NAS (Yu et al., 2019).</p>
<p>The space of mathematical expressions is discrete (in model structure) and continuous (in model parameters), growing exponentially with the length of the expression, rendering symbolic regression a challenging machine learning problem-thought to be NP-hard (Lu et al., 2016). Given this large, combinatorial search space, traditional approaches to symbolic regression typically utilize evolutionary algorithms, especially genetic programming (GP) (Koza, 1992; Schmidt \&amp; Lipson, 2009; BÃ¤ck et al., 2018). In GP-based symbolic regression, a population of mathematical expressions is "evolved" using evolutionary operations like selection, crossover, and mutation to improve a fitness function. While GP can be effective, it is also known to scale poorly to larger problems and to exhibit high sensitivity to hyperparameters.</p>
<p>Deep learning has permeated almost all areas of artificial intelligence, from computer vision (Krizhevsky et al., 2012) to optimal control (Mnih et al., 2015). However, deep learning may seem incongruous with or even antithetical toward symbolic regression, given that neural networks are typically highly complex, difficult to interpret, and rely on gradient information. We propose a framework that resolves this incongruity by tying deep learning and symbolic regression together with a simple idea: use a large model (i.e. neural network) to search the space of small models (i.e. symbolic expressions). This framework leverages the representational capacity of neural networks to generate interpretable expressions, while entirely bypassing the need to interpret the network itself.</p>
<p>We present deep symbolic regression (DSR), a gradient-based approach for symbolic regression based on reinforcement learning. In DSR, a recurrent neural network (RNN) emits a distribution over mathematical expressions. Expressions are sampled from the distribution, instantiated, and evaluated based on their fitness to the dataset. This fitness is used as the reward signal to train the RNN using a novel risk-seeking policy gradient algorithm. As training proceeds, the RNN adjusts the likelihood of an expression relative to its reward, assigning higher probabilities to better expressions.</p>
<p>We demonstrate that DSR outperforms several baseline methods, including two commercial software algorithms. We summarize our contributions as follows: (1) a novel method for symbolic regression that outperforms several baselines on a set of benchmark problems, (2) an autoregressive generative modeling framework for optimizing hierarchical, variable-length objects that accommodates in situ constraints, and (3) a novel risk-seeking policy gradient objective and accompanying Monte Carlo estimation procedure that optimizes for best-case performance instead of average performance.</p>
<h1>2 Related Work</h1>
<p>Deep learning for symbolic regression. Several recent approaches leverage deep learning for symbolic regression. AI Feynman (Udrescu \&amp; Tegmark, 2020) propose a problem-simplification tool for symbolic regression. They use neural networks to identify simplifying properties in a dataset (e.g. multiplicative separability, translational symmetry), which they exploit to recursively define simplified sub-problems that can then be tackled using any symbolic regression algorithm. In GrammarVAE, Kusner et al. (2017) develop a generative model for discrete objects that adhere to a pre-specified grammar, then optimize them in latent space. They demonstrate this can be used for symbolic regression; however, the method struggles to exactly recover expressions, and the generated expressions are not always syntactically valid. Sahoo et al. (2018) develop a symbolic regression framework using neural networks whose activation functions are symbolic operators. While this approach enables an end-to-end differentiable system, backpropagation through activation functions like division or logarithm requires the authors to make several simplifications to the search space, ultimately precluding learning certain simple classes of expressions like $\sqrt{x}$ or $\sin (x / y)$. We address and/or directly compare to these works in Appendices C and E.</p>
<p>AutoML and program synthesis. Symbolic regression is related to both automated machine learning (AutoML) and program synthesis, in that they all involve a search for an executable program (i.e. expression) to solve a particular task (i.e. to fit data) (Abolafia et al., 2018; Devlin et al., 2017; Riedel et al., 2016). More specifically, our framework has many parallels to a body of works within AutoML that use an autoregressive RNN to define a distribution over discrete objects and use reinforcement learning to optimize this distribution under a black-box performance metric (Zoph \&amp; Le, 2017; Ramachandran et al., 2017; Bello et al., 2017; Abolafia et al., 2018). For example, in neural architecture search (Zoph \&amp; Le, 2017), an RNN searches the space of neural network architectures, encoded by a sequence of discrete "tokens" specifying architectural properties (e.g. number of neurons) of each layer. The length of the sequence is fixed or scheduled during training; in contrast, our framework defines a search space that is both inherently hierarchical and variable length. Ramachandran et al. (2017) search the space of neural network activation functions. While this space is hierarchical in nature, the authors (rightfully) constrain it substantially by positing a functional unit that is repeated sequentially, thus restricting their search space back to a fixed-length sequence. However, a repeating-unit constraint is not practical for symbolic regression because the ground truth expression may have arbitrary structure.</p>
<p>Autoregressive models. The RNN-based distribution over expressions used in DSR is autoregressive, meaning each token is conditioned on the previously sampled tokens. Autoregressive models have proven to be useful for audio and image data (Oord et al., 2016a;b) in addition to the AutoML works discussed above; we further demonstrate their efficacy for hierarchical expressions. GraphRNN defines a distribution over graphs that generates an adjacency matrix one column at a time in autoregressive fashion (You et al., 2018). In principle, GraphRNN could be constrained to define a distribution over expressions, since trees are a special case of graphs. However, GraphRNN constructs graphs breadth-first, whereas expressions are more naturally represented using depth-first traversals (Li et al., 2005). Further, DSR exploits the hierarchical nature of trees by providing the parent and sibling as inputs to the RNN, and leverages the additional structure of expression trees that a node's value determines its number of children (e.g. cosine is a unary operator and thus has one child).</p>
<p>Risk-aware reinforcement learning. Many of the AutoML methods discussed above suffer from what we call the "expectation problem." That is, policy gradient methods are fundamentally suited for optimizing expectations; however, domains like neural architecture search and symbolic regression are evaluated by the few or single best-performing samples. Thus, there is a mismatch between the training objective function and the true desired objective: to maximize best-case performance. Abolafia et al. (2018) address the expectation problem by maintaining a priority queue of the best seen samples and using supervised learning to increase the likelihood of those top samples. Similarly, Liang et al. (2018) use a memory buffer to augment a policy gradient with off-policy training. These methods, however, only apply in the context of reinforcement learning environments with both deterministic transition dynamics and deterministic rewards. In contrast, the risk-seeking policy gradient introduced here is general, applying to any reinforcement learning environment and any stochastic policy gradient algorithm trained using batches, e.g. on Atari using proximal policy optimization (Schulman et al., 2017). Lastly, our risk-seeking policy gradient is closely related to the EPOpt- $\varepsilon$ algorithm used for robust reinforcement learning (Rajeswaran et al., 2016), which is based on a risk-averse policy gradient formulation (Tamar et al., 2014).</p>
<h1>3 MEthods</h1>
<p>Our overall approach involves representing mathematical expressions as sequences, developing an autoregressive model to generate expressions under a pre-specified set of constraints, and developing a risk-seeking policy gradient to train the model to generate better-fitting expressions.</p>
<h3>3.1 GENERATING EXPRESSIONS WITH A RECURRENT NEURAL NETWORK</h3>
<p>We leverage the fact that mathematical expressions can be represented using symbolic expression trees. Expression trees are a type of binary tree in which internal nodes are mathematical operators and terminal nodes are input variables or constants. Operators may be unary (i.e. one argument, such as sine) or binary (i.e. two arguments, such as multiply). Further, we can represent an expression tree as a sequence of node values or "tokens" by using its pre-order traversal (i.e. by visiting each node depth-first, then left-to-right). This allows us to generate an expression tree sequentially while still</p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: A. Example of sampling an expression from the RNN. For each token, the RNN emits a categorical distribution over tokens, a token is sampled, and the parent and sibling of the next token are used as the next input to the RNN. Subsequent tokens are sampled autoregressively until the tree is complete (i.e. all tree branches reach terminal nodes). The resulting sequence of tokens is the tree's pre-order traversal, which can be used to reconstruct the tree and instantiate its corresponding expression. Colors correspond to the number of children for each token. White circles represent empty tokens. Numbers indicate the order in which tokens were sampled. B. The library of tokens. C. The expression tree sampled in $\mathbf{A}$. In this example, the sampled expression is $\sin (c x) / \log (y)$, where the value of the constant $c$ is optimized with respect to an input dataset.
maintaining a one-to-one correspondence between the tree and its traversal. ${ }^{1}$ Thus, we represent an expression $\tau$ by the pre-order traversal of its corresponding expression tree. ${ }^{2}$ We denote the $i^{\text {th }}$ token of the traversal as $\tau_{i}$ and the length of the traversal as $|\tau|=T$. Each token has a value within a given library $\mathcal{L}$ of possible tokens, e.g. ${+,-, \times, \div, \sin , x}$.
We generate expressions one token at a time along the pre-order traversal (from $\tau_{1}$ to $\tau_{T}$ ). A categorical distribution with parameters $\psi$ defines the probabilities of selecting each token from $\mathcal{L}$. To capture the "context" of the expression as it is being generated, we condition this probability upon the selections of all previous tokens in that traversal. This conditional dependence can be achieved very generally using an RNN with parameters $\theta$ that emits a probability vector $\psi$ in an autoregressive manner. Specifically, the $i^{\text {th }}$ output of the RNN passes through a softmax layer (with shared weights across time steps) to produce vector $\psi^{(i)}$, which defines the probability distribution for selecting the $i^{\text {th }}$ token $\tau_{i}$, conditioned on the previously selected tokens $\tau_{1:(i-1)}$. That is, $p\left(\tau_{i} \mid \tau_{1:(i-1)} ; \theta\right)=\psi_{\mathcal{L}\left(\tau_{i}\right)}^{(i)}$, where $\mathcal{L}\left(\tau_{i}\right)$ is the index in $\mathcal{L}$ corresponding to $\tau_{i}$. The likelihood of the entire sampled expression is simply the product of the likelihoods of its tokens: $p(\tau \mid \theta)=\prod_{i=1}^{|\tau|} p\left(\tau_{i} \mid \tau_{1:(i-1)} ; \theta\right)=\prod_{i=1}^{|\tau|} \psi_{\mathcal{L}\left(\tau_{i}\right)}^{(i)}$.
An example of the sampling process is illustrated in Figure 1; pseudocode is provided in Algorithm 2 in Appendix A. Note that different samples from the distribution have different tree structures of different size; thus, the search space is inherently both hierarchical and variable length.</p>
<p>Providing hierarchical inputs to the RNN. Conventionally, the input to the RNN when sampling a token would be a representation of the previously sampled token. However, the search space for symbolic regression is inherently hierarchical, and the previously sampled token may actually be very distant from the next token to be sampled in the expression tree. For example, the fifth and</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>sixth tokens sampled in Figure 1 are adjacent nodes in the traversal but are four edges apart in the expression tree. To better capture hierarchical information, we provide as inputs to the RNN a representation of the parent and sibling nodes of the token being sampled. We introduce an empty token for cases in which a node does not have a parent or sibling. Pseudocode for identifying the parent and sibling nodes given a partial traversal is provided in Subroutine 1 in Appendix A.</p>
<p>Constraining the search space. Under our framework, it is straightforward to apply a priori constraints to reduce the search space. To demonstrate, we impose several simple, domain-agnostic constraints: (1) Expressions are limited to a pre-specified minimum and maximum length. We selected minimum length of 4 to prevent trivial expressions and a maximum length of 30 to ensure expressions are tractable. (2) The children of an operator should not all be constants, as the result would simply be a different constant. (3) The child of a unary operator should not be the inverse of that operator, e.g. $\log (\exp (x))$ is not allowed. (4) Descendants of trigonometric operators should not be trigonometric operators, e.g. $\sin (x+\cos (x))$ is not allowed because cosine is a descendant of sine. While still semantically meaningful, such composed trigonometric operators do not appear in virtually any scientific domain.</p>
<p>We apply these constraints in situ (i.e. concurrently with autoregressive sampling) by zeroing out the probabilities of selecting tokens that would violate a constraint. Pseudocode for this process is provided in Subroutine 2 in Appendix A. This process ensures that samples always adhere to all constraints, without rejecting samples post hoc. In contrast, imposing constraints with GP requires rejecting evolutionary operations post hoc (Fortin et al., 2012), which can be problematic (Craenen et al., 2001), and as we show in our experiments, can actually reduce performance.</p>
<p>Reward function. Once a pre-order traversal is sampled, we instantiate the corresponding symbolic expression and evaluate it with a reward function. A standard fitness measure in GP-based symbolic regression is normalized root-mean-square error (NRMSE), the root-mean-square error normalized by the standard deviation of the target values, $\sigma_{y}$. That is, given a dataset $(X, y)$ of size $n$ and candidate expression $f$, NRMSE $=\frac{1}{\sigma_{y}} \sqrt{\frac{1}{n} \sum_{i=1}^{n}\left(y_{i}-f\left(X_{i}\right)\right)^{2}}$. To bound the reward function, we apply a squashing function: $R(\tau)=1 /(1+\mathrm{NRMSE})$.</p>
<p>Constant optimization. If the library $\mathcal{L}$ includes the constant token, sampled expressions may include several constant placeholders. These can be viewed as parameters $\xi$ of the symbolic expression, which we optimize by maximizing the reward function: $\xi^{\star}=\arg \max _{\xi} R(\tau ; \xi)$, using a nonlinear optimization algorithm, e.g. BFGS (Fletcher, 2013). We perform this inner optimization loop for each sampled expression as part of the reward computation before performing each training step.</p>
<h1>3.2 TRAINING THE RNN USING POLICY GRADIENTS</h1>
<p>The reward function is not differentiable with respect to $\theta$; thus, we turn to reinforcement learning to train the RNN to produce better-fitting expressions. In this view, the distribution over mathematical expressions $p(\tau \mid \hat{\theta})$ is like a policy, sampled tokens are like actions, the parent and sibling inputs are like observations, sequences corresponding to expressions are like episodes, and the reward is a terminal, undiscounted reward only computed when an expression completes.</p>
<p>Standard policy gradient. We first consider the standard policy gradient objective to maximize $J_{\text {std }}(\theta)$, defined as the expectation of a reward function $R(\tau)$ under expressions from the policy: $J_{\text {std }}(\theta) \doteq \mathbb{E}_{\tau \sim p(\tau \mid \theta)}[R(\tau)]$. The standard REINFORCE policy gradient (Williams, 1992) can be used to maximize this expectation via gradient ascent:</p>
<p>$$
\begin{aligned}
\nabla_{\theta} J_{\text {std }}(\theta) &amp; =\nabla_{\theta} \mathbb{E}<em _mid="\mid" _sim="\sim" _tau="\tau" _theta_="\theta)" p_tau="p(\tau">{\tau \sim p(\tau \mid \theta)}[R(\tau)] \
&amp; =\mathbb{E}</em> \log p(\tau \mid \theta)\right]
\end{aligned}
$$}\left[R(\tau) \nabla_{\theta</p>
<p>This result allows one to estimate the expectation using samples from the distribution. Specifically, an unbiased estimate of $\nabla_{\theta} J_{\text {std }}(\theta)$ can be obtained by computing the sample mean over a batch of $N$ sampled expressions $\mathcal{T}=\left{\tau^{(i)}\right}_{i=1}^{N}$ :</p>
<p>$$
\nabla_{\theta} J_{\text {std }}(\theta) \approx \frac{1}{N} \sum_{i=1}^{N} R\left(\tau^{(i)}\right) \nabla_{\theta} \log p\left(\tau^{(i)} \mid \theta\right)
$$</p>
<p>This is an unbiased gradient estimate, but in practice it has high variance. To reduce variance, it is common to subtract a baseline function $b$ from the reward. As long as the baseline is not a function of</p>
<p>the current batch of expressions, the gradient estimate is still unbiased. Common choices of baseline functions are a moving average of rewards or an estimate of the value function. Intuitively, the gradient step increases the likelihood of expressions above the baseline and decreases the likelihood of expressions below.</p>
<p>Risk-seeking policy gradient. The standard policy gradient objective, $J_{\text {std }}(\theta)$, is defined as an expectation. This is the desired objective for control problems in which one seeks to optimize the average performance of a policy. However, in domains like symbolic regression, program synthesis, or neural architecture search, the final performance is measured by the single or few best-performing samples found during training. Similarly, one might be interested in a policy that achieves a "high score" in a control environment (e.g. Atari). For such problems, $J_{\text {std }}(\theta)$ is not an appropriate objective, as there is a mismatch between the objective being optimized and the final performance metric; this is the "expectation problem." To address this disconnect, we propose an alternative objective that focuses learning only on maximizing best-case performance. We first define $R_{\varepsilon}(\theta)$ as the $(1-\varepsilon)$-quantile of the distribution of rewards under the current policy. Note this is a function of $\theta$ but is typically intractable. We then propose a new learning objective, $J_{\text {risk }}(\theta ; \varepsilon)$, parameterized by $\varepsilon$ :</p>
<p>$$
J_{\text {risk }}(\theta ; \varepsilon) \doteq \mathbb{E}<em _varepsilon="\varepsilon">{\tau \sim p(\tau \mid \theta)}[R(\tau) \mid R(\tau) \geq R</em>(\theta)]
$$</p>
<p>This objective aims to increase the reward of the top $\varepsilon$ fraction of samples from the distribution, without regard for samples below that threshold. This objective bears close resemblance with $\varepsilon$ conditional value at risk (CVaR), for which the " $\leq$ " symbol is used instead of " $\geq$ " and the $\varepsilon$-quantile of rewards is used instead of the $(1-\varepsilon)$-quantile. Optimizing CVaR is a form of risk-averse learning that results in a policy that is robust against catastrophic outcomes (Tamar et al., 2014; Rajeswaran et al., 2016). In contrast, optimizing $J_{\text {risk }}(\theta ; \varepsilon)$ yields a risk-seeking policy gradient that aims to increase best-case performance at the expense of lower worst-case and average performances. Next, we show the analogous policy gradient of $J_{\text {risk }}(\theta ; \varepsilon)$ and how to estimate it via Monte Carlo sampling.
Proposition 1. Let $J_{\text {risk }}(\theta ; \varepsilon)$ denote the conditional expectation of rewards above the $(1-\varepsilon)$-quantile, as in Equation (1). Then the gradient of $J_{\text {risk }}(\theta ; \varepsilon)$ is given by:</p>
<p>$$
\nabla_{\theta} J_{\text {risk }}(\theta ; \varepsilon)=\mathbb{E}<em _varepsilon="\varepsilon">{\tau \sim p(\tau \mid \theta)}\left[\left(R(\tau)-R</em>(\theta)\right]
$$}(\theta)\right) \cdot \nabla_{\theta} \log p(\tau \mid \theta) \mid R(\tau) \geq R_{\varepsilon</p>
<p>The proof and assumptions are provided in Appendix B, and are adapted from the policy gradient derivation for the CVaR objective (Tamar et al., 2014). This result suggests a simple Monte Carlo estimate of the gradient from a batch of $N$ samples:</p>
<p>$$
\nabla_{\theta} J_{\text {risk }}(\theta ; \varepsilon) \approx \frac{1}{\varepsilon N} \sum_{i=1}^{N}\left[R\left(\tau^{(i)}\right)-\tilde{R}<em R_left_tau_i_="R\left(\tau^{(i)">{\varepsilon}(\theta)\right] \cdot \mathbf{1}</em>}\right) \geq \tilde{R<em _theta="\theta">{\varepsilon}(\theta)} \nabla</em> \mid \theta\right)
$$} \log p\left(\tau^{(i)</p>
<p>where $\tilde{R}<em x="x">{\varepsilon}(\theta)$ is the empirical $(1-\varepsilon)$-quantile of the batch of rewards, and $\mathbf{1}</em>(\theta)$, whereas the baseline for standard policy gradients is non-specific, chosen by the user; and (2) effectively, only the top $\varepsilon$ fraction of samples from each batch are used in the gradient computation. This process is essentially the opposite of the approach used to optimize CVaR (Tamar et al., 2014; Rajeswaran et al., 2016) for risk-averse reinforcement learning, in which only the bottom $\varepsilon$ fraction of samples from each batch are used.}$ returns 1 if condition $x$ is true and 0 otherwise. Essentially, this is the standard REINFORCE Monte Carlo estimate with two differences: (1) theory suggests a specific baseline, $R_{\varepsilon</p>
<p>Note that in Proposition 1 and the corresponding Monte Carlo estimation procedure, $\tau$ need not refer to a symbolic expression or even a discrete object. For example, it may refer to a state-action trajectory in a control problem. Thus, the risk-seeking policy gradient formulation is general and can easily be applied to any reinforcement learning environment using any stochastic policy gradient algorithm trained using batches, e.g. proximal policy optimization (Schulman et al., 2017).</p>
<p>Lastly, in accordance with the maximum entropy reinforcement learning framework (Haarnoja et al., 2018), we provide a bonus to the loss function proportional to the entropy of the sampled expressions. Pseudocode for DSR is shown in Algorithm 1. Source code is made available at https://github.com/brendenpetersen/deep-symbolic-regression.</p>
<h1>4 ReSults and DisCussion</h1>
<p>Evaluating DSR. We evaluated DSR on the Nguyen symbolic regression benchmark suite (Uy et al., 2011), a set of 12 commonly used benchmark expressions developed and vetted by the symbolic</p>
<div class="codehilite"><pre><span></span><code><span class="n">Algorithm</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">Deep</span><span class="w"> </span><span class="n">symbolic</span><span class="w"> </span><span class="n">regression</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">risk</span><span class="o">-</span><span class="n">seeking</span><span class="w"> </span><span class="n">policy</span><span class="w"> </span><span class="n">gradient</span>
<span class="n">input</span><span class="w"> </span><span class="n">learning</span><span class="w"> </span><span class="n">rate</span><span class="w"> </span>\<span class="p">(</span>\<span class="n">alpha</span>\<span class="p">);</span><span class="w"> </span><span class="n">entropy</span><span class="w"> </span><span class="n">coefficient</span><span class="w"> </span>\<span class="p">(</span>\<span class="n">lambda_</span><span class="p">{</span>\<span class="n">mathcal</span><span class="p">{</span><span class="n">H</span><span class="p">}}</span>\<span class="p">);</span><span class="w"> </span><span class="n">risk</span><span class="w"> </span><span class="n">factor</span><span class="w"> </span>\<span class="p">(</span>\<span class="n">varepsilon</span>\<span class="p">);</span><span class="w"> </span><span class="n">batch</span><span class="w"> </span><span class="n">size</span><span class="w"> </span>\<span class="p">(</span><span class="n">N</span>\<span class="p">);</span><span class="w"> </span><span class="n">reward</span><span class="w"> </span><span class="n">function</span><span class="w"> </span>\<span class="p">(</span><span class="n">R</span>\<span class="p">)</span>
<span class="n">output</span><span class="w"> </span><span class="n">Best</span><span class="w"> </span><span class="n">fitting</span><span class="w"> </span><span class="n">expression</span><span class="w"> </span>\<span class="p">(</span>\<span class="n">tau</span><span class="o">^</span><span class="p">{</span><span class="o">*</span><span class="p">}</span>\<span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="w"> </span><span class="n">Initialize</span><span class="w"> </span><span class="n">RNN</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">parameters</span><span class="w"> </span>\<span class="p">(</span>\<span class="n">theta</span>\<span class="p">),</span><span class="w"> </span><span class="n">defining</span><span class="w"> </span><span class="n">distribution</span><span class="w"> </span><span class="n">over</span><span class="w"> </span><span class="n">expressions</span><span class="w"> </span>\<span class="p">(</span><span class="n">p</span><span class="p">(</span>\<span class="n">cdot</span><span class="w"> </span>\<span class="n">mid</span><span class="w"> </span>\<span class="n">theta</span><span class="p">)</span>\<span class="p">)</span>
<span class="mi">2</span><span class="p">:</span><span class="w"> </span><span class="n">repeat</span>
<span class="w">        </span>\<span class="p">(</span>\<span class="n">mathcal</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="w"> </span>\<span class="n">leftarrow</span>\<span class="n">left</span>\<span class="p">{</span>\<span class="n">tau</span><span class="o">^</span><span class="p">{(</span><span class="n">i</span><span class="p">)}</span><span class="w"> </span>\<span class="n">sim</span><span class="w"> </span><span class="n">p</span><span class="p">(</span>\<span class="n">cdot</span><span class="w"> </span>\<span class="n">mid</span><span class="w"> </span>\<span class="n">theta</span><span class="p">)</span>\<span class="n">right</span>\<span class="p">}</span><span class="n">_</span><span class="p">{</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="n">N</span><span class="p">}</span><span class="w"> </span>\<span class="n">quad</span><span class="w"> </span>\<span class="n">triangleright</span>\<span class="p">)</span><span class="w"> </span><span class="n">Sample</span><span class="w"> </span>\<span class="p">(</span><span class="n">N</span>\<span class="p">)</span><span class="w"> </span><span class="n">expressions</span><span class="w"> </span><span class="p">(</span><span class="n">Alg</span><span class="o">.</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">Appendix</span><span class="w"> </span><span class="n">A</span><span class="p">)</span>
<span class="w">        </span>\<span class="p">(</span>\<span class="n">mathcal</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="w"> </span>\<span class="n">leftarrow</span>\<span class="n">left</span>\<span class="p">{</span>\<span class="n">operatorname</span><span class="p">{</span><span class="n">OptimizeConstants</span>\<span class="n">left</span><span class="p">(</span>\<span class="n">tau</span><span class="o">^</span><span class="p">{(</span><span class="n">i</span><span class="p">)},</span><span class="w"> </span><span class="n">R</span>\<span class="n">right</span><span class="p">)</span>\<span class="n">right</span>\<span class="p">}}</span><span class="n">_</span><span class="p">{</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="n">N</span><span class="p">}</span><span class="w"> </span>\<span class="n">quad</span><span class="w"> </span>\<span class="n">triangleright</span>\<span class="p">)</span><span class="w"> </span><span class="n">Optimize</span><span class="w"> </span><span class="n">constants</span><span class="w"> </span><span class="n">w</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="w"> </span><span class="n">reward</span><span class="w"> </span><span class="n">function</span>
<span class="w">        </span>\<span class="p">(</span>\<span class="n">mathcal</span><span class="p">{</span><span class="n">R</span><span class="p">}</span><span class="w"> </span>\<span class="n">leftarrow</span>\<span class="n">left</span>\<span class="p">{</span><span class="n">R</span>\<span class="n">left</span><span class="p">(</span>\<span class="n">tau</span><span class="o">^</span><span class="p">{(</span><span class="n">i</span><span class="p">)}</span>\<span class="n">right</span><span class="p">)</span>\<span class="n">right</span>\<span class="p">}</span><span class="n">_</span><span class="p">{</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="n">N</span><span class="p">}</span><span class="w"> </span>\<span class="n">quad</span><span class="w"> </span>\<span class="n">triangleright</span>\<span class="p">)</span><span class="w"> </span><span class="n">Compute</span><span class="w"> </span><span class="n">rewards</span>
<span class="w">        </span>\<span class="p">(</span><span class="n">R_</span><span class="p">{</span>\<span class="n">varepsilon</span><span class="p">}</span><span class="w"> </span>\<span class="n">leftarrow</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span>\<span class="n">varepsilon</span><span class="p">)</span>\<span class="p">)</span><span class="o">-</span><span class="n">quantile</span><span class="w"> </span><span class="n">of</span><span class="w"> </span>\<span class="p">(</span>\<span class="n">mathcal</span><span class="p">{</span><span class="n">R</span><span class="p">}</span><span class="w"> </span>\<span class="n">quad</span><span class="w"> </span>\<span class="n">triangleright</span>\<span class="p">)</span><span class="w"> </span><span class="n">Compute</span><span class="w"> </span><span class="n">reward</span><span class="w"> </span><span class="n">threshold</span>
<span class="w">        </span>\<span class="p">(</span>\<span class="n">mathcal</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="w"> </span>\<span class="n">leftarrow</span>\<span class="n">left</span>\<span class="p">{</span>\<span class="n">tau</span><span class="o">^</span><span class="p">{(</span><span class="n">i</span><span class="p">)}:</span><span class="w"> </span><span class="n">R</span>\<span class="n">left</span><span class="p">(</span>\<span class="n">tau</span><span class="o">^</span><span class="p">{(</span><span class="n">i</span><span class="p">)}</span>\<span class="n">right</span><span class="p">)</span><span class="w"> </span>\<span class="n">geq</span><span class="w"> </span><span class="n">R_</span><span class="p">{</span>\<span class="n">varepsilon</span><span class="p">}</span>\<span class="n">right</span>\<span class="p">}</span><span class="w"> </span>\<span class="n">quad</span><span class="w"> </span>\<span class="n">triangleright</span>\<span class="p">)</span><span class="w"> </span><span class="n">Select</span><span class="w"> </span><span class="n">subset</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">expressions</span><span class="w"> </span><span class="n">above</span><span class="w"> </span><span class="n">threshold</span>
<span class="w">        </span>\<span class="p">(</span>\<span class="n">mathcal</span><span class="p">{</span><span class="n">R</span><span class="p">}</span><span class="w"> </span>\<span class="n">leftarrow</span>\<span class="n">left</span>\<span class="p">{</span><span class="n">R</span>\<span class="n">left</span><span class="p">(</span>\<span class="n">tau</span><span class="o">^</span><span class="p">{(</span><span class="n">i</span><span class="p">)}</span>\<span class="n">right</span><span class="p">):</span><span class="w"> </span><span class="n">R</span>\<span class="n">left</span><span class="p">(</span>\<span class="n">tau</span><span class="o">^</span><span class="p">{(</span><span class="n">i</span><span class="p">)}</span>\<span class="n">right</span><span class="p">)</span><span class="w"> </span>\<span class="n">geq</span><span class="w"> </span><span class="n">R_</span><span class="p">{</span>\<span class="n">varepsilon</span><span class="p">}</span>\<span class="n">right</span>\<span class="p">}</span><span class="w"> </span>\<span class="n">quad</span><span class="w"> </span>\<span class="n">triangleright</span>\<span class="p">)</span><span class="w"> </span><span class="n">Select</span><span class="w"> </span><span class="n">corresponding</span><span class="w"> </span><span class="n">subset</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">rewards</span>
<span class="w">        </span>\<span class="p">(</span>\<span class="n">hat</span><span class="p">{</span><span class="n">g_</span><span class="p">{</span><span class="mi">1</span><span class="p">}}</span><span class="w"> </span>\<span class="n">leftarrow</span><span class="w"> </span>\<span class="n">operatorname</span><span class="p">{</span><span class="n">ReduceMean</span><span class="p">}</span>\<span class="n">left</span><span class="p">(</span>\<span class="n">left</span><span class="p">(</span>\<span class="n">mathcal</span><span class="p">{</span><span class="n">R</span><span class="p">}</span><span class="o">-</span><span class="n">R_</span><span class="p">{</span>\<span class="n">varepsilon</span><span class="p">}</span>\<span class="n">right</span><span class="p">)</span><span class="w"> </span>\<span class="n">nabla_</span><span class="p">{</span>\<span class="n">theta</span><span class="p">}</span><span class="w"> </span>\<span class="nb">log</span><span class="w"> </span><span class="n">p</span><span class="p">(</span>\<span class="n">mathcal</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="w"> </span>\<span class="n">mid</span><span class="w"> </span>\<span class="n">theta</span><span class="p">)</span>\<span class="n">right</span><span class="p">)</span><span class="w"> </span>\<span class="n">quad</span><span class="w"> </span>\<span class="n">triangleright</span>\<span class="p">)</span><span class="w"> </span><span class="n">Compute</span><span class="w"> </span><span class="n">risk</span><span class="o">-</span><span class="n">seeking</span><span class="w"> </span><span class="n">policy</span><span class="w"> </span><span class="n">gradient</span>
<span class="w">        </span>\<span class="p">(</span>\<span class="n">hat</span><span class="p">{</span><span class="n">g_</span><span class="p">{</span><span class="mi">2</span><span class="p">}}</span><span class="w"> </span>\<span class="n">leftarrow</span><span class="w"> </span>\<span class="n">operatorname</span><span class="p">{</span><span class="n">ReduceMean</span><span class="p">}</span>\<span class="n">left</span><span class="p">(</span>\<span class="n">lambda_</span><span class="p">{</span>\<span class="n">mathcal</span><span class="p">{</span><span class="n">H</span><span class="p">}}</span><span class="w"> </span>\<span class="n">nabla_</span><span class="p">{</span>\<span class="n">theta</span><span class="p">}</span><span class="w"> </span>\<span class="n">mathcal</span><span class="p">{</span><span class="n">H</span><span class="p">}(</span>\<span class="n">mathcal</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="w"> </span>\<span class="n">mid</span><span class="w"> </span>\<span class="n">theta</span><span class="p">)</span>\<span class="n">right</span><span class="p">)</span><span class="w"> </span>\<span class="n">quad</span><span class="w"> </span>\<span class="n">triangleright</span>\<span class="p">)</span><span class="w"> </span><span class="n">Compute</span><span class="w"> </span><span class="n">entropy</span><span class="w"> </span><span class="n">gradient</span>
<span class="w">        </span>\<span class="p">(</span>\<span class="n">theta</span><span class="w"> </span>\<span class="n">leftarrow</span><span class="w"> </span>\<span class="n">theta</span><span class="o">+</span>\<span class="n">alpha</span>\<span class="n">left</span><span class="p">(</span>\<span class="n">hat</span><span class="p">{</span><span class="n">g_</span><span class="p">{</span><span class="mi">1</span><span class="p">}}</span><span class="o">+</span>\<span class="n">hat</span><span class="p">{</span><span class="n">g_</span><span class="p">{</span><span class="mi">2</span><span class="p">}}</span>\<span class="n">right</span><span class="p">)</span><span class="w"> </span>\<span class="n">quad</span><span class="w"> </span>\<span class="n">triangleright</span>\<span class="p">)</span><span class="w"> </span><span class="n">Apply</span><span class="w"> </span><span class="n">gradients</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span>\<span class="p">(</span>\<span class="nb">max</span><span class="w"> </span>\<span class="n">mathcal</span><span class="p">{</span><span class="n">R</span><span class="p">}</span><span class="o">&gt;</span><span class="n">R</span>\<span class="n">left</span><span class="p">(</span>\<span class="n">tau</span><span class="o">^</span><span class="p">{</span><span class="o">*</span><span class="p">}</span>\<span class="n">right</span><span class="p">)</span>\<span class="p">)</span><span class="w"> </span><span class="n">then</span><span class="w"> </span>\<span class="p">(</span>\<span class="n">tau</span><span class="o">^</span><span class="p">{</span><span class="o">*</span><span class="p">}</span><span class="w"> </span>\<span class="n">leftarrow</span><span class="w"> </span>\<span class="n">tau</span><span class="o">^</span><span class="p">{</span>\<span class="n">left</span><span class="p">(</span>\<span class="n">arg</span><span class="w"> </span>\<span class="nb">max</span><span class="w"> </span>\<span class="n">mathcal</span><span class="p">{</span><span class="n">R</span><span class="p">}</span>\<span class="n">right</span><span class="p">)}</span>\<span class="p">)</span><span class="w"> </span>\<span class="n">quad</span><span class="w"> </span>\<span class="n">triangleright</span><span class="w"> </span><span class="n">Update</span><span class="w"> </span><span class="n">best</span><span class="w"> </span><span class="n">expression</span>
<span class="mi">3</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span>\<span class="p">(</span>\<span class="n">tau</span><span class="o">^</span><span class="p">{</span><span class="o">*</span><span class="p">}</span>\<span class="p">)</span><span class="w"> </span>
</code></pre></div>

<p>regression community (White et al., 2013). Each benchmark is defined by a ground truth expression, a training and test dataset, and a set of allowed operators, described in Table 2 in Appendix D. The training data is used to compute the reward for each candidate expression, the test data is used to evaluate the best found candidate expression at the end of training, and the ground truth expression is used to determine whether the best found candidate expression was correctly recovered.</p>
<p>We compared DSR against five strong symbolic regression baselines: (1) PQT: an implementation of our framework trained using priority queue training (Abolafia et al., 2018) in place of the risk-seeking policy gradient, (2) VPG: a "vanilla" implementation of our framework using the standard policy gradient (with baseline) in place of the risk-seeking policy gradient, (3) GP: a standard GP-based symbolic regression implementation (Fortin et al., 2012), (4) Eureqa: popular commercial software ${ }^{3}$ based on Schmidt \&amp; Lipson (2009), the gold standard for symbolic regression, and (5) Wolfram: commercial software ${ }^{4}$ based on Markov chain Monte Carlo and nonlinear regression (Fortuna, 2015). Each baseline is further detailed in Appendix C. Notably, the two RNN-based baselines (PQT and VPG) differ from DSR only via their training objective, i.e. a supervised objective for PQT and the standard policy gradient for VPG. All other aspects of our framework (in situ constraints, hierarchical RNN inputs, constant optimization) are also included for these baselines. While GP can incorporate post hoc constraints, we found that doing so actually hinders performance (see Appendix F); thus, they are excluded for GP we exclude all constraints other than the maximum length constraint.</p>
<p>Each experiment consists of 2 million expression evaluations for DSR, PQT, VPG, and GP, by which point training curves have levelled off. Hyperparameters were tuned on benchmarks Nguyen-7 and Nguyen-10 using a grid search comprising 800 hyperparameter combinations for GP and 81 combinations for each of DSR, PQT, and VPG (see Appendix D for details). Commercial software algorithms (Eureqa and Wolfram) do not expose hyperparameters and were run until completion. All experiments were replicated with 100 different random seeds for each benchmark expression. Wolfram results are only presented for one-dimensional benchmarks because the method is not applicable to higher dimensions. Additional experiment details are provided in Appendix D. Training curves are provided in Appendix F.</p>
<p>In Table 1, we report the recovery rate for each benchmark. We use the strictest definition of recovery: exact symbolic equivalence, as determined using a computer algebra system, e.g. SymPy (Meurer et al., 2017). In Table 9 in Appendix F, we report recovery on several additional variants of Nguyen benchmarks in which we introduced real-valued constants (to demonstrate the constant optimizer) or altered the functional form to make the problems more challenging. DSR significantly outperforms all five baselines in its ability to exactly recover benchmark expressions. In Tables 5-8 in Appendix E, we compare DSR to literature-reported values from four additional baseline methods (Huynh et al., 2016; Kusner et al., 2017; Jin et al., 2019; Trujillo et al., 2016) by carefully recapitulating their</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>Table 1: Recovery rate comparison of DSR and five baselines on the Nguyen symbolic regression benchmark suite. A bold value represents statistical significance ( $p&lt;10^{-3}$ ) across all benchmarks.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Benchmark</th>
<th style="text-align: center;">Expression</th>
<th style="text-align: center;">DSR</th>
<th style="text-align: center;">PQT</th>
<th style="text-align: center;">VPG</th>
<th style="text-align: center;">GP</th>
<th style="text-align: center;">Eureqa</th>
<th style="text-align: center;">Wolfram</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Nguyen-1</td>
<td style="text-align: center;">$x^{3}+x^{2}+x$</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">96\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">100\%</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-2</td>
<td style="text-align: center;">$x^{4}+x^{3}+x^{2}+x$</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">99\%</td>
<td style="text-align: center;">47\%</td>
<td style="text-align: center;">97\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">100\%</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-3</td>
<td style="text-align: center;">$x^{5}+x^{4}+x^{3}+x^{2}+x$</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">86\%</td>
<td style="text-align: center;">4\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">95\%</td>
<td style="text-align: center;">100\%</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-4</td>
<td style="text-align: center;">$x^{6}+x^{5}+x^{4}+x^{3}+x^{2}+x$</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">93\%</td>
<td style="text-align: center;">1\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">70\%</td>
<td style="text-align: center;">100\%</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-5</td>
<td style="text-align: center;">$\sin \left(x^{2}\right) \cos (x)-1$</td>
<td style="text-align: center;">72\%</td>
<td style="text-align: center;">73\%</td>
<td style="text-align: center;">5\%</td>
<td style="text-align: center;">45\%</td>
<td style="text-align: center;">73\%</td>
<td style="text-align: center;">2\%</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-6</td>
<td style="text-align: center;">$\sin (x)+\sin \left(x+x^{2}\right)$</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">98\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">91\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">1\%</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-7</td>
<td style="text-align: center;">$\log (x+1)+\log \left(x^{2}+1\right)$</td>
<td style="text-align: center;">35\%</td>
<td style="text-align: center;">41\%</td>
<td style="text-align: center;">3\%</td>
<td style="text-align: center;">0\%</td>
<td style="text-align: center;">85\%</td>
<td style="text-align: center;">0\%</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-8</td>
<td style="text-align: center;">$\sqrt{x}$</td>
<td style="text-align: center;">96\%</td>
<td style="text-align: center;">21\%</td>
<td style="text-align: center;">5\%</td>
<td style="text-align: center;">5\%</td>
<td style="text-align: center;">0\%</td>
<td style="text-align: center;">71\%</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-9</td>
<td style="text-align: center;">$\sin (x)+\sin \left(y^{2}\right)$</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-10</td>
<td style="text-align: center;">$2 \sin (x) \cos (y)$</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">91\%</td>
<td style="text-align: center;">99\%</td>
<td style="text-align: center;">76\%</td>
<td style="text-align: center;">64\%</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-11</td>
<td style="text-align: center;">$x^{6}$</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">7\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-12</td>
<td style="text-align: center;">$x^{4}-x^{3}+\frac{1}{2} y^{2}-y$</td>
<td style="text-align: center;">0\%</td>
<td style="text-align: center;">0\%</td>
<td style="text-align: center;">0\%</td>
<td style="text-align: center;">0\%</td>
<td style="text-align: center;">0\%</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Average</td>
<td style="text-align: center;">83.6\%</td>
<td style="text-align: center;">75.2\%</td>
<td style="text-align: center;">46.7\%</td>
<td style="text-align: center;">60.1\%</td>
<td style="text-align: center;">73.9\%</td>
<td style="text-align: center;">-</td>
</tr>
</tbody>
</table>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: A - D. Empirical reward distributions for Nguyen-8. Each curve is a Gaussian kernel density estimate (bandwidth 0.25 ) of the rewards for a particular training iteration, using either the full batch of expressions ( $\mathbf{A}$ and $\mathbf{C}$ ) or the top $\varepsilon$ fraction of the batch ( $\mathbf{B}$ and $\mathbf{D}$ ), averaged over all training runs. Black plots ( $\mathbf{A}$ and $\mathbf{B}$ ) were trained using the risk-seeking policy gradient objective. Blue plots ( $\mathbf{C}$ and $\mathbf{D}$ ) were trained using the standard policy gradient objective. Colorbars indicate training step. Triangle markings denote the empirical mean of the distribution at the final training step. E. Training curves for mean reward of full batch (dotted), mean reward of top $\varepsilon$ fraction of the batch (dashed), and best expression found so far (solid), averaged over all training runs.
experimental setup (e.g. choice of library, benchmarks, and measure of performance). DSR greatly outperforms each study's published results.
Characterizing the risk-seeking policy gradient. The intuition behind the risk-seeking policy gradient is that it explicitly optimizes for best-case performance, possibly at the expense of average performance. We demonstrate this visually in Figure 2 by comparing the empirical reward distributions when trained with either the risk-seeking or standard policy gradient for Nguyen-8. (Analogous plots for all Nguyen benchmarks are provided in Appendix F.) Interestingly, at the end of training, the mean reward over the full batch (an estimate of $J_{\text {std }}(\theta)$ ) is larger when training with the standard policy gradient, even though the risk-seeking policy gradient produces larger mean over the top $\varepsilon$ fraction of the batch (an estimate of $J_{\text {risk }}(\theta ; \varepsilon)$ ) and a superior best expression. This is consistent with the intuition of maximizing best-case performance at the expense of average performance. In contrast, the best-case performance of the standard policy gradient plateaus early in training (Figure 2E, dashed blue curve), whereas the risk-seeking policy gradient continues to increase until the end of training (Figure 2E, dashed black curve).
Ablation studies. Algorithm 1 includes several additional components relative to a "vanilla" policy gradient search. We performed a series of ablation studies to quantify the effect of each of these components, along with the effects of the various constraints on the search space. In Figure 3, we show recovery rate for DSR on the Nguyen benchmarks for each ablation. While no single ablation leads to catastrophic failure, combinations of ablations can cause large degradation in performance.</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: Recovery for various ablations of Algorithm 1 across all Nguyen benchmarks. Error bars represent standard error.
<img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 4: Recovery vs dataset noise and dataset size across all Nguyen benchmarks. Error bars represent standard error.
<img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 5: Recovery vs added reward noise on Nguyen-4. Error bars represent standard error.</p>
<p>Noisy data and amount of data. We evaluated the robustness of DSR to noisy data by adding independent Gaussian noise to the dependent variable, with mean zero and standard deviation proportional to the root-mean-square of the dependent variable in the training data. In Figure 4, we varied the proportionality constant from 0 (noiseless) to $10^{-1}$ and evaluated each algorithm (except Wolfram, which catastrophically fails for even the smallest noise level) across all Nguyen benchmarks. Because expressions can overfit to the noise in these experiments, we defined recovery as exact symbolic equivalence on any expression along the reward-complexity Pareto front at the end of training (see Appendix D for details). Increasing the dataset size may help prevent overfitting by smoothing the reward function. Thus, we repeated the noise experiments with 10-fold larger training datasets (Figure 4, dashed lines). For each dataset size, DSR consistently outperforms all baselines.</p>
<p>Performance under reward noise. The risk-seeking policy gradient is derived from a conditional expectation, and is thus well-justified for tasks with stochastic rewards. In contrast, PQT assumes deterministic rewards. Since symbolic regression is a deterministic task, we emulated a stochastic reward function by adding independent Gaussian noise directly to the reward function: $R^{\prime}(\tau)=$ $R(\tau)+\mathcal{N}(0, \sigma)$. In Figure 5, we compare DSR and PQT performance under increasing reward noise on benchmark Nguyen-4, a task that is an easier exploitation problem but difficult exploration problem. As reward noise increases, recovery for PQT heavily relies on exploration and luck, whereas DSR recovery remains stable even for high reward noise.</p>
<h1>5 CONCLUSION AND FUTURE WORK</h1>
<p>We introduce a reinforcement learning approach to symbolic regression that outperforms state-of-theart baselines in its ability to recover exact expressions on benchmark tasks. Since both DSR and GP generate expression trees, there are many opportunities for hybrid methods, for example including several generations of evolutionary operations within the inner optimization loop. Our framework includes a flexible distribution over hierarchical, variable-length objects that allows imposing in situ constraints. Our framework is easily extensible to other domains, which we save for future work; for example, searching the space of expressions to be used as control policies in reinforcement learning environments, or searching the space of organic molecular structures for high binding affinity to a reference compound. Our risk-seeking policy gradient formulation can also be applied to more traditional reinforcement learning domains; for example, optimizing for a high score (instead of average score) in Atari video games.</p>
<h2>ACKNOWLEDGMENTS</h2>
<p>We thank Ruben Glatt, Thomas Desautels, Priyadip Ray, David Widemann, and the 2019 UC Merced Data Science Challenge participants for their useful comments and insights. This work was performed under the auspices of the U.S. Department of Energy by Lawrence Livermore National Laboratory under contract DE-AC52-07NA27344. Lawrence Livermore National Security, LLC. LLNL-CONF-790457.</p>
<h1>REFERENCES</h1>
<p>Daniel A Abolafia, Mohammad Norouzi, Jonathan Shen, Rui Zhao, and Quoc V Le. Neural program synthesis with priority queue training. arXiv preprint arXiv:1801.03526, 2018.</p>
<p>Thomas BÃ¤ck, David B Fogel, and Zbigniew Michalewicz. Evolutionary Computation 1: Basic Algorithms and Operators. CRC press, 2018.</p>
<p>Irwan Bello, Barret Zoph, Vijay Vasudevan, and Quoc V Le. Neural optimizer search with reinforcement learning. In Proceedings of the 34th International Conference on Machine Learning-Volume 70, pp. 459-468. JMLR. org, 2017.</p>
<p>BGW Craenen, AE Eiben, and E Marchiori. How to handle constraints with evolutionary algorithms. Practical Handbook Of Genetic Algorithms: Applications, pp. 341-361, 2001.</p>
<p>Jacob Devlin, Jonathan Uesato, Surya Bhupatiraju, Rishabh Singh, Abdel-rahman Mohamed, and Pushmeet Kohli. Robustfill: Neural program learning under noisy i/o. arXiv preprint arXiv:1703.07469, 2017.</p>
<p>Roger Fletcher. Practical Methods of Optimization. John Wiley \&amp; Sons, 2013.
FÃ©lix-Antoine Fortin, FranÃ§ois-Michel De Rainville, Marc-AndrÃ© Gardner, Marc Parizeau, and Christian GagnÃ©. Deap: Evolutionary algorithms made easy. Journal of Machine Learning Research, 13(Jul):2171-2175, 2012.</p>
<p>Giorgia Fortuna. Automatic formula discovery in the wolfram language. In Wolfram Technology Conference 2015. Wolfram Research, 2015. URL https://library.wolfram.com/ infocenter/Conferences/9329/.</p>
<p>Tuomas Haarnoja, Aurick Zhou, Pieter Abbeel, and Sergey Levine. Soft actor-critic: Off-policy maximum entropy deep reinforcement learning with a stochastic actor. arXiv preprint arXiv:1801.01290, 2018.</p>
<p>Quang Nhat Huynh, Hemant Kumar Singh, and Tapabrata Ray. Improving symbolic regression through a semantics-driven framework. In 2016 IEEE Symposium Series on Computational Intelligence (SSCI), pp. 1-8. IEEE, 2016.</p>
<p>Ying Jin, Weilin Fu, Jian Kang, Jiadong Guo, and Jian Guo. Bayesian symbolic regression. arXiv preprint arXiv:1910.08892, 2019.</p>
<p>John R Koza. Genetic Programming: On the Programming of Computers by Means of Natural Selection, volume 1. MIT press, 1992.</p>
<p>Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton. Imagenet classification with deep convolutional neural networks. In Advances in neural information processing systems, pp. 1097-1105, 2012.</p>
<p>Matt J Kusner, Brooks Paige, and JosÃ© Miguel HernÃ¡ndez-Lobato. Grammar variational autoencoder. In Proceedings of the 34th International Conference on Machine Learning-Volume 70, pp. 19451954. JMLR. org, 2017.</p>
<p>Xin Li, Chi Zhou, Weimin Xiao, and Peter C Nelson. Prefix gene expression programming. In Late breaking paper at Genetic and Evolutionary Computation Conference (GECCO'2005), Washington, DC, USA, pp. 25-29, 2005.</p>
<p>Chen Liang, Mohammad Norouzi, Jonathan Berant, Quoc Le, and Ni Lao. Memory augmented policy optimization for program synthesis with generalization. arXiv preprint arXiv:1807.02322, 2018.</p>
<p>Qiang Lu, Jun Ren, and Zhiguang Wang. Using genetic programming with prior formula knowledge to solve symbolic regression problem. Computational intelligence and neuroscience, 2016, 2016.</p>
<p>Aaron Meurer, Christopher P. Smith, Mateusz Paprocki, OndÅej ÄertÃ­k, Sergey B. Kirpichev, Matthew Rocklin, AMiT Kumar, Sergiu Ivanov, Jason K. Moore, Sartaj Singh, Thilina Rathnayake, Sean Vig, Brian E. Granger, Richard P. Muller, Francesco Bonazzi, Harsh Gupta, Shivam Vats, Fredrik Johansson, Fabian Pedregosa, Matthew J. Curry, Andy R. Terrel, Å tÄpÃ¡n RouÄka, Ashutosh Saboo, Isuru Fernando, Sumith Kulal, Robert Cimrman, and Anthony Scopatz. Sympy: symbolic computing in python. PeerJ Computer Science, 3:e103, January 2017. ISSN 2376-5992. doi: 10.7717/peerj-cs.103. URL https://doi.org/10.7717/peerj-cs. 103.</p>
<p>Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Andrei A Rusu, Joel Veness, Marc G Bellemare, Alex Graves, Martin Riedmiller, Andreas K Fidjeland, Georg Ostrovski, et al. Human-level control through deep reinforcement learning. Nature, 518(7540):529, 2015.</p>
<p>Aaron van den Oord, Sander Dieleman, Heiga Zen, Karen Simonyan, Oriol Vinyals, Alex Graves, Nal Kalchbrenner, Andrew Senior, and Koray Kavukcuoglu. Wavenet: A generative model for raw audio. arXiv preprint arXiv:1609.03499, 2016a.</p>
<p>Aaron van den Oord, Nal Kalchbrenner, and Koray Kavukcuoglu. Pixel recurrent neural networks. arXiv preprint arXiv:1601.06759, 2016b.</p>
<p>Aravind Rajeswaran, Sarvjeet Ghotra, Balaraman Ravindran, and Sergey Levine. Epopt: Learning robust neural network policies using model ensembles. arXiv preprint arXiv:1610.01283, 2016.</p>
<p>Prajit Ramachandran, Barret Zoph, and Quoc V Le. Searching for activation functions. arXiv preprint arXiv:1710.05941, 2017.</p>
<p>Sebastian Riedel, Matko Bosnjak, and Tim RocktÃ¤schel. Programming with a differentiable forth interpreter. CoRR, abs/1605.06640, 2016.</p>
<p>Subham S Sahoo, Christoph H Lampert, and Georg Martius. Learning equations for extrapolation and control. arXiv preprint arXiv:1806.07259, 2018.</p>
<p>Michael Schmidt and Hod Lipson. Distilling free-form natural laws from experimental data. science, 324(5923):81-85, 2009.</p>
<p>John Schulman, Filip Wolski, Prafulla Dhariwal, Alec Radford, and Oleg Klimov. Proximal policy optimization algorithms. arXiv preprint arXiv:1707.06347, 2017.</p>
<p>Aviv Tamar, Yonatan Glassner, and Shie Mannor. Policy gradients beyond expectations: Conditional value-at-risk. arXiv preprint arXiv:1404.3862, 2014.</p>
<p>Leonardo Trujillo, Luis MuÃ±oz, Edgar GalvÃ¡n-LÃ³pez, and Sara Silva. neat genetic programming: Controlling bloat naturally. Information Sciences, 333:21-43, 2016.</p>
<p>Silviu-Marian Udrescu and Max Tegmark. Ai feynman: A physics-inspired method for symbolic regression. Science Advances, 6(16):eaay2631, 2020.</p>
<p>Nguyen Quang Uy, Nguyen Xuan Hoai, Michael OâNeill, Robert I McKay, and Edgar GalvÃ¡nLÃ³pez. Semantically-based crossover in genetic programming: application to real-valued symbolic regression. Genetic Programming and Evolvable Machines, 12(2):91-119, 2011.</p>
<p>David R White, James Mcdermott, Mauro Castelli, Luca Manzoni, Brian W Goldman, Gabriel Kronberger, Wojciech JaÅkowski, Una-May OâReilly, and Sean Luke. Better gp benchmarks: community survey results and proposals. Genetic Programming and Evolvable Machines, 14(1): $3-29,2013$.</p>
<p>Ronald J Williams. Simple statistical gradient-following algorithms for connectionist reinforcement learning. Machine learning, 8(3-4):229-256, 1992.</p>
<p>Jiaxuan You, Rex Ying, Xiang Ren, William L Hamilton, and Jure Leskovec. Graphrnn: Generating realistic graphs with deep auto-regressive models. arXiv preprint arXiv:1802.08773, 2018.</p>
<p>Kaicheng Yu, Christian Sciuto, Martin Jaggi, Claudiu Musat, and Mathieu Salzmann. Evaluating the search phase of neural architecture search. arXiv preprint arXiv:1902.08142, 2019.</p>
<p>Barret Zoph and Quoc V Le. Neural architecture search with reinforcement learning. International Conference on Learning Representations, 2017.</p>
<h1>APPENDIX A PSEUDOCODE FOR ADDITIONAL ALGORITHMS AND SUBROUTINES</h1>
<p>Pseudocode for sampling an expression from the RNN. The sampling process in DSR (line 4 of Algorithm 1) is more complicated than typical autoregressive sampling procedures due to applying constraints in situ and providing hierarchical information to the RNN. Thus, we provide pseudocode for this process in Algorithm 2. Within this algorithm, the function $\operatorname{Arity}\left(\tau_{i}\right)$ simply returns the arity (number of arguments) of token $\tau_{i}$, i.e. two for binary operators, one for unary operators, or zero for input variables or constants.</p>
<div class="codehilite"><pre><span></span><code><span class="nx">Algorithm</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="nx">Sampling</span><span class="w"> </span><span class="nx">an</span><span class="w"> </span><span class="nx">expression</span><span class="w"> </span><span class="nx">from</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">RNN</span>
<span class="nx">input</span><span class="w"> </span><span class="nx">RNN</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="nx">parameters</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">theta</span><span class="err">\</span><span class="p">);</span><span class="w"> </span><span class="kn">library</span><span class="w"> </span><span class="nx">of</span><span class="w"> </span><span class="nx">tokens</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">mathcal</span><span class="p">{</span><span class="nx">L</span><span class="p">}</span><span class="err">\</span><span class="p">)</span>
<span class="nx">output</span><span class="w"> </span><span class="nx">Pre</span><span class="o">-</span><span class="nx">order</span><span class="w"> </span><span class="nx">traversal</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">tau</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">of</span><span class="w"> </span><span class="nx">an</span><span class="w"> </span><span class="nx">expression</span><span class="w"> </span><span class="nx">sampled</span><span class="w"> </span><span class="nx">from</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">RNN</span>
<span class="w">    </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">tau</span><span class="w"> </span><span class="err">\</span><span class="nx">leftarrow</span><span class="p">[]</span><span class="w"> </span><span class="err">\</span><span class="nx">quad</span><span class="w"> </span><span class="err">\</span><span class="nx">triangleright</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">Initialize</span><span class="w"> </span><span class="nx">empty</span><span class="w"> </span><span class="nx">traversal</span>
<span class="w">    </span><span class="nx">counter</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">leftarrow</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="err">\</span><span class="nx">quad</span><span class="w"> </span><span class="err">\</span><span class="nx">triangleright</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">Initialize</span><span class="w"> </span><span class="nx">counter</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">number</span><span class="w"> </span><span class="nx">of</span><span class="w"> </span><span class="nx">unselected</span><span class="w"> </span><span class="nx">nodes</span>
<span class="w">    </span><span class="err">\</span><span class="p">(</span><span class="nx">x</span><span class="w"> </span><span class="err">\</span><span class="nx">leftarrow</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">empty</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="o">|</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">empty</span>
<span class="w">    </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">triangleright</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">Initial</span><span class="w"> </span><span class="nx">RNN</span><span class="w"> </span><span class="nx">input</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="nx">empty</span><span class="w"> </span><span class="nx">parent</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="nx">sibling</span>
<span class="w">    </span><span class="err">\</span><span class="p">(</span><span class="nx">c_</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nx">leftarrow</span><span class="w"> </span><span class="err">\</span><span class="nx">stackrel</span><span class="p">{</span><span class="err">\</span><span class="nx">rightharpoonup</span><span class="p">}{</span><span class="mi">0</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nx">quad</span><span class="w"> </span><span class="err">\</span><span class="nx">triangleright</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">Initialize</span><span class="w"> </span><span class="nx">RNN</span><span class="w"> </span><span class="nx">cell</span><span class="w"> </span><span class="nx">state</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">zero</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="nx">i</span><span class="p">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="nx">ldots</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">do</span>
<span class="w">        </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">left</span><span class="p">(</span><span class="err">\</span><span class="nx">psi</span><span class="o">^</span><span class="p">{(</span><span class="nx">i</span><span class="p">)},</span><span class="w"> </span><span class="nx">c_</span><span class="p">{</span><span class="nx">i</span><span class="p">}</span><span class="err">\</span><span class="nx">right</span><span class="p">)</span><span class="w"> </span><span class="err">\</span><span class="nx">leftarrow</span><span class="w"> </span><span class="err">\</span><span class="nx">operatorname</span><span class="p">{</span><span class="nx">RNN</span><span class="p">}</span><span class="err">\</span><span class="nx">left</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">c_</span><span class="p">{</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="err">\</span><span class="nx">theta</span><span class="err">\</span><span class="nx">right</span><span class="p">)</span><span class="w"> </span><span class="err">\</span><span class="nx">quad</span><span class="w"> </span><span class="err">\</span><span class="nx">triangleright</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">Emit</span><span class="w"> </span><span class="nx">probabilities</span><span class="p">;</span><span class="w"> </span><span class="nx">update</span><span class="w"> </span><span class="nx">state</span>
<span class="w">        </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">psi</span><span class="o">^</span><span class="p">{(</span><span class="nx">i</span><span class="p">)}</span><span class="w"> </span><span class="err">\</span><span class="nx">leftarrow</span><span class="w"> </span><span class="err">\</span><span class="nx">operatorname</span><span class="p">{</span><span class="nx">ApplyConstraints</span><span class="p">}</span><span class="err">\</span><span class="nx">left</span><span class="p">(</span><span class="err">\</span><span class="nx">psi</span><span class="o">^</span><span class="p">{(</span><span class="nx">i</span><span class="p">)},</span><span class="w"> </span><span class="err">\</span><span class="nx">mathcal</span><span class="p">{</span><span class="nx">L</span><span class="p">},</span><span class="w"> </span><span class="err">\</span><span class="nx">tau</span><span class="err">\</span><span class="nx">right</span><span class="p">)</span><span class="w"> </span><span class="err">\</span><span class="nx">quad</span><span class="w"> </span><span class="err">\</span><span class="nx">triangleright</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">Adjust</span><span class="w"> </span><span class="nx">probabilities</span>
<span class="w">        </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">tau_</span><span class="p">{</span><span class="nx">i</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nx">leftarrow</span><span class="w"> </span><span class="err">\</span><span class="nx">operatorname</span><span class="p">{</span><span class="nx">Categorical</span><span class="p">}</span><span class="err">\</span><span class="nx">left</span><span class="p">(</span><span class="err">\</span><span class="nx">psi</span><span class="o">^</span><span class="p">{(</span><span class="nx">i</span><span class="p">)}</span><span class="err">\</span><span class="nx">right</span><span class="p">)</span><span class="w"> </span><span class="err">\</span><span class="nx">quad</span><span class="w"> </span><span class="err">\</span><span class="nx">triangleright</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">Sample</span><span class="w"> </span><span class="nx">next</span><span class="w"> </span><span class="nx">token</span>
<span class="w">        </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">tau</span><span class="w"> </span><span class="err">\</span><span class="nx">leftarrow</span><span class="w"> </span><span class="err">\</span><span class="nx">tau</span><span class="w"> </span><span class="err">\</span><span class="o">|</span><span class="w"> </span><span class="err">\</span><span class="nx">tau_</span><span class="p">{</span><span class="nx">i</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nx">quad</span><span class="w"> </span><span class="err">\</span><span class="nx">triangleright</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">Append</span><span class="w"> </span><span class="nx">token</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">traversal</span>
<span class="w">        </span><span class="nx">counter</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">leftarrow</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">counter</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="o">+</span><span class="err">\</span><span class="nx">operatorname</span><span class="p">{</span><span class="nx">Arity</span><span class="p">}</span><span class="err">\</span><span class="nx">left</span><span class="p">(</span><span class="err">\</span><span class="nx">tau_</span><span class="p">{</span><span class="nx">i</span><span class="p">}</span><span class="err">\</span><span class="nx">right</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="err">\</span><span class="nx">quad</span><span class="w"> </span><span class="err">\</span><span class="nx">triangleright</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">Update</span><span class="w"> </span><span class="nx">number</span><span class="w"> </span><span class="nx">of</span><span class="w"> </span><span class="nx">unselected</span><span class="w"> </span><span class="nx">nodes</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">counter</span><span class="w"> </span><span class="err">\</span><span class="p">(=</span><span class="mi">0</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">tau</span><span class="w"> </span><span class="err">\</span><span class="nx">quad</span><span class="w"> </span><span class="err">\</span><span class="nx">triangleright</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">If</span><span class="w"> </span><span class="nx">expression</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="nx">complete</span><span class="p">,</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">it</span>
<span class="w">        </span><span class="err">\</span><span class="p">(</span><span class="nx">x</span><span class="w"> </span><span class="err">\</span><span class="nx">leftarrow</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">ParentSibling</span><span class="w"> </span><span class="err">\</span><span class="p">((</span><span class="err">\</span><span class="nx">tau</span><span class="p">)</span><span class="w"> </span><span class="err">\</span><span class="nx">quad</span><span class="w"> </span><span class="err">\</span><span class="nx">triangleright</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">Compute</span><span class="w"> </span><span class="nx">next</span><span class="w"> </span><span class="nx">parent</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="nx">sibling</span>
</code></pre></div>

<p>Additional subroutines. DSR includes several subroutines used when sampling an expression from the RNN and during training. In Subroutine 1, we describe the function ParentSibling $(\tau)$ used in Algorithm 2, which computes the parent and sibling of the next token to be sampled. This subroutine uses the following logic. If the final node in the partial traversal is a unary or binary operator, then that node is the parent and there is no sibling. Otherwise, the subroutine iterates backward through the traversal until finding a node with an unselected child node. That node is the parent and the subsequent node is the sibling.</p>
<div class="codehilite"><pre><span></span><code>Subroutine 1 Computing parent and sibling inputs to the RNN
input Partially sampled traversal \(\tau\)
output Concatenated parent and sibling tokens of the next token to be sampled
    \(T \leftarrow|\tau| \quad \triangleright\) Length of partial traversal
    counter \(\leftarrow 0 \quad \triangleright\) Initialize counter for number of unselected nodes
    if \(\operatorname{Arity}\left(\tau_{T}\right)&gt;0\) then
        parent \(\leftarrow \tau_{T}\)
        sibling \(\leftarrow\) empty
        return parent \(\|\) sibling
    for \(i=T, \ldots, 1\) do \(\triangleright\) Iterate backward
        counter \(\leftarrow\) counter \(+\operatorname{Arity}\left(\tau_{i}\right)-1 \quad \triangleright\) Update number of unselected nodes
        if counter \(=0\) then
            parent \(\leftarrow \tau_{i}\)
            sibling \(\leftarrow \tau_{i+1}\)
            return parent \(\mid\) sibling
</code></pre></div>

<p>In Subroutine 2, we describe the function $\operatorname{ApplyConstraints}(\psi, \mathcal{L}, \tau)$ used in Algorithm 2, which zeros out the probabilities of tokens that would violate any given constraints. Within this subroutine, the user-specific function ViolatesConstraint $\left(\tau, \mathcal{L}_{i}\right)$ returns TRUE if adding the $i^{\text {th }}$ token of the library $\mathcal{L}$ to the partial traversal $\tau$ would violate any user-specified constraints, and FALSE otherwise.</p>
<p>In Subroutine 3, we describe the function OptimizeConstants $(\tau, R)$ used in Algorithm 1, which optimizes the placeholder constants $\xi$ of an expression with respect to the reward function using a</p>
<p>Subroutine 2 Applying generic constraints in situ when sampling from the RNN
input Categorical probabilities $\psi$; corresponding library of tokens $\mathcal{L}$; partially sampled traversal $\tau$
output Adjusted categorical probabilities $\psi$
1: $L \leftarrow|\mathcal{L}| \quad \triangleright$ Length of library
2: for $i=1, \ldots, L$ do
3: if $\operatorname{ViolatesConstraint}\left(\tau, \mathcal{L}<em i="i">{i}\right)$ then $\psi</em> \leftarrow 0 \quad \triangleright$ If the token would violate a constraint, set its probability to 0
4: $\psi \leftarrow \frac{\psi}{\sum_{i} \psi_{i}} \quad \triangleright$ Normalize probability vector back to 1
5: return $\psi$
black-box optimizer, e.g. BFGS. In Algorithm 1, this subroutine is abstracted away into the computation of the reward function; here, we explicitly consider the reward function $R(\tau ; \xi)$ as parameterized by the placeholder constants. Within this subroutine, the function ReplaceConstants $\left(\tau, \xi^{\star}\right)$ replaces the placeholder constants in the expression with the optimized constants $\xi^{\star}$.</p>
<p>Subroutine 3 Optimizing the constants of an expression (inner optimization loop)
input Expression $\tau$ with placeholder constants $\xi$; reward function $R$
output Expression $\tau^{\star}$ with optimized constants $\xi^{\star}$
1: $\xi^{\star} \leftarrow \arg \max _{\xi} R(\tau ; \xi) \quad \triangleright$ Maximize reward w.r.t. constants, e.g. with BFGS
2: $\tau^{\star} \leftarrow$ ReplaceConstants $\left(\tau, \xi^{\star}\right) \quad \triangleright$ Replace placeholder constants
3: return $\tau^{\star}$</p>
<h1>APPENDIX B PROOF OF POLICY GRADIENT FOR RISK-SEEKING OBJECTIVE (PROPOSITION 1)</h1>
<p>Tamar et al. (2014) proved the following result for the policy gradient of the $\varepsilon$-conditional value at risk objective, $J_{\mathrm{CVaR}}(\theta)$ :</p>
<p>$$
\begin{aligned}
\nabla_{\theta} J_{\mathrm{CVaR}}(\theta) &amp; \doteq \nabla_{\theta} \mathbb{E}<em _varepsilon="\varepsilon">{\tau \sim p(\tau \mid \theta)}\left[R(\tau) \mid R(\tau) \leq R</em>(\theta)\right] \
&amp; =\mathbb{E}<em _varepsilon="\varepsilon">{\tau \sim p(\tau \mid \theta)}\left[\left(R(\tau)-R</em>(\theta)\right]
\end{aligned}
$$}(\theta)\right) \nabla_{\theta} \log p(\tau \mid \theta) \mid R(\tau) \leq R_{\varepsilon</p>
<p>For completeness, we adapt this proof from the CVaR objective to our risk-seeking objective given in (1). We emphasize that the proof closely follows Tamar et al. (2014). The difference amounts to defining the threshold $R_{\varepsilon}$ as the top $\varepsilon$ quantile of rewards (instead of the bottom $\varepsilon$ quantile), and replacing $R(\tau) \leq R_{\varepsilon}$ in the CVaR objective with $R(\tau) \geq R_{\varepsilon}$ in our objective. This difference results in the limits of integration swapping, causing an additional minus sign that eventually cancels out. Important differences from the proof in Tamar et al. (2014) are colored in red. As in Tamar et al. (2014), we first demonstrate the policy gradient in the single variable case, then extend to the multivariable case in the reinforcement learning setting. The assumptions follow Assumptions 1 - 7 detailed in Tamar et al. (2014).</p>
<p>Proof. Consider a bounded random variable $Z \in[-b, b]$ generated from a parameterized distribution $p(Z \mid \theta)$. The $(1-\varepsilon)$ quantile of $Z$ is:</p>
<p>$$
Q_{1-\varepsilon}(Z ; \theta)=\inf {z: \operatorname{CDF}(z) \geq 1-\varepsilon}
$$</p>
<p>where $\operatorname{CDF}(z)$ is the cumulative distribution function corresponding to $p(Z \mid \theta)$. We define the risk-seeking objective $J_{\text {risk }}(\theta ; \varepsilon)$ as the expectation of the $\varepsilon$ fraction of the best outcomes of $Z$ :</p>
<p>$$
J_{\text {risk }}(\theta ; \varepsilon) \doteq \mathbb{E}<em 1-_varepsilon="1-\varepsilon">{Z \sim p(Z \mid \theta)}\left[Z \mid Z \geq Q</em>(Z ; \theta)\right]
$$</p>
<p>We define $D_{\theta}$ as the set of all values of $z$ above this quantile:</p>
<p>$$
D_{\theta}=\left{z \in[-b, b]: z \geq Q_{1-\varepsilon}(Z ; \theta)\right}
$$</p>
<p>By construction, $D_{\theta}$ is simply the interval $\left[Q_{1-\varepsilon}(Z ; \theta), b\right]$, and</p>
<p>$$
\int_{z \in D_{\theta}} p(z \mid \theta) d z=\varepsilon
$$</p>
<p>Rewriting the conditional expectation in Equation (2) as an integral,</p>
<p>$$
\begin{aligned}
J_{\text {risk }}(\theta ; \varepsilon) &amp; =\frac{1}{\int_{z \in D_{\theta}} p(z \mid \theta) d z} \int_{z \in D_{\theta}} p(z \mid \theta) z d z \
&amp; =\frac{1}{\varepsilon} \int_{z \in D_{\theta}} p(z \mid \theta) z d z \
&amp; =\frac{1}{\varepsilon} \int_{Q_{1-\varepsilon}(Z ; \theta)}^{b} p(z \mid \theta) z d z
\end{aligned}
$$</p>
<p>We now compute the gradient of $J_{\text {risk }}(\theta ; \varepsilon)$ with respect to $\theta$. In the standard policy gradient derivation, the gradient can be swapped with the integral. In this case, the domain of integration depends on $\theta$, thus requiring the Leibniz rule:</p>
<p>$$
\begin{aligned}
\nabla_{\theta} J_{\text {risk }}(\theta ; \varepsilon) &amp; =\nabla_{\theta} \frac{1}{\varepsilon} \int_{Q_{1-\varepsilon}(Z ; \theta)}^{b} p(z \mid \theta) z d z \
&amp; =\frac{1}{\varepsilon} \int_{Q_{1-\varepsilon}(Z ; \theta)}^{b} \nabla_{\theta} p(z \mid \theta) z d z-\frac{1}{\varepsilon} p\left(Q_{1-\varepsilon}(Z ; \theta) \mid \theta\right) Q_{1-\varepsilon}(Z ; \theta) \nabla_{\theta} Q_{1-\varepsilon}(Z ; \theta)
\end{aligned}
$$</p>
<p>We similarly take the gradient of Equation (3):</p>
<p>$$
\begin{aligned}
0 &amp; =\nabla_{\theta} \int_{z \in D_{\theta}} p(z \mid \theta) d z \
&amp; =\nabla_{\theta} \int_{Q_{1-\varepsilon}(Z ; \theta)}^{b} p(z \mid \theta) d z \
&amp; =\int_{Q_{1-\varepsilon}(Z ; \theta)}^{b} \nabla_{\theta} p(z \mid \theta) d z-p\left(Q_{1-\varepsilon}(Z ; \theta) \mid \theta\right) \nabla_{\theta} Q_{1-\varepsilon}(Z ; \theta)
\end{aligned}
$$</p>
<p>Plugging Equation (5) into Equation (4) and rearranging yields</p>
<p>$$
\nabla_{\theta} J_{\text {risk }}(\theta ; \varepsilon)=\frac{1}{\varepsilon} \int_{Q_{1-\varepsilon}(Z ; \theta)}^{b} \nabla_{\theta} p(z \mid \theta)\left(z-Q_{1-\varepsilon}(Z ; \theta)\right) d z
$$</p>
<p>Using the "log-derivative trick" (multiplying by $p(Z \mid \theta) / p(Z \mid \theta)$ and using the derivative of a logarithm) and the definition of conditional expectation yields the final result:</p>
<p>$$
\begin{aligned}
\nabla_{\theta} J_{\text {risk }}(\theta ; \varepsilon) &amp; =\frac{1}{\varepsilon} \int_{Q_{1-\varepsilon}(Z ; \theta)}^{b}\left(z-Q_{1-\varepsilon}(Z ; \theta)\right) p(z \mid \theta) \nabla_{\theta} \log p(z \mid \theta) d z \
&amp; =\mathbb{E}<em 1-_varepsilon="1-\varepsilon">{Z \sim p(Z \mid \theta)}\left[\left(Z-Q</em>(Z ; \theta)\right]
\end{aligned}
$$}(Z ; \theta)\right) \nabla_{\theta} \log p(Z \mid \theta) \mid Z \geq Q_{1-\varepsilon</p>
<p>The extension to the case in which $Z$ is replaced by a scalar reward function $R(\tau)$, where $\tau$ is generated from a parameterized distribution $p(\tau \mid \theta)$, follows the proof in Tamar et al. (2014) without additional adaptation. Thus,</p>
<p>$$
\nabla_{\theta} J_{\text {risk }}(\theta ; \varepsilon)=\mathbb{E}<em _varepsilon="\varepsilon">{\tau \sim p(\tau \mid \theta)}\left[\left(R(\tau)-R</em>(\theta)\right]
$$}(\theta)\right) \nabla_{\theta} \log p(\tau \mid \theta) \mid R(\tau) \geq R_{\varepsilon</p>
<p>where $R_{\varepsilon}(\theta)$ is the $(1-\varepsilon)$-quantile of the distribution of rewards under the current policy.</p>
<h1>APPENDIX C DESCRIPTIONS OF BASELINE ALGORITHMS</h1>
<p>Priority queue training. The PQT baseline was implemented using our DSR framework (including in situ constraints, hierarchical RNN inputs, and constant optimization), but replacing the risk-seeking policy gradient objective with the priority queue training objective proposed in Abolafia et al. (2018). PQT works by maintaining a priority queue, defined by the top $k$ highest reward samples ever encountered during training, which is updated each training step. They then define their training objective as the average log-likelihood of the samples in the priority queue:</p>
<p>$$
J_{\mathrm{PQT}}(\theta ; k) \doteq \frac{1}{k} \sum_{i=1}^{k} \log p\left(\tau^{[i]} \mid \theta\right)
$$</p>
<p>where $k$ is a hyperparameter controlling the size of the priority queue, and $\tau^{[i]}$ is the $i^{\text {th }}$ member of the priority queue, i.e. the $i^{\text {th }}$ best expression encountered during training. Unlike $J_{\text {std }}(\theta)$ and $J_{\text {risk }}(\theta ; \varepsilon)$, the terms in $J_{\text {PQT }}(\theta ; k)$ are not scaled by rewards.</p>
<p>As discussed in Abolafia et al. (2018), the PQT objective can be combined with a policy gradient objective; however, the authors did not find this to improve results relative to PQT only. For this reason, and to avoid additional hyperparameters, our PQT baseline does not include a policy gradient term.</p>
<p>Vanilla policy gradient. The VPG baseline was implemented using our DSR framework (including in situ constraints, hierarchical RNN inputs, and constant optimization), but replacing the risk-seeking policy gradient objective, $J_{\text {risk }}(\theta ; \varepsilon)$, with the standard policy gradient objective, $J_{\text {std }}(\theta)$. In addition, as is common for standard policy gradients, we subtract a baseline from the reward function. As in Zoph \&amp; Le (2017), our baseline is an exponentially-weighted moving average (EWMA) of rewards. This introduces a VPG-specific hyperparameter $\beta$, controlling the degree of weighting decrease. Note that VPG is essentially an ablation of the risk-seeking policy gradient in DSR. However, as it is the critical ablation, we independently tune hyperparameters for the VPG baseline, in contrast to the "No risk" ablation in Figure 3.</p>
<p>Genetic programming. GP-based symbolic regression was implemented using the open-source software package "deap" (Fortin et al., 2012). The initial population of expressions is generated using the "full" method (Koza, 1992) with depth randomly selected between $d_{\min }$ and $d_{\max }$. The selection operator is defined by deterministic tournament selection, in which the expression with the best fitness among $k$ randomly selected expressions is chosen. The crossover operator is defined by swapping random subtrees between two expressions. The point mutation operator is defined by replacing a random subtree with a new subtree initialized using the "full" method with depth randomly selected between $d_{\min }$ and $d_{\max }$.</p>
<p>Constraints were implemented in GP in a post hoc manner. Each time a new expression is generated via mutation or crossover, all constraints are checked. If any constraints are violated, the new expression is rejected and the evolutionary operation is simply reverted (Fortin et al., 2012; Craenen et al., 2001). Like the in situ constraints used in DSR, this process reduces the search space; however, unlike in situ constraints, this rejection-based process introduces a tradeoff between search space and sample diversity. Thus, we performed all GP hyperparameter grid search both with and without post hoc constraints (using the same constraints as DSR and the RNN-based baselines). Using the best hyperparameters found for each mode, we repeated the full recovery rate experiments on the Nguyen benchmarks, and ultimately selected the best performing mode. We found that constraints actually hindered performance: GP recovery rate with constraints fell from $60.1 \%$ (in Table 1) to $32.3 \%$ across the Nguyen benchmarks. Thus, GP results herein do not include constraints other than constraining the maximum length to 30 (to prevent excessively long expressions with a low chance of recovery) and the maximum number of constants to 3 (otherwise, runs using constant optimization can become prohibitively expensive) as in DSR.</p>
<p>Eureqa. Considered to be the gold standard for symbolic regression (Udrescu \&amp; Tegmark, 2020), Eureqa is based on the GP-based approach proposed by Schmidt \&amp; Lipson (2009). Eureqa experiments were run using the DataRobot platform (www.datarobot.com). Eureqa allows the user to select which tokens to include, and thus experiments used the same library as DSR, as specified by Table 2 in Appendix D. While the number of expression evaluations is not tunable or made transparent to the user, Eureqa allows the user to select among several runtime modes. For all experiments, we used the longest-running mode, Long Running Search (10,000 Generations). After training, Eureqa outputs the best found expression based on mean-square error (MSE), as well as the Pareto front (using a proprietary complexity measure). For noise experiments, to mimic the other baselines, we checked for exact symbolic equivalence for all solutions along the Pareto front.</p>
<p>Wolfram. Wolfram results were obtained using the Mathematica built-in function FindFormula, which combines Markov chain Monte Carlo sampling methods with nonlinear regression (Fortuna, 2015). The function allows the user to specify the set of tokens to include. However, subtraction and division operators are not allowed. The use of real-valued constants is an integral part of the method and cannot be deactivated. Therefore, the Wolfram experiments used a slightly different library than the other algorithms. Specifically, we used ${+, \times$, pow, $\sin , \cos , \exp , \log , x}$, where pow $(a, b) \doteq a^{b}$.</p>
<p>Note that $a-b$ can be obtained via $a+(-1.0) \times b$ and $a \div b$ can be obtained via $a \times \operatorname{pow}(b,-1.0)$ ); thus, all benchmarks can still be recovered using this modified library.</p>
<p>Notable exclusions. The baselines selected for this work are suitable for searching the space of tractable mathematical expressions to discover exact symbolic expressions, and can accommodate numerical constants within expressions. There are several well-known algorithms that do not exhibit these features, and thus we do not include as baselines:</p>
<ul>
<li>Geometric-semantic genetic programming (GSGP): Originally proposed by Moraglio et al. (2012), GSGP is a GP-based approach that directly searches the space of the semantics of a program. They do this by constructing geometric semantic operators, which promote a strict increase in fitness per generation. However, this desirable feature comes with the cost of the size of the expressions growing exponentially. The resulting expressions are routinely on the order of trillions of nodes (Pawlak, 2016). This essentially forfeits the ability to exactly recover expressions, and severely limits the usefulness of the technique for interpretability-the primary motivation for symbolic regression.</li>
<li>Equation learner (EQL ${ }^{\circledR}$ ): As discussed in Related Work, Sahoo et al. (2018) perform symbolic regression via neural networks whose activation functions are elementary operators. However, the approach precludes the ability to recovery many simple classes of expressions, such as those involving exponent, logarithm, roots, or division within unary operators. Further, the resulting expressions can be very long, including real-valued shifts and scaled for each operator.</li>
<li>AI Feynman (AIF): As discussed in Related Work, Udrescu \&amp; Tegmark (2020) develop a tool to recursively simplify symbolic regression problems into smaller sub-problems; solving each sub-problem then requires an inner search algorithm. The authors demonstrate that many physics equations can be reduced to sub-problems that are solvable using a simple inner search algorithm, e.g. polynomial fit or small brute-force search. However, more challenging sub-problems-including many of the benchmark expressions in this work (namely, those with numerical constants, or those which are non-separable)-still require an underlying symbolic regression method to conduct the discrete search. Thus, AIF can be used during pre-processing as a problem-simplification step, then combined with any symbolic regression algorithm. Here, DSR and the baselines tested focus on the underlying discrete search problem, e.g. after any problem simplification steps have been applied.</li>
</ul>
<h1>APPENDIX D ADDITIONAL EXPERIMENT DETAILS</h1>
<p>Detailed description of the symbolic regression benchmarks. Details of the benchmark symbolic regression problems are shown in Table 2. Note that benchmarks without the "const" token in the library do note use a constant optimizer (line 4 in Algorithm 1, detailed in 3 in Appendix A). Benchmarks without real-valued constants can be recovered exactly (except Neat-6, discussed in Appendix E), thus recovery is defined by exact symbolic equivalence. Note that the square root and power operators are not part of the function set; however, such benchmarks can still be recovered with the given function set, e.g. Nguyen-8 can still be recovered via $\exp \left(\frac{x}{x+x} \log (x)\right)$ and Nguyen-11 can still be recovered via $\exp (y \log (x))$.</p>
<p>While all algorithms always produce syntactically valid expressions, they do not always produce semantically meaningful expressions. For example, the expression $\log (x)$ is not semantically meaningful for non-positive values of $x$. Thus, for all non-commercial algorithms, any expression that produces an overflow or other floating-point error on the input domain is deemed "invalid" and receives a reward of 0 , which corresponds to infinite error. Eureqa and Wolfram follow their own strategy to deal with this issue.</p>
<p>Hyperparameter selection. Hyperparameters were tuned by performing grid search on benchmarks Nguyen-7 and Nguyen-10. For each hyperparameter combination, we performed 10 independent training runs of the algorithm for 1 M total expression evaluations. We selected the hyperparameter combination with the highest average recovery rate, with ties broken by lowest average NRMSE. For all algorithms, the best found hyperparameters were used for all experiments and all benchmark expressions.</p>
<p>Table 2: Benchmark symbolic regression problem specifications. Input variables are denoted by $x$ and/or $y$. $\mathrm{U}(a, b, c)$ denotes $c$ random points uniformly sampled between $a$ and $b$ for each input variable; training and test datasets use different random seeds. $\mathrm{E}(a, b, c)$ denotes $c$ points evenly spaced between $a$ and $b$ for each input variable; training and test datasets use the same points (except Neat-6, which uses $\mathrm{E}(1,120,120)$ as test data, and the Jin tests, which use $\mathrm{U}(-3,3,30)$ as test data). To simplify notation, libraries are defined relative to a "base" library $\mathcal{L}_{0}={+,-, \times, \div, \sin , \cos , \exp , \log , x}$. Placeholder operands are denoted by $<em>$, e.g. $</em>^{2}$ corresponds to the square operator.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Name</th>
<th style="text-align: center;">Expression</th>
<th style="text-align: center;">Dataset</th>
<th style="text-align: center;">Library</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Nguyen-1</td>
<td style="text-align: center;">$x^{3}+x^{2}+x$</td>
<td style="text-align: center;">$\mathrm{U}(-1,1,20)$</td>
<td style="text-align: center;">$\mathcal{L}_{0}$</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-2</td>
<td style="text-align: center;">$x^{3}+x^{3}+x^{2}+x$</td>
<td style="text-align: center;">$\mathrm{U}(-1,1,20)$</td>
<td style="text-align: center;">$\mathcal{L}_{0}$</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-3</td>
<td style="text-align: center;">$x^{5}+x^{4}+x^{3}+x^{2}+x$</td>
<td style="text-align: center;">$\mathrm{U}(-1,1,20)$</td>
<td style="text-align: center;">$\mathcal{L}_{0}$</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-4</td>
<td style="text-align: center;">$x^{6}+x^{5}+x^{4}+x^{3}+x^{2}+x$</td>
<td style="text-align: center;">$\mathrm{U}(-1,1,20)$</td>
<td style="text-align: center;">$\mathcal{L}_{0}$</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-5</td>
<td style="text-align: center;">$\sin \left(x^{2}\right) \cos (x)-1$</td>
<td style="text-align: center;">$\mathrm{U}(-1,1,20)$</td>
<td style="text-align: center;">$\mathcal{L}_{0}$</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-6</td>
<td style="text-align: center;">$\sin (x)+\sin \left(x+x^{2}\right)$</td>
<td style="text-align: center;">$\mathrm{U}(-1,1,20)$</td>
<td style="text-align: center;">$\mathcal{L}_{0}$</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-7</td>
<td style="text-align: center;">$\log (x+1)+\log \left(x^{2}+1\right)$</td>
<td style="text-align: center;">$\mathrm{U}(0,2,20)$</td>
<td style="text-align: center;">$\mathcal{L}_{0}$</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-8</td>
<td style="text-align: center;">$\sqrt{x}$</td>
<td style="text-align: center;">$\mathrm{U}(0,4,20)$</td>
<td style="text-align: center;">$\mathcal{L}_{0}$</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-9</td>
<td style="text-align: center;">$\sin (x)+\sin \left(y^{2}\right)$</td>
<td style="text-align: center;">$\mathrm{U}(0,1,20)$</td>
<td style="text-align: center;">$\mathcal{L}_{0} \cup{y}$</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-10</td>
<td style="text-align: center;">$2 \sin (x) \cos (y)$</td>
<td style="text-align: center;">$\mathrm{U}(0,1,20)$</td>
<td style="text-align: center;">$\mathcal{L}_{0} \cup{y}$</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-11</td>
<td style="text-align: center;">$x^{y}$</td>
<td style="text-align: center;">$\mathrm{U}(0,1,20)$</td>
<td style="text-align: center;">$\mathcal{L}_{0} \cup{y}$</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-12</td>
<td style="text-align: center;">$x^{4}-x^{3}+\frac{1}{3} y^{2}-y$</td>
<td style="text-align: center;">$\mathrm{U}(0,1,20)$</td>
<td style="text-align: center;">$\mathcal{L}_{0} \cup{y}$</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-2</td>
<td style="text-align: center;">$4 x^{4}+3 x^{3}+2 x^{2}+x$</td>
<td style="text-align: center;">$\mathrm{U}(-1,1,20)$</td>
<td style="text-align: center;">$\mathcal{L}_{0}$</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-5</td>
<td style="text-align: center;">$\sin \left(x^{2}\right) \cos (x)-2$</td>
<td style="text-align: center;">$\mathrm{U}(-1,1,20)$</td>
<td style="text-align: center;">$\mathcal{L}_{0}$</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-8</td>
<td style="text-align: center;">$\frac{\sqrt[3]{x}}{\sqrt[3]{x^{2}}}$</td>
<td style="text-align: center;">$\mathrm{U}(0,4,20)$</td>
<td style="text-align: center;">$\mathcal{L}_{0}$</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-8"</td>
<td style="text-align: center;">$\sqrt[3]{x^{2}}$</td>
<td style="text-align: center;">$\mathrm{U}(0,4,20)$</td>
<td style="text-align: center;">$\mathcal{L}_{0}$</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-1</td>
<td style="text-align: center;">$3.39 x^{3}+2.12 x^{2}+1.78 x$</td>
<td style="text-align: center;">$\mathrm{U}(-1,1,20)$</td>
<td style="text-align: center;">$\mathcal{L}_{0} \cup{$ const $}$</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-5</td>
<td style="text-align: center;">$\sin \left(x^{2}\right) \cos (x)-0.75$</td>
<td style="text-align: center;">$\mathrm{U}(-1,1,20)$</td>
<td style="text-align: center;">$\mathcal{L}_{0} \cup{$ const $}$</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-7</td>
<td style="text-align: center;">$\log (x+1.4)+\log \left(x^{2}+1.3\right)$</td>
<td style="text-align: center;">$\mathrm{U}(0,2,20)$</td>
<td style="text-align: center;">$\mathcal{L}_{0} \cup{$ const $}$</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-8</td>
<td style="text-align: center;">$\sqrt{1.23 x}$</td>
<td style="text-align: center;">$\mathrm{U}(0,4,20)$</td>
<td style="text-align: center;">$\mathcal{L}_{0} \cup{$ const $}$</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-10</td>
<td style="text-align: center;">$\sin (1.5 x) \cos (0.5 y)$</td>
<td style="text-align: center;">$\mathrm{U}(0,1,20)$</td>
<td style="text-align: center;">$\mathcal{L}_{0} \cup{y$, const $}$</td>
</tr>
<tr>
<td style="text-align: center;">GrammarVAE-1</td>
<td style="text-align: center;">$\frac{1}{3}+x+\sin \left(x^{2}\right)$</td>
<td style="text-align: center;">$\mathrm{E}\left(-10,10,10^{2}\right)$</td>
<td style="text-align: center;">$\mathcal{L}_{0}-{-, \cos , \log } \cup{1,2,3}$</td>
</tr>
<tr>
<td style="text-align: center;">Jin-1</td>
<td style="text-align: center;">$2.5 x^{4}-1.3 x^{3}+0.5 y^{2}-1.7 y$</td>
<td style="text-align: center;">$\mathrm{U}(-3,3,100)$</td>
<td style="text-align: center;">$\mathcal{L}_{0}-{\log } \cup\left{<em>^{2}, </em>^{3}, y$, const $\right}$</td>
</tr>
<tr>
<td style="text-align: center;">Jin-2</td>
<td style="text-align: center;">$8.0 x^{2}+8.0 y^{3}-15.0$</td>
<td style="text-align: center;">$\mathrm{U}(-3,3,100)$</td>
<td style="text-align: center;">$\mathcal{L}_{0}-{\log } \cup\left{<em>^{2}, </em>^{3}, y$, const $\right}$</td>
</tr>
<tr>
<td style="text-align: center;">Jin-3</td>
<td style="text-align: center;">$0.2 x^{3}+0.5 y^{2}-1.2 y-0.5 x$</td>
<td style="text-align: center;">$\mathrm{U}(-3,3,100)$</td>
<td style="text-align: center;">$\mathcal{L}_{0}-{\log } \cup\left{<em>^{2}, </em>^{3}, y$, const $\right}$</td>
</tr>
<tr>
<td style="text-align: center;">Jin-4</td>
<td style="text-align: center;">$1.5 \exp (x)+5.0 \cos (y)$</td>
<td style="text-align: center;">$\mathrm{U}(-3,3,100)$</td>
<td style="text-align: center;">$\mathcal{L}_{0}-{\log } \cup\left{<em>^{2}, </em>^{3}, y$, const $\right}$</td>
</tr>
<tr>
<td style="text-align: center;">Jin-5</td>
<td style="text-align: center;">$6.0 \sin (x) \cos (y)$</td>
<td style="text-align: center;">$\mathrm{U}(-3,3,100)$</td>
<td style="text-align: center;">$\mathcal{L}_{0}-{\log } \cup\left{<em>^{2}, </em>^{3}, y$, const $\right}$</td>
</tr>
<tr>
<td style="text-align: center;">Jin-6</td>
<td style="text-align: center;">$1.35 x y+5.5 \sin ((x-1.0)(y-1.0))$</td>
<td style="text-align: center;">$\mathrm{U}(-3,3,100)$</td>
<td style="text-align: center;">$\mathcal{L}_{0}-{\log } \cup\left{<em>^{2}, </em>^{3}, y$, const $\right}$</td>
</tr>
<tr>
<td style="text-align: center;">Neat-1</td>
<td style="text-align: center;">$x^{4}+x^{3}+x^{2}+x$</td>
<td style="text-align: center;">$\mathrm{U}(-1,1,20)$</td>
<td style="text-align: center;">$\mathcal{L}_{0} \cup{1}$</td>
</tr>
<tr>
<td style="text-align: center;">Neat-2</td>
<td style="text-align: center;">$x^{5}+x^{4}+x^{3}+x^{2}+x$</td>
<td style="text-align: center;">$\mathrm{U}(-1,1,20)$</td>
<td style="text-align: center;">$\mathcal{L}_{0} \cup{1}$</td>
</tr>
<tr>
<td style="text-align: center;">Neat-3</td>
<td style="text-align: center;">$\sin \left(x^{2}\right) \cos (x)-1$</td>
<td style="text-align: center;">$\mathrm{U}(-1,1,20)$</td>
<td style="text-align: center;">$\mathcal{L}_{0} \cup{1}$</td>
</tr>
<tr>
<td style="text-align: center;">Neat-4</td>
<td style="text-align: center;">$\log (x+1)+\log \left(x^{2}+1\right)$</td>
<td style="text-align: center;">$\mathrm{U}(0,2,20)$</td>
<td style="text-align: center;">$\mathcal{L}_{0} \cup{1}$</td>
</tr>
<tr>
<td style="text-align: center;">Neat-5</td>
<td style="text-align: center;">$2 \sin (x) \cos (y)$</td>
<td style="text-align: center;">$\mathrm{U}(-1,1,100)$</td>
<td style="text-align: center;">$\mathcal{L}_{0} \cup{y}$</td>
</tr>
<tr>
<td style="text-align: center;">Neat-6</td>
<td style="text-align: center;">$\sum_{k=1}^{x} \frac{1}{k}$</td>
<td style="text-align: center;">$\mathrm{E}(1,50,50)$</td>
<td style="text-align: center;">$\left{+, \times, \div, <em>^{-1},-</em>, \sqrt{ }, x\right}$</td>
</tr>
<tr>
<td style="text-align: center;">Neat-7</td>
<td style="text-align: center;">$2-2.1 \cos (9.8 x) \sin (1.3 y)$</td>
<td style="text-align: center;">$\mathrm{E}\left(-50,50,10^{3}\right)$</td>
<td style="text-align: center;">$\mathcal{L}_{0} \cup{\tan , \tanh , <em>^{2}, </em>^{3}, \sqrt{ }, y}$</td>
</tr>
<tr>
<td style="text-align: center;">Neat-8</td>
<td style="text-align: center;">$\frac{e^{-(x-1)^{2}}}{1.2+(y-2.5)^{2}}$</td>
<td style="text-align: center;">$\mathrm{U}(0.3,4,100)$</td>
<td style="text-align: center;">$\left{+,-, \times, \div, \exp , e^{-<em>}, </em>^{2}, x, y\right}$</td>
</tr>
<tr>
<td style="text-align: center;">Neat-9</td>
<td style="text-align: center;">$\frac{1}{1+e^{-4}}+\frac{1}{1+y^{-2}}$</td>
<td style="text-align: center;">$\mathrm{E}(-5,5,21)$</td>
<td style="text-align: center;">$\mathcal{L}_{0} \cup{y}$</td>
</tr>
</tbody>
</table>
<p>Conveniently, the three RNN-based algorithms (DSR, PQT, and VPG) each have one unique hyperparameter: risk factor $\varepsilon$ for DSR, priority queue size $k$ for PQT, and EWMA coefficient $\beta$ for VPG. The remaining three hyperparameters considered (batch size, learning rate, and entropy weight) are present for each algorithm. For these three algorithms, the space of hyperparameters considered was batch size $\in{250,500,1000}$, learning rate $\in{0.0003,0.0005,0.001}$, and entropy weight $\lambda_{\mathrm{H}} \in{0.01,0.05,0.1}$. For the algorithm-specific hyperparameters, we considered risk factor $\varepsilon \in{0.05,0.10,0.15}$ for DSR, priority queue size $k \in{5,10,20}$ for PQT, and EWMA coefficient $\beta \in{0.1,0.25,0.5}$ for VPG. Thus, these algorithms each considered 81 hyperparameter combinations. The final tuned hyperparameters are listed in Table 3. (Note that hyperparameters were tuned independently for each algorithm; identical values across algorithms are incidental.)</p>
<p>For GP, the space of hyperparameters considered was population size $\in{100,250,500,1000}$, tournament size $\in{2,3,5,10}$, mutation probability $\in{0.01,0.03,0.05,0.10,0.15}$, crossover probability $\in{0.25,0.50,0.75,0.90,0.95}$, and post hoc constraints $\in{$ TRUE, FALSE $}$ (800 combinations). The final tuned hyperparameters are listed in Table 4.</p>
<p>As commercial software, Eureqa and Wolfram do not expose tunable hyperparameters. Wolfram allows the user to select among three "performance goal" modes (Error, Score, and Complexity)</p>
<p>and two "specificity goal" modes (Low and High). We tested all 6 combinations for 100 random seeds. Wolfram is not applicable to Nguyen-10, and we found that recovery rate for Nguyen-7 was $0 \%$ for all combinations; thus, the best combination of modalities was selected based on benchmarks Nguyen-5 and Nguyen-6 instead. The best results were obtained using Error for performance and High for specificity.</p>
<p>Table 3: Tuned hyperparameters for RNN-based algorithms.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter name</th>
<th style="text-align: center;">Symbol</th>
<th style="text-align: center;">DSR</th>
<th style="text-align: center;">PQT</th>
<th style="text-align: center;">VPG</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Batch size</td>
<td style="text-align: center;">$N$</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">1000</td>
</tr>
<tr>
<td style="text-align: center;">Learning rate</td>
<td style="text-align: center;">$\alpha$</td>
<td style="text-align: center;">0.0005</td>
<td style="text-align: center;">0.0005</td>
<td style="text-align: center;">0.0001</td>
</tr>
<tr>
<td style="text-align: center;">Entropy coefficient</td>
<td style="text-align: center;">$\lambda_{\mathcal{H}}$</td>
<td style="text-align: center;">0.005</td>
<td style="text-align: center;">0.005</td>
<td style="text-align: center;">0.005</td>
</tr>
<tr>
<td style="text-align: center;">Risk factor</td>
<td style="text-align: center;">$\varepsilon$</td>
<td style="text-align: center;">0.05</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">Priority queue size</td>
<td style="text-align: center;">$k$</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">EWMA coefficient</td>
<td style="text-align: center;">$\alpha$</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">0.25</td>
</tr>
</tbody>
</table>
<p>Table 4: Tuned hyperparameters for GP.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Parameter</th>
<th style="text-align: center;">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Population size</td>
<td style="text-align: center;">1,000</td>
</tr>
<tr>
<td style="text-align: center;">Fitness function</td>
<td style="text-align: center;">NRMSE</td>
</tr>
<tr>
<td style="text-align: center;">Initialization method</td>
<td style="text-align: center;">Full</td>
</tr>
<tr>
<td style="text-align: center;">Selection type</td>
<td style="text-align: center;">Tournament</td>
</tr>
<tr>
<td style="text-align: center;">Tournament size $(k)$</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: center;">Mutation probability</td>
<td style="text-align: center;">0.05</td>
</tr>
<tr>
<td style="text-align: center;">Crossover probability</td>
<td style="text-align: center;">0.95</td>
</tr>
<tr>
<td style="text-align: center;">Post hoc constraints</td>
<td style="text-align: center;">FALSE</td>
</tr>
<tr>
<td style="text-align: center;">Minimum subtree depth $\left(d_{\min }\right)$</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">Maximum subtree depth $\left(d_{\max }\right)$</td>
<td style="text-align: center;">2</td>
</tr>
</tbody>
</table>
<p>Additional details for constant optimization. The same constant optimizer was used for all noncommercial software algorithms: DSR, PQT, VPG, and GP. To optimize constants, the values for constant placeholder tokens are optimized against the reward (or fitness) function using BFGS with an initial guess of 1.0 for each constant. Before training, we ensured that all benchmarks with constants do not get stuck in a poor local optimum when optimizing with BFGS and the candidate functional form is correct. Since numerical constants can only be recovered up to floating-point precision, for benchmarks with constants we determined recovery by manually inspecting the functional form for symbolic correctness. Since constant optimization is a computational bottleneck, we limited each expression to three constants for all experiments with the "const" token, and ran experiments for 1M expression evaluations instead of 2M. Eureqa and Wolfram follow their own strategy to learn real-valued constants.</p>
<p>Additional details for ablation studies. In Figure 3, "No risk" denotes using the standard policy gradient (with baseline) instead of the risk-seeking policy gradient, equivalent to $\varepsilon=1$. Since the standard policy gradient typically includes a baseline term, we used an exponentially-weighted moving average (weight 0.5 ) of the average reward of the batch. The difference between this ablation and the VPG baseline is that VPG hyperparameters were tuned independently, whereas this ablation uses the DSR tuned hyperparameters. "No entropy" denotes no entropy bonus, equivalent to $\lambda_{\mathcal{H}}=0$. "No constraints" denotes no constraints precluding nested trigonometric operators, inverse unary operators, minimum length, or maximum length. Instead, if the maximum length of 30 tokens is reached, the expression is appended with $x$ until complete. "No risk/ent." denotes combining ablations for "No risk" and "No entropy." "No risk/con." denotes combining ablations for "No risk" and "No constraints." "No ent./con." denotes combining ablations for "No entropy" and "No constraints." "All ablations" denotes combining ablations for "No risk," "No entropy," and "No constraints."</p>
<p>Pareto front computation. Overfitting in symbolic regression occurs when an expression has added complexity to conform to noisy data. For example, high-degree polynomials can fit small datasets with low error, though generalization may be poor. While overfitting is not an issue for noiseless experiments (since the global optimal expression has zero error), it is indeed possible for expressions to overfit in the noisy data experiments, especially with small dataset sizes. Thus, for noisy data</p>
<p>experiments, we defined recovery as exact symbolic equivalence on any expression along the Pareto front (defined over the reward-complexity plane) at the end of training. To compute the Pareto front, we define a simple complexity measure $C$ :</p>
<p>$$
C(\tau)=\sum_{i}^{T} c\left(\tau_{i}\right)
$$</p>
<p>where $c$ is the complexity of a particular token. In accordance with Eureqa's default parameters, we used token complexities of 1 for,,$+- \times$, input variables, and constants; 2 for $\div ; 3$ for $\sin$ and $\cos$; and 4 for $\exp$ and $\log$.</p>
<p>Note that $C$ is only used to determine the Pareto front at the end of training; it does not affect training. This method of determining recovery based on the Pareto front was used for all algorithms, except that Eureqa uses a proprietary complexity measure.</p>
<p>Computing infrastructure. Experiments were executed on an Intel Xeon E5-2695 v4 equipped with NVIDIA Tesla P100 GPUs, with 32 cores per node, 2 GPUs per node, and 256 GB RAM per node.</p>
<h1>APPENDIX E COMPARISONS TO LITERATURE-REPORTED RESULTS</h1>
<p>Unfortunately, the majority of symbolic regression methods are inconsistent in their experimental setup, i.e. choice of library, benchmarks, and measure of performance. Often, benchmark expressions are hand-selected from several benchmark suites (Trujillo et al., 2016) or even hand-crafted for a particular study (Kusner et al., 2017; Sahoo et al., 2018). The criteria for determining "recovery" (also called "hit" or "success") is often defined by an arbitrary error threshold instead of exact symbolic equivalence (White et al., 2013). Further, different works use different performance metrics (e.g. RMSE, mean absolute error) that cannot be converted without access to raw data (Jin et al., 2019).
These issues make it difficult to compare methods via direct comparison of literature-reported results. To enable such comparisons, we mimic the experimental setup and measures of performance for several works. The alternative approach would be to evaluate these methods using our experimental setup and measures of performance; however, not all methods have available source code or sufficient implementation details for reproducibility. Below, we recapitulate the experiments of several additional works, and directly compare literature-reported results to our experiments using DSR. We note that even these comparisons are imperfect for for benchmarks with randomly sampled points, as the random number generator and seed used to generate the training and test data are typically not disclosed.</p>
<p>Semantics-based symbolic regression. Huynh et al. (2016) is an exceptional case in that they also report recovery as exact symbolic recovery, using an overlapping set of benchmarks: Nguyen-1 through Nguyen-10. In this work, the authors present Semantic-based Symbolic Regression (SSR), a GP-based approach that considers the semantics of each expression tree; for example, they remove duplicate trees with different tree structures but identical semantics, e.g. $((((x-1)+(x / x))-x)+y)$ is equivalent to $y$. In Table 5, we compare DSR's recovery to SSR's reported values. To replicate their experimental setup, we report DSR recovery rate for 30 independent training runs. DSR's average recovery rate is more than twice as high as SSR.</p>
<p>Table 5: Recovery rate comparison of DSR and literature-reported values from SSR (Huynh et al., 2016). A bold value represents statistical significance $\left(p&lt;10^{-3}\right)$ across all benchmarks.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Benchmark</th>
<th style="text-align: center;">Expression</th>
<th style="text-align: center;">DSR</th>
<th style="text-align: center;">SSR</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Nguyen-1</td>
<td style="text-align: center;">$x^{3}+x^{2}+x$</td>
<td style="text-align: center;">$100 \%$</td>
<td style="text-align: center;">$100 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Nguyen-2</td>
<td style="text-align: center;">$x^{4}+x^{3}+x^{2}+x$</td>
<td style="text-align: center;">$100 \%$</td>
<td style="text-align: center;">$10 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Nguyen-3</td>
<td style="text-align: center;">$x^{5}+x^{4}+x^{3}+x^{2}+x$</td>
<td style="text-align: center;">$100 \%$</td>
<td style="text-align: center;">$70 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Nguyen-4</td>
<td style="text-align: center;">$x^{6}+x^{5}+x^{4}+x^{3}+x^{2}+x$</td>
<td style="text-align: center;">$100 \%$</td>
<td style="text-align: center;">$30 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Nguyen-5</td>
<td style="text-align: center;">$\sin \left(x^{2}\right) \cos (x)-1$</td>
<td style="text-align: center;">$77 \%$</td>
<td style="text-align: center;">$10 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Nguyen-6</td>
<td style="text-align: center;">$\sin (x)+\sin \left(x+x^{2}\right)$</td>
<td style="text-align: center;">$100 \%$</td>
<td style="text-align: center;">$73 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Nguyen-7</td>
<td style="text-align: center;">$\log (x+1)+\log \left(x^{2}+1\right)$</td>
<td style="text-align: center;">$33 \%$</td>
<td style="text-align: center;">$3 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Nguyen-8</td>
<td style="text-align: center;">$\sqrt{x}$</td>
<td style="text-align: center;">$97 \%$</td>
<td style="text-align: center;">$3 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Nguyen-9</td>
<td style="text-align: center;">$\sin (x)+\sin \left(y^{2}\right)$</td>
<td style="text-align: center;">$100 \%$</td>
<td style="text-align: center;">$57 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Nguyen-10</td>
<td style="text-align: center;">$2 \sin (x) \cos (y)$</td>
<td style="text-align: center;">$100 \%$</td>
<td style="text-align: center;">$93 \%$</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;">Average</td>
<td style="text-align: center;">$\mathbf{9 0 . 7 \%}$</td>
<td style="text-align: center;">$45.0 \%$</td>
</tr>
</tbody>
</table>
<p>GrammarVAE. As mentioned in Related Work, Kusner et al. (2017) develop a generative model for discrete objects that adhere to a pre-specified grammar, then optimize them in latent space. To mimic their experimental setup, we run 10 independent trials using the performance metric $\log (1+\mathrm{MSE})$ and the GrammarVAE benchmark described in Table 2 Using the best solution found in each trial, DSR's average performance metric is $0.0105 \pm 0.0149$, whereas GrammarVAE's reported average is orders of magnitude larger: $3.47 \pm 0.24$. In Table 6, as in Kusner et al. (2017), we compare the top 3 expressions reported in GrammarVAE to the top 3 expressions found using DSR across all 10 trials. In addition to exactly recovering the expression, DSR's top 3 expressions are all superior to those found by GrammarVAE. Further, when repeating for 100 trials, we find that DSR exactly recovers the benchmark expression in 19\% of runs, whereas GrammarVAE never exactly recovers the ground truth expression.</p>
<p>Table 6: Comparison of DSR and literature-reported values from GrammarVAE (Kusner et al., 2017).</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Algorithm</th>
<th style="text-align: center;">Rank</th>
<th style="text-align: center;">Expression</th>
<th style="text-align: center;">$\log (1+\mathrm{MSE})$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">GrammarVAE</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">$\sin (3)+x+\sin \left(x^{2}\right)$</td>
<td style="text-align: center;">0.04</td>
</tr>
<tr>
<td style="text-align: center;">GrammarVAE</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">$\frac{1}{2}+x+\sin \left(x^{2}\right)$</td>
<td style="text-align: center;">0.10</td>
</tr>
<tr>
<td style="text-align: center;">GrammarVAE</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">$1+x+\sin \left(x^{2}\right)$</td>
<td style="text-align: center;">0.37</td>
</tr>
<tr>
<td style="text-align: center;">DSR</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">$\frac{1}{2}+x+\sin \left(x^{2}\right)$</td>
<td style="text-align: center;">$\mathbf{0}$</td>
</tr>
<tr>
<td style="text-align: center;">DSR</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">$\frac{\sin (1.5)}{2}+x+\sin \left(x^{2}\right)$</td>
<td style="text-align: center;">$\mathbf{7 . 0 \times 1 0 ^ { - 7 }}$</td>
</tr>
<tr>
<td style="text-align: center;">DSR</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">$\sin \left(\frac{1}{3}\right)+x+\sin \left(x^{2}\right)$</td>
<td style="text-align: center;">$\mathbf{3 . 8 \times 1 0 ^ { - 5 }}$</td>
</tr>
</tbody>
</table>
<p>Bayesian Symbolic Regression. In Jin et al. (2019), the authors propose Bayesian symbolic regression (BSR), a Bayesian framework for symbolic regression. In BSR, several carefully designed prior distributions are used to encode domain knowledge like preference of basis functions or tree structure. The resulting posterior distributions are efficiently sampled using Markov chain Monte Carlo techniques. To mimic their experiments, we run 50 independent trials using the performance metric RMSE and the Jin benchmarks described in Table 2 Table 7 shows the average RMSE on the test data for DSR and BSR across the benchmarks used in Jin et al. (2019). DSR outperforms BSR on all six benchmarks.</p>
<p>Table 7: RMSE comparison of DSR and literature-reported values from BSR (Jin et al., 2019).</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Benchmark</th>
<th style="text-align: center;">Expression</th>
<th style="text-align: center;">DSR</th>
<th style="text-align: center;">BSR</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Jin-1</td>
<td style="text-align: center;">$2.5 x^{4}-1.3 x^{3}+0.5 y^{2}-1.7 y$</td>
<td style="text-align: center;">$\mathbf{0 . 4 6} \pm \mathbf{0 . 4 1}$</td>
<td style="text-align: center;">$2.04 \pm 3.27$</td>
</tr>
<tr>
<td style="text-align: center;">Jin-2</td>
<td style="text-align: center;">$8.0 x^{3}+8.0 y^{3}-15.0$</td>
<td style="text-align: center;">$\mathbf{0} \pm \mathbf{0}$</td>
<td style="text-align: center;">$6.84 \pm 10.10$</td>
</tr>
<tr>
<td style="text-align: center;">Jin-3</td>
<td style="text-align: center;">$0.2 x^{3}+0.5 y^{3}-1.2 y-0.5 x$</td>
<td style="text-align: center;">$\mathbf{5 . 2} \times \mathbf{1 0}^{-\mathbf{4}} \pm \mathbf{3 . 5} \times \mathbf{1 0}^{-\mathbf{3}}$</td>
<td style="text-align: center;">$0.21 \pm 0.20$</td>
</tr>
<tr>
<td style="text-align: center;">Jin-4</td>
<td style="text-align: center;">$1.5 \exp (x)+5.0 \cos (y)$</td>
<td style="text-align: center;">$\mathbf{1 . 3 6} \times \mathbf{1 0}^{-\mathbf{4}} \pm \mathbf{8 . 9 1} \times \mathbf{1 0}^{-\mathbf{4}}$</td>
<td style="text-align: center;">$0.16 \pm 0.62$</td>
</tr>
<tr>
<td style="text-align: center;">Jin-5</td>
<td style="text-align: center;">$6.0 \sin (x) \cos (y)$</td>
<td style="text-align: center;">$\mathbf{0} \pm \mathbf{0}$</td>
<td style="text-align: center;">$0.66 \pm 1.13$</td>
</tr>
<tr>
<td style="text-align: center;">Jin-6</td>
<td style="text-align: center;">$1.35 x y+5.5 \sin ((x-1.0)(y-1.0))$</td>
<td style="text-align: center;">$\mathbf{2 . 2 3} \pm \mathbf{0 . 9 4}$</td>
<td style="text-align: center;">$4.63 \pm 0.62$</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Average</td>
<td style="text-align: center;">$\mathbf{0 . 4 5} \pm \mathbf{0 . 2 3}$</td>
<td style="text-align: center;">$2.42 \pm 2.66$</td>
</tr>
</tbody>
</table>
<p>Neat-GP. In Trujillo et al. (2016), the authors propose Neat-GP, a genetic programming approach that uses the NEAT (NeuroEvolution of Augmenting Topologies) algorithm to address the problem of uncontrolled program size growth in standard GP approaches. The authors report median values of RMSE on the test data for 30 independent trials using the Neat benchmark set described in Table 2 We replicate their experimental setup using DSR and compare to their reported values in Table 8 DSR outperforms Neat-GP on seven of the nine benchmarks.
The task in Neat-6 is to find closed-form approximations of the harmonic series $H_{n}=\sum_{k=1}^{n} \frac{1}{k}$. As an additional experiment, we repeated DSR on Neat-6 with ${\log , \operatorname{const}}$ added to $\mathcal{L}$. DSR discovered expressions which are remarkably accurate approximations of $H_{n}$ : when extrapolating to all $n \in \mathbb{N}$, the error of the best discovered expression is less than $0.000001 \%$. In particular, DSR discovered the expression:</p>
<p>$$
H_{n} \approx \gamma+\log (n)+\frac{1}{2 n+\frac{1}{11.3776} \frac{1}{n+15.725}+0.327981}
$$</p>
<p>where $\gamma \approx 0.57721$ is the Euler-Mascheroni constant. This is a variation of the formula $H_{n} \approx$ $\gamma+\log (n)+1 /(2 n)-1 /\left(12 n^{2}\right)$ found by Leonhard Euler in 1755 (Bromwich, 1908). Remarkably, the constant $\gamma$ naturally emerged in our recovered expression.</p>
<p>Table 8: Comparison of median values of RMSE for DSR and literature-reported values from Neat-GP (Trujillo et al., 2016).</p>
<table>
<thead>
<tr>
<th>Benchmark</th>
<th>Expression</th>
<th>DSR</th>
<th>Neat-GP</th>
</tr>
</thead>
<tbody>
<tr>
<td>Neat-1</td>
<td>$x^{4}+x^{3}+x^{2}+x$</td>
<td>$\mathbf{0}$</td>
<td>0.0779</td>
</tr>
<tr>
<td>Neat-2</td>
<td>$x^{5}+x^{4}+x^{3}+x^{2}+x$</td>
<td>$\mathbf{0}$</td>
<td>0.0576</td>
</tr>
<tr>
<td>Neat-3</td>
<td>$\sin \left(x^{2}\right) \cos (x)-1$</td>
<td>$\mathbf{0 . 0 0 4 1}$</td>
<td>0.0065</td>
</tr>
<tr>
<td>Neat-4</td>
<td>$\log (x+1)+\log \left(x^{2}+1\right)$</td>
<td>$\mathbf{0 . 0 1 8 9}$</td>
<td>0.0253</td>
</tr>
<tr>
<td>Neat-5</td>
<td>$2 \sin (x) \cos (y)$</td>
<td>$\mathbf{0}$</td>
<td>0.0023</td>
</tr>
<tr>
<td>Neat-6</td>
<td>$\sum_{k=1}^{x} \frac{1}{k}$</td>
<td>$\mathbf{0 . 2 3 7 8}$</td>
<td>0.2855</td>
</tr>
<tr>
<td>Neat-7</td>
<td>$2-2.1 \cos (9.8 x) \sin (1.3 y)$</td>
<td>1.0606</td>
<td>$\mathbf{1 . 0 5 4 1}$</td>
</tr>
<tr>
<td>Neat-8</td>
<td>$\frac{x^{-(x-1) 2}}{1.2+(y-2.5)^{2}}$</td>
<td>$\mathbf{0 . 1 0 7 6}$</td>
<td>0.1498</td>
</tr>
<tr>
<td>Neat-9</td>
<td>$\frac{1}{1+x^{-4}}+\frac{1}{1+y^{-4}}$</td>
<td>0.1511</td>
<td>$\mathbf{0 . 1 2 0 2}$</td>
</tr>
<tr>
<td></td>
<td>Average</td>
<td>$\mathbf{0 . 1 7 5 6}$</td>
<td>0.1977</td>
</tr>
</tbody>
</table>
<h1>APPENDIX F ADDITIONAL RESULTS ON NGUYEN BENCHMARKS</h1>
<p>Variations of Nguyen benchmarks. We introduce two sets of variations of the Nguyen benchmarks. In the first set, we alter existing benchmarks to make them more challenging. In the second set, we introduce real-valued constants and add the "const" token to the library to demonstrate the constant optimizer. We report recovery rate for DSR and all five baselines in Table 9. DSR significantly outperforms all baselines in the first set, and achieves $100 \%$ recover in the second set.</p>
<p>Table 9: Recovery rate comparison of DSR and five baselines on variations of the Nguyen symbolic regression benchmark suite. A bold value represents statistical significance ( $p&lt;10^{-3}$ ) across each set of benchmarks.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Benchmark</th>
<th style="text-align: center;">Expression</th>
<th style="text-align: center;">DSR</th>
<th style="text-align: center;">PQT</th>
<th style="text-align: center;">VPG</th>
<th style="text-align: center;">GP</th>
<th style="text-align: center;">Eureqa</th>
<th style="text-align: center;">Wolfram</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Nguyen-2 ${ }^{c}$</td>
<td style="text-align: center;">$4 x^{4}+3 x^{3}+2 x^{2}+x$</td>
<td style="text-align: center;">96\%</td>
<td style="text-align: center;">$92 \%$</td>
<td style="text-align: center;">0\%</td>
<td style="text-align: center;">$52 \%$</td>
<td style="text-align: center;">0\%</td>
<td style="text-align: center;">100\%</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-5 ${ }^{c}$</td>
<td style="text-align: center;">$\sin \left(x^{2}\right) \cos (x)-2$</td>
<td style="text-align: center;">87\%</td>
<td style="text-align: center;">$25 \%$</td>
<td style="text-align: center;">0\%</td>
<td style="text-align: center;">4\%</td>
<td style="text-align: center;">1\%</td>
<td style="text-align: center;">0\%</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-8 ${ }^{c}$</td>
<td style="text-align: center;">$\sqrt[3]{x}$</td>
<td style="text-align: center;">50\%</td>
<td style="text-align: center;">44\%</td>
<td style="text-align: center;">1\%</td>
<td style="text-align: center;">2\%</td>
<td style="text-align: center;">0\%</td>
<td style="text-align: center;">0\%</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-8 ${ }^{c}$</td>
<td style="text-align: center;">$\sqrt[3]{x^{2}}$</td>
<td style="text-align: center;">3\%</td>
<td style="text-align: center;">1\%</td>
<td style="text-align: center;">0\%</td>
<td style="text-align: center;">1\%</td>
<td style="text-align: center;">1\%</td>
<td style="text-align: center;">0\%</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Average</td>
<td style="text-align: center;">59.0\%</td>
<td style="text-align: center;">40.5\%</td>
<td style="text-align: center;">0.2\%</td>
<td style="text-align: center;">14.8\%</td>
<td style="text-align: center;">0.5\%</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-1 ${ }^{c}$</td>
<td style="text-align: center;">$3.39 x^{3}+2.12 x^{2}+1.78 x$</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">100\%</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-5 ${ }^{c}$</td>
<td style="text-align: center;">$\sin \left(x^{2}\right) \cos (x)-0.75$</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">70\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">1\%</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-7 ${ }^{c}$</td>
<td style="text-align: center;">$\log (x+1.4)+\log \left(x^{2}+1.3\right)$</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">90\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">0\%</td>
<td style="text-align: center;">0\%</td>
<td style="text-align: center;">0\%</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-8 ${ }^{c}$</td>
<td style="text-align: center;">$\sqrt{1.23 x}$</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">20\%</td>
<td style="text-align: center;">30\%</td>
<td style="text-align: center;">44\%</td>
</tr>
<tr>
<td style="text-align: center;">Nguyen-10 ${ }^{c}$</td>
<td style="text-align: center;">$\sin (1.5 x) \cos (0.5 y)$</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">100\%</td>
<td style="text-align: center;">40\%</td>
<td style="text-align: center;">0\%</td>
<td style="text-align: center;">10\%</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Average</td>
<td style="text-align: center;">100.0\%</td>
<td style="text-align: center;">98.0\%</td>
<td style="text-align: center;">88.0\%</td>
<td style="text-align: center;">38.0\%</td>
<td style="text-align: center;">48.0\%</td>
</tr>
</tbody>
</table>
<p>NRMSE comparisons. Tables 1 and 9 show recovery rates for all algorithms across all benchmarks. In Table 10, we show the analogous results for NRMSE on the test data. DSR outperforms all algorithms across each benchmark set, except Eureqa on the original Nguyen benchmark set. Here, Eureqa's lower average NRMSE is attributed to its low error for Nguyen-12. However, this is a result of not being able to constrain or limit the complexity of expressions produced by Eureqa. In particular, Eureqa routinely identified expressions of length $\sim 100$ for Nguyen-12, whereas all non-commercial baselines were limited to length 30 to ensure that expressions are tractable.
We also observe that for the few expressions with low or zero recovery rate (e.g. Nguyen-7 and Nguyen-12), GP sometimes exhibits lower NRMSE. One explanation is that GP is more prone to overfitting the expression to the dataset. As an evolutionary approach, GP directly modifies the previous generation's expressions, allowing it to make small "corrections" that decrease error each generation even if the functional form is far from correct. In contrast, in DSR the RNN "rewrites" each expression from scratch each iteration after learning from a gradient update, making it less prone to overfitting.</p>
<p>Training curves. Figures 6 and 7 show the reward $(1 /(1+\mathrm{NRMSE}))$ and recovery rate, respectively, as a function of total expressions evaluated during training. Commercial software algorithms (Eureqa</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{3}$ Sold by DataRobot, Inc. (www.datarobot.com) and formerly by Nutonian, Inc. (www.nutonian.com).
${ }^{4}$ Sold by Wolfram Research, Inc. as a part of Mathematica (www.wolfram.com/mathematica).&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>