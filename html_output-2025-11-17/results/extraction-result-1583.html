<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-1583 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-1583</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-1583</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-31.html">extraction-schema-31</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <p><strong>Paper ID:</strong> paper-9434841</p>
                <p><strong>Paper Title:</strong> <a href="https://arxiv.org/pdf/1304.2467v1.pdf" target="_blank">Evolutionary Design of Digital Circuits Using Genetic Programming</a></p>
                <p><strong>Paper Abstract:</strong> For simple digital circuits, conventional method of designing circuits can easily be applied. But for complex digital circuits, the conventional method of designing circuits is not fruitfully applicable because it is time-consuming. On the contrary, Genetic Programming is used mostly for automatic program generation. The modern approach for designing Arithmetic circuits, commonly digital circuits, is based on Graphs. This graph-based evolutionary design of arithmetic circuits is a method of optimized designing of arithmetic circuits. In this paper, a new technique for evolutionary design of digital circuits is proposed using Genetic Programming (GP) with Subtree Mutation in place of Graph-based design. The results obtained using this technique demonstrates the potential capability of genetic programming in digital circuit design with limited computer algorithms. The proposed technique, helps to simplify and speed up the process of designing digital circuits, discovers a variation in the field of digital circuit design where optimized digital circuits can be successfully and effectively designed.</p>
                <p><strong>Cost:</strong> 0.01</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e1583.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e1583.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>GP-Subtree-Mutation</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Genetic Programming with Subtree / Tree-structured Mutation for Digital Circuit Design</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A genetic programming system that evolves parse-tree representations of digital circuits using tournament selection and multiple tree-based mutation operators (including subtree mutation) and evaluates individuals by truth-table fitness to produce correct circuit implementations.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Genetic Programming (parse-tree) with Subtree and Tree Mutation</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>This system represents digital circuits as parse trees (functions = gates and functional elements; terminals = input signals). An initial population of randomly generated parse trees (limited depth and node count) is created. Parent selection is EP-style tournament selection (tournament size 10). Offspring are generated exclusively via tree/mutation operators (no crossover reported): six mutation operators are listed (OneNode, AllNodes, Swap, Grow, Trunc and an additional subtree mutation), and subtree mutation is emphasized for structural transformations. Fitness is computed by comparing the circuit's outputs to a provided truth table (per-input-combination correctness). A circuit verification algorithm marks a circuit as correct if measured output equals desired output for all input combinations. Control parameters reported include population size = 1000, max nodes = 50, initial depth = 10, mutation probability = 1.0, and gross number of generations = 1000.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs (parse-tree representations of digital circuits)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Multiple tree-based mutation operators applied to parse trees: specifically named operators include OneNode, AllNodes, Swap, Grow, Trunc, and Subtree mutation; subtree mutation replaces/re-wires subtrees, preserving input-output mapping constraints during construction; mutation probability set to 1.0 (i.e. always mutate offspring).</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Truth-table-based fitness: for each possible input combination the circuit's outputs are compared to the desired outputs; fitness (reported as error percentage) is the aggregate mis-match across tested combinations. A circuit is considered correct when measured outputs equal desired outputs for all input combinations (zero error).</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>Reported per-problem trials/generations in TABLE IV. Examples: 3-input 1-output: No. of trials=10, No. of generations=1; 4-input 1-output: trials=15, generations=1; 4-input 2-output: F1 trials=10 gen=1, F2 trials=50 gen=25; 5-input 1-output: trials=40 gen=1; 6-input 1-output: trials=50 gen=23; 7-input 1-output: trials=30 gen=60; 8-input 1-output: trials=30 gen=6; 9-input 1-output: trials=65 gen=40; 10-input 1-output: trials=60 gen=10. (Units: trials (independent runs) and generations until success as reported in TABLE IV).</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Digital circuit synthesis / program synthesis of logic circuits (combinational and sequential circuits; evaluated against provided truth tables)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Conventional/manual circuit design (descriptive comparison) and graph-based evolutionary design (cited), but no empirical baseline experiments comparing crossover-based GP vs this mutation-only GP are reported.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Mutation-only GP with subtree/tree mutations can discover correct digital-circuit parse trees matching truth-table specifications; fitness error decreases generation-by-generation until zero error (correct circuit) for a range of input sizes (3–10 inputs). The system uses mutation operators (subtree mutation emphasized) and EP-style tournament selection; crossover is not used. The paper reports successful synthesis across several example circuits and gives runs/generations required, but does not report formal measures of novelty, diversity, or behavioral/genotypic exploration.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1583.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e1583.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>KozaGP-analog</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Automated synthesis of analog electrical circuits by means of genetic programming (Koza et al.)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Cited foundational GP work where circuit topologies, component counts, and component values are evolved together using genetic programming to synthesize analog filters and other circuits.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Automated synthesis of analog electrical circuits by means of genetic programming</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Genetic Programming for Analog Circuit Synthesis (Koza et al.)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Cited as an example where GP evolves analog circuit topologies, component counts, and component values simultaneously. Included in the paper's related-work discussion as precedent for using GP in circuit synthesis.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs / circuit representations (analog circuit topologies and component parameters)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Generic GP mutation operators are referenced in the related-work discussion (the paper does not detail Koza's exact operators beyond the citation).</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Analog electrical circuit synthesis (cited as related work)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Mentioned as a prior successful application of GP to circuit synthesis where topology and component parameters are co-evolved; used as motivation for applying GP to digital circuits in the present paper. The present paper does not extract or report Koza's metrics for novelty, diversity, or executability.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1583.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e1583.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>No-Crossover-GP</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Evolving Computer Programs without Subtree Crossover (Chellapilla)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Cited work that studies GP variants that omit subtree crossover, i.e., relying on mutation-only genetic programming.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Evolving Computer Programs without Subtree Crossover</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Mutation-only Genetic Programming (as described by Chellapilla)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Referenced as related work on GP approaches that avoid subtree crossover and rely principally on mutation-based operators to evolve programs; included in the paper's literature review to contextualize the authors' mutation-focused approach.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs (computer programs / parse trees)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>explicitly omitted in the cited work (title indicates no subtree crossover), but the present paper provides no mechanistic details.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Mutation-driven program variation (details not provided in the citing paper).</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Program evolution / GP methodology (cited for methodological relevance)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Cited to support and contextualize the paper's mutation-centric GP design; no quantitative details about novelty/diversity/executability are reported in this paper regarding Chellapilla's results.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1583.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e1583.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Graph-Evo-Arithmetic</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Graph-Based Evolutionary Design of Arithmetic Circuits (Chen et al.)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A cited graph-based evolutionary design approach for arithmetic circuits (evolves graph representations rather than parse trees), used as a contrasting method in related work.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Graph-Based Evolutionary Design of Arithmetic Circuits</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Graph-based Evolutionary Design (arithmetic circuits)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Cited approach where circuits are represented as graphs and evolved (graph-level evolutionary operators) for arithmetic circuit design; mentioned as the 'modern approach' contrasted with the paper's parse-tree / subtree-mutation GP approach.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>graph representations of circuits (not parse-tree code)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Arithmetic/digital circuit synthesis (graph-based evolutionary methods)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Referenced as an alternative evolutionary representation and methodology for circuit design; the present paper positions subtree-mutation GP as a complementary/simple alternative but does not empirically compare metrics such as novelty or diversity against the graph-based approach.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Automated synthesis of analog electrical circuits by means of genetic programming <em>(Rating: 2)</em></li>
                <li>Graph-Based Evolutionary Design of Arithmetic Circuits <em>(Rating: 2)</em></li>
                <li>Evolving Computer Programs without Subtree Crossover <em>(Rating: 2)</em></li>
                <li>Designing electronic circuits using evolutionary algorithms, Arithmetic circuits: A case study <em>(Rating: 2)</em></li>
                <li>GPQUICK: A Simple Genetic Programming System in C++ <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-1583",
    "paper_id": "paper-9434841",
    "extraction_schema_id": "extraction-schema-31",
    "extracted_data": [
        {
            "name_short": "GP-Subtree-Mutation",
            "name_full": "Genetic Programming with Subtree / Tree-structured Mutation for Digital Circuit Design",
            "brief_description": "A genetic programming system that evolves parse-tree representations of digital circuits using tournament selection and multiple tree-based mutation operators (including subtree mutation) and evaluates individuals by truth-table fitness to produce correct circuit implementations.",
            "citation_title": "here",
            "mention_or_use": "use",
            "system_name": "Genetic Programming (parse-tree) with Subtree and Tree Mutation",
            "system_description": "This system represents digital circuits as parse trees (functions = gates and functional elements; terminals = input signals). An initial population of randomly generated parse trees (limited depth and node count) is created. Parent selection is EP-style tournament selection (tournament size 10). Offspring are generated exclusively via tree/mutation operators (no crossover reported): six mutation operators are listed (OneNode, AllNodes, Swap, Grow, Trunc and an additional subtree mutation), and subtree mutation is emphasized for structural transformations. Fitness is computed by comparing the circuit's outputs to a provided truth table (per-input-combination correctness). A circuit verification algorithm marks a circuit as correct if measured output equals desired output for all input combinations. Control parameters reported include population size = 1000, max nodes = 50, initial depth = 10, mutation probability = 1.0, and gross number of generations = 1000.",
            "input_type": "programs (parse-tree representations of digital circuits)",
            "crossover_operation": null,
            "mutation_operation": "Multiple tree-based mutation operators applied to parse trees: specifically named operators include OneNode, AllNodes, Swap, Grow, Trunc, and Subtree mutation; subtree mutation replaces/re-wires subtrees, preserving input-output mapping constraints during construction; mutation probability set to 1.0 (i.e. always mutate offspring).",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Truth-table-based fitness: for each possible input combination the circuit's outputs are compared to the desired outputs; fitness (reported as error percentage) is the aggregate mis-match across tested combinations. A circuit is considered correct when measured outputs equal desired outputs for all input combinations (zero error).",
            "executability_results": "Reported per-problem trials/generations in TABLE IV. Examples: 3-input 1-output: No. of trials=10, No. of generations=1; 4-input 1-output: trials=15, generations=1; 4-input 2-output: F1 trials=10 gen=1, F2 trials=50 gen=25; 5-input 1-output: trials=40 gen=1; 6-input 1-output: trials=50 gen=23; 7-input 1-output: trials=30 gen=60; 8-input 1-output: trials=30 gen=6; 9-input 1-output: trials=65 gen=40; 10-input 1-output: trials=60 gen=10. (Units: trials (independent runs) and generations until success as reported in TABLE IV).",
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Digital circuit synthesis / program synthesis of logic circuits (combinational and sequential circuits; evaluated against provided truth tables)",
            "comparison_baseline": "Conventional/manual circuit design (descriptive comparison) and graph-based evolutionary design (cited), but no empirical baseline experiments comparing crossover-based GP vs this mutation-only GP are reported.",
            "key_findings": "Mutation-only GP with subtree/tree mutations can discover correct digital-circuit parse trees matching truth-table specifications; fitness error decreases generation-by-generation until zero error (correct circuit) for a range of input sizes (3–10 inputs). The system uses mutation operators (subtree mutation emphasized) and EP-style tournament selection; crossover is not used. The paper reports successful synthesis across several example circuits and gives runs/generations required, but does not report formal measures of novelty, diversity, or behavioral/genotypic exploration.",
            "uuid": "e1583.0"
        },
        {
            "name_short": "KozaGP-analog",
            "name_full": "Automated synthesis of analog electrical circuits by means of genetic programming (Koza et al.)",
            "brief_description": "Cited foundational GP work where circuit topologies, component counts, and component values are evolved together using genetic programming to synthesize analog filters and other circuits.",
            "citation_title": "Automated synthesis of analog electrical circuits by means of genetic programming",
            "mention_or_use": "mention",
            "system_name": "Genetic Programming for Analog Circuit Synthesis (Koza et al.)",
            "system_description": "Cited as an example where GP evolves analog circuit topologies, component counts, and component values simultaneously. Included in the paper's related-work discussion as precedent for using GP in circuit synthesis.",
            "input_type": "programs / circuit representations (analog circuit topologies and component parameters)",
            "crossover_operation": null,
            "mutation_operation": "Generic GP mutation operators are referenced in the related-work discussion (the paper does not detail Koza's exact operators beyond the citation).",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Analog electrical circuit synthesis (cited as related work)",
            "comparison_baseline": "",
            "key_findings": "Mentioned as a prior successful application of GP to circuit synthesis where topology and component parameters are co-evolved; used as motivation for applying GP to digital circuits in the present paper. The present paper does not extract or report Koza's metrics for novelty, diversity, or executability.",
            "uuid": "e1583.1"
        },
        {
            "name_short": "No-Crossover-GP",
            "name_full": "Evolving Computer Programs without Subtree Crossover (Chellapilla)",
            "brief_description": "Cited work that studies GP variants that omit subtree crossover, i.e., relying on mutation-only genetic programming.",
            "citation_title": "Evolving Computer Programs without Subtree Crossover",
            "mention_or_use": "mention",
            "system_name": "Mutation-only Genetic Programming (as described by Chellapilla)",
            "system_description": "Referenced as related work on GP approaches that avoid subtree crossover and rely principally on mutation-based operators to evolve programs; included in the paper's literature review to contextualize the authors' mutation-focused approach.",
            "input_type": "programs (computer programs / parse trees)",
            "crossover_operation": "explicitly omitted in the cited work (title indicates no subtree crossover), but the present paper provides no mechanistic details.",
            "mutation_operation": "Mutation-driven program variation (details not provided in the citing paper).",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Program evolution / GP methodology (cited for methodological relevance)",
            "comparison_baseline": "",
            "key_findings": "Cited to support and contextualize the paper's mutation-centric GP design; no quantitative details about novelty/diversity/executability are reported in this paper regarding Chellapilla's results.",
            "uuid": "e1583.2"
        },
        {
            "name_short": "Graph-Evo-Arithmetic",
            "name_full": "Graph-Based Evolutionary Design of Arithmetic Circuits (Chen et al.)",
            "brief_description": "A cited graph-based evolutionary design approach for arithmetic circuits (evolves graph representations rather than parse trees), used as a contrasting method in related work.",
            "citation_title": "Graph-Based Evolutionary Design of Arithmetic Circuits",
            "mention_or_use": "mention",
            "system_name": "Graph-based Evolutionary Design (arithmetic circuits)",
            "system_description": "Cited approach where circuits are represented as graphs and evolved (graph-level evolutionary operators) for arithmetic circuit design; mentioned as the 'modern approach' contrasted with the paper's parse-tree / subtree-mutation GP approach.",
            "input_type": "graph representations of circuits (not parse-tree code)",
            "crossover_operation": null,
            "mutation_operation": null,
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Arithmetic/digital circuit synthesis (graph-based evolutionary methods)",
            "comparison_baseline": "",
            "key_findings": "Referenced as an alternative evolutionary representation and methodology for circuit design; the present paper positions subtree-mutation GP as a complementary/simple alternative but does not empirically compare metrics such as novelty or diversity against the graph-based approach.",
            "uuid": "e1583.3"
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Automated synthesis of analog electrical circuits by means of genetic programming",
            "rating": 2,
            "sanitized_title": "automated_synthesis_of_analog_electrical_circuits_by_means_of_genetic_programming"
        },
        {
            "paper_title": "Graph-Based Evolutionary Design of Arithmetic Circuits",
            "rating": 2,
            "sanitized_title": "graphbased_evolutionary_design_of_arithmetic_circuits"
        },
        {
            "paper_title": "Evolving Computer Programs without Subtree Crossover",
            "rating": 2,
            "sanitized_title": "evolving_computer_programs_without_subtree_crossover"
        },
        {
            "paper_title": "Designing electronic circuits using evolutionary algorithms, Arithmetic circuits: A case study",
            "rating": 2,
            "sanitized_title": "designing_electronic_circuits_using_evolutionary_algorithms_arithmetic_circuits_a_case_study"
        },
        {
            "paper_title": "GPQUICK: A Simple Genetic Programming System in C++",
            "rating": 1,
            "sanitized_title": "gpquick_a_simple_genetic_programming_system_in_c"
        }
    ],
    "cost": 0.00960725,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>Evolutionary Design of Digital Circuits Using Genetic Programming Evolutionary Design of Digital Circuits Using Genetic Programming</p>
<p>S M Ashik Eftakhar 
Department of Computer Science and Engineering
Department Department of Computer Science and Engineering
Khulna University of Engineering and Technology
Khulna-9203Bangladesh</p>
<p>Sk Mahbub Habib 
Department of Computer Science and Engineering
Department Department of Computer Science and Engineering
Khulna University of Engineering and Technology
Khulna-9203Bangladesh</p>
<p>M M A Hashem mma_hashem@hotmail.com 
Department of Computer Science and Engineering
Department Department of Computer Science and Engineering
Khulna University of Engineering and Technology
Khulna-9203Bangladesh</p>
<p>Prof. DrM M A Hashem 
Department of Computer Science and Engineering
Khulna University of Engineering and Technology
Khulna-9203Bangladesh</p>
<p>S M Ashik Eftakhar 
Khulna University of Engineering and Technology
Khulna-9203Bangladesh</p>
<p>Evolutionary Design of Digital Circuits Using Genetic Programming Evolutionary Design of Digital Circuits Using Genetic Programming
Category: Artificial Intelligence Contact Person: Presenter:Evolutionary AlgorithmDigital circuitsParse-TreeAutomatic ProgrammingElectronic Design AutomationTree Mutation Keywords-Evolutionary AlgorithmDigital circuitsParse-TreeAutomatic ProgrammingElectronic Design AutomationTree Mutation
For simple digital circuits, conventional method of designing circuits can easily be applied. But for complex digital circuits, the conventional method of designing circuits is not fruitfully applicable because it is time-consuming. On the contrary, Genetic Programming is used mostly for automatic program generation. The modern approach for designing Arithmetic circuits, commonly digital circuits, is based on Graphs. This graph-based evolutionary design of arithmetic circuits is a method of optimized designing of arithmetic circuits. In this paper, a new technique for evolutionary design of digital circuits is proposed using Genetic Programming (GP) with Subtree Mutation in place of Graph-based design. The results obtained using this technique demonstrates the potential capability of genetic programming in digital circuit design with limited computer algorithms. The proposed technique, helps to simplify and speed up the process of designing digital circuits, discovers a variation in the field of digital circuit design where optimized digital circuits can be successfully and effectively designed .Abstract-For simple digital circuits, conventional method of designing circuits can easily be applied. But for complex digital circuits, the conventional method of designing circuits is not fruitfully applicable because it is time-consuming. On the contrary, GeneticProgramming is used mostly for automatic program generation. The modern approach for designing Arithmetic circuits, commonly digital circuits, is based on Graphs. This graph-based evolutionary design of arithmetic circuits is a method of optimized designing of arithmetic circuits. In this paper, a new technique for evolutionary design of digital circuits is proposed using Genetic Programming (GP) with Subtree Mutation in place of Graph-based design. The results obtained using this technique demonstrates the potential capability of genetic programming in digital circuit design with limited computer algorithms. The proposed technique, helps to simplify and speed up the process of designing digital circuits, discovers a variation in the field of digital circuit design where optimized digital circuits can be successfully and effectively designed .</p>
<p>INTRODUCTION</p>
<p>The research in Genetic Programming has been vastly developed over the last few years. Genetic Programming has recently been applied for designing analog electrical circuits. In the work of Koza et al., on analog circuit synthesis by means of genetic programming (GP), the component values, number of components and the circuits topologies are evolved together, where various analog filter design and circuit synthesis problems have been solved using this approach [1]. Like analog circuits, the design of digital circuits is not really an easy task. These digital circuits are inseparable part of the modern computer life. What is done with the computer is basically computation and logic-based operations. For this reason, digital circuits are badly needed. But designing digital circuits is generally a complicated and timeconsuming task requiring knowledge of large collections of domain-specific rules. The design basically depends on the understanding of operations of the circuits. To design a digital circuit efficiently and with little algorithmic knowledge, our traditional digital circuit solution strategy must be changed. For this reason, like the automatic synthesis of analog electrical circuits used in [1], [2], we are trying to design digital circuits with genetic programming efficiently and effectively.</p>
<p>The conventional digital circuit design approach involves a large amount of task to develop digital circuits, whereas genetic programming can design a digital circuit heuristically without performing a large number of tasks. The tasks that the conventional approach includes the statement of the problem, determination of number of input and output variables, the letter symbols for input and output variables, the truth table defining input-output mapping, simplified Boolean expression and drawing of circuits [3]. On the other hand, the automatic synthesis just requires the definition of input and output variables, the input-output mapping and drawing of circuits. For those significant benefits of designing digital circuits using genetic programming, we have adopted this technique to design different critical digital circuits. Our objective here is to design digital circuits automatically using Genetic Programming with Evolutionary Tree Mutation. Our goal is to achieve 100% accurate result in designing digital circuits, that is, to achieve a fitness that is equal to required fitness. Here it is being tried to focus on the design of comparatively critical digital circuits used in many spheres of digital operations.</p>
<p>In this paper, the method of designing digital circuits using a modern approach in genetic programming with Evolutionary Tree Mutation [4] has been proposed. Here the effort, outcome and measurement of the accuracy of our outcome are represented.</p>
<p>GENETIC PROGRAMMING: AN EVOLUTIONARY DESIGN OVERVIEW</p>
<p>Finding a potential solution of the problem at hand represented by a suitable chromosome is a key issue for evolutionary computation, e.g., genetic programming. Currently, there are numerous approaches used as the chromosome representation of hardware structure [1], [6]- [11]. In [6], for example, an approach to the evolutionary design is described. The reported design method, however, is based on direct evolution with gate level primitive components such as logic gates and flip-flops. In our research, it is tried to solve the problem of designing digital circuits using Genetic Programming; hence it is needed to formulate the problem genetically. In order to formulate the problem, the basics of Genetic Programming are required. Using this technique, a new solution is searched in non-linear time, with relative certainty that the final outcome will converge on a near-optimal, global solution. Much of the theory behind genetic programming is the same as that behind genetic algorithms. The same Darwinian concept of survival-of-the-fittest applies, through genetic operators, but with a twist. Sometimes Genetic programming can solve problem more efficiently than Genetic Algorithm.</p>
<p>Genetic programming is proposed as a search and optimization technique for automatic program induction: a population of trial computer programs is maintained, mutation operations produce changes in these programs, and selection is used to determine which programs survives to the next generation and which programs are culled from the pool of trials. The process is repeated until an acceptable program is obtained or the allotted computer time is exhausted. The genetic programming procedure consists of an initialization followed by an iterative loop of mutation and selection.</p>
<p>Initialization</p>
<p>The initial population of trial computer is randomly generated. There are several methods for generating parse trees that can be used to initialize the population. Here the initialization depends upon the maximum allowed length of tree. Once the trees are generated, the performance of each of randomly generated trees is evaluated based on objective function. In our problem, we have used circuits as individuals. In the initial population, there are some defined number of circuits for us for forward propagation. Initially, what we do is to assign fitness to each individual for the further generation processing.</p>
<p>Offspring Generation by Mutation</p>
<p>Six different mutation operators are employed to generate offspring from parents. These mutation operators are named OneNode, AllNodes, Swap, Grow, and Trunc [4].</p>
<p>The tree structures consists of nodes, with the function nodes taking one or more arguments and terminal nodes taking zero arguments.</p>
<p>Parent Selection</p>
<p>EP-style tournament selection [4] with ten opponents is applied to select the parents for the next generation. Every program in the population was compared with ten randomly selected opponents. For each comparison in which the program receives a better than or equal score, it receives a win. The better half of the population with the largest number of wins becomes the parents for the next generation. The success predicate of the retained parents is computed to check for the discovery of a solution program that solves the problem. If the solution is found, the search procedure is terminated and the problem is considered to be solved; otherwise the process of mutation and selection is continued for the next generation.</p>
<p>CIRCUIT DESIGN METHODOLOGY</p>
<p>In this paper, said genetic programming has been used to design digital circuits using the evolutionary tree mutation technique. Subtree mutation transforms the structure of a circuit preserving its correctness property, that is, the input output mapping must be perfect. Selection is used to determine which programs survive to the next generation and which programs are culled from the pool of trials. The process is repeated until an acceptable program is obtained or the allotted computer time is exhausted. The initialization is followed by an iterative loop of mutation and selection. For our problem, the individuals are generated in the initial population as follows. First, we select functional nodes or functions randomly from the table of functions, then count the number of input and output terminals in all nodes selected, next add specific functional nodes so as to balance the input and output terminals, and finally connect the terminals randomly to generate a correct digital circuit. After the generation of initial population, the subtrees of each individual are also randomly generated [5].</p>
<p>Functions and Terminals</p>
<p>Functional representation includes the internal structure of a circuit. Generally, the circuits are designed internally as parse trees. To design a parse tree the definition of operators is a must; the operators that are used here are termed as functional nodes or functions [   </p>
<p>Fitness Calculation</p>
<p>The fitness calculation is mainly depends on the truth table that indicates the inputoutput mapping. The fitness for the circuits, generated in each generation, is compared to the desired fitness that indicates the correctness of our design. So fitness is termed as the performance measure of our design. Depending on the fitness achieved, decision can be made whether there is a variation from the possible circuit representation or how much far we are from our actual design.</p>
<p>Circuit Verification</p>
<p>After getting the desired fitness, a new circuit verification algorithm is applied to check whether the circuit is perfect or not. If the circuit is not perfect, the process of designing circuits is repeatedly applied.  </p>
<p>IMPLEMENTATION</p>
<p>To implement the program of designing digital circuits in computer, there is an essence of control parameters listed in [TABLE II]. Besides this, there must be the alphabetic terminal names, number of inputs and outputs, and a truth table that is externally given. Moreover, randomness is performed based on time-based seed. There is also a limit for number 'runs' or 'trials'. Using these information of a circuit, a perfect digital circuit can be designed.  TABLE III  SAMPLE TRUTH TABLE FOR  3-INPUT 1-OUTPUT CIRCUIT   Inputs  Outputs  A2  A1  A0  F  0  0  0  0  0  0  1  0  0  1  0  0  0  1  1  1  1  0  0  1  1  0  1  1  1  1  0  1  1 1 1 1</p>
<p>RESULTS</p>
<p>The genetic programming approach has been used here to design digital circuits efficiently having small to large number of inputs. The circuits (both combinational and sequential circuits) that are designed have inputs from three to ten and outputs having one to more; circuits having more than ten inputs can also be designed properly. The circuits obtained depending on the truth table are expressed in the program as parse tree representations and they are in prefix notation. The results and the circuit diagrams for multi-input circuits are listed in  </p>
<p>A. 3-Input-1-Output Combinational Circuit</p>
<p>According to the sample truth table [TABLE III], the correct expression achieved in genetic programming is: F = (AND (OR A0 A2) (OR A2 A1)) The actual Boolean expression for the above expression found in genetic programming is:
F = (A0+A2).(A1+A2)
Corresponding circuit diagram is given below.   a sample truth table  Genetic programming, while designing the digital circuits, shows appreciable performance. In this approach, the fitness error decreases generation by generation. The divergence of error generation by generation is shown in fig 5.10, fig 5.11, fig  5.12, and fig. 5.13. The fitness error shown in the figure is the error with circuits that were tested and as error goes down to zero, it can be said that the circuit is correct, otherwise wrong. showing Generation vs Error(%)</p>
<p>C. 4-Input-2-Output Combinational Circuit</p>
<p>CONCLUSION</p>
<p>In this paper, an efficient digital circuit design technique using genetic programming with subtree mutation is proposed which is applied to various combinational and sequential circuit design. In fact, the proposed technique can easily be applied to the different digital circuit design specification by changing fitness functions. In addition, the effectiveness of our design has been shown in the result. In the sample design of digital circuits, the circuit got is also verified and found that the design is perfect. This implies that the proposed design can help to speed up the process of designing digital circuits. So, Genetic programming can be a nice choice for designing more complex arithmetic circuits, like ALU design. Our proposed technique can do better in this respect.</p>
<p>I]. Different problem uses different functions and terminals. For digital circuits, functions are Basic gates (AND-gate, OR-gate, NOT-gate), Combinational functional elements (Half Adder-HA, Full Adder-FA etc.) and Sequential Memory elements (JK-Flip-Flop, RS-Flip-Flop, D-Flip-Flop, T-Flip-Flop etc.). The terminals are the input variables used in the circuits. Suppose, a circuit consists of input set {a,b}, then a and b are terminals. These terminals, as well as, functions are initialized to use in the design of circuits.4. RESULTSIn our research, we have experimented on the digital circuits. Here we list our outcome for simple and complex digital circuits design.</p>
<p>Fig 3. 1 :
1Circuit verification algorithm</p>
<p>Figure 5 . 1 :Figure 5 . 2 :
5152Circuit Diagram discovered by GP for 3-input-1-output combinational circuitB. 4-Input-1-Output Combinational CircuitCircuit Diagram discovered by GP for 4-input-1-output combinational circuit for a sample truth table</p>
<p>Figure 5 . 3 :Figure 5 . 4 :Figure 5 . 5 :Figure 5 . 6 :Figure 5 . 7 :Figure 5 . 8 :Figure 5 . 9 :
53545556575859Circuit Diagram discovered by GP for 4-input-2-output combinational circuit for a sample truth table D. 5-Input-1-Output Sequential Circuit Circuit Diagram discovered by GP for 5-input-1-output sequential circuit for a sample truth table E. 6-Input-1-Output Combinational Circuit Circuit Diagram discovered by GP for 6-input-1-output combinational circuit for a sample truth table F. 7-Input-1-Output Combinational Circuit Circuit Diagram discovered by GP for 7-input-1-output combinational circuit for a sample truth table G. 8-Input-1-Output Combinational Circuit Circuit Diagram discovered by GP for 8-input-1-output combinational circuit for a sample truth table H. 9-Input-1-Output Combinational Circuit Circuit Diagram discovered by GP for 9-input-1-output combinational circuit for a sample truth table I. 10-Input-1-Output Combinational Circuit Circuit Diagram discovered by GP for 9-input-1-output combinational circuit for</p>
<p>Fig 5 . 10 : 11 :Fig 5 . 12 :
51011512Divergence in error for GP Fig 5.Divergence Divergence in error for GP Fig 5.13 Divergence in error for GP for 9-input circuit for 10-input circuit showing Generation vs Error(%)</p>
<p>TABLE</p>
<p>TABLE I FUNCTIONS
I</p>
<p>desired output = measured output for all combinations : Correct Circuit. 4. desired output ≠ measured output for any combination : Wrong circuit.1. Calculate total no. of combinations: 2 inputs 
2. For each combination -
i) Replace each terminal with the corresponding input terminal value by 
matching with input terminals. 
ii) Get the desired output from truth table. 
iii) Calculate desired output until the measured circuit is solved for each 
Combination-
a) Calculate the function values as defined in functions. 
b) Update after calculating values. 
3. </p>
<p>TABLE II MAIN
IICONTROL PARAMETER VALUESPopulation size 
1000 
Weight of Allnode mutation 100 
Gross number of generations 1000 
Weight of Swap mutation 
100 
Max. number of nodes 
50 
Weight of Grow mutation 
100 
Initial Population depth 
10 
Weight of Trunc mutation 
100 
Tournament Size 
10 
Probability of mutation 
1.0 </p>
<p>TABLE IV
IVand in fig 5.1-5.9. </p>
<p>TABLE IV RESULTS
IVOBTAINED IN GENETIC PROGRAMMINGNo. 
of 
inputs </p>
<p>No. 
of 
outputs </p>
<p>Input 
Terminals </p>
<p>Output 
Terminals </p>
<p>Functions 
No. of 
trials </p>
<p>No. of 
Generations </p>
<p>3 
1 
{A0, A1, A2} 
{F} 
{AND, OR, 
NOT, HA, FA} </p>
<p>10 
1 </p>
<p>4 
1 
{A0, A1, A2, 
A3} </p>
<p>{F} 
{AND, OR, 
NOT, HA, FA} </p>
<p>15 
1 </p>
<p>4 
2 
{A0, A1, A2, 
A3} </p>
<p>{F1,F2} 
{AND, OR, 
NOT, HA, FA} </p>
<p>10(F1) 
50(F2) </p>
<p>1(F1) 
25(F2) 
5 
1 
{A0, A1, A2, 
A3, A4} </p>
<p>{F} 
{AND, OR, 
NOT, HA, FA, 
JKFF, RSFF, 
DFF, TFF} </p>
<p>40 
1 </p>
<p>6 
1 
{A0, A1, A2, 
A3, A4, A5} </p>
<p>{F} 
{AND, OR, 
NOT, HA, FA} </p>
<p>50 
23 </p>
<p>7 
1 
{A0, A1, A2, 
A3, A4, A5, 
A6} </p>
<p>{F} 
{AND, OR, 
NOT, HA, FA} </p>
<p>30 
60 </p>
<p>8 
1 
{A0, A1, A2, 
A3, A4, A5, A6, 
A7} </p>
<p>{F} 
{AND, OR, 
NOT, HA, FA} </p>
<p>30 
6 </p>
<p>9 
1 
{A0, A1, A2, 
A3, A4, A5, A6, 
A7, A8} </p>
<p>{F} 
{AND, OR, 
NOT, HA, FA} </p>
<p>65 
40 </p>
<p>10 
1 
{A0, A1, A2, 
A3, A4, A5, A6, 
A7, A8, A9} </p>
<p>{F} 
{AND, OR, 
NOT, HA, FA} </p>
<p>60 
10 </p>
<p>Automated synthesis of analog electrical circuits by means of genetic programming. J R Koza, F H Bennett, D Andre, M A Keane, F Dunlap, IEEE Transactions on evolutionary computation. 1J. R. Koza, F. H. Bennett, D. Andre, M. A. Keane and F. Dunlap, "Automated synthesis of analog electrical circuits by means of genetic programming", IEEE Transactions on evolutionary computation, vol. 1, pp. 109-128, July- 1997.</p>
<p>An Evolutionary Approach to Automatic Synthesis of High-Performance Analog Integrated Circuits. Sina Güner Alpaydın, Günhan Balkır, Dündar, IEEE Transactions on evolutionary computation. 73Güner Alpaydın, Sina Balkır and Günhan Dündar, "An Evolutionary Approach to Automatic Synthesis of High-Performance Analog Integrated Circuits", IEEE Transactions on evolutionary computation, vol. 7, no. 3, pp. 240-252, June-2003.</p>
<p>Digital Logic and Computer Design. M , Morris Mano, Prentice Hall of India Private LimitedNineteenth Reprinted EditionM. Morris Mano " Digital Logic and Computer Design ", Nineteenth Reprinted Edition,2000,Prentice Hall of India Private Limited, pp. 116-150.</p>
<p>Evolving Computer Programs without Subtree Crossover. Kumar Chellapilla, IEEE Transactions on evolutionary computation. 13Kumar Chellapilla, "Evolving Computer Programs without Subtree Crossover", IEEE Transactions on evolutionary computation, vol. 1, no. 3, pp. 209-216, Sept.-1997.</p>
<p>Graph-Based Evolutionary Design of Arithmetic Circuits. Dingjun Chen, Takafumi Aoki, Naofumi Homma, Toshiki Terasaki, Tatsuo Higuchi, IEEE Transactions on evolutionary computation. 61Dingjun Chen, Takafumi Aoki, Naofumi Homma, Toshiki Terasaki and Tatsuo Higuchi, "Graph-Based Evolutionary Design of Arithmetic Circuits", IEEE Transactions on evolutionary computation, vol. 6, no. 1, pp. 86-99, Feb.-2002.</p>
<p>Designing electronic circuits using evolutionary algorithms, Arithmetic circuits: A case study" in Genetic Algorithms and Evolution Strategies in Engineering and Computer Science. J F Miller, P Thomson, T Fogarty, WileyNew YorkJ. F. Miller, P. Thomson and T. Fogarty, "Designing electronic circuits using evolutionary algorithms, Arithmetic circuits: A case study" in Genetic Algorithms and Evolution Strategies in Engineering and Computer Science. New York: Wiley, 1997, pp. 105-131.</p>
<p>Evolvable Hardware: Genetic programming of a Darwin machine. H De Garis, Artificial Neural Nets and Genetic Algorithms. R. F. Albrecht, C. R. Reeves, and N. C. Steele EdsHeidelberg, GermanySpringer-VerlagH. De Garis, "Evolvable Hardware: Genetic programming of a Darwin machine", in Artificial Neural Nets and Genetic Algorithms, R. F. Albrecht, C. R. Reeves, and N. C. Steele Eds. Heidelberg, Germany: Springer-Verlag, 1993, pp. 441-449.</p>
<p>Variable length genetic algorithms for evolvable hardware. I Kajitani, T Hoshino, M Iwata, T Highchi, Proc. 1996 IEEE Int. Conf. Evolutionary Computation. 1996 IEEE Int. Conf. Evolutionary ComputationI. Kajitani, T. Hoshino, M. Iwata, and T. Highchi, "Variable length genetic algorithms for evolvable hardware", in Proc. 1996 IEEE Int. Conf. Evolutionary Computation, May 1996, pp. 443-447.</p>
<p>A phylogenetic , ontogenetic, and epigenetic view of bio-inspired hardware systems. M Sipper, E Sanchez, D Mange, M Tomassini, A Perez-Uribe, A Stauffer, IEEE Transactions on evolutionary computation. 1M. Sipper, E. Sanchez, D. Mange, M. Tomassini, A. Perez-Uribe, and A. Stauffer, "A phylogenetic , ontogenetic, and epigenetic view of bio-inspired hardware systems", IEEE Transactions on evolutionary computation, vol. 1, pp. 83-97, Apr.-1997.</p>
<p>Evolutionary computation: The Fossil Record. D B Fogel, D. B. FogelIEEE PressEd. Piscataway, NJD. B. Fogel, Evolutionary computation: The Fossil Record, D. B. Fogel, Ed. Piscataway, NJ: IEEE Press, 1998.</p>
<p>Evolvable hardware at function level. T Higuchi, M Murakawa, M Iwata, I Kajitani, L Weixin, M Salami, Proc. 1997 IEEE Int. Conf. Evolutionary Computation. 1997 IEEE Int. Conf. Evolutionary ComputationT. Higuchi, M. Murakawa, M. Iwata, I. Kajitani, L. Weixin, and M. Salami, "Evolvable hardware at function level", in Proc. 1997 IEEE Int. Conf. Evolutionary Computation, May 1997, pp. 187-192..</p>
<p>GPQUICK: A Simple Genetic Programming System in C++. A Singleton, A. Singleton, GPQUICK: A Simple Genetic Programming System in C++. Available: ftp://ftp.krl.caltech.edu/pub/EC/GP/src/gpquick-1.2.tar.gz.</p>            </div>
        </div>

    </div>
</body>
</html>