<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-2858 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-2858</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-2858</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-71.html">extraction-schema-71</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of LLM-based agents that use memory systems to play text games, including details about the memory architecture, the text games played, and performance results.</div>
                <p><strong>Paper ID:</strong> paper-60441391</p>
                <p><strong>Paper Title:</strong> <a href="https://arxiv.org/pdf/1902.04259v2.pdf" target="_blank">NAIL: A General Interactive Fiction Agent</a></p>
                <p><strong>Paper Abstract:</strong> Interactive Fiction (IF) games are complex textual decision making problems. This paper introduces NAIL, an autonomous agent for general parser-based IF games. NAIL won the 2018 Text Adventure AI Competition, where it was evaluated on twenty unseen games. This paper describes the architecture, development, and insights underpinning NAIL's performance.</p>
                <p><strong>Cost:</strong> 0.017</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e2858.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e2858.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of LLM-based agents that use memory systems to play text games, including details about the memory architecture, the text games played, and performance results.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>NAIL</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>NAIL (Navigate, Acquire, Interact and Learn)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A modular, rule+learned hybrid agent for parser-based Interactive Fiction (IF) that builds and uses an explicit knowledge graph to represent locations, objects, connections and object states while selecting actions via specialized decision modules.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>NAIL</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>NAIL is a modular agent composed of specialized Decision Modules (Examiner, Hoarder, Interactor, Navigator and various specialized handlers). Modules compete for control via an eagerness score; the active module generates one or more textual actions, observes the game's response, and updates a shared Knowledge Graph. Action generation uses a 5-gram language model to rank candidate verb-object and verb-object-preposition-object templates; action success/failure is judged by a FastText-based Validity Detector. The Knowledge Graph is the agent's central memory: Decision Modules read from it to compute eagerness and generate actions, and write to it when actions are judged successful.</td>
                        </tr>
                        <tr>
                            <td><strong>base_llm</strong></td>
                            <td>Not a transformer LLM; uses a 5-gram language model (trained on ~1.5B n-grams from web titles) for action ranking and a FastText classifier for action validity detection.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_memory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>knowledge graph (structured semantic/episodic memory of locations, entities, inventory, connections and object states)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_architecture</strong></td>
                            <td>A structured Knowledge Graph storing: Current Location, list of discovered Locations (each with Name, Description, Entities, Action Record), a Connection Graph linking locations, Inventory, Unrecognized Words, and Entity nodes (Names, Description, contained Entities, State, Attributes). Decision Modules (Examiner, Navigator, Hoarder, Interactor) update the KG: Examiner adds Entities when 'examine' returns a valid description; Navigator adds Locations and Connection edges when navigation is judged successful (using fuzzy string matching to detect new location descriptions); Hoarder and Interactor update inventory and object states for actions like 'take' or 'turn on'. The Validity Detector gates creation of KG entries. The KG is used by modules to avoid repeated failed actions, prioritize navigation, and focus interactions.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_capacity</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>Exact and fuzzy text matching of location descriptions (FuzzyWuzzy) and direct lookups in the KG; decision modules query KG state (e.g., Entities at current Location, previously attempted actions) to select actions. (No vector similarity retrieval described.)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_update_strategy</strong></td>
                            <td>KG is updated immediately after actions judged successful by the Validity Detector: Examiner on successful 'examine' adds Entities and descriptions; Navigator on successful movement adds Locations and Connection edges and records descriptions; Hoarder updates Inventory on successful 'take' actions; Interactor updates object states for common actions whose effects are manually encoded. Unrecognized words are appended to a list when the game returns parser-failure messages.</td>
                        </tr>
                        <tr>
                            <td><strong>text_game_benchmark</strong></td>
                            <td>Jericho environment; evaluated in the 2018 Text-Based Adventure AI Competition on 20 unseen parser-based IF games (also developed and tuned on a set of 56 Jericho games).</td>
                        </tr>
                        <tr>
                            <td><strong>game_characteristics</strong></td>
                            <td>Parser-based Interactive Fiction: highly partially observable, many discrete locations, narrative text observations, combinatorial language action space, sparse rewards, puzzles requiring commonsense and object interaction; competition limited to 1000 steps per game (also reported 100-step runs).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>Competition (20 unseen games, 1000 steps/game): average normalized % completion = 2.56% (SD 0.33); % non-zero games = 45.5% (SD 2.84). NAIL won the 2018 Text-Based Adventure AI Competition. Also reported: NAIL (100 steps) % completion = 0.95% (SD 0.19), % non-zero = 26% (SD 2.11).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td>Ablation baseline with no decision modules (only 'look') achieved 0.53% normalized score. Sequentially adding modules (which create/use KG information) raised scores: Navigator 1.2%, Hoarder 1.6%, Examiner 2.6%, Interactor 3.5% (these numbers are from an ablation that adds modules one-by-one on Jericho games). (There is no direct experiment that removes only the Knowledge Graph while keeping modules active; ablation is by module.)</td>
                        </tr>
                        <tr>
                            <td><strong>has_ablation_study</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_ablation_results</strong></td>
                            <td>Module ablations that add or remove components that build/use the KG strongly affect performance: adding Navigator (which builds the map) increased score from 0.53% to 1.2%; adding Hoarder increased to 1.6%; adding Examiner (which populates the KG with recognized Entities) raised to 2.6%; Interactor (which uses KG Entities for actions) increased to 3.5%. Authors highlight that the explicit KG is a major contribution and that Examiner-driven examination (26% of actions in training set were 'examine') plus the Validity Detector are key to reliable KG population.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other_memory_types</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings_about_memory_effectiveness</strong></td>
                            <td>An explicit, structured Knowledge Graph that records discovered locations, objects, connections and object states is crucial for general IF play: it produces an interpretable map, gates actions to recognized objects, and reduces wasted interactions. The Validity Detector (learned classifier) is essential to avoid populating the KG with invalid entries. Aggressive examination of text to populate memory (Examiner) markedly improves interaction quality.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'NAIL: A General Interactive Fiction Agent', 'publication_date_yy_mm': '2019-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e2858.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e2858.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of LLM-based agents that use memory systems to play text games, including details about the memory architecture, the text games played, and performance results.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>LSTM-DQN</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>LSTM-DQN (language-understanding DQN with LSTM state encoder)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A deep reinforcement learning agent that encodes game narrative with an LSTM to form a state representation used by a DQN policy; the recurrence provides a form of working memory over text observations.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Language understanding for textbased games using deep reinforcement learning</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>LSTM-DQN</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Uses an LSTM to process narrative text and produce a state representation which is fed to a DQN to select actions. The recurrent encoder integrates information over time so that partial observations become an internal state for decision-making.</td>
                        </tr>
                        <tr>
                            <td><strong>base_llm</strong></td>
                            <td>Not a large pretrained transformer LLM; based on an LSTM encoder trained end-to-end with DQN.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_memory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>working memory implemented by recurrent LSTM hidden state (temporal/stateful memory)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_architecture</strong></td>
                            <td>An LSTM processes the sequence of textual observations; the resulting hidden state acts as the agent's state representation (memory) that the DQN uses to score actions. Memory is implicit in the LSTM hidden activation rather than an explicit external store.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_capacity</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>Implicit retrieval via the recurrent hidden state; recent observations are reflected in the hidden activation.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_update_strategy</strong></td>
                            <td>Updated at every timestep by feeding the new observation into the LSTM (standard recurrent update).</td>
                        </tr>
                        <tr>
                            <td><strong>text_game_benchmark</strong></td>
                            <td>Described in the referenced Narasimhan et al. (2015) work as evaluated on text-based game environments (not quantified in this NAIL paper).</td>
                        </tr>
                        <tr>
                            <td><strong>game_characteristics</strong></td>
                            <td>Text-based interactive fiction with partial observability; requires integrating sequential textual observations.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_ablation_study</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_ablation_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other_memory_types</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings_about_memory_effectiveness</strong></td>
                            <td>The paper (referenced) introduced building a representation for current state via recurrent processing of narrative text; recurrence provides the agent the ability to integrate recent observations into decisions.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'NAIL: A General Interactive Fiction Agent', 'publication_date_yy_mm': '2019-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e2858.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e2858.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of LLM-based agents that use memory systems to play text games, including details about the memory architecture, the text games played, and performance results.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>LSTM-DRQN</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>LSTM-DRQN (Deep Recurrent Q-Network with hierarchical recurrence)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A deep RL agent that augments recurrent state representations with an additional recurrence over states (a second-level recurrence) to improve reasoning over visited locations and long-term dependencies in text games.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Counting to explore and generalize in text-based games</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>LSTM-DRQN</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Extends recurrent DQN approaches by adding a second recurrence over learned state representations (i.e., recurrence at the state level on top of observation-level recurrence), enabling longer-horizon dependencies and improved reasoning across multiple visited locations.</td>
                        </tr>
                        <tr>
                            <td><strong>base_llm</strong></td>
                            <td>Not a transformer LLM; uses recurrent networks (DRQN variants).</td>
                        </tr>
                        <tr>
                            <td><strong>uses_memory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>hierarchical/episodic recurrence (recurrence over states in addition to observation-level recurrence)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_architecture</strong></td>
                            <td>A two-level recurrent architecture: an observation encoder (LSTM) producing per-timestep states and a higher-level recurrent mechanism over those state vectors allowing the agent to aggregate information over longer horizons and across visited locations.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_capacity</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>Temporal recurrence (hidden states carry forward information); no explicit external retrieval mechanism described in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_update_strategy</strong></td>
                            <td>States updated per timestep and propagated through the higher-level recurrence.</td>
                        </tr>
                        <tr>
                            <td><strong>text_game_benchmark</strong></td>
                            <td>Mentioned as evaluated on text-based games in the referenced work (Yuan et al., 2018); no specific performance numbers reported in the NAIL paper.</td>
                        </tr>
                        <tr>
                            <td><strong>game_characteristics</strong></td>
                            <td>Long-horizon text games where reasoning about previously visited locations and events matters.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_ablation_study</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_ablation_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other_memory_types</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings_about_memory_effectiveness</strong></td>
                            <td>Adding recurrence over states provides the agent an improved ability to reason over locations visited in the past, i.e., helps with longer-term dependencies in IF.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'NAIL: A General Interactive Fiction Agent', 'publication_date_yy_mm': '2019-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e2858.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e2858.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of LLM-based agents that use memory systems to play text games, including details about the memory architecture, the text games played, and performance results.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>CARL</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>CARL (Competition agent by creators of BYU Agent)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An IF agent that encodes observations with skipâ€‘thought vectors and uses a hash table to track visited states and avoid repetition; it generates actions by extracting nouns and pairing them with verbs inferred from embeddings.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>The text-based adventure ai competition</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>CARL</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>CARL encodes observation text with skip-thought vectors to classify whether text contains location information or action effects. For location-like observations, it extracts nouns and uses word-embedding affordance heuristics to pair nouns with likely verbs, then generates commands. CARL also stores visited states in a hash table to avoid repeating state-action pairs.</td>
                        </tr>
                        <tr>
                            <td><strong>base_llm</strong></td>
                            <td>Not a large pretrained transformer LLM; uses skip-thought vector encoders (unsupervised sentence representations) and word-embedding based affordance reasoning.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_memory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>episodic visited-state memory implemented as a hash table; semantic observation vectors (skip-thought) for representation</td>
                        </tr>
                        <tr>
                            <td><strong>memory_architecture</strong></td>
                            <td>Observations are encoded into skip-thought vectors; a hash-table of visited states/actions records which state-action pairs have been tried to prevent repetition. The hash table is used as a simple external memory to track coverage of state space.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_capacity</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>Exact hashing/lookup of previously seen state representations; classification of observations via skip-thought vectors to decide storage/use.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_update_strategy</strong></td>
                            <td>Visited states and attempted actions are recorded into the hash table after each step to avoid repetition.</td>
                        </tr>
                        <tr>
                            <td><strong>text_game_benchmark</strong></td>
                            <td>Used in the Text-Based Adventure AI Competition (cited in the competition paper); evaluated on parser-based IF games used in the competition.</td>
                        </tr>
                        <tr>
                            <td><strong>game_characteristics</strong></td>
                            <td>Parser-based IF with combinatorial action spaces; CARL focuses on extracting nouns from text and pairing with likely verbs.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_ablation_study</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_ablation_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other_memory_types</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings_about_memory_effectiveness</strong></td>
                            <td>Maintaining a visited-state hash table reduces repetition and is a lightweight form of external memory helpful in parser-based IF; skip-thought encodings provide semantic representations for deciding when to generate actions.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'NAIL: A General Interactive Fiction Agent', 'publication_date_yy_mm': '2019-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e2858.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e2858.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of LLM-based agents that use memory systems to play text games, including details about the memory architecture, the text games played, and performance results.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Graph-based DRL (Ammanabrolu & Riedl)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Playing text-adventure games with graph-based deep reinforcement learning</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An end-to-end deep RL approach that represents the game state as a knowledge graph and uses that structured state as input to a policy network to play text-adventure games.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Playing text-adventure games with graph-based deep reinforcement learning</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>Graph-based deep RL agent (Ammanabrolu & Riedl)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Constructs a knowledge graph representation of the game state (entities, relations) from textual observations and uses it as the input to reinforcement learning policy/value networks so the policy operates over a structured memory representation instead of raw text.</td>
                        </tr>
                        <tr>
                            <td><strong>base_llm</strong></td>
                            <td>Not a transformer LLM; deep RL with graph-structured state representations.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_memory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>knowledge graph (structured semantic memory of state)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_architecture</strong></td>
                            <td>An explicit knowledge graph constructed from textual observations encodes entities and relations; graph features/embeddings are used by the RL learner as the agent's state representation. The KG acts as an external memory for planning and policy input.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_capacity</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>Policy network consumes graph-structured representation directly; retrieval is via graph queries/feature extraction rather than free-text search.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_update_strategy</strong></td>
                            <td>KG is updated as new textual observations are parsed into entities and relations (details in the referenced paper).</td>
                        </tr>
                        <tr>
                            <td><strong>text_game_benchmark</strong></td>
                            <td>Evaluated on text-adventure games in the literature (referenced work); NAIL cites this as related work.</td>
                        </tr>
                        <tr>
                            <td><strong>game_characteristics</strong></td>
                            <td>Parser-based IF requiring structured state understanding for planning; KG approach aims to capture relations important for puzzle solving.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_ablation_study</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_ablation_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other_memory_types</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings_about_memory_effectiveness</strong></td>
                            <td>Using an explicit knowledge graph as the agent's state representation enables RL policies to operate over structured memory and was proposed as a promising direction for end-to-end learning in text-adventure games.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'NAIL: A General Interactive Fiction Agent', 'publication_date_yy_mm': '2019-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Playing text-adventure games with graph-based deep reinforcement learning <em>(Rating: 2)</em></li>
                <li>Language understanding for textbased games using deep reinforcement learning <em>(Rating: 2)</em></li>
                <li>Counting to explore and generalize in text-based games <em>(Rating: 2)</em></li>
                <li>What can you do with a rock? affordance extraction via word embeddings <em>(Rating: 1)</em></li>
                <li>The text-based adventure ai competition <em>(Rating: 2)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-2858",
    "paper_id": "paper-60441391",
    "extraction_schema_id": "extraction-schema-71",
    "extracted_data": [
        {
            "name_short": "NAIL",
            "name_full": "NAIL (Navigate, Acquire, Interact and Learn)",
            "brief_description": "A modular, rule+learned hybrid agent for parser-based Interactive Fiction (IF) that builds and uses an explicit knowledge graph to represent locations, objects, connections and object states while selecting actions via specialized decision modules.",
            "citation_title": "here",
            "mention_or_use": "use",
            "agent_name": "NAIL",
            "agent_description": "NAIL is a modular agent composed of specialized Decision Modules (Examiner, Hoarder, Interactor, Navigator and various specialized handlers). Modules compete for control via an eagerness score; the active module generates one or more textual actions, observes the game's response, and updates a shared Knowledge Graph. Action generation uses a 5-gram language model to rank candidate verb-object and verb-object-preposition-object templates; action success/failure is judged by a FastText-based Validity Detector. The Knowledge Graph is the agent's central memory: Decision Modules read from it to compute eagerness and generate actions, and write to it when actions are judged successful.",
            "base_llm": "Not a transformer LLM; uses a 5-gram language model (trained on ~1.5B n-grams from web titles) for action ranking and a FastText classifier for action validity detection.",
            "uses_memory": true,
            "memory_type": "knowledge graph (structured semantic/episodic memory of locations, entities, inventory, connections and object states)",
            "memory_architecture": "A structured Knowledge Graph storing: Current Location, list of discovered Locations (each with Name, Description, Entities, Action Record), a Connection Graph linking locations, Inventory, Unrecognized Words, and Entity nodes (Names, Description, contained Entities, State, Attributes). Decision Modules (Examiner, Navigator, Hoarder, Interactor) update the KG: Examiner adds Entities when 'examine' returns a valid description; Navigator adds Locations and Connection edges when navigation is judged successful (using fuzzy string matching to detect new location descriptions); Hoarder and Interactor update inventory and object states for actions like 'take' or 'turn on'. The Validity Detector gates creation of KG entries. The KG is used by modules to avoid repeated failed actions, prioritize navigation, and focus interactions.",
            "memory_capacity": null,
            "memory_retrieval_method": "Exact and fuzzy text matching of location descriptions (FuzzyWuzzy) and direct lookups in the KG; decision modules query KG state (e.g., Entities at current Location, previously attempted actions) to select actions. (No vector similarity retrieval described.)",
            "memory_update_strategy": "KG is updated immediately after actions judged successful by the Validity Detector: Examiner on successful 'examine' adds Entities and descriptions; Navigator on successful movement adds Locations and Connection edges and records descriptions; Hoarder updates Inventory on successful 'take' actions; Interactor updates object states for common actions whose effects are manually encoded. Unrecognized words are appended to a list when the game returns parser-failure messages.",
            "text_game_benchmark": "Jericho environment; evaluated in the 2018 Text-Based Adventure AI Competition on 20 unseen parser-based IF games (also developed and tuned on a set of 56 Jericho games).",
            "game_characteristics": "Parser-based Interactive Fiction: highly partially observable, many discrete locations, narrative text observations, combinatorial language action space, sparse rewards, puzzles requiring commonsense and object interaction; competition limited to 1000 steps per game (also reported 100-step runs).",
            "performance_with_memory": "Competition (20 unseen games, 1000 steps/game): average normalized % completion = 2.56% (SD 0.33); % non-zero games = 45.5% (SD 2.84). NAIL won the 2018 Text-Based Adventure AI Competition. Also reported: NAIL (100 steps) % completion = 0.95% (SD 0.19), % non-zero = 26% (SD 2.11).",
            "performance_without_memory": "Ablation baseline with no decision modules (only 'look') achieved 0.53% normalized score. Sequentially adding modules (which create/use KG information) raised scores: Navigator 1.2%, Hoarder 1.6%, Examiner 2.6%, Interactor 3.5% (these numbers are from an ablation that adds modules one-by-one on Jericho games). (There is no direct experiment that removes only the Knowledge Graph while keeping modules active; ablation is by module.)",
            "has_ablation_study": true,
            "memory_ablation_results": "Module ablations that add or remove components that build/use the KG strongly affect performance: adding Navigator (which builds the map) increased score from 0.53% to 1.2%; adding Hoarder increased to 1.6%; adding Examiner (which populates the KG with recognized Entities) raised to 2.6%; Interactor (which uses KG Entities for actions) increased to 3.5%. Authors highlight that the explicit KG is a major contribution and that Examiner-driven examination (26% of actions in training set were 'examine') plus the Validity Detector are key to reliable KG population.",
            "comparison_with_other_memory_types": null,
            "key_findings_about_memory_effectiveness": "An explicit, structured Knowledge Graph that records discovered locations, objects, connections and object states is crucial for general IF play: it produces an interpretable map, gates actions to recognized objects, and reduces wasted interactions. The Validity Detector (learned classifier) is essential to avoid populating the KG with invalid entries. Aggressive examination of text to populate memory (Examiner) markedly improves interaction quality.",
            "uuid": "e2858.0",
            "source_info": {
                "paper_title": "NAIL: A General Interactive Fiction Agent",
                "publication_date_yy_mm": "2019-02"
            }
        },
        {
            "name_short": "LSTM-DQN",
            "name_full": "LSTM-DQN (language-understanding DQN with LSTM state encoder)",
            "brief_description": "A deep reinforcement learning agent that encodes game narrative with an LSTM to form a state representation used by a DQN policy; the recurrence provides a form of working memory over text observations.",
            "citation_title": "Language understanding for textbased games using deep reinforcement learning",
            "mention_or_use": "mention",
            "agent_name": "LSTM-DQN",
            "agent_description": "Uses an LSTM to process narrative text and produce a state representation which is fed to a DQN to select actions. The recurrent encoder integrates information over time so that partial observations become an internal state for decision-making.",
            "base_llm": "Not a large pretrained transformer LLM; based on an LSTM encoder trained end-to-end with DQN.",
            "uses_memory": true,
            "memory_type": "working memory implemented by recurrent LSTM hidden state (temporal/stateful memory)",
            "memory_architecture": "An LSTM processes the sequence of textual observations; the resulting hidden state acts as the agent's state representation (memory) that the DQN uses to score actions. Memory is implicit in the LSTM hidden activation rather than an explicit external store.",
            "memory_capacity": null,
            "memory_retrieval_method": "Implicit retrieval via the recurrent hidden state; recent observations are reflected in the hidden activation.",
            "memory_update_strategy": "Updated at every timestep by feeding the new observation into the LSTM (standard recurrent update).",
            "text_game_benchmark": "Described in the referenced Narasimhan et al. (2015) work as evaluated on text-based game environments (not quantified in this NAIL paper).",
            "game_characteristics": "Text-based interactive fiction with partial observability; requires integrating sequential textual observations.",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_ablation_study": null,
            "memory_ablation_results": null,
            "comparison_with_other_memory_types": null,
            "key_findings_about_memory_effectiveness": "The paper (referenced) introduced building a representation for current state via recurrent processing of narrative text; recurrence provides the agent the ability to integrate recent observations into decisions.",
            "uuid": "e2858.1",
            "source_info": {
                "paper_title": "NAIL: A General Interactive Fiction Agent",
                "publication_date_yy_mm": "2019-02"
            }
        },
        {
            "name_short": "LSTM-DRQN",
            "name_full": "LSTM-DRQN (Deep Recurrent Q-Network with hierarchical recurrence)",
            "brief_description": "A deep RL agent that augments recurrent state representations with an additional recurrence over states (a second-level recurrence) to improve reasoning over visited locations and long-term dependencies in text games.",
            "citation_title": "Counting to explore and generalize in text-based games",
            "mention_or_use": "mention",
            "agent_name": "LSTM-DRQN",
            "agent_description": "Extends recurrent DQN approaches by adding a second recurrence over learned state representations (i.e., recurrence at the state level on top of observation-level recurrence), enabling longer-horizon dependencies and improved reasoning across multiple visited locations.",
            "base_llm": "Not a transformer LLM; uses recurrent networks (DRQN variants).",
            "uses_memory": true,
            "memory_type": "hierarchical/episodic recurrence (recurrence over states in addition to observation-level recurrence)",
            "memory_architecture": "A two-level recurrent architecture: an observation encoder (LSTM) producing per-timestep states and a higher-level recurrent mechanism over those state vectors allowing the agent to aggregate information over longer horizons and across visited locations.",
            "memory_capacity": null,
            "memory_retrieval_method": "Temporal recurrence (hidden states carry forward information); no explicit external retrieval mechanism described in this paper.",
            "memory_update_strategy": "States updated per timestep and propagated through the higher-level recurrence.",
            "text_game_benchmark": "Mentioned as evaluated on text-based games in the referenced work (Yuan et al., 2018); no specific performance numbers reported in the NAIL paper.",
            "game_characteristics": "Long-horizon text games where reasoning about previously visited locations and events matters.",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_ablation_study": null,
            "memory_ablation_results": null,
            "comparison_with_other_memory_types": null,
            "key_findings_about_memory_effectiveness": "Adding recurrence over states provides the agent an improved ability to reason over locations visited in the past, i.e., helps with longer-term dependencies in IF.",
            "uuid": "e2858.2",
            "source_info": {
                "paper_title": "NAIL: A General Interactive Fiction Agent",
                "publication_date_yy_mm": "2019-02"
            }
        },
        {
            "name_short": "CARL",
            "name_full": "CARL (Competition agent by creators of BYU Agent)",
            "brief_description": "An IF agent that encodes observations with skipâ€‘thought vectors and uses a hash table to track visited states and avoid repetition; it generates actions by extracting nouns and pairing them with verbs inferred from embeddings.",
            "citation_title": "The text-based adventure ai competition",
            "mention_or_use": "mention",
            "agent_name": "CARL",
            "agent_description": "CARL encodes observation text with skip-thought vectors to classify whether text contains location information or action effects. For location-like observations, it extracts nouns and uses word-embedding affordance heuristics to pair nouns with likely verbs, then generates commands. CARL also stores visited states in a hash table to avoid repeating state-action pairs.",
            "base_llm": "Not a large pretrained transformer LLM; uses skip-thought vector encoders (unsupervised sentence representations) and word-embedding based affordance reasoning.",
            "uses_memory": true,
            "memory_type": "episodic visited-state memory implemented as a hash table; semantic observation vectors (skip-thought) for representation",
            "memory_architecture": "Observations are encoded into skip-thought vectors; a hash-table of visited states/actions records which state-action pairs have been tried to prevent repetition. The hash table is used as a simple external memory to track coverage of state space.",
            "memory_capacity": null,
            "memory_retrieval_method": "Exact hashing/lookup of previously seen state representations; classification of observations via skip-thought vectors to decide storage/use.",
            "memory_update_strategy": "Visited states and attempted actions are recorded into the hash table after each step to avoid repetition.",
            "text_game_benchmark": "Used in the Text-Based Adventure AI Competition (cited in the competition paper); evaluated on parser-based IF games used in the competition.",
            "game_characteristics": "Parser-based IF with combinatorial action spaces; CARL focuses on extracting nouns from text and pairing with likely verbs.",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_ablation_study": null,
            "memory_ablation_results": null,
            "comparison_with_other_memory_types": null,
            "key_findings_about_memory_effectiveness": "Maintaining a visited-state hash table reduces repetition and is a lightweight form of external memory helpful in parser-based IF; skip-thought encodings provide semantic representations for deciding when to generate actions.",
            "uuid": "e2858.3",
            "source_info": {
                "paper_title": "NAIL: A General Interactive Fiction Agent",
                "publication_date_yy_mm": "2019-02"
            }
        },
        {
            "name_short": "Graph-based DRL (Ammanabrolu & Riedl)",
            "name_full": "Playing text-adventure games with graph-based deep reinforcement learning",
            "brief_description": "An end-to-end deep RL approach that represents the game state as a knowledge graph and uses that structured state as input to a policy network to play text-adventure games.",
            "citation_title": "Playing text-adventure games with graph-based deep reinforcement learning",
            "mention_or_use": "mention",
            "agent_name": "Graph-based deep RL agent (Ammanabrolu & Riedl)",
            "agent_description": "Constructs a knowledge graph representation of the game state (entities, relations) from textual observations and uses it as the input to reinforcement learning policy/value networks so the policy operates over a structured memory representation instead of raw text.",
            "base_llm": "Not a transformer LLM; deep RL with graph-structured state representations.",
            "uses_memory": true,
            "memory_type": "knowledge graph (structured semantic memory of state)",
            "memory_architecture": "An explicit knowledge graph constructed from textual observations encodes entities and relations; graph features/embeddings are used by the RL learner as the agent's state representation. The KG acts as an external memory for planning and policy input.",
            "memory_capacity": null,
            "memory_retrieval_method": "Policy network consumes graph-structured representation directly; retrieval is via graph queries/feature extraction rather than free-text search.",
            "memory_update_strategy": "KG is updated as new textual observations are parsed into entities and relations (details in the referenced paper).",
            "text_game_benchmark": "Evaluated on text-adventure games in the literature (referenced work); NAIL cites this as related work.",
            "game_characteristics": "Parser-based IF requiring structured state understanding for planning; KG approach aims to capture relations important for puzzle solving.",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_ablation_study": null,
            "memory_ablation_results": null,
            "comparison_with_other_memory_types": null,
            "key_findings_about_memory_effectiveness": "Using an explicit knowledge graph as the agent's state representation enables RL policies to operate over structured memory and was proposed as a promising direction for end-to-end learning in text-adventure games.",
            "uuid": "e2858.4",
            "source_info": {
                "paper_title": "NAIL: A General Interactive Fiction Agent",
                "publication_date_yy_mm": "2019-02"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Playing text-adventure games with graph-based deep reinforcement learning",
            "rating": 2
        },
        {
            "paper_title": "Language understanding for textbased games using deep reinforcement learning",
            "rating": 2
        },
        {
            "paper_title": "Counting to explore and generalize in text-based games",
            "rating": 2
        },
        {
            "paper_title": "What can you do with a rock? affordance extraction via word embeddings",
            "rating": 1
        },
        {
            "paper_title": "The text-based adventure ai competition",
            "rating": 2
        }
    ],
    "cost": 0.01665725,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>NAIL: A General Interactive Fiction Agent</p>
<p>Matthew Hausknecht 
Microsoft Research AI</p>
<p>Ricky Loynd riloynd@microsoft.com 
Microsoft Research AI</p>
<p>Greg Yang gregyang@microsoft.com 
Microsoft Research AI</p>
<p>Adith Swaminathan 
Microsoft Research AI</p>
<p>Jason D Williams 
Microsoft Research AI</p>
<p>Apple 
Microsoft Research AI</p>
<p>NAIL: A General Interactive Fiction Agent</p>
<p>Interactive Fiction (IF) games are complex textual decision making problems. This paper introduces NAIL, an autonomous agent for general parser-based IF games. NAIL won the 2018 Text Adventure AI Competition, where it was evaluated on twenty unseen games.</p>
<p>Introduction</p>
<p>Interactive Fiction games are rich simulation environments where players issue text commands to control their character and progress through the narrative. Unlike modern video games, there are no graphics; text is the sole modality of interaction. Of the varieties of IF games, this paper is concerned with parser-based IF games, environments in which the player may issue arbitrary textual commands which the game's parser attempts to interpret and execute. Despite this daunting interface, parser-based IF games were highly successful in the early 1980s. Classic games like Zork ( Figure 1) and Hitchhiker's Guide to the Galaxy sparked the imaginations of many and created a community of IF enthusiasts who continue to play and create new games to this day.</p>
<p>As a testbed for autonomous agents, IF games promote natural language understanding, commonsense reasoning, problem solving, and planning. Formally, IF games can be understood as Partially Observable Markov Decision Processes (POMDPs), since they are governed by an underlying system but provide only partial observations of the underlying game state. Game playing agents need to be capable of generating valid actions that make sense in the context of the current story. These actions often take the form of 1) information gathering about the player's surroundings, 2) interaction with nearby objects or people, and 3) navigation between game locations. In return for solving puzzles, the player is rewarded with game score that quantifies advancement through the story.</p>
<p>IF games present several unique challenges to learning agents: First, IF games feature a combinatorial language-based action space. Learning agents have been extensively studied in both discrete and continuous action spaces, but not the repeated discrete space defining IF actions. Second, IF games expect the player to understand how to interact with everyday objects like doors and mailboxes. This form of commonsense reasoning is difficult for learning agents lacking embodiment. Finally, IF games are extremely partially observable -they commonly feature tens to hundreds of unique locations, and the player only receives the description of its current location. Humans often construct a maps to remember how to navigate between rooms and keep track of which objects are in each location. For these reasons, learning agents that excel in graphical video games aren't directly applicable to IF games. Instead, a new type of agent is needed. NAIL (Navigate, Acquire, Interact and Learn) is an autonomous agent designed to play arbitrary human-made IF games. NAIL competed in the 2018 Text-Based Adventure AI Competition (Atkinson et al., 2019), where it was evaluated on twenty unknown IF games, with only one-thousand steps of interaction per game. To excel in this context, NAIL needed to be truly general, with the capability of encountering a new game and quickly accruing as much score as possible. For this reason, we designed NAIL with strong heuristics for exploring the game, interacting with objects, and building an internal representation of the game world. The remainder of this paper describes NAIL's architecture, development process, and innovations.</p>
<p>Related Work</p>
<p>NAIL draws inspiration from previous generations of IF game-playing agents:</p>
<p>BYU'16 Agent (Fulda et al., 2017) analyzes relationships in word-embedding space (Mikolov et al., 2013) to reason about which objects are possible to interact with and which verbs can likely be paired with each interactive object. Armed with this knowledge, the agent exhaustively enumerates possible actions. While effective, this approach is less efficient in terms of the number of in-game steps required.</p>
<p>Golovin (Kostka et al., 2017) generates actions using a large set of predefined command patterns extracted through walkthroughs, tutorials, and decompilation of games. Additionally, it employs specialized command generators for common tasks such as fighting, collecting items, managing inventory, and exploring. An recurrent neural network is used to identify the objects most likely to be interactable in a scene's description.</p>
<p>CARL (Atkinson et al., 2019) was developed by the creators of the BYU Agent and uses skip-thought vectors (Kiros et al., 2015) as representations of the observation text. These vectors are classified as either containing location information or relating to the effects of an action. For those containing location information, commands are generated by extracting nouns from the text and using the BYU Agent's word embedding approach to find likely verbs. A hash table is used to keep track of visited states and actions to avoid repetition.</p>
<p>There is also a growing body of work studying reinforcement learning agents in textual environments: LSTM-DQN (Narasimhan et al., 2015) introduced the idea of building a representation for the current state by processing narrative text with a recurrent network. Building on this idea, LSTM-DRQN (Yuan et al., 2018) added a second level recurrence over states, which was demonstrated to give the agent an ability to reason over locations visited in the past. In the realm of choice-based games, He et al. (2016); Zelinka (2018) explored architectural choices for scoring different pre-defined actions. Another recent innovation included training a separate network to eliminate consideration of invalid actions (Haroush et al., 2018). Finally, Ammanabrolu and Riedl (2018) demonstrated end-to-end learning using an architecture that represents game state as a knowledge graph.</p>
<p>Response p(success) I didn't understand that sentence. 0 You can't go that way. 0 You can't use multiple objects with that verb.</p>
<p>.0008 You try to push past, but vines block your way.</p>
<p>.0009 I don't know the word xyzzy.</p>
<p>.1145 Even with a lamp, you would not chance these stairs in the darkness. .6366 The gentle tapping sounds again.</p>
<p>.9387 Help! You hurtle through the cave opening! .9835 The grating opens.</p>
<p>.9998 The cyclops seems somewhat agitated.</p>
<p>.9998 Table 1: Validity Detector predicts if the game's response to an action indicates success or failure.</p>
<p>Predictions are only concerned with whether or not the action was recognized and effected change in the game. Responses are classified as successful even if they indicate that the player has done something wrong or is likely to die.</p>
<p>Architecture</p>
<p>NAIL was designed with a modular architecture that decouples the decision making from the knowledge acquisition. At the highest level, NAIL utilizes a set of Decision Modules to interact with the game and accumulates information in its knowledge graph. Further separation is achieved by decomposing the overall decision making problem into specialized task-specific Decision Modules, which take control of the agent to perform a particular job when the right context arises. For example, the darkness decision module activates in response to game narratives that include key phrases "pitch black" and "too dark too see," and attempts to provide light by issuing a "turn on" command. Separating decision making from knowledge acquisition enables NAIL's capabilities to be augmented by adding more decision modules while being able to inspect and debug the information accumulated in the knowledge graph. Figure 2 depicts NAIL's architecture, which we discuss in detail below.  </p>
<p>Validity Detector</p>
<p>The game's responses to the agent's actions provide a continual stream of feedback. NAIL processes game responses to determine whether an action was 1) unrecognized by the game, 2) recognized but failed, or 3) recognized and successful. This information is crucial to determining how the Knowledge Graph is populated with Locations and Entities.</p>
<p>The Validity Detector, a FastText (Joulin et al., 2017) classifier, predicts whether the game's response to an action indicates success or failure. The Validity Detector was trained on a manually created dataset of 1337 successful responses and 705 failed responses. Despite the small size of the training dataset, classifier performance was surprisingly good, as shown by the example predictions in Table  1. Many games use a common set of failure responses, simplifying the classification task.</p>
<p>The Validity Detector underlies each of NAIL's core components: it is used by Decision Modules to decide when actions have succeeded and it serves as a gatekeeper to the knowledge graph by disallowing the creation of invalid Entities and Locations.</p>
<p>Decision Modules</p>
<p>NAIL is composed of many decision modules (Fig. 2) which can be thought of as sub-policies designed to accomplish individual tasks. NAIL's core decision modules are the Examiner, Hoarder, Interactor, and Navigator. Respectively they are responsible for identifying relevant objects, acquiring objects, interacting with identified objects, and changing locations. Before delving into the specifics of these core modules, we first discuss the process for synchronizing control between modules.</p>
<p>Choosing Between Decision Modules: Eagerness</p>
<p>Each decision module has the ability to take control of the agent and generate textual actions. Since only a single decision module can have control over the agent at any given timestep, NAIL employs a winner-take-all competition in which decision modules report how eager they are to have control over the agent given the current context. Game context consists of various factors such as information contained within the game narrative and knowledge graph. Different modules are eager in different contexts: the Examiner module is eager to take control when a new location is discovered, while the Interactor is most eager when new objects are added to the knowledge graph. By convention, eagerness values are real numbers constrained to the range (0, 1).</p>
<p>The most eager decision module generates actions until it relinquishes control. Currently there is no mechanism for decision modules to interrupt each other, as this would require the interrupted module to resume control in a different context than before the interrupt. Instead, modules are designed to accomplish many short tasks and relinquish control so as to provide more eager modules many chances to take control.</p>
<p>Examiner Decision Module</p>
<p>One of the fundamental steps in playing IF games is reading the current narrative and deciding which parts of the surroundings are capable of being interacted with. This is the job of the Examiner, a decision module that outputs a high eagerness upon visiting a new location 4 and seeks to identify objects to add to the knowledge graph. Identification of objects proceeds in two steps: first, candidate noun phrases are extracted from the narrative text using Spacy (Honnibal and Montani, 2017). Second, "examine X" commands are issued for each of the candidate noun phrases. If the game's response to the examine command indicates the object is recognized (often in the form of a longer description of that object) the Examiner will add the object to the knowledge graph. Conversely if the response indicates the game doesn't recognize the object, it is not added to the knowledge graph and will not be interacted with in the future. The Validity Detector is used to decide which responses are valid.</p>
<p>Hoarder Decision Module</p>
<p>Acquiring objects such as weapons, treasures, and consumables is a necessity in nearly all IF games. The Hoarder outputs the highest possible eagerness upon reaching a new location. After taking control it issues a single "take all" command. Many games support this shorthand and will reward the player by transporting all portable objects directly into the player's inventory. 5 For example, in Hitchhiker's Guide to the Galaxy:  Figure 3: The Examiner decision module is responsible for extracting game objects from narrative text and adding them to the knowledge graph. Subsequent modules like the Interactor use the objects in the knowledge graph to generate further actions.</p>
<blockquote>
<p>take all telephone: You lunge for it, but the room spins nauseatingly away. flathead screwdriver: It slips through your fumbling fingers and hits the carpet with a nerve-shattering bang. toothbrush: You lunge for it, but the room spins nauseatingly away. your gown: Luckily, this is large enough for you to get hold of. You notice something in the pocket.</p>
</blockquote>
<p>The response indicates four valid objects are present, of which we succeeded in acquiring only the gown. The Hoarder uses a custom parser to add all detected objects to the knowledge graph and the successfully acquired objects to the player's inventory. The Validity Detector decides whether a response indicates the item has been successfully acquired.</p>
<p>Interactor Decision Module</p>
<p>A core challenge of IF games is deciding how to effectively interact with the objects at the current location. Exhaustive search is rarely tractable as even a restricted subset of the English language can produce a combinatorially large set of possible actions. To narrow this search, NAIL uses a 5-gram language model (LM), trained on 1.5 billion n-grams collected from web page titles, 6 to impose a prior over generated actions. As shown in Figure 4, this prior gives preference to common, sensible actions like "open the door" or "light the torch" over less reasonable actions like "light the door" or "open the torch." The Interactor works through the prioritized list of actions in descending order, executing a single action, judging whether it succeeded, and reporting an eagerness score proportional to how highly ranked the next action is.</p>
<p>In more detail, starting from the set of objects present in the player's current location, the Interactor generates an unranked list of candidate actions. These candidate actions are enumerated from two templates: a verb-object template and a verb-object-preposition-object template. 7 Verb-object commands use verbs selected from a manually curated list of 561 commonly recognized IF-game verbs. These verbs are paired with the objects present at the current location and inventory; the LM is then used to compute the joint probability of each generated verb-object pair.</p>
<p>Verb-object-preposition-object commands are also created by iterating over objects x, y present at the current location or in the player's inventory. Ten fixed templates (such as put x in y and open x with y) provide verbs and prepositions for each object pair. These candidate commands are then ranked along with the verb-object actions according to their LM-based joint probabilities. 8 Figure 4: The Interactor ranks candidate actions according to their log-probabilities. These logprobabilities are proportional to the Interactor's eagerness.</p>
<p>Navigator Decision Module</p>
<p>The Navigator is invoked to move the player to a new location. Outputting a consistently low eagerness, the Navigator is intended to activate only after the Hoarder, Examiner, and Interactor have exhausted the useful actions at the current location. After gaining control, the Navigator applies one of the twelve canonical navigation actions: North, South, West, East, Northwest, Northeast, Southwest, Southeast, Up, Down, Enter, and Exit. To avoid repeating failed navigation actions, the Navigator keeps track of all previously attempted navigational actions from each location, and prefers actions that have either not yet been attempted or have succeeded in changing locations in the past. Additionally, since location descriptions frequently tell the player where exits are (e.g. "there is an open door to the west"), the Navigator performs a simple string match and prioritizes directional actions that are present in the description.</p>
<p>After attempting a navigational action the Navigator must decide whether or not the action succeeded and a new location was reached. To do this, it first checks the knowledge graph to see if there are any locations whose textual description matches the game's response. If no known locations are found, the Navigator issues a "look" command and compares the resulting description to the description of the previous location. High similarity between location descriptions indicates that the move action likely failed; low similarity indicates that a new location has likely been discovered.</p>
<p>A fuzzy string match (FuzzyWuzzy, 2011) between location descriptions is necessary since many games randomly alter location descriptions. For example, in the forested locations of Zork 1, the game will occasionally append "You hear in the distance the chirping of a song bird" to the location's description. Similarly, dropped objects will be reported in a location's description.</p>
<p>Finally, to finish a location change, the Navigator updates the Knowledge Graph by adding a new location and connecting it to the previous location. This step results in an ad-hoc map of the game world. In future work, this map could be used to efficiently revisit previous locations or to guide future exploration.</p>
<p>Specialized Decision Modules</p>
<p>NAIL uses several highly specialized decision modules, mainly ensure the agent doesn't get stuck while playing a game.</p>
<p>â€¢ Darkness: Emits a "turn on" action in response to observation text containing phrases "pitch black" or "too dark to see".</p>
<p>â€¢ Restart: Emits a "restart" action to restart the game in response to an observation containing "restart", "restore", and "quit" being observed.</p>
<p>â€¢ Yes-No: Randomly emits either "Yes" or "No" in response to common game prompts asking the player to answer a yes-no question.</p>
<p>â€¢ YouHaveTo: Attempts to take advantage of in-game hints by using a set of custom regular expressions to parse suggested actions from the game's response. For example: "You'll have to get out of bed first" will emit "get out of bed" as the next action. â€¢ Idler: As a fallback when no other decision module is eager for control, the Idler randomly composes actions from hundreds of common verb phrases combined with nearby objects. This exhaustive exploration over possible actions sometimes produces combinations that can get the agent unstuck.</p>
<p>Due to the flexibility of NAIL's architecture it's quite easy to create new decision modules to handle different situations.</p>
<p>Decision Modules as Python Generators</p>
<p>A key design choice was to implement decision modules as Python generators. Using Python's yield to generate actions allows a straight-line implementation of the logic within each DM. Consider the case of a MorningRoutine decision module. Using a generator, the implementation is straightforward:</p>
<p>class In other words, generators allow the agent to be written as if it has direct access to the environment's step function when, in reality, it is being invoked as a library and does not have direct access to the environment. This is commonly the case in competition settings.</p>
<p>Knowledge Graph</p>
<p>NAIL accumulates knowledge about the game world as the agent interacts with the game. Specifically, NAIL's knowledge graph keeps track of objects, past interactions, locations, connections between locations, object states, and unrecognized words. This information is used by decision modules to compute eagerness and generate actions. In turn, the decision modules modify the knowledge graph to reflect the consequences of their actions.</p>
<p>At the top level, the knowledge graph is organized as follows:</p>
<p>â€¢ Current Location: Player's current location, updated by the Navigator upon successful movement.</p>
<p>â€¢ Locations: List of all discovered locations.</p>
<p>â€¢ Connection Graph: Graph of connections between discovered locations. Updated by the Navigator upon successful movement. â€¢ Inventory: List of objects in the player's inventory. Updated by any decision module that issues take/drop commands. â€¢ Unrecognized Words: List of words not recognized by the game. NAIL avoids taking actions containing any unrecognized words. Updated after each action by matching the game's response against a custom list of unrecognized responses (e.g. "That's not a verb I recognise.").</p>
<p>Each Location contains the following information:</p>
<p>â€¢ Name: The short name of the location (e.g. "West of House").</p>
<p>â€¢ Description: The full-length description of the location, as returned by a "look" command. Populated by the Navigator upon discovering the location. â€¢ Entities: List of entities (interactive objects or characters) present at that location. Populated by the Examiner. â€¢ Action Record: List of all actions NAIL has attempted at this location along with the game's response and NAIL's estimate of how likely the response indicates success. This information is optionally used by decision modules to avoid repeating actions that previously failed.</p>
<p>Finally, each Entity contains the following information:</p>
<p>â€¢ Names: List of discovered names for this entity. Many games are flexible when referring to entities -e.g. the Brass Lantern in Zork may be alternatively referred to as "lantern" or even just "brass." â€¢ Description: Long-form description of the entity -as given by "examine entity." Populated by Examiner. â€¢ Entities: List of contained entities -e.g. in the case of a container such as a chest.</p>
<p>â€¢ State: Keeps track of a list of manually-defined states: Open/Closed, Locked/Unlocked, On/Off. Also keeps track of whether the item has been used -in the case of consumable items. â€¢ Attributes: A manually-defined list of object attributes: Openable, Lockable, Switchable.</p>
<p>Attributes inform which verbs are expected to succeed on a particular object.</p>
<p>Beyond its use to Decision Modules, the knowledge graph also provides an interpretable representation of NAIL's understanding of the game. By comparing the knowledge graph to the published map for well documented games like Zork, it was possible to track down bugs in NAIL's decision modules.</p>
<p>Encoding Action Effects</p>
<p>The core interaction for many games relies heavily on a small set of common actions -take, drop, turn on, push, pull, go north, etc. Furthermore, the effects of these common actions are reasonably general across games. For example, the take action, if successful, will move an object from the player's current location to the player's inventory.</p>
<p>For these common actions, the expected changes to the knowledge graph are manually implemented and associated with the action. This association allows the effects of the action to be implemented once, and subsequently used by many different decision modules. For non-common actions, we do not make any changes to the knowledge graph, aside from recording the action and its probability of success. In future work, it may be possible to learn the effects of uncommon actions.</p>
<p>Text-Adventure Competition</p>
<p>To meet the needs of generality and efficient exploration of unseen games, we developed and evaluated NAIL on a set of fifty-six IF games (full list in Table 3) using the Jericho (2018) Learning Environment.</p>
<p>Jericho was a ideal learning environment because of its ability to introspect and provide ground truth knowledge of the game state. Our primary metric was normalized game score averaged over all games. However, due to the sparse rewards in most games, improvements to the NAIL agent often weren't reflected in game score. To address this problem, we created Dependencies, a fine-grained metric that quantifies progress towards the first point of score on each game. Specifically this metric manually defines the locations needed to be visited, the items that need to be acquired, entities that need to be detected, and the key actions that must be performed. The following snippet shows the Dependencies for the game Balances:</p>
<p>analyzer To satisfy the Entity Dependency (EntDep), the agent must detect an Entity called "furniture" or "wooden furniture" at Location 49. This dependency is verified by using Jericho's introspection feature to detect when the agent visits the location corresponding to world object number 49, and looking into the Knowledge Graph for an Entity named furniture at the KG's current Location. The Action Dependency (ActDep) "search furniture" is satisfied upon receiving a new observation that contains the text "you come across an old box." This is verified simply by monitoring the incoming observations through the event stream. Simple text matching is sufficient to recognize the results of key actions that progress the game. The Location Dependency (LocDep) is satisfied when the agent visits location number 53 (aka Pocket Valley). Locations are verified by using Jericho to inspect the game and return the world object number corresponding to the player's actual location. Finally the Inventory Dependency (InvDep) is satisfied when the world object number 62 exists in the player's inventory. This is verified using Jericho to access the list of world objects belonging to the player. We implemented Dependencies for each of the fifty-six games in the Jericho suite. Figure 5 shows that these Dependencies help quantify progress and more importantly, help pinpoint exactly which parts of the agent need to be improved: if the agent is failing ActDeps, then perhaps the Interactor needs to use a different set of verbs, conversely if NavDeps are failing, a bug may have entered the Navigator.</p>
<p>Results</p>
<p>NAIL won first place in the 2018 Text-Based Adventure AI Competition Atkinson et al. (2019), where it was evaluated on a set of twenty unknown parser-based IF games. Designed to assess an agent's ability to achieve human-like performance, the competition only allowed one thousand steps of interaction per game, comparable to a few hours of playtime for a human. Each agent's scores were normalized by the maximum possible score per game, then averaged over all games to obtain the final scores shown in Table 2 Table 2: Performance on the test set of 20 games in (unless stated otherwise) 1000 time steps per game. "% completion" is the average score percentage an agent achieved over all games and runs; "% non-zero" is the percentage of games in which an agent achieved any score, averaged over all runs. Standard deviations (SD), wherever given, refer to 10 runs over all games. Where they are not given, only 1 run could be completed. </p>
<p>Analysis</p>
<p>As apparent from the competition results, agents have a long way to go towards solving unseen games. However, the progress over the past three years of the competition is encouraging. NAIL advances the state-of-the-art in comparison to other agents in several ways:</p>
<ol>
<li>
<p>NAIL maintains an explicit Knowledge Graph which tracks relevant game information and builds a map of the game world. The information contained within is both used and populated by decision modules as the game progresses. This knowledge representation is human-interpretable and debuggable given ground-truth information about the game.</p>
</li>
<li>
<p>Unlike prior agents, NAIL leverages the intuition that interactive objects can be examined, and extensively uses its Examiner decision module as a gatekeeper for deciding which objects are worth interacting with. Across the training set of 56 games, 26% of NAIL's actions are Examines, versus 8% for CARL, 2% for Golovin, and only 0.2% for BYU. By exhaustively examining candidate objects, NAIL can focus actions on only the objects that are recognized by the game's parser.</p>
</li>
<li>
<p>NAIL is the first agent to use a Validity Detector, a learned model, to decide whether actions have succeeded. This model is key to correctly populating the Knowledge Graph and is used extensively by individual decision modules to reason about the success of their actions.</p>
</li>
</ol>
<p>To further understand NAIL's performance, we selectively ablate NAIL's decision modules. Figure 6 shows the average normalized score of NAIL across Jericho games as decision modules are sequentially added. Without any decision modules, NAIL is capable of only performing the "look" command and gets a score of 0.53%, since some games start with small positive score. Adding the Navigator allows the agent to locomote and create a map of the game world. Using this module, scores go up to 1.2%, primarily due to games that reward visiting new locations. Next, the Hoarder issues "take all" commands at each new location it visits to collect items. Scores increase to 1.6% since many games reward the player for acquiring treasures or key items. Adding the Examiner module allows the agent to more deeply search the environment and reason about which objects are interactive, boosting the score to 2.6%. Leveraging the objects identified by the Examiner, the Interactor uses its language model to generate likely actions for application to those objects. These interactions are key to solving puzzles and boost the score to 3.5%. Together, these modules make up NAIL's core and account for the lion's share of the score. A 0.2% gain is added by the Idler which exhaustively generates common IF actions when no other module is eager to take control. Finally, the specialized decision modules together contribute 0.03%.</p>
<p>Discussion</p>
<p>Interactive Fiction games are rich narrative adventures that challenge even skilled human players. We presented NAIL, an open-source, 9 competition-winning IF agent. More than just a baseline for future comparison, we expect that NAIL's extendable architecture can serve as a starting point for future IF agents.    : Analysis of walkthroughs reveals that over 90% of actions are one and two words in length. Among these actions, there were 530 unique verbs used, but the 100 most common account for 95% of all actions.</p>
<p>A Analysis of Parser-Based IF Games</p>
<p>Perhaps the least friendly user interface of all time, parser-based IF games accept any natural language string as input, and use a parser to interpret the player's action. The difficulty of using the interface stems from the fact that many natural language strings are not recognized by the parser and result in failed actions. For example, many games will produce canned responses such as "I don't know the word x." or "You can't y." Since the parser is hidden, players often need to read a manual and experiment with the game to discover what types of actions are recognized. Fortunately, parsers for many popular IF games are similar in the types of actions they accept and the responses they produce for unrecognized actions. This standardization reduces the burden on learning agents, as they do not have to generate arbitrarily complex natural language.</p>
<p>To better understand the complex action space of parser-based games, we analyzed human-created walkthroughs for 188 games. From these walkthroughs we extracted 20,263 natural language actions. As shown in Figure 7 (left), most actions are one or two words in length, with a maximum of five words 10 . Further analysis reveals that these actions have extensive structure: single-word actions are often shortcuts provided by the game for navigation ("north" moves the player north), examination ("look" describes the current location), and item management ("inventory" lists the objects carried). Two-word actions take the form of verb-object ("climb tree", "eat apple"). Three-word actions are commonly verb-preposition-object ("search under bed"), but can occasionally take on different patterns ("turn dial left"). Though uncommon, four-word actions include the pattern verb-objectpreposition-object ("unlock chest with key", "ask bolitho about ghost"). Five-word actions commonly used multiple words to describe an object: "attack troll with brass lantern."</p>
<p>The verb distribution shows that the majority of actions stem from a compact set of verbs focused on navigation, item acquisition, and environment examination. However, the distribution in Figure  7 (right) has a long tail corresponding to a diverse set of verbs used to interact with objects in the environment. The nouns used in these commands are highly varied from game to game. Some games even go so far as to create their own proper nouns for special objects and spells. Such words are not in any English dictionary and need to be remembered from the observation text.</p>
<p>Altogether, this analysis indicates that the action generation task in IF games is significantly more structured than generating free-form dialog. Thus, while learning agents still need to understand arbitrary free-form text presented by the game, they only need to generate a compact subset of language.</p>
<p>Figure 1 :
1Interactive fiction games made Infocom the dominant computer game company of the early 1980s. Right: Transcript of Zork, with player actions in green.</p>
<p>Figure 2 :
2NAIL consists of multiple Decision Modules, which are designed to perform specialized tasks. One decision module at a time may be active. The active module is responsible for generating actions and updating the knowledge graph with the effects of its actions. The knowledge graph builds a structured representation of the objects, locations, and interactions observed in the game so far and is used by the decision modules to select actions.</p>
<p>. deps = [ EntDep ([ ' wooden furniture ' , ' furniture '] , loc =49) , ActDep ( ' search furniture ' , ' you come across an old box ') , LocDep ( ' pocket valley ' , loc =53) , EntDep ([ ' pile of oats ' , ' oats ' , ' pile '] , loc =53) , ActDep ( ' search oats ' , ' You find a shiny scroll ! ') , InvDep ( ' shiny scroll ' , 62) ]</p>
<p>Figure 5 :
5Development of NAIL on fifty-six human-made IF games: The blue line tracks normalized game score while the orange shows the percentage of dependencies that are satisfied. The x-axis tracks the 32 commits made to NAIL after the implementation of game-specific Dependencies.</p>
<p>Figure 6 :
6Ablation of decision modules: Largest performance increases come from NAIL's core decision modules: the Navigator, the Examiner, and the Interactor.</p>
<p>Figure 7
7Figure 7: Analysis of walkthroughs reveals that over 90% of actions are one and two words in length. Among these actions, there were 530 unique verbs used, but the 100 most common account for 95% of all actions.</p>
<p>Without a generator the logic for the same DM becomes quite a bit more complex:MorningRoutine ( DecisionModule ): 
def take_control ( self ): 
obs = yield 
obs = yield ' get out of bed ' 
obs = yield ' turn on light ' 
obs = yield ' brush teeth ' </p>
<p>class MorningRoutine ( DecisionModule ): 
def <strong>init</strong> ( self ): 
self . out_of_bed = False 
self . turned_on_light = False 
self . brushed_teeth = False </p>
<p>def take_control ( self , obs ): 
if not self . out_of_bed : 
self . out_of_bed = True 
return ' get out of bed ' 
elif not self . turned_on_light : 
self . turned_on_light = True 
return ' turn on light ' 
elif not self . brushed_teeth : 
self . brushed_teeth = True 
return ' brush teeth ' </p>
<p>.Agent 
% completion % non-zero </p>
<p>M 
SD 
M 
SD </p>
<p>BYUAGENT 2016 
0.79 
-
15 
-
GOLOVIN 
1.45 
0.09 
31 3.94 
CARL (BYUAGENT 2017) 1.59 
-
30 
-
NAIL 
2.56 
0.33 45.5 2.84 </p>
<p>GOLOVIN (100 steps) 
0.99 
0.24 17.5 3.53 
NAIL (100 steps) 
0.95 
0.19 
26 2.11 
GOLOVIN (10k steps) 
1.44 
0.10 32.5 4.25 </p>
<p>RandomAgent 
1.66 
0.15 
34 2.11 </p>
<p>Table duplicatedfromAtkinson et al. (2019).</p>
<p>Table 3 :
3Raw scores for Jericho-supported games, averaged over sixteen runs. The Random agent selects actions from the set north/south/east/west/up/down/look/inventory/take all/drop/yes.
More precisely upon a new Location object being added to the knowledge graph. 5 For the games that don't support the take all command, objects may still be acquired individually using the Interactor decision module.
Although language used in web titles is definitely not the same as actions in IF games, in terms of both speed and perplexity, LMs trained on titles have been reported to outperform LMs trained on document body text on general information retrieval tasks(Wang et al., 2010).7  As discussed in Appendix A, the vast majority of actions taken by human players can be expressed by one of these two templates.
LM probabilities for two-word actions are nearly always higher than four-word actions. Fortunately, as shown inFigure 7, humans also prefer shorter actions.
All actions with six words or longer were reducible to equivalent shorter actions.
AcknowledgementsThe authors would like to thank Marc-Alexandre CÃ´tÃ©, Xingdi Yuan, and Alekh Agarwal for their comments and suggestions. Additional thanks to Shuohang Wang for testing models for learning priorities over examined objects.
Playing text-adventure games with graph-based deep reinforcement learning. CoRR. Prithviraj Ammanabrolu, Mark O Riedl, abs/1812.01628Prithviraj Ammanabrolu and Mark O. Riedl. Playing text-adventure games with graph-based deep reinforcement learning. CoRR, abs/1812.01628, 2018. URL http://arxiv.org/abs/1812. 1628.</p>
<p>The text-based adventure ai competition. T Atkinson, H Baier, T Copplestone, S Devlin, J Swan, 10.1109/TG.2019.2896017IEEE Transactions on Games. T. Atkinson, H. Baier, T. Copplestone, S. Devlin, and J. Swan. The text-based adventure ai competition. IEEE Transactions on Games, pages 1-1, 2019. ISSN 2475-1502. doi: 10.1109/TG.2019.2896017.</p>
<p>What can you do with a rock? affordance extraction via word embeddings. Nancy Fulda, Daniel Ricks, Ben Murdoch, David Wingate, 10.24963/ijcai.2017/144doi: 10.24963/ ijcai.2017/144IJCAI. Nancy Fulda, Daniel Ricks, Ben Murdoch, and David Wingate. What can you do with a rock? affordance extraction via word embeddings. In IJCAI, pages 1039-1045, 2017. doi: 10.24963/ ijcai.2017/144. URL https://doi.org/1 .24963/ijcai.2 17/144.</p>
<p>Fuzzy string matching in python. Fuzzywuzzy, FuzzyWuzzy. Fuzzy string matching in python. https://github.com/seatgeek/fuzzywuzzy, 2011.</p>
<p>Learning how not to act in text-based games. Matan Haroush, Tom Zahavy, Daniel J Mankowitz, Shie Mannor, Matan Haroush, Tom Zahavy, Daniel J. Mankowitz, and Shie Mannor. Learning how not to act in text-based games, 2018. URL https://openreview.net/forum?id=B1-tVX1Pz.</p>
<p>Deep reinforcement learning with a natural language action space. Ji He, Jianshu Chen, Xiaodong He, Jianfeng Gao, Lihong Li, Li Deng, Mari Ostendorf, ACL. Ji He, Jianshu Chen, Xiaodong He, Jianfeng Gao, Lihong Li, Li Deng, and Mari Ostendorf. Deep reinforcement learning with a natural language action space. In ACL, 2016.</p>
<p>spacy 2: Natural language understanding with bloom embeddings, convolutional neural networks and incremental parsing. Matthew Honnibal, Ines Montani, To appear, 2017. 9 NAIL's source code is available atMatthew Honnibal and Ines Montani. spacy 2: Natural language understanding with bloom embed- dings, convolutional neural networks and incremental parsing. To appear, 2017. 9 NAIL's source code is available at https://github.com/Microsoft/nail_agent. 11</p>
<p>A learning environment for interactive fiction games. Jericho, Jericho, Jericho. Jericho: A learning environment for interactive fiction games. https://github.com/ Microsoft/jericho, 2018.</p>
<p>Bag of tricks for efficient text classification. Armand Joulin, Edouard Grave, Piotr Bojanowski, Tomas Mikolov, EACL. Association for Computational LinguisticsArmand Joulin, Edouard Grave, Piotr Bojanowski, and Tomas Mikolov. Bag of tricks for efficient text classification. In EACL, pages 427-431. Association for Computational Linguistics, April 2017.</p>
<p>Skip-thought vectors. Ryan Kiros, Yukun Zhu, R Ruslan, Richard Salakhutdinov, Raquel Zemel, Antonio Urtasun, Sanja Torralba, Fidler, NIPS. C. Cortes, N. D. Lawrence, D. D. Lee, M. Sugiyama, and R. GarnettCurran Associates, IncRyan Kiros, Yukun Zhu, Ruslan R Salakhutdinov, Richard Zemel, Raquel Urtasun, Antonio Torralba, and Sanja Fidler. Skip-thought vectors. In C. Cortes, N. D. Lawrence, D. D. Lee, M. Sugiyama, and R. Garnett, editors, NIPS, pages 3294-3302. Curran Associates, Inc., 2015. URL http: //papers.nips.cc/paper/595 -skip-thought-vectors.pdf.</p>
<p>Text-based adventures of the golovin AI agent. CoRR, abs/1705.05637. Bartosz Kostka, Jaroslaw Kwiecien, Jakub Kowalski, Pawel Rychlikowski, Bartosz Kostka, Jaroslaw Kwiecien, Jakub Kowalski, and Pawel Rychlikowski. Text-based adventures of the golovin AI agent. CoRR, abs/1705.05637, 2017. URL http://arxiv.org/abs/17 5. 5637.</p>
<p>Efficient estimation of word representations in vector space. Tomas Mikolov, Kai Chen, Greg Corrado, Jeffrey Dean, abs/1301.3781CoRR. Tomas Mikolov, Kai Chen, Greg Corrado, and Jeffrey Dean. Efficient estimation of word representa- tions in vector space. CoRR, abs/1301.3781, 2013. URL http://arxiv.org/abs/13 1.3781.</p>
<p>Language understanding for textbased games using deep reinforcement learning. Karthik Narasimhan, Tejas D Kulkarni, Regina Barzilay, EMNLP. Karthik Narasimhan, Tejas D. Kulkarni, and Regina Barzilay. Language understanding for text- based games using deep reinforcement learning. In EMNLP, pages 1-11, 2015. URL http: //aclweb.org/anthology/D/D15/D15-1 1.pdf.</p>
<p>Multi-style language model for web scale information retrieval. Kuansan Wang, Xiaolong Li, Jianfeng Gao, SIGIR'10. Kuansan Wang, Xiaolong Li, and Jianfeng Gao. Multi-style language model for web scale information retrieval. In SIGIR'10, pages 467-474, 2010. URL https://dl.acm.org/citation.cfm?id= 1835528.</p>
<p>Counting to explore and generalize in text-based games. CoRR, abs/1806.11525. Xingdi Yuan, Marc-Alexandre CÃ´tÃ©, Alessandro Sordoni, Romain Laroche, Remi Tachet, Matthew J Combes, Adam Hausknecht, Trischler, Xingdi Yuan, Marc-Alexandre CÃ´tÃ©, Alessandro Sordoni, Romain Laroche, Remi Tachet des Combes, Matthew J. Hausknecht, and Adam Trischler. Counting to explore and generalize in text-based games. CoRR, abs/1806.11525, 2018. URL http://arxiv.org/abs/18 6.11525.</p>
<p>Using reinforcement learning to learn how to play text-based games. MikulÃ¡s Zelinka, abs/1801.01999MikulÃ¡s Zelinka. Using reinforcement learning to learn how to play text-based games. CoRR, abs/1801.01999, 2018. URL http://arxiv.org/abs/18 1. 1999.</p>            </div>
        </div>

    </div>
</body>
</html>