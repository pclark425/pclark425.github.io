<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-1610 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-1610</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-1610</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-31.html">extraction-schema-31</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <p><strong>Paper ID:</strong> paper-26589025</p>
                <p><strong>Paper Title:</strong> <a href="https://hal.archives-ouvertes.fr/hal-00111336/file/Ratle2001.pdf" target="_blank">Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics</a></p>
                <p><strong>Paper Abstract:</strong> Although genetic programming has often successfully been applied to non-parametric modeling, it is frequently impaired by the huge size of the search space explored. Domain knowledge is a powerful way to trim out the size of the space, by restricting the search to a priori relevant models. A most natural domain knowledge in scientiﬁc modeling is known as dimensional analysis, stipulating that the models must be consistent with regards to the variable measurement units. In this paper,itis shown thatdimensional analysis can automatically be expressed as a context free grammar.Dimensionally-aware GP is thus achieved by employing the dimensional grammar within the grammar-guided GP framework ﬁrst investigated by Gruau [On using syntactic constraints with genetic programming, in: P. Angeline, K.E. Kinnear Jr. (Eds.), Advances in Genetic Programming II, MIT Press, Cambridge, MA, 1996, pp. 377–394.]. However, grammar-guided genetic programming encounters severe difﬁculties when it involves a complex grammar, which mightexplainwhythisapproachhasnotbeenwidelyusedsofar.Thedrawbackisblamedontheinitializationstep,whichhardly constructsasufﬁcientlydiversiﬁedinitialpopulation,thushinderingthesuccessofevolution.Thislimitationisaddressedby anewCFGcompliantinitializationprocedure. The approach is validated on two problems related to the identiﬁcation of mechanical properties of materials.</p>
                <p><strong>Cost:</strong> 0.015</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e1610.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e1610.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Canonical GP</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Canonical Genetic Programming (GP)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Tree-structured evolutionary algorithm that evolves symbolic expressions/programs via subtree crossover and mutation; fitness is task-dependent (here, sum-of-squared errors to experimental curves).</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Canonical Genetic Programming</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Standard GP evolving expression trees (phenotypes). Individuals are parse trees built from function/operator nodes and terminal leaves. Evolution uses population initialization, fitness evaluation, selection, phenotype crossover (swap expression subtrees between parents) and phenotype mutation (replace a subtree by a randomly generated subtree or perform point mutation on terminals). The closure assumption (any subtree return is valid for any operator) is used, allowing simple operators but producing very large, unconstrained search spaces.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs/expressions (symbolic mathematical expressions)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Phenotypic subtree crossover: select a random subtree node in parent A (an expression-tree node) and a random subtree node in parent B (without type constraints) and swap the subtrees to create two offspring; crossover operates on expression trees (phenotypes).</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Phenotypic mutation: replace a randomly selected subtree by a newly generated random subtree (or perform point mutation on a terminal); paper describes mutation as applying crossover between a parent and a randomly generated tree.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Quadratic distance (sum of squared errors) between experimental curves and learned functions (fitness to be minimized).</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>Kelvin-Voigt benchmark: average best fitness after 2,000,000 evaluations = 100.8 (SD 9.2) (Table 3). Exact solution not found in any run.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Scientific discovery / non-parametric identification in mechanics (rheological models: Kelvin-Voigt and four-element models; force-displacement/time curve fitting).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Compared against grammar-guided GP variants (universal-exn, dimensional-exn grammars / G3P) and used as the universal-grammar baseline.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Canonical GP explores a very large unconstrained search space due to closure hypothesis, lacks dimensional/type constraints and thus includes many irrelevant individuals; performs worse (higher SSE) than grammar-constrained approaches on the rheological identification tasks; initialization quality strongly affects performance.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics', 'publication_date_yy_mm': '2001-06'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1610.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e1610.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>G3P</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Grammar-Guided Genetic Programming (G3P)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A GP variant that uses context-free grammars (CFGs) to declaratively constrain the admissible program space; genotypes are derivation trees and crossover/mutation operate on grammar-nonterminals to preserve grammatical correctness.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Grammar-Guided Genetic Programming (G3P)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>GP generalized to enforce syntactic/domain constraints via a context-free grammar. Individuals have genotypes (derivation trees) and phenotypes (parsed expression trees). CFG defines admissible programs (e.g. enforces dimensional consistency). Evolutionary operators are made grammar-compliant: genotypic crossover and genotypic mutation swap or replace subtrees that correspond to the same non-terminal symbols, guaranteeing offspring remain in the admissible language. An enhanced CFG-compliant initialization (dynamic masking based on minimal derivation depth indices) is used to uniformly sample admissible individuals within a maximum tree depth.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs/expressions (symbolic mathematical expressions derived from a CFG)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Genotypic crossover on derivation trees: select uniformly a node labeled with a non-terminal symbol N_u in parent A; if parent B contains at least one node with the same symbol N_u pick one uniformly and swap the corresponding subtrees (derivation subtrees). If no matching symbol in parent B, the crossover is rejected. This enforces grammatical consistency in offspring.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Genotypic mutation: select uniformly a node carrying a non-terminal N_u and replace the subtree rooted at that node with a randomly generated derivation (an expression rewriting N_u), i.e. equivalent to crossover with a random valid parent for that non-terminal.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Quadratic distance (sum of squared errors) between experimental curves and learned functions (fitness).</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>Dimensional-exn grammar (G3P with dimensional constraints and negative-exponential operator) on Kelvin-Voigt: average best fitness after 2,000,000 evaluations = 39.4 (SD 5.9) (Table 3). Exact solution not found.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Initialization-focused genotypic/grammar-aware uniform sampling (qualitative): dynamic masking uses minimal derivation-depth indices to ensure all sampled individuals are admissible and to avoid oversize trees; paper aims at genotypic diversity in the initial population but provides no numeric diversity metric.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td>Qualitative: the CFG-compliant initialization with dynamic masking produces a diversified initial population uniformly sampled among admissible derivations and prevents oversize trees; no quantitative diversity numbers reported.</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Discussed qualitatively: imposing stronger grammatical/domain constraints (reducing search space) improves executability (lower SSE) but reduces the raw search space size; no explicit quantitative tradeoff curve provided.</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Scientific discovery / non-parametric identification in mechanics (same rheological benchmarks as canonical GP).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Compared against canonical GP (universal grammar) and variants (universal-exn grammar).</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>CFGs can encode dimensional consistency and other syntactic constraints, drastically reducing the search space; genotypic crossover can make fine-grained (operator-only) changes that phenotypic crossover cannot; enforcing dimensional grammar (dimensional-exn) significantly improves fitness (Table 3); however, grammar-guided GP can perform poorly if initialization does not sample a diverse admissible population—addressed here by a dynamic masking initialization heuristic which restored diversity and usability.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics', 'publication_date_yy_mm': '2001-06'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1610.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e1610.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>STGP</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Strongly-Typed Genetic Programming (STGP)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A GP variant that attaches type labels to terminals and operator arguments so that crossover and mutation only exchange/replace subtrees of matching types, enforcing type safety and restricting search.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Strongly-Typed Genetic Programming</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>STGP associates type labels to every terminal and operator argument; genetic operators are constrained so that crossover swaps subtrees of identical type and mutation replaces a subtree with a random subtree of the same type, thereby preventing type errors and reducing the search space.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs/expressions (typed symbolic expressions)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Type-constrained subtree crossover: swap subtrees between parents only when the selected subtrees have the same type label.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Type-constrained subtree mutation: replace a subtree by a random subtree of the same type.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Mentioned as a framework for encoding typing constraints in GP; not experimentally evaluated in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Mentioned in relation to grammar-guided GP as a predecessor/related approach.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>STGP is straightforward to adapt crossover/mutation to respect syntactic/type constraints, but such constraints can make initialization more difficult; cited as conceptual background for G3P.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics', 'publication_date_yy_mm': '2001-06'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1610.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e1610.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Grammatical Evolution</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Grammatical Evolution (GE)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An evolutionary approach that maps linear genomes to programs in an arbitrary language using a user-specified grammar, enabling evolution of programs for particular target languages via grammatical decoding.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Grammatical Evolution</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>GE evolves linear genomes (typically integer sequences) which are decoded using a context-free grammar to produce programs in a target language; genetic operators act on the linear genome, while the grammar ensures syntactic validity of decoded programs.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs/expressions (decoded from genome via CFG)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Genome-level crossover: standard linear-genome crossover operators applied on encoded genomes; offspring genomes are decoded through a grammar to produce syntactically valid programs (paper references GE but does not detail operators).</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Genome-level mutation: standard point mutations on the genotype (integers), followed by grammar-based decoding to programs.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Mentioned as related work on grammar-based GP approaches; not used in experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Mentioned among grammar/CFG-based GP approaches (Ryan et al.).</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>GE is an alternative grammar-based GP approach; cited as related work but not evaluated in this study.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics', 'publication_date_yy_mm': '2001-06'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1610.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e1610.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Dimensional-Aware GP (Keijzer & Babovic)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Dimensionally Aware Genetic Programming (Keijzer & Babovic)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A GP approach encoding the dimensionality of expressions with labels listing exponents of base units, constraining production and requiring ad-hoc initialization routines (e.g., DimTransform) when target labels have no direct terminals.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Dimensionally Aware Genetic Programming (label-based)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Encodes compound units as exponent vectors and attaches dimensional labels to subtrees; operator application must respect label arithmetic (e.g., addition requires same unit), and initialization may need ad-hoc transformation functions (DimTransform) to generate subtrees of required labels when no terminal matches directly.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs/expressions (dimension-labeled symbolic expressions)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Type/dimension-constrained crossover: swap subtrees only when dimensional labels match (implementation details referenced from original work).</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Dimension-constrained mutation: replace subtree with another of the same dimensional label; paper notes special initialization (DimTransform) may introduce non-physical constructs.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Mentioned as prior dimensional-consistency approach in GP (related to the dimensional grammar developed in this paper).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Cited as an alternative to grammar-based encoding of dimensional constraints; noted drawbacks in initialization requiring DimTransform and penalization.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>The paper contrasts its CFG-based automatic grammar generator encoding dimensional consistency with Keijzer & Babovic's label-based approach, arguing that CFG encoding avoids ad-hoc initialization transforms and better preserves physical meaning.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics', 'publication_date_yy_mm': '2001-06'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1610.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e1610.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>CFG Init (dynamic masking)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>CFG-compliant Initialization with Dynamic Masking</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An initialization heuristic introduced in this paper that computes minimal derivation-depth indices and dynamically masks derivations that would exceed a maximum tree depth, enabling uniform sampling of admissible small trees under complex grammars.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>CFG-compliant Initialization (dynamic masking)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>For each non-terminal and derivation compute the minimal depth (index) needed to reach a terminal expansion. During top-down derivation, at a node at current depth m only allow derivations whose index <= D_max - m; select uniformly among those allowed. This avoids constructing oversized trees and yields diversified admissible individuals for grammars where terminal derivations are rare.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs/expressions (derivation trees from CFG)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Initialization uniformity / genotypic diversity (qualitative): ensures uniform sampling among admissible derivations under depth limit.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td>Qualitative: produces a sufficiently diversified initial population within the allowed maximum tree size and prevents oversized trees; no numerical diversity measures provided.</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Used within G3P experiments for rheological model identification; addresses initialization difficulties arising from complex grammars (e.g., dimensional grammar).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Contrasted with naive/uniform CFG sampling which tends to produce oversize trees or poorly diversified populations; cited literature that initialization quality impacts results (Daida et al.).</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Dynamic masking using minimal derivation-depth indices resolves poor-initialization problems in grammar-guided GP, enabling uniform sampling of admissible individuals and improving evolutionary outcomes under complex grammars.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics', 'publication_date_yy_mm': '2001-06'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>On using syntactic constraints with genetic programming <em>(Rating: 2)</em></li>
                <li>Dimensionally aware genetic programming <em>(Rating: 2)</em></li>
                <li>Grammatical evolution: evolving programs for an arbitrary language <em>(Rating: 2)</em></li>
                <li>Strongly typed genetic programming <em>(Rating: 2)</em></li>
                <li>Genetic Programming: On the Programming of Computers by Means of Natural Evolution <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-1610",
    "paper_id": "paper-26589025",
    "extraction_schema_id": "extraction-schema-31",
    "extracted_data": [
        {
            "name_short": "Canonical GP",
            "name_full": "Canonical Genetic Programming (GP)",
            "brief_description": "Tree-structured evolutionary algorithm that evolves symbolic expressions/programs via subtree crossover and mutation; fitness is task-dependent (here, sum-of-squared errors to experimental curves).",
            "citation_title": "Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics",
            "mention_or_use": "use",
            "system_name": "Canonical Genetic Programming",
            "system_description": "Standard GP evolving expression trees (phenotypes). Individuals are parse trees built from function/operator nodes and terminal leaves. Evolution uses population initialization, fitness evaluation, selection, phenotype crossover (swap expression subtrees between parents) and phenotype mutation (replace a subtree by a randomly generated subtree or perform point mutation on terminals). The closure assumption (any subtree return is valid for any operator) is used, allowing simple operators but producing very large, unconstrained search spaces.",
            "input_type": "programs/expressions (symbolic mathematical expressions)",
            "crossover_operation": "Phenotypic subtree crossover: select a random subtree node in parent A (an expression-tree node) and a random subtree node in parent B (without type constraints) and swap the subtrees to create two offspring; crossover operates on expression trees (phenotypes).",
            "mutation_operation": "Phenotypic mutation: replace a randomly selected subtree by a newly generated random subtree (or perform point mutation on a terminal); paper describes mutation as applying crossover between a parent and a randomly generated tree.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Quadratic distance (sum of squared errors) between experimental curves and learned functions (fitness to be minimized).",
            "executability_results": "Kelvin-Voigt benchmark: average best fitness after 2,000,000 evaluations = 100.8 (SD 9.2) (Table 3). Exact solution not found in any run.",
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Scientific discovery / non-parametric identification in mechanics (rheological models: Kelvin-Voigt and four-element models; force-displacement/time curve fitting).",
            "comparison_baseline": "Compared against grammar-guided GP variants (universal-exn, dimensional-exn grammars / G3P) and used as the universal-grammar baseline.",
            "key_findings": "Canonical GP explores a very large unconstrained search space due to closure hypothesis, lacks dimensional/type constraints and thus includes many irrelevant individuals; performs worse (higher SSE) than grammar-constrained approaches on the rheological identification tasks; initialization quality strongly affects performance.",
            "uuid": "e1610.0",
            "source_info": {
                "paper_title": "Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics",
                "publication_date_yy_mm": "2001-06"
            }
        },
        {
            "name_short": "G3P",
            "name_full": "Grammar-Guided Genetic Programming (G3P)",
            "brief_description": "A GP variant that uses context-free grammars (CFGs) to declaratively constrain the admissible program space; genotypes are derivation trees and crossover/mutation operate on grammar-nonterminals to preserve grammatical correctness.",
            "citation_title": "Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics",
            "mention_or_use": "use",
            "system_name": "Grammar-Guided Genetic Programming (G3P)",
            "system_description": "GP generalized to enforce syntactic/domain constraints via a context-free grammar. Individuals have genotypes (derivation trees) and phenotypes (parsed expression trees). CFG defines admissible programs (e.g. enforces dimensional consistency). Evolutionary operators are made grammar-compliant: genotypic crossover and genotypic mutation swap or replace subtrees that correspond to the same non-terminal symbols, guaranteeing offspring remain in the admissible language. An enhanced CFG-compliant initialization (dynamic masking based on minimal derivation depth indices) is used to uniformly sample admissible individuals within a maximum tree depth.",
            "input_type": "programs/expressions (symbolic mathematical expressions derived from a CFG)",
            "crossover_operation": "Genotypic crossover on derivation trees: select uniformly a node labeled with a non-terminal symbol N_u in parent A; if parent B contains at least one node with the same symbol N_u pick one uniformly and swap the corresponding subtrees (derivation subtrees). If no matching symbol in parent B, the crossover is rejected. This enforces grammatical consistency in offspring.",
            "mutation_operation": "Genotypic mutation: select uniformly a node carrying a non-terminal N_u and replace the subtree rooted at that node with a randomly generated derivation (an expression rewriting N_u), i.e. equivalent to crossover with a random valid parent for that non-terminal.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Quadratic distance (sum of squared errors) between experimental curves and learned functions (fitness).",
            "executability_results": "Dimensional-exn grammar (G3P with dimensional constraints and negative-exponential operator) on Kelvin-Voigt: average best fitness after 2,000,000 evaluations = 39.4 (SD 5.9) (Table 3). Exact solution not found.",
            "diversity_metric": "Initialization-focused genotypic/grammar-aware uniform sampling (qualitative): dynamic masking uses minimal derivation-depth indices to ensure all sampled individuals are admissible and to avoid oversize trees; paper aims at genotypic diversity in the initial population but provides no numeric diversity metric.",
            "diversity_results": "Qualitative: the CFG-compliant initialization with dynamic masking produces a diversified initial population uniformly sampled among admissible derivations and prevents oversize trees; no quantitative diversity numbers reported.",
            "novelty_executability_tradeoff": "Discussed qualitatively: imposing stronger grammatical/domain constraints (reducing search space) improves executability (lower SSE) but reduces the raw search space size; no explicit quantitative tradeoff curve provided.",
            "frontier_characterization": null,
            "benchmark_or_domain": "Scientific discovery / non-parametric identification in mechanics (same rheological benchmarks as canonical GP).",
            "comparison_baseline": "Compared against canonical GP (universal grammar) and variants (universal-exn grammar).",
            "key_findings": "CFGs can encode dimensional consistency and other syntactic constraints, drastically reducing the search space; genotypic crossover can make fine-grained (operator-only) changes that phenotypic crossover cannot; enforcing dimensional grammar (dimensional-exn) significantly improves fitness (Table 3); however, grammar-guided GP can perform poorly if initialization does not sample a diverse admissible population—addressed here by a dynamic masking initialization heuristic which restored diversity and usability.",
            "uuid": "e1610.1",
            "source_info": {
                "paper_title": "Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics",
                "publication_date_yy_mm": "2001-06"
            }
        },
        {
            "name_short": "STGP",
            "name_full": "Strongly-Typed Genetic Programming (STGP)",
            "brief_description": "A GP variant that attaches type labels to terminals and operator arguments so that crossover and mutation only exchange/replace subtrees of matching types, enforcing type safety and restricting search.",
            "citation_title": "Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics",
            "mention_or_use": "mention",
            "system_name": "Strongly-Typed Genetic Programming",
            "system_description": "STGP associates type labels to every terminal and operator argument; genetic operators are constrained so that crossover swaps subtrees of identical type and mutation replaces a subtree with a random subtree of the same type, thereby preventing type errors and reducing the search space.",
            "input_type": "programs/expressions (typed symbolic expressions)",
            "crossover_operation": "Type-constrained subtree crossover: swap subtrees between parents only when the selected subtrees have the same type label.",
            "mutation_operation": "Type-constrained subtree mutation: replace a subtree by a random subtree of the same type.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Mentioned as a framework for encoding typing constraints in GP; not experimentally evaluated in this paper.",
            "comparison_baseline": "Mentioned in relation to grammar-guided GP as a predecessor/related approach.",
            "key_findings": "STGP is straightforward to adapt crossover/mutation to respect syntactic/type constraints, but such constraints can make initialization more difficult; cited as conceptual background for G3P.",
            "uuid": "e1610.2",
            "source_info": {
                "paper_title": "Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics",
                "publication_date_yy_mm": "2001-06"
            }
        },
        {
            "name_short": "Grammatical Evolution",
            "name_full": "Grammatical Evolution (GE)",
            "brief_description": "An evolutionary approach that maps linear genomes to programs in an arbitrary language using a user-specified grammar, enabling evolution of programs for particular target languages via grammatical decoding.",
            "citation_title": "Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics",
            "mention_or_use": "mention",
            "system_name": "Grammatical Evolution",
            "system_description": "GE evolves linear genomes (typically integer sequences) which are decoded using a context-free grammar to produce programs in a target language; genetic operators act on the linear genome, while the grammar ensures syntactic validity of decoded programs.",
            "input_type": "programs/expressions (decoded from genome via CFG)",
            "crossover_operation": "Genome-level crossover: standard linear-genome crossover operators applied on encoded genomes; offspring genomes are decoded through a grammar to produce syntactically valid programs (paper references GE but does not detail operators).",
            "mutation_operation": "Genome-level mutation: standard point mutations on the genotype (integers), followed by grammar-based decoding to programs.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Mentioned as related work on grammar-based GP approaches; not used in experiments.",
            "comparison_baseline": "Mentioned among grammar/CFG-based GP approaches (Ryan et al.).",
            "key_findings": "GE is an alternative grammar-based GP approach; cited as related work but not evaluated in this study.",
            "uuid": "e1610.3",
            "source_info": {
                "paper_title": "Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics",
                "publication_date_yy_mm": "2001-06"
            }
        },
        {
            "name_short": "Dimensional-Aware GP (Keijzer & Babovic)",
            "name_full": "Dimensionally Aware Genetic Programming (Keijzer & Babovic)",
            "brief_description": "A GP approach encoding the dimensionality of expressions with labels listing exponents of base units, constraining production and requiring ad-hoc initialization routines (e.g., DimTransform) when target labels have no direct terminals.",
            "citation_title": "Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics",
            "mention_or_use": "mention",
            "system_name": "Dimensionally Aware Genetic Programming (label-based)",
            "system_description": "Encodes compound units as exponent vectors and attaches dimensional labels to subtrees; operator application must respect label arithmetic (e.g., addition requires same unit), and initialization may need ad-hoc transformation functions (DimTransform) to generate subtrees of required labels when no terminal matches directly.",
            "input_type": "programs/expressions (dimension-labeled symbolic expressions)",
            "crossover_operation": "Type/dimension-constrained crossover: swap subtrees only when dimensional labels match (implementation details referenced from original work).",
            "mutation_operation": "Dimension-constrained mutation: replace subtree with another of the same dimensional label; paper notes special initialization (DimTransform) may introduce non-physical constructs.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Mentioned as prior dimensional-consistency approach in GP (related to the dimensional grammar developed in this paper).",
            "comparison_baseline": "Cited as an alternative to grammar-based encoding of dimensional constraints; noted drawbacks in initialization requiring DimTransform and penalization.",
            "key_findings": "The paper contrasts its CFG-based automatic grammar generator encoding dimensional consistency with Keijzer & Babovic's label-based approach, arguing that CFG encoding avoids ad-hoc initialization transforms and better preserves physical meaning.",
            "uuid": "e1610.4",
            "source_info": {
                "paper_title": "Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics",
                "publication_date_yy_mm": "2001-06"
            }
        },
        {
            "name_short": "CFG Init (dynamic masking)",
            "name_full": "CFG-compliant Initialization with Dynamic Masking",
            "brief_description": "An initialization heuristic introduced in this paper that computes minimal derivation-depth indices and dynamically masks derivations that would exceed a maximum tree depth, enabling uniform sampling of admissible small trees under complex grammars.",
            "citation_title": "Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics",
            "mention_or_use": "use",
            "system_name": "CFG-compliant Initialization (dynamic masking)",
            "system_description": "For each non-terminal and derivation compute the minimal depth (index) needed to reach a terminal expansion. During top-down derivation, at a node at current depth m only allow derivations whose index &lt;= D_max - m; select uniformly among those allowed. This avoids constructing oversized trees and yields diversified admissible individuals for grammars where terminal derivations are rare.",
            "input_type": "programs/expressions (derivation trees from CFG)",
            "crossover_operation": null,
            "mutation_operation": null,
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": "Initialization uniformity / genotypic diversity (qualitative): ensures uniform sampling among admissible derivations under depth limit.",
            "diversity_results": "Qualitative: produces a sufficiently diversified initial population within the allowed maximum tree size and prevents oversized trees; no numerical diversity measures provided.",
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Used within G3P experiments for rheological model identification; addresses initialization difficulties arising from complex grammars (e.g., dimensional grammar).",
            "comparison_baseline": "Contrasted with naive/uniform CFG sampling which tends to produce oversize trees or poorly diversified populations; cited literature that initialization quality impacts results (Daida et al.).",
            "key_findings": "Dynamic masking using minimal derivation-depth indices resolves poor-initialization problems in grammar-guided GP, enabling uniform sampling of admissible individuals and improving evolutionary outcomes under complex grammars.",
            "uuid": "e1610.5",
            "source_info": {
                "paper_title": "Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics",
                "publication_date_yy_mm": "2001-06"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "On using syntactic constraints with genetic programming",
            "rating": 2,
            "sanitized_title": "on_using_syntactic_constraints_with_genetic_programming"
        },
        {
            "paper_title": "Dimensionally aware genetic programming",
            "rating": 2,
            "sanitized_title": "dimensionally_aware_genetic_programming"
        },
        {
            "paper_title": "Grammatical evolution: evolving programs for an arbitrary language",
            "rating": 2,
            "sanitized_title": "grammatical_evolution_evolving_programs_for_an_arbitrary_language"
        },
        {
            "paper_title": "Strongly typed genetic programming",
            "rating": 2,
            "sanitized_title": "strongly_typed_genetic_programming"
        },
        {
            "paper_title": "Genetic Programming: On the Programming of Computers by Means of Natural Evolution",
            "rating": 1,
            "sanitized_title": "genetic_programming_on_the_programming_of_computers_by_means_of_natural_evolution"
        }
    ],
    "cost": 0.01454425,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics</p>
<p>Alain Ratle 
Institut Supérieur de l'Automobile et des Transports
49 rue Melle Bourgeois, BP 31-58027Nevers CedexFrance</p>
<p>Michèle Sebag michele.sebag@polytechnique.fr 
Lab. de Mécanique des Solides
UMR 76-49
CNRS
Ecole Polytechnique
91128PalaiseauFrance</p>
<p>Grammar-guided genetic programming and dimensional consistency: application to non-parametric identification in mechanics
5A10D31859B7D00BF7139E149771DFA710.1016/S1568-4946(01)00009-6Genetic programmingContext-free grammarGrammatical evolutionDomain knowledgeConstrained genetic programmingDimensional analysisMachine discoveryInverse problemsIdentification in mechanics
Although genetic programming has often successfully been applied to non-parametric modeling, it is frequently impaired by the huge size of the search space explored.Domain knowledge is a powerful way to trim out the size of the space, by restricting the search to a priori relevant models.A most natural domain knowledge in scientific modeling is known as dimensional analysis, stipulating that the models must be consistent with regards to the variable measurement units.In this paper, it is shown that dimensional analysis can automatically be expressed as a context free grammar.Dimensionallyaware GP is thus achieved by employing the dimensional grammar within the grammar-guided GP framework first investigated by Gruau [On using syntactic constraints with genetic programming, in: P. Angeline, K.E.Kinnear Jr. (Eds.),Advances in Genetic Programming II, MIT Press, Cambridge, MA, 1996, pp.377-394.].However, grammar-guided genetic programming encounters severe difficulties when it involves a complex grammar, which might explain why this approach has not been widely used so far.The drawback is blamed on the initialization step, which hardly constructs a sufficiently diversified initial population, thus hindering the success of evolution.This limitation is addressed by a new CFG compliant initialization procedure.The approach is validated on two problems related to the identification of mechanical properties of materials.</p>
<p>Introduction</p>
<p>Scientific discovery consists of modeling a physical (mechanical, chemical, biological, etc.) phenomenon from the available observations and current theories.This paper is concerned with the automatic discovery of such empirical laws, referred to as machine discovery (MD).Machine discovery has primarily been investigated in the machine learning framework [1][2][3][4][5].The machine learning approach used to make restrictive assumptions on the available data [1,2]; it still heavily requires the domain expert or the MDer's support, tuning a wide range of declarative heuristics [3][4][5].This might make it questionable for machine discovery to scale up to high dimensional problems, or achieve exploratory analysis in ill-known domains.</p>
<p>The discovery of empirical laws has also been tackled by a number of modeling (or identification) techniques, ranging from data analysis [6] to support vector machines [7].Modeling techniques can be divided into parametric and non-parametric approaches.Parametric modeling is concerned with finding a fixed number of coefficients, whose interpretation is governed by a prescribed model.Non-parametric modeling, which will be the only one considered in the following, determines both the model and the coefficients thereof.</p>
<p>Major breakthroughs in non-parametric modeling have been achieved by genetic programming (GP) [8][9][10], which extends the principles of genetic algorithms and evolutionary computation [11,12] to structured (infinite) search spaces.Its stochastic search allows GP to explore practically and robustly, if not necessarily efficiently, huge search spaces.Indeed, many applications concerned with non-parametric modeling have been successfully tackled by GP [13][14][15][16][17].</p>
<p>However, GP suffers from a major limitation with respect to MD.Although the knowledge-based issues of evolutionary computation have been widely acknowledged [18,19], canonical GP offers no straightforward way of exploiting domain knowledge, namely the expert expectations or requirements regarding the sought model.In MD, a most trivial kind of domain knowledge is dimensional analysis; variables are typed depending on their measurement units (e.g.meter, second, kilogram, etc.), and admissible models are dimensionally consistent (meter and second should not be added).Dimensional consistency, or more generally domain knowledge, can thus be viewed as constraints on the model space.Such constraints are meant to drastically and soundly reduce the search space, thereby increasing the chances of success everything else being equal.Such a constraint can be enforced within GP by means of penalization on non-consistent models [20].</p>
<p>Still, the most natural way of dealing with constraints in optimization is, if possible, to get rid of them by re-designing the search space and/or the evolution initialization and operators [21].Within GP and generalizing the strongly typed GP framework [22,23], Gruau shows that context-free grammars (CFGs) can be both used to declaratively specify the set of ad-missible models, and to enforce the production of admissible offspring from admissible parents [24].The coupling of CFGs and GP has been studied by several authors (see [25][26][27] among others).The expressiveness of CFGs is demonstrated by showing how these can be used to enforce dimensional consistency; an automatic grammar generator implementing dimensional consistency, first described in [28], is presented.</p>
<p>Unfortunately, grammar-guided GP (G 3 P) is observed to perform poorly when it involves a reasonably complex grammar (i.e. when the admissible search space is small, which is the case for dimensionally consistent solutions) [26].We blamed this shortcoming on the initialization step, for the following reasons.On one hand, the standard sampling of the admissible search space might result in poorly diversified individuals.On the other hand, as emphasized by [29,30], the initial population quality can have a considerable impact on the overall result (up to several orders of magnitude).A new initialization procedure for G 3 P, that produces admissible individuals of limited size that are sufficiently diverse was therefore proposed [28].</p>
<p>Applications</p>
<p>In this paper, the main application concerns the identification of an analytic model of materials behavior from experimental data [37].Such a task is essential for material scientists in order to characterize recently developed materials.One of the most common test for on-site applications is the indentation test described in Fig. 1.This test consists of pushing a hard indenter with a standardized shape against the material to be tested.The applied force is recorded together with the penetration depth of the indenter, and the result is a force-displacement curve, or a force-time curve for time dependent materials, as shown in Fig. 1.</p>
<p>The goal of the learning task is to find out an analytical model which can explain the physics lying behind these curves.It should be noted, however, that except for some classes of materials, this is an open problem which has no solution.Therefore, in order to develop the automatic learning tool in a better controlled environment, a simpler application is also considered.This second case consists of a visco-elastic model known as the Kelvin-Voigt model.The model is sketched in Fig. 2a, and consists of a spring K in parallel with a dashpot C. When this model is submitted to a step-function force of amplitude F from the time t = 0, the displacement u is easily derived from the equation of motion of the system:
u(t) = F K (1 − e −Kt/C )(1)
A second, more complex case, is the four-element model sketched in Fig. 2b.This model has a response to a step function force given by:
x(t) = F K 1 + Ft C 1 + F K 2 (1 − e −Kt/C 2 ) (2)</p>
<p>Organization</p>
<p>This paper is organized as follows.First of all, Section 2 presents a brief overview of classical genetic programming.Section 3 reviews some related works and discusses how to take into account prior knowledge within GP.In order for this paper to be self contained, Section 4 briefly describes context-free grammars.Section 5 demonstrates how grammars can be used to automatically encode dimensional consistency.Section 6 details how to modify the GP components to accommodate a CFG, notably focusing on the initialization procedure.Last sections are devoted to the empirical validation of the presented G 3 P scheme on problems inspired from real-world applications in mechanical modeling, the identification of materials behavioral law.Section 7 describes the test applications.Section 7.2 presents our empirical setting and discusses the experimental results.The paper ends with some perspectives for further research.</p>
<p>Elementary genetic programming</p>
<p>Genetic programming consists of a special class of evolutionary algorithms for which the evolution takes place over tree representations of computer programs rather than over linear genomes.The basic scheme of an evolutionary algorithm can be described as follows:</p>
<p>• Create a random population of solutions.</p>
<p>• Evaluate the fitness of each individual (solution).</p>
<p>• While the stopping criteria is not satisfied,</p>
<p>• select the best parents in the current population according to fitness; • recombine them in order to generate offsprings;</p>
<p>• mutate some of them in a random direction.</p>
<p>• End of the algorithm.</p>
<p>The tree representation, and the crossover (recombination) and mutation operators are illustrated by the following example, where a function of the three variables a, b and c is required using the four basic arithmetic operators (+, −, * , /).Fig. 3 shows in the upper part two individuals equivalent to the functions:
f 1 (a,b,c) = (a − c) + (b − a) * b and f 2 (a,b,c) = a + b a * (c + b)(3)
The crossover operator consists of selecting two subtrees in two preselected parents, and swapping these subtrees in order to generate new solutions which contains the building blocks of the "good" parents.Fig. 3 shows in the bottom part the two offsprings obtained by the recombination of the two parents.These offsprings correspond to the following functions:
f 3 (a,b,c) = (a − c) + b a and f 4 (a,b,c) = a + ((b − a) * b) * (c + b)(4)
The mutation operator of the basic GP algorithm consists in applying the crossover operator between a selected parent and a randomly generated tree.In the context of genetic programming for symbolic regression, or function identification, the fitness function is based on the distance between the solution given by the algorithm and the experimental results to be learned.</p>
<p>In the present application, the quadratic distance between the experimental curves and the learned functions was employed.This fitness function should, of course, be minimized by the algorithm.</p>
<p>Evolutionary non-parametric modeling</p>
<p>The branch of evolutionary computation concerned with non-parametric modeling is genetic programming [8][9][10].Genetic programming extends the principles of genetic algorithms to tree-structured spaces, described from a set of operators or nodes N , and a set of terminals or leaves T .As trees of any depth can be generated, evolution truly explores an unbounded search space. 1 As an example, consider the tree-structured space defined from nodes plus and multiply and leaves x (variable) and R (any real-valued constant).This space includes polynomials of variable x of any degree.</p>
<p>Canonical GP relies on the hypothesis of closure of the search space [8], which assumes that the return value of any subtree is a valid argument for any function.This ensures that simple crossover and mutation (respectively swapping sub-trees and replacing an arbitrary (part of) subtree by a random one) shall produce admissible offsprings.On the other hand, this assumption forbids any syntactic or semantic restrictions to be done.Some simple restrictions can be handled through the operator design, e.g. a protected division is designed to handle the case of a null divisor.All other restrictions must be accounted for through the fitness function design, e.g.penalizing non-viable individuals.The closure assumption thus implies strong limitations:</p>
<p>• The search space is huge, even for problems of moderate difficulty [31]: it is exponential with respect to the number of terminals and operators and the maximum tree depth allowed.• No consideration is taken for the variable types (integers, real numbers, complex numbers, etc.) or dimensions (meter, second, kilogram, etc.), which implies that the search space includes a number of irrelevant individuals [32].• The general shape of the generated trees is arbitrary; the expert prior knowledge can only dictate the operator set.</p>
<p>In summary, the price to pay for simple GP evolution operators is that the search space is much larger than the set of relevant individuals.GP implicitly deals with a constrained optimization problem, where the constraints reflect the domain expert or GPer prior knowledge.The importance for evolutionary computation to take the expert knowledge into account is now generally acknowledged [18,19], and several authors have addressed the coding of expert knowledge through GP biases.</p>
<p>A first class of bias concerns the shape of the sought solution.A significant improvement in the success rate of a GP application can be obtained by biasing the shape of the parse trees toward some shapes judged interesting [31,33].This can be done through setting or adapting the selection probabilities of the operators [33], or via syntactic constraints [31].</p>
<p>Actually, most GP biases are expressed as syntactic constraints.Koza used syntactic constraints (e.g.setting the root operator or restricting the crossover according to the operator types) to either enforce the production of viable individuals or improve GP efficiency in his early work [8].Automatically defined functions (ADF) can also be viewed as particular kinds of syntactic constraints, controlling the operators hierarchy in order to enforce GP scalability [9].</p>
<p>Syntactic constraints might also regard the types of the variables manipulated by the tree expression.These constraints might express the operator restrictions (e.g. the cosine operator should be applied on angular variables only) and the admissible combinations of operators.In the strongly typed GP (STGP) proposed by Montana [22] and extended by Haynes et al. [23], a type label is associated to every terminal, and every operator argument.The crossover and mutation procedures are then constrained accordingly; crossover operates by swapping a subtree with another subtree of the same type, and mutation replaces a subtree with a random subtree of the same type.Along the same lines, type constraints might reflect semantic restrictions, such as those related to dimensional analysis.A first step toward dimensionally aware GP was proposed by Keijzer and Babovic [20].The dimensionality of each expression is encoded by a label, listing the exponents of the basic units.The requirements on the label of a subtree derive from those of its parent and sibling nodes.</p>
<p>As shown by Montana [22], it is relatively easy for crossover and mutation to accommodate syntactic constraints.But these might render the initialization step significantly more difficult.In Keijzer and Babovic's approach for instance [20], during initialization one has to generate a subtree of any prescribed label (compound unit); still, there does not necessarily exist a terminal associated to the desired label.Initialization thus calls an ad hoc function, DimTransform, which might introduce non-physically meaningful constructs hindering the physical relevance of the final tree.The fitness design hence takes care of this undesired side effect, by penalizing the individuals with many calls to DimTransform.</p>
<p>Next section describes a general framework for specifying or constraining the GP search space, namely context-free grammars [34].How to accommodate these specifications within genetic programming is studied in Section 6.</p>
<p>Context-free grammars</p>
<p>As reminded by Gruau, syntactic constraints historically pertain to the theory of formal language and grammars; a grammar is meant to describe all admissible expressions of a language.In his pioneering work [24], Gruau showed how context-free grammars (CFGs) allow one to bias the GP search space through syntactic constraints, neatly expressing the admissible search space and significantly reducing the exploration effort.A publicly available GP software implementing the use of context-free grammars has been realized by Hörner [25].</p>
<p>In order for this paper to be self-contained, this section briefly reminds the CFG formalism.A standard way of characterizing a context-free grammar, known as Backus-Naur expression, is by a four-tuple {S, N, T, P}, where S denotes the start symbol, N the set of non-terminal symbols, T the set of terminal symbols, and P is the set of production rules.Fig. 4 shows the CFG describing the polynomials of variable X, to be compared with the standard GP description from the node set N ={+, ×} and terminal set T = {x, R}.</p>
<p>Any expression is built up from the start symbol S. For each non-terminal symbol (e.g.E ) there exists a production rule stating all possible ways of rewriting the non-terminal symbol, named derivations (e.g. the two possible derivations for E are O E E and V ).Each non-terminal symbol is rewritten by selecting a derivation until the expression contains terminals only.In evolutionary terms, one could consider the derivation tree as the genotype of the individual.The derivation tree gives rise to a parse tree that constitutes the phenotype and whose fitness is ultimately computed (Fig. 5).</p>
<p>The distinct roles of non-terminals and terminals in GP and CFG are shown from the derivation tree and the corresponding expression tree (Fig. 5).In both cases, non-terminal symbols correspond to the nodes of the tree, while terminal symbols are the leaves.But operators are leaves of the derivation tree (CFG terminal symbols), whereas they are nodes of the expression tree (GP non-terminal symbols).This difference implies that crossover and mutation will operate in different ways, depending on whether they apply on the derivation or the expression tree; this point will be discussed further in Section 6.1.</p>
<p>The advantage of CFGs is to allow for fine-grained restrictions on the combinations of operators and vari- ables.Assume for instance that the parent node of a plus node should only be a multiply node, and conversely.Such a restriction is written down by modifying the above CFG as follows (only modified items are shown):
N :={ add E , mult E , O , V } S := add E | mult E add E := (+ mult E mult E )| V mult E&gt; := (× add E add E )| V
Canonical GP cannot declaratively accommodate such restrictions, i.e. through the description of N and T only.Procedural modifications are required to avoid or discourage non-complying individuals, through either the initialization procedure and evolution operators, or the fitness design.</p>
<p>Dimensional analysis through CFGs</p>
<p>For our purpose, it remains to show that context-free grammars can be used to encode reasonably complex prior knowledge in the domain of machine discovery.The particular prior knowledge considered in the following is dimensional consistency, for two reasons.First of all, dimensional consistency constitutes a fairly general domain knowledge relevant to machine discovery.Secondly, it is very efficient in the sense that it drastically reduces the number of admissible solutions.</p>
<p>Two restrictions are done.The set of admissible compound units is finite, and only arithmetic operators (plus, multiply and divide) are applied on non-dimensionless expressions.</p>
<p>Under these restrictions, dimensional analysis can be expressed through a CFG [28].Let u 1 ,... ,u K denote the K elementary units of the problem domain.For instance, in the domain of macro-mechanical modeling the three elementary units are meter, second and kilogram.Borrowing to the formalism used in [20], any compound unit based on these K elementary units is described as a vector of R K ; e.g. the Newton unit (kilogram × meter/second 2 ) is represented as (1, −2, 1).The set D of allowed compound units is given as a finite subset of R K (e.g. in the example domain, K = 3 and D is {−2, −1, 0, 1, 2} 3 ).</p>
<p>To each unit u in D is associated a non-terminal symbol N u .The production rule associated to N u describes all possible ways of constructing an expression of unit u:</p>
<ol>
<li>
<p>by selecting a terminal symbol (problem variable) with unit u;</p>
</li>
<li>
<p>by adding or subtracting expressions with unit u; 3. by multiplying two expressions with respective units v and w, such that u = v + • w,o r 4. by dividing an expression of unit v by an expression of unit w, such that u = v − • w, where + • and − • , respectively, denote the vector addition and subtraction on R K .</p>
</li>
</ol>
<p>Other possibilities, not considered in the following, would be by taking the square root of an expression of unit 2u, or the cubic root of an expression of unit 3u; but clearly, the use of fractional power operators cannot be extended beyond certain limits.</p>
<p>In the particular case of dimensionless expressions (u = (0,... ,0)), any other operator (e.g.exp, log, etc.) can be used.</p>
<p>The number |D| of allowed units is exponential in the number of exponents allowed for an elementary unit on average (e.g.|D|=5 3 = 125 in our example), which makes it necessary to devise an automatic generator for the CFG.Note however, that although the grammar size is actually exponential, using it to enforce dimensional consistency entails no computational overhead compared to using some dimensionally-consistent crossover or mutation procedures.</p>
<p>The automatic CFG generator takes as input the unit of each terminal symbol, the set D of admissible units, and the unit u s of the sought solution.The set of domain variables with unit u, possibly empty, is noted V u .The algorithm for automatically generating the production rules is depicted in Fig. 6.</p>
<p>Note that any additional cue on the shape of the solution might easily be given by the expert, through the production rule associated to the start symbol.For instance, if the sought model should involve an inverse exponential of the time variable t, the first production rule becomes:
S := N u s e −( N 0 t)</p>
<p>Grammar-guided genetic programming</p>
<p>CFGs allow one to declaratively characterize the GP search space.As the closure hypothesis does no longer hold, the standard GP components need be modified, giving rise to the grammar-guided GP (G 3 P) framework.After briefly discussing the case of G 3 P crossover and mutation, this section focuses on the initialization procedure.</p>
<p>G 3 P crossover and mutation</p>
<p>CFG compliant crossover and mutation operators should produce admissible offspring from admissible parents.As mentioned earlier on, the required modifications are rather straightforward [22,24,25].</p>
<p>Within G 3 P, genetic individuals are provided with two descriptions: the derivation tree, or genotype, encodes the expression tree, or phenotype.G 3 P crossover and mutation apply on the genotypes, contrasting with canonical GP crossover and mutation applying on the phenotypes.</p>
<p>G 3 P crossover selects with uniform probability a node in the first parent carrying any non-terminal symbol,2 say N u .If the second parent has no node carrying symbol N u , the crossover is rejected.Otherwise, a node carrying symbol N u is selected with uniform probability in the second parent, and the two subtrees rooted in the selected nodes are swapped.</p>
<p>G 3 P mutation likewise selects with uniform probability a node carrying a non-terminal symbol N u , and replaces the subtree rooted from this node with any expression rewriting N u (same as crossover with a random parent).</p>
<p>It is worth noting that handling the genotypes instead of the phenotypes remarkably modifies the crossover effects.As a proof, which is new to our best knowledge, note that phenotypic GP crossover (operating on the expression trees) cannot produce an offspring which differs from a parent by an operator only; phenotypic crossover can but modify a whole expression subtree.Quite the contrary, genotypic G 3 P crossover (operating on the derivation trees) can access a leave of the derivation tree, hence modify an operator independently from its arguments (Fig 5).</p>
<p>The propensity of G 3 P crossover to achieve such restricted modifications appears quite desirable.In opposition, the canonical GP setting requires the individuals to grow before canonical GP crossover could operate small modifications [8]; and such growth clearly congests the evolution process.</p>
<p>CFG compliant initialization</p>
<p>In the G 3 P framework, initialization should both sample the search space as uniformly as possible, and respect the maximum tree-depth prescribed by the user.</p>
<p>However, in a reasonably complex CFG such as the dimensional one (Section 5), most non-terminal symbols cannot be resolved directly into a terminal.And in all cases, the fraction of terminal derivations is so small anyway that there is little chance for a uniform process to select a terminal derivation.Furthermore, in the general case the rewriting rules impose no limitations on the number of recursive calls to a non-terminal symbol. 3A uniform initialization procedure thus tends to build up very deep trees, as noted by Ryan et al. [26], and oversized trees are massively rejected.</p>
<p>Similar difficulties are met in all constrained evolutionary schemes using a death penalty, when the admissible search space constitutes a small fraction of the search space [21].</p>
<p>A possibility would be to favor the selection of terminal variables whenever possible, e.g. through setting high probabilities on the corresponding derivations.Unfortunately, unless these probabilities are very carefully tuned, this leads to construct poorly diversified individuals, and evolution practically never recovers from such a poor initial population.As stressed by Daida [29], the importance of the initial population cannot be overestimated. 3Although one might upper bound the number of such recursions [24] this requires one to have fairly precise ideas on the shape of the solutions sought.</p>
<p>The heuristics first presented in [28] for overcoming the initialization difficulties within G 3 P, proceeds by dynamically masking the derivations that would lead to oversized trees.</p>
<p>To each symbol N u is associated an integer index i(N u ) giving the depth of the smallest tree resolving N u into terminal symbols; an integer index is similarly associated to each derivation 'deriv'.These indices are recursively computed from the following considerations:</p>
<p>• The index of a terminal variable is 1.</p>
<p>• The index of a non-terminal symbol is the minimum index of its derivations:
N u := deriv 1 | ...|deriv K ;⇒ i(N u ) = min k=1,... ,K i(deriv k )
• The index of a derivation involving an operator is one plus the maximum index of its operands:
i( op N u N v ) = 1 + max(i(N u ), i(N v ))
As an example, let us consider the CFG describing all polynomial fractions of variables a, b, and c with rational coefficients ( Fig 7).</p>
<p>The index of non-terminal symbol V is 1.Hence, the index of derivation ( op V V ) is 2, and the index of non-terminal symbol E is also 2.</p>
<p>Let D Max denote the maximum tree depth set by the expert.Obviously D Max must be greater than the index of the start symbol S (D Max ≥ i(S)), otherwise no individual in the CFG space satisfies the depth limitation and the admissible space is empty.Along the same lines, any non-terminal symbol N u such that i(N u ) is greater than D Max is useless and should therefore removed from the CFG, together with all derivations involving them.For instance, if D Max were set to 2, all derivations of E but the last one in the above example, should be removed.</p>
<p>Indices are employed to enforce the upper bound on tree size as follows.Consider a given occurrence of some non-terminal symbol N u , situated at level m of the tree under construction.The maximum depth allowed for rewriting this occurrence of N u is D Max − m.Only those derivations of N u with index less than D Max − m are therefore allowed; and at least one such derivation must exist, since otherwise symbol N u would not have been allowed to use at level m.Other derivations are locally masked since they would lead to construct an oversized tree.</p>
<p>Practically, the derivation used to rewrite this occurrence of N u is uniformly selected among the admissible derivations.This way, it is impossible for the initialization algorithm to engage into a path providing no solution within the allowed tree depth: all constructed individuals are admissible with respect to both the CFG and the maximum treedepth.</p>
<p>As an example, let D Max be set to 4, and see how the derivation tree develops.It starts with S, readily rewritten as E .Assume that the first derivation op E E is chosen.Assume then that the leftmost E symbol is rewritten using the second derivation op E V .At that point, the limitation on the tree depth imposes the leftmost E symbol to be rewritten using the shortest derivation op V V (Fig. 8).</p>
<p>The advantage of this procedure is that the initial population does not suffer from any loss of diversity; the set of admissible individuals is uniformly sampled, as the dynamic masking of the derivations does not introduce any unnecessary restrictions. 4</p>
<p>Numerical experiments</p>
<p>In this section the G 3 P is empirically validated on the artificial problems described in the introduction, and then is tested on the real application for which the solution is unknown.The goal is to identify the behavior laws of new materials, which has important applications especially for polymers and composite materials [36,37].In the two test problems, a target model is analytically defined, and numerical examples are generated with random values of the materials parameters.Depending on the class of materials and the properties under study, the sought model either is a force-time relation, or a force-displacement relation.</p>
<p>In the test application 20 pseudo-materials have been numerically generated from random values of the material properties.The goal of the learning tool is to minimize the quadratic distance between these 20 simulated experiments and the proposed model.Therefore, a fitness value of zero is expected if the exact solution is found.</p>
<p>Grammar generation</p>
<p>Three grammars are considered for the rheological models.For the second application (real problem), only the universal and dimensional grammars are considered.</p>
<p>Universal grammar again specifies the same search space as canonical GP with operator set N and terminal set T :
S := E E := O E E | V O :=+|−|×|÷|exp ≡ N V := F | K | C | t | 1 | 2 | 3 | 4 ≡ T
Universal-exn grammar, which expresses the fact that the exponent is necessarily negative (material parameters are always positive, and negative time is not considered).Within the universal grammar, evolution must thus create a combination of constants equal to −1, and multiply the result by another combination of variables.Instead, the search space can be biased toward physically plausible solutions by introducing the negative exponential operator exn, which returns the exponentiation of the negation of its argument.Universal-exn grammar differs from the universal one as operator exn is added to non-terminal O .</p>
<p>Dimensional-exn grammar, which takes advantage of the variable dimensions described on Table 1.This table allows the automatic generation of a dimensional grammar as described in Section 5. Operator exn is applicable on dimensionless expressions.</p>
<p>Experiment settings</p>
<p>The empirical validation is concerned with evaluating how domain knowledge, provided through vari- Canonical GP and G 3 P both follow a generational scheme with crossover, tree mutation and point mutation.Crossover swaps a randomly selected tree with another randomly selected tree (respectively derived from the same non-terminal symbol) in GP (respectively in G 3 P).Tree mutation replaces a randomly selected subtree with a newly generated subtree (respectively derived from the same non-terminal symbol) in GP (respectively in G 3 P).Point mutation replaces a randomly selected variable/constant with another one (respectively derived from the same non-terminal symbol) in GP (respectively in G 3 P).The relevant parameters are summarized in Table 2.</p>
<p>Results</p>
<p>For both the Kelvin-Voigt and the four-element model, the exact solution was found in no run, whatever the grammar used.Fig. 9 shows the average over 20 runs of the best fitness against the total number of evaluations for all three grammars considered, for the most simple case, the Kelvin-Voigt problem.The baseline corresponds to the universal grammar (canonical GP); the second grammar differs from the universal one by the only addition of operator exn; the third one involves besides all dimensional constraints.</p>
<p>As could have been expected, the use of exn significantly improves the overall result.The use of dimensional constraints improves results even more significantly, as shown in Table 3.</p>
<p>In spite of the fact that the exact solution was never found, some of the approximate solutions were, from an engineering point of view, very similar to the data.Fig. 10 presents four random materials extracted from  Finally, for the real application of unknown solution, similar results were found.No exact solution (zero fitness) was found, regardless of the parameters of the algorithm.Fig. 11 shows, however, that using a universal grammar, the best solution consists of a compromise lying in between all of the training samples.Using a dimensional grammar, the algorithm is able to find out a solution that matches more closely each of the samples.</p>
<p>Conclusion and perspectives</p>
<p>This paper has investigated how to enhance genetic programming by taking into account prior knowledge related to the application domain.</p>
<p>After Gruau [24], the formalism of context-free grammars appears to be both efficient and manageable to express a wide range of syntactic constraints about the shape or properties of sought solutions.Grammar-guided GP, generalizing STGP [22], improves on canonical GP by restricting the search to admissible solutions, which represent a negligible fraction of the total search space.</p>
<p>The power of CF grammars has been demonstrated by showing how dimensional consistency can be encoded within such a grammar.Though the size of dimensional grammar is exponential in the number of elementary units in the domain, grammar-guided GP suffers from no computational overhead compared to typed GP.Compared to fitness-based ways of favoring dimensionally consistent solutions [20], the advantage of G 3 P is a drastic reduction of the GP search space.Besides, grammars also allow the expert to encode his/her priors regarding the shape of the target model.</p>
<p>One barrier to the wide use of G 3 P was identified as the initialization mechanism, for the maximum tree depth allowed for the trees usually conflicts with a great many constraints.This limitation has been addressed by a new heuristics, based on the dynamic masking of non-admissible constructs and derivations.This way, a sufficiently diversified initial population within the allowed maximal tree size might be created.</p>
<p>The advantage of the approach has been experimentally demonstrated on two test problems inspired from real-world applications.Indeed, the use of expert grammars is show to significantly improve the overall identification results.</p>
<p>The main limitation of G 3 P for dimensionally-aware GP is that a limited range of units is considered so far.Further research will investigate the use of fractional units together with a broader range of operators (e.g.square or cubic roots).This could be made possible by considering twice as many basic units (using rational instead of integer exponents).</p>
<p>Another difficulty for genetic programming regards the adjustment of real-valued parameters, which was not considered in our test problem.A perspective of research is to investigate how G 3 P could be used to restrict the range of values explored, according to the expert's indications.</p>
<p>Fig. 1 .
1
Fig. 1.Sketch of the experimental setup, and typical results.</p>
<p>Fig. 2 .
2
Fig. 2. The Kelvin-Voigt model, and the four-element model.</p>
<p>Fig. 3 .
3
Fig. 3. Function representation and crossover operator of the basic GP algorithm.</p>
<p>Fig. 4 .
4
Fig. 4. The grammar for polynomials of any degree of variable x.</p>
<p>Fig. 5 .
5
Fig. 5. Derivation tree and corresponding parse tree.</p>
<p>Fig. 6 .
6
Fig. 6.Generation of the dimensional grammar.</p>
<p>Fig. 7 .
7
Fig. 7.The grammar for polynomial fractions of a, b, and c.</p>
<p>Fig. 8 .
8
Fig. 8. Dynamically pruning the derivations.</p>
<p>Fig. 9 .
9
Fig. 9. Solution quality obtained with the three grammars for the Kelvin-Voigt problem.</p>
<p>Fig. 11 .
11
Fig. 11.Correlation between four samples of the real application and the best model found by the learning algorithm: universal grammar (left); dimensional grammar (right).</p>
<p>Fig. 10 .
10
Fig. 10.Correlation between the training examples and the learned model for the four-element problem.</p>
<p>Table 1
1
Physical units of measurement for the two rheological models can facilitate the evolution task.After describing the experiment setting, we present and discuss the results obtained by canonical GP and G3Pon the test applications.
QuantityMassLengthTimeDomain variablesForce, F+1+1−2Elastic element, K+10−2Viscous element, C+10−1Time, t00+1SolutionDisplacement, u0+10</p>
<p>Table 3
3
Comparative results on the Kelvin-Voigt problem (best result for 2,000,000 fitness evaluations, averaged on 20 runs)
GrammarAverage fitnessS.D.Universal grammar100.89.2Universal-exn grammar69.61.1Dimensional-exn grammar39.45.9
Practically, an upper bound is set on the maximum tree depth, which might raise difficulties during the initialization step; this point is discussed in more detail in Section 6.
Note that the crossover point must be a non-terminal; otherwise crossover can only be ineffective, swapping a terminal with itself.
With regards to formal grammars, the presented heuristics corresponds to the use of an attribute grammar[35] with constraints. A depth attribute is attached to each symbol occurrence and each derivation rule is associated a constraint on the attributes. A simple constraint solver is used to check whether a given derivation path is currently allowed.
AcknowledgementsThe authors acknowledge Helmut Hörner, who developed an efficient freeware for G 3 P; this freeware, extended with the CFG compliant initialization procedure and the automatic generation of the dimensional CFG, served as a basis for our experiments.Numerical simulations data were provided by Nicolas Tardieu.We last acknowledge Andrei Constantinescu, Nicolas Tardieu, and Marc Schoenauer at Ecole Polytechnique, for many lively discussions.
Rediscovering chemistry with the BACON system. P Langley, H Simon, G Bradshaw, Machine Learning: An Artificial Intelligence Approach. R Michalski, J Carbonell, T Mitchell, Los Altos, CAMorgan Kaufmann19831</p>
<p>Integrating quantitative and qualitative discovery: the ABACUS system. B Falkenhainer, R Michalski, Machine Learning. 19861</p>
<p>Discovery tools for science applications. R Valdes-Perez, Communications of the ACM. 42111999</p>
<p>Discovering dynamics. S Dzeroski, L Todorovski, Proceedings of the 10th International Conference on Machine Learning. the 10th International Conference on Machine LearningLos Altos, CAMorgan Kaufmann1993</p>
<p>Discovering admissible models of complex systems based on scale-types and identity constraints. T Washio, H Motoda, Proceedings of the International Joint Conference on Artificial Intelligence. the International Joint Conference on Artificial Intelligence1997</p>
<p>Classification and Regression by Tree. L Breiman, J Friedman, R Olshen, C Stone, 1984Wadsworth, Belmont, CA</p>
<p>V N Vapnik, The Nature of Statistical Learning. BerlinSpringer1995</p>
<p>Genetic Programming: On the Programming of Computers by Means of Natural Evolution. J R Koza, 1992MIT PressCambridge, MA</p>
<p>Genetic Programming II: Automatic Discovery of Reusable Programs. J R Koza, 1994MIT PressCambridge, MA</p>
<p>Genetic Programming -An Introduction on the Automatic Evolution of Computer Programs and its Applications. W Banzhaf, P Nordin, R Keller, F Francone, 1998Morgan KaufmannLos Altos, CA</p>
<p>D E Goldberg, Genetic Algorithms in Search, Optimization and Machine Learning. Reading, MAAddison-Wesley1989</p>
<p>T Baäck, Evolutionary Algorithms in Theory and Practice. New YorkOxford University Press1995</p>
<p>Using a tree structures genetic algorithm to perform symbolic regression. B Mckay, M Willis, G Barton, Proceedings of the IEEE Conference. the IEEE Conference1995414</p>
<p>Cultural transmission of information in genetic programming. L Spector, S Luke, Proceedings of the Second International Conference on Genetic Programming (GP97). the Second International Conference on Genetic Programming (GP97)Los Altos, CAMorgan Kaufmann1997</p>
<p>Using symbolic regression to infer strategies from experimental data. J Duffy, J Engle-Warnick, Evolutionary Computation in Economics and Finance. 1999Springer</p>
<p>Numeric mutation as an improvement to symbolic regression in genetic programming. T Fernandez, M Evett, Evolutionary Programming VII. BerlinSpringer19981447</p>
<p>Parallel implementation of a genetic programming-based tool for symbolic regression. A Salhi, H Glaser, D Deroure, Information Processing Letters. 661998</p>
<p>Equivalence class analysis of genetic algorithms. N J Radcliffe, Complex Systems. 51991</p>
<p>A knowledge-intensive genetic algorithm for supervised learning. C Z Janikow, Machine Learning. 131993</p>
<p>Dimensionally aware genetic programming. M Keijzer, V Babovic, Proceedings of the Genetic and Evolutionary Conference'99. the Genetic and Evolutionary Conference'99Los Altos, CAMorgan Kaufmann1999</p>
<p>Evolutionary algorithms for constrained parameter optimization problems. Z Michalewicz, M Schoenauer, Evolutionary Computation. 411996</p>
<p>Strongly typed genetic programming. D J Montana, Evolutionary Computation. 321995</p>
<p>Type inheritance in strongly typed genetic programming. T Haynes, D Schoenefeld, R Wainwright, Advances in Genetic Programming II. P Angeline, K E KinnearJr, Cambridge, MAMIT Press1996</p>
<p>On using syntactic constraints with genetic programming. F Gruau, Advances in Genetic Programming II. P Angeline, K E KinnearJr, Cambridge, MAMIT Press1996</p>
<p>A C++ class library for genetic programming. H Hörner, 1996The Vienna University of EconomicsTechnical Report</p>
<p>Grammatical evolution: evolving programs for an arbitrary language. C Ryan, J Collins, M O'neill, Proceedings of the First European Workshop on Genetic Programming (EuroGP98). W Banzhaf, R Poli, M Schoenauer, T Fogarty, the First European Workshop on Genetic Programming (EuroGP98)BerlinSpringer19981391</p>
<p>Declarative expression of biases in genetic programming. L Martin, F Moal, C Vrain, Proceedings of the Genetic and Evolutionary Conference'99. the Genetic and Evolutionary Conference'99Los Altos, CAMorgan Kaufmann1999</p>
<p>Genetic programming and domain knowledge: beyond the limitations of grammar-guided machine discovery. A Ratle, M Sebag, Proceedings of the Sixth Conference on Parallel Problems Solving from Nature. M Schoenauer, the Sixth Conference on Parallel Problems Solving from NatureBerlinSpringer2000</p>
<p>Challenges with verification, repeatability, and meaningful comparison in genetic programming: Gibson's magic. J Daida, Proceedings of the Genetic and Evolutionary Conference'99. the Genetic and Evolutionary Conference'99Los Altos, CAMorgan Kaufmann1999</p>
<p>Alternative random initialization in genetic algorithms. L Kallel, M Schoenauer, Proceedings of the Seventh International Conference on Genetic Algorithms. T Baäck, the Seventh International Conference on Genetic AlgorithmsLos Altos, CAMorgan Kaufmann1997</p>
<p>Inductive bias and genetic programming. P Whigham, Proceedings of the IEEE Conference. the IEEE Conference1995414</p>
<p>Performance enhanced genetic programming. C Clack, T Yu, Evolutionary Programming VI. P Angeline, R Reynolds, J Mcdonnell, R Eberhart, BerlinSpringer1997</p>
<p>Evolving structured programs with hierarchical instructions and skip nodes. R Salustowicz, J Schmidhuber, Proceedings of the 15th International Conference on Machine Learning. the 15th International Conference on Machine LearningLos Altos, CAMorgan Kaufmann1998</p>
<p>The semantics of context-free languages. D E Knuth, Mathematical System Theory. 221968</p>
<p>. D Schmidt, Denotational Semantics, 1986Allyn &amp; Bacon, Newton, MA</p>
<p>Mechanical Properties of Solid Polymers. I Ward, 1985WileyChichester</p>
<p>Evolutionary identification of macro-mechanical models. M Schoenauer, M Sebag, F Jouve, B Lamy, H Maitournam, Advances in Genetic Programming II. P J Angeline, J K E Kinnear, Cambridge, MAMIT Press1996</p>            </div>
        </div>

    </div>
</body>
</html>