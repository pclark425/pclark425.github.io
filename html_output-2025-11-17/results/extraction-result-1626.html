<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-1626 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-1626</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-1626</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-31.html">extraction-schema-31</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <p><strong>Paper ID:</strong> paper-49644635</p>
                <p><strong>Paper Title:</strong> Program synthesis using uniform mutation by addition and deletion</p>
                <p><strong>Paper Abstract:</strong> Most genetic programming systems use mutation and crossover operators to create child programs from selected parent programs. Typically the mutation operator will replace a randomly chosen subprogram in the parent with a new, randomly generated subprogram. In systems with linear genomes, a uniform mutation operator can be used that has some probability of replacing any particular gene with a new, randomly chosen gene. In this paper, we present a new uniform mutation operator called Uniform Mutation by Addition and Deletion (UMAD), which first adds genes with some probability before or after every existing gene, and then deletes random genes from the resulting genome. In UMAD it is not necessary that the new genes replace old genes, as the additions and deletions can occur in different locations. We find that UMAD, with relatively high rates of addition and deletion, results in significant increases in problem-solving performance on a range of program synthesis benchmark problems. In our experiments, we compare this method to a variety of alternatives, showing that it equals or outperforms all of them. We explore this new mutation operator and other well-performing high-rate mutation schemes to determine what traits are crucial to improved performance.</p>
                <p><strong>Cost:</strong> 0.016</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e1626.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e1626.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>UMAD</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Uniform Mutation by Addition and Deletion</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A variable-length, uniform single‑parent mutation operator that first probabilistically inserts random genes before/after each gene (addition rate) and then probabilistically deletes genes from the augmented genome (deletion rate), allowing additions and deletions to be dissociated in location and number.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Uniform Mutation by Addition and Deletion (UMAD)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>UMAD is a mutation-only genetic operator applied to linear genomes (Plush genomes) encoding Push programs. For each gene in a parent genome it independently (1) with probability additionRate adds a newly generated random gene before or after that gene and (2) after all additions, with probability deletionRate deletes each gene in the augmented genome. Addition and deletion rates can be chosen to be size‑neutral or biased to grow/shrink offspring. UMAD was used as the sole variation operator (no crossover) in evolutionary runs on program synthesis benchmarks.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Two-stage uniform operation: (a) for each parent gene, with probability additionRate insert a random gene immediately before or after that gene (new genes generated same as for random initialization); (b) on the resulting augmented genome, for each gene independently delete it with probability deletionRate. The deletionRate can be chosen (using deletionRate = additionRate / (1 + additionRate)) to make operation size-neutral on average, or adjusted to bias growth/shrinkage.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Success rate = number of independent GP runs (out of 100) that produced programs passing all training cases and also generalizing on withheld unseen test cases (solutions simplified before generalization check).</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>UMAD substantially improved executable/generalizing solution rates versus prior benchmark operators on many problems. Examples from Table 2: Replace Space With Newline 87/100 (UMAD) vs 58/100 (Benchmark); Vector Average 88/100 vs 43/100; Syllables 38/100 vs 24/100. UMAD variants (size-neutral and shrinking) were among top performers and were significantly better than benchmark on ~9 problems (see Table 2 summary).</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Genotypic size distributions (average genome length over generations) and population-based diversity implicitly via lexicase selection; no formal novelty score was measured.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td>UMAD produced varied genome-size dynamics across runs (some runs grew average genome size >500, others shrank to ~50). Shrinking UMAD drove average genome size downward (floor observed), growing UMAD drove sizes up until capped by maximum genome size producing oscillations. No numeric behavioral-diversity measures reported beyond genome-size ranges and success counts.</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>null</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td>null</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>program synthesis (PushGP on general program synthesis benchmark suite of 29 CS textbook problems)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Benchmark genetic operators (alternation + uniform mutation + uniform close mutation mix), high-rate uniform mutation (uniform mutation rate 0.09), HAHD (Half Addition Half Deletion), growing/shrinking UMAD variants, combinations with alternation (50/50 UMAD+alternation).</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>UMAD (especially size‑neutral and shrinking variants) often outperformed the benchmark recombination + mutation mix, showing mutation-only search with dissociated insertions/deletions can improve the rate of producing executable, generalizing programs. UMAD's ability to add and delete in different places (and to change genome size) appears important; mixing UMAD with alternation (recombination) decreased performance on tested problems; UMAD is robust to large changes in addition/deletion rates, but growth-biased settings led to bloat and worse performance.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1626.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e1626.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>HAHD</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Half Addition, Half Deletion (HAHD)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An experimental mutation-only variant that constructs each child by either (with 50% probability) performing addition-only mutations or (with 50% probability) performing deletion-only mutations, using the same per-gene addition and deletion probabilities as UMAD.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Half Addition Half Deletion (HAHD)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>HAHD is a two-mode single-parent mutation scheme: when creating a child, with probability 0.5 perform only additions (probabilistic insertion before/after genes using the same additionRate as UMAD) or with probability 0.5 perform only deletions (probabilistic deletion across the parent genome using the same deletionRate as UMAD). Over multiple generations HAHD can effect both additions and deletions but never in the same single mutation event.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Either addition-only (for each parent gene, with additionRate insert a random gene before/after) or deletion-only (for each gene, with deletionRate delete it), chosen per-child with 50% probability each.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Same success-rate metric (number of runs out of 100 producing generalizing solutions).</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>HAHD performed worse than UMAD in many comparisons but was often better than the benchmark operators; it never was significantly worse than UMAD in the reported experiments. In Table 2 HAHD improved over benchmark in some problems but had fewer significant improvements than UMAD.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Genotypic size dynamics (implicit), no explicit novelty metric.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td>HAHD showed generally weaker genome-size control compared to UMAD and produced fewer instances of significant improvement over the benchmark, suggesting that performing additions and deletions in the same mutation event (as UMAD does) is beneficial.</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>null</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td>null</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>program synthesis (PushGP)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>UMAD variants, high-rate uniform mutation, benchmark genetic operators</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>HAHD indicates that performing additions and deletions in separate mutation steps is less effective than dissociating them within the same mutation event (UMAD), implying that the simultaneous possibility of addition+deletion in different genome locations helps search.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1626.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e1626.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Uniform mutation (high-rate)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Uniform mutation (replacement-based) with high mutation rate</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Per-gene replacement mutation where each gene in the parent is independently replaced by a randomly generated gene with some mutation probability; this study tested a high-rate variant (0.09) relative to conventional 0.01.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Uniform per-gene replacement mutation</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>The operator copies the parent genome to the child except each gene has an independent probability (mutationRate) of being replaced by a new randomly generated gene at the same position; genome length is preserved. The paper compares a conventional low-rate (0.01) and a high-rate (0.09) variant.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Per-gene replacement: for each gene of the parent, with probability mutationRate replace it in the child with a newly generated random gene at the same index; child genome length equals parent length.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Success rate (runs out of 100 producing generalizing solutions).</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>High-rate uniform mutation (0.09) generally outperformed the prior benchmark operator set on many problems and in some cases was competitive with UMAD, but UMAD outperformed this high-rate uniform mutation on several problems. Example from Table 2: Replace Space With Newline 92/100 (Uni. mut. 0.09) vs Benchmark 58/100; UMAD had 87/100 on same problem.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Implicit genotypic size stability (uniform mutation preserves genome length) and observed population homogeneity events in which entire populations had identical genome sizes for many generations (horizontal lines in genome-size plots).</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td>Uniform mutation preserves genome sizes, which led to runs where one genome size dominated for many generations; despite that, it produced competitive success rates on many problems, though UMAD often produced higher success rates.</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>null</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td>null</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>program synthesis (PushGP)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>UMAD variants, HAHD, benchmark genetic operators</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Higher uniform mutation rates than historically used (0.09 vs 0.01) substantially improved mutation-only performance and in some cases approached UMAD's effectiveness, but dissociating insertion and deletion (UMAD) and permitting changes in genome length contributed additional benefits.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1626.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e1626.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Alternation</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Alternation (recombination crossover operator)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A crossover operator for linear genomes that constructs children by copying genes alternately from two parents, with probabilistic switching and optional index deviation when switching between parents.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Alternation crossover</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Alternation creates a child by copying genes from one parent, and at each gene position with some probability switching to the other parent; when switching parents the read index in the source parent may randomly deviate forward or backward (alignment deviation parameter). This operator sources replacement subprogram material from a second parent rather than random generation.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Child genome constructed by copying genes from parent A or B at each step; at each step a switch between parents occurs with a given alternation probability, and when switching the source index can be offset by a random alignment deviation (positive or negative), producing non-trivial recombinations of gene sequences.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Success rate (runs out of 100 that generalize).</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>Alternation is part of the benchmark operator mix; when mixed 50/50 with UMAD, alternation reduced UMAD's performance on tested problems (UMAD alone outperformed the 50/50 UMAD+alternation mix on Replace Space With Newline and Vector Average).</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Implicit recombinative genotypic mixing across population; no explicit diversity metric reported.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td>Using alternation alongside UMAD (50/50) decreased success rates relative to UMAD alone, indicating that recombination as implemented did not consistently improve discovery of executable programs in these experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>null</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td>null</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>program synthesis (PushGP)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Used within benchmark genetic operator mix and in experiments combining alternation with UMAD.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Alternation (recombination) did not improve and in some cases harmed performance when combined with UMAD; this questions the necessity of recombination for these PushGP program-synthesis problems under tested settings.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1626.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e1626.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Benchmark ops</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Benchmark genetic operators (prior PushGP settings)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>The previously used combination of genetic operators for PushGP including alternation (crossover), uniform mutation (replacement), and uniform close mutation, used as the baseline in experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Benchmark genetic operators (PushGP default mix)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>A mixed operator regime: alternation (probability 0.2), uniform mutation (probability 0.2) at low mutation rate (0.01 per gene), uniform close mutation (probability 0.1), and alternation followed by uniform mutation (probability 0.5) as specified in the paper's Table 1. This mix had been used in prior PushGP benchmark experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Alternation (as described) is the primary recombination mechanism in the baseline.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Uniform per-gene replacement mutation at rate 0.01 (default) and uniform close mutation that perturbs epigenetic close markers (each marker inc/dec with prob 0.1).</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Success rate (runs out of 100 producing generalizing solutions).</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>The benchmark operator mix was outperformed on many problems by mutation-only methods (UMAD, HAHD, and high-rate uniform mutation); e.g., Vector Average benchmark 43/100 vs UMAD 88/100.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Implicit via mixed operators and lexicase selection; no explicit numeric diversity metric reported.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td>Benchmark mix produced lower success rates on many benchmark problems compared to mutation-only configurations, suggesting its operator mix yielded less effective traversal of the search space under tested settings.</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>null</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td>null</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>program synthesis (PushGP)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Compared against UMAD variants, HAHD, high-rate uniform mutation, and combinations with alternation.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>The previous mixed-operator baseline was frequently outperformed by mutation-only approaches, calling into question the assumed necessity of crossover in this domain under these representations and selection methods.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1626.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e1626.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>PushGP / Plush</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>PushGP with linear Plush genomes</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>PushGP is a genetic programming system that evolves Push programs; recent implementations represent programs as linear 'Plush' genomes (linear sequences of genes that translate to hierarchical Push code), enabling usage of linear-genome genetic operators.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>PushGP (Plush genomes)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>PushGP evolves programs in the Push language. In the Plush representation, programs are represented as linear gene sequences where each gene encodes an instruction or constant and epigenetic close markers mark block ends; genomes are translated into hierarchical Push programs before execution. The linear form allows GA-like per-gene mutation and alternation crossover.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Alternation and other linear crossover variants (e.g., alternation with alignment deviation) were used on Plush genomes; subtree crossover is not directly used on linear genomes here.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Operators applied to Plush genomes included UMAD, uniform per-gene replacement mutation, and uniform close mutation (perturbing close markers).</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Success rate (runs out of 100 producing generalizing Push programs that pass training and withheld test cases).</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>PushGP with UMAD achieved the highest reported success rates on many of the program-synthesis benchmark problems compared to previous PushGP operator settings.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Population-based behavioral/genotypic diversity is encouraged via lexicase selection; genome-size dynamics were used to study genotypic diversity.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td>Average genome sizes and their dynamics across runs were reported; Plush genomes enabled both replacement-based and add/delete based mutations producing different diversity dynamics.</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>null</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td>null</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>program synthesis</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>PushGP prior operator settings (benchmark operators) and mutation-only variants</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>The Plush linear genome representation supports UMAD effectively; mutation-only regimes on Plush genomes can outperform traditional recombination-heavy baselines on program synthesis tasks.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1626.6">
                <h3 class="extraction-instance">Extracted Data Instance 6 (e1626.6)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Uniform close mutation</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Uniform close mutation (epigenetic marker mutation)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A mutation operator that perturbs epigenetic close markers in Plush genomes, incrementing or decrementing each close marker with some probability, thereby altering hierarchical code block structure when genomes are translated to Push programs.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Uniform close mutation</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Applied to Plush genomes where close markers delimit code blocks; for each epigenetic close marker, with probability p (e.g., 0.1) increment or decrement its value, changing where blocks close and hence the hierarchical structure of the translated Push program.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Per-marker perturbation: each 'close' marker is independently incremented or decremented with specified probability, altering code block boundaries.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Success rate (used in benchmark operator mix).</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>Uniform close mutation was part of the benchmark operator mix; mutation-only regimes that excluded this operator but used UMAD or high-rate uniform mutation often outperformed the benchmark mix that included uniform close mutation.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Structural (epigenetic) genotypic variation; no explicit numeric diversity metric reported.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td>Was used to provide structural variation in the baseline but did not lead to higher success rates than mutation-only regimes tested.</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>null</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td>null</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>program synthesis (PushGP)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Part of benchmark genetic operators</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Uniform close mutation can alter program structure via epigenetic markers, but in the reported experiments, overall operator mixes that included this operator were outperformed by UMAD-based mutation-only approaches.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1626.7">
                <h3 class="extraction-instance">Extracted Data Instance 7 (e1626.7)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Lexicase</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Lexicase selection</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A parent selection algorithm that randomly orders test cases and filters the population by keeping only those individuals that are tied for best on the current case, proceeding case-by-case until one parent remains, thereby emphasizing diverse partial solutions.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Lexicase selection</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Selection method used for parent selection in all experiments. For each parent selection, the set of training cases is shuffled and individuals are filtered iteratively by keeping only those tied for best on each case; this tends to maintain behavioral diversity because different selections emphasize different cases.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Implicit: lexicase selection aims to maintain partial solutions that perform best on subsets of cases; effectiveness measured by downstream success rates.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>Authors hypothesize larger population sizes are necessary with lexicase selection to ensure coverage of many test cases; empirically, very small populations (size 10) had poor success rates while sizes 100–10,000 were generally adequate (with caveats about generation counts).</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Behavioral diversity preserved by case-wise filtering; no explicit quantitative diversity metric other than empirical success rates and qualitative reasoning.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td>Evidence that small populations lead to loss of diversity and poor performance; larger populations allow lexicase to maintain diverse partial solutions leading to higher success rates.</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>null</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td>null</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>program synthesis (PushGP)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Used consistently across experiments, discussed in relation to population size effects and need for diversity.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Lexicase selection helps maintain diverse lines of search by emphasizing different test cases; mutation-only approaches like UMAD still require adequately large populations under lexicase selection to perform well.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Linear Genomes for Structured Programs <em>(Rating: 2)</em></li>
                <li>Genetic Programming and Autoconstructive Evolution with the Push Programming Language <em>(Rating: 2)</em></li>
                <li>A field guide to genetic programming <em>(Rating: 1)</em></li>
                <li>Comparing subtree crossover with macromutation <em>(Rating: 1)</em></li>
                <li>A Rigorous Evaluation of Crossover and Mutation in Genetic Programming <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-1626",
    "paper_id": "paper-49644635",
    "extraction_schema_id": "extraction-schema-31",
    "extracted_data": [
        {
            "name_short": "UMAD",
            "name_full": "Uniform Mutation by Addition and Deletion",
            "brief_description": "A variable-length, uniform single‑parent mutation operator that first probabilistically inserts random genes before/after each gene (addition rate) and then probabilistically deletes genes from the augmented genome (deletion rate), allowing additions and deletions to be dissociated in location and number.",
            "citation_title": "here",
            "mention_or_use": "use",
            "system_name": "Uniform Mutation by Addition and Deletion (UMAD)",
            "system_description": "UMAD is a mutation-only genetic operator applied to linear genomes (Plush genomes) encoding Push programs. For each gene in a parent genome it independently (1) with probability additionRate adds a newly generated random gene before or after that gene and (2) after all additions, with probability deletionRate deletes each gene in the augmented genome. Addition and deletion rates can be chosen to be size‑neutral or biased to grow/shrink offspring. UMAD was used as the sole variation operator (no crossover) in evolutionary runs on program synthesis benchmarks.",
            "input_type": "programs",
            "crossover_operation": null,
            "mutation_operation": "Two-stage uniform operation: (a) for each parent gene, with probability additionRate insert a random gene immediately before or after that gene (new genes generated same as for random initialization); (b) on the resulting augmented genome, for each gene independently delete it with probability deletionRate. The deletionRate can be chosen (using deletionRate = additionRate / (1 + additionRate)) to make operation size-neutral on average, or adjusted to bias growth/shrinkage.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Success rate = number of independent GP runs (out of 100) that produced programs passing all training cases and also generalizing on withheld unseen test cases (solutions simplified before generalization check).",
            "executability_results": "UMAD substantially improved executable/generalizing solution rates versus prior benchmark operators on many problems. Examples from Table 2: Replace Space With Newline 87/100 (UMAD) vs 58/100 (Benchmark); Vector Average 88/100 vs 43/100; Syllables 38/100 vs 24/100. UMAD variants (size-neutral and shrinking) were among top performers and were significantly better than benchmark on ~9 problems (see Table 2 summary).",
            "diversity_metric": "Genotypic size distributions (average genome length over generations) and population-based diversity implicitly via lexicase selection; no formal novelty score was measured.",
            "diversity_results": "UMAD produced varied genome-size dynamics across runs (some runs grew average genome size &gt;500, others shrank to ~50). Shrinking UMAD drove average genome size downward (floor observed), growing UMAD drove sizes up until capped by maximum genome size producing oscillations. No numeric behavioral-diversity measures reported beyond genome-size ranges and success counts.",
            "novelty_executability_tradeoff": "null",
            "frontier_characterization": "null",
            "benchmark_or_domain": "program synthesis (PushGP on general program synthesis benchmark suite of 29 CS textbook problems)",
            "comparison_baseline": "Benchmark genetic operators (alternation + uniform mutation + uniform close mutation mix), high-rate uniform mutation (uniform mutation rate 0.09), HAHD (Half Addition Half Deletion), growing/shrinking UMAD variants, combinations with alternation (50/50 UMAD+alternation).",
            "key_findings": "UMAD (especially size‑neutral and shrinking variants) often outperformed the benchmark recombination + mutation mix, showing mutation-only search with dissociated insertions/deletions can improve the rate of producing executable, generalizing programs. UMAD's ability to add and delete in different places (and to change genome size) appears important; mixing UMAD with alternation (recombination) decreased performance on tested problems; UMAD is robust to large changes in addition/deletion rates, but growth-biased settings led to bloat and worse performance.",
            "uuid": "e1626.0"
        },
        {
            "name_short": "HAHD",
            "name_full": "Half Addition, Half Deletion (HAHD)",
            "brief_description": "An experimental mutation-only variant that constructs each child by either (with 50% probability) performing addition-only mutations or (with 50% probability) performing deletion-only mutations, using the same per-gene addition and deletion probabilities as UMAD.",
            "citation_title": "here",
            "mention_or_use": "use",
            "system_name": "Half Addition Half Deletion (HAHD)",
            "system_description": "HAHD is a two-mode single-parent mutation scheme: when creating a child, with probability 0.5 perform only additions (probabilistic insertion before/after genes using the same additionRate as UMAD) or with probability 0.5 perform only deletions (probabilistic deletion across the parent genome using the same deletionRate as UMAD). Over multiple generations HAHD can effect both additions and deletions but never in the same single mutation event.",
            "input_type": "programs",
            "crossover_operation": null,
            "mutation_operation": "Either addition-only (for each parent gene, with additionRate insert a random gene before/after) or deletion-only (for each gene, with deletionRate delete it), chosen per-child with 50% probability each.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Same success-rate metric (number of runs out of 100 producing generalizing solutions).",
            "executability_results": "HAHD performed worse than UMAD in many comparisons but was often better than the benchmark operators; it never was significantly worse than UMAD in the reported experiments. In Table 2 HAHD improved over benchmark in some problems but had fewer significant improvements than UMAD.",
            "diversity_metric": "Genotypic size dynamics (implicit), no explicit novelty metric.",
            "diversity_results": "HAHD showed generally weaker genome-size control compared to UMAD and produced fewer instances of significant improvement over the benchmark, suggesting that performing additions and deletions in the same mutation event (as UMAD does) is beneficial.",
            "novelty_executability_tradeoff": "null",
            "frontier_characterization": "null",
            "benchmark_or_domain": "program synthesis (PushGP)",
            "comparison_baseline": "UMAD variants, high-rate uniform mutation, benchmark genetic operators",
            "key_findings": "HAHD indicates that performing additions and deletions in separate mutation steps is less effective than dissociating them within the same mutation event (UMAD), implying that the simultaneous possibility of addition+deletion in different genome locations helps search.",
            "uuid": "e1626.1"
        },
        {
            "name_short": "Uniform mutation (high-rate)",
            "name_full": "Uniform mutation (replacement-based) with high mutation rate",
            "brief_description": "Per-gene replacement mutation where each gene in the parent is independently replaced by a randomly generated gene with some mutation probability; this study tested a high-rate variant (0.09) relative to conventional 0.01.",
            "citation_title": "",
            "mention_or_use": "use",
            "system_name": "Uniform per-gene replacement mutation",
            "system_description": "The operator copies the parent genome to the child except each gene has an independent probability (mutationRate) of being replaced by a new randomly generated gene at the same position; genome length is preserved. The paper compares a conventional low-rate (0.01) and a high-rate (0.09) variant.",
            "input_type": "programs",
            "crossover_operation": null,
            "mutation_operation": "Per-gene replacement: for each gene of the parent, with probability mutationRate replace it in the child with a newly generated random gene at the same index; child genome length equals parent length.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Success rate (runs out of 100 producing generalizing solutions).",
            "executability_results": "High-rate uniform mutation (0.09) generally outperformed the prior benchmark operator set on many problems and in some cases was competitive with UMAD, but UMAD outperformed this high-rate uniform mutation on several problems. Example from Table 2: Replace Space With Newline 92/100 (Uni. mut. 0.09) vs Benchmark 58/100; UMAD had 87/100 on same problem.",
            "diversity_metric": "Implicit genotypic size stability (uniform mutation preserves genome length) and observed population homogeneity events in which entire populations had identical genome sizes for many generations (horizontal lines in genome-size plots).",
            "diversity_results": "Uniform mutation preserves genome sizes, which led to runs where one genome size dominated for many generations; despite that, it produced competitive success rates on many problems, though UMAD often produced higher success rates.",
            "novelty_executability_tradeoff": "null",
            "frontier_characterization": "null",
            "benchmark_or_domain": "program synthesis (PushGP)",
            "comparison_baseline": "UMAD variants, HAHD, benchmark genetic operators",
            "key_findings": "Higher uniform mutation rates than historically used (0.09 vs 0.01) substantially improved mutation-only performance and in some cases approached UMAD's effectiveness, but dissociating insertion and deletion (UMAD) and permitting changes in genome length contributed additional benefits.",
            "uuid": "e1626.2"
        },
        {
            "name_short": "Alternation",
            "name_full": "Alternation (recombination crossover operator)",
            "brief_description": "A crossover operator for linear genomes that constructs children by copying genes alternately from two parents, with probabilistic switching and optional index deviation when switching between parents.",
            "citation_title": "",
            "mention_or_use": "use",
            "system_name": "Alternation crossover",
            "system_description": "Alternation creates a child by copying genes from one parent, and at each gene position with some probability switching to the other parent; when switching parents the read index in the source parent may randomly deviate forward or backward (alignment deviation parameter). This operator sources replacement subprogram material from a second parent rather than random generation.",
            "input_type": "programs",
            "crossover_operation": "Child genome constructed by copying genes from parent A or B at each step; at each step a switch between parents occurs with a given alternation probability, and when switching the source index can be offset by a random alignment deviation (positive or negative), producing non-trivial recombinations of gene sequences.",
            "mutation_operation": null,
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Success rate (runs out of 100 that generalize).",
            "executability_results": "Alternation is part of the benchmark operator mix; when mixed 50/50 with UMAD, alternation reduced UMAD's performance on tested problems (UMAD alone outperformed the 50/50 UMAD+alternation mix on Replace Space With Newline and Vector Average).",
            "diversity_metric": "Implicit recombinative genotypic mixing across population; no explicit diversity metric reported.",
            "diversity_results": "Using alternation alongside UMAD (50/50) decreased success rates relative to UMAD alone, indicating that recombination as implemented did not consistently improve discovery of executable programs in these experiments.",
            "novelty_executability_tradeoff": "null",
            "frontier_characterization": "null",
            "benchmark_or_domain": "program synthesis (PushGP)",
            "comparison_baseline": "Used within benchmark genetic operator mix and in experiments combining alternation with UMAD.",
            "key_findings": "Alternation (recombination) did not improve and in some cases harmed performance when combined with UMAD; this questions the necessity of recombination for these PushGP program-synthesis problems under tested settings.",
            "uuid": "e1626.3"
        },
        {
            "name_short": "Benchmark ops",
            "name_full": "Benchmark genetic operators (prior PushGP settings)",
            "brief_description": "The previously used combination of genetic operators for PushGP including alternation (crossover), uniform mutation (replacement), and uniform close mutation, used as the baseline in experiments.",
            "citation_title": "",
            "mention_or_use": "use",
            "system_name": "Benchmark genetic operators (PushGP default mix)",
            "system_description": "A mixed operator regime: alternation (probability 0.2), uniform mutation (probability 0.2) at low mutation rate (0.01 per gene), uniform close mutation (probability 0.1), and alternation followed by uniform mutation (probability 0.5) as specified in the paper's Table 1. This mix had been used in prior PushGP benchmark experiments.",
            "input_type": "programs",
            "crossover_operation": "Alternation (as described) is the primary recombination mechanism in the baseline.",
            "mutation_operation": "Uniform per-gene replacement mutation at rate 0.01 (default) and uniform close mutation that perturbs epigenetic close markers (each marker inc/dec with prob 0.1).",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Success rate (runs out of 100 producing generalizing solutions).",
            "executability_results": "The benchmark operator mix was outperformed on many problems by mutation-only methods (UMAD, HAHD, and high-rate uniform mutation); e.g., Vector Average benchmark 43/100 vs UMAD 88/100.",
            "diversity_metric": "Implicit via mixed operators and lexicase selection; no explicit numeric diversity metric reported.",
            "diversity_results": "Benchmark mix produced lower success rates on many benchmark problems compared to mutation-only configurations, suggesting its operator mix yielded less effective traversal of the search space under tested settings.",
            "novelty_executability_tradeoff": "null",
            "frontier_characterization": "null",
            "benchmark_or_domain": "program synthesis (PushGP)",
            "comparison_baseline": "Compared against UMAD variants, HAHD, high-rate uniform mutation, and combinations with alternation.",
            "key_findings": "The previous mixed-operator baseline was frequently outperformed by mutation-only approaches, calling into question the assumed necessity of crossover in this domain under these representations and selection methods.",
            "uuid": "e1626.4"
        },
        {
            "name_short": "PushGP / Plush",
            "name_full": "PushGP with linear Plush genomes",
            "brief_description": "PushGP is a genetic programming system that evolves Push programs; recent implementations represent programs as linear 'Plush' genomes (linear sequences of genes that translate to hierarchical Push code), enabling usage of linear-genome genetic operators.",
            "citation_title": "",
            "mention_or_use": "use",
            "system_name": "PushGP (Plush genomes)",
            "system_description": "PushGP evolves programs in the Push language. In the Plush representation, programs are represented as linear gene sequences where each gene encodes an instruction or constant and epigenetic close markers mark block ends; genomes are translated into hierarchical Push programs before execution. The linear form allows GA-like per-gene mutation and alternation crossover.",
            "input_type": "programs",
            "crossover_operation": "Alternation and other linear crossover variants (e.g., alternation with alignment deviation) were used on Plush genomes; subtree crossover is not directly used on linear genomes here.",
            "mutation_operation": "Operators applied to Plush genomes included UMAD, uniform per-gene replacement mutation, and uniform close mutation (perturbing close markers).",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Success rate (runs out of 100 producing generalizing Push programs that pass training and withheld test cases).",
            "executability_results": "PushGP with UMAD achieved the highest reported success rates on many of the program-synthesis benchmark problems compared to previous PushGP operator settings.",
            "diversity_metric": "Population-based behavioral/genotypic diversity is encouraged via lexicase selection; genome-size dynamics were used to study genotypic diversity.",
            "diversity_results": "Average genome sizes and their dynamics across runs were reported; Plush genomes enabled both replacement-based and add/delete based mutations producing different diversity dynamics.",
            "novelty_executability_tradeoff": "null",
            "frontier_characterization": "null",
            "benchmark_or_domain": "program synthesis",
            "comparison_baseline": "PushGP prior operator settings (benchmark operators) and mutation-only variants",
            "key_findings": "The Plush linear genome representation supports UMAD effectively; mutation-only regimes on Plush genomes can outperform traditional recombination-heavy baselines on program synthesis tasks.",
            "uuid": "e1626.5"
        },
        {
            "name_short": "Uniform close mutation",
            "name_full": "Uniform close mutation (epigenetic marker mutation)",
            "brief_description": "A mutation operator that perturbs epigenetic close markers in Plush genomes, incrementing or decrementing each close marker with some probability, thereby altering hierarchical code block structure when genomes are translated to Push programs.",
            "citation_title": "",
            "mention_or_use": "use",
            "system_name": "Uniform close mutation",
            "system_description": "Applied to Plush genomes where close markers delimit code blocks; for each epigenetic close marker, with probability p (e.g., 0.1) increment or decrement its value, changing where blocks close and hence the hierarchical structure of the translated Push program.",
            "input_type": "programs",
            "crossover_operation": null,
            "mutation_operation": "Per-marker perturbation: each 'close' marker is independently incremented or decremented with specified probability, altering code block boundaries.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Success rate (used in benchmark operator mix).",
            "executability_results": "Uniform close mutation was part of the benchmark operator mix; mutation-only regimes that excluded this operator but used UMAD or high-rate uniform mutation often outperformed the benchmark mix that included uniform close mutation.",
            "diversity_metric": "Structural (epigenetic) genotypic variation; no explicit numeric diversity metric reported.",
            "diversity_results": "Was used to provide structural variation in the baseline but did not lead to higher success rates than mutation-only regimes tested.",
            "novelty_executability_tradeoff": "null",
            "frontier_characterization": "null",
            "benchmark_or_domain": "program synthesis (PushGP)",
            "comparison_baseline": "Part of benchmark genetic operators",
            "key_findings": "Uniform close mutation can alter program structure via epigenetic markers, but in the reported experiments, overall operator mixes that included this operator were outperformed by UMAD-based mutation-only approaches.",
            "uuid": "e1626.6"
        },
        {
            "name_short": "Lexicase",
            "name_full": "Lexicase selection",
            "brief_description": "A parent selection algorithm that randomly orders test cases and filters the population by keeping only those individuals that are tied for best on the current case, proceeding case-by-case until one parent remains, thereby emphasizing diverse partial solutions.",
            "citation_title": "",
            "mention_or_use": "use",
            "system_name": "Lexicase selection",
            "system_description": "Selection method used for parent selection in all experiments. For each parent selection, the set of training cases is shuffled and individuals are filtered iteratively by keeping only those tied for best on each case; this tends to maintain behavioral diversity because different selections emphasize different cases.",
            "input_type": "programs",
            "crossover_operation": null,
            "mutation_operation": null,
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Implicit: lexicase selection aims to maintain partial solutions that perform best on subsets of cases; effectiveness measured by downstream success rates.",
            "executability_results": "Authors hypothesize larger population sizes are necessary with lexicase selection to ensure coverage of many test cases; empirically, very small populations (size 10) had poor success rates while sizes 100–10,000 were generally adequate (with caveats about generation counts).",
            "diversity_metric": "Behavioral diversity preserved by case-wise filtering; no explicit quantitative diversity metric other than empirical success rates and qualitative reasoning.",
            "diversity_results": "Evidence that small populations lead to loss of diversity and poor performance; larger populations allow lexicase to maintain diverse partial solutions leading to higher success rates.",
            "novelty_executability_tradeoff": "null",
            "frontier_characterization": "null",
            "benchmark_or_domain": "program synthesis (PushGP)",
            "comparison_baseline": "Used consistently across experiments, discussed in relation to population size effects and need for diversity.",
            "key_findings": "Lexicase selection helps maintain diverse lines of search by emphasizing different test cases; mutation-only approaches like UMAD still require adequately large populations under lexicase selection to perform well.",
            "uuid": "e1626.7"
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Linear Genomes for Structured Programs",
            "rating": 2,
            "sanitized_title": "linear_genomes_for_structured_programs"
        },
        {
            "paper_title": "Genetic Programming and Autoconstructive Evolution with the Push Programming Language",
            "rating": 2,
            "sanitized_title": "genetic_programming_and_autoconstructive_evolution_with_the_push_programming_language"
        },
        {
            "paper_title": "A field guide to genetic programming",
            "rating": 1,
            "sanitized_title": "a_field_guide_to_genetic_programming"
        },
        {
            "paper_title": "Comparing subtree crossover with macromutation",
            "rating": 1,
            "sanitized_title": "comparing_subtree_crossover_with_macromutation"
        },
        {
            "paper_title": "A Rigorous Evaluation of Crossover and Mutation in Genetic Programming",
            "rating": 1,
            "sanitized_title": "a_rigorous_evaluation_of_crossover_and_mutation_in_genetic_programming"
        }
    ],
    "cost": 0.0161705,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>Program Synthesis using Uniform Mutation by Addition and Deletion</p>
<p>Thomas Helmuth thelmuth@hamilton.edu 
Hamilton College Clinton
New YorkUSA</p>
<p>Nicholas Freitag Mcphee mcphee@morris.umn.edu 
University of Minnesota
Morris MorrisMinnesotaUSA</p>
<p>Lee Spector lspector@hampshire.edu 
Hampshire College Amherst
MassachusettsUSA</p>
<p>Program Synthesis using Uniform Mutation by Addition and Deletion
ACM Reference Format: Thomas Helmuth, Nicholas Freitag McPhee, and Lee Spector. 2018. Program Synthesis using Uniform Mutation by Addition and Deletion. In GECCO '18: Genetic and Evolutionary Computation Conference, July 15-19, 2018, Kyoto, Japan. ACM, New York, NY, USA, 8 pages. https://CCS CONCEPTS • Computing methodologies → Genetic programming; KEYWORDS mutationgenetic operatorsPushprogram synthesis
Most genetic programming systems use mutation and crossover operators to create child programs from selected parent programs. Typically, the mutation operator will replace a randomly chosen subprogram in the parent with a new, randomly generated subprogram. In systems with linear genomes, a uniform mutation operator can be used that has some probability of replacing any particular gene with a new, randomly chosen gene. In this paper, we present a new uniform mutation operator called Uniform Mutation by Addition and Deletion (UMAD), which rst adds genes with some probability before or after every existing gene, and then deletes random genes from the resulting genome. In UMAD it is not necessary that the new genes replace old genes, as the additions and deletions can occur in dierent locations. We nd that UMAD, with relatively high rates of addition and deletion, results in signicant increases in problem-solving performance on a range of program synthesis benchmark problems. In our experiments, we compare this method to a variety of alternatives, showing that it equals or outperforms all of them. We explore this new mutation operator and other wellperforming high-rate mutation schemes to determine what traits are crucial to improved performance.</p>
<p>INTRODUCTION</p>
<p>Genetic programming (GP) is a problem solving tool that begins with a population of random programs, and produces a succession Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for prot or commercial advantage and that copies bear this notice and the full citation on the rst page. Copyrights for components of this work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specic permission and/or a fee. Request permissions from permissions@acm.org. GECCO '18, July [15][16][17][18][19]2018 of populations, each derived from previous, with the aim of nding a program that solves a given target problem. Each new program is produced by passing one or more selected parents to genetic operators that construct children, incorporating material from the parents while also introducing variation. The traditional approach produces some children for each population with a mutation operator that uses material only from a single parent, and others with a recombination or crossover operator that uses material from two parents. The traditional mutation operator replaces a randomly chosen subprogram of the single parent program with a new, randomly generated subprogram. The traditional crossover operator does something similar but obtains the replacement subprogram from a second parent, rather than generating it randomly. Many variants of these methods have been explored in the literature; for example, see the "Mutation Cookbook" section of [14].</p>
<p>Here we describe a novel single-parent mutation operator, which we demonstrate in the context of genetic programming on benchmark software synthesis problems [6]. We show that by using this novel mutation operator, without any form of crossover, we achieve signicant and general improvements in program synthesis, improving the state of the art over all previous known approaches.</p>
<p>This new operator, which we call Uniform Mutation by Addition and Deletion (UMAD), stems from the idea that mutations based on replacement, such as the traditional mutation operator, are overly constrained. They delete parts of a parent program and add new parts, but the additions are always in the same places as the deletions. With UMAD we dissociate the additions from the deletions, so that we can get one without the other and/or both but in different parts of the parent program. Intriguingly, the high levels of problem-solving performance that we demonstrate with UMADthe highest ever demonstrated for the general program synthesis benchmarks considered here-are achieved without recombination.</p>
<p>One explanation for improved performance with dissociated additions and deletions, relative to replacements, is that the former can provide more paths through the search space from a parent to a descendant than can the latter. For example, if we have a parent ABC and we seek a child ADC, in a context in which the loss of either A or C would be fatal, then there is only one path to ADC by replacement: replacing B with D. With dissociated additions and deletions, it would still be possible to go directly from ABC to ADC but there would also be additional paths, including paths through AC, ABDC, and ADBC. Depending on the details of the program representation and the problem's tness function, some of these alternative paths might either be more likely to arise randomly or more likely to be favored, at each step, by selection.</p>
<p>Here we study UMAD in the context of the PushGP genetic programming system [15,16], recent versions of which generate and manipulate programs in the form of linear genomes [8]. It should be directly applicable, however, to any genetic programming system that uses linear program representations, and the general idea may be applicable to non-linear representations as well.</p>
<p>Among our ndings is that UMAD works well with mutation rates that are considerably higher than those generally used in the eld. For this reason, we also present the results of experiments using replacement-based mutation with the same high rates; we nd that this also works surprisingly well, but not as well as UMAD.</p>
<p>Because gene addition and deletion are dissociated in UMAD, the rates of addition and deletion can be set independently. While some settings are size neutral on average, others produce a bias toward smaller or larger programs. In the experiments described here, we explore the eects of these settings.</p>
<p>In the following section we describe the PushGP system in which our experiments are conducted, along with the genetic operators against which we will later compare UMAD. We then describe UMAD itself, our experimental design, and the results of our experiments. After discussing results we describe related work and draw general conclusions, including suggestions for future research.</p>
<p>PUSHGP</p>
<p>PushGP is a GP system that evolves Push programs [15,16]. Push is a stack-based language that uses a separate stack for each data type, including a stack for program code that remains to be executed. These features facilitate the evolution of programs that involve multiple data types and non-trivial control structures, including for general program synthesis benchmark problems [6].</p>
<p>Although Push programs can have a nested, hierarchical structure, recent versions of PushGP represent the programs in their populations as linear sequences of genes. These sequences, which are called "Plush genomes" (the "l" is for "linear"), are translated into Push programs prior to execution [8]. Each gene in a Plush genome species an instruction or a constant, and when certain instructions (such as conditional or looping instructions) are processed for translation to a Push program, one or more code blocks may be opened, resulting in a hierarchical Push program. Genes in a Plush genome also include epigenetic close markers that specify where these code blocks end. We initialize random Plush genomes by simply creating sequences of random genes, with each gene having a random instruction and close marker.</p>
<p>When using linear Plush genomes, we can vary individuals using methods similar to those developed for genetic algorithms that operate on linear genomes. The primary genetic operators used in prior work are uniform mutation, alternation and uniform close mutation. In uniform mutation, each gene in a single parent has a specied probability of being replaced by a new, randomly generated gene in the child program that is otherwise copied directly from the parent. Note that the child will always be the same size as its parent. In alternation, a crossover operator, two selected parents serve as source material for the child; initially, genes are copied from one of the parents, but copying alternates between the two parents with some probability at each step as it proceeds. Furthermore, the index from which genes are being copied may randomly deviate either forward or backward when switching between parents. In uniform close mutation, each epigenetic close marker has some probability of being incremented or decremented. These are described in more detail in [8].</p>
<p>Our experiments refer to a genetic operator setting used in previous papers on the problems studied here [6]; we call this setting the benchmark genetic operators (see Table 1), and we note that experiments have shown that 100% uniform mutation, with a rate of 0.01, can be almost equally eective [8].</p>
<p>UNIFORM MUTATION BY ADDITION AND DELETION</p>
<p>Uniform Mutation by Addition and Deletion (UMAD) could be applied to any variable-length linear genome representation in evolutionary computing. For each gene in a parent's genome, UMAD considers whether to add a new random gene before or after it with probability given by the parameter addition rate. Then, in this augmented genome, UMAD considers whether to delete each gene with probability given by the parameter deletion rate. This process is formalized in the Algorithm 1. UMAD is uniform in that every gene in the parent has equal chance of having a new gene added before or after it, and also has equal chance of being deleted. During the addition step of UMAD, we generate new genes using the same process used to generate random genomes, as described above. The addition and deletion rate parameters aect not only how much of the parent is changed in the child, but also whether this mutation will, on average, increase size, decrease size, or remain size-neutral. For a particular addition rate, using the same deletion rate will actually result in smaller child programs on average. In general, for UMAD to be size-neutral, the deletion rate needs to be set using the formula:
deletionRate = additionRate 1 + additionRate(1)
For example, in the extreme case of an addition rate of 1.0, after the addition step the genome will be twice as large as the parent; in order to reduce it to the parent's size, the deletion rate should be 0.5. In some of our experiments we test UMAD variants that are not size-neutral, and therefore grow or shrink children on average, by varying the deletion rate while holding the addition rate constant. </p>
<p>EXPERIMENTAL DESIGN</p>
<p>In our experiments we explore a variety of factors related to UMAD. Some of these experiments test variants of UMAD with dierent parameters or combined with other genetic operators. Others try to understand why UMAD works so well compared to our previously-used benchmark genetic operators, and ask questions about whether a large population is necessary even without crossover to recombine individuals.</p>
<p>To explore these questions, we focus on general program synthesis problems, where the aim is to generate programs sharing characteristics with programs that humans write. In particular, the problems tested here require programs to utilize a variety of data types and control ow structures. These experiments use problems from a recent program synthesis benchmark suite, composed of 29 problems from introductory computer science textbooks [6].</p>
<p>We use various subsets of this benchmark suite for dierent experiments, using more problems for more important experiments or when dierences in performance are not obvious from a few problems. In our main comparisons, we use 25 of the problems, only leaving o 4 problems that have never been previously solved. Every experiment includes, at minimum, the three problems Replace Space With Newline, Syllables, and Vector Average, as these are problems that have previously shown varying levels of diculty without being either trivial or impossible. To give some idea of the types of problems in the suite, we briey describe these three problems; more details and the remaining problems are described in the benchmark suite [6]:</p>
<p>• Replace Space With Newline (RSWN): Given a string input, the program must do two things: it must print the input string after replacing each space character with a newline character, and it must functionally return the number of non-whitespace characters in the string.</p>
<p>• Syllables: Given a string input, the program must print The number of syllables is X , where X is the number of vowels in the string. • Vector Average: Given a vector of oats, functionally return the average of those oats.</p>
<p>For our experiments, we used Clojush, 1 an implementation of the PushGP system written in Clojure. For each PushGP run we used a population size of 1000 and at most 300 generations, except for the Median, Number IO, and Smallest problems, which used at most 200 generations. The maximum Plush genome size varies per problem between 200 and 1000 instructions, as given with the original benchmark suite [6]. The experiments here used lexicase selection for parent selection [7], which has shown to produce signicantly better results than tools like tournament selection on these problems [6].</p>
<p>In our experiments, we measure problem solving performance as the number of GP runs out of 100 that solve the problem, which we call the success rate. In particular, we only count programs that return the correct answer on test cases used for training as well as on a withheld set of unseen data, to ensure that solutions generalize instead of simply memorizing answers [6]. Before testing for generalization, we automatically simplify the evolved programs that pass all of the training cases to create smaller programs with identical outputs on every training case; this was recently shown to improve generalization on the problems in the benchmark suite used here [3]. To test for signicant dierences in success rates, we use a pairwise chi-square test with Holm correction and a 0.05 signicance level. These tests are applied independently on each row of every results table in Section 5; no comparisons or corrections were performed across rows or across tables.</p>
<p>RESULTS</p>
<p>We designed a variety of experiments to learn more about UMAD and compare it to related genetic operators. While we performed numerous comparisons, there are many more that we could have performed. For some experiments we limited the number of problems tested once initial results made outcomes clear. • HAHD (Half Addition, Half Deletion), which half of the time uses addition alone to generate a child genome, and half of the time uses deletion alone. • Uniform mutation like that used in earlier work (e.g, [6]), but with a substantially higher mutation rate than that used before (0.09 instead of 0.01). • Benchmark genetic operators described in Section 2.</p>
<p>Initial Comparisons to UMAD</p>
<p>The three UMAD variants each use an addition rate of 0.09, but dier in their deletion rates:</p>
<p>• UMAD (or size-neutral UMAD) uses a deletion rate of 0.0826, computed using Eq. 1 so that on average, a child genome will have the same size as its parent genome.  Table 2: Number of successes out of 100 independent runs for three variations of UMAD, half addition and half deletion (HAHD), high-rate uniform mutation ("Uni. mut."), and the benchmark genetic operations on a range of software synthesis problems. "UMAD" is size neutral UMAD, shrinking UMAD (i.e. "UMAD#") is UMAD with a bias toward smaller genomes, and growing UMAD (i.e. "UMAD"") is UMAD with a bias toward larger genomes. Bold results are signicantly better than Benchmark using a pairwise chi-squared test (see Section 4 for details). No method was ever signicantly worse than Benchmark. Underlined results are signicantly worse than UMAD; no results were signicantly better.</p>
<p>• Shrinking UMAD ("UMAD#") uses a deletion rate of 0.1. This leads to a bias towards child genomes that are, on average, smaller than their parent genomes. • Growing UMAD ("UMAD"") uses a deletion rate of only 0.0652, causing child genomes to, on average, be larger than their parent genomes.</p>
<p>We discuss the eects on genome sizes in Section 5.5. Where UMAD performs a combination of additions and deletions as a single step to generate a child genome, HAHD does either addition or deletion to create a child, but not both. Each new individual has a 50% chance of being constructed via addition, and a 50% chance of being constructed via deletion. We compare UMAD with HAHD to determine whether it is important for UMAD to do additions and deletions in the same step. Over time HAHD can in principle accomplish the same changes as UMAD, but it is possible that the intermediate individuals that HAHD adds to the population might be selected either for or against in ways that would aect HAHD's ecacy. The version of HAHD used here uses the same addition and deletion rates as UMAD.</p>
<p>The uniform mutation operator used in earlier work [6] replaces genes in the parent with probability set by the mutation rate. Uniform mutation is similar to UMAD, except that a gene is always replaced by a gene in the same location, where with UMAD insertions and deletions are not correlated in position or number of changes. With our standard rates for addition and deletion, UMAD makes considerably more changes to a genome than the uniform mutation operator used in earlier work, where the default mutation rate was 0.01, i.e., one gene in a hundred would be replaced with a randomly generated gene. Of note, a previous experiment showed that only using uniform mutation with rate of 0.01 was approximately as good as using our benchmark genetic operators [8].</p>
<p>To gauge the importance of UMAD's ability to add genes in one location and remove them in another, we compare it to uniform mutation with a much higher mutation rate (0.09) than has been used in the past in the Uni. Mut. column of Table 2. Table 2 shows the number of successes out of 100 independent runs for each of the three variants of UMAD, HAHD, high-rate uniform mutation, and the benchmark set of genetic operators.</p>
<p>Here we see that the all of the purely mutational genetic operators outperform the benchmark set on almost every problem, frequently by wide margins. In quite a few cases, for example, one or more of the mutation-only approaches leads to over twice the number of successes achieved with the benchmark set of genetic operators.</p>
<p>Of the various operators in Table 2, size-neutral UMAD and shrinking UMAD consistently have the best success rates, with one ranked rst and the other ranked second for most of the test problems. The dierences in success rates between UMAD and shrinking UMAD are typically quite small, and one does not appear to have a meaningful advantage over the other, with no dierences ever being signicant. Both UMAD and shrinking UMAD are signicantly better than the benchmark operators on more than one third of the problems here, where the other three operator settings are not.</p>
<p>Growing UMAD was typically comparable to or better than the benchmark operator results, but was less successful than UMAD, and was signicantly worse on two problems. These results likely reect issues related to code growth, as we discuss when examining average program sizes in Section 5.5.</p>
<p>HAHD appears somewhat weaker than UMAD and shrinking UMAD, having fewer instances of signicant improvement over the benchmark operator. However, it was never signicantly worse than UMAD.</p>
<p>In general, UMAD outperformed high-rate uniform mutation, including by a signicant amount on three problems. Additionally, uniform mutation was signicantly better than the benchmark operators on only six problems, three fewer than UMAD.</p>
<p>To our knowledge, this is the rst time that GP has created generalizing solutions to the Super Anagrams problem. We have previously seen solutions that do not generalize, but never generalizing ones. Thus it is quite interesting that four dierent mutation-based methods found such solutions.</p>
<p>Overall, the results in Table 2 suggest that size-neutral UMAD and shrinking UMAD are generally similar to each other in performance, and generally better than any of the other options. Both HAHD and uniform mutation with a mutation rate of 0.09 also generally outperformed the benchmark set of genetic operators. It is important to note, however, that all of these approaches depend on particular parameter values, none of which were tuned extensively. These experiments, for example, only looked at one particular addition rate (0.09) for all three UMAD variants, and one mutation rate (0.09) for uniform mutation. It is thus certainly possible that there are other parameter settings that could further improve the performance of some of these approaches.</p>
<p>UMAD Addition and Deletion Rates</p>
<p>While size-neutral UMAD, with addition rate 0.09 and deletion rate 0.0826, performs signicantly better than our benchmark genetic operators, it was not clear whether these mostly arbitrary settings for addition and deletion rates were good choices. To explore whether higher or lower rates would produce even better results, we conducted sets of runs with addition rates both halved and doubled compared to our standard choices, with deletion rates computed using Eq. 1. Table 3 gives the results for these runs.</p>
<p>While for the most part the results with both higher and lower rates of addition and deletion resulted in similar success rates,  those with higher rates were a bit worse. With addition rate of 0.18 and deletion rate of 0.1525, UMAD produced signicantly worse results on the Syllables and X-Word Lines problems. On the other hand, with addition rate of 0.045 and deletion rate of 0.0431, UMAD performed similarly to standard UMAD on all problems, and only signicantly worse than UMAD with addition rate of 0.18 on one problem. These results suggest that UMAD is robust to large changes in the addition and deletion rates, since a 4-times dierence in rates produced very similar performance.</p>
<p>Population Size</p>
<p>An important question raised by the use of a mutation-only system is what role (if any) do populations play? Some sort of population is necessary when using recombination to provide a pool from which to draw pairs of parents. There is also evidence that populations provide a diverse pool of individuals for evolutionary search to act on [4,5]. When using just a single mutation operator like UMAD, it is less clear how important populations are to the process; in principle there's no reason UMAD could not be used in a singleindividual system such as a (1 + 1)-ES [2]. To help assess the importance of populations when using UMAD alone, we conducted runs with population sizes of 10, 100, 1,000, and 10,000; these results are summarized in Table 4. In each case we adjusted the number of generations so that the total number of individuals processed remained constant. For example, since our runs with population size of 1,000 were run for at most 300 generations, the runs with population size 100 had a maximum of 3,000 generations. Table 4 indicates there is some exibility in population size; for Replace Space With Newline, results are very similar with population sizes across three orders of magnitude (100, 1,000, and 10,000). Both Vector Average and Syllables show a drop in successes when using a population size of 10,000; it is possible here that the real issue is only having 30 generations, and that these problems often require more than 30 "evolutionary steps" to reach a solution.  Table 4: Number of successes out of 100 runs for four dierent population sizes using UMAD on three problems. In each case the total number of generations was adjusted so that the total number of individuals processed remained constant across each treatment. Bold success rates are signicantly better than non-bolded rates in the same row. For Vector Average, the success rate with population size 10,000 is also signicantly better than with population size 10.</p>
<p>Problem UMAD UMAD + Alt</p>
<p>Replace Space With Newline 87 62 Syllables 38 40 Vector Average 88 74 Table 5: Successes out of 100 run for UMAD and a 50/50 mix of UMAD and alternation. UMAD is signicantly better on the two problems with bold success rates.</p>
<p>All three problems have very poor success rates with a population size of 10; this might suggest that they need a larger population to explore a variety of dierent partial solutions to the target problem. With only 10 individuals, the cost of even a few "fatal" mutations is very high (and such mutations occur quite regularly), and it would be easy for one or two strong individuals to swamp the entire population with their progeny, eliminating necessary diversity. Additionally, this poor performance may be related to our use of lexicase selection, which focuses on dierent test cases during each selection This emphasis on dierent cases may necessitate a population size above some threshold in order to ensure that many areas of the search space are considered in each generation.</p>
<p>Using Recombination Alongside UMAD</p>
<p>Previous work has shown that uniform mutation alone, without alternation, is approximately as powerful as the benchmark genetic operators [8]. The present work raises additional questions about the utility of recombination. We therefore conducted runs that used a 50/50 combination of alternation and UMAD, in which an independent choice of alternation vs. UMAD was made for each new child. The results in Table 5 show that using alternation alongside UMAD decreased its performance on all three problems, with two of those dierences signicant.</p>
<p>Genome Sizes</p>
<p>While it is clear that several of these mutation-based systems outperform the benchmark set of genetic operators on the bulk of our test problems, it is less clear why they do so and what other eects they have on evolutionary dynamics. To better understand their impact, we plotted the average genome size in Figure 1. Each subplot contains one plot line representing the average genome The impact of size-neutral UMAD on genome size (the left-most column in Figure 1) is scattered on all three problems, with some runs showing a growth in average genome size to over 500, while other runs shrink to average sizes around 50.</p>
<p>Shrinking UMAD sharply drives down the average genome size on all three problems to sizes well below any of the other trends. With an addition rate of 0.09 and deletion rate of 0.1, the average ratio of size between parent and child will be (1 + 0.09)(1 0.1) = 0.981, meaning that a child will have approximately 2% fewer genes than its parent. The plots of average size for shrinking UMAD follow this expected decrease in size until they reach some size above zero. This suggests there may be a "oor" beyond which Plush genomes are unlikely to encode programs that have a reasonable chance of being selected, meaning that children that randomly grow or stay the same size are the only ones that receive selections.</p>
<p>Just as shrinking UMAD drives the sizes down, growing UMAD drives the sizes up at a similar rate, where there are then complex interactions between the growth bias and the cap on the maximum genome length. In these runs, if an ospring is generated with a genome that exceeds the maximum allowed length, then it is replaced by a newly generated random individual. This likely accounts for the oscillations of the average genome length between a ceiling near the maximum allowed and a strong band caused by the injection of new random programs. Since the random individuals are likely considerably worse than the large ones, this process accelerates while larger genomes receive most of the selections, until substantial proportions of the population are being replaced by random programs.</p>
<p>The uniform mutation plots display a peculiar trait, particularly on the Syllables problem, where many runs have the same average genome size for hundreds of consecutive generations. Remember that a child produced by uniform mutation will always have the same size as its parent, since genes are simply replaced, meaning that changes in average genome size simply reect which sizes become more prevalent in the population. That said, if one or more genomes of the same size dominate parent selections over a few generations, genomes of that size may make up the entire population in a generation. Once that happens, every single new child will also be that size, resulting in the horizontal lines in the plot. Even with this strange trait, uniform mutation performed about as well as UMAD on these problems.</p>
<p>DISCUSSION</p>
<p>The choices of the particular addition, deletion, and mutation rates for UMAD and uniform mutation used here were somewhat arbitrary. The fact that both size-neutral UMAD and shrinking UMAD did well (see Table 2) suggests that there is some exibility in setting those rates. Additionally, our experiment in Section 5.2 with both doubled and halved addition rates (and corresponding deletion rates) showed that UMAD has considerable robustness to changes in these weights. However, the weaker performance of growing UMAD suggests that parameter settings that actively encourage genome growth can lead to code bloat and poor performance.</p>
<p>We designed many of our comparisons between UMAD and variants or other operators to tell us what characteristics of UMAD are important to its improved performance compared to the benchmark operators. HAHD does additions and deletions like UMAD, but not both in one step. HAHD performed slightly worse in this comparison, showing that the ability of UMAD to perform both additions and deletions in one step helps, although it is not crucial.</p>
<p>Similarly, we compared UMAD to high-rate uniform mutation to see if the dissociation of adding and deleting genes contributes to UMAD's success. As noted in Section 5.5, UMAD also has the ability to make genomes larger or smaller, which uniform mutation lacks. UMAD performed signicantly better than uniform mutation on three problems, and better than the benchmark on three problems more than uniform mutation. These dierences in performance suggest that the ability to add and delete genes in dierent places, along with the ability to change genome sizes, is somewhat important for the performance of UMAD.</p>
<p>Our experiments with dierent population sizes clearly show that UMAD performs poorly if the population is too small. Since a population is not necessary for providing individuals to crossover when we only use UMAD, why do we need a population? The other way in which individuals interact is through parent selection. In all of our experiments we use lexicase selection [7]. Lexicase selection rst shues the list of test cases; it then considers the cases one at a time, discarding any individuals that are not tied for best on the case, until a single individual remains. Lexicase selection emphasizes dierent test cases, and therefore dierent parts of the search space, with each selection. In this way, we hypothesize that larger population sizes allow lexicase selection to prefer individuals with dierent strengths in dierent selections, maintaining exploration in numerous areas in the search space. All of the test problems used here have several hundred test cases, so with a population size as small as 10, lexicase selection cannot consistently emphasize all of the test cases, which may mean that during some generations it never selects the individuals that would best move it toward a solution. Thus a reasonably sized population is necessary in order for lexicase selection to maintain search lines in multiple interesting parts of the search space.</p>
<p>RELATED WORK</p>
<p>Explorations of mutation-only tree-based GP systems date back several decades, although mutation-only systems never became a popular approach in the eld. In fact the question posed was often not whether mutation was sucient on its own, but whether it was necessary; section 5.2.1 of A eld guide to genetic programming [14] is, for example, titled "Is Mutation Necessary?" O'Reilly's PhD dissertation [13] proposed a set of mutation operators for tree-based GP, and showed that some mutation-only systems are competitive with tree-based GP with sub-tree crossover. For example, a system using simulated annealing with the proposed mutation operators consistently outperformed GP with sub-tree crossover on the test problems used. Chellapilla [15] also explored the ecacy of mutation-only tree-based GP sytems on 14 test problems, and concluded that "crossover is not essential for successful program evolution".</p>
<p>Much of this early work was connected to the question of whether sub-tree crossover was in fact mixing and spreading building blocks. An alternative theory was that sub-tree crossover was really a form of macro-mutation; while a sub-tree from one parent was replaced by a subtree from the other parent, the eect was similar to replacing the sub-tree with a randomly generated subtree. Angeline [1] showed that two forms of headless chicken crossover [9], where a subtree was replaced with a randomly generated subtree, were as eective or better than sub-tree crossover on three test problems.</p>
<p>Over a decade later, White and Poulding [18] did a comparison of sub-tree crossover and sub-tree mutation based GP systems on six test problems, independently tuning the parameters for each approach, and found that "crossover does not signicantly outperform mutation on most of the problems examined".</p>
<p>More recently, much of the work in the area of genetic improvement [10,11,17] has been substantially or entirely mutation based. Here researchers are modifying existing code that was typically generated by humans, and mutation is a natural approach to making the small, local changes that are necessary.</p>
<p>CONCLUSIONS &amp; FUTURE WORK</p>
<p>Many researchers in GP assume to some degree that crossover is necessary, or at least benecial, for combining elements from parents in dierent areas in the search space, while mutation primarily ne tunes programs that are nearly correct. Our results defy these assumptions in multiple ways, at least in the context of PushGP with Plush genomes applied to these software synthesis problems.</p>
<p>The results in Table 2 make it clear that mutation alone can be a powerful genetic operator. Two versions of UMAD (size-neutral and shrinking) regularly outperformed the benchmark set of genetic operators used in previous work, and two other mutation-only systems (HAHD and high-rate uniform mutation) also outperformed the benchmark set in many instances. In all of these systems, mutation is not simply ne-tuning programs, but is entirely in charge of exploring the search space, and succeeding. A 50/50 combination of UMAD with a recombination operator (alternation) did not improve performance and in two cases harmed it; while this does not suggest that adding recombination is strongly detrimental, it also does not indicate that it is particularly helpful.</p>
<p>These experiments, especially when combined with the results of earlier studies, raise important questions about the role, necessity, and ecacy of recombination in this type of genetic search.</p>
<p>It is always possible, however, that no one has found the "right" recombination operator or operator parameters for PushGP and Plush genomes. As far as we know, no one has ever comprehensively explored the parameters and combinations of operators used in previous PushGP work. While those choices allowed PushGP to discover solutions to a variety of interesting software synthesis problems, there was never a claim that those were the "best" options; some limited parameter tuning work [12] denitely indicated that there was potential for improvements in these parameter settings. Thus there might exist dierent parameters or operators that outperform the mutation-based systems presented here, in which recombination plays a vital role. It is also possible, however, that dierent settings or dierent mutation operators might improve the results here even further. While we explored quite a few variations here, our exploration was by no means exhaustive.</p>
<p>This suggests the broad range of potential future work. These new mutation operators imply a large parameter space which we have only begun to explore, including alternative combinations of mutation operators like UMAD and crossovers like alternation. It would also be worth trying to identify problems where recombination is demonstrably important, as well as looking for more eective recombination operators.</p>
<p>Lastly, while all the work here was on PushGP using Plush genomes, mutation operators like UMAD could easily be used with other variable-length linear genome systems. It would be valuable to explore mutation-only systems in those domains as well to see if these results are in some way specic to PushGP and Plush, or are a more general phenomena. Previous work has shown that mutation-only systems can be very eective in tree-based GP systems; our results suggest that more attention should be paid to this area, and that additional exploration of the space of mutation operators would be valuable throughout GP.</p>
<p>Figure 1 :
1Average genome sizes over time for Replace Space with Newline (RSWN), Syllables, and Vector Average for UMAD, shrinking UMAD, growing UMAD, uniform mutation, and the benchmark genetic operators.size over the generations for each of the 100 runs for a particular combination of benchmark problem and genetic operator. Because runs are terminated as soon as a solution is found, many of the plot lines end before reaching generation 300. Both Replace Space with Newline and Syllables start with an average genome size of 200 and have a maximum size of 800, where the starting genomes in Vector Average runs have an average length of 100 with an overall maximum of 400.</p>
<p>, Kyoto, Japan © 2018 Copyright held by the owner/author(s). Publication rights licensed to Association for Computing Machinery. ACM ISBN 978-1-4503-5618-3/18/07. . . $15.00 https://doi.org/10.1145/3205455.3205603</p>
<p>Table 1 :
1Genetic operator parameter settings and the rates at which we use them in our benchmark genetic operators.Parameter 
Value </p>
<p>alternation rate 
0.01 
alignment deviation 
10 
uniform mutation rate 
0.01 
uniform close mutation rate 
0.1 </p>
<p>Genetic Operator Rates 
Prob </p>
<p>alternation 
0.2 
uniform mutation 
0.2 
uniform close mutation 
0.1 
alternation followed by uniform mutation 
0.5 </p>
<p>Table 2
2presents our rst set of results, comparing • Three variants of UMAD (see below)</p>
<p>ProblemUMAD UMAD# UMAD" HAHD Uni. mut. BenchmarkChecksum 
1 
5 
0 
4 
2 
1 
Compare String Lengths 
32 
42 
26 
22 
28 
5 
Count Odds 
8 
12 
6 
10 
7 
5 
Digits 
19 
11 
10 
15 
14 
10 
Double Letters 
19 
20 
5 
18 
16 
1 
Even Squares 
0 
0 
0 
0 
0 
0 
For Loop Index 
2 
1 
0 
1 
1 
0 
Grade 
0 
0 
0 
0 
0 
1 
Last Index of Zero 
62 
56 
62 
49 
72 
29 
Median 
55 
48 
66 
60 
55 
54 
Mirror Image 
100 
100 
100 
100 
100 
87 
Negative To Zero 
80 
82 
73 
72 
79 
62 
Number IO 
98 
100 
100 
100 
100 
100 
Pig Latin 
0 
0 
0 
0 
0 
0 
Replace Space With Newline 
87 
87 
88 
83 
92 
58 
Scrabble Score 
13 
20 
3 
11 
10 
4 
Small or Large 
7 
4 
9 
4 
6 
5 
Smallest 
100 
100 
98 
99 
86 
97 
String Lengths Backwards 
94 
86 
80 
82 
62 
74 
Sum of Squares 
21 
26 
13 
10 
13 
3 
Super Anagrams 
4 
0 
2 
3 
1 
0 
Syllables 
38 
48 
21 
51 
28 
24 
Vector Average 
88 
92 
84 
77 
82 
43 
Vectors Summed 
11 
9 
3 
9 
7 
1 
X-Word Lines 
61 
59 
12 
63 
25 
18 </p>
<h1>Sig. Better than Bench.</h1>
<p>9 
11 
5 
6 
6 
-</p>
<p>Table 3 :
3Number of success out of 100 runs for size-neutral 
UMAD with dierent addition rates (given in each column). 
The corresponding deletion rates for each set of runs can 
be calculated using Eq. 1. The underlined results are signi-
cantly worse than the other results in their rows. The Vector 
Average result of 75 for 0.045 is signicantly worse than the 
result of 91 for 0.18, but not signicantly dierent from the 
result of 88 for 0.09. </p>
<p>https://github.com/lspector/Clojush
ACKNOWLEDGMENTSThanks to the members of the Hampshire College Computational Intelligence Lab and Shawn Saliyev at the University of Minnesota, Morris for discussions that helped shape this work, and to Josiah Erikson for systems support. This material is based upon work supported by the National Science Foundation under Grant No.1617087. Any opinions, ndings, and conclusions or recommendations expressed in this publication are those of the authors and do not necessarily reect the views of the National Science Foundation.
Comparing subtree crossover with macromutation. J Peter, Angeline, Evolutionary Programming VI, Peter J. Angeline, Robert G. Reynolds, John R. Mc-Donnell, and Russ EberhartSpringerBerlin Heidelberg; Berlin, HeidelbergPeter J. Angeline. 1997. Comparing subtree crossover with macromutation. In Evolutionary Programming VI, Peter J. Angeline, Robert G. Reynolds, John R. Mc- Donnell, and Russ Eberhart (Eds.). Springer Berlin Heidelberg, Berlin, Heidelberg, 101-111.</p>
<p>. Georg Hans, Hans-Paul Beyer, Schwefel, 10.1023/A:1015059928466Evolution Strategies -A Comprehensive Introduction. 1Hans-Georg Beyer and Hans-Paul Schwefel. 2002. Evolution Strategies -A Comprehensive Introduction. 1, 1 (May 2002), 3-52. https://doi.org/10.1023/A: 1015059928466</p>
<p>Improving Generalization of Evolved Programs Through Automatic Simplication. Thomas Helmuth, Nicholas Freitag Mcphee, Edward Pantridge, Lee Spector, 10.1145/3071178.3071330Proceedings of the Genetic and Evolutionary Computation Conference (GECCO '17). the Genetic and Evolutionary Computation Conference (GECCO '17)Berlin, GermanyACMThomas Helmuth, Nicholas Freitag McPhee, Edward Pantridge, and Lee Spec- tor. 2017. Improving Generalization of Evolved Programs Through Automatic Simplication. In Proceedings of the Genetic and Evolutionary Computation Con- ference (GECCO '17). ACM, Berlin, Germany, 937-944. https://doi.org/doi: 10.1145/3071178.3071330</p>
<p>Lexicase Selection For Program Synthesis: A Diversity Analysis. In Genetic Programming Theory and Practice XIII (Genetic and Evolutionary Computation). Thomas Helmuth, Nicholas Freitag Mcphee, Lee Spector, SpringerAnn Arbor, USAThomas Helmuth, Nicholas Freitag McPhee, and Lee Spector. 2015. Lexicase Selection For Program Synthesis: A Diversity Analysis. In Genetic Programming Theory and Practice XIII (Genetic and Evolutionary Computation). Springer, Ann Arbor, USA. http://www.springer.com/us/book/9783319342214</p>
<p>Eects of Lexicase and Tournament Selection on Diversity Recovery and Maintenance. Thomas Helmuth, Nicholas Freitag Mcphee, Lee Spector, GECCO '16 Companion: Proceedings of the Companion Publication of the. Thomas Helmuth, Nicholas Freitag McPhee, and Lee Spector. 2016. Eects of Lexicase and Tournament Selection on Diversity Recovery and Maintenance. In GECCO '16 Companion: Proceedings of the Companion Publication of the 2016</p>
<p>. 10.1145/2908961.2931657Annual Conference on Genetic and Evolutionary Computation. ACM. Annual Conference on Genetic and Evolutionary Computation. ACM, Denver, Colorado, USA, 983-990. https://doi.org/doi:10.1145/2908961.2931657</p>
<p>General Program Synthesis Benchmark Suite. Thomas Helmuth, Lee Spector, 10.1145/2739480.2754769GECCO '15: Proceedings of the 2015 Annual Conference on Genetic and Evolutionary Computation. Madrid, SpainACMThomas Helmuth and Lee Spector. 2015. General Program Synthesis Benchmark Suite. In GECCO '15: Proceedings of the 2015 Annual Conference on Genetic and Evolutionary Computation. ACM, Madrid, Spain, 1039-1046. https://doi.org/doi: 10.1145/2739480.2754769</p>
<p>Solving Uncompromising Problems with Lexicase Selection. Thomas Helmuth, Lee Spector, James Matheson, 10.1109/TEVC.2014.2362729IEEE Transactions on Evolutionary Computation. 19Thomas Helmuth, Lee Spector, and James Matheson. 2015. Solving Uncompromis- ing Problems with Lexicase Selection. IEEE Transactions on Evolutionary Compu- tation 19, 5 (Oct. 2015), 630-643. https://doi.org/doi:10.1109/TEVC.2014.2362729</p>
<p>Linear Genomes for Structured Programs. Thomas Helmuth, Lee Spector, Nicholas Freitag Mcphee, Saul Shanabrook, Genetic Programming Theory and Practice XIV. SpringerThomas Helmuth, Lee Spector, Nicholas Freitag McPhee, and Saul Shanabrook. 2017. Linear Genomes for Structured Programs. In Genetic Programming Theory and Practice XIV. Springer.</p>
<p>Crossover, macromutation, and population-based search. Terry Jones, Proceedings of the Sixth International Conference on Genetic Algorithms. the Sixth International Conference on Genetic AlgorithmsTerry Jones et al. 1995. Crossover, macromutation, and population-based search. In Proceedings of the Sixth International Conference on Genetic Algorithms. 73-80.</p>
<p>Optimizing existing software with genetic programming. B William, Mark Langdon, Harman, IEEE Transactions on Evolutionary Computation. 19William B Langdon and Mark Harman. 2015. Optimizing existing software with genetic programming. IEEE Transactions on Evolutionary Computation 19, 1 (2015), 118-135.</p>
<p>A systematic study of automated program repair: Fixing 55 out of 105 bugs for 8 each. Claire Le Goues, Michael Dewey-Vogt, Stephanie Forrest, Westley Weimer, Software Engineering (ICSE). Claire Le Goues, Michael Dewey-Vogt, Stephanie Forrest, and Westley Weimer. 2012. A systematic study of automated program repair: Fixing 55 out of 105 bugs for 8 each. In Software Engineering (ICSE), 2012 34th International Conference on. IEEE, 3-13.</p>
<p>Using Algorithm Conguration Tools to Optimize Genetic Programming Parameters: A Case Study. Thomas Nicholas Freitag Mcphee, Lee Helmuth, Spector, 10.1145/3067695.3076097Proceedings of the Genetic and Evolutionary Computation Conference Companion (GECCO '17). the Genetic and Evolutionary Computation Conference Companion (GECCO '17)New York, NY, USAACMNicholas Freitag McPhee, Thomas Helmuth, and Lee Spector. 2017. Using Algorithm Conguration Tools to Optimize Genetic Programming Parame- ters: A Case Study. In Proceedings of the Genetic and Evolutionary Computa- tion Conference Companion (GECCO '17). ACM, New York, NY, USA, 243-244. https://doi.org/10.1145/3067695.3076097</p>
<p>An Analysis of Genetic Programming. Una-May O&apos; Reilly, Ottawa, Ontario, CanadaPh.D. Dissertation. Carleton University, Ottawa-Carleton Institute for Computer ScienceUna-May O'Reilly. 1995. An Analysis of Genetic Programming. Ph.D. Dissertation. Carleton University, Ottawa-Carleton Institute for Computer Science, Ottawa, Ontario, Canada. http://www.cs.ucl.ac.uk/sta/W.Langdon/ftp/papers/oreilly/ abstract.ps.gz</p>
<p>A eld guide to genetic programming. Riccardo Poli, William B Langdon, Nicholas Freitag Mcphee, J. R. KozaRiccardo Poli, William B. Langdon, and Nicholas Freitag McPhee. 2008. A eld guide to genetic programming. Published via http://lulu.com and freely avail- able at http://www.gp-field-guide.org.uk. http://www.gp-eld-guide.org. uk (With contributions by J. R. Koza).</p>
<p>The Push3 execution stack and the evolution of control. Lee Spector, Jon Klein, Maarten Keijzer, 10.1145/1068009.1068292GECCO 2005: Proceedings of the 2005 conference on Genetic and evolutionary computation. Washington DC, USAACM Press2Lee Spector, Jon Klein, and Maarten Keijzer. 2005. The Push3 execution stack and the evolution of control. In GECCO 2005: Proceedings of the 2005 conference on Genetic and evolutionary computation, Vol. 2. ACM Press, Washington DC, USA, 1689-1696. https://doi.org/doi:10.1145/1068009.1068292</p>
<p>Genetic Programming and Autoconstructive Evolution with the Push Programming Language. Lee Spector, Alan Robinson, 10.1023/A:1014538503543Genetic Programming and Evolvable Machines. 31Lee Spector and Alan Robinson. 2002. Genetic Programming and Autoconstruc- tive Evolution with the Push Programming Language. Genetic Programming and Evolvable Machines 3, 1 (March 2002), 7-40. https://doi.org/doi:10.1023/A: 1014538503543</p>
<p>Evolutionary improvement of programs. Andrea David R White, John A Arcuri, Clark, IEEE Transactions on Evolutionary Computation. 15David R White, Andrea Arcuri, and John A Clark. 2011. Evolutionary improve- ment of programs. IEEE Transactions on Evolutionary Computation 15, 4 (2011), 515-538.</p>
<p>A Rigorous Evaluation of Crossover and Mutation in Genetic Programming. R David, Simon White, Poulding, Genetic Programming. Berlin Heidelberg; Berlin, HeidelbergSpringerDavid R. White and Simon Poulding. 2009. A Rigorous Evaluation of Crossover and Mutation in Genetic Programming. In Genetic Programming. Springer Berlin Heidelberg, Berlin, Heidelberg, 220-231.</p>            </div>
        </div>

    </div>
</body>
</html>