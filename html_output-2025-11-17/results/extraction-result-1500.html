<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-1500 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-1500</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-1500</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-29.html">extraction-schema-29</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of simulators used for training models or agents on scientific reasoning tasks (especially in thermodynamics, circuits, or biology), including details about simulator fidelity levels and transfer performance to real-world or different contexts.</div>
                <p><strong>Paper ID:</strong> paper-dcc45df9a9291a511aaa6d33fbbf057c5e3bdc9b</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/dcc45df9a9291a511aaa6d33fbbf057c5e3bdc9b" target="_blank">ChainQueen: A Real-Time Differentiable Physical Simulator for Soft Robotics</a></p>
                <p><strong>Paper Venue:</strong> IEEE International Conference on Robotics and Automation</p>
                <p><strong>Paper TL;DR:</strong> A real-time, differentiable hybrid Lagrangian-Eulerian physical simulator for deformable objects, ChainQueen, based on the Moving Least Squares Material Point Method (MLS-MPM), which can simulate deformable Objects with collisions and can be seamlessly incorporated into soft robotic systems.</p>
                <p><strong>Paper Abstract:</strong> Physical simulators have been widely used in robot planning and control. Among them, differentiable simulators are particularly favored, as they can be incorporated into gradient-based optimization algorithms that are efficient in solving inverse problems such as optimal control and motion planning. Therefore, rigid body simulators and recently their differentiable variants are studied extensively. Simulating deformable objects is, however, more challenging compared to rigid body dynamics. The underlying physical laws of deformable objects are more complex, and the resulting systems have orders of magnitude more degrees of freedom and there-fore they are significantly more computationally expensive to simulate. Computing gradients with respect to physical design or controller parameters is typically even more computationally challenging. In this paper, we propose a real-time, differentiable hybrid Lagrangian-Eulerian physical simulator for deformable objects, ChainQueen, based on the Moving Least Squares Material Point Method (MLS-MPM). MLS-MPM can simulate deformable objects with collisions and can be seamlessly incorporated into soft robotic systems. We demonstrate that our simulator achieves high precision in both forward simulation and backward gradient computation. We have successfully employed it in a diverse set of inference, control and co-design tasks for soft robotics.</p>
                <p><strong>Cost:</strong> 0.015</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e1500.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e1500.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of simulators used for training models or agents on scientific reasoning tasks (especially in thermodynamics, circuits, or biology), including details about simulator fidelity levels and transfer performance to real-world or different contexts.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>ChainQueen</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>ChainQueen (differentiable MLS-MPM simulator)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A real-time, fully-differentiable hybrid Lagrangian–Eulerian physical simulator for deformable (soft) objects based on the Moving Least Squares Material Point Method (MLS-MPM), implemented with a high-performance CUDA backend and a TensorFlow reference implementation.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>simulator_name</strong></td>
                            <td>ChainQueen (MLS-MPM)</td>
                        </tr>
                        <tr>
                            <td><strong>simulator_description</strong></td>
                            <td>Physically-founded differentiable simulator that models soft/deformable continua (elastic/hyperelastic materials), particle-grid hybrid (MPM) handling large deformations, contact and self-collision, with analytic backward gradients for states and parameters; GPU-optimized CUDA solver and a slower TensorFlow reference implementation.</td>
                        </tr>
                        <tr>
                            <td><strong>scientific_domain</strong></td>
                            <td>mechanics / soft-body dynamics (soft robotics)</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_level</strong></td>
                            <td>high-fidelity for soft-body continuum mechanics (physically-derived MLS-MPM discretization), with explicit modeling of deformation gradients, constitutive stress (PK1), contact and collisions; more physically-plausible than approximate PBD methods.</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_characteristics</strong></td>
                            <td>Includes continuum mechanics derived constitutive models (Young's modulus, Poisson ratio), deformation gradients, contact and self-collision, actuation stress models (Cauchy/ material-space actuation stress), frictional boundary projection, explicit time integration with Δt stability limit (depends on E and Δx). Implements substepping where needed; supports GPU-parallelized, fine-grained particle resolution (tens of thousands of particles).</td>
                        </tr>
                        <tr>
                            <td><strong>model_or_agent_name</strong></td>
                            <td>Regression-based controller (tanh(W z + b)); PPO baseline (actor-critic RL)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Controller: a regression-based policy parameterized by weights W and biases b mapping state z to actuator commands a = tanh(W z + b), optimized by gradient descent using ChainQueen's analytic gradients; Baseline: PPO (proximal policy optimization) actor-critic RL trained model-free using simulator rollouts.</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task</strong></td>
                            <td>Scientific/control reasoning tasks for soft robotics: trajectory/control optimization (stable gaits, walking/running), system identification (inferring physical parameters like relative density/Young's modulus), dynamic reach/co-design (optimizing spatial stiffness distribution and actuation to reach targets).</td>
                        </tr>
                        <tr>
                            <td><strong>training_performance</strong></td>
                            <td>Gradient-based controller optimization converged rapidly (often within tens to hundreds of iterations); for the 2D walker the controller began functioning well within ~20 minutes of optimization on ChainQueen. Quantitatively, ChainQueen provides forward and backward simulation at high throughput (e.g., 8k particles: ~0.392 ms forward, ~0.406 ms backward per frame on GTX 1080 Ti) and gradient accuracy with relative errors in analytic/numeric tests down to 1e-8--1e-5 (Table III).</td>
                        </tr>
                        <tr>
                            <td><strong>transfer_target</strong></td>
                            <td>Real-world soft actuator experiments (pneumatic leg/actuator), system identification scenarios (inferring densities), and design evaluation (co-designed arm behavior, validated in simulation and compared qualitatively to expected real-world behavior).</td>
                        </tr>
                        <tr>
                            <td><strong>transfer_performance</strong></td>
                            <td>Experimental comparisons show close agreement between simulated and physical pneumatic actuator deformation and dynamic bouncing (qualitative match shown; gradients remain stable up to 1000 steps). Analytic/numeric test cases report very low relative errors (e.g., A1 down to ~1e-7; B ~2.4e-8). No large-scale quantitative numeric error reported for the experimental actuator beyond plotted/visual agreement in Fig.3.</td>
                        </tr>
                        <tr>
                            <td><strong>compares_fidelity_levels</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_comparison_results</strong></td>
                            <td>The paper compares ChainQueen (physically-based MLS-MPM) to NVIDIA Flex (a Position-Based Dynamics (PBD) simulator) mainly in terms of speed and plausibility: ChainQueen is faster (when particle counts matched) and more physically-grounded (has explicit physical parameters like Young's modulus), whereas Flex is an approximate PBD method requiring parameter tuning to visually match results and lacks explicit physical quantities.</td>
                        </tr>
                        <tr>
                            <td><strong>minimal_fidelity_discussion</strong></td>
                            <td>The paper argues that physically-founded discretization (MPM) facilitates matching real-world experiments and enables system identification; it notes that very stiff (nearly-rigid) materials impose restrictive Δt limits for explicit integration and thus should be handled by a rigid-body simulator or coupled approaches (Compatible Particle-in-Cell). No explicit lower bound on fidelity for transfer is given (no formal minimal-fidelity ablation), but authors emphasize the need for physically-accurate constitutive models and contact handling for realistic transfer.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>No explicit failure cases of transfer from low-fidelity simulations are reported, but caveats include: PBD (Flex) lacks explicit physical parameters making direct physical matching hard; explicit MPM requires small Δt for very stiff materials (necessitating rigid-body coupling). Also, PPO (model-free RL) trained in the same simulator learned much more slowly for some tasks, effectively failing to match gradient-based optimization efficiency within comparable wall-clock time (PPO still near-random after >4 hours vs ChainQueen controller effective within ~20 minutes).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'ChainQueen: A Real-Time Differentiable Physical Simulator for Soft Robotics', 'publication_date_yy_mm': '2018-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1500.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e1500.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of simulators used for training models or agents on scientific reasoning tasks (especially in thermodynamics, circuits, or biology), including details about simulator fidelity levels and transfer performance to real-world or different contexts.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Flex</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>NVIDIA Flex (Unified particle physics / Position-Based Dynamics)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A popular real-time particle-based Position-Based Dynamics (PBD) physics engine used for simulating deformable objects and fluids in interactive/graphics contexts; used here as a benchmark baseline for forward simulation performance.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Unified particle physics for real-time applications</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>simulator_name</strong></td>
                            <td>NVIDIA Flex (PBD)</td>
                        </tr>
                        <tr>
                            <td><strong>simulator_description</strong></td>
                            <td>A particle-based Position-Based Dynamics simulator optimized for real-time applications (graphics/games) that can simulate deformable bodies and fluids using PBD integration and substepping.</td>
                        </tr>
                        <tr>
                            <td><strong>scientific_domain</strong></td>
                            <td>mechanics / real-time deformable body simulation</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_level</strong></td>
                            <td>approximate / lower-fidelity compared to continuum MPM—PBD focuses on stability and speed rather than explicit physical fidelity (e.g. no explicit Young's modulus).</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_characteristics</strong></td>
                            <td>Uses PBD constraints with substepping and iteration counts to increase stiffness; parameters are not direct physical quantities (no explicit Young's modulus), collision handled via PBD constraints; tuned for visual plausibility and real-time performance.</td>
                        </tr>
                        <tr>
                            <td><strong>model_or_agent_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>training_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>transfer_target</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>transfer_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>compares_fidelity_levels</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_comparison_results</strong></td>
                            <td>ChainQueen (MLS-MPM) was faster for matched particle counts and is more physically-plausible (has explicit constitutive parameters) whereas Flex required parameter tuning and uses PBD iterations/substeps to reach similar visual stiffness; no systematic transfer experiments reported comparing Flex->real world.</td>
                        </tr>
                        <tr>
                            <td><strong>minimal_fidelity_discussion</strong></td>
                            <td>The paper notes PBD does not expose explicit physical quantities (e.g., Young's modulus), complicating physical matching; authors tuned Flex parameters to visually match ChainQueen for benchmarking.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>No explicit transfer failures reported, but implicit limitation is PBD's limited physical interpretability for system identification or accurate real-world transfer.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'ChainQueen: A Real-Time Differentiable Physical Simulator for Soft Robotics', 'publication_date_yy_mm': '2018-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1500.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e1500.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of simulators used for training models or agents on scientific reasoning tasks (especially in thermodynamics, circuits, or biology), including details about simulator fidelity levels and transfer performance to real-world or different contexts.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>TensorFlow reference implementation</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>ChainQueen TensorFlow reference implementation</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A reference TensorFlow-based implementation of the differentiable MLS-MPM algorithm used for correctness and as a high-level interface, but substantially slower than the optimized CUDA backend.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>simulator_name</strong></td>
                            <td>ChainQueen (TensorFlow reference)</td>
                        </tr>
                        <tr>
                            <td><strong>simulator_description</strong></td>
                            <td>A high-level reference implementation of ChainQueen implemented in TensorFlow to expose differentiable computation graphs and a user-friendly API, intended for correctness and prototyping rather than speed.</td>
                        </tr>
                        <tr>
                            <td><strong>scientific_domain</strong></td>
                            <td>mechanics / differentiable simulation</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_level</strong></td>
                            <td>same algorithmic fidelity as ChainQueen (MLS-MPM) but lower practical performance due to framework/runtime overheads.</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_characteristics</strong></td>
                            <td>Implements the same MLS-MPM discretization and differentiable steps, but with higher overhead and less GPU/parallel memory optimization than CUDA backend; numerical fidelity identical in principle but wall-clock throughput much lower.</td>
                        </tr>
                        <tr>
                            <td><strong>model_or_agent_name</strong></td>
                            <td>same regression-based controller (used via TensorFlow interface for prototyping)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Controller encoded in TensorFlow as differentiable operations allowing symbolic differentiation; used more for prototyping than large-scale optimization due to performance overhead.</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task</strong></td>
                            <td>Same soft-robotics control and inference tasks for prototyping</td>
                        </tr>
                        <tr>
                            <td><strong>training_performance</strong></td>
                            <td>Much slower: Table II reports e.g. 2D forward 6,400 particles: TF forward 13.2 ms/frame vs CUDA 0.10 ms/frame; TF backward 35.7 ms/frame vs CUDA 0.14 ms/frame. No separate transfer metrics reported.</td>
                        </tr>
                        <tr>
                            <td><strong>transfer_target</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>transfer_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>compares_fidelity_levels</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_comparison_results</strong></td>
                            <td>Shows that implementing the same physics in a general AD framework (TensorFlow) is functionally possible, but runtime overheads make it far slower than a tailored CUDA implementation; no fidelity difference except performance.</td>
                        </tr>
                        <tr>
                            <td><strong>minimal_fidelity_discussion</strong></td>
                            <td>Authors note TensorFlow is optimized for deep learning workloads and not the memory-access patterns of particle simulation, implying that simulation fidelity is not limited by framework but by implementation efficiency.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>Performance constraints (slowness) make TF reference less practical for large-scale or real-time optimization experiments, but no numerical failures reported.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'ChainQueen: A Real-Time Differentiable Physical Simulator for Soft Robotics', 'publication_date_yy_mm': '2018-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1500.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e1500.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of simulators used for training models or agents on scientific reasoning tasks (especially in thermodynamics, circuits, or biology), including details about simulator fidelity levels and transfer performance to real-world or different contexts.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>SPNets</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>SPNets (differentiable fluid dynamics)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A differentiable simulator for position-based fluids where particle interactions are implemented as neural-network-style operations to enable automatic differentiation for fluid tasks; cited as related work for differentiable deformable/fluids simulation.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Spnets: Differentiable fluid dynamics for deep neural networks</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>simulator_name</strong></td>
                            <td>SPNets</td>
                        </tr>
                        <tr>
                            <td><strong>simulator_description</strong></td>
                            <td>A differentiable particle-based fluid simulator built as neural-network operations (PyTorch) to support gradient-based learning and inference on fluid dynamics tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>scientific_domain</strong></td>
                            <td>fluid dynamics</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_level</strong></td>
                            <td>medium-fidelity particle-based fluid simulation tailored to differentiability; emphasis on enabling learning rather than highest physical fidelity.</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_characteristics</strong></td>
                            <td>Particle interactions encoded as NN ops; uses PyTorch AD for gradients; targeted at position-based fluid models; likely simplifies some continuum aspects compared to full Navier–Stokes solvers.</td>
                        </tr>
                        <tr>
                            <td><strong>model_or_agent_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>training_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>transfer_target</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>transfer_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>compares_fidelity_levels</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_comparison_results</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>minimal_fidelity_discussion</strong></td>
                            <td>Mentioned as an alternative differentiable approach, but no transfer or fidelity-ablation details provided in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>Not discussed in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'ChainQueen: A Real-Time Differentiable Physical Simulator for Soft Robotics', 'publication_date_yy_mm': '2018-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1500.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e1500.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of simulators used for training models or agents on scientific reasoning tasks (especially in thermodynamics, circuits, or biology), including details about simulator fidelity levels and transfer performance to real-world or different contexts.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>MuJoCo</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>MuJoCo (Multi-Joint dynamics with Contact)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A physics engine for model-based control and simulation of articulated rigid-body systems; mentioned in context of simulators used for model-based robotics and control.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Mujoco: A physics engine for model-based control</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>simulator_name</strong></td>
                            <td>MuJoCo</td>
                        </tr>
                        <tr>
                            <td><strong>simulator_description</strong></td>
                            <td>A widely-used rigid-body physics engine designed for model-based control tasks (fast, contact-handling rigid dynamics), commonly used in robotics and reinforcement learning benchmarks.</td>
                        </tr>
                        <tr>
                            <td><strong>scientific_domain</strong></td>
                            <td>rigid-body dynamics / robotics</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_level</strong></td>
                            <td>high-fidelity for articulated rigid-body dynamics and contact, but not designed for deformable continuum soft-body physics.</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_characteristics</strong></td>
                            <td>Accurate rigid-body dynamics with contact and constraints; not intended for large-deformation continuum soft bodies; used widely for model-based control research.</td>
                        </tr>
                        <tr>
                            <td><strong>model_or_agent_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>training_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>transfer_target</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>transfer_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>compares_fidelity_levels</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_comparison_results</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>minimal_fidelity_discussion</strong></td>
                            <td>Mentioned in refs as example simulator for model-based control; no discussion about minimal fidelity for transfer in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>Not discussed here; general limitation for soft-body tasks is that rigid-body engines are not suitable for large-deformation soft robotics without coupling to deformable solvers.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'ChainQueen: A Real-Time Differentiable Physical Simulator for Soft Robotics', 'publication_date_yy_mm': '2018-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Mujoco: A physics engine for model-based control <em>(Rating: 2)</em></li>
                <li>Unified particle physics for real-time applications <em>(Rating: 2)</em></li>
                <li>Spnets: Differentiable fluid dynamics for deep neural networks <em>(Rating: 2)</em></li>
                <li>A moving least squares material point method with displacement discontinuity and two-way rigid body coupling <em>(Rating: 2)</em></li>
                <li>Gpu optimization of material point methods <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-1500",
    "paper_id": "paper-dcc45df9a9291a511aaa6d33fbbf057c5e3bdc9b",
    "extraction_schema_id": "extraction-schema-29",
    "extracted_data": [
        {
            "name_short": "ChainQueen",
            "name_full": "ChainQueen (differentiable MLS-MPM simulator)",
            "brief_description": "A real-time, fully-differentiable hybrid Lagrangian–Eulerian physical simulator for deformable (soft) objects based on the Moving Least Squares Material Point Method (MLS-MPM), implemented with a high-performance CUDA backend and a TensorFlow reference implementation.",
            "citation_title": "here",
            "mention_or_use": "use",
            "simulator_name": "ChainQueen (MLS-MPM)",
            "simulator_description": "Physically-founded differentiable simulator that models soft/deformable continua (elastic/hyperelastic materials), particle-grid hybrid (MPM) handling large deformations, contact and self-collision, with analytic backward gradients for states and parameters; GPU-optimized CUDA solver and a slower TensorFlow reference implementation.",
            "scientific_domain": "mechanics / soft-body dynamics (soft robotics)",
            "fidelity_level": "high-fidelity for soft-body continuum mechanics (physically-derived MLS-MPM discretization), with explicit modeling of deformation gradients, constitutive stress (PK1), contact and collisions; more physically-plausible than approximate PBD methods.",
            "fidelity_characteristics": "Includes continuum mechanics derived constitutive models (Young's modulus, Poisson ratio), deformation gradients, contact and self-collision, actuation stress models (Cauchy/ material-space actuation stress), frictional boundary projection, explicit time integration with Δt stability limit (depends on E and Δx). Implements substepping where needed; supports GPU-parallelized, fine-grained particle resolution (tens of thousands of particles).",
            "model_or_agent_name": "Regression-based controller (tanh(W z + b)); PPO baseline (actor-critic RL)",
            "model_description": "Controller: a regression-based policy parameterized by weights W and biases b mapping state z to actuator commands a = tanh(W z + b), optimized by gradient descent using ChainQueen's analytic gradients; Baseline: PPO (proximal policy optimization) actor-critic RL trained model-free using simulator rollouts.",
            "reasoning_task": "Scientific/control reasoning tasks for soft robotics: trajectory/control optimization (stable gaits, walking/running), system identification (inferring physical parameters like relative density/Young's modulus), dynamic reach/co-design (optimizing spatial stiffness distribution and actuation to reach targets).",
            "training_performance": "Gradient-based controller optimization converged rapidly (often within tens to hundreds of iterations); for the 2D walker the controller began functioning well within ~20 minutes of optimization on ChainQueen. Quantitatively, ChainQueen provides forward and backward simulation at high throughput (e.g., 8k particles: ~0.392 ms forward, ~0.406 ms backward per frame on GTX 1080 Ti) and gradient accuracy with relative errors in analytic/numeric tests down to 1e-8--1e-5 (Table III).",
            "transfer_target": "Real-world soft actuator experiments (pneumatic leg/actuator), system identification scenarios (inferring densities), and design evaluation (co-designed arm behavior, validated in simulation and compared qualitatively to expected real-world behavior).",
            "transfer_performance": "Experimental comparisons show close agreement between simulated and physical pneumatic actuator deformation and dynamic bouncing (qualitative match shown; gradients remain stable up to 1000 steps). Analytic/numeric test cases report very low relative errors (e.g., A1 down to ~1e-7; B ~2.4e-8). No large-scale quantitative numeric error reported for the experimental actuator beyond plotted/visual agreement in Fig.3.",
            "compares_fidelity_levels": false,
            "fidelity_comparison_results": "The paper compares ChainQueen (physically-based MLS-MPM) to NVIDIA Flex (a Position-Based Dynamics (PBD) simulator) mainly in terms of speed and plausibility: ChainQueen is faster (when particle counts matched) and more physically-grounded (has explicit physical parameters like Young's modulus), whereas Flex is an approximate PBD method requiring parameter tuning to visually match results and lacks explicit physical quantities.",
            "minimal_fidelity_discussion": "The paper argues that physically-founded discretization (MPM) facilitates matching real-world experiments and enables system identification; it notes that very stiff (nearly-rigid) materials impose restrictive Δt limits for explicit integration and thus should be handled by a rigid-body simulator or coupled approaches (Compatible Particle-in-Cell). No explicit lower bound on fidelity for transfer is given (no formal minimal-fidelity ablation), but authors emphasize the need for physically-accurate constitutive models and contact handling for realistic transfer.",
            "failure_cases": "No explicit failure cases of transfer from low-fidelity simulations are reported, but caveats include: PBD (Flex) lacks explicit physical parameters making direct physical matching hard; explicit MPM requires small Δt for very stiff materials (necessitating rigid-body coupling). Also, PPO (model-free RL) trained in the same simulator learned much more slowly for some tasks, effectively failing to match gradient-based optimization efficiency within comparable wall-clock time (PPO still near-random after &gt;4 hours vs ChainQueen controller effective within ~20 minutes).",
            "uuid": "e1500.0",
            "source_info": {
                "paper_title": "ChainQueen: A Real-Time Differentiable Physical Simulator for Soft Robotics",
                "publication_date_yy_mm": "2018-10"
            }
        },
        {
            "name_short": "Flex",
            "name_full": "NVIDIA Flex (Unified particle physics / Position-Based Dynamics)",
            "brief_description": "A popular real-time particle-based Position-Based Dynamics (PBD) physics engine used for simulating deformable objects and fluids in interactive/graphics contexts; used here as a benchmark baseline for forward simulation performance.",
            "citation_title": "Unified particle physics for real-time applications",
            "mention_or_use": "use",
            "simulator_name": "NVIDIA Flex (PBD)",
            "simulator_description": "A particle-based Position-Based Dynamics simulator optimized for real-time applications (graphics/games) that can simulate deformable bodies and fluids using PBD integration and substepping.",
            "scientific_domain": "mechanics / real-time deformable body simulation",
            "fidelity_level": "approximate / lower-fidelity compared to continuum MPM—PBD focuses on stability and speed rather than explicit physical fidelity (e.g. no explicit Young's modulus).",
            "fidelity_characteristics": "Uses PBD constraints with substepping and iteration counts to increase stiffness; parameters are not direct physical quantities (no explicit Young's modulus), collision handled via PBD constraints; tuned for visual plausibility and real-time performance.",
            "model_or_agent_name": null,
            "model_description": null,
            "reasoning_task": null,
            "training_performance": null,
            "transfer_target": null,
            "transfer_performance": null,
            "compares_fidelity_levels": false,
            "fidelity_comparison_results": "ChainQueen (MLS-MPM) was faster for matched particle counts and is more physically-plausible (has explicit constitutive parameters) whereas Flex required parameter tuning and uses PBD iterations/substeps to reach similar visual stiffness; no systematic transfer experiments reported comparing Flex-&gt;real world.",
            "minimal_fidelity_discussion": "The paper notes PBD does not expose explicit physical quantities (e.g., Young's modulus), complicating physical matching; authors tuned Flex parameters to visually match ChainQueen for benchmarking.",
            "failure_cases": "No explicit transfer failures reported, but implicit limitation is PBD's limited physical interpretability for system identification or accurate real-world transfer.",
            "uuid": "e1500.1",
            "source_info": {
                "paper_title": "ChainQueen: A Real-Time Differentiable Physical Simulator for Soft Robotics",
                "publication_date_yy_mm": "2018-10"
            }
        },
        {
            "name_short": "TensorFlow reference implementation",
            "name_full": "ChainQueen TensorFlow reference implementation",
            "brief_description": "A reference TensorFlow-based implementation of the differentiable MLS-MPM algorithm used for correctness and as a high-level interface, but substantially slower than the optimized CUDA backend.",
            "citation_title": "",
            "mention_or_use": "use",
            "simulator_name": "ChainQueen (TensorFlow reference)",
            "simulator_description": "A high-level reference implementation of ChainQueen implemented in TensorFlow to expose differentiable computation graphs and a user-friendly API, intended for correctness and prototyping rather than speed.",
            "scientific_domain": "mechanics / differentiable simulation",
            "fidelity_level": "same algorithmic fidelity as ChainQueen (MLS-MPM) but lower practical performance due to framework/runtime overheads.",
            "fidelity_characteristics": "Implements the same MLS-MPM discretization and differentiable steps, but with higher overhead and less GPU/parallel memory optimization than CUDA backend; numerical fidelity identical in principle but wall-clock throughput much lower.",
            "model_or_agent_name": "same regression-based controller (used via TensorFlow interface for prototyping)",
            "model_description": "Controller encoded in TensorFlow as differentiable operations allowing symbolic differentiation; used more for prototyping than large-scale optimization due to performance overhead.",
            "reasoning_task": "Same soft-robotics control and inference tasks for prototyping",
            "training_performance": "Much slower: Table II reports e.g. 2D forward 6,400 particles: TF forward 13.2 ms/frame vs CUDA 0.10 ms/frame; TF backward 35.7 ms/frame vs CUDA 0.14 ms/frame. No separate transfer metrics reported.",
            "transfer_target": null,
            "transfer_performance": null,
            "compares_fidelity_levels": false,
            "fidelity_comparison_results": "Shows that implementing the same physics in a general AD framework (TensorFlow) is functionally possible, but runtime overheads make it far slower than a tailored CUDA implementation; no fidelity difference except performance.",
            "minimal_fidelity_discussion": "Authors note TensorFlow is optimized for deep learning workloads and not the memory-access patterns of particle simulation, implying that simulation fidelity is not limited by framework but by implementation efficiency.",
            "failure_cases": "Performance constraints (slowness) make TF reference less practical for large-scale or real-time optimization experiments, but no numerical failures reported.",
            "uuid": "e1500.2",
            "source_info": {
                "paper_title": "ChainQueen: A Real-Time Differentiable Physical Simulator for Soft Robotics",
                "publication_date_yy_mm": "2018-10"
            }
        },
        {
            "name_short": "SPNets",
            "name_full": "SPNets (differentiable fluid dynamics)",
            "brief_description": "A differentiable simulator for position-based fluids where particle interactions are implemented as neural-network-style operations to enable automatic differentiation for fluid tasks; cited as related work for differentiable deformable/fluids simulation.",
            "citation_title": "Spnets: Differentiable fluid dynamics for deep neural networks",
            "mention_or_use": "mention",
            "simulator_name": "SPNets",
            "simulator_description": "A differentiable particle-based fluid simulator built as neural-network operations (PyTorch) to support gradient-based learning and inference on fluid dynamics tasks.",
            "scientific_domain": "fluid dynamics",
            "fidelity_level": "medium-fidelity particle-based fluid simulation tailored to differentiability; emphasis on enabling learning rather than highest physical fidelity.",
            "fidelity_characteristics": "Particle interactions encoded as NN ops; uses PyTorch AD for gradients; targeted at position-based fluid models; likely simplifies some continuum aspects compared to full Navier–Stokes solvers.",
            "model_or_agent_name": null,
            "model_description": null,
            "reasoning_task": null,
            "training_performance": null,
            "transfer_target": null,
            "transfer_performance": null,
            "compares_fidelity_levels": null,
            "fidelity_comparison_results": "",
            "minimal_fidelity_discussion": "Mentioned as an alternative differentiable approach, but no transfer or fidelity-ablation details provided in this paper.",
            "failure_cases": "Not discussed in this paper.",
            "uuid": "e1500.3",
            "source_info": {
                "paper_title": "ChainQueen: A Real-Time Differentiable Physical Simulator for Soft Robotics",
                "publication_date_yy_mm": "2018-10"
            }
        },
        {
            "name_short": "MuJoCo",
            "name_full": "MuJoCo (Multi-Joint dynamics with Contact)",
            "brief_description": "A physics engine for model-based control and simulation of articulated rigid-body systems; mentioned in context of simulators used for model-based robotics and control.",
            "citation_title": "Mujoco: A physics engine for model-based control",
            "mention_or_use": "mention",
            "simulator_name": "MuJoCo",
            "simulator_description": "A widely-used rigid-body physics engine designed for model-based control tasks (fast, contact-handling rigid dynamics), commonly used in robotics and reinforcement learning benchmarks.",
            "scientific_domain": "rigid-body dynamics / robotics",
            "fidelity_level": "high-fidelity for articulated rigid-body dynamics and contact, but not designed for deformable continuum soft-body physics.",
            "fidelity_characteristics": "Accurate rigid-body dynamics with contact and constraints; not intended for large-deformation continuum soft bodies; used widely for model-based control research.",
            "model_or_agent_name": null,
            "model_description": null,
            "reasoning_task": null,
            "training_performance": null,
            "transfer_target": null,
            "transfer_performance": null,
            "compares_fidelity_levels": null,
            "fidelity_comparison_results": "",
            "minimal_fidelity_discussion": "Mentioned in refs as example simulator for model-based control; no discussion about minimal fidelity for transfer in this paper.",
            "failure_cases": "Not discussed here; general limitation for soft-body tasks is that rigid-body engines are not suitable for large-deformation soft robotics without coupling to deformable solvers.",
            "uuid": "e1500.4",
            "source_info": {
                "paper_title": "ChainQueen: A Real-Time Differentiable Physical Simulator for Soft Robotics",
                "publication_date_yy_mm": "2018-10"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Mujoco: A physics engine for model-based control",
            "rating": 2
        },
        {
            "paper_title": "Unified particle physics for real-time applications",
            "rating": 2
        },
        {
            "paper_title": "Spnets: Differentiable fluid dynamics for deep neural networks",
            "rating": 2
        },
        {
            "paper_title": "A moving least squares material point method with displacement discontinuity and two-way rigid body coupling",
            "rating": 2
        },
        {
            "paper_title": "Gpu optimization of material point methods",
            "rating": 1
        }
    ],
    "cost": 0.015425,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>MIT <br> Libraries</h1>
<h2>DSpace@MIT</h2>
<h2>MIT Open Access Articles</h2>
<h2>ChainQueen: a real-time differentiable physical simulator for soft robotics</h2>
<p>The MIT Faculty has made this article openly available. Please share how this access benefits you. Your story matters.</p>
<p>Citation: Hu, Yuanming et al. "ChainQueen: a real-time differentiable physical simulator for soft robotics." IEEE International Conference on Robotics and Automation 2019 (ICRA 2019), May 20-24, 2019, Montreal, Quebec: 6265-71 ©2019 Author(s)</p>
<p>As Published: 10.1109/ICRA.2019.8794333
Publisher: IEEE
Persistent URL: https://hdl.handle.net/1721.1/126657
Version: Original manuscript: author's manuscript prior to formal peer review
Terms of use: Creative Commons Attribution-Noncommercial-Share Alike</p>
<h1>ChainQueen: A Real-Time Differentiable Physical Simulator for Soft Robotics</h1>
<p>Yuanming Hu, Jiancheng Liu<em>, Andrew Spielberg</em>, Joshua B. Tenenbaum, William T. Freeman, Jiajun Wu, Daniela Rus, Wojciech Matusik ${ }^{1,2}$</p>
<h4>Abstract</h4>
<p>Physical simulators have been widely used in robot planning and control. Among them, differentiable simulators are particularly favored, as they can be incorporated into gradient-based optimization algorithms that are efficient in solving inverse problems such as optimal control and motion planning. Simulating deformable objects is, however, more challenging compared to rigid body dynamics. The underlying physical laws of deformable objects are more complex, and the resulting systems have orders of magnitude more degrees of freedom and therefore they are significantly more computationally expensive to simulate. Computing gradients with respect to physical design or controller parameters is typically even more computationally challenging. In this paper, we propose a real-time, differentiable hybrid Lagrangian-Eulerian physical simulator for deformable objects, ChainQueen, based on the Moving Least Squares Material Point Method (MLS-MPM). MLS-MPM can simulate deformable objects including contact and can be seamlessly incorporated into inference, control and co-design systems. We demonstrate that our simulator achieves high precision in both forward simulation and backward gradient computation. We have successfully employed it in a diverse set of control tasks for soft robots, including problems with nearly 3,000 decision variables.</p>
<h2>I. INTRODUCTION</h2>
<p>Robot planning and control algorithms often rely on physical simulators for prediction and optimization [1], [2]. In particular, differentiable physical simulators enable the use of gradient-based optimizers, significantly improving control efficiency and precision. Motivated by this, there has been extensive research on differentiable rigid body simulators, using approximate [3], [4] and exact [5], [6], [7] methods.</p>
<p>Significant challenges remain for deformable objects. First, simulating the motion of deformable objects is slow, because they have much higher degrees of freedom (DoFs). Second, contact detection and resolution is challenging for deformable objects, due to their changing geometries and potential selfcollisions. Third, closed-form and efficient computation of gradients is challenging in the presence of contact. As a consequence, current simulation methods for soft objects cannot be effectively used for solving inverse problems such as optimal control and motion planning.</p>
<p>In this paper, we introduce a real-time, differentiable physical simulator for deformable objects, building upon the Moving Least Squares Material Point Method (MLS-</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup>MPM) [8]. We name our simulator ChainQueen*. The Material Point Method (MPM) is a hybrid LagrangianEulerian method that uses both particles and grid nodes for simulation [9]. MLS-MPM accelerates and simplifies traditional MPM using a moving least squares force discretization. In ChainQueen, we introduce the first fully differentiable MLS-MPM simulator with respect to both state and model parameters, with both forward simulation and backpropagation running efficiently on GPUs. We demonstrate the ability to efficiently calculate gradients with respect to the entire simulation. This enables many novel applications for soft robotics including optimization-based closed-loop controller design, trajectory optimization, and co-design of robot geometry, materials, and control.</p>
<p>As a particle-grid-based hybrid simulator, MPM simulates objects of various states, such as liquid (e.g., water), granular materials (e.g., sand), and elastoplastic materials (e.g., snow and human tissue). ChainQueen focuses on elastic materials for soft robotics. It is fully differentiable and $4-9 \times$ faster than the current state-of-the-art. Numerical and experimental validation suggest that ChainQueen achieves high precision in both forward simulation and backward gradient computation.</p>
<p>ChainQueen's differentiability allows it to support gradientbased optimization for control and system identification. By performing gradient descent on controller parameters, our simulator is capable of solving these inverse problems on a diverse set of complex tasks, such as optimizing a 3D soft walker controller given an objective. Similarly, gradient descent on physical design parameters, enables inference of physical properties (e.g. mass, density and Young's modulus) of objects and optimizing design for a desired task.</p>
<p>In addition to benchmarking ChainQueen's performance and demonstrating its capabilities on a diverse set of inverse problems, we have interfaced our simulator with high-level python scripts to make ChainQueen user-friendly. Users at all levels will be able to develop their own soft robotics systems using our simulator, without the need to understand its low-level details. We will open-source our code and data and we hope they can benefit the robotics community.</p>
<h2>II. Related Work</h2>
<h2>A. Material Point Method</h2>
<p>The material point method has been extensively developed from both a solid mechanics [9] and computer graphics [10] perspective. As a hybrid Eulerian-Langrangian method, MPM</p>
<p><sup id="fnref:1"><a class="footnote-ref" href="#fn:1">2</a></sup></p>
<p>TABLE I: List of notations for MLS-MPM.</p>
<table>
<thead>
<tr>
<th>Symbol</th>
<th>Type</th>
<th>Affiliation</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\Delta t$</td>
<td>scalar</td>
<td></td>
<td>time step size</td>
</tr>
<tr>
<td>$\Delta x$</td>
<td>scalar</td>
<td></td>
<td>grid cell size</td>
</tr>
<tr>
<td>$\mathbf{x}_{p}$</td>
<td>vector</td>
<td>particle</td>
<td>position</td>
</tr>
<tr>
<td>$V_{p}^{0}$</td>
<td>scalar</td>
<td>particle</td>
<td>initial volume</td>
</tr>
<tr>
<td>$\mathbf{v}_{p}$</td>
<td>vector</td>
<td>particle</td>
<td>velocity</td>
</tr>
<tr>
<td>$\mathbf{C}_{p}$</td>
<td>matrix</td>
<td>particle</td>
<td>affine velocity field [28]</td>
</tr>
<tr>
<td>$\mathbf{P}_{p}$</td>
<td>matrix</td>
<td>particle</td>
<td>PK1 stress $\left(\partial\psi_{p} / \partial \mathbf{F}_{p}\right)$</td>
</tr>
<tr>
<td>$\boldsymbol{\sigma}_{p o}$</td>
<td>matrix</td>
<td>particle</td>
<td>actuation Cauchy stress</td>
</tr>
<tr>
<td>$\mathbf{A}_{p}$</td>
<td>matrix</td>
<td>particle</td>
<td>actuation stress (material space)</td>
</tr>
<tr>
<td>$\mathbf{F}_{p}$</td>
<td>matrix</td>
<td>particle</td>
<td>deformation gradient</td>
</tr>
<tr>
<td>$\mathbf{x}_{i}$</td>
<td>vector</td>
<td>node</td>
<td>position</td>
</tr>
<tr>
<td>$m_{i}$</td>
<td>scalar</td>
<td>node</td>
<td>mass</td>
</tr>
<tr>
<td>$\mathbf{v}_{i}$</td>
<td>vector</td>
<td>node</td>
<td>velocity</td>
</tr>
<tr>
<td>$\mathbf{p}_{i}$</td>
<td>vector</td>
<td>node</td>
<td>momentum, i.e. $m_{i} \mathbf{v}_{i}$</td>
</tr>
<tr>
<td>$N$</td>
<td>scalar</td>
<td></td>
<td>quadratic B-spline function</td>
</tr>
</tbody>
</table>
<p>has demonstrated its versatility in simulating snow [11], [12], sand [13], [14], non-Newtonion fluids [15], cloth [16], [17], solid-fluid coupling [18], [19], rigid body coupling, and cutting [8]. [20] also proposed an adaptive MPM scheme to concentrate computation resources in the regions of interest.</p>
<p>There are many benefits of using MPM for soft robotics. First, MPM is a well-founded and physically-accurate discretization method and can be derived through the weak form of conservation laws. Such a physically-based approach makes it easier to match simulation with real-world experiments. Second, MPM is friendly to parallelization on modern hardware architectures. Closely related to our work is a high-performance GPU implementation [21] by Gao et al., from which we borrow many useful optimization practices. Though efficient when solving forward simulation, their simulator is not differentiable, making it inefficient for inverse problems in robotics and learning. Third, MPM naturally handles large deformation and (self-)collision, which are common in soft robotics, but often not modeled in, e.g., mesh-based approaches due to computational expense. Finally, the continuum dynamics (including soft object collision) are governed by the smooth (and differentiable) potential energy, making the whole system differentiable.</p>
<p>Our simulator, ChainQueen, is fully differentiable and the first simulator that applies MPM to soft robotics.</p>
<h2>B. Differentiable Simulation and Control</h2>
<p>Recently, there has been an increasing interest in building differentiable simulators for planning and control. For rigid bodies, [22], [3] and [4] proposed to approximate object interaction with neural nets; later, [23] explored their usage in control. Approximate analytic differentiable rigid body simulators have also been proposed [5], [24]. Such systems have been deployed for manipulation and planning [25].</p>
<p>Differentiable simulators for deformable objects have been less studied. Recently, [26] proposed SPNets for differentiable simulation of position-based fluids [27]. The particle interactions are coded as neural network operations and differentiability is achieved via automatic differentiation in PyTorch. A hierarchical particle-based object representation using neural networks is also proposed in [4]. Instead of approximating physics using neural networks, ChainQueen differentiates MLS-MPM, a well physically founded discretization scheme derived from continuum mechanics. In summary, our simulator can be used for a more diverse set of objects; it is more physically plausible, and runs faster.</p>
<h2>III. FORWARD SIMULATION AND BACK-PROPAGATION</h2>
<p>We use the moving least squares material point method (MLS-MPM) [8] to discretize continuum mechanics, which is governed by the following two equations:</p>
<p>$$
\begin{gathered}
\rho \frac{D \mathbf{v}}{D t}=\nabla \cdot \boldsymbol{\sigma}+\rho \mathbf{g} \quad \text { (momentum conservation) } \
\frac{D \rho}{D t}+\rho \nabla \cdot \mathbf{v}=0 \quad \text { (mass conservation) }
\end{gathered}
$$</p>
<p>We briefly cover the basics of MLS-MPM and readers are referred to [10] and [8] for a comprehensive introduction of MPM and MLS-MPM, respectively. The material point method is a hybrid Eulerian-Lagrangian method, where both particles and grid nodes are used. Simulation state information is transferred back-and-forth between these two representations. We summarize the notations we use in this paper in Table IV. Subscripts are used to denote particle ( $p$ ) and grid nodes $(i)$, while superscripts $(n, n+1)$ are used to distinguish quantities in different time steps. The MLS-MPM simulation cycle has three steps:</p>
<p>1) Particle-to-grid transfer (P2G). Particles transfer mass $m_{p}$, momentum $(m \mathbf{v})_{p}^{n}$, and stress-contributed impulse to their neighbouring grid nodes, using the Affine Particle-in-Cell method (APIC) [28] and moving least squares force discretization [8], weighted by a compact B-spline kernel $N$ :</p>
<p>$$
\begin{aligned}
m_{i}^{n} &amp; =\sum_{p} N\left(\mathbf{x}<em p="p">{i}-\mathbf{x}</em> \
\mathbf{G}}^{n}\right) m_{p<em p="p">{p}^{n} &amp; =-\frac{4}{\Delta x^{2}} \Delta t V</em>}^{0} \mathbf{P<em p="p">{p}^{n} \mathbf{F}</em>}^{n T}+m_{p} \mathbf{C<em i="i">{p}^{n} \
\mathbf{p}</em>}^{n} &amp; =\sum_{p} N\left(\mathbf{x<em p="p">{i}-\mathbf{x}</em>}^{n}\right)\left[m_{p} \mathbf{v<em p="p">{p}^{n}+\mathbf{G}</em>}^{n}\left(\mathbf{x<em p="p">{i}-\mathbf{x}</em>\right)\right]
\end{aligned}
$$}^{n</p>
<p>2) Grid operations. Grid momentum is normalized into grid velocity after division by grid mass:</p>
<p>$$
\mathbf{v}<em i="i">{i}^{n}=\frac{1}{m</em>
$$}^{n}} \mathbf{p}_{i}^{n</p>
<p>Note that neighbouring particles interact with each other through their shared grid nodes, and collisions are handled automatically. Here we omit boundary conditions and gravity for simplicity.
3) Grid-to-particle transfer (G2P). Particles gather updated velocity $\mathbf{v}<em p="p">{p}^{n+1}$, local velocity field gradients $\mathbf{C}</em>}^{n+1}$ and position $\mathbf{x<em p="p">{p}^{n+1}$. The constitutive model properties (e.g. deformation gradients $\mathbf{F}</em>$ ) are updated.}^{n+1</p>
<p>$$
\begin{aligned}
\mathbf{v}<em i="i">{p}^{n+1} &amp; =\sum</em>} N\left(\mathbf{x<em p="p">{i}-\mathbf{x}</em>}^{n}\right) \mathbf{v<em p="p">{i}^{n} \
\mathbf{C}</em>}^{n+1} &amp; =\frac{4}{\Delta x^{2}} \sum_{i} N\left(\mathbf{x<em p="p">{i}-\mathbf{x}</em>}^{n}\right) \mathbf{v<em i="i">{i}^{n}\left(\mathbf{x}</em>}-\mathbf{x<em p="p">{p}^{n}\right)^{T} \
\mathbf{F}</em>}^{n+1} &amp; =\left(\mathbf{I}+\Delta t \mathbf{C<em p="p">{p}^{n+1}\right) \mathbf{F}</em> \
\mathbf{x}}^{n<em p="p">{p}^{n+1} &amp; =\mathbf{x}</em>
\end{aligned}
$$}^{n}+\Delta t \mathbf{v}_{p}^{n+1</p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Fig. 1: One time step of MLS-MPM. Top arrows are for forward simulation and bottom ones are for back propagation. A controller is embedded in the P2G process to generate actuation given particle configurations.</p>
<p>For soft robotics, we additionally introduce an actuation model. Inspired by actuators such as [29], we designed an actuation model that expands or stretches particle <em>p</em> via an additional Cauchy stress <strong>A</strong><sup><em>p</em></sup> = <strong>F</strong><sup><em>p</em></sup><strong>σ</strong><sub><em>p</em><em>a</em></sub><strong>F</strong><sub><em>p</em></sub><sup><em>T</em></sup>, with <strong>σ</strong><sub><em>p</em><em>a</em></sub> = Diag(<em>a</em><sub><em>x</em></sub>, <em>a</em><sub><em>y</em></sub>, <em>a</em><sub><em>z</em></sub>) – the stress in the material space. This framework supports the use of other differentiable actuation models including pneumatic, hydraulic, and cable-driven actuators. Fig. 1 illustrates forward simulation and back propagation.</p>
<p>MLS-MPM is naturally differentiable. Though the forward direction has been extensively used in computer graphics, the backward direction (differentiation or back-propagation) is largely unexplored.</p>
<p>Based on the gradients we have derived analytically, we have designed a high-performance implementation that resembles the traditional forward MPM cycle: backward P2G (scatter particle gradients to grid), grid operations, and backward G2P (gather grid gradients to particles). <sup>†</sup> Gradients of state at the end of a time step with respect to states at the starting of the time step can be computed using the chain rule. With the single-step gradients computed, applying the chain rule at a higher level from the final state all-the-way to the initial state yields gradients of the final state with respect to the initial state, as well as to the controller parameters that are used in each state. We cache all the simulation states in memory, using a "memo" object. Though the underlying differentiation is complicated, we have designed a simple high-level TensorFlow interface on which end-users can build their applications (Fig. 2).</p>
<p>Our high-performance implementation<sup>‡</sup> takes advantage of the computational power of modern GPUs through CUDA. We also implemented a reference implementation in TensorFlow. Note that programming physical simulation as a "computation graph" using high-level frameworks such as TensorFlow is less inefficient. In fact, when all the overheads are gone, our optimized CUDA solver is 132× faster than the TensorFlow reference version. This is because TensorFlow is optimized towards deep learning applications where data granularity is much larger and memory access pattern is much more regular than physical simulation, and limited CPU-GPU bandwidth. In contrast, our CUDA implementation is tailored for MLS-</p>
<p>TABLE II: Performance comparisons on a NVIDIA GTX 1080 Ti GPU. <strong>F</strong> stands for forward simulation and <strong>B</strong> stands for backward differentiation. <strong>TF</strong> indicates the TensorFlow implementation. When benchmarking our simulator with CUDA we use the C++ instead of python interface to avoid the extra overhead due to the TensorFlow runtime library.</p>
<table>
<thead>
<tr>
<th>Approach</th>
<th>Impl.</th>
<th># Particles</th>
<th>Time per Frame</th>
</tr>
</thead>
<tbody>
<tr>
<td>Flex (3D)</td>
<td>CUDA</td>
<td>8,024</td>
<td>3.5 ms (286 FPS)</td>
</tr>
<tr>
<td>Ours (3D, F)</td>
<td>CUDA</td>
<td>8,000</td>
<td>0.392 ms (2,551 FPS)</td>
</tr>
<tr>
<td>Ours (3D, B)</td>
<td>CUDA</td>
<td>8,000</td>
<td>0.406 ms (2,463 FPS)</td>
</tr>
<tr>
<td>Flex (3D)</td>
<td>CUDA</td>
<td>61,238</td>
<td>6 ms (167 FPS)</td>
</tr>
<tr>
<td>Ours (3D, F)</td>
<td>CUDA</td>
<td>64,000</td>
<td>1.594 ms (628 FPS)</td>
</tr>
<tr>
<td>Ours (3D, B)</td>
<td>CUDA</td>
<td>64,000</td>
<td>1.774 ms (563 FPS)</td>
</tr>
<tr>
<td>Ours (3D, F)</td>
<td>CUDA</td>
<td>512,000</td>
<td>10.501 ms (92 FPS)</td>
</tr>
<tr>
<td>Ours (3D, B)</td>
<td>CUDA</td>
<td>512,000</td>
<td>11.594 ms (86 FPS)</td>
</tr>
<tr>
<td>Ours (2D, F)</td>
<td>TF</td>
<td>6,400</td>
<td>13.2 ms (76 FPS)</td>
</tr>
<tr>
<td>Ours (2D, B)</td>
<td>TF</td>
<td>6,400</td>
<td>35.7 ms (28 FPS)</td>
</tr>
<tr>
<td>Ours (2D, F)</td>
<td>CUDA</td>
<td>6,400</td>
<td>0.10 ms (10,000 FPS)</td>
</tr>
<tr>
<td>Ours (2D, B)</td>
<td>CUDA</td>
<td>6,400</td>
<td>0.14 ms (7,162 FPS)</td>
</tr>
</tbody>
</table>
<p>MPM and explicitly optimized for parallelism and locality, thus delivering high-performance.</p>
<h2>IV. EVALUATION</h2>
<p>In this section, we conduct a comprehensive study of the efficiency and accuracy of our system, in both 2D and 3D.</p>
<h3>A. Efficiency</h3>
<p>Instead of using complex geometries, a simple falling cube is used for performance benchmarking, to ensure easy analysis and reproducibility. We benchmark the performance of our CUDA simulator against NVIDIA Flex [31], a popular PBD physical simulator capable of simulating deformable objects. Note that both PBD and MLS-MPM needs substepping iterations to ensure high stiffness. To ensure fair comparison, we set a Young's modulus, Poisson's ration and density so that visually ChainQueen gives similar results to Flex. We used two steps per frame and four iterations per step in Flex. Note that setting exactly the same parameters is not possible since in PBD there is no explicitly defined physical quantity such as Young's modulus.</p>
<p>We summarize the quantitative performance in Table II. Our CUDA simulator provides higher speed than Flex, when the number of particles are the same. It is also worth noting</p>
<p><sup>†</sup>Please see the supplemental document for the gradient derivations.</p>
<p><sup>‡</sup>Based the Taichi [30] open source computer graphics library.</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Fig. 2: Left: A "memo" object consists all information of a single simulation execution, including all the time step state information (position, velocity, deformation gradients etc.), and parameters for the initial state $p_{0}$, policy parameter $\theta$. Right: Code samples to get the symbolic differentiation (top) and memo, evaluate gradients out of the memo and symbolic differentiation, and finally use them for gradient descent (bottom).</p>
<p>that the TensorFlow implementation is much slower, due to excessive runtime overheads.</p>
<h3>B. Accuracy</h3>
<p>We design five test cases to evaluate the accuracy of both forward simulation and backward gradient evaluation:</p>
<ol>
<li>A1 (analytic, 3D, float32 precision): final position w.r.t. initial velocity (with collision). This case tests conservation of momentum, gradient accuracy and stability of back-propagation.</li>
<li>A2 (analytic, 3D, float32 precision): same as A1 but with one collision to a friction-less wall.</li>
<li>B (numeric, 2D, float64 precision): colliding billiards. This case tests gradient accuracy and stability in more complex cases where analytic solutions do not exist. We used float64 precision for accurate finite difference results.</li>
<li>C (numeric, 2D, float64 precision): finger controller. This case tests gradient accuracy of controller parameters, which are used repeatedly in the whole simulation process.</li>
<li>D1 (experimental, pneumatic actuator, actuation) In order to evaluate our simulator's real-world accuracy, we compared the deformation of a physical actuator to a virtual one. The physical actuator has four pneumatic chambers which can be inflated with an external pump, arranged in a cross-shape. Inflating the individual chambers bends the actuator away from that chamber. The actuator was</li>
</ol>
<p>TABLE III: Relative error in simulation and gradient precision. Empty values are because of too short time for collision to happen.</p>
<table>
<thead>
<tr>
<th>Case</th>
<th>1 steps</th>
<th>10 steps</th>
<th>100 steps</th>
<th>1000 steps</th>
</tr>
</thead>
<tbody>
<tr>
<td>A1</td>
<td>9.80 × 10<sup>−8</sup></td>
<td>4.74 × 10<sup>−8</sup></td>
<td>1.15 × 10<sup>−7</sup></td>
<td>1.43 × 10<sup>−5</sup></td>
</tr>
<tr>
<td>A2</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>2.69 × 10<sup>−5</sup></td>
</tr>
<tr>
<td>B</td>
<td>-</td>
<td>-</td>
<td>2.39 × 10<sup>−8</sup></td>
<td>2.83 × 10<sup>−8</sup></td>
</tr>
<tr>
<td>C</td>
<td>5.63 × 10<sup>−6</sup></td>
<td>2.24 × 10<sup>−7</sup></td>
<td>6.97 × 10<sup>−7</sup></td>
<td>1.76 × 10<sup>−6</sup></td>
</tr>
</tbody>
</table>
<p>cast using Smooth-On Dragon Skin 30.</p>
<ol>
<li>D2 (experimental, pneumatic actuator, bouncing) In a second test, we dropped the same actuator from a 15 cm height, and compared its dynamic motion to a simulation.</li>
</ol>
<p>In 3D analytic test cases, where gradients w.r.t. initial velocity can be directly evaluated as in Table III. For the experimental comparisons, the results are shown in Fig. 3. In addition to our simulator's high performance and accuracy, it is worth noting that that the gradients remain stable in the long term, within up to 1000 time steps.</p>
<h3>V. INFERENCE, CONTROL AND CO-DESIGN</h3>
<p>The most attractive feature of our simulator is the existence of quickly computable gradients, which allows the use of much more efficient gradient-based optimization algorithms. In this section, we show the effectiveness of our differentiable simulator on gradient-based optimization tasks, including physical inference, control for soft robotics, and co-design of robotic arms.</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Fig. 3: Experiments on the pneumatic leg. Row (A, B) Footage and simulator results of a bouncing experiment with the leg dropping at 15 cm. Row (C, D) Actuation test.</p>
<h3>A. Physical Parameter Inference</h3>
<p>ChainQueen can be used to infer physical system properties given its observed motion, e.g. perform gradient descent to infer the relative densities of two colliding elastic balls (see figure above, ball A moving to the right hitting ball B, and ball B arrives the destination C). Gradient-based optimization infers that relative density of ball A is 2.26, which constitutes to the correct momentum to push B to C. Such capability makes it useful for real-world robotic tasks such as system identification.</p>
<h3>B. Control</h3>
<p>We can optimize regression-based controllers for soft robots and efficiently discover stable gaits. The controller takes as input the state vector <strong>z</strong>, which includes target position, the center of mass position, and velocity of each composed soft component. In our examples, the actuation vector <strong>a</strong> for up to 16 actuators is generated by the controller in each time step. During optimization, we perform gradient descent on variables <strong>W</strong> and <strong>b</strong>, where <strong>a</strong> = tanh(<strong>Wz</strong>+<strong>b</strong>) is the</p>
<p><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Fig. 4: A soft 2D walker with controller optimized using gradient descent, aiming to achieve a maximum distance after 600 simulation steps. The walker has four actuators (left, marked by letter 'A's) with each capable of stretching or compressing in the vertical direction. The full walking animation (middle and right) is available in the video.</p>
<p>actuation-generating controller.</p>
<p>We have designed a series of experiments including the 2D biped runner (Fig. 4) and robotic finger, and 3D quadrupedal runner (Fig. 6), crawler and robotic arm. Gradient-based optimizers successfully compute desired controllers within only tens or hundreds of iterations. Visual results are included in the supplemental video.</p>
<p>To emphasize the merits of gradient-based approaches, we compare our control method with proximal policy optimization (PPO) [32], a state-of-the-art reinforcement learning algorithm. PPO is an actor-critic method which relies on sampled gradients of a <em>reward</em> function in order to optimize a policy. This sampling-based approach is model-free; it relies on gradients of the rewards with respect to controller parameters, but <em>not</em> with respect to the physical model for updates. For our comparison, we use velocity projected onto the direction toward the goal as the reward. <sup>§</sup> We use a simplified single link version (with only two adjacent actuators) of Fig. 5 and the 2D runner Fig. 4 as a benchmark. Quantitative results for the finger are shown in Fig. 7. We performed a similar comparison on the 2D walker, the controller optimized by ChainQueen for the 2D walker starts functioning well within 20 minutes; by comparison the policy recovered by PPO still chose nearly-random actions after over 4 hours of training; demonstrating that for certain soft locomotion tasks our gradient-based method can be more efficient than model-free approaches.</p>
<h3>C. Co-design</h3>
<p>Our simulator is capable of not only providing gradients with respect to dynamics and controller parameters, but also with respect to structural design parameters, enabling co-design of soft robots. To demonstrate this, we designed a multi-link robot arm (two links, two joints each with two side-by-side actuators; all parts deformable). Similar to shooting method trajectory optimization, actuation for each time step is solved for, along with the time-invariant Young's modulus of the system for each particle. In our task, we optimized the end-effector of the arm to reach a goal ball with final 0 arm velocity, and minimized for actuation cost $$ \sum_{i=0}^{N} u_i^T u_i dt $$, where $$ u_i $$ is the actuation vector at timestep $$ i $$, and $$ N $$ is the total number of timesteps. This is a <em>dynamic</em> task and</p>
<p><sup>§</sup>Note that this is functionally extremely similar to a distance loss; the cumulative reward $$ \int_t = 0^T v_{goal} dt = D - |x_T - x_{goal} | $$, where $$ D $$ is the initial distance and $$ x_T $$ and $$ x_{goal} $$ represent world coordinates of the robot at time $$ T $$ and of the goal, respectively. As velocity toward the goal increases, final distance to the goal decreases.</p>
<p><img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Fig. 5: Final poses of the arm swing task. Lighter colors refer to stiffer regions. (c) Final pose of the fixed-stiffness 300% initial Young’s modulus arm. (d) Final pose of the fixed-stiffness 300% initial Young’s modulus arm. (e) Final pose of the co-optimized arm. Actuation cost is 95.5% that of the fixed 100% initial Young’s modulus arm and converges. Only the co-optimized arm is able to fully reach its target. The final optimized spatially varying stiffness of the arm has lower stiffness on the outside of the bend, and higher stiffness inside, promoting more bend to the left. Qualitatively, this is similar in effect to the pleating on soft robot fingers.</p>
<p><img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>Fig. 6: A 3D quadrupedal runner. Please see the supplemental video for more results.</p>
<p><img alt="img-6.jpeg" src="img-6.jpeg" /></p>
<p>Fig. 7: Gradient-free optimization using PPO and gradient-descent based on ChainQueen, on the 2D finger task. Thanks to the accurate gradient information, even the most vanilla optimizer can beat state-of-the-art reinforcement learning algorithms by one order of magnitude regarding optimization speed. (Left) single, fixed target. (Middle) random targets. (Right) random targets, larger range. Curves are smoothed over 10, 100 and 100 iterations respectively. The x-axis is simulation iterations and y-axis the loss.</p>
<p>The target pose cannot be reached in a static equilibrium. NLOPT’s sequential least squares programming algorithm was used for optimization [33]. We compared our co-design solution to fixed designs. The designed stiffness distribution is shown in Fig. 5, along with controls. The convergence for the different tasks can be seen in Fig. 8. As can be seen, only the co-design arm fully converges to the target goal, and with lower actuation cost. Actuation for each chamber was clamped, and rnges of 30% to 400% of a dimensionless initial Young’s modulus were allowed and chosen large enough such as to require a swing instead of a simple bend.</p>
<h2>VI. DISCUSSION</h2>
<p>We have presented ChainQueen, a differentiable simulator for soft robotics, and demonstrated how it can be deployed for inference, control, and co-design. ChainQueen has the potential to accelerate the development of soft robots. We have also developed a high-performance GPU implementation for ChainQueen, which we plan to open source.</p>
<p><img alt="img-7.jpeg" src="img-7.jpeg" /></p>
<p>Fig. 8: Convergence of the arm reaching task for co-design vs. fixed arm designs. The fixed designs can make progress but not complete the task, while with co-design, the task can be completed and the actuation cost is lower. Constraint violation is the norm of two constraints: distance of end-effector to goal and mean squared velocity of the particles.</p>
<p>One interesting future direction is to couple our soft object simulation with rigid body simulation, as done in [8]. As derived in [34], the ∆t limit for explicit time integration is C∆x√gˆt, where C is a constant close to one, ρ is the density, and E is the Young’s modulus. That means for very stiff materials (e.g., rigid bodies), only a very restrictive ∆t can be used. However, a rigid body simulator should probably be employed in the realm of nearly-rigid objects and coupled with our deformable body simulator. Combining our simulator with existing rigid-body simulators using Compatible Particle-in-Cell [8] can be an interesting direction.</p>
<h2>ACKNOWLEDGMENTS</h2>
<p>We would like to thank Chenfanfu Jiang, Ming Gao and Kui Wu for the insightful discussions.</p>
<h1>Supplemental Document</h1>
<p>In this document, we discuss the detailed steps for backward gradient computation in ChainQueen, i.e. the differentiable Moving Least Squares Material Point Method (MLS-MPM) [8]. Again, we summarize the notations in Table IV. We assume fixed particle mass $m_{p}$, volume $V_{p}^{0}$, hyperelastic constitutive model (with potential energy $\psi_{p}$ or Young's modulus $E_{p}$ and Poisson's ratio $\nu_{p}$ ) for simplicity.</p>
<p>TABLE IV: List of notations for MLS-MPM.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Symbol</th>
<th style="text-align: center;">Type</th>
<th style="text-align: center;">Affiliation</th>
<th style="text-align: center;">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">$\Delta t$</td>
<td style="text-align: center;">scalar</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">time step size</td>
</tr>
<tr>
<td style="text-align: center;">$\Delta x$</td>
<td style="text-align: center;">scalar</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">grid cell size</td>
</tr>
<tr>
<td style="text-align: center;">$\mathbf{x}_{p}$</td>
<td style="text-align: center;">vector</td>
<td style="text-align: center;">particle</td>
<td style="text-align: center;">position</td>
</tr>
<tr>
<td style="text-align: center;">$V_{p}^{0}$</td>
<td style="text-align: center;">scalar</td>
<td style="text-align: center;">particle</td>
<td style="text-align: center;">initial volume</td>
</tr>
<tr>
<td style="text-align: center;">$\mathbf{v}_{p}$</td>
<td style="text-align: center;">vector</td>
<td style="text-align: center;">particle</td>
<td style="text-align: center;">velocity</td>
</tr>
<tr>
<td style="text-align: center;">$\mathbf{C}_{p}$</td>
<td style="text-align: center;">matrix</td>
<td style="text-align: center;">particle</td>
<td style="text-align: center;">affine velocity field [28]</td>
</tr>
<tr>
<td style="text-align: center;">$\mathbf{P}_{p}$</td>
<td style="text-align: center;">matrix</td>
<td style="text-align: center;">particle</td>
<td style="text-align: center;">PK1 stress $\left(\partial \psi_{p} / \partial \mathbf{F}_{p}\right)$</td>
</tr>
<tr>
<td style="text-align: center;">$\boldsymbol{\sigma}_{p a}$</td>
<td style="text-align: center;">matrix</td>
<td style="text-align: center;">particle</td>
<td style="text-align: center;">actuation Cauchy stress</td>
</tr>
<tr>
<td style="text-align: center;">$\mathbf{A}_{p}$</td>
<td style="text-align: center;">matrix</td>
<td style="text-align: center;">particle</td>
<td style="text-align: center;">actuation stress (material space)</td>
</tr>
<tr>
<td style="text-align: center;">$\mathbf{F}_{p}$</td>
<td style="text-align: center;">matrix</td>
<td style="text-align: center;">particle</td>
<td style="text-align: center;">deformation gradient</td>
</tr>
<tr>
<td style="text-align: center;">$\mathbf{x}_{i}$</td>
<td style="text-align: center;">vector</td>
<td style="text-align: center;">node</td>
<td style="text-align: center;">position</td>
</tr>
<tr>
<td style="text-align: center;">$m_{i}$</td>
<td style="text-align: center;">scalar</td>
<td style="text-align: center;">node</td>
<td style="text-align: center;">mass</td>
</tr>
<tr>
<td style="text-align: center;">$\mathbf{v}_{i}$</td>
<td style="text-align: center;">vector</td>
<td style="text-align: center;">node</td>
<td style="text-align: center;">velocity</td>
</tr>
<tr>
<td style="text-align: center;">$\mathbf{p}_{i}$</td>
<td style="text-align: center;">vector</td>
<td style="text-align: center;">node</td>
<td style="text-align: center;">momentum, i.e. $m_{i} \mathbf{v}_{i}$</td>
</tr>
<tr>
<td style="text-align: center;">$N$</td>
<td style="text-align: center;">scalar</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">quadratic B-spline function</td>
</tr>
</tbody>
</table>
<h2>VII. VARIABLE DEPENDENCIES</h2>
<p>The MLS-MPM time stepping is defined as follows:</p>
<p>$$
\begin{aligned}
\mathbf{P}<em p="p">{p}^{n} &amp; =\mathbf{P}</em>}^{n}\left(\mathbf{F<em p="p">{p}^{n}\right)+\mathbf{F}</em>} \boldsymbol{\sigma<em i="i">{p a}^{n} \
m</em>}^{n} &amp; =\sum_{p} N\left(\mathbf{x<em p="p">{i}-\mathbf{x}</em> \
\mathbf{p}}^{n}\right) m_{p<em p="p">{i}^{n} &amp; =\sum</em>} N\left(\mathbf{x<em p="p">{i}-\mathbf{x}</em>}^{n}\right)\left[m_{p} \mathbf{v<em p="p">{p}^{n}+\left(-\frac{4}{\Delta x^{2}} \Delta t V</em>}^{0} \mathbf{P<em p="p">{p}^{n} \mathbf{F}</em>}^{n T}+m_{p} \mathbf{C<em i="i">{p}^{n}\right)\left(\mathbf{x}</em>}-\mathbf{x<em i="i">{p}^{n}\right)\right] \
\mathbf{v}</em>}^{n} &amp; =\frac{1}{m_{i}^{n}} \mathbf{p<em p="p">{i}^{n} \
\mathbf{v}</em>}^{n+1} &amp; =\sum_{i} N\left(\mathbf{x<em p="p">{i}-\mathbf{x}</em>}^{n}\right) \mathbf{v<em p="p">{i}^{n} \
\mathbf{C}</em>}^{n+1} &amp; =\frac{4}{\Delta x^{2}} \sum_{i} N\left(\mathbf{x<em p="p">{i}-\mathbf{x}</em>}^{n}\right) \mathbf{v<em i="i">{i}^{n}\left(\mathbf{x}</em>}-\mathbf{x<em p="p">{p}^{n}\right)^{T} \
\mathbf{F}</em>}^{n+1} &amp; =\left(\mathbf{I}+\Delta t \mathbf{C<em p="p">{p}^{n+1}\right) \mathbf{F}</em> \
\mathbf{x}}^{n<em p="p">{p}^{n+1} &amp; =\mathbf{x}</em>
\end{aligned}
$$}^{n}+\Delta t \mathbf{v}_{p}^{n+1</p>
<p>The forward variable dependency is as follows:</p>
<p>$\mathbf{x}<em p="p">{p}^{n+1}$ $\leftarrow$ $\mathbf{x}</em>}^{n}, \mathbf{v<em p="p">{p}^{n+1}$
$\mathbf{v}</em>}^{n+1}$ $\leftarrow$ $\mathbf{x<em i="i">{p}^{n}, \mathbf{v}</em>$
$\mathbf{C}}^{n<em p="p">{p}^{n+1}$ $\leftarrow$ $\mathbf{x}</em>}^{n}, \mathbf{v<em p="p">{i}^{n}$
$\mathbf{F}</em>}^{n+1}$ $\leftarrow$ $\mathbf{F<em p="p">{p}^{n}, \mathbf{C}</em>$
$\mathbf{p}}^{n+1<em p="p">{i}^{n}$ $\leftarrow$ $\mathbf{x}</em>}^{n}, \mathbf{C<em p="p">{p}^{n}, \mathbf{v}</em>}^{n}, \mathbf{P<em p="p">{p}^{n}, \mathbf{F}</em>$
$\mathbf{v}}^{n<em i="i">{i}^{n}$ $\leftarrow$ $\mathbf{p}</em>$
$\mathbf{P}}^{n}, m_{i}^{n<em p="p">{p}^{n}$ $\leftarrow$ $\mathbf{F}</em>}^{n}, \boldsymbol{\sigma<em i="i">{p a}^{n}$
$m</em>$}^{n}$ $\leftarrow$ $\mathbf{x}_{p}^{n</p>
<p>During back-propagation, we have the following reversed variable dependency:</p>
<p>$\mathbf{x}<em p="p">{p}^{n+1}, \mathbf{v}</em>}^{n+1}, \mathbf{C<em i="i">{p}^{n+1}, \mathbf{p}</em>}^{n+1}, m_{i}$ $\leftarrow \mathbf{x<em i="i">{p}^{n}$
$\mathbf{p}</em>}^{n} \leftarrow \mathbf{v<em p="p">{p}^{n}$
$\mathbf{x}</em>}^{n+1} \leftarrow \mathbf{v<em p="p">{p}^{n+1}$
$\mathbf{v}</em>}^{n+1}, \mathbf{C<em i="i">{p}^{n+1} \leftarrow \mathbf{v}</em>$
$\mathbf{F}}^{n<em p="p">{p}^{n+1}, \mathbf{P}</em>}^{n}, \mathbf{p<em p="p">{i}^{n} \leftarrow \mathbf{F}</em>$
$\mathbf{F}}^{n<em p="p">{p}^{n+1} \leftarrow \mathbf{C}</em>$
$\mathbf{p}}^{n+1<em p="p">{i}^{n} \leftarrow \mathbf{C}</em>$
$\mathbf{v}}^{n<em i="i">{i}^{n} \leftarrow \mathbf{p}</em>$
$\mathbf{v}}^{n<em i="i">{i}^{n} \leftarrow m</em>$
$\mathbf{p}}^{n<em p="p">{i}^{n} \leftarrow \mathbf{P}</em>$
$\mathbf{P}}^{n<em a="a" p="p">{p}^{n} \leftarrow \boldsymbol{\sigma}</em>$}^{n</p>
<p>We reverse swap two sides of the equations for easier differentiation derivation:</p>
<p>$\mathbf{x}<em p="p">{p}^{n} \rightarrow \mathbf{x}</em>}^{n+1}, \mathbf{v<em p="p">{p}^{n+1}, \mathbf{C}</em>}^{n+1}, \mathbf{p<em i="i">{i}^{n+1}, m</em>$
$\mathbf{v}<em p="p">{p}^{n} \rightarrow \mathbf{p}</em>$
$\mathbf{v}}^{n<em p="p">{p}^{n+1} \rightarrow \mathbf{x}</em>$
$\mathbf{v}}^{n+1<em p="p">{i}^{n} \rightarrow \mathbf{v}</em>}^{n+1}, \mathbf{C<em p="p">{p}^{n+1}$
$\mathbf{F}</em>}^{n} \rightarrow \mathbf{F<em p="p">{p}^{n+1}, \mathbf{P}</em>}^{n}, \mathbf{p<em p="p">{i}^{n}$
$\mathbf{C}</em>}^{n+1} \rightarrow \mathbf{F<em p="p">{p}^{n+1}$
$\mathbf{C}</em>}^{n} \rightarrow \mathbf{p<em i="i">{i}^{n}$
$\mathbf{p}</em>}^{n} \rightarrow \mathbf{v<em i="i">{i}^{n}$
$m</em>}^{n} \rightarrow \mathbf{v<em p="p">{i}^{n}$
$\mathbf{P}</em>}^{n} \rightarrow \mathbf{p<em a="a" p="p">{i}^{n}$
$\boldsymbol{\sigma}</em>$}^{n} \rightarrow \mathbf{P}_{p}^{n</p>
<p>In the following sections, we derive detailed gradient relationships, in the order of actual gradient computation. The frictional boundary condition gradients are postponed to the end since it is less central, though during computation it belongs to grid operations. Back-propagation in ChainQueen is essentially a reversed process of forward simulation. The computation has three steps, backward particle to grid (P2G), backward grid operations, and backward grid to particle (G2P).</p>
<p>(A, P2G) For $\mathbf{v}_{p}^{n+1}$, we have</p>
<p>$$
\begin{aligned}
\mathbf{x}<em p="p">{p}^{n+1} &amp; =\mathbf{x}</em>}^{n}+\Delta t \mathbf{v<em _alpha="\alpha" p="p">{p}^{n+1} \
\Longrightarrow \frac{\partial L}{\partial \mathbf{v}</em>}^{n+1}} &amp; =\left[\frac{\partial L}{\partial \mathbf{x<em p="p">{p}^{n+1}} \frac{\partial \mathbf{x}</em>}^{n+1}}{\partial \mathbf{v<em _alpha="\alpha">{p}^{n+1}}\right]</em> \
&amp; =\Delta t \frac{\partial L}{\partial \mathbf{x}_{p \alpha}^{n+1}}
\end{aligned}
$$</p>
<p>(B, P2G) For $\mathbf{C}_{p}^{n+1}$, we have</p>
<p>$$
\begin{aligned}
\mathbf{F}<em p="p">{p}^{n+1} &amp; =\left(\mathbf{I}+\Delta t \mathbf{C}</em>}^{n+1}\right) \mathbf{F<em _alpha="\alpha" _beta="\beta" p="p">{p}^{n} \
\Longrightarrow \frac{\partial L}{\partial \mathbf{C}</em>}^{n+1}} &amp; =\left[\frac{\partial L}{\partial \mathbf{F<em p="p">{p}^{n+1}} \frac{\partial \mathbf{F}</em>}^{n+1}}{\partial \mathbf{C<em _alpha="\alpha" _beta="\beta">{p}^{n+1}}\right]</em> \
&amp; =\Delta t \sum_{\gamma} \frac{\partial L}{\partial \mathbf{F}<em _beta="\beta" _gamma="\gamma" p="p">{p \alpha \gamma}^{n+1}} \mathbf{F}</em>
\end{aligned}
$$}^{n</p>
<p>Note, the above two gradients should also include the contributions of $\frac{\partial L}{\partial \mathbf{v}<em p="p">{p}^{n}}$ and $\frac{\partial L}{\partial \mathbf{C}</em>$ respectively, with $n$ being the next time step.
(C, P2G) For $\mathbf{v}_{i}^{n}$, we have}^{n}</p>
<p>$$
\begin{aligned}
\mathbf{v}<em i="i">{p}^{n+1} &amp; =\sum</em>} N\left(\mathbf{x<em p="p">{i}-\mathbf{x}</em>}^{n}\right) \mathbf{v<em p="p">{i}^{n} \
\mathbf{C}</em>}^{n+1} &amp; =\frac{4}{\Delta x^{2}} \sum_{i} N\left(\mathbf{x<em p="p">{i}-\mathbf{x}</em>}^{n}\right) \mathbf{v<em i="i">{i}^{n}\left(\mathbf{x}</em>}-\mathbf{x<em _alpha="\alpha" i="i">{p}^{n}\right)^{T} \
\Longrightarrow \frac{\partial L}{\partial \mathbf{v}</em>}^{n}} &amp; =\left[\sum_{p} \frac{\partial L}{\partial \mathbf{v<em p="p">{p}^{n+1}} \frac{\partial \mathbf{v}</em>}^{n+1}}{\partial \mathbf{v<em p="p">{i}^{n}}+\sum</em>} \frac{\partial L}{\partial \mathbf{C<em p="p">{p}^{n+1}} \frac{\partial \mathbf{C}</em>}^{n+1}}{\partial \mathbf{v<em _alpha="\alpha">{i}^{n}}\right]</em> \
&amp; =\sum_{p}\left[\frac{\partial L}{\partial \mathbf{v}<em i="i">{p \alpha}^{n+1}} N\left(\mathbf{x}</em>}-\mathbf{x<em i="i">{p}^{n}\right)+\frac{4}{\Delta x^{2}} N\left(\mathbf{x}</em>}-\mathbf{x<em _beta="\beta">{p}^{n}\right) \sum</em>} \frac{\partial L}{\partial \mathbf{C<em _beta="\beta" i="i">{p \alpha \beta}^{n+1}}\left(\mathbf{x}</em>\right)\right]
\end{aligned}
$$}-\mathbf{x}_{p \beta</p>
<h1>IX. BackWARd GRID OPERATIONS</h1>
<p>(D, grid) For $\mathbf{p}_{i}^{n}$, we have</p>
<p>$$
\begin{aligned}
\mathbf{v}<em i="i">{i}^{n} &amp; =\frac{1}{m</em>}^{n}} \mathbf{p<em _alpha="\alpha" i="i">{i}^{n} \
\Longrightarrow \frac{\partial L}{\partial \mathbf{p}</em>}^{n}} &amp; =\left[\frac{\partial L}{\partial \mathbf{v<em p="p">{i}^{n}} \frac{\partial \mathbf{v}</em>}^{n}}{\partial \mathbf{p<em _alpha="\alpha">{i}^{n}}\right]</em> \
&amp; =\frac{\partial L}{\partial \mathbf{v}<em i="i">{i \alpha}^{n}} \frac{1}{m</em>
\end{aligned}
$$}^{n}</p>
<p>(E, grid) For $m_{i}^{n}$, we have</p>
<p>$$
\begin{aligned}
\mathbf{v}<em i="i">{i}^{n} &amp; =\frac{1}{m</em>}^{n}} \mathbf{p<em i="i">{i}^{n} \
\Longrightarrow \frac{\partial L}{\partial m</em>}^{n}} &amp; =\frac{\partial L}{\partial \mathbf{v<em i="i">{i}^{n}} \frac{\partial \mathbf{v}</em> \
&amp; =-\frac{1}{\left(m_{i}^{n}\right)^{2}} \sum_{\alpha} \mathbf{p}}^{n}}{\partial m_{i}^{n}<em _alpha="\alpha" i="i">{i \alpha}^{n} \frac{\partial L}{\partial \mathbf{v}</em> \
&amp; =-\frac{1}{m_{i}^{n}} \sum_{\alpha} \mathbf{v}}^{n}<em _alpha="\alpha" i="i">{i \alpha}^{n} \frac{\partial L}{\partial \mathbf{v}</em>
\end{aligned}
$$}^{n}</p>
<p>(F, G2P) For $\mathbf{v}_{p}^{n}$, we have</p>
<p>$$
\begin{aligned}
\mathbf{p}<em p="p">{i}^{n} &amp; =\sum</em>} N\left(\mathbf{x<em p="p">{i}-\mathbf{x}</em>}^{n}\right)\left[m_{p} \mathbf{v<em p="p">{p}^{n}+\left(-\frac{4}{\Delta x^{2}} \Delta t V</em>}^{0} \mathbf{P<em p="p">{p}^{n} \mathbf{F}</em>}^{n T}+m_{p} \mathbf{C<em i="i">{p}^{n}\right)\left(\mathbf{x}</em>}-\mathbf{x<em _alpha="\alpha" p="p">{p}^{n}\right)\right] \
\Longrightarrow \frac{\partial L}{\partial \mathbf{v}</em>}^{n}} &amp; =\left[\sum_{i} \frac{\partial L}{\partial \mathbf{p<em p="p">{p}^{n}} \frac{\partial \mathbf{p}</em>}^{n}}{\partial \mathbf{v<em _alpha="\alpha">{p}^{n}}\right]</em> \
&amp; =\sum_{i} N\left(\mathbf{x}<em p="p">{i}-\mathbf{x}</em>
\end{aligned}
$$}^{n}\right) m_{p} \frac{\partial L}{\partial \mathbf{p}_{i \alpha}^{n}</p>
<p>(G, G2P) For $\mathbf{P}_{p}^{n}$, we have</p>
<p>$$
\begin{aligned}
\mathbf{p}<em p="p">{i}^{n} &amp; =\sum</em>} N\left(\mathbf{x<em p="p">{i}-\mathbf{x}</em>}^{n}\right)\left[m_{p} \mathbf{v<em p="p">{p}^{n}+\left(-\frac{4}{\Delta x^{2}} \Delta t V</em>}^{0} \mathbf{P<em p="p">{p}^{n} \mathbf{F}</em>}^{n T}+m_{p} \mathbf{C<em i="i">{p}^{n}\right)\left(\mathbf{x}</em>}-\mathbf{x<em _alpha="\alpha" _beta="\beta" p="p">{p}^{n}\right)\right] \
\Longrightarrow \frac{\partial L}{\partial \mathbf{P}</em>}^{n}} &amp; =\left[\frac{\partial L}{\partial \mathbf{p<em i="i">{i}^{n}} \frac{\partial \mathbf{p}</em>}^{n}}{\partial \mathbf{P<em _alpha="\alpha" _beta="\beta">{p}^{n}}\right]</em> \
&amp; =-\sum_{i} N\left(\mathbf{x}<em p="p">{i}-\mathbf{x}</em>}^{n}\right) \frac{4}{\Delta x^{2}} \Delta t V_{p}^{0} \sum_{\gamma} \frac{\partial L}{\partial \mathbf{p<em p__gamma="p_{\gamma">{i \alpha}^{n}} \mathbf{F}</em>} \beta}^{n}\left(\mathbf{x<em _gamma="\gamma" p="p">{i \gamma}-\mathbf{x}</em>\right)
\end{aligned}
$$}^{n</p>
<p>(H, G2P) For $\mathbf{F}_{p}^{n}$, we have</p>
<p>$$
\begin{aligned}
\mathbf{F}<em p="p">{p}^{n+1} &amp; =\left(\mathbf{I}+\Delta t \mathbf{C}</em>}^{n+1}\right) \mathbf{F<em p="p">{p}^{n} \
\mathbf{P}</em>}^{n} &amp; =\mathbf{P<em p="p">{p}^{n}\left(\mathbf{F}</em>}^{n}\right)+\mathbf{F<em _alpha="\alpha" p="p">{p} \boldsymbol{\sigma}</em> \
\mathbf{p}}^{n<em p="p">{i}^{n} &amp; =\sum</em>} N\left(\mathbf{x<em p="p">{i}-\mathbf{x}</em>}^{n}\right)\left[m_{p} \mathbf{v<em p="p">{p}^{n}+\left(-\frac{4}{\Delta x^{2}} \Delta t V</em>}^{0} \mathbf{P<em p="p">{p}^{n} \mathbf{F}</em>}^{n T}+m_{p} \mathbf{C<em i="i">{p}^{n}\right)\left(\mathbf{x}</em>}-\mathbf{x<em _alpha="\alpha" _beta="\beta" p="p">{p}^{n}\right)\right] \
\Longrightarrow \frac{\partial L}{\partial \mathbf{F}</em>}^{n}} &amp; =\left[\frac{\partial L}{\partial \mathbf{F<em p="p">{p}^{n+1}} \frac{\partial \mathbf{F}</em>}^{n+1}}{\partial \mathbf{F<em p="p">{p}^{n}}+\frac{\partial L}{\partial \mathbf{P}</em>}^{n}} \frac{\partial \mathbf{P<em p="p">{p}^{n}}{\partial \mathbf{F}</em>}^{n}}+\frac{\partial L}{\partial \mathbf{p<em i="i">{i}^{n}} \frac{\partial \mathbf{p}</em>}^{n}}{\partial \mathbf{F<em _alpha="\alpha" _beta="\beta">{p}^{n}}\right]</em> \
&amp; =\sum_{\gamma} \frac{\partial L}{\partial \mathbf{F}<em _alpha="\alpha" _gamma="\gamma">{p \gamma \beta}^{n+1}}\left(\mathbf{I}</em>}+\Delta t \mathbf{C<em _gamma="\gamma">{p \gamma \alpha}^{n+1}\right)+\sum</em>} \sum_{\eta} \frac{\partial L}{\partial \mathbf{P<em p="p">{p \gamma \eta}} \frac{\partial^{2} \Psi</em>}}{\partial \mathbf{F<em _alpha="\alpha" _beta="\beta" p="p">{p \gamma \eta}^{n} \partial \mathbf{F}</em>}^{n}}+\sum_{\gamma} \frac{\partial L}{\partial \mathbf{P<em _alpha="\alpha" _beta="\beta" _gamma="\gamma" p="p">{p \alpha \gamma}^{n}} \boldsymbol{\sigma}</em> \
&amp; +\sum_{i}-N\left(\mathbf{x}<em p="p">{i}-\mathbf{x}</em>}^{n}\right) \sum_{\gamma} \frac{\partial L}{\partial \mathbf{p<em p="p">{i \gamma}^{n}} \frac{4}{\Delta x^{2}} \Delta t V</em>}^{0} \mathbf{P<em _alpha="\alpha" i="i">{p \gamma \beta}^{n}\left(\mathbf{x}</em>\right)
\end{aligned}
$$}-\mathbf{x}_{p \alpha}^{n</p>
<p>(I, G2P) For $\mathbf{C}_{p}^{n}$, we have</p>
<p>$$
\begin{aligned}
\mathbf{p}<em p="p">{i}^{n} &amp; =\sum</em>} N\left(\mathbf{x<em p="p">{i}-\mathbf{x}</em>}^{n}\right)\left[m_{p} \mathbf{v<em p="p">{p}^{n}+\left(-\frac{4}{\Delta x^{2}} \Delta t V</em>}^{0} \mathbf{P<em p="p">{p}^{n} \mathbf{F}</em>}^{n T}+m_{p} \mathbf{C<em i="i">{p}^{n}\right)\left(\mathbf{x}</em>}-\mathbf{x<em _alpha="\alpha" _beta="\beta" p="p">{p}^{n}\right)\right] \
\Longrightarrow \frac{\partial L}{\partial \mathbf{C}</em>}^{n}} &amp; =\left[\sum_{i} \frac{\partial L}{\partial \mathbf{p<em i="i">{i}^{n}} \frac{\partial \mathbf{p}</em>}^{n}}{\partial \mathbf{C<em _alpha="\alpha" _beta="\beta">{p}^{n}}\right]</em> \
&amp; =\sum_{i} N\left(\mathbf{x}<em p="p">{i}-\mathbf{x}</em>}^{n}\right) \frac{\partial L}{\partial \mathbf{p<em p="p">{i \alpha}^{n}} m</em>}\left(\mathbf{x<em _beta="\beta" p="p">{i \beta}-\mathbf{x}</em>\right)
\end{aligned}
$$}^{n</p>
<p>(J, G2P) For $\mathbf{x}_{p}^{n}$, we have</p>
<p>$$
\begin{aligned}
\mathbf{x}<em p="p">{p}^{n+1} &amp; =\mathbf{x}</em>}^{n}+\Delta t \mathbf{v<em p="p">{p}^{n+1} \
\mathbf{v}</em>}^{n+1} &amp; =\sum_{i} N\left(\mathbf{x<em p="p">{i}-\mathbf{x}</em>}^{n}\right) \mathbf{v<em p="p">{i}^{n} \
\mathbf{C}</em>}^{n+1} &amp; =\frac{4}{\Delta x^{2}} \sum_{i} N\left(\mathbf{x<em p="p">{i}-\mathbf{x}</em>}^{n}\right) \mathbf{v<em i="i">{i}^{n}\left(\mathbf{x}</em>}-\mathbf{x<em i="i">{p}^{n}\right)^{T} \
\mathbf{p}</em>}^{n} &amp; =\sum_{p} N\left(\mathbf{x<em p="p">{i}-\mathbf{x}</em>}^{n}\right)\left[m_{p} \mathbf{v<em p="p">{p}^{n}+\left(-\frac{4}{\Delta x^{2}} \Delta t V</em>}^{0} \mathbf{P<em p="p">{p}^{n} \mathbf{F}</em>}^{n T}+m_{p} \mathbf{C<em i="i">{p}^{n}\right)\left(\mathbf{x}</em>}-\mathbf{x<em i="i">{p}^{n}\right)\right] \
m</em>}^{n} &amp; =\sum_{p} N\left(\mathbf{x<em p="p">{i}-\mathbf{x}</em> \
\mathbf{G}}^{n}\right) m_{p<em p="p">{p} &amp; :=(-\frac{4}{\Delta x^{2}} V</em>}^{0} \Delta t \mathbf{P<em p="p">{p}^{n} \mathbf{F}</em>}^{n T}+m_{p} \mathbf{C<em _alpha="\alpha" p="p">{p}^{n}) \
\Longrightarrow &amp; \
\frac{\partial L}{\partial \mathbf{x}</em>}^{n}}= &amp; {\left[\frac{\partial L}{\partial \mathbf{x<em p="p">{p}^{n+1}} \frac{\partial \mathbf{x}</em>}^{n+1}}{\partial \mathbf{x<em p="p">{p}^{n}}+\frac{\partial L}{\partial \mathbf{v}</em>}^{n+1}} \frac{\partial \mathbf{v<em p="p">{p}^{n+1}}{\partial \mathbf{x}</em>}^{n}}+\frac{\partial L}{\partial \mathbf{C<em p="p">{p}^{n+1}} \frac{\partial \mathbf{C}</em>}^{n+1}}{\partial \mathbf{x<em i="i">{p}^{n}}+\frac{\partial L}{\partial \mathbf{p}</em>}^{n}} \frac{\partial \mathbf{p<em p="p">{i}^{n}}{\partial \mathbf{x}</em>}^{n}}+\frac{\partial L}{\partial m_{i}^{n}} \frac{\partial m_{i}^{n}}{\partial \mathbf{x<em _alpha="\alpha">{p}^{n}}\right]</em> \
= &amp; \frac{\partial L}{\partial \mathbf{x}} <em i="i">{p \alpha}^{n+1}} \
&amp; +\sum</em>} \sum_{\beta} \frac{\partial L}{\partial \mathbf{v<em i="i">{p \beta}^{n+1}} \frac{\partial N\left(\mathbf{x}</em>}-\mathbf{x<em _alpha="\alpha" i="i">{p}^{n}\right)}{\partial \mathbf{x}</em>}} \mathbf{v<em i="i">{i \beta}^{n} \
&amp; +\sum</em>} \sum_{\beta} \frac{4}{\Delta x^{2}}\left{-\frac{\partial L}{\partial \mathbf{C<em i="i">{p \beta \alpha}^{n+1}} N\left(\mathbf{x}</em>}-\mathbf{x<em _beta="\beta" i="i">{p}^{n}\right) \mathbf{v}</em>}+\sum_{\gamma} \frac{\partial L}{\partial \mathbf{C<em i="i">{p \beta \gamma}^{n+1}} \frac{\partial N\left(\mathbf{x}</em>}-\mathbf{x<em _alpha="\alpha" i="i">{p}^{n}\right)}{\partial \mathbf{x}</em>}} \mathbf{v<em _gamma="\gamma" i="i">{i \beta}\left(\mathbf{x}</em>}-\mathbf{x<em i="i">{p \gamma}\right)\right} \
&amp; +\sum</em>} \sum_{\beta} \frac{\partial L}{\partial \mathbf{p<em i="i">{i \beta}^{n}}\left[\frac{\partial N\left(\mathbf{x}</em>}-\mathbf{x<em _alpha="\alpha" i="i">{p}^{n}\right)}{\partial \mathbf{x}</em>}}\left(m_{p} \mathbf{v<em p="p">{p \beta}^{n}+\left[\mathbf{G}</em>}\left(\mathbf{x<em p="p">{i}-\mathbf{x}</em>\right)\right]}^{n<em i="i">{\beta}\right)-N\left(\mathbf{x}</em>}-\mathbf{x<em _alpha="\alpha" _beta="\beta" p="p">{p}^{n}\right) \mathbf{G}</em>\right] \
&amp; +m_{p} \sum_{i} \frac{\partial L}{\partial m_{i}^{n}} \frac{\partial N\left(\mathbf{x}<em p="p">{i}-\mathbf{x}</em>
\end{aligned}
$$}^{n}\right)}{\partial \mathbf{x}_{i \alpha}</p>
<p>(K, G2P) For $\boldsymbol{\sigma}_{p a}^{n}$, we have</p>
<p>$$
\begin{aligned}
\mathbf{P}<em p="p">{p}^{n} &amp; =\mathbf{P}</em>}^{n}\left(\mathbf{F<em p="p">{p}^{n}\right)+\mathbf{F}</em>} \boldsymbol{\sigma<em _alpha="\alpha" _beta="\beta" a="a" p="p">{p a}^{n} \
\Longrightarrow \frac{\partial L}{\partial \boldsymbol{\sigma}</em>}^{n}} &amp; =\left[\frac{\partial L}{\partial \mathbf{P<em p="p">{p}^{n}} \frac{\partial \mathbf{P}</em>}^{n}}{\partial \boldsymbol{\sigma<em _alpha="\alpha" _beta="\beta">{p \alpha}^{n}}\right]</em> \
&amp; =\sum_{\gamma} \frac{\partial L}{\partial \mathbf{P}<em _alpha="\alpha" _gamma="\gamma" p="p">{p \gamma \beta}^{n+1}} \mathbf{F}</em>
\end{aligned}
$$}^{n</p>
<h1>XI. Friction Projection Gradients</h1>
<p>When there are boundary conditions:
$(\mathrm{L}, \operatorname{grid})$ For $\mathbf{v}_{i}^{\mathrm{n}}$, we have</p>
<p>$$
\begin{aligned}
l_{i \mathbf{n}} &amp; =\sum_{\alpha} \mathbf{v}<em _alpha="\alpha" i="i">{i \alpha} \mathbf{n}</em> \
\mathbf{v}<em i="i">{i \mathbf{t}} &amp; =\mathbf{v}</em>}-l_{i \mathbf{n}} \mathbf{n<em _mathbf_t="\mathbf{t" i="i">{i} \
l</em>}} &amp; =\sqrt{\sum_{\alpha} \mathbf{v<em _mathbf_t="\mathbf{t" i="i">{i \mathbf{t} \alpha}^{2}+\varepsilon} \
\dot{\mathbf{v}}</em>}} &amp; =\frac{1}{l_{i \mathbf{t}}} \mathbf{v<em _mathbf_t="\mathbf{t" i="i">{i \mathbf{t}} \
l</em>^{}<em>} &amp; =\max \left{l_{i \mathbf{t}}+c_{i} \min \left{l_{i \mathbf{n}}, 0\right}, 0\right} \
\mathbf{v}_{i}^{</em>} &amp; =l_{i \mathbf{t}}^{<em>} \dot{\mathbf{v}}<em _mathbf_n="\mathbf{n" i="i">{i \mathbf{t}}+\max \left{l</em>}}, 0\right} \mathbf{n<em _mathbf_t="\mathbf{t" i="i">{i} \
H(x) &amp; :=[x \geq 0] \
R &amp; :=l</em>\right} \
\Longrightarrow \frac{\partial L}{\partial l_{i \mathbf{t}}^{}}+c_{i} \min \left{l_{i \mathbf{n}, 0</em>}} &amp; =\sum_{\alpha} \frac{\partial L}{\partial \mathbf{v}<em _mathbf_t="\mathbf{t" i="i">{i \alpha}^{<em>}} \dot{\mathbf{v}}<em _mathbf_t="\mathbf{t" i="i">{i \mathbf{t} \alpha} \
\frac{\partial L}{\partial \dot{\mathbf{v}}</em>^{}}} &amp; =\frac{\partial L}{\partial \mathbf{v}_{i \alpha</em>}} l</em>^{}<em>} \
\frac{\partial L}{\partial l_{i \mathbf{t}}} &amp; =-\frac{1}{l_{i \mathbf{t}}^{</em>}} \sum_{\alpha} \mathbf{v}<em _mathbf_t="\mathbf{t" i="i">{i \mathbf{t} \alpha} \frac{\partial L}{\partial \dot{\mathbf{v}}</em>^{} \alpha}}+\frac{\partial L}{\partial l_{i \mathbf{t}<em>}} H(R) \
\frac{\partial L}{\partial \mathbf{v}<em _mathbf_t="\mathbf{t" i="i">{i \mathbf{t} \alpha}} &amp; =\frac{\mathbf{v}</em>} \alpha}}{l_{i \mathbf{t}}} \frac{\partial L}{\partial l_{i \mathbf{t}}}+\frac{1}{l_{i \mathbf{t}}} \frac{\partial L}{\partial \dot{\mathbf{v}<em _mathbf_t="\mathbf{t" i="i">{i \mathbf{t} \alpha}} \
&amp; =\frac{1}{l</em>}}}\left[\frac{\partial L}{\partial l_{i \mathbf{t}}} \mathbf{v<em _mathbf_t="\mathbf{t" i="i">{i \mathbf{t} \alpha}+\frac{\partial L}{\partial \dot{\mathbf{v}}</em>\right] \
\frac{\partial L}{\partial l_{i \mathbf{n}}} &amp; =-\left[\sum_{\alpha} \frac{\partial L}{\partial \mathbf{v}} \alpha}<em _alpha="\alpha" i="i">{i \mathbf{t} \alpha}} \mathbf{n}</em>^{}\right]+\frac{\partial L}{\partial l_{i \mathbf{t}</em>}} H(R) c_{i} H\left(-l_{i \mathbf{n}}\right)+\sum_{\alpha} H\left(l_{i \mathbf{n}}\right) \mathbf{n}<em _alpha="\alpha" i="i">{i \alpha} \frac{\partial L}{\partial \mathbf{v}</em> \
\frac{\partial L}{\partial \mathbf{v}}^{*}<em _mathbf_n="\mathbf{n" i="i">{i \alpha}} &amp; =\frac{\partial L}{\partial l</em>}}} \mathbf{n<em _mathbf_t="\mathbf{t" i="i">{i \alpha}+\frac{\partial L}{\partial \mathbf{v}</em>
\end{aligned}
$$} \alpha}</p>
<h1>REFERENCES</h1>
<p>[1] E. Todorov, T. Erez, and Y. Tassa, "Mujoco: A physics engine for model-based control," in IROS. IEEE, 2012, pp. 5026-5033.
[2] T. Erez, Y. Tassa, and E. Todorov, "Simulation tools for model-based robotics: Comparison of bullet, havok, mujoco, ode and physx," in ICRA. IEEE, 2015, pp. 4397-4404.
[3] M. B. Chang, T. Ullman, A. Torralba, and J. B. Tenenbaum, "A compositional object-based approach to learning physical dynamics," ICLR 2016, 2016.
[4] D. Mrowca, C. Zhuang, E. Wang, N. Haber, L. Fei-Fei, J. B. Tenenbaum, and D. L. Yamins, "Flexible neural representation for physics prediction," arXiv:1806.08047, 2018.
[5] J. Degrave, M. Hermans, J. Dambre et al., "A differentiable physics engine for deep learning in robotics," arXiv preprint arXiv:1611.01652, 2016.
[6] R. Tedrake and the Drake Development Team, "Drake: A planning, control, and analysis toolbox for nonlinear dynamical systems," 2016. [Online]. Available: https://drake.mit.edu
[7] M. Frigerio, J. Buchli, D. G. Caldwell, and C. Semini, "RobCoGen: a code generator for efficient kinematics and dynamics of articulated robots, based on Domain Specific Languages," vol. 7, no. 1, pp. 36-54, 2016.
[8] Y. Hu, Y. Fang, Z. Ge, Z. Qu, Y. Zhu, A. Pradhana, and C. Jiang, "A moving least squares material point method with displacement discontinuity and two-way rigid body coupling," ACM TOG, vol. 37, no. 4, p. 150, 2018.
[9] D. Sulsky, S.-J. Zhou, and H. L. Schreyer, "Application of a particle-in-cell method to solid mechanics," Computer physics communications, vol. 87, no. 1-2, pp. 236-252, 1995.
[10] C. Jiang, C. Schroeder, J. Teran, A. Stomakhin, and A. Selle, "The material point method for simulating continuum materials," in ACM SIGGRAPH 2016 Courses. ACM, 2016, p. 24.
[11] A. Stomakhin, C. Schroeder, L. Chai, J. Teran, and A. Selle, "A material point method for snow simulation," ACM Transactions on Graphics (TOG), vol. 32, no. 4, p. 102, 2013.
[12] J. Gaume, T. Gast, J. Teran, A. van Herwijnen, and C. Jiang, "Dynamic anticrack propagation in snow," Nature communications, vol. 9, no. 1, p. 3047, 2018.
[13] G. Klär, T. Gast, A. Pradhana, C. Fu, C. Schroeder, C. Jiang, and J. Teran, "Drucker-prager elastoplasticity for sand animation," ACM Transactions on Graphics (TOG), vol. 35, no. 4, p. 103, 2016.
[14] G. Daviet and F. Bertails-Descoubes, "A semi-implicit material point method for the continuum simulation of granular materials," ACM Transactions on Graphics (TOG), vol. 35, no. 4, p. 102, 2016.
[15] D. Ram, T. Gast, C. Jiang, C. Schroeder, A. Stomakhin, J. Teran, and P. Kavehpour, "A material point method for viscoelastic fluids, foams and sponges," in Proceedings of the 14th ACM SIGGRAPH/Eurographics Symposium on Computer Animation. ACM, 2015, pp. 157-163.
[16] C. Jiang, T. Gast, and J. Teran, "Anisotropic elastoplasticity for cloth, knit and hair frictional contact," ACM Transactions on Graphics (TOG), vol. 36, no. 4, p. 152, 2017.
[17] Q. Guo, X. Han, C. Fu, T. Gast, R. Tamstorf, and J. Teran, "A material point method for thin shells with frictional contact," ACM Transactions on Graphics (TOG), vol. 37, no. 4, p. 147, 2018.
[18] M. Gao, A. Pradhana, X. Han, Q. Guo, G. Kot, E. Sifakis, and C. Jiang, "Animating fluid sediment mixture in particle-laden flows," ACM Trans. Graph., vol. 37, no. 4, pp. 149:1-149:11, Jul. 2018.
[19] A. P. Tampubolon, T. Gast, G. Klär, C. Fu, J. Teran, C. Jiang, and K. Museth, "Multi-species simulation of porous sand and water mixtures," ACM Trans. Graph., vol. 36, no. 4, pp. 105:1-105:11, Jul. 2017.
[20] M. Gao, A. P. Tampubolon, C. Jiang, and E. Sifakis, "An adaptive generalized interpolation material point method for simulating elastoplastic materials," ACM Trans. Graph., vol. 36, no. 6, pp. 223:1-223:12, Nov. 2017.
[21] M. Gao, Wang, K. Wu, A. Pradhana-Tampubolon, E. Sifakis, Y. Cem, and C. Jiang, "Gpu optimization of material point methods," ACM Transactions on Graphics (TOG), vol. 32, no. 4, p. 102, 2013.
[22] P. W. Battaglia, R. Pascanu, M. Lai, D. Rezende, and K. Kavukcuoglu, "Interaction networks for learning about objects, relations and physics," in NIPS, 2016.
[23] A. Sanchez-Gonzalez, N. Heess, J. T. Springenberg, J. Merel, M. Riedmiller, R. Hadsell, and P. Battaglia, "Graph networks as learnable physics engines for inference and control," in ICML, 2018.
[24] F. de Avila Belbute-Peres, K. A. Smith, K. Allen, J. B. Tenenbaum, and J. Z. Kolter, "End-to-end differentiable physics for learning and control," in Neural Information Processing Systems, 2018.
[25] M. Toussaint, K. R. Allen, K. A. Smith, and J. B. Tenenbaum, "Differentiable physics and stable modes for tool-use and manipulation planning," in RSS, 2018.
[26] C. Schenck and D. Fox, "Spnets: Differentiable fluid dynamics for deep neural networks," arXiv:1806.06094, 2018.
[27] M. Macklin and M. Müller, "Position based fluids," ACM Transactions on Graphics (TOG), vol. 32, no. 4, p. 104, 2013.
[28] C. Jiang, C. Schroeder, A. Selle, J. Teran, and A. Stomakhin, "The affine particle-in-cell method," ACM Trans Graph, vol. 34, no. 4, pp. 51:1-51:10, 2015.
[29] S. Hara, T. Zama, W. Takashima, and K. Kaneto, "Artificial muscles based on polypyrrole actuators with large strain and stress induced electrically," Polymer journal, vol. 36, no. 2, p. 151, 2004.
[30] Y. Hu, "Taichi: An open-source computer graphics library," arXiv preprint arXiv:1804.09293, 2018.
[31] M. Macklin, M. Müller, N. Chentanez, and T.-Y. Kim, "Unified particle physics for real-time applications," ACM Transactions on Graphics (TOG), vol. 33, no. 4, p. 153, 2014.
[32] J. Schulman, F. Wolski, P. Dhariwal, A. Radford, and O. Klimov, "Proximal policy optimization algorithms," arXiv:1707.06347, 2017.
[33] S. G. Johnson, "The nlopt nonlinear-optimization package," 2014.
[34] Y. Fang, Y. Hu, S.-m. Hu, and C. Jiang, "A temporally adaptive material point method with regional time stepping," Computer graphics forum, vol. 37, 2018.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{1}$ Y. Hu, A. Spielberg, J. B. Tenenbaum, W. T. Freeman, J. Wu, D. Rus, and W. Matusik are with Computer Science and Artificial Intelligence Laboratory, Massachusetts Institute of Technology, Cambridge, MA, USA
${ }^{2}$ J. Liu is with Institute for Interdisciplinary Information Science, Tsinghua University, Beijing, China</p>
<ul>
<li>Equally contributed.</li>
</ul>
<p><a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:1">
<p>*Or 乾坤，literally "everything between the sky and the earth."&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>