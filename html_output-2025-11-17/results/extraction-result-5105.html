<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-5105 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-5105</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-5105</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-107.html">extraction-schema-107</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models being evaluated or improved for strict logical reasoning, including details of the models, logical reasoning tasks or benchmarks, methods or approaches used, performance results, limitations, and comparisons.</div>
                <p><strong>Paper ID:</strong> paper-87c45a908537ffe1d2ab71a5d609bd7b4efa4fe1</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/87c45a908537ffe1d2ab71a5d609bd7b4efa4fe1" target="_blank">ProofWriter: Generating Implications, Proofs, and Abductive Statements over Natural Language</a></p>
                <p><strong>Paper Venue:</strong> Findings</p>
                <p><strong>Paper TL;DR:</strong> A generative model, called ProofWriter, can reliably generate both implications of a theory and the natural language proof(s) that support them, and iterating a 1-step implication generator results in proofs that are highly reliable, and represent actual model decisions (rather than post-hoc rationalizations).</p>
                <p><strong>Paper Abstract:</strong> Transformers have been shown to emulate logical deduction over natural language theories (logical rules expressed in natural language), reliably assigning true/false labels to candidate implications. However, their ability to generate implications of a theory has not yet been demonstrated, and methods for reconstructing proofs of answers are imperfect. In this work we show that a generative model, called ProofWriter, can reliably generate both implications of a theory and the natural language proof(s) that support them. In particular, iterating a 1-step implication generator results in proofs that are highly reliable, and represent actual model decisions (rather than post-hoc rationalizations). On the RuleTaker dataset, the accuracy of ProofWriter's proofs exceed previous methods by +9% absolute, and in a way that generalizes to proof depths unseen in training and on out-of-domain problems. We also show that generative techniques can perform a type of abduction with high precision: Given a theory and an unprovable conclusion, identify a missing fact that allows the conclusion to be proved, along with a proof. These results significantly improve the viability of neural methods for systematically reasoning over natural language.</p>
                <p><strong>Cost:</strong> 0.017</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e5105.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e5105.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models being evaluated or improved for strict logical reasoning, including details of the models, logical reasoning tasks or benchmarks, methods or approaches used, performance results, limitations, and comparisons.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>ProofWriter</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>ProofWriter (generative proof/implication/abduction system)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A generative system built on a pretrained T5 transformer that (1) generates True/False/Unknown answers, (2) generates human-readable proofs as directed acyclic graphs linearized for seq2seq output, (3) enumerates all implications of a natural-language theory, and (4) performs single-fact abduction by proposing missing facts that make a query provable.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>ProofWriter (finetuned T5)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>A text-to-text generative system implemented by fine-tuning the T5 transformer (primarily T5-11B) to output answers plus a linearized proof representation; supports two generation strategies: All-At-Once (generate full proof+answer) and Iterative (generate 1-step implications repeatedly and assemble proofs). Uses special linear encoding (Polish notation, special tokens) to represent proofs and identifiers for facts/rules/conc/naf.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>11B</td>
                        </tr>
                        <tr>
                            <td><strong>logical_reasoning_task</strong></td>
                            <td>Proof generation, implication enumeration, and single-fact abduction on RuleTaker-derived benchmarks (D0-D5, CWA and OWA variants), Birds-Electricity, and ParaRules.</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Deductive reasoning over natural-language theories (Datalog-style semantics under CWA or OWA): decide truth of queries with proofs (directed acyclic graphs of facts/rules), enumerate all implications that follow from a theory, and abduce single missing facts that, when added, make an otherwise-unprovable query provable.</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_approach</strong></td>
                            <td>Fine-tune T5 to generate proofs and implications. Two main approaches: (1) All-At-Once: directly generate full proof+answer for C,Q -> A,P; (2) Iterative: train to generate single 1-step implications with 1-step proofs (C -> implication + 1-step-proof) and at test time apply iteratively (forward-chaining), adding derived implications into the context until saturation and assembling full proofs from 1-step fragments. Proofs encoded in linearized Polish notation; abduction implemented by enumerating candidate formal facts in the underlying formalization then training the generator to output the missing fact(s) in NL.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>State-of-the-art proof generation results on RuleTaker-derived datasets: e.g., on D5(orig) ProofWriter All-At-Once produced proof-correctness 96.2% vs PRover 87.1% (≈ +9% absolute); answer accuracy ≈99.2–99.3%. Iterative ProofWriter shows strong OOD transfer and robust generalization: e.g., on hand-authored Birds-Electricity rulesets Iterative proof correctness ≈97.0% (substantially higher than prior baseline). Implication enumeration: Iterative achieves F1≈99.5 on D5-Enum (and high exact-set accuracy), All-At-Once degrades on deeper/unseen depths (e.g., D5). Abduction (single-fact) achieves F1≈97.3 and exact-match accuracy ≈93–94% on D3-Ab/D5-Ab IID tests, but lower zero-shot on more complex Electricity rulebases (down to mid-60s F1 for hardest). Verification: All-At-Once proofs within training depths are highly verifiable (~95–99%), but verifiability drops for proofs deeper than seen in training; Iterative proofs are by-construction verifiable (they come from actual 1-step inferences).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>All-At-Once approach does not generalize well to proofs deeper than those seen in training; some All-At-Once proofs may be post-hoc and not reflect model's internal inference (though individual steps can be verified via QA). Iterative approach is computationally inefficient (exhaustive forward-chaining), unguided, can blow past transformer input token limits (default 512 tokens) as facts accumulate, and may require retrieval/guidance for larger theories. Abduction generalizes imperfectly OOD (performance degrades on more complex hand-authored Electricity datasets). Methods were evaluated on synthetic / templated NL plus some paraphrased and small hand-authored rulebases; scalability to very large, naturally written KBs is not shown. Domain sizes are small so exhaustive enumeration (for abduction training labels) is feasible; that might not scale.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison</strong></td>
                            <td>Compared against PRover (classification+ILP assembly) and other prior methods: ProofWriter (generative) outperforms PRover on proof correctness (≈ +9% absolute on D5(orig)); Iterative ProofWriter generalizes better OOD and to deeper proofs than All-At-Once and PRover. T5-11B base is compared to T5-large (see ablation). Also discussed relative to RuleTaker (prior transformer-as-reasoner baseline) and LeapOfThought (combining implicit and explicit knowledge): ProofWriter can materialize implicit facts for LeapOfThought outputs via abduction+proof generation.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_analysis_results</strong></td>
                            <td>Model-size and training-regime analyses: T5-11B consistently outperforms T5-large on proof correctness, especially at higher depths (Appendix C/Table14-15). Training depth matters: models trained on shallower data (D3) struggle to generate/verifiably correct proofs at deeper depths (D5) in All-At-Once mode, while Iterative models trained on 1-step examples generalize to unseen depths. Verification experiments (Table 6) quantify that All-At-Once proofs within seen depths are verifiable at ≈93–99% but verifiability drops for unseen depths (very low for deepest levels when trained only to depth 3), while Iterative proofs are always verifiable by construction. Enumeration & abduction metrics (F1, exact-match accuracy) show Iterative > All-At-Once for unordered multi-output tasks and better robustness to OOD conclusion generation.</td>
                        </tr>
                        <tr>
                            <td><strong>notes</strong></td>
                            <td>Implementation details: primarily fine-tuned T5-11B (40k steps, batch size 8); All-At-Once trained on full proof outputs, Iterative trained on aggregated 1-step examples constructed from gold proofs; proof linearization uses special tokens and identifier schemes (sentX, concX, nafX). Datasets and code released at allenai.org/data/proofwriter.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'ProofWriter: Generating Implications, Proofs, and Abductive Statements over Natural Language', 'publication_date_yy_mm': '2020-12'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e5105.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e5105.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models being evaluated or improved for strict logical reasoning, including details of the models, logical reasoning tasks or benchmarks, methods or approaches used, performance results, limitations, and comparisons.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>T5-11B</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>T5-11B (Text-to-Text Transfer Transformer, 11B parameters)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A large pretrained seq2seq text-to-text transformer used as the base model for ProofWriter; fine-tuned to generate answers, proofs, implications, and abductive facts in natural language.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Exploring the limits of transfer learning with a unified text-to-text transformer</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>T5-11B</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Encoder-decoder Transformer pre-trained in a unified text-to-text framework (T5); here fine-tuned for proof generation tasks and used as the backbone for ProofWriter experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>11B</td>
                        </tr>
                        <tr>
                            <td><strong>logical_reasoning_task</strong></td>
                            <td>Proof generation, implication enumeration, abduction on RuleTaker-derived datasets (D0-D5, CWA/OWA), Birds-Electricity, ParaRules.</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Same as for ProofWriter: Datalog-style deductive reasoning over NL theories, producing proofs and enumerating implications, plus abductive identification of missing facts.</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_approach</strong></td>
                            <td>Fine-tuning T5-11B as a seq2seq generator to produce linearized proofs and implications; experimented with All-At-Once and Iterative training regimes.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>Primary backbone achieving the best-reported numbers in the paper: higher proof correctness than T5-large, e.g., Iterative ProofWriter on D5 achieves proof correctness in the mid-90s% and outperforms baselines; verification and generalization experiments reported using T5-11B show superior robustness to unseen depths compared to All-At-Once and to smaller models.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Large model but still subject to input token limits (512 tokens default) when using Iterative forward-chaining; computation and TPU resources required (authors acknowledge Google TPUs). Performance still falls for proofs deeper than training for All-At-Once regime.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison</strong></td>
                            <td>Compared directly to T5-large in ablation: T5-11B yields systematically better proof correctness and robustness (Appendix C). When used in iterative regime, it outperforms PRover and All-At-Once variants.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_analysis_results</strong></td>
                            <td>Appendix C/Tables 14–15 show T5-11B > T5-large on proof correctness (especially at higher depths), while T5-large remains competitive on many answer-accuracy metrics.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'ProofWriter: Generating Implications, Proofs, and Abductive Statements over Natural Language', 'publication_date_yy_mm': '2020-12'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e5105.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e5105.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models being evaluated or improved for strict logical reasoning, including details of the models, logical reasoning tasks or benchmarks, methods or approaches used, performance results, limitations, and comparisons.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>T5-large</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>T5-large (Text-to-Text Transfer Transformer, ~770M parameters)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A mid-sized T5 model variant evaluated as an ablation to measure the effect of model size on proof generation and reasoning; fine-tuned with the same ProofWriter methods.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Exploring the limits of transfer learning with a unified text-to-text transformer</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>T5-large</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>A 770M-parameter variant of the T5 family (encoder-decoder text-to-text transformer) used to test impact of parameter count on reasoning tasks when fine-tuned with ProofWriter formats.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>770M</td>
                        </tr>
                        <tr>
                            <td><strong>logical_reasoning_task</strong></td>
                            <td>Same RuleTaker-derived proof generation, implication enumeration, and abduction tasks used in the paper.</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Datalog-style deductive reasoning over NL theories for QA-with-proof, implication enumeration, and abduction.</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_approach</strong></td>
                            <td>Same two regimes (All-At-Once and Iterative) as used with T5-11B, fine-tuned on the same datasets for comparison.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>Generally slightly worse than T5-11B on proof-correctness metrics, especially at higher proof depths: e.g., All-At-Once and Iterative evaluations (Appendix C) show reductions in proof correctness for deeper proofs relative to 11B, though answer-accuracy differences can be small. Concrete example: in some settings T5-large proof correctness at deep depths drops substantially compared to T5-11B (see Tables 14–15).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Lower proof generation accuracy at deeper reasoning depths compared to the 11B model; same token-limit and forward-chaining efficiency issues when using Iterative approach.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison</strong></td>
                            <td>Direct ablation against T5-11B: T5-11B systematically slightly better, supporting that model size improves complex proof generation and generalization to unseen depths.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_analysis_results</strong></td>
                            <td>Tables 14–15 quantify the effect: T5-large is competitive on many answer-accuracy metrics but lags on proof-correctness, particularly at high depths and in All-At-Once generalization tests.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'ProofWriter: Generating Implications, Proofs, and Abductive Statements over Natural Language', 'publication_date_yy_mm': '2020-12'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e5105.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e5105.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models being evaluated or improved for strict logical reasoning, including details of the models, logical reasoning tasks or benchmarks, methods or approaches used, performance results, limitations, and comparisons.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>PRover</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>PRover: Proof generation for interpretable reasoning over rules</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A prior state-of-the-art system that assembles proofs by first classifying which facts/rules/connections belong in the proof tree and then using an ILP module to enforce consistency constraints; treated as the primary baseline for proof generation over the RuleTaker-style data.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>PRover: Proof generation for interpretable reasoning over rules</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>PRover</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>A classifier-based approach that predicts nodes and edges of a proof graph and uses Integer Linear Programming (ILP) to enforce global consistency and assemble final proof trees; not a generative proof output model.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>logical_reasoning_task</strong></td>
                            <td>Proof generation over RuleTaker-derived datasets (D5 and others); proof assembly for QA over natural-language rules/facts.</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Produce interpretable proofs (graphs) supporting True/False QA answers for NL-expressed rules/facts; earlier SOTA for proof production.</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_approach</strong></td>
                            <td>Classify which context sentences (facts/rules) and intermediate conclusions belong in a proof, predict edges, then solve an ILP to assemble a consistent proof tree.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>Prior baseline: on D5(orig) PRover proof correctness ~87.1% (Table 2), answer accuracy ~99.3%; ProofWriter generative approach improved proof correctness by ≈+9% absolute over PRover on that dataset. On Birds-Electricity and ParaRules, ProofWriter variants improve over PRover (detailed per-dataset numbers in paper).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>PRover's proofs were sometimes imperfect and could be post-hoc (not necessarily reflecting model internal decisions); relies on ILP assembler and separate classification steps, adding complexity and heuristics; less robust OOD and to deeper proofs than Iterative ProofWriter.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison</strong></td>
                            <td>Direct baseline: ProofWriter (All-At-Once and Iterative) outperforms PRover on proof correctness across multiple datasets; Iterative ProofWriter shows substantially better OOD generalization and proof verifiability.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_analysis_results</strong></td>
                            <td>The paper reports strict FA (Full Accuracy) metric comparisons using the same scoring as PRover and shows quantitative improvements; no internal ablation of PRover is performed here (PRover cited as prior work).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'ProofWriter: Generating Implications, Proofs, and Abductive Statements over Natural Language', 'publication_date_yy_mm': '2020-12'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e5105.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e5105.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models being evaluated or improved for strict logical reasoning, including details of the models, logical reasoning tasks or benchmarks, methods or approaches used, performance results, limitations, and comparisons.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>RuleTaker</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>RuleTaker (benchmarks D0-D5, CWA/OWA variants)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A suite of synthetic natural-language logical reasoning datasets (D0, D1, D2, D3, D5) originally introduced to test transformers' ability to emulate deductive reasoning; used as the primary benchmark for evaluating ProofWriter.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Transformers as soft reasoners over language</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>RuleTaker datasets</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Collections of theories (facts+rules) and associated queries expressed in templated English, generated from underlying formal Datalog programs; versions include closed-world (CWA) and open-world (OWA) semantics and variants for implication enumeration and abduction (D*-Enum, D*-Ab).</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>logical_reasoning_task</strong></td>
                            <td>Proof generation, QA-with-proof, implication enumeration, and abduction tasks derived from formal Datalog theories expressed in NL; tests reasoning depths up to 5 (and implications deeper than that exist for enumeration).</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Evaluate deductive reasoning over NL-expressed rules and facts, with ground-truth proofs and exhaustive sets of implications and abduction targets available (small domain allows enumeration).</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_approach</strong></td>
                            <td>Used as the training and evaluation data for all ProofWriter experiments; variants created in this work include repaired CWA datasets and OWA versions, plus enumerative and abductive derivatives.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>Used to report ProofWriter performance: D5 results (proof correctness, answer accuracy, enumeration F1, abduction F1/accuracy) summarized across tables. Enables measurement of depth-wise generalization, OOD transfer (Birds/Electricity, ParaRules), and ablation over model size and training regimes.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Datasets are synthetic and templated in many cases; while ParaRules and Birds/Electricity test linguistic variation and hand-authored rulebases, broader natural-language variability and very large-scale KBs are not covered. Some original RuleTaker files had minor issues with negation and stratification that this paper repaired in D*(CWA) and D*(OWA) variants.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison</strong></td>
                            <td>RuleTaker serves as the benchmark against which ProofWriter (and PRover) are compared; the paper also uses ParaRules and Birds/Electricity for OOD evaluation.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_analysis_results</strong></td>
                            <td>Dataset variants enable analysis of CWA vs OWA semantics, training on different depth cutoffs (D3 vs D5) to test generalization, and enumeration/abduction task variants to evaluate multi-output generation.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'ProofWriter: Generating Implications, Proofs, and Abductive Statements over Natural Language', 'publication_date_yy_mm': '2020-12'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>PRover: Proof generation for interpretable reasoning over rules <em>(Rating: 2)</em></li>
                <li>Transformers as soft reasoners over language <em>(Rating: 2)</em></li>
                <li>Exploring the limits of transfer learning with a unified text-to-text transformer <em>(Rating: 2)</em></li>
                <li>LeapOfThought: Teaching pre-trained models to systematically reason over implicit knowledge <em>(Rating: 2)</em></li>
                <li>Generative language modeling for automated theorem proving <em>(Rating: 1)</em></li>
                <li>Measuring systematic generalization in neural proof generation with transformers <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-5105",
    "paper_id": "paper-87c45a908537ffe1d2ab71a5d609bd7b4efa4fe1",
    "extraction_schema_id": "extraction-schema-107",
    "extracted_data": [
        {
            "name_short": "ProofWriter",
            "name_full": "ProofWriter (generative proof/implication/abduction system)",
            "brief_description": "A generative system built on a pretrained T5 transformer that (1) generates True/False/Unknown answers, (2) generates human-readable proofs as directed acyclic graphs linearized for seq2seq output, (3) enumerates all implications of a natural-language theory, and (4) performs single-fact abduction by proposing missing facts that make a query provable.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "ProofWriter (finetuned T5)",
            "model_description": "A text-to-text generative system implemented by fine-tuning the T5 transformer (primarily T5-11B) to output answers plus a linearized proof representation; supports two generation strategies: All-At-Once (generate full proof+answer) and Iterative (generate 1-step implications repeatedly and assemble proofs). Uses special linear encoding (Polish notation, special tokens) to represent proofs and identifiers for facts/rules/conc/naf.",
            "model_size": "11B",
            "logical_reasoning_task": "Proof generation, implication enumeration, and single-fact abduction on RuleTaker-derived benchmarks (D0-D5, CWA and OWA variants), Birds-Electricity, and ParaRules.",
            "task_description": "Deductive reasoning over natural-language theories (Datalog-style semantics under CWA or OWA): decide truth of queries with proofs (directed acyclic graphs of facts/rules), enumerate all implications that follow from a theory, and abduce single missing facts that, when added, make an otherwise-unprovable query provable.",
            "method_or_approach": "Fine-tune T5 to generate proofs and implications. Two main approaches: (1) All-At-Once: directly generate full proof+answer for C,Q -&gt; A,P; (2) Iterative: train to generate single 1-step implications with 1-step proofs (C -&gt; implication + 1-step-proof) and at test time apply iteratively (forward-chaining), adding derived implications into the context until saturation and assembling full proofs from 1-step fragments. Proofs encoded in linearized Polish notation; abduction implemented by enumerating candidate formal facts in the underlying formalization then training the generator to output the missing fact(s) in NL.",
            "performance": "State-of-the-art proof generation results on RuleTaker-derived datasets: e.g., on D5(orig) ProofWriter All-At-Once produced proof-correctness 96.2% vs PRover 87.1% (≈ +9% absolute); answer accuracy ≈99.2–99.3%. Iterative ProofWriter shows strong OOD transfer and robust generalization: e.g., on hand-authored Birds-Electricity rulesets Iterative proof correctness ≈97.0% (substantially higher than prior baseline). Implication enumeration: Iterative achieves F1≈99.5 on D5-Enum (and high exact-set accuracy), All-At-Once degrades on deeper/unseen depths (e.g., D5). Abduction (single-fact) achieves F1≈97.3 and exact-match accuracy ≈93–94% on D3-Ab/D5-Ab IID tests, but lower zero-shot on more complex Electricity rulebases (down to mid-60s F1 for hardest). Verification: All-At-Once proofs within training depths are highly verifiable (~95–99%), but verifiability drops for proofs deeper than seen in training; Iterative proofs are by-construction verifiable (they come from actual 1-step inferences).",
            "limitations_or_failure_cases": "All-At-Once approach does not generalize well to proofs deeper than those seen in training; some All-At-Once proofs may be post-hoc and not reflect model's internal inference (though individual steps can be verified via QA). Iterative approach is computationally inefficient (exhaustive forward-chaining), unguided, can blow past transformer input token limits (default 512 tokens) as facts accumulate, and may require retrieval/guidance for larger theories. Abduction generalizes imperfectly OOD (performance degrades on more complex hand-authored Electricity datasets). Methods were evaluated on synthetic / templated NL plus some paraphrased and small hand-authored rulebases; scalability to very large, naturally written KBs is not shown. Domain sizes are small so exhaustive enumeration (for abduction training labels) is feasible; that might not scale.",
            "comparison": "Compared against PRover (classification+ILP assembly) and other prior methods: ProofWriter (generative) outperforms PRover on proof correctness (≈ +9% absolute on D5(orig)); Iterative ProofWriter generalizes better OOD and to deeper proofs than All-At-Once and PRover. T5-11B base is compared to T5-large (see ablation). Also discussed relative to RuleTaker (prior transformer-as-reasoner baseline) and LeapOfThought (combining implicit and explicit knowledge): ProofWriter can materialize implicit facts for LeapOfThought outputs via abduction+proof generation.",
            "ablation_or_analysis_results": "Model-size and training-regime analyses: T5-11B consistently outperforms T5-large on proof correctness, especially at higher depths (Appendix C/Table14-15). Training depth matters: models trained on shallower data (D3) struggle to generate/verifiably correct proofs at deeper depths (D5) in All-At-Once mode, while Iterative models trained on 1-step examples generalize to unseen depths. Verification experiments (Table 6) quantify that All-At-Once proofs within seen depths are verifiable at ≈93–99% but verifiability drops for unseen depths (very low for deepest levels when trained only to depth 3), while Iterative proofs are always verifiable by construction. Enumeration & abduction metrics (F1, exact-match accuracy) show Iterative &gt; All-At-Once for unordered multi-output tasks and better robustness to OOD conclusion generation.",
            "notes": "Implementation details: primarily fine-tuned T5-11B (40k steps, batch size 8); All-At-Once trained on full proof outputs, Iterative trained on aggregated 1-step examples constructed from gold proofs; proof linearization uses special tokens and identifier schemes (sentX, concX, nafX). Datasets and code released at allenai.org/data/proofwriter.",
            "uuid": "e5105.0",
            "source_info": {
                "paper_title": "ProofWriter: Generating Implications, Proofs, and Abductive Statements over Natural Language",
                "publication_date_yy_mm": "2020-12"
            }
        },
        {
            "name_short": "T5-11B",
            "name_full": "T5-11B (Text-to-Text Transfer Transformer, 11B parameters)",
            "brief_description": "A large pretrained seq2seq text-to-text transformer used as the base model for ProofWriter; fine-tuned to generate answers, proofs, implications, and abductive facts in natural language.",
            "citation_title": "Exploring the limits of transfer learning with a unified text-to-text transformer",
            "mention_or_use": "use",
            "model_name": "T5-11B",
            "model_description": "Encoder-decoder Transformer pre-trained in a unified text-to-text framework (T5); here fine-tuned for proof generation tasks and used as the backbone for ProofWriter experiments.",
            "model_size": "11B",
            "logical_reasoning_task": "Proof generation, implication enumeration, abduction on RuleTaker-derived datasets (D0-D5, CWA/OWA), Birds-Electricity, ParaRules.",
            "task_description": "Same as for ProofWriter: Datalog-style deductive reasoning over NL theories, producing proofs and enumerating implications, plus abductive identification of missing facts.",
            "method_or_approach": "Fine-tuning T5-11B as a seq2seq generator to produce linearized proofs and implications; experimented with All-At-Once and Iterative training regimes.",
            "performance": "Primary backbone achieving the best-reported numbers in the paper: higher proof correctness than T5-large, e.g., Iterative ProofWriter on D5 achieves proof correctness in the mid-90s% and outperforms baselines; verification and generalization experiments reported using T5-11B show superior robustness to unseen depths compared to All-At-Once and to smaller models.",
            "limitations_or_failure_cases": "Large model but still subject to input token limits (512 tokens default) when using Iterative forward-chaining; computation and TPU resources required (authors acknowledge Google TPUs). Performance still falls for proofs deeper than training for All-At-Once regime.",
            "comparison": "Compared directly to T5-large in ablation: T5-11B yields systematically better proof correctness and robustness (Appendix C). When used in iterative regime, it outperforms PRover and All-At-Once variants.",
            "ablation_or_analysis_results": "Appendix C/Tables 14–15 show T5-11B &gt; T5-large on proof correctness (especially at higher depths), while T5-large remains competitive on many answer-accuracy metrics.",
            "uuid": "e5105.1",
            "source_info": {
                "paper_title": "ProofWriter: Generating Implications, Proofs, and Abductive Statements over Natural Language",
                "publication_date_yy_mm": "2020-12"
            }
        },
        {
            "name_short": "T5-large",
            "name_full": "T5-large (Text-to-Text Transfer Transformer, ~770M parameters)",
            "brief_description": "A mid-sized T5 model variant evaluated as an ablation to measure the effect of model size on proof generation and reasoning; fine-tuned with the same ProofWriter methods.",
            "citation_title": "Exploring the limits of transfer learning with a unified text-to-text transformer",
            "mention_or_use": "use",
            "model_name": "T5-large",
            "model_description": "A 770M-parameter variant of the T5 family (encoder-decoder text-to-text transformer) used to test impact of parameter count on reasoning tasks when fine-tuned with ProofWriter formats.",
            "model_size": "770M",
            "logical_reasoning_task": "Same RuleTaker-derived proof generation, implication enumeration, and abduction tasks used in the paper.",
            "task_description": "Datalog-style deductive reasoning over NL theories for QA-with-proof, implication enumeration, and abduction.",
            "method_or_approach": "Same two regimes (All-At-Once and Iterative) as used with T5-11B, fine-tuned on the same datasets for comparison.",
            "performance": "Generally slightly worse than T5-11B on proof-correctness metrics, especially at higher proof depths: e.g., All-At-Once and Iterative evaluations (Appendix C) show reductions in proof correctness for deeper proofs relative to 11B, though answer-accuracy differences can be small. Concrete example: in some settings T5-large proof correctness at deep depths drops substantially compared to T5-11B (see Tables 14–15).",
            "limitations_or_failure_cases": "Lower proof generation accuracy at deeper reasoning depths compared to the 11B model; same token-limit and forward-chaining efficiency issues when using Iterative approach.",
            "comparison": "Direct ablation against T5-11B: T5-11B systematically slightly better, supporting that model size improves complex proof generation and generalization to unseen depths.",
            "ablation_or_analysis_results": "Tables 14–15 quantify the effect: T5-large is competitive on many answer-accuracy metrics but lags on proof-correctness, particularly at high depths and in All-At-Once generalization tests.",
            "uuid": "e5105.2",
            "source_info": {
                "paper_title": "ProofWriter: Generating Implications, Proofs, and Abductive Statements over Natural Language",
                "publication_date_yy_mm": "2020-12"
            }
        },
        {
            "name_short": "PRover",
            "name_full": "PRover: Proof generation for interpretable reasoning over rules",
            "brief_description": "A prior state-of-the-art system that assembles proofs by first classifying which facts/rules/connections belong in the proof tree and then using an ILP module to enforce consistency constraints; treated as the primary baseline for proof generation over the RuleTaker-style data.",
            "citation_title": "PRover: Proof generation for interpretable reasoning over rules",
            "mention_or_use": "use",
            "model_name": "PRover",
            "model_description": "A classifier-based approach that predicts nodes and edges of a proof graph and uses Integer Linear Programming (ILP) to enforce global consistency and assemble final proof trees; not a generative proof output model.",
            "model_size": null,
            "logical_reasoning_task": "Proof generation over RuleTaker-derived datasets (D5 and others); proof assembly for QA over natural-language rules/facts.",
            "task_description": "Produce interpretable proofs (graphs) supporting True/False QA answers for NL-expressed rules/facts; earlier SOTA for proof production.",
            "method_or_approach": "Classify which context sentences (facts/rules) and intermediate conclusions belong in a proof, predict edges, then solve an ILP to assemble a consistent proof tree.",
            "performance": "Prior baseline: on D5(orig) PRover proof correctness ~87.1% (Table 2), answer accuracy ~99.3%; ProofWriter generative approach improved proof correctness by ≈+9% absolute over PRover on that dataset. On Birds-Electricity and ParaRules, ProofWriter variants improve over PRover (detailed per-dataset numbers in paper).",
            "limitations_or_failure_cases": "PRover's proofs were sometimes imperfect and could be post-hoc (not necessarily reflecting model internal decisions); relies on ILP assembler and separate classification steps, adding complexity and heuristics; less robust OOD and to deeper proofs than Iterative ProofWriter.",
            "comparison": "Direct baseline: ProofWriter (All-At-Once and Iterative) outperforms PRover on proof correctness across multiple datasets; Iterative ProofWriter shows substantially better OOD generalization and proof verifiability.",
            "ablation_or_analysis_results": "The paper reports strict FA (Full Accuracy) metric comparisons using the same scoring as PRover and shows quantitative improvements; no internal ablation of PRover is performed here (PRover cited as prior work).",
            "uuid": "e5105.3",
            "source_info": {
                "paper_title": "ProofWriter: Generating Implications, Proofs, and Abductive Statements over Natural Language",
                "publication_date_yy_mm": "2020-12"
            }
        },
        {
            "name_short": "RuleTaker",
            "name_full": "RuleTaker (benchmarks D0-D5, CWA/OWA variants)",
            "brief_description": "A suite of synthetic natural-language logical reasoning datasets (D0, D1, D2, D3, D5) originally introduced to test transformers' ability to emulate deductive reasoning; used as the primary benchmark for evaluating ProofWriter.",
            "citation_title": "Transformers as soft reasoners over language",
            "mention_or_use": "use",
            "model_name": "RuleTaker datasets",
            "model_description": "Collections of theories (facts+rules) and associated queries expressed in templated English, generated from underlying formal Datalog programs; versions include closed-world (CWA) and open-world (OWA) semantics and variants for implication enumeration and abduction (D*-Enum, D*-Ab).",
            "model_size": null,
            "logical_reasoning_task": "Proof generation, QA-with-proof, implication enumeration, and abduction tasks derived from formal Datalog theories expressed in NL; tests reasoning depths up to 5 (and implications deeper than that exist for enumeration).",
            "task_description": "Evaluate deductive reasoning over NL-expressed rules and facts, with ground-truth proofs and exhaustive sets of implications and abduction targets available (small domain allows enumeration).",
            "method_or_approach": "Used as the training and evaluation data for all ProofWriter experiments; variants created in this work include repaired CWA datasets and OWA versions, plus enumerative and abductive derivatives.",
            "performance": "Used to report ProofWriter performance: D5 results (proof correctness, answer accuracy, enumeration F1, abduction F1/accuracy) summarized across tables. Enables measurement of depth-wise generalization, OOD transfer (Birds/Electricity, ParaRules), and ablation over model size and training regimes.",
            "limitations_or_failure_cases": "Datasets are synthetic and templated in many cases; while ParaRules and Birds/Electricity test linguistic variation and hand-authored rulebases, broader natural-language variability and very large-scale KBs are not covered. Some original RuleTaker files had minor issues with negation and stratification that this paper repaired in D*(CWA) and D*(OWA) variants.",
            "comparison": "RuleTaker serves as the benchmark against which ProofWriter (and PRover) are compared; the paper also uses ParaRules and Birds/Electricity for OOD evaluation.",
            "ablation_or_analysis_results": "Dataset variants enable analysis of CWA vs OWA semantics, training on different depth cutoffs (D3 vs D5) to test generalization, and enumeration/abduction task variants to evaluate multi-output generation.",
            "uuid": "e5105.4",
            "source_info": {
                "paper_title": "ProofWriter: Generating Implications, Proofs, and Abductive Statements over Natural Language",
                "publication_date_yy_mm": "2020-12"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "PRover: Proof generation for interpretable reasoning over rules",
            "rating": 2
        },
        {
            "paper_title": "Transformers as soft reasoners over language",
            "rating": 2
        },
        {
            "paper_title": "Exploring the limits of transfer learning with a unified text-to-text transformer",
            "rating": 2
        },
        {
            "paper_title": "LeapOfThought: Teaching pre-trained models to systematically reason over implicit knowledge",
            "rating": 2
        },
        {
            "paper_title": "Generative language modeling for automated theorem proving",
            "rating": 1
        },
        {
            "paper_title": "Measuring systematic generalization in neural proof generation with transformers",
            "rating": 1
        }
    ],
    "cost": 0.016760249999999997,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>ProofWriter: Generating Implications, Proofs, and Abductive Statements over Natural Language</h1>
<p>Oyvind Tafjord, Bhavana Dalvi Mishra, Peter Clark<br>Allen Institute for AI, Seattle, WA<br>{oyvindt, bhavanad, peterc}@allenai.org</p>
<h4>Abstract</h4>
<p>Transformers have been shown to emulate logical deduction over natural language theories (logical rules expressed in natural language), reliably assigning true/false labels to candidate implications. However, their ability to generate implications of a theory has not yet been demonstrated, and methods for reconstructing proofs of answers are imperfect. In this work we show that a generative model, called ProofWriter, can reliably generate both implications of a theory and the natural language proofs that support them. In particular, iterating a 1 -step implication generator results in proofs that are highly reliable, and represent actual model decisions (rather than post-hoc rationalizations). On the RuleTaker dataset, the accuracy of ProofWriter's proofs exceed previous methods by $+9 \%$ absolute, and in a way that generalizes to proof depths unseen in training and on out-of-domain problems. We also show that generative techniques can perform a type of abduction with high precision: Given a theory and an unprovable conclusion, identify a missing fact that allows the conclusion to be proved, along with a proof. These results significantly improve the viability of neural methods for systematically reasoning over natural language. ${ }^{1}$</p>
<h2>1 Introduction</h2>
<p>A fundamental goal for AI, dating back to its earliest years, is automated reasoning: the ability to draw valid conclusions from explicitly provided knowledge (McCarthy, 1959). However, approaches relying on expressing knowledge in a formal representation language have sometimes proved challenging (Musen and Van der Lei, 1988). Recent work on RuleTaker (Clark et al., 2020) demonstrated a modern approach to this goal, in which transformers emulate deductive reasoning</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Given facts, rules, and a question all expressed in natural language, ProofWriter answers the question and generates a proof of the answer.
over statements expressed in natural language, by reliably assigning true/false labels to candidate implications. However, simply assigning true/false labels is limiting. For practical purposes, systems should also generate proofs of those labels, so that their conclusions can be verified and a humanunderstandable rationale be produced.</p>
<p>Recent work on PRover, by Saha et al. (2020), provided first results towards this goal, assembling proofs by first classifying which facts, rules, and connections should be in the proof tree then using an Integer Linear Programming (ILP) module to enforce consistency constraints. However, the gen-</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: ProofWriter iteratively generates 1-step implications and their proofs, and adds implications back into into the context for deeper reasoning. The stepwise proof fragments are assembled into full proofs of N-hop conclusions.
erated proofs were imperfect, and there were no guarantees that the model "believed" the proofs that it was reciting, i.e., that its QA module would agree with the steps shown in the proof. In this paper, we adopt a different approach, based on generation rather than classification. Our system, ProofWriter, generates proofs such as that shown in Figure 1 by iteratively generating 1-hop inferences and their (simple) proofs, adding implications back into the context for deeper reasoning, and assembling more complex proofs from the 1-hop fragments (Figure 2). As the accuracy of 1-hop inference is highly reliable, the accuracy of deeper inference and their proofs is also high. This results in proofs that substantially exceed the earlier method's accuracy, and also reflect the model's internal decisions, rather than a post-hoc rationalization (i.e., is a "faithful" proof (Subramanian et al., 2020)).</p>
<p>The generative approach also affords two other new capabilities. First, ProofWriter generates implications that logically follow from a NL (natural language) theory, allowing enumeration of consequences (rather than only assigning truth values to pre-conjectured hypotheses). Second, we demonstrate (a constrained form of) abduction: Given a theory and an unprovable conclusion, identify a missing fact (if any) that allows the conclusion to be proved when added to the theory, plus its proof.</p>
<p>We evaluate our work on a collection of natural language reasoning datasets, including the Rule-</p>
<p>Taker datasets as well as several new variants. We achieve state-of-the-art results in proof generation, and strong new baselines for implication enumeration and abduction over natural language theories. Our contributions are thus:</p>
<ol>
<li>A new method for proof generation for logical reasoning over natural language, that obtains state-of-the-art results and is faithful to the model's internal decisions.</li>
<li>A method and baseline results for generating logical implications of statements in NL.</li>
<li>A method and baseline results for performing abduction over natural language statements.</li>
<li>New datasets to promote further research.</li>
</ol>
<p>These results significantly improve the viability of neural methods for formal reasoning over language.</p>
<h2>2 Related Work</h2>
<p>Our work builds on the RuleTaker line of research, in which transformers learn to emulate a deductive reasoning algorithm (Clark et al., 2020). Unlike other approaches to reasoning such as parsing to a formal language (Kamath and Das, 2019), implementing a reasoning algorithm with neural components (Weber et al., 2019; Rocktäschel and Riedel, 2017), or SAT solving (Selsam et al., 2019), these transformers emulate reasoning over language directly, bypassing a formal representation.</p>
<p>PRover (Saha et al., 2020), mentioned earlier, was the first system to also produce proofs in this context, although its post hoc approach meant that proofs did not necessarily represent the actual model decisions. Gontier et al. (2020) also explored the generation of answers and proofs, but in the context of rule induction with $(\approx 10)$ fixed rules to induce. In contrast, ProofWriter generates proofs from explicit NL rules (which may differ for each problem). Similarly, formal theorem proving has explored proving mathematical theorems from fixed, fundamental axioms, e.g., (Polu and Sutskever, 2020; Wang and Deng, 2020), while ProofWriter performs inference with differing sets of rules expressed in natural language.</p>
<p>Our work is also distinct from the large body of work on rationales and explanation. Work on rationales aims to identify sentences (or phrases) that caused a model to make a particular decision, but without an explanation of why that rationale led to the answer (the model's reasoning is opaque), e.g., (DeYoung et al., 2019; Narang et al., 2020). Similarly, work on explanations has sought to gen-</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Proof (and Answer)</th>
<th style="text-align: left;">$C Q \rightarrow A P$</th>
<th style="text-align: left;">Given theory $C$ and hypothesis fact $Q$, determine $Q$ 's truth $A$ and proof $P$ (if any)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Enumeration</td>
<td style="text-align: left;">$C \rightarrow I_{1}, \ldots, I_{n}$</td>
<td style="text-align: left;">Given $C$, generate all implications $I_{i}$ that logically follow.</td>
</tr>
<tr>
<td style="text-align: left;">Abduction</td>
<td style="text-align: left;">$C Q \rightarrow f_{m}$</td>
<td style="text-align: left;">Given $C$ and an unprovable fact $Q$, identify a new fact $f_{m}$ that, when added to $C$, <br> would make $Q$ true.</td>
</tr>
</tbody>
</table>
<p>Table 1: The three tasks that ProofWriter performs.
erate human-style justifications, which again are typically supporting evidence rather than a fullyformed line of reasoning, and without explicit reasoning rules (Camburu et al., 2018; Jhamtani and Clark, 2020; Inoue et al., 2020). In contrast, ProofWriter produces a deductive chain of reasoning from what is known to what is concluded, using a transformer retrained to reason systematically.</p>
<h2>3 Approach</h2>
<h3>3.1 Definitions</h3>
<p>Let:</p>
<ul>
<li>$C$ be a theory, a set of English sentences $C$ consisting of facts $F$ and rules $R$, each expressing a logical fact or rule in English. (We also refer to $C$ as the context).</li>
<li>$Q$ be a question, a hypothesis fact in English whose truth is to be determined based solely on the information in $C$.</li>
<li>$A$ be an answer, where $A \in{$ True, False $}$ (if reasoning using a closed-world assumption) or $A \in{$ True, False, Unknown $}$ (open-world assumption).</li>
<li>$P$ be a proof, described shortly.</li>
<li>$I$ be an implication, a fact that logically follows from $C$.</li>
</ul>
<p>We define three tasks (also see Table 1):</p>
<ol>
<li>proof (inc. QA): $C Q \rightarrow A P$ : Given $C$ and hypothesis fact $Q$, what is the truth $A$ and proof $P$ (if any) of $Q$ ?</li>
<li>enumeration: $C \rightarrow I_{1}, \ldots, I_{n}$ : Which $I_{i}$ follow from $C$ ?</li>
<li>abduction(restricted form) $C Q \rightarrow f_{m}$ : Which extra fact $f_{m}$ will make $Q$ true given $C$ ?
We reuse (and add to) the RuleTaker datasets for our work, which include all five elements above. An example of a RuleTaker theory (facts and rules), a query, and a proof generated by ProofWriter are shown in Figure 1. Facts and rules are English statements, and implications are English statements that logically follow from those facts and rules. The original datasets were generated from synthetic logic programs and their implications, using natural language patterns to produce the English forms.</li>
</ol>
<h3>3.2 Semantics</h3>
<p>Following prior work, we adopt the semantics of Datalog (Ceri et al., 1989): A fact is true if it is either known (i.e., explicitly stated in the context $C$ ), or (recursively) is the conclusion of a rule whose conditions are true (is "supported"). For handling negation, we use two alternative Datalog semantics: The first, following prior work, makes the closedworld assumption (CWA) and uses negation as failure (NAF), so that any fact not provable is assumed false. Under this semantics, negated facts and negative rule conclusions are not allowed (redundant under the CWA). The second makes an open-world assumption (OWA), and does allow negative facts and rule conclusions. Under this semantics, a third truth value Unknown is also possible.</p>
<h3>3.3 Proof Representation</h3>
<p>We define a proof $P$ of a fact $f_{q}$ as a directed acyclic graph $(N, E)$ with nodes $n \in N$ and (directed, untyped) edges $e \in E$. Each node in $P$ is either a fact $f$ (a ground literal) or a rule $r$ (a logical implication), expressed in English. Each edge in the proof either connects a fact to a rule, denoting that the fact helps satisfy the rule's condition, or connects a rule to a fact, denoting that the fact follows from the instantiated rule. Thus nodes in any branch of the proof will alternate between facts and rules. Note this definition differs from (and is richer than) that in PRover, where intermediate conclusions were not part of the proof.</p>
<p>Facts in the proof are one of three types: known facts $f_{i} \in F$, negated facts $f_{\text {naf }}$ that cannot be proven (false under negation-as-failure (NAF)), and facts $f_{\text {conc }}$ that are the conclusions of rules. $f_{i}$ and $f_{\text {naf }}$ are leaf nodes of the proof, while the $f_{\text {conc }}$ are intermediate nodes within the proof. Note that $f_{\text {naf }}$ and $f_{\text {conc }}$ are by definition not in $F$. Example proofs are shown in Figures 1 and 3.</p>
<h3>3.4 Proof Encoding</h3>
<p>As we wish to generate proofs, we need to encode $P$ as a linear structure that can be output by a generative model. Facts and rules in the context are explicitly labeled with identifiers (fact1, ..., rule1,</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: An example proof that includes a negated (negation-as-failure) fact.
...) that the proof can refer to, see Figures 1 and 3. ${ }^{2}$ Then, in the linear proof, rule nodes are denoted by their identifier (rule1, ...), while fact nodes are denoted by three types of identifiers: fact1, fact2, ... for facts in the context; naf1, naf2, ... for facts not in the context and assumed false; and conc1, conc2, ... for facts concluded by rules. To decode the naf<em> and conc</em> identifiers (which by definition are not in the context), an additional sequence of the form "with conc1: sentence1. conc2: sentence2. ..." is appended to the proof.</p>
<p>To linearize the proof in a format convenient for a generative model, we conjoin rules and their conclusions using a "\%" symbol, express conjunctive rule conditions with a "\&amp;" symbol, and use "#" to denote the inverse implication (" $\leftarrow$ "). We then express the tree using Polish notation. E.g., the proof tree "((fact1 \&amp; fact2) $\rightarrow$ rule1 $\rightarrow$ conc1)" (i.e., fact1 and fact2 satisfy rule1, concluding conc1) would be expressed "# rule1\%conc1 \&amp; fact1 fact2". Thus the 3 -step proof from Figure 1 is encoded:
# rule $18 \%$ conc1 \&amp; fact5 # rule $12 \%$ conc2
# rule $11 \%$ conc3 fact16 ; with conc1:
Charlie is quiet. ; conc2: Charlie is young. ; conc3: Charlie is kind.</p>
<p>If the question is a known fact, the "depth 0 proof" is simply the fact itself (e.g., fact1). If no proof exists, the symbol "None" is used.</p>
<h3>3.5 Models</h3>
<p>The ProofWriter models are built on top of the text-to-text pretrained T5 transformer (Raffel et al., 2020) (T5-11B). We use different textual prompts for the different tasks. For the task of generating an answer and a proof, the input to the model is</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup>of the form: " \$question\$ = question ; \$context\$ = theory-sentences", for example: "\$question\$ = Erin is big. ; \$context\$ = sent1: Erin is young. sent2: If ..." The output is of the form: "\$answer\$ = True/False/Unknown : \$proof\$ = proof ;", where proof is encoded as described in Section 3.4. For training instances where multiple outputs are valid, we select a single one at random (for multiple proofs, we select among the shortest proofs). Appendix D lists the hyperparameters and gives input/output examples for each task.</p>
<h3>3.6 Task 1: Proof Generation</h3>
<p>We evaluate two methods of proof generation:
All-At-Once: We train a model to generate the full proof and answer in one go (theory + question $\rightarrow$ answer + proof).
Iterative: We first train a model to generate a single 1-step implication (theory $\rightarrow$ implication +1 -step-proof), where the implication follows from a single rule application. Then at test time, we apply this model iteratively, adding each implication to the theory and repeating until no more implications can be found (i.e., exhaustive forward-chaining). The proof for any given implication can then be assembled from the 1-step-proof fragments (Figure 2).</p>
<h3>3.6.1 All-At-Once ProofWriter ("All")</h3>
<p>The All-At-Once model is trained directly on $C Q \rightarrow A P$ examples in the datasets ( $P=$ "None" if there is no proof of $Q$ ). Section 3.5 describes the i/o format, and Appendix D. 1 shows an example.</p>
<h3>3.6.2 Iterative ProofWriter ("Iter")</h3>
<p>Training: To train the Iterative model, for each theory $C$ in the training data, we create an augmented set of training examples with one sequence of iteratively inferred facts in turn, each using $C$ plus the previously inferred facts. For example, if theory $C_{1}$ implies $I_{1}, I_{2}$, and $I_{3}$, then we create four training examples $C_{1} \rightarrow I_{1}, C_{1} \cup\left{I_{1}\right} \rightarrow I_{2}$, $C_{1} \cup\left{I_{1}, I_{2}\right} \rightarrow I_{3}$, and $C_{1} \cup\left{I_{1}, I_{2}, I_{3}\right} \rightarrow$ "None". The order of adding the $I_{i}$ is random but constrained such that if a later implication depends on an earlier one, the earlier one must be inferred first. For example, if the proof of $I_{3}$ depends on $I_{2}$ (determined by inspecting the gold proofs), $I_{2}$ must be in the context before $I_{3}$ is inferred. This ensures that all example inferences are depth 1 (i.e., a single rule application). An example input/output for one step is shown in Appendix D.2.</p>
<p>Testing: To answer and provide the proof for a particular question/implication, the model generates all implications and their proofs by iteratively applying the model until no more implications (the implication "None") is generated. It then looks for the question among them. If found, the answer is True with the proof given. The model also looks for the negation of the question ${ }^{3}$ and its proof. If found, the answer is False with the proof given. Otherwise, there is no proof (proof = "None") and the answer is False (for positive questions, CWA), True (for negative questions, CWA), or Unknown (any question, OWA).</p>
<h3>3.7 Task 2: Implication Enumeration</h3>
<p>A second desirable reasoning skill is enumerating implications of a theory (rather than just assign True/False to a hypothesis). This capability is important for practical application of the technology. In fact, the Iterative ProofWriter already does this by design, a substantial advantage. To evaluate this (later), we compare this with an "all at once" strategy of generating all implications as a single output string, analogous to the All-At-Once strategy for generating the full proof as a single string. For training this All-At-Once enumerator, and testing both, we gather the list of all implications $I_{i}$ of each theory $C$ in the train/test data. Each train/test example is of then of the form: given $C$, predict all the $I_{i}$. An example input/output is in Appendix D.3.</p>
<h3>3.8 Task 3: Abduction (Single Fact)</h3>
<p>A third desirable reasoning skill is abduction over natural language theories, again made possible by generative models. Abduction has previously been studied extensively in formal logic, e.g., (Konolige, 1997), and in NLP, e.g., (Hobbs et al., 1993; Bhagavatula et al., 2020). Here we evaluate whether a generative approach can combine logic and NLP, performing logical abduction over natural language knowledge. We do this for a restricted form of abduction, namely single-fact abduction: Given a theory $C$ and a possible implication $Q$ not provable from $C$, identify a new fact $f_{m}$ (other than the trivial $Q$ itself) such that $C \cup\left{f_{m}\right}$ implies $Q$.</p>
<p>We restrict this task to the OWA (open-world) setting where questions can naturally have unknown truth values. To train and test an abductive</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup>model over our datasets, we create an abductive version as follows: For each theory $C$ in the train/test data, for each unprovable fact $Q$, identify all alternative "missing facts" fact $M$ that, when added to $C$, make $Q$ True. To do this, recall that each NL theory was originally generated from a formal one $C_{\text {formal }}$ in a formal representation language (Datalog). We first exhaustively enumerate all possible $Q_{\text {formal }}$ and fact $M_{\text {formal }}$ in the formal language (this is feasible as the space of predicates and individuals is small), then use a theorem prover to test if $C_{\text {formal }} \cup\left{\right.$ fact $M_{\text {formal }}}$ implies $Q_{\text {formal }}$ for all pairs (factM $M_{\text {formal }}, Q_{\text {formal }}$ ). For each success, we generate the NL equivalents $Q$ and fact $M$ using simple NL generation templates. We then collect the alternative factMs for each $Q$. The abduction task is then, given $C$ and $Q$, identify the set of all alternative factMs, i.e.:</p>
<p>$$
C, Q \rightarrow \text { factM }<em i="i">{1}, \ldots, \text { factM }</em>
$$</p>
<p>If there is no single fact $M$ that can be added to make $Q$ true, then the symbol "None" is output.</p>
<h2>4 Datasets</h2>
<p>We now evaluate ProofWriter on these three tasks. We use the original RuleTaker D* datasets (Clark et al., 2020), plus we create two new variants: The first (CWA) is similar to the original except it fixes some minor inconsistencies concerning negation (details in Appendix A.2). The second (OWA) is also similar to the original, except reasoning uses an open-world assumption.</p>
<p>We denote these as $\mathrm{D}^{<em>}($ orig $), \mathrm{D}^{</em>}(\mathrm{CWA})$, and $\mathrm{D}^{*}$ (OWA). Each example in each dataset contains a theory $C$, a question $Q$, the answer $A$ (True/False/Unknown), and all possible proofs $P_{1}, \ldots, P_{n}$ for that answer (if provable). ${ }^{4}$ Each theory is also accompanied with all possible proofs of all possible implications, as auxiliary annotations.</p>
<p>The D* datasets comprise five datasets, named D0, D1, D2, D3, D5, each containing 100k questions. In each dataset, theories and questions are expressed in templated English (e.g., Figure 1), questions can be positive or negated facts (e.g., "Charlie is not quiet?"), and answers are equally divided into True/False (and Unknown, for the OWA versions). Each dataset contains questions whose answers require reasoning up to depths $D(D=0$, $1,2,3,5)$. Thus, for example, all questions in D0</p>
<p><sup id="fnref:1"><a class="footnote-ref" href="#fn:1">2</a></sup></p>
<p>|  |  | Answer | Proof |  |  |
| Depth | # qns | PRo | ProofWriter | PRo | ProofWriter |
| 0 | 6299 | 100 | 100 | 98.4 | 99.6 |
| 1 | 4434 | 99.0 | 99.1 | 93.1 | 98.7 |
| 2 | 2915 | 98.8 | 98.6 | 84.8 | 97.3 |
| 3 | 2396 | 99.1 | 98.5 | 80.5 | 94.4 |
| 4 | 2134 | 98.8 | 98.7 | 72.4 | 91.0 |
| 5 | 2003 | 99.3 | 99.3 | 65.1 | 86.4 |
| All | 20192 | 99.3 | 99.2 | 87.1 | 96.2 |</p>
<p>Table 2: [Task 1: Proof Generation] Systems trained and tested on D5(orig), showing the breakdown by depth of proof required to answer each question. ProofWriter generates significantly more correct proofs for all depths, achieving a new SOTA on this task.
are lookup questions, requiring no inference. Each dataset is split 70/10/20 into train/dev/test.</p>
<p>To test generalization, we also use two other datasets from the original RuleTaker work:
Birds-Electricity: These 6 test-only datasets use small, real-world theories written by hand (one per dataset) to test out-of-distribution model performance. Details are in Appendix A.3.
ParaRules: This dataset contains 40k questions against 2 k theories expressed in paraphrased natural language, obtained through crowdsourcing. This dataset tests transfer to more natural expressions of knowledge. Details are in Appendix A.4.</p>
<h2>5 Experiments and Results</h2>
<h3>5.1 Task 1: Proof Generation (Comparison with Prior Work)</h3>
<p>First, we compare ProofWriter's ability to generate proofs with PRover, the current state-of-the-art. We evaluate both answer accuracy and proof correctness. For proof correctness, for a fair comparison, we ignore the intermediate conclusion nodes (which PRover does not generate). We then use the same strict scoring metric as in PRover (called FA or Full Accuracy in the PRover paper): the proof graph must exactly match a gold proof (i.e., be perfectly correct); otherwise, the proof scores 0 .</p>
<h3>5.1.1 Generating Answers and Proofs</h3>
<p>We use the same IID (independent, identically distributed) data used for PRover (train/test on dataset D5(orig)). The results are in Table 2, showing accuracies for questions requiring increasingly deeper depths of reasoning to answer. The ProofWriter's results are for the All-At-Once model. (The Iterative model scores are almost identical, see later Table 4.) While answer accuracy is almost perfect for both systems, ProofWriter generates substantially</p>
<p>|  |  | Answer | Proof |  |  |  |
| :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- |
|  |  | PRo | ProofWriter |  |  |  |
| Test | # qns |  | All | Iter |  |  |
| Birds1 | 40 | 95.0 | 100 | 95.0 | 92.5 | 100 | 95.0 |
| Birds2 | 40 | 95.0 | 100 | 95.0 | 95.0 | 100 | 95.0 |
| Elec1 | 162 | 100 | 96.9 | 100 | 95.1 | 96.9 | 100 |
| Elec2 | 180 | 100 | 98.9 | 100 | 91.7 | 98.9 | 100 |
| Elec3 | 624 | 89.7 | 92.0 | 95.5 | 71.8 | 92.0 | 95.5 |
| Elec4 | 4224 | 84.8 | 83.3 | 97.1 | 80.6 | 82.0 | 97.1 |
| All | 5270 | 86.5 | 85.5 | 97.0 | 80.5 | 84.5 | 97.0 |</p>
<p>Table 3: [Task 1: Proof Generation] Training on D5, test on Birds-Electricity. Both ProofWriter versions ("All" for All-At-Once, "Iter" for Iterative) outperform PRover overall in both answer and proof correctness. The Iterative model is also significantly more robust.
more correct proofs (last line, $+9 \%$ absolute), and without the complexity of PRover's heuristic assembly of proof graphs using ILP.</p>
<h3>5.1.2 Performance on OOD Rulesets</h3>
<p>We compared ProofWriter's and PRover's ability to generalize to the hand-authored Birds-Electricity rulesets, zero shot. These rulesets are out-ofdomain (OOD), as their English is not templated and is stylistically different to the training data. We compare the PRover and All-At-Once ("All") ProofWriter models trained on D5, plus the Iterative ProofWriter ("Iter") trained on D0-D3 theories. The models do not see any Birds-Electricity examples during training. The results in Table 3 show that ProofWriter's proof generation transfers well zero-shot to these hand-authored datasets, with $84.5 \%$ proof correctness for All-At-Once, and $97 \%$ for the Iterative ProofWriter, indicating better out-of-domain generalization for the Iterative version. Both ProofWriter models significantly outperform PRover ( $80.5 \%$ ).</p>
<p>We also find ProofWriter obtains more correct proofs ( $+3 \%$ ) than PRover on the ParaRules dataset. Details are in Appendix B.1.</p>
<h3>5.2 Task 1: Proof Generation (All-At-Once vs. Iterative)</h3>
<p>Second, we compare our two approaches to proof generation, All-At-Once vs. Iterative, in more detail. We show that although they have almost identical performance for proofs with depths seen in training, the Iterative model generalizes better to proofs of longer depths than seen in training. For these comparisons, we use the new $\mathrm{D}^{<em>}(\mathrm{CWA})$ datasets (which fix some minor errors in $\mathrm{D}^{</em>}$ (orig)), and also the $\mathrm{D}^{*}(\mathrm{OWA})$ datasets to explore performance in an open-world setting.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: center;">Answer</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Proof</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Depth</td>
<td style="text-align: center;">CWA</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">OWA</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">CWA</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">OWA</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;">All</td>
<td style="text-align: center;">Iter</td>
<td style="text-align: center;">All</td>
<td style="text-align: center;">Iter</td>
<td style="text-align: center;">All</td>
<td style="text-align: center;">Iter</td>
<td style="text-align: center;">All</td>
<td style="text-align: center;">Iter</td>
</tr>
<tr>
<td style="text-align: left;">N/A</td>
<td style="text-align: center;">99.0</td>
<td style="text-align: center;">99.7</td>
<td style="text-align: center;">99.4</td>
<td style="text-align: center;">99.9</td>
<td style="text-align: center;">99.0</td>
<td style="text-align: center;">99.7</td>
<td style="text-align: center;">99.4</td>
<td style="text-align: center;">99.9</td>
</tr>
<tr>
<td style="text-align: left;">0</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
</tr>
<tr>
<td style="text-align: left;">1</td>
<td style="text-align: center;">99.9</td>
<td style="text-align: center;">99.8</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">99.3</td>
<td style="text-align: center;">99.6</td>
<td style="text-align: center;">95.4</td>
<td style="text-align: center;">99.7</td>
<td style="text-align: center;">97.8</td>
</tr>
<tr>
<td style="text-align: left;">2</td>
<td style="text-align: center;">99.9</td>
<td style="text-align: center;">99.5</td>
<td style="text-align: center;">99.9</td>
<td style="text-align: center;">99.7</td>
<td style="text-align: center;">98.3</td>
<td style="text-align: center;">91.7</td>
<td style="text-align: center;">98.6</td>
<td style="text-align: center;">97.3</td>
</tr>
<tr>
<td style="text-align: left;">3</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">99.7</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">99.2</td>
<td style="text-align: center;">95.8</td>
<td style="text-align: center;">90.4</td>
<td style="text-align: center;">96.9</td>
<td style="text-align: center;">97.1</td>
</tr>
<tr>
<td style="text-align: left;">4</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">99.7</td>
<td style="text-align: center;">99.9</td>
<td style="text-align: center;">99.1</td>
<td style="text-align: center;">93.1</td>
<td style="text-align: center;">88.9</td>
<td style="text-align: center;">94.8</td>
<td style="text-align: center;">96.5</td>
</tr>
<tr>
<td style="text-align: left;">5</td>
<td style="text-align: center;">99.9</td>
<td style="text-align: center;">98.9</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">98.8</td>
<td style="text-align: center;">89.3</td>
<td style="text-align: center;">87.8</td>
<td style="text-align: center;">91.4</td>
<td style="text-align: center;">86.4</td>
</tr>
<tr>
<td style="text-align: left;">All</td>
<td style="text-align: center;">99.6</td>
<td style="text-align: center;">99.7</td>
<td style="text-align: center;">99.7</td>
<td style="text-align: center;">99.6</td>
<td style="text-align: center;">97.2</td>
<td style="text-align: center;">95.4</td>
<td style="text-align: center;">98.0</td>
<td style="text-align: center;">97.6</td>
</tr>
</tbody>
</table>
<p>Table 4: [Task 1] Comparison of All-At-Once ("All") vs. Iterative ("Iter") ProofWriter models, trained on D5 and D0-D3 respectively, and tested on D5.</p>
<h3>5.2.1 Comparison (IID Test Set)</h3>
<p>We train the All-At-Once model on D5 (train), and the Iterative model using the method described in Section 3.6.2, using the ( $\sim 5 \mathrm{k}$ ) theories from D3 (train) plus $\sim 20 \%$ of the D0-D2 (train) theories. ${ }^{5}$ We then test both models on D5 (test). We measure both answer and proof accuracies, and also break down the results by proof depth (using "N/A" as the proof depth for questions that are not provable). The D5 test set has 2 k questions at each proof depth, plus 8 k unprovable questions (proof $=$ "None", depth = "N/A'). ${ }^{6}$</p>
<p>The results are shown in Table 4, and show that both ProofWriter versions have similar, high proof correctness ( $95 \%+$ ) on the test set, even though some proofs are highly complex.</p>
<h3>5.2.2 Generalization to Unseen Depths</h3>
<p>We also wish to see how well the models can generate proofs at depths unseen during training. To do this, we train an All-At-Once model on D3, and use the same Iterative model as earlier (trained on iterative examples from theories up to depth 3). We test on D5. As D5 contains problems at greater depths than those seen during training, we can observe the models' ability to generalize. We compare with both the CWA and OWA versions of our datasets.</p>
<p>The results are shown in Table 5. As can be seen, the All-At-Once model has quite poor generalization for generating longer proofs than seen in training, while the Iterative model is more robust (red box).</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup>Table 5: [Task 1] Comparison of the All-At-Once vs. Iterative ProofWriter models, trained on D3 and tested on D5. While scores are mostly similar throughout, the iterative model generalizes substantially better to generate proofs of depths unseen during training (red box).
<img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Table 5: [Task 1] Comparison of the All-At-Once vs. Iterative ProofWriter models, trained on D3 and tested on D5. While scores are mostly similar throughout, the iterative model generalizes substantially better to generate proofs of depths unseen during training (red box).
<img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 4: [Task 1] All-At-Once proofs can be verified by checking each step as a separate QA query.</p>
<h3>5.3 Verifying All-At-Once Proofs</h3>
<p>Proofs from the Iterative ProofWriter have an additional desirable property: each proof step is one that the model explicitly took during the iteration, i.e., the model "believes" the step. In contrast, the All-At-Once proofs are a post hoc generated string of symbols, and may not reflect steps that ProofWriter would actually make. However, because proofs include intermediate conclusions, we can alleviate this concern by verifying individual steps in the All-At-Once proofs. For example, if a generated proof step states that fact2 + fact3 + rule4 implies conc1, we can simply ask ProofWriter in QA mode if this is true (Figure 4). Given the almost perfect performance for such simple depth 1 questions in QA mode (with no distractor facts or rules), the ability to verify a correct proof corresponds to the accuracy of correctly generating the correct intermediate conclusions conc* in the first place. (Note that an unverified proof is not necessarily wrong, rather cannot be verified as right). OWA proofs can be fully verified in this way. For CWA theories with NAFs, the verification is only partial as NAFs are presumed negative statements</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: center;">Verified Proofs</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;">CWA</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">OWA</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;">Train on:</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Train on:</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">Depth</td>
<td style="text-align: center;">D3</td>
<td style="text-align: center;">D5</td>
<td style="text-align: center;">D3</td>
<td style="text-align: center;">D5</td>
</tr>
<tr>
<td style="text-align: left;">N/A</td>
<td style="text-align: center;">99.6</td>
<td style="text-align: center;">99.0</td>
<td style="text-align: center;">99.4</td>
<td style="text-align: center;">99.4</td>
</tr>
<tr>
<td style="text-align: left;">0</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
</tr>
<tr>
<td style="text-align: left;">1</td>
<td style="text-align: center;">99.8</td>
<td style="text-align: center;">99.6</td>
<td style="text-align: center;">99.7</td>
<td style="text-align: center;">99.7</td>
</tr>
<tr>
<td style="text-align: left;">2</td>
<td style="text-align: center;">98.2</td>
<td style="text-align: center;">98.3</td>
<td style="text-align: center;">98.6</td>
<td style="text-align: center;">98.6</td>
</tr>
<tr>
<td style="text-align: left;">3</td>
<td style="text-align: center;">93.2</td>
<td style="text-align: center;">95.8</td>
<td style="text-align: center;">94.3</td>
<td style="text-align: center;">96.8</td>
</tr>
<tr>
<td style="text-align: left;">4</td>
<td style="text-align: center;">66.7</td>
<td style="text-align: center;">92.9</td>
<td style="text-align: center;">66.1</td>
<td style="text-align: center;">94.6</td>
</tr>
<tr>
<td style="text-align: left;">5</td>
<td style="text-align: center;">13.8</td>
<td style="text-align: center;">89.3</td>
<td style="text-align: center;">16.4</td>
<td style="text-align: center;">90.8</td>
</tr>
<tr>
<td style="text-align: left;">All</td>
<td style="text-align: center;">87.2</td>
<td style="text-align: center;">97.2</td>
<td style="text-align: center;">87.9</td>
<td style="text-align: center;">97.9</td>
</tr>
</tbody>
</table>
<p>Table 6: [Task 1: Proof Generation] The All-At-Once model's ability to verify its proofs. For proofs within depths seen during training, almost all correct proofs (Tables 5 and 4, columns 5 and 7) can be verified. However, for proofs at unseen depths, the proportion that can be verified drops rapidly (trained on D3, test on depths 4,5). In contrast, Iterative ProofWriter's proofs are always verified, by definition of its algorithm.
which require the full theory to verify.
We measured the percentage of correct, verified proofs, shown in Table 6. Provided proofs are within the depths seen during training, almost all correct proofs can be verified. However, at depths deeper than seen at training, the proportion that can be verified drops rapidly. In contrast, the Iterative ProofWriter's proofs are always verified, as by definition they are assembled from single step inferences that the model actually took.</p>
<h3>5.4 Task 2: Implication Enumeration</h3>
<p>Third, we evaluate ProofWriter's performance on a new task, namely enumerating implications of a theory (rather than just assign True/False to a hypothesis). We compare the All-At-Once and Iterative strategies as described in Section 3.7.</p>
<p>To train All-At-Once, and test both, we created an enumerative dataset of $C \rightarrow\left{I_{1}, \ldots, I_{n}\right}$ examples (Section 3.7). For this we sample theories $C$ in the D0-D3 datasets and gather the list of all implications $I_{i}$ for each theory $C$. We call this enumerative dataset D3+Enum. We similarly create a D5-Enum dataset from theories in (only) D5 to test OOD conclusion generation. We create CWA and OWA versions of both.</p>
<p>We train All-At-Once on D3-Enum (train), then test both models on D3-Enum (test) and D5-Enum (test). For metrics, we measure F1 scores by comparing the individual predicted implications with the gold $I_{i}$, as well as the exact-match correctness of the predicted set of implications $\left{I_{1}, \ldots, I_{n}\right}$ (one point if the set exactly matches the gold, bar ordering, zero otherwise). The results are shown in</p>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">F1</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Accuracy</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Enum</td>
<td style="text-align: center;">CWA</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">OWA</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">CWA</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">OWA</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Test</td>
<td style="text-align: center;">All</td>
<td style="text-align: center;">Iter</td>
<td style="text-align: center;">All</td>
<td style="text-align: center;">Iter</td>
<td style="text-align: center;">All</td>
<td style="text-align: center;">Iter</td>
<td style="text-align: center;">All</td>
<td style="text-align: center;">Iter</td>
</tr>
<tr>
<td style="text-align: center;">D3+</td>
<td style="text-align: center;">98.9</td>
<td style="text-align: center;">99.8</td>
<td style="text-align: center;">99.4</td>
<td style="text-align: center;">99.6</td>
<td style="text-align: center;">92.5</td>
<td style="text-align: center;">98.8</td>
<td style="text-align: center;">95.5</td>
<td style="text-align: center;">99.0</td>
</tr>
<tr>
<td style="text-align: center;">D5</td>
<td style="text-align: center;">94.5</td>
<td style="text-align: center;">99.5</td>
<td style="text-align: center;">94.8</td>
<td style="text-align: center;">99.4</td>
<td style="text-align: center;">44.6</td>
<td style="text-align: center;">93.9</td>
<td style="text-align: center;">48.9</td>
<td style="text-align: center;">94.8</td>
</tr>
</tbody>
</table>
<p>Table 7: [Task 2: Enumeration] Iterative ProofWriter is better at generating all implications than an All-AtOnce strategy. (All-At-Once is trained on D3+Enum, Iterative ProofWriter is the same model as earlier.)</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Test:</th>
<th style="text-align: center;">Count</th>
<th style="text-align: center;">F1</th>
<th style="text-align: center;">Acc</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">D3-Ab</td>
<td style="text-align: center;">7067</td>
<td style="text-align: center;">97.4</td>
<td style="text-align: center;">94.5</td>
</tr>
<tr>
<td style="text-align: left;">D5-Ab</td>
<td style="text-align: center;">7181</td>
<td style="text-align: center;">97.3</td>
<td style="text-align: center;">93.5</td>
</tr>
</tbody>
</table>
<p>Table 8: [Task 3: Abduction] Given a theory $C$ and an unprovable conclusion $Q$, predict all alternative facts that, when added to $C$, make $Q$ provable.</p>
<p>Table 7, and show that the Iterative ProofWriter is better at implication enumeration than the simple All-At-Once strategy. In particular, the All-At-Once strategy struggles for problems at depths unseen in training (second row), although it does well on its own test set despite the complicated unordered output it has to generate (up to 16 different implications in D3, 21 in D5).</p>
<h3>5.5 Task 3: Abduction (Single Fact)</h3>
<p>Fourth and finally, we evaluate performance on a second new task, namely abduction over natural language theories, again made possible by generative models. Analogous to implication enumeration, we create a derivative abductive dataset of $C, Q \rightarrow f a c t M_{1}, \ldots$, fact $M_{i}$ examples, where $C \cup\left{f a c t M_{i}\right}$ results in $Q$ becoming provable as described in Section 3.8. We create such D<em>-Ab datasets from the D</em>(OWA) datasets.</p>
<h3>5.5.1 Results (IID)</h3>
<p>We trained a model on D3-Ab (train), and then tested on both D3-Ab (test) and D5-Ab (test). We evaluate the results by comparing the predicted and gold fact $M \mathrm{~s}$, measuring both F1 and "perfect match" Accuracy ( 1 when F1=1, 0 otherwise). The results are shown in Table 8, and indicate that the model performs well overall ( $85 \%+$ scores). We also broke down the recall of fact $M \mathrm{~s}$ by proof depth required to prove $Q$ given $C$ and fact $M$. This is shown in Table 9, indicating that it is harder to identify a fact $M$ that completes a deeper proof. The similarity of D3-Ab and D5-Ab scores suggests that D5-Ab is not out-of-domain for this task: Although depths for provable D5 facts are deeper than D3, this task concerns unprovable facts, which may not be distributed differently to D3-Ab.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Gold Proof</th>
<th style="text-align: center;">Test on D3-Ab</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Test on D5-Ab</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Depth</td>
<td style="text-align: center;"># Gold</td>
<td style="text-align: center;">Acc (recall)</td>
<td style="text-align: center;"># Gold</td>
<td style="text-align: center;">Acc (recall)</td>
</tr>
<tr>
<td style="text-align: left;">N/A</td>
<td style="text-align: center;">2155</td>
<td style="text-align: center;">97.73</td>
<td style="text-align: center;">2170</td>
<td style="text-align: center;">97.74</td>
</tr>
<tr>
<td style="text-align: left;">1</td>
<td style="text-align: center;">4813</td>
<td style="text-align: center;">98.46</td>
<td style="text-align: center;">4731</td>
<td style="text-align: center;">98.73</td>
</tr>
<tr>
<td style="text-align: left;">2</td>
<td style="text-align: center;">1719</td>
<td style="text-align: center;">96.22</td>
<td style="text-align: center;">1986</td>
<td style="text-align: center;">96.17</td>
</tr>
<tr>
<td style="text-align: left;">3</td>
<td style="text-align: center;">688</td>
<td style="text-align: center;">90.26</td>
<td style="text-align: center;">915</td>
<td style="text-align: center;">92.79</td>
</tr>
<tr>
<td style="text-align: left;">4</td>
<td style="text-align: center;">153</td>
<td style="text-align: center;">75.82</td>
<td style="text-align: center;">330</td>
<td style="text-align: center;">82.73</td>
</tr>
<tr>
<td style="text-align: left;">5</td>
<td style="text-align: center;">19</td>
<td style="text-align: center;">36.84</td>
<td style="text-align: center;">96</td>
<td style="text-align: center;">78.13</td>
</tr>
</tbody>
</table>
<p>Table 9: [Task 3: Abduction] Recall of abduced facts by proof depth. The data suggests that it is harder to identify a fact $M$ that completes a deeper proof.</p>
<h3>5.5.2 Generalization to New Tasks</h3>
<p>To assess out-of-domain generalization, we also evaluate how well the trained abductive model performs on an abductive version of the BirdsElectricity(OWA) theories, zero-shot (created using the same approach, Section 3.8). We find that ProofWriter has perfect zero-shot performance for the simple Birds rulebases, but progressively reduced performance for the Electricity theories as they get more complex (dropping to $64 \%$ F1, $62 \%$ Accuracy for one rulebase), indicating that the abductive task is only partly solved (Appendix B.2).</p>
<h2>6 Discussion</h2>
<h3>6.1 All-At-Once vs. Iterative Strategies</h3>
<p>While the All-At-Once approach to proof generation is simple, efficient, and effective, it does not generalize as well to proofs of greater depth than seen at training. In contrast, the Iterative approach is robust to generalization. Even though errors at each iteration accumulate, the reliability of 1-step inference is so high that such error accumulations remain small. The Iterative architecture, namely a simple model embedded in a recursive loop (rather than single seq2seq model), illustrates how transformers can be used in a "scale-invariant" way, i.e., performance is largely unchanged by the scale (here reasoning depth) of the problem. In addition, as proofs are built from actual inference steps taken by the model, they are by definition "faithful" to the model's inference steps, rather than being a post hoc rationalization.</p>
<p>However, there are also some drawbacks to the Iterative approach: First, it is inefficient and unguided, proving everything possible and only then looking for the answer and proof for a particular question. In fact, this is a limitation of unconstrained forward-chaining in general, hence established techniques for guiding forward-chaining could be applied, e.g., a best-first expansion strategy, or using a backward-chaining strategy instead
(which would similarly need to be controlled). Second, as the theory grows by one fact per iteration, there is a risk of exceeding the transformer's input token limit ( 512 tokens by default), hence limiting the size of theories that can be handled. For larger theories, a retrieval mechanism might be needed to manage the facts and rules available to the reasoner.</p>
<h3>6.2 Abduction and Implicit Knowledge</h3>
<p>Recently, LeapOfThought (Talmor et al., 2020) showed that RuleTaker-like models could be retrained to reason with a combination of explicit and implicit knowledge, rather than requiring all rules to be stated explicitly (the implicit knowledge coming from the latent knowledge acquired during pretraining (Petroni et al., 2019)). Now, given an abductive capability such as the one we have presented, we have a mechanism for materializing the implicit knowledge used to answer a question, and hence generating the full proof of its answer: Given a LeapOfThought conclusion, first abduce the "missing" (implicit) fact(s) required for an explicit proof, then use ProofWriter to generate that proof. This is a significant step forward to help understand a model's decisions when both implicit and explicit knowledge has been used.</p>
<h2>7 Summary and Conclusion</h2>
<p>While it is remarkable that transformers can learn to systematically reason over language, such methods will have limited impact if they cannot also explain their answers. In this work, we showed the first application of generative techniques to this task, and demonstrated how proofs, implication enumerations, and abductive inferences can be generated, exceeding the prior state-of-the-art in proof generation by $+9 \%$ (absolute). In addition, the Iterative ProofWriter robustly generalizes to deeper proofs and more varied language than seen in training, and produces proofs that reflect (i.e., are faithful to) the model's actual inference decisions. Finally, the abductive capability offers the potential for generating proofs when both explicit and implicit knowledge are used, by materializing the implicit knowledge needed to complete the proof. Together, these significantly improve the viability of neural methods for systematically reasoning over language in practical settings. The ProofWriter datasets are available at https://allenai.org/data/proofwriter</p>
<p>Acknowledgements: We thank Google for providing the TPUs for conducting experiments.</p>
<h2>References</h2>
<p>Chandra Bhagavatula, Ronan Le Bras, Chaitanya Malaviya, Keisuke Sakaguchi, Ari Holtzman, Hannah Rashkin, Doug Downey, S. Yih, and Yejin Choi. 2020. Abductive commonsense reasoning. In $I C L R^{\prime} 20$.</p>
<p>Oana-Maria Camburu, Tim Rocktäschel, Thomas Lukasiewicz, and Phil Blunsom. 2018. e-SNLI: Natural language inference with natural language explanations. In Advances in Neural Information Processing Systems, pages 9539-9549.
S. Ceri, G. Gottlob, and L. Tanca. 1989. What you always wanted to know about datalog (and never dared to ask). IEEE Trans. Knowl. Data Eng., 1:146-166.</p>
<p>Peter Clark, Oyvind Tafjord, and Kyle Richardson. 2020. Transformers as soft reasoners over language. In IJCAI'20.</p>
<p>Jay DeYoung, Sarthak Jain, Nazneen Rajani, E. Lehman, Caiming Xiong, R. Socher, and Byron C. Wallace. 2019. ERASER: A benchmark to evaluate rationalized nlp models. In $A C L$.</p>
<p>Nicolas Gontier, Koustuv Sinha, Siva Reddy, and C. Pal. 2020. Measuring systematic generalization in neural proof generation with transformers. In NeurIPS'20.
J. Hobbs, Mark E. Stickel, Douglas E. Appelt, and P. Martin. 1993. Interpretation as abduction. Artificial Intelligence, 63:69-142.
N. Inoue, Pontus Stenetorp, and Kentaro Inui. 2020. R4C: A benchmark for evaluating RC systems to get the right answer for the right reason. In $A C L$.</p>
<p>Harsh Jhamtani and P. Clark. 2020. Learning to explain: Datasets and models for identifying valid reasoning chains in multihop question-answering. In EMNLP.</p>
<p>Aishwarya Kamath and Rajarshi Das. 2019. A survey on semantic parsing. In $A K B C^{\prime} 19$.
K. Konolige. 1997. Abductive theories in artificial intelligence. In Principles of Knowledge Representation.</p>
<p>John McCarthy. 1984. Applications of circumscription to formalizing common sense knowledge. In NMR.</p>
<p>John W. McCarthy. 1959. Programs with common sense. In Proc. Tedding Conf. on the Mechanization of Thought Processes, pages 75-91.</p>
<p>Mark A Musen and Johan Van der Lei. 1988. Of brittleness and bottlenecks: Challenges in the creation of pattern-recognition and expert-system models. In Machine Intelligence and Pattern Recognition, volume 7, pages 335-352. Elsevier.</p>
<p>Sharan Narang, Colin Raffel, Katherine Lee, A. Roberts, Noah Fiedel, and Karishma Malkan. 2020. WT5?! training text-to-text models to explain their predictions. ArXiv, abs/2004.14546.
F. Petroni, Tim Rocktäschel, Patrick Lewis, A. Bakhtin, Y. Wu, Alexander H. Miller, and S. Riedel. 2019. Language models as knowledge bases? In EMNLP.</p>
<p>Stanislas Polu and Ilya Sutskever. 2020. Generative language modeling for automated theorem proving. ArXiv, abs/2009.03393.</p>
<p>Colin Raffel, Noam Shazeer, Adam Roberts, Katherine Lee, Sharan Narang, M. Matena, Yanqi Zhou, W. Li, and Peter J. Liu. 2020. Exploring the limits of transfer learning with a unified text-to-text transformer. J. Mach. Learn. Res., 21:140:1-140:67.</p>
<p>Tim Rocktäschel and S. Riedel. 2017. End-to-end differentiable proving. In NeurIPS.</p>
<p>Swarnadeep Saha, Sayan Ghosh, Shashank Srivastava, and Mohit Bansal. 2020. PRover: Proof generation for interpretable reasoning over rules. In EMNLP'20.</p>
<p>Daniel Selsam, Matthew Lamm, Benedikt Bünz, Percy Liang, Leonardo de Moura, and David L. Dill. 2019. Learning a SAT solver from single-bit supervision. In $I C L R$.</p>
<p>Sanjay Subramanian, Ben Bogin, Nitish Gupta, Tomer Wolfson, Sameer Singh, Jonathan Berant, and Matt Gardner. 2020. Obtaining faithful interpretations from compositional neural networks. In $A C L$.</p>
<p>Alon Talmor, Oyvind Tafjord, P. Clark, Y. Goldberg, and Jonathan Berant. 2020. LeapOfThought: Teaching pre-trained models to systematically reason over implicit knowledge. In NeurIPS.</p>
<p>Ming-Zhe Wang and Jun Deng. 2020. Learning to prove theorems by learning to generate theorems. In NeurIPS.</p>
<p>Leon Weber, Pasquale Minervini, Jannes Münchmeyer, Ulf Leser, and Tim Rocktäschel. 2019. Nlprolog: Reasoning with weak unification for question answering in natural language. In $A C L$.</p>
<h1>Appendix: ProofWriter: Generating Implications, Proofs, and Abductive Statements over Natural Language</h1>
<h2>A Datasets: Additional Details</h2>
<h2>A. 1 Statistics</h2>
<p>Some overall statistics for the updated RuleTaker CWA and OWA datasets are in Table 10. The number of implications per theory can reach 20 and above, and the proof depths go up to 10 , even though the proof depths of the associated questions are limited to the dataset depth (e.g., depth 3 for D3).</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Dataset</th>
<th style="text-align: center;"># th</th>
<th style="text-align: center;"># qns</th>
<th style="text-align: center;"># impl min/mean/max</th>
<th style="text-align: center;">depth <br> max</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">CWA:</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">D0</td>
<td style="text-align: center;">27020</td>
<td style="text-align: center;">100002</td>
<td style="text-align: center;">0/1.0/18</td>
<td style="text-align: center;">8</td>
</tr>
<tr>
<td style="text-align: center;">D1</td>
<td style="text-align: center;">12965</td>
<td style="text-align: center;">100012</td>
<td style="text-align: center;">1/1.9/17</td>
<td style="text-align: center;">6</td>
</tr>
<tr>
<td style="text-align: center;">D2</td>
<td style="text-align: center;">9138</td>
<td style="text-align: center;">100014</td>
<td style="text-align: center;">2/3.3/18</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td style="text-align: center;">D3</td>
<td style="text-align: center;">7067</td>
<td style="text-align: center;">100024</td>
<td style="text-align: center;">3/5.1/16</td>
<td style="text-align: center;">7</td>
</tr>
<tr>
<td style="text-align: center;">D5</td>
<td style="text-align: center;">4935</td>
<td style="text-align: center;">100030</td>
<td style="text-align: center;">5/9.8/21</td>
<td style="text-align: center;">10</td>
</tr>
<tr>
<td style="text-align: center;">Birds/Elec</td>
<td style="text-align: center;">140</td>
<td style="text-align: center;">5270</td>
<td style="text-align: center;">0/2.0/6</td>
<td style="text-align: center;">4</td>
</tr>
<tr>
<td style="text-align: center;">ParaRules</td>
<td style="text-align: center;">2403</td>
<td style="text-align: center;">40022</td>
<td style="text-align: center;">3/4.3/14</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td style="text-align: center;">OWA:</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">D0</td>
<td style="text-align: center;">26978</td>
<td style="text-align: center;">100000</td>
<td style="text-align: center;">0/0.8/18</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td style="text-align: center;">D1</td>
<td style="text-align: center;">12933</td>
<td style="text-align: center;">100014</td>
<td style="text-align: center;">1/1.7/14</td>
<td style="text-align: center;">6</td>
</tr>
<tr>
<td style="text-align: center;">D2</td>
<td style="text-align: center;">9033</td>
<td style="text-align: center;">100010</td>
<td style="text-align: center;">2/3.1/14</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td style="text-align: center;">D3</td>
<td style="text-align: center;">6940</td>
<td style="text-align: center;">100036</td>
<td style="text-align: center;">3/4.8/16</td>
<td style="text-align: center;">6</td>
</tr>
<tr>
<td style="text-align: center;">D5</td>
<td style="text-align: center;">4752</td>
<td style="text-align: center;">100030</td>
<td style="text-align: center;">5/9.1/21</td>
<td style="text-align: center;">10</td>
</tr>
<tr>
<td style="text-align: center;">Birds/Elec</td>
<td style="text-align: center;">140</td>
<td style="text-align: center;">5270</td>
<td style="text-align: center;">0/1.2/6</td>
<td style="text-align: center;">3</td>
</tr>
<tr>
<td style="text-align: center;">ParaRules</td>
<td style="text-align: center;">2403</td>
<td style="text-align: center;">40022</td>
<td style="text-align: center;">3/4.3/14</td>
<td style="text-align: center;">5</td>
</tr>
</tbody>
</table>
<p>Table 10: Statistics for the CWA and OWA datasets, giving the number of theories, questions and implications per theory. Note that the maximum implication proof depth can go higher than the maximum proof depth for the included questions (e.g., for D5 the maximum questions depth is 5 , but there are implications up to depth 10 which are include in the enumeration task).</p>
<p>Table 11 describes overall statistics for the datasets for Task 3: Abduction. Each abduction question can have zero or more missing facts as answer, and the proof depths can go up to 11 .</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Dataset</th>
<th style="text-align: center;"># th</th>
<th style="text-align: center;"># qns</th>
<th style="text-align: center;"># missing <br> facts <br> min/mean/max</th>
<th style="text-align: center;">max <br> proof <br> depth</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">D0-Ab</td>
<td style="text-align: center;">18011</td>
<td style="text-align: center;">85705</td>
<td style="text-align: center;">$0 / 0.8 / 15$</td>
<td style="text-align: center;">6</td>
</tr>
<tr>
<td style="text-align: left;">D1-Ab</td>
<td style="text-align: center;">10448</td>
<td style="text-align: center;">49808</td>
<td style="text-align: center;">$0 / 0.8 / 12$</td>
<td style="text-align: center;">7</td>
</tr>
<tr>
<td style="text-align: left;">D2-Ab</td>
<td style="text-align: center;">7092</td>
<td style="text-align: center;">37245</td>
<td style="text-align: center;">$0 / 0.9 / 11$</td>
<td style="text-align: center;">6</td>
</tr>
<tr>
<td style="text-align: left;">D3-Ab</td>
<td style="text-align: center;">5633</td>
<td style="text-align: center;">34915</td>
<td style="text-align: center;">$0 / 1.1 / 11$</td>
<td style="text-align: center;">8</td>
</tr>
<tr>
<td style="text-align: left;">D5-Ab</td>
<td style="text-align: center;">4362</td>
<td style="text-align: center;">35213</td>
<td style="text-align: center;">$0 / 1.2 / 9$</td>
<td style="text-align: center;">11</td>
</tr>
<tr>
<td style="text-align: left;">Birds-Electricity-Ab</td>
<td style="text-align: center;">140</td>
<td style="text-align: center;">3940</td>
<td style="text-align: center;">$0 / 0.24 / 4$</td>
<td style="text-align: center;">4</td>
</tr>
</tbody>
</table>
<p>Table 11: Statistics for the Abduction datasets, giving the number of theories, abduction questions, number of missing facts per question and maximum proof depth.</p>
<h2>A. 2 Repairs to the RuleTaker Datasets</h2>
<p>The original RuleTaker theories were intended to be full Datalog theories, but contained three occasional violations in the with-negation theories:</p>
<ol>
<li>Some theories contained negated facts (e.g., "Bob is not red") and/or rules with negated conclusions. Such statements are redundant under a CWA, and not allowed according to formal Datalog specifications.</li>
<li>Some theories included rules with a free variable in a negated condition (e.g., "If someone is not blue then Bob is happy."). Such rules are not allowed according to formal Datalog specifications, as the possible groundings of the variable require meta-information about the theory as a whole.</li>
<li>A bug in the stratification checker led to a few theories being included that were not stratifiable, and hence may have multiple, valid truth assignments for their facts.
As a result, the theories were regenerated (with the same distribution over number of facts, rules, condition, etc.) to create the $\mathrm{D}^{*}(\mathrm{CWA})$ datasets, avoiding these issues.</li>
</ol>
<p>The $\mathrm{D}^{<em>}(\mathrm{OWA})$ datasets are similar to the $\mathrm{D}^{</em>}$ (orig) datasets, but evaluated without a CWA, i.e., negation-as-failure (NAF) is replaced with hard negation. The theories with negation were again regenerated to ensure they were stratifiable (to avoid negation cycles), but they still retain negated facts and rule conclusions. The truth values of the questions were recomputed using an OWA, resulting in answers True/False/Unknown.</p>
<h2>A. 3 The Birds-Electricity Datasets</h2>
<p>The RuleTaker "birds" rulebase is a well-known logic problem illustrating the use of "abnormality" predicates (McCarthy, 1984), ${ }^{7}$, and converted into English by hand. The dataset contains a single theory of six rules (e.g., "If someone is a bird and wounded then they are abnormal.") and seven facts (e.g., "Bill is wounded"), and forty questions against this theory (i.e., 40 test examples total). Birds1 and Birds2 differ solely in the English wording (e.g., "Bill is flying" vs. "Bill can fly").</p>
<p><sup id="fnref5:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Answer</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Proof</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;"># qns</td>
<td style="text-align: center;">PRo</td>
<td style="text-align: center;">ProofWriter</td>
<td style="text-align: center;">PRo</td>
<td style="text-align: center;">ProofWriter</td>
</tr>
<tr>
<td style="text-align: left;">$\mathrm{D}=0$</td>
<td style="text-align: center;">2968</td>
<td style="text-align: center;">99.7</td>
<td style="text-align: center;">99.9</td>
<td style="text-align: center;">99.4</td>
<td style="text-align: center;">99.9</td>
</tr>
<tr>
<td style="text-align: left;">1</td>
<td style="text-align: center;">2406</td>
<td style="text-align: center;">98.6</td>
<td style="text-align: center;">99.3</td>
<td style="text-align: center;">97.3</td>
<td style="text-align: center;">99.3</td>
</tr>
<tr>
<td style="text-align: left;">2</td>
<td style="text-align: center;">1443</td>
<td style="text-align: center;">98.2</td>
<td style="text-align: center;">98.3</td>
<td style="text-align: center;">88.7</td>
<td style="text-align: center;">97.7</td>
</tr>
<tr>
<td style="text-align: left;">3</td>
<td style="text-align: center;">1036</td>
<td style="text-align: center;">96.5</td>
<td style="text-align: center;">98.2</td>
<td style="text-align: center;">89.9</td>
<td style="text-align: center;">96.5</td>
</tr>
<tr>
<td style="text-align: left;">4</td>
<td style="text-align: center;">142</td>
<td style="text-align: center;">88.0</td>
<td style="text-align: center;">91.5</td>
<td style="text-align: center;">76.1</td>
<td style="text-align: center;">83.1</td>
</tr>
<tr>
<td style="text-align: left;">All</td>
<td style="text-align: center;">8008</td>
<td style="text-align: center;">98.4</td>
<td style="text-align: center;">99.1</td>
<td style="text-align: center;">95.1</td>
<td style="text-align: center;">98.5</td>
</tr>
</tbody>
</table>
<p>Table 12: [Task 1: Proof Generation] Train on D3 + ParaRules, test on (only) ParaRules. Both systems demonstrate robustness to more complex linguistic expressions in the theories, with ProofWriter obtaining $3 \%$ higher proof correctness.</p>
<p>The four RuleTaker "electricity" datasets contain examples of reasoning about toy electrical cicuits using a small set of general rules about circuits. Examples in each dataset are built using a fixed set of general rules per dataset, ranging from five rules (Elec1) to twelve rules (Elec4). Each example in these datasets contains the general rules, plus between two and five facts describing a particular circuit, with a set of questions about the circuit, e.g., Q: "The light bulb is glowing?" A: True.</p>
<h2>A. 4 The ParaRules Dataset</h2>
<p>The RuleTaker "ParaRules" dataset contains 40k questions against 2 k theories expressed in paraphrased natural language, obtained by having crowdworkers rephrase the templated English facts and rules from sampled original theories into more varied natural language. For example, "Bob is cold." might be rephrased "In the snow sits Bob, crying from being cold"; or "Alan is round. Alan is blue. Alan is kind." might be rephrased "Alan, who is round and also kind, tends to be rather blue"; or "If someone is kind then they are young." might be rephrased "A kind person will certainly be young.". While the previous datasets contain synthetic language, ParaRules tests the models' ability to reason over more human-like paraphrased language.</p>
<h2>B Additional Results</h2>
<h2>B. 1 Results on the OOD ParaRules Dataset</h2>
<p>We also test the robustness of ProofWriter's proof generation to theories that use more varied natural language, summarized in Section 5.1.2. Following (Clark et al., 2020) and (Saha et al., 2020), we train on the combined training partitions of D3(orig) and ParaRules, then test on the ParaRules test partition. The results in Table 12 show that PRover and ProofWriter (All-At-Once) are robust to more com-</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Test Dataset:</th>
<th style="text-align: center;"># qns</th>
<th style="text-align: center;">F1</th>
<th style="text-align: center;">Acc</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Birds1-Ab</td>
<td style="text-align: center;">14</td>
<td style="text-align: center;">100.00</td>
<td style="text-align: center;">100.00</td>
</tr>
<tr>
<td style="text-align: left;">Birds2-Ab</td>
<td style="text-align: center;">14</td>
<td style="text-align: center;">100.00</td>
<td style="text-align: center;">100.00</td>
</tr>
<tr>
<td style="text-align: left;">Elec1-Ab</td>
<td style="text-align: center;">114</td>
<td style="text-align: center;">89.47</td>
<td style="text-align: center;">89.47</td>
</tr>
<tr>
<td style="text-align: left;">Elec2-Ab</td>
<td style="text-align: center;">126</td>
<td style="text-align: center;">90.25</td>
<td style="text-align: center;">88.89</td>
</tr>
<tr>
<td style="text-align: left;">Elec3-Ab</td>
<td style="text-align: center;">456</td>
<td style="text-align: center;">81.79</td>
<td style="text-align: center;">76.32</td>
</tr>
<tr>
<td style="text-align: left;">Elec4-Ab</td>
<td style="text-align: center;">3216</td>
<td style="text-align: center;">85.77</td>
<td style="text-align: center;">83.99</td>
</tr>
<tr>
<td style="text-align: left;">All</td>
<td style="text-align: center;">3940</td>
<td style="text-align: center;">85.66</td>
<td style="text-align: center;">83.53</td>
</tr>
</tbody>
</table>
<p>Table 13: [Task 3: Abduction] Zero-shot scores of the D3-Ab model on the Birds-Electricity-Ab rulebases.
plex natural language in the input, with ProofWriter obtaining $3 \%$ higher proof correctness.</p>
<h2>B. 2 Abduction: Generalization to New Tasks</h2>
<p>Section 5.5.2 summarized the results of testing abductive reasoning on abductive versions of the Birds-Electricity(OWA) theories. The detailed results are shown in Table 13, showing perfect zeroshot performance for the simple Birds rulebases, but progressively reduced performance for the Electricity theories as they get more complex. This indicates that the abductive task remains only partially solved by our generative model.</p>
<h2>C Results with T5-large</h2>
<p>In the main part of the paper we trained ProofWriter starting from the largest available T5-11B model (11 billion parameters). If we instead use the more manageable T5-large model ( 770 million parameters), the scores generally go down, but typically by a small amount.</p>
<p>In Tables 14 and 15 we show two examples of this, for the All-At-Once and Iterative ProofWriter models respectively, when training on the D3 dataset and evaluating on D5. We see the T5-large model is a bit worse on higher depth proof accuracy in the All-At-Once model, but is otherwise quite competitive.</p>
<h2>D Hyperparameters and I/O Examples</h2>
<p>We fine-tune the models on the training set using the default hyperparameters (including the Adafactor optimizer) in the T5 library. ${ }^{8}$ We use the largest T5-11B model for the main results, fine-tuned for 40k steps (batch size 8), selecting the checkpoint with highest validation score (usually the final step). See Appendix C for results using the smaller T5large.</p>
<p><sup id="fnref6:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: center;">Answer</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Proof</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;">CWA</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">OWA</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">CWA</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">OWA</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">Depth</td>
<td style="text-align: center;">large</td>
<td style="text-align: center;">11 B</td>
<td style="text-align: center;">large</td>
<td style="text-align: center;">11 B</td>
<td style="text-align: center;">large</td>
<td style="text-align: center;">11 B</td>
<td style="text-align: center;">large</td>
<td style="text-align: center;">11 B</td>
</tr>
<tr>
<td style="text-align: left;">N/A</td>
<td style="text-align: center;">98.4</td>
<td style="text-align: center;">99.6</td>
<td style="text-align: center;">97.4</td>
<td style="text-align: center;">99.4</td>
<td style="text-align: center;">98.4</td>
<td style="text-align: center;">99.6</td>
<td style="text-align: center;">97.4</td>
<td style="text-align: center;">99.4</td>
</tr>
<tr>
<td style="text-align: left;">0</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
</tr>
<tr>
<td style="text-align: left;">1</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">99.9</td>
<td style="text-align: center;">99.9</td>
<td style="text-align: center;">99.9</td>
<td style="text-align: center;">99.4</td>
<td style="text-align: center;">99.7</td>
<td style="text-align: center;">99.3</td>
<td style="text-align: center;">99.8</td>
</tr>
<tr>
<td style="text-align: left;">2</td>
<td style="text-align: center;">99.8</td>
<td style="text-align: center;">99.4</td>
<td style="text-align: center;">99.7</td>
<td style="text-align: center;">99.8</td>
<td style="text-align: center;">97.5</td>
<td style="text-align: center;">98.2</td>
<td style="text-align: center;">97.6</td>
<td style="text-align: center;">98.8</td>
</tr>
<tr>
<td style="text-align: left;">3</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">99.2</td>
<td style="text-align: center;">99.7</td>
<td style="text-align: center;">99.8</td>
<td style="text-align: center;">90.4</td>
<td style="text-align: center;">93.4</td>
<td style="text-align: center;">91.2</td>
<td style="text-align: center;">94.5</td>
</tr>
<tr>
<td style="text-align: left;">4</td>
<td style="text-align: center;">98.9</td>
<td style="text-align: center;">95.4</td>
<td style="text-align: center;">99.5</td>
<td style="text-align: center;">99.3</td>
<td style="text-align: center;">38.6</td>
<td style="text-align: center;">69.9</td>
<td style="text-align: center;">46.9</td>
<td style="text-align: center;">71.4</td>
</tr>
<tr>
<td style="text-align: left;">5</td>
<td style="text-align: center;">92.3</td>
<td style="text-align: center;">72.9</td>
<td style="text-align: center;">98.9</td>
<td style="text-align: center;">93.7</td>
<td style="text-align: center;">12.4</td>
<td style="text-align: center;">27.4</td>
<td style="text-align: center;">24.4</td>
<td style="text-align: center;">35.1</td>
</tr>
<tr>
<td style="text-align: left;">All</td>
<td style="text-align: center;">98.4</td>
<td style="text-align: center;">96.6</td>
<td style="text-align: center;">98.7</td>
<td style="text-align: center;">99.0</td>
<td style="text-align: center;">83.4</td>
<td style="text-align: center;">88.9</td>
<td style="text-align: center;">85.6</td>
<td style="text-align: center;">90.2</td>
</tr>
</tbody>
</table>
<p>Table 14: [Task 1] Comparing T5-large vs T5-11B for the All-At-Once models trained on D3 and evaluated on D5. T5-large is actually a bit ahead of T5-11B on answer accuracy (for CWA), although the proof correctness is noticeably higher with T5-11B.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: center;">Answer</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Proof</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;">CWA</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">OWA</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">CWA</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">OWA</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">Depth</td>
<td style="text-align: center;">large</td>
<td style="text-align: center;">11 B</td>
<td style="text-align: center;">large</td>
<td style="text-align: center;">11 B</td>
<td style="text-align: center;">large</td>
<td style="text-align: center;">11 B</td>
<td style="text-align: center;">large</td>
<td style="text-align: center;">11 B</td>
</tr>
<tr>
<td style="text-align: left;">N/A</td>
<td style="text-align: center;">99.0</td>
<td style="text-align: center;">99.7</td>
<td style="text-align: center;">99.2</td>
<td style="text-align: center;">99.9</td>
<td style="text-align: center;">99.0</td>
<td style="text-align: center;">99.7</td>
<td style="text-align: center;">99.2</td>
<td style="text-align: center;">99.9</td>
</tr>
<tr>
<td style="text-align: left;">0</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">100</td>
</tr>
<tr>
<td style="text-align: left;">1</td>
<td style="text-align: center;">98.8</td>
<td style="text-align: center;">99.8</td>
<td style="text-align: center;">99.1</td>
<td style="text-align: center;">99.3</td>
<td style="text-align: center;">95.0</td>
<td style="text-align: center;">95.4</td>
<td style="text-align: center;">97.5</td>
<td style="text-align: center;">97.8</td>
</tr>
<tr>
<td style="text-align: left;">2</td>
<td style="text-align: center;">98.3</td>
<td style="text-align: center;">99.5</td>
<td style="text-align: center;">98.9</td>
<td style="text-align: center;">99.7</td>
<td style="text-align: center;">91.0</td>
<td style="text-align: center;">91.7</td>
<td style="text-align: center;">96.4</td>
<td style="text-align: center;">97.3</td>
</tr>
<tr>
<td style="text-align: left;">3</td>
<td style="text-align: center;">98.6</td>
<td style="text-align: center;">99.7</td>
<td style="text-align: center;">98.4</td>
<td style="text-align: center;">99.2</td>
<td style="text-align: center;">89.0</td>
<td style="text-align: center;">90.4</td>
<td style="text-align: center;">95.5</td>
<td style="text-align: center;">97.1</td>
</tr>
<tr>
<td style="text-align: left;">4</td>
<td style="text-align: center;">98.0</td>
<td style="text-align: center;">99.7</td>
<td style="text-align: center;">97.5</td>
<td style="text-align: center;">99.1</td>
<td style="text-align: center;">86.3</td>
<td style="text-align: center;">88.9</td>
<td style="text-align: center;">93.4</td>
<td style="text-align: center;">96.3</td>
</tr>
<tr>
<td style="text-align: left;">5</td>
<td style="text-align: center;">97.7</td>
<td style="text-align: center;">98.9</td>
<td style="text-align: center;">96.5</td>
<td style="text-align: center;">98.8</td>
<td style="text-align: center;">85.4</td>
<td style="text-align: center;">87.8</td>
<td style="text-align: center;">82.3</td>
<td style="text-align: center;">86.4</td>
</tr>
<tr>
<td style="text-align: left;">All</td>
<td style="text-align: center;">98.7</td>
<td style="text-align: center;">99.7</td>
<td style="text-align: center;">98.8</td>
<td style="text-align: center;">99.6</td>
<td style="text-align: center;">94.4</td>
<td style="text-align: center;">95.4</td>
<td style="text-align: center;">96.4</td>
<td style="text-align: center;">97.6</td>
</tr>
</tbody>
</table>
<p>Table 15: [Task 1] Comparing T5-large vs T5-11B for the Iterative ProofWriter trained on D0-D3 and evaluated on D5. T5-11B is systematically slightly better.</p>
<p>For all tasks in this paper, the model input and output are plain textual strings in a certain format. The format is slightly more verbose than strictly necessary, as it is compatible with a more general framework combining different views of the task. This is not typically an issue, although there are a few cases where the iterative model reaches the default 512 token limit of T5 when adding implications to the theory. We now show input/output examples for proof generation (All-At-Once and (one step of) the Iterative approaches), implication generation (All-At-Once approach; Iterative implication generation is a side-effect of Iterative proof generation), and abduction.</p>
<h2>D. 1 All-At-Once Proof Generation</h2>
<p>In this task we are given a theory and question, and need to produce an answer (True/False/Unknown) and proof with intermediates.
INPUT: \$answer\$ ; \$proof\$ ; \$question\$ = The lion is not nice? ; \$context\$ = sent1: The tiger chases the lion. sent2: The lion is not big. sent3: If something visits the dog and it is kind then it visits the mouse. sent4: The dog chases the lion. sent5: If something is big then it visits the dog. sent6: The tiger eats the dog. sent7: If something visits the tiger and the tiger is not red then it is not nice. sent8: If something chases
the dog then it is not red. sent9: The mouse does not chase the tiger. sent10: If something visits the mouse then the mouse is red. sent11: The tiger visits the lion. sent12: The tiger does not eat the mouse. sent13: The mouse is nice. sent14: The lion does not eat the tiger. sent15: If the tiger visits the dog and the dog is not big then the dog chases the mouse. sent16: The lion visits the tiger. sent17: If something chases the lion and it visits the dog then it chases the dog. sent18: The dog is nice. sent19: If something chases the lion then it is big. sent20: If something eats the lion then it is not cold.
OUTPUT: \$answer\$ = True ; \$proof\$ = # sent7@int1 \&amp; sent16 # sent8@int2 # sent17@int3 \&amp; sent1 # sent5@int4 # sent19@int5 sent1 ; with int1: The lion is not nice. ; int2: The tiger is not red. ; int3: The tiger chases the dog. ; int4: The tiger visits the dog. ; int5: The tiger is big.</p>
<p>If we translate back from Polish Notation, this proof corresponds to ((sent16 \&amp; ((((sent1 \&amp; ((sent1 $\rightarrow$ sent $19 \rightarrow$ int5) $\rightarrow$ sent5 $\rightarrow$ int4)) $\rightarrow$ sent $17 \rightarrow$ int3)) $\rightarrow$ sent $8 \rightarrow$ int2)) $\rightarrow$ sent $7 \rightarrow$ int1)</p>
<h2>D. 2 Iterative Proof Generation (one step)</h2>
<p>In this task we ask the model to generate one valid implication of the theory with proof of depth 1. If no such implication exists, instead generate "None" as the answer.
INPUT: \$answer\$ ; \$proof\$ ; \$question\$ = What is one singlehop inference? ; \$context\$ = sent1: If something eats the cow and it is big then the cow sees the bald eagle. sent2: If something likes the bald eagle then it is rough. sent3: If something eats the dog then it likes the cow. sent4: Big things are young. sent5: If something likes the cow then it eats the cow. sent6: If something sees the bald eagle then the bald eagle eats the cow. sent7: If something likes the bald eagle then the bald eagle is kind. sent8: If something sees the bald eagle then the bald eagle eats the dog. sent9: The bald eagle eats the cow. sent10: The bald eagle sees the dog. sent11: The dog is big. sent12: The cow likes the bald eagle. sent13: The bald eagle is young. sent14: The dog sees the cow. sent15: The bald eagle is kind. sent16: The dog is young. sent17: The bald eagle sees the cow. sent18: The bald eagle is rough. sent19: The cow eats the bald eagle. sent20: The dog is cold. sent21: The dog likes the cow. sent22: The dog eats the bald eagle. sent23: The dog eats the cow. sent24: The bald eagle likes the dog. sent25: The bald eagle likes the cow. sent26: The cow sees the bald eagle. sent27: The cow sees the dog. OUTPUT: \$answer\$ = The cow is rough. ; \$proof\$ = # sent2 sent12</p>
<p>During evaluation time, we would then take this output and append it to the theory as "sent28: The cow is rough." and repeat the question. If a subsequent proof then references "sent28", we know already that this was derived using the proof "# sent2 sent12".</p>
<h2>D. 3 All-At-Once Implication Enumeration</h2>
<p>In this task we ask the model to simply output all valid implications of a theory, without generations proofs in this case.</p>
<p>INPUT: \$answer\$ ; \$proof\$ ; \$question\$ = What are all the inferences? ; \$context\$ = sent1: The tiger chases the lion. sent2: The lion is not big. sent3: If something visits the dog and it is kind then it visits the mouse. sent4: The dog chases the lion. sent5: If something is big then it visits the dog. sent6: The tiger eats the dog. sent7: If something visits the tiger and the tiger is not red then it is not nice. sent8: If something chases the dog then it is not red. sent9: The mouse does not chase the tiger. sent10: If something visits the mouse then the mouse is red. sent11: The tiger visits the lion. sent12: The tiger does not eat the mouse. sent13: The mouse is nice. sent14: The lion does not eat the tiger. sent15: If the tiger visits the dog and the dog is not big then the dog chases the mouse. sent16: The lion visits the tiger. sent17: If something chases the lion and it visits the dog then it chases the dog. sent18: The dog is nice. sent19: If something chases the lion then it is big. sent20: If something eats the lion then it is not cold.
OUTPUT: \$answer\$ = The dog is big. The tiger is big. The dog visits the dog. The tiger visits the dog. The dog chases the dog. The tiger chases the dog. The dog is not red. The tiger is not red. The lion is not nice.</p>
<p>This particular theory has 9 valid implications, around average for D5 theories. (The number of implications can be as high as 21).</p>
<h1>D. 4 Iterative Implication Enumeration</h1>
<p>Iterative implication generation is a side-effect of Iterative proof generation, hence the input/output (one step) is the same as in Appendix D.2.</p>
<h2>D. 5 Abduction</h2>
<p>In this task we ask the model to output all alternative missing facts, separated by a comma, that can be (separately) added to a theory so as to prove the given implication to be True.
INPUT: \$answer\$ ; \$question\$ = Dave is rough. ; \$context\$ = triple1: Anne is white. triple2: Charlie is young. triple3: Dave is round. triple4: Erin is quiet. rule1: If someone is rough and young then they are blue. rule2: Rough, white people are smart. rule3: All smart people are rough. rule4: All white people are smart. rule5: If someone is young then they are smart. rule6: All smart people are rough.
OUTPUT: \$answer\$ = Dave is young. , Dave is smart.
This particular abduction question has 2 alternative missing facts. Any one of them when added to the input theory is sufficient to prove the implication 'Dave is rough'.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{8}$ https://github.com/google-research/text-to-text-transfertransformer&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref5:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref6:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:1">
<p>${ }^{4}$ The domain is small enough that all proofs can be enumerated. However, there still can be a large number, e.g., some D5 questions have over 3000 possible proofs.&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>