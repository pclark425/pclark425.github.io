<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-1649 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-1649</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-1649</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-31.html">extraction-schema-31</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <p><strong>Paper ID:</strong> paper-251162204</p>
                <p><strong>Paper Title:</strong> Simplification of genetic programs: a literature survey</p>
                <p><strong>Paper Abstract:</strong> Genetic programming (GP), a widely used evolutionary computing technique, suffers from bloat—the problem of excessive growth in individuals’ sizes. As a result, its ability to efficiently explore complex search spaces reduces. The resulting solutions are less robust and generalisable. Moreover, it is difficult to understand and explain models which contain bloat. This phenomenon is well researched, primarily from the angle of controlling bloat: instead, our focus in this paper is to review the literature from an explainability point of view, by looking at how simplification can make GP models more explainable by reducing their sizes. Simplification is a code editing technique whose primary purpose is to make GP models more explainable. However, it can offer bloat control as an additional benefit when implemented and applied with caution. Researchers have proposed several simplification techniques and adopted various strategies to implement them. We organise the literature along multiple axes to identify the relative strengths and weaknesses of simplification techniques and to identify emerging trends and areas for future exploration. We highlight design and integration challenges and propose several avenues for research. One of them is to consider simplification as a standalone operator, rather than an extension of the standard crossover or mutation operators. Its role is then more clearly complementary to other GP operators, and it can be integrated as an optional feature into an existing GP setup. Another proposed avenue is to explore the lack of utilisation of complexity measures in simplification. So far, size is the most discussed measure, with only two pieces of prior work pointing out the benefits of using time as a measure when controlling bloat.</p>
                <p><strong>Cost:</strong> 0.022</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e1649.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e1649.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>GP</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Genetic Programming</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Evolutionary computation technique that evolves entire computer programs (often tree-based) via populations, fitness evaluation, crossover and mutation to solve optimisation and program synthesis tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Genetic programming: on the programming of computers by means of natural selection</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Genetic Programming (tree-based)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Population-based evolutionary method that represents candidate solutions as program trees; new solutions are generated each generation by selecting parents according to fitness and producing offspring via crossover (subtree exchange) and mutation (subtree replacement, hoist, etc.), with optional simplification/post-processing to control bloat and improve interpretability.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Standard tree-based crossover: select a subtree in parent A and a subtree in parent B and swap them to create two offspring (subtree-exchange crossover). Variants exist (size-fair, homologous) that constrain chosen subtrees to control offspring size.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Standard subtree mutation: replace a randomly chosen subtree with a newly generated random subtree; other mutation variants include point/no-op mutation, silencing/NOOPing genes, cut/hoist (copying or removing subtrees) and size-biased mutation operators.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Generally discussed qualitatively (genotypic and phenotypic diversity); some approaches (operator equalisation) work on size-distribution rather than explicit numeric diversity metric.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Paper discusses conceptually that exploration (novelty) comes from crossover/mutation randomness while simplification operators reduce search novelty and may hurt diversity/exploration; no quantitative curve provided.</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>General (symbolic regression, classification, program synthesis, data-mining tasks)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Various GP variants (standard crossover/mutation, size-fair/homologous crossover, simplification-enabled GP)</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Crossover and mutation are the primary stochastic operators generating novelty and diversity; unmodified they can cause bloat and produce non-executable or excessively large programs; many variants constrain subtree sizes or bias operations to control bloat while preserving exploration.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Simplification of genetic programs: a literature survey', 'publication_date_yy_mm': '2022-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1649.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e1649.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Crossover (tree-based)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Tree-based Crossover Operator</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Operator combining genetic material from two parent program trees by exchanging subtrees to create offspring, subject to variants that control size and structure.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Tree-based crossover</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Select a crossover point (a node/subtree) in each of two parent trees and swap the subtrees, producing two offspring; variants include size-fair and homologous crossovers that constrain subtree size or alignment to maintain size distribution or semantic locality.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Subtree exchange between two parents as described; can be modified to pick points with matched subtree sizes (size-fair) or homologous positions to avoid dramatic structural changes.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Implicitly contributes to genotypic and phenotypic diversity; some studies evaluate effects on building-block disruption but no standard numeric metric is specified in the survey.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Survey notes that crossover's randomness produces novelty but may increase bloat and disrupt building blocks; size-aware crossover variants trade some novelty for better size control and reduced bloat.</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>General GP domains</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Standard subtree crossover vs size-fair and homologous variants</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Unconstrained subtree crossover can increase program size and harm interpretability; size-fair/homologous crossovers are effective at limiting size growth while still producing offspring, reducing bloat at the cost of restricting some exploratory moves.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Simplification of genetic programs: a literature survey', 'publication_date_yy_mm': '2022-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1649.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e1649.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Mutation (tree-based)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Tree-based Mutation Operator</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Operator that perturbs an individual by replacing or modifying a randomly chosen subtree or instruction, generating variation and enabling exploration.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Tree-based mutation</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Randomly select a node/subtree in the parent program and replace it with a new randomly generated subtree (or apply specialized mutations like hoist, NOOP insertion, silencing genes), with probability typically lower than crossover; can be size-aware (size-fair) or biased to reduce bloat.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Subtree replacement (randomly generated subtree), hoist (replace root by a randomly chosen subtree), uniform-subtree mutation (mutations proportional to tree size), size-fair mutation that maintains size distribution.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Contributes to genotypic diversity; variants can be tuned to preserve diversity vs control bloat (qualitative discussion).</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Mutation increases novelty but can add introns/bloat; size-aware mutation reduces growth and preserves executability/readability while reducing some exploratory capacity.</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>General GP domains</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Standard subtree mutation vs hoist/size-fair/uniform variants</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Mutation is essential for exploration; modifications to mutation to be size-aware or semantic-aware can reduce bloat and improve interpretability but may reduce the raw novelty generated by fully random mutations.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Simplification of genetic programs: a literature survey', 'publication_date_yy_mm': '2022-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1649.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e1649.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Hoist</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Hoist Mutation / Modified Single Crossover</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Operator that replaces a tree by a copy of one of its subtrees (hoisting), effectively shortening individuals and sometimes used as a mutation or crossover variant to control size.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Evolving a sort: Lessons in genetic programming</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Hoist operator</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Select a subtree within an individual and replace the entire individual (or a larger context) with that subtree (hoisting), acting like a destructive mutation that tends to reduce depth/size and can rescue useful smaller building blocks.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Described as a modified single-point crossover where a subtree copy is used; can be interpreted as crossover-like when applied between individuals by copying subtrees.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Hoist selection is applied as a mutation that replaces an ancestor node by one of its descendants (a subtree), reducing size and potentially removing introns.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Hoist reduces size/excess code improving interpretability and executability potential but can reduce search diversity by collapsing structure.</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>General GP problems</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Standard mutation/crossover</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Hoist tends to produce smaller trees and can help control bloat while preserving or exposing compact building blocks; it is a commonly used size-reduction mutation variant.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Simplification of genetic programs: a literature survey', 'publication_date_yy_mm': '2022-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1649.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e1649.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Size-fair crossover</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Size-fair and Homologous Tree Crossover</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Crossover variants that choose crossover points so offspring subtree sizes are controlled or matched, limiting program size growth.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Size fair and homologous tree crossovers for tree genetic programming</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Size-fair/homologous crossover</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Crossover that selects a crossover point in the first parent, measures the subtree size, then selects a point in the second parent whose subtree size matches (or aligns homologously) so that exchanged subtrees produce offspring with controlled or similar sizes.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Matched-size subtree exchange: pick subtree in parent A, find subtree in B with similar size (or homologous position) and swap, thereby constraining size changes.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Aims to preserve size-distribution rather than maximize novelty; impacts genotypic diversity by limiting large structural changes.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Size-fair crossover trades off some radical structural novelty for control over bloat and more predictable executability/interpretability of offspring.</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Tree-based GP</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Standard subtree crossover</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Effective at preventing offspring size explosion and controlling bloat while still enabling recombination; reduces building-block disruption compared to unconstrained crossover.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Simplification of genetic programs: a literature survey', 'publication_date_yy_mm': '2022-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1649.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e1649.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Uniform Subtree Mutation</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Uniform Subtree Mutation</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Mutation operator that applies subtree mutations proportional to tree size, following a binomial distribution, to maintain size-related mutation rates.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Uniform subtree mutation</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Uniform Subtree Mutation</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Mutation scheme where the probability of mutating a node/subtree is proportional to tree size; multiple mutation locations may be selected according to a binomial model, yielding mutations better matched to tree-scale.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Select mutation points across the tree with probabilities proportional to size (binomial distribution over nodes), replace selected subtrees with random subtrees.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Designed to maintain expected mutation effects across sizes; qualitatively impacts genotypic diversity control.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Aims to balance introducing novelty while preventing large destructive edits on very large trees (mitigating negative impacts on executability and bloat).</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Tree-based GP</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Standard single-point/subtree mutation</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Provides a principled mutation rate that scales with individual size, helping avoid overwhelming large programs with too many changes and controlling bloat.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Simplification of genetic programs: a literature survey', 'publication_date_yy_mm': '2022-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1649.6">
                <h3 class="extraction-instance">Extracted Data Instance 6 (e1649.6)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Operator Equalisation</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Operator Equalisation (population-based bloat control)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Population-level technique that maintains a target distribution of program sizes by grouping individuals into size buckets and controlling reproduction to match bucket capacities.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Operator equalisation and bloat free GP</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Operator Equalisation</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Group individuals by size into buckets and control acceptance of newly generated individuals to maintain a desired distribution over sizes (fixed or adaptive capacities), thereby preventing unchecked growth of program lengths.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Used in conjunction with standard crossover/mutation; the operator equalisation mechanism filters or accepts offspring based on maintaining the size-distribution.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Same—mutation produces variants but acceptance depends on bucket capacities; operator equalisation does not change mutation mechanism but its selection/acceptance.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Indirect control of population size-distribution; seeks to preserve diversity across sizes (a form of genotypic diversity control).</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Maintains diversity of sizes to avoid dominance of large individuals; may limit extreme novelty in size growth but preserves exploration across size bands.</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>General GP</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Unconstrained GP and other bloat-control techniques</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Shifts focus from per-individual control to population distribution control; effective at limiting bloat while allowing exploration across size buckets.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Simplification of genetic programs: a literature survey', 'publication_date_yy_mm': '2022-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1649.7">
                <h3 class="extraction-instance">Extracted Data Instance 7 (e1649.7)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Ekart mutation</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Ekart's Fitness-preserving Simplification / Mutation</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Mutation-like operator that applies algebraic simplification rules to remove nonfunctional code (introns) while preserving semantics and fitness.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Shorter fitness preserving genetic programs</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Ekart simplification-mutation</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Identify algebraic simplifications that preserve semantics and apply them as a mutation-like operator to replace complex expressions with simpler equivalents, effectively removing introns while keeping fitness constant.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Deterministic semantic-preserving edits: apply pre-defined algebraic simplification rules to nodes/subtrees (acts like a mutation but preserves fitness).</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Preserves executability/fitness while reducing size; reduces syntactic novelty but improves interpretability without harming performance.</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>GP simplification</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Standard GP without algebraic simplification</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Shows that semantic-preserving simplifications can remove nonfunctional code (introns) and reduce program size while maintaining fitness, acting as a specialized mutation.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Simplification of genetic programs: a literature survey', 'publication_date_yy_mm': '2022-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1649.8">
                <h3 class="extraction-instance">Extracted Data Instance 8 (e1649.8)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Algebraic simplification</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Algebraic (rule-based) simplification of GP programs</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Exact simplification approach using domain-specified algebraic rules (e.g., A*0 -> 0) to replace subexpressions with smaller semantically equivalent expressions.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Algebraic simplification of GP programs during evolution</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Algebraic (rule-based) simplification</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Apply a pre-defined set of algebraic transformation rules to expression trees to replace matched subexpressions by smaller, semantically equivalent forms; can be applied online (every k generations) or offline to final solutions.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Qualitatively affects building blocks; may disrupt syntactic building blocks while producing new ones (building-block analysis discussed).</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Preserves semantics (thus executability) while removing syntactic novelty; can disrupt building blocks and thereby affect evolutionary search trajectories.</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Symbolic regression and other algebraic-expression tasks</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>GP without algebraic simplification</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Algebraic simplification reduces size without harming semantics; when applied too frequently it can slow evolution and disturb building blocks, so trade-offs in application frequency exist.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Simplification of genetic programs: a literature survey', 'publication_date_yy_mm': '2022-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1649.9">
                <h3 class="extraction-instance">Extracted Data Instance 9 (e1649.9)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Numerical simplification</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Numerical contribution-based simplification</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Exact simplification technique that estimates numerical contribution of subtrees to parents across training cases and prunes or replaces subtrees whose contribution is below thresholds.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Using numerical simplification to control bloat in genetic programming</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Numerical simplification</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Compute contribution of child nodes/subtrees to parent outputs over training examples (e.g., via linear regression or range checks); if contribution is negligible or variance small, replace subtree by constant or remove it, accepting modifications if error below threshold.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Acts like a deterministic destructive mutation: prune or replace subtrees based on low numerical contribution; proposals can be accepted based on MSE thresholds.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Semantic fidelity measured as mean squared error (MSE) between original and simplified program outputs on training/validation points; acceptance thresholds used.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Discussed in terms of building-block effects; numerical simplification can change the building-block distribution and thus affect genotypic/phenotypic diversity.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Removes numerically-insignificant code improving executability/interpretability with controlled loss in fidelity (thresholded by MSE); tradeoff managed by acceptance thresholds.</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Symbolic regression and numeric GP tasks</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Algebraic and semantic simplification approaches</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Numerical pruning can effectively shrink trees and control bloat while preserving performance within thresholds; choice of contribution thresholds is application-dependent.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Simplification of genetic programs: a literature survey', 'publication_date_yy_mm': '2022-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1649.10">
                <h3 class="extraction-instance">Extracted Data Instance 10 (e1649.10)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Fitness-based simplification / Pruning</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Fitness-based destructive simplification / Pruning</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Approximate simplification family that proposes removing/replacing subtrees (or silencing genes) and accepts the change if fitness does not degrade (or improves), akin to destructive mutation tested by fitness.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Fitness-based simplification / pruning</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Randomly or systematically propose destructive edits (prune branches, replace with terminals/constants, NOOP or silence genes), evaluate the modified program's fitness and retain the change if fitness is not worse (or improved); can be iterative and applied top-down or bottom-up.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Destructive edits replacing subtrees with terminals, constant replacements, NOOP or gene silencing; proposals evaluated by fitness comparisons (acts like selective mutation).</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Fitness comparison (problem-specific fitness measures, e.g., accuracy, MSE) used as acceptance criterion; may use validation sets for corroboration.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>May reduce phenotypic/genotypic diversity if applied globally; some authors prune only selected individuals to limit diversity loss.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Fitness-based pruning explicitly trades off syntactic novelty for fitness-preserving compactness; aggressive pruning can reduce diversity and harm later search.</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>PushGP, symbolic regression, dispatching rule design, general GP tasks</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>GP without pruning, algebraic/numerical/semantic simplification</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Pruning via fitness checks can produce smaller solutions while maintaining or improving generalisation, but must be applied carefully (e.g., on a subset of individuals, intermittently) to avoid loss of diversity and premature convergence.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Simplification of genetic programs: a literature survey', 'publication_date_yy_mm': '2022-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1649.11">
                <h3 class="extraction-instance">Extracted Data Instance 11 (e1649.11)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Semantics-based substitution</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Semantics-based (semantic-approximation) substitution/simplification</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Approximate simplification approach that replaces subtrees with smaller subtrees or terminals chosen to match (approximately) the original subtree's semantics on a set of input points, often using libraries or generated approximations.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Semantic approximation for reducing code bloat in genetic programming</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Semantics-based simplification/substitution</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Compute a target semantics (output vector on regression points) for a subtree and replace it with a smaller subtree or terminal whose semantics approximates the target (via library lookup or by growing a small approximating subtree); accept replacements based on semantic similarity (e.g., MSE) possibly using validation.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Acts like a guided mutation where replacement is chosen to match semantics rather than at random; can use a small search to grow approximate subtree replacements.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Semantic similarity measured over regression points via MSE or other distance metrics; acceptance thresholds applied.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>By replacing subtrees with semantically similar but smaller ones, may reduce syntactic diversity while preserving phenotypic behaviour; impact on diversity must be managed.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Provides small-size replacements that preserve phenotype (executability) at cost of reducing syntactic novelty; computationally expensive but effective at finding compact semantically-equivalent variants.</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Symbolic regression and GP tasks requiring semantic fidelity</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Algebraic and numerical simplification approaches</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Semantic substitution can find compact replacements that are functionally similar, enabling better interpretability and often maintaining generalisation, but is computationally intensive and problem-dependent.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Simplification of genetic programs: a literature survey', 'publication_date_yy_mm': '2022-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1649.12">
                <h3 class="extraction-instance">Extracted Data Instance 12 (e1649.12)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Generation-wide simplification (Gws)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Generation-wide simplification via Rupturing (Gws)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Population-level simplification where individuals are 'ruptured' to produce the power set of their subcomponents as offspring and the fittest unique children are selected to form the next generation, replacing standard crossover/mutation at those epochs.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>On-the-fly simplification of genetic programming models</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Generation-wide simplification (Gws) / Rupturing</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Every k generations, replace standard reproduction by rupturing each individual to produce many offspring (members of the parent's power set of components), enforce uniqueness, then select the fittest individuals (or top-N) to populate the next generation; semantics may change so this is approximate simplification.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>During Gws epochs, standard crossover/mutation is suspended or limited; offspring result from combinatorial rupturing of a single parent rather than recombination of two parents.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Rupturing acts akin to exhaustive pruning/combination within a parent rather than random mutation; consequently, explicit mutation may be deprioritised at Gws steps.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Selection still uses fitness; semantics may differ between parent and children and acceptance based on fitness leads to executability preserved by selection rather than semantic-preservation rules.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Uniqueness constraint is enforced to avoid genetic duplicates (genotypic uniqueness); may reduce redundancy but has potential to reduce diversity if many parents produce similar children.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Gws aggressively explores simplified subsets of parents which can improve compactness/executability for selected individuals but risks reducing population diversity and exploration; authors recommend combining with standard operators when offspring count insufficient.</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>GP generally; proposed by Javed & Gobet (2021)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Standard GP with crossover/mutation and other simplification techniques</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Population-wide rupturing can produce many simplified children and reduce mean tree sizes while retaining fitness-based selection, but it can risk reducing diversity and altering evolutionary trajectories; uniqueness and selection heuristics are necessary to manage population composition.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Simplification of genetic programs: a literature survey', 'publication_date_yy_mm': '2022-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1649.13">
                <h3 class="extraction-instance">Extracted Data Instance 13 (e1649.13)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>PushGP simplification operators</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>PushGP simplification (gene silencing, NOOP, pruning)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Simplification operators designed for PushGP that act at the genotype level by silencing genes, replacing with NOOP instructions, or pruning instructions to reduce expression without necessarily altering genotype structure radically.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Improving generalization of evolved programs through automatic simplification</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>PushGP simplification operators</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>In PushGP (stack-based language), simplification operators include silencing genes (prevent expression of a gene in phenotype), replacing genes with NOOPs (instructions that do nothing on execution), and iterative pruning of instructions followed by fitness comparison; these act like genotype-level destructive mutations aimed at simplification and generalisation improvement.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Simplification acts as iterative destructive genotype edits (silence/NOOP/prune) evaluated by fitness; works complementarily with PushGP's regular crossover/mutation.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Fitness on problem tasks used to accept simplifications; simplifications aim to improve generalisation on validation/test sets.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Pruning can reduce expressed phenotypic diversity while preserving genotypic material (silenced genes remain available), which can help exploration without immediate loss of genetic variation.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Silencing/NOOP keeps genotypic novelty available while reducing current phenotype complexity (improving executability/interpretability) — a design to balance novelty retention and immediate simplification.</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>PushGP / program synthesis tasks</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>PushGP without simplification</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>PushGP-specific simplification operators can reduce overfitting and improve generalisation by removing or deactivating nonessential instructions; genotype-level silencing offers a way to retain raw genetic novelty while simplifying expressed behaviour.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Simplification of genetic programs: a literature survey', 'publication_date_yy_mm': '2022-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1649.14">
                <h3 class="extraction-instance">Extracted Data Instance 14 (e1649.14)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Pruning via permutation tests</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Pruning of GP trees using permutation tests</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A statistical approach proposing pruning based on measuring the contribution of a subtree via permutation tests and validating the effect on parental output using a validation set.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Pruning of genetic programming trees using permutation tests</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Permutation-test-based pruning</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Propose candidate prunes by estimating subtree contribution, then use a permutation test to assess whether pruning significantly affects parent's outputs; validations on held-out data corroborate acceptance, providing a statistically principled pruning operator.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Prune proposals act like destructive mutations whose acceptance is determined by permutation-test significance and validation-set corroboration.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Statistical significance (permutation test p-values) and validation-set fitness comparisons used to judge acceptability of prunes.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Provides a conservative pruning mechanism that aims to preserve executability/performance (statistically validated) while reducing size; tradeoff controlled by significance thresholds.</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>GP simplification/pruning</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Other pruning/simplification heuristics</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Statistical testing provides a principled acceptance criterion for pruning proposals, helping avoid harmful simplifications while reducing bloat when prunes are statistically non-significant.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Simplification of genetic programs: a literature survey', 'publication_date_yy_mm': '2022-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Shorter fitness preserving genetic programs <em>(Rating: 2)</em></li>
                <li>Evolving a sort: Lessons in genetic programming <em>(Rating: 2)</em></li>
                <li>Size fair and homologous tree crossovers for tree genetic programming <em>(Rating: 2)</em></li>
                <li>Uniform subtree mutation <em>(Rating: 2)</em></li>
                <li>Operator equalisation and bloat free GP <em>(Rating: 2)</em></li>
                <li>Algebraic simplification of GP programs during evolution <em>(Rating: 2)</em></li>
                <li>Using numerical simplification to control bloat in genetic programming <em>(Rating: 2)</em></li>
                <li>Improving generalization of evolved programs through automatic simplification <em>(Rating: 2)</em></li>
                <li>On-the-fly simplification of genetic programming models <em>(Rating: 2)</em></li>
                <li>Pruning of genetic programming trees using permutation tests <em>(Rating: 2)</em></li>
                <li>Contribution based bloat control in genetic programming <em>(Rating: 1)</em></li>
                <li>Effective simplification of evolved push programs using a simple, stochastic hill-climber <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-1649",
    "paper_id": "paper-251162204",
    "extraction_schema_id": "extraction-schema-31",
    "extracted_data": [
        {
            "name_short": "GP",
            "name_full": "Genetic Programming",
            "brief_description": "Evolutionary computation technique that evolves entire computer programs (often tree-based) via populations, fitness evaluation, crossover and mutation to solve optimisation and program synthesis tasks.",
            "citation_title": "Genetic programming: on the programming of computers by means of natural selection",
            "mention_or_use": "mention",
            "system_name": "Genetic Programming (tree-based)",
            "system_description": "Population-based evolutionary method that represents candidate solutions as program trees; new solutions are generated each generation by selecting parents according to fitness and producing offspring via crossover (subtree exchange) and mutation (subtree replacement, hoist, etc.), with optional simplification/post-processing to control bloat and improve interpretability.",
            "input_type": "programs",
            "crossover_operation": "Standard tree-based crossover: select a subtree in parent A and a subtree in parent B and swap them to create two offspring (subtree-exchange crossover). Variants exist (size-fair, homologous) that constrain chosen subtrees to control offspring size.",
            "mutation_operation": "Standard subtree mutation: replace a randomly chosen subtree with a newly generated random subtree; other mutation variants include point/no-op mutation, silencing/NOOPing genes, cut/hoist (copying or removing subtrees) and size-biased mutation operators.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": "Generally discussed qualitatively (genotypic and phenotypic diversity); some approaches (operator equalisation) work on size-distribution rather than explicit numeric diversity metric.",
            "diversity_results": null,
            "novelty_executability_tradeoff": "Paper discusses conceptually that exploration (novelty) comes from crossover/mutation randomness while simplification operators reduce search novelty and may hurt diversity/exploration; no quantitative curve provided.",
            "frontier_characterization": null,
            "benchmark_or_domain": "General (symbolic regression, classification, program synthesis, data-mining tasks)",
            "comparison_baseline": "Various GP variants (standard crossover/mutation, size-fair/homologous crossover, simplification-enabled GP)",
            "key_findings": "Crossover and mutation are the primary stochastic operators generating novelty and diversity; unmodified they can cause bloat and produce non-executable or excessively large programs; many variants constrain subtree sizes or bias operations to control bloat while preserving exploration.",
            "uuid": "e1649.0",
            "source_info": {
                "paper_title": "Simplification of genetic programs: a literature survey",
                "publication_date_yy_mm": "2022-04"
            }
        },
        {
            "name_short": "Crossover (tree-based)",
            "name_full": "Tree-based Crossover Operator",
            "brief_description": "Operator combining genetic material from two parent program trees by exchanging subtrees to create offspring, subject to variants that control size and structure.",
            "citation_title": "",
            "mention_or_use": "mention",
            "system_name": "Tree-based crossover",
            "system_description": "Select a crossover point (a node/subtree) in each of two parent trees and swap the subtrees, producing two offspring; variants include size-fair and homologous crossovers that constrain subtree size or alignment to maintain size distribution or semantic locality.",
            "input_type": "programs",
            "crossover_operation": "Subtree exchange between two parents as described; can be modified to pick points with matched subtree sizes (size-fair) or homologous positions to avoid dramatic structural changes.",
            "mutation_operation": null,
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": "Implicitly contributes to genotypic and phenotypic diversity; some studies evaluate effects on building-block disruption but no standard numeric metric is specified in the survey.",
            "diversity_results": null,
            "novelty_executability_tradeoff": "Survey notes that crossover's randomness produces novelty but may increase bloat and disrupt building blocks; size-aware crossover variants trade some novelty for better size control and reduced bloat.",
            "frontier_characterization": null,
            "benchmark_or_domain": "General GP domains",
            "comparison_baseline": "Standard subtree crossover vs size-fair and homologous variants",
            "key_findings": "Unconstrained subtree crossover can increase program size and harm interpretability; size-fair/homologous crossovers are effective at limiting size growth while still producing offspring, reducing bloat at the cost of restricting some exploratory moves.",
            "uuid": "e1649.1",
            "source_info": {
                "paper_title": "Simplification of genetic programs: a literature survey",
                "publication_date_yy_mm": "2022-04"
            }
        },
        {
            "name_short": "Mutation (tree-based)",
            "name_full": "Tree-based Mutation Operator",
            "brief_description": "Operator that perturbs an individual by replacing or modifying a randomly chosen subtree or instruction, generating variation and enabling exploration.",
            "citation_title": "",
            "mention_or_use": "mention",
            "system_name": "Tree-based mutation",
            "system_description": "Randomly select a node/subtree in the parent program and replace it with a new randomly generated subtree (or apply specialized mutations like hoist, NOOP insertion, silencing genes), with probability typically lower than crossover; can be size-aware (size-fair) or biased to reduce bloat.",
            "input_type": "programs",
            "crossover_operation": null,
            "mutation_operation": "Subtree replacement (randomly generated subtree), hoist (replace root by a randomly chosen subtree), uniform-subtree mutation (mutations proportional to tree size), size-fair mutation that maintains size distribution.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": "Contributes to genotypic diversity; variants can be tuned to preserve diversity vs control bloat (qualitative discussion).",
            "diversity_results": null,
            "novelty_executability_tradeoff": "Mutation increases novelty but can add introns/bloat; size-aware mutation reduces growth and preserves executability/readability while reducing some exploratory capacity.",
            "frontier_characterization": null,
            "benchmark_or_domain": "General GP domains",
            "comparison_baseline": "Standard subtree mutation vs hoist/size-fair/uniform variants",
            "key_findings": "Mutation is essential for exploration; modifications to mutation to be size-aware or semantic-aware can reduce bloat and improve interpretability but may reduce the raw novelty generated by fully random mutations.",
            "uuid": "e1649.2",
            "source_info": {
                "paper_title": "Simplification of genetic programs: a literature survey",
                "publication_date_yy_mm": "2022-04"
            }
        },
        {
            "name_short": "Hoist",
            "name_full": "Hoist Mutation / Modified Single Crossover",
            "brief_description": "Operator that replaces a tree by a copy of one of its subtrees (hoisting), effectively shortening individuals and sometimes used as a mutation or crossover variant to control size.",
            "citation_title": "Evolving a sort: Lessons in genetic programming",
            "mention_or_use": "mention",
            "system_name": "Hoist operator",
            "system_description": "Select a subtree within an individual and replace the entire individual (or a larger context) with that subtree (hoisting), acting like a destructive mutation that tends to reduce depth/size and can rescue useful smaller building blocks.",
            "input_type": "programs",
            "crossover_operation": "Described as a modified single-point crossover where a subtree copy is used; can be interpreted as crossover-like when applied between individuals by copying subtrees.",
            "mutation_operation": "Hoist selection is applied as a mutation that replaces an ancestor node by one of its descendants (a subtree), reducing size and potentially removing introns.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": "Hoist reduces size/excess code improving interpretability and executability potential but can reduce search diversity by collapsing structure.",
            "frontier_characterization": null,
            "benchmark_or_domain": "General GP problems",
            "comparison_baseline": "Standard mutation/crossover",
            "key_findings": "Hoist tends to produce smaller trees and can help control bloat while preserving or exposing compact building blocks; it is a commonly used size-reduction mutation variant.",
            "uuid": "e1649.3",
            "source_info": {
                "paper_title": "Simplification of genetic programs: a literature survey",
                "publication_date_yy_mm": "2022-04"
            }
        },
        {
            "name_short": "Size-fair crossover",
            "name_full": "Size-fair and Homologous Tree Crossover",
            "brief_description": "Crossover variants that choose crossover points so offspring subtree sizes are controlled or matched, limiting program size growth.",
            "citation_title": "Size fair and homologous tree crossovers for tree genetic programming",
            "mention_or_use": "mention",
            "system_name": "Size-fair/homologous crossover",
            "system_description": "Crossover that selects a crossover point in the first parent, measures the subtree size, then selects a point in the second parent whose subtree size matches (or aligns homologously) so that exchanged subtrees produce offspring with controlled or similar sizes.",
            "input_type": "programs",
            "crossover_operation": "Matched-size subtree exchange: pick subtree in parent A, find subtree in B with similar size (or homologous position) and swap, thereby constraining size changes.",
            "mutation_operation": null,
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": "Aims to preserve size-distribution rather than maximize novelty; impacts genotypic diversity by limiting large structural changes.",
            "diversity_results": null,
            "novelty_executability_tradeoff": "Size-fair crossover trades off some radical structural novelty for control over bloat and more predictable executability/interpretability of offspring.",
            "frontier_characterization": null,
            "benchmark_or_domain": "Tree-based GP",
            "comparison_baseline": "Standard subtree crossover",
            "key_findings": "Effective at preventing offspring size explosion and controlling bloat while still enabling recombination; reduces building-block disruption compared to unconstrained crossover.",
            "uuid": "e1649.4",
            "source_info": {
                "paper_title": "Simplification of genetic programs: a literature survey",
                "publication_date_yy_mm": "2022-04"
            }
        },
        {
            "name_short": "Uniform Subtree Mutation",
            "name_full": "Uniform Subtree Mutation",
            "brief_description": "Mutation operator that applies subtree mutations proportional to tree size, following a binomial distribution, to maintain size-related mutation rates.",
            "citation_title": "Uniform subtree mutation",
            "mention_or_use": "mention",
            "system_name": "Uniform Subtree Mutation",
            "system_description": "Mutation scheme where the probability of mutating a node/subtree is proportional to tree size; multiple mutation locations may be selected according to a binomial model, yielding mutations better matched to tree-scale.",
            "input_type": "programs",
            "crossover_operation": null,
            "mutation_operation": "Select mutation points across the tree with probabilities proportional to size (binomial distribution over nodes), replace selected subtrees with random subtrees.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": "Designed to maintain expected mutation effects across sizes; qualitatively impacts genotypic diversity control.",
            "diversity_results": null,
            "novelty_executability_tradeoff": "Aims to balance introducing novelty while preventing large destructive edits on very large trees (mitigating negative impacts on executability and bloat).",
            "frontier_characterization": null,
            "benchmark_or_domain": "Tree-based GP",
            "comparison_baseline": "Standard single-point/subtree mutation",
            "key_findings": "Provides a principled mutation rate that scales with individual size, helping avoid overwhelming large programs with too many changes and controlling bloat.",
            "uuid": "e1649.5",
            "source_info": {
                "paper_title": "Simplification of genetic programs: a literature survey",
                "publication_date_yy_mm": "2022-04"
            }
        },
        {
            "name_short": "Operator Equalisation",
            "name_full": "Operator Equalisation (population-based bloat control)",
            "brief_description": "Population-level technique that maintains a target distribution of program sizes by grouping individuals into size buckets and controlling reproduction to match bucket capacities.",
            "citation_title": "Operator equalisation and bloat free GP",
            "mention_or_use": "mention",
            "system_name": "Operator Equalisation",
            "system_description": "Group individuals by size into buckets and control acceptance of newly generated individuals to maintain a desired distribution over sizes (fixed or adaptive capacities), thereby preventing unchecked growth of program lengths.",
            "input_type": "programs",
            "crossover_operation": "Used in conjunction with standard crossover/mutation; the operator equalisation mechanism filters or accepts offspring based on maintaining the size-distribution.",
            "mutation_operation": "Same—mutation produces variants but acceptance depends on bucket capacities; operator equalisation does not change mutation mechanism but its selection/acceptance.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": "Indirect control of population size-distribution; seeks to preserve diversity across sizes (a form of genotypic diversity control).",
            "diversity_results": null,
            "novelty_executability_tradeoff": "Maintains diversity of sizes to avoid dominance of large individuals; may limit extreme novelty in size growth but preserves exploration across size bands.",
            "frontier_characterization": null,
            "benchmark_or_domain": "General GP",
            "comparison_baseline": "Unconstrained GP and other bloat-control techniques",
            "key_findings": "Shifts focus from per-individual control to population distribution control; effective at limiting bloat while allowing exploration across size buckets.",
            "uuid": "e1649.6",
            "source_info": {
                "paper_title": "Simplification of genetic programs: a literature survey",
                "publication_date_yy_mm": "2022-04"
            }
        },
        {
            "name_short": "Ekart mutation",
            "name_full": "Ekart's Fitness-preserving Simplification / Mutation",
            "brief_description": "Mutation-like operator that applies algebraic simplification rules to remove nonfunctional code (introns) while preserving semantics and fitness.",
            "citation_title": "Shorter fitness preserving genetic programs",
            "mention_or_use": "mention",
            "system_name": "Ekart simplification-mutation",
            "system_description": "Identify algebraic simplifications that preserve semantics and apply them as a mutation-like operator to replace complex expressions with simpler equivalents, effectively removing introns while keeping fitness constant.",
            "input_type": "programs",
            "crossover_operation": null,
            "mutation_operation": "Deterministic semantic-preserving edits: apply pre-defined algebraic simplification rules to nodes/subtrees (acts like a mutation but preserves fitness).",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": "Preserves executability/fitness while reducing size; reduces syntactic novelty but improves interpretability without harming performance.",
            "frontier_characterization": null,
            "benchmark_or_domain": "GP simplification",
            "comparison_baseline": "Standard GP without algebraic simplification",
            "key_findings": "Shows that semantic-preserving simplifications can remove nonfunctional code (introns) and reduce program size while maintaining fitness, acting as a specialized mutation.",
            "uuid": "e1649.7",
            "source_info": {
                "paper_title": "Simplification of genetic programs: a literature survey",
                "publication_date_yy_mm": "2022-04"
            }
        },
        {
            "name_short": "Algebraic simplification",
            "name_full": "Algebraic (rule-based) simplification of GP programs",
            "brief_description": "Exact simplification approach using domain-specified algebraic rules (e.g., A*0 -&gt; 0) to replace subexpressions with smaller semantically equivalent expressions.",
            "citation_title": "Algebraic simplification of GP programs during evolution",
            "mention_or_use": "mention",
            "system_name": "Algebraic (rule-based) simplification",
            "system_description": "Apply a pre-defined set of algebraic transformation rules to expression trees to replace matched subexpressions by smaller, semantically equivalent forms; can be applied online (every k generations) or offline to final solutions.",
            "input_type": "programs",
            "crossover_operation": null,
            "mutation_operation": null,
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": "Qualitatively affects building blocks; may disrupt syntactic building blocks while producing new ones (building-block analysis discussed).",
            "diversity_results": null,
            "novelty_executability_tradeoff": "Preserves semantics (thus executability) while removing syntactic novelty; can disrupt building blocks and thereby affect evolutionary search trajectories.",
            "frontier_characterization": null,
            "benchmark_or_domain": "Symbolic regression and other algebraic-expression tasks",
            "comparison_baseline": "GP without algebraic simplification",
            "key_findings": "Algebraic simplification reduces size without harming semantics; when applied too frequently it can slow evolution and disturb building blocks, so trade-offs in application frequency exist.",
            "uuid": "e1649.8",
            "source_info": {
                "paper_title": "Simplification of genetic programs: a literature survey",
                "publication_date_yy_mm": "2022-04"
            }
        },
        {
            "name_short": "Numerical simplification",
            "name_full": "Numerical contribution-based simplification",
            "brief_description": "Exact simplification technique that estimates numerical contribution of subtrees to parents across training cases and prunes or replaces subtrees whose contribution is below thresholds.",
            "citation_title": "Using numerical simplification to control bloat in genetic programming",
            "mention_or_use": "mention",
            "system_name": "Numerical simplification",
            "system_description": "Compute contribution of child nodes/subtrees to parent outputs over training examples (e.g., via linear regression or range checks); if contribution is negligible or variance small, replace subtree by constant or remove it, accepting modifications if error below threshold.",
            "input_type": "programs",
            "crossover_operation": null,
            "mutation_operation": "Acts like a deterministic destructive mutation: prune or replace subtrees based on low numerical contribution; proposals can be accepted based on MSE thresholds.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Semantic fidelity measured as mean squared error (MSE) between original and simplified program outputs on training/validation points; acceptance thresholds used.",
            "executability_results": null,
            "diversity_metric": "Discussed in terms of building-block effects; numerical simplification can change the building-block distribution and thus affect genotypic/phenotypic diversity.",
            "diversity_results": null,
            "novelty_executability_tradeoff": "Removes numerically-insignificant code improving executability/interpretability with controlled loss in fidelity (thresholded by MSE); tradeoff managed by acceptance thresholds.",
            "frontier_characterization": null,
            "benchmark_or_domain": "Symbolic regression and numeric GP tasks",
            "comparison_baseline": "Algebraic and semantic simplification approaches",
            "key_findings": "Numerical pruning can effectively shrink trees and control bloat while preserving performance within thresholds; choice of contribution thresholds is application-dependent.",
            "uuid": "e1649.9",
            "source_info": {
                "paper_title": "Simplification of genetic programs: a literature survey",
                "publication_date_yy_mm": "2022-04"
            }
        },
        {
            "name_short": "Fitness-based simplification / Pruning",
            "name_full": "Fitness-based destructive simplification / Pruning",
            "brief_description": "Approximate simplification family that proposes removing/replacing subtrees (or silencing genes) and accepts the change if fitness does not degrade (or improves), akin to destructive mutation tested by fitness.",
            "citation_title": "",
            "mention_or_use": "mention",
            "system_name": "Fitness-based simplification / pruning",
            "system_description": "Randomly or systematically propose destructive edits (prune branches, replace with terminals/constants, NOOP or silence genes), evaluate the modified program's fitness and retain the change if fitness is not worse (or improved); can be iterative and applied top-down or bottom-up.",
            "input_type": "programs",
            "crossover_operation": null,
            "mutation_operation": "Destructive edits replacing subtrees with terminals, constant replacements, NOOP or gene silencing; proposals evaluated by fitness comparisons (acts like selective mutation).",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Fitness comparison (problem-specific fitness measures, e.g., accuracy, MSE) used as acceptance criterion; may use validation sets for corroboration.",
            "executability_results": null,
            "diversity_metric": "May reduce phenotypic/genotypic diversity if applied globally; some authors prune only selected individuals to limit diversity loss.",
            "diversity_results": null,
            "novelty_executability_tradeoff": "Fitness-based pruning explicitly trades off syntactic novelty for fitness-preserving compactness; aggressive pruning can reduce diversity and harm later search.",
            "frontier_characterization": null,
            "benchmark_or_domain": "PushGP, symbolic regression, dispatching rule design, general GP tasks",
            "comparison_baseline": "GP without pruning, algebraic/numerical/semantic simplification",
            "key_findings": "Pruning via fitness checks can produce smaller solutions while maintaining or improving generalisation, but must be applied carefully (e.g., on a subset of individuals, intermittently) to avoid loss of diversity and premature convergence.",
            "uuid": "e1649.10",
            "source_info": {
                "paper_title": "Simplification of genetic programs: a literature survey",
                "publication_date_yy_mm": "2022-04"
            }
        },
        {
            "name_short": "Semantics-based substitution",
            "name_full": "Semantics-based (semantic-approximation) substitution/simplification",
            "brief_description": "Approximate simplification approach that replaces subtrees with smaller subtrees or terminals chosen to match (approximately) the original subtree's semantics on a set of input points, often using libraries or generated approximations.",
            "citation_title": "Semantic approximation for reducing code bloat in genetic programming",
            "mention_or_use": "mention",
            "system_name": "Semantics-based simplification/substitution",
            "system_description": "Compute a target semantics (output vector on regression points) for a subtree and replace it with a smaller subtree or terminal whose semantics approximates the target (via library lookup or by growing a small approximating subtree); accept replacements based on semantic similarity (e.g., MSE) possibly using validation.",
            "input_type": "programs",
            "crossover_operation": null,
            "mutation_operation": "Acts like a guided mutation where replacement is chosen to match semantics rather than at random; can use a small search to grow approximate subtree replacements.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Semantic similarity measured over regression points via MSE or other distance metrics; acceptance thresholds applied.",
            "executability_results": null,
            "diversity_metric": "By replacing subtrees with semantically similar but smaller ones, may reduce syntactic diversity while preserving phenotypic behaviour; impact on diversity must be managed.",
            "diversity_results": null,
            "novelty_executability_tradeoff": "Provides small-size replacements that preserve phenotype (executability) at cost of reducing syntactic novelty; computationally expensive but effective at finding compact semantically-equivalent variants.",
            "frontier_characterization": null,
            "benchmark_or_domain": "Symbolic regression and GP tasks requiring semantic fidelity",
            "comparison_baseline": "Algebraic and numerical simplification approaches",
            "key_findings": "Semantic substitution can find compact replacements that are functionally similar, enabling better interpretability and often maintaining generalisation, but is computationally intensive and problem-dependent.",
            "uuid": "e1649.11",
            "source_info": {
                "paper_title": "Simplification of genetic programs: a literature survey",
                "publication_date_yy_mm": "2022-04"
            }
        },
        {
            "name_short": "Generation-wide simplification (Gws)",
            "name_full": "Generation-wide simplification via Rupturing (Gws)",
            "brief_description": "Population-level simplification where individuals are 'ruptured' to produce the power set of their subcomponents as offspring and the fittest unique children are selected to form the next generation, replacing standard crossover/mutation at those epochs.",
            "citation_title": "On-the-fly simplification of genetic programming models",
            "mention_or_use": "mention",
            "system_name": "Generation-wide simplification (Gws) / Rupturing",
            "system_description": "Every k generations, replace standard reproduction by rupturing each individual to produce many offspring (members of the parent's power set of components), enforce uniqueness, then select the fittest individuals (or top-N) to populate the next generation; semantics may change so this is approximate simplification.",
            "input_type": "programs",
            "crossover_operation": "During Gws epochs, standard crossover/mutation is suspended or limited; offspring result from combinatorial rupturing of a single parent rather than recombination of two parents.",
            "mutation_operation": "Rupturing acts akin to exhaustive pruning/combination within a parent rather than random mutation; consequently, explicit mutation may be deprioritised at Gws steps.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Selection still uses fitness; semantics may differ between parent and children and acceptance based on fitness leads to executability preserved by selection rather than semantic-preservation rules.",
            "executability_results": null,
            "diversity_metric": "Uniqueness constraint is enforced to avoid genetic duplicates (genotypic uniqueness); may reduce redundancy but has potential to reduce diversity if many parents produce similar children.",
            "diversity_results": null,
            "novelty_executability_tradeoff": "Gws aggressively explores simplified subsets of parents which can improve compactness/executability for selected individuals but risks reducing population diversity and exploration; authors recommend combining with standard operators when offspring count insufficient.",
            "frontier_characterization": null,
            "benchmark_or_domain": "GP generally; proposed by Javed & Gobet (2021)",
            "comparison_baseline": "Standard GP with crossover/mutation and other simplification techniques",
            "key_findings": "Population-wide rupturing can produce many simplified children and reduce mean tree sizes while retaining fitness-based selection, but it can risk reducing diversity and altering evolutionary trajectories; uniqueness and selection heuristics are necessary to manage population composition.",
            "uuid": "e1649.12",
            "source_info": {
                "paper_title": "Simplification of genetic programs: a literature survey",
                "publication_date_yy_mm": "2022-04"
            }
        },
        {
            "name_short": "PushGP simplification operators",
            "name_full": "PushGP simplification (gene silencing, NOOP, pruning)",
            "brief_description": "Simplification operators designed for PushGP that act at the genotype level by silencing genes, replacing with NOOP instructions, or pruning instructions to reduce expression without necessarily altering genotype structure radically.",
            "citation_title": "Improving generalization of evolved programs through automatic simplification",
            "mention_or_use": "mention",
            "system_name": "PushGP simplification operators",
            "system_description": "In PushGP (stack-based language), simplification operators include silencing genes (prevent expression of a gene in phenotype), replacing genes with NOOPs (instructions that do nothing on execution), and iterative pruning of instructions followed by fitness comparison; these act like genotype-level destructive mutations aimed at simplification and generalisation improvement.",
            "input_type": "programs",
            "crossover_operation": null,
            "mutation_operation": "Simplification acts as iterative destructive genotype edits (silence/NOOP/prune) evaluated by fitness; works complementarily with PushGP's regular crossover/mutation.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Fitness on problem tasks used to accept simplifications; simplifications aim to improve generalisation on validation/test sets.",
            "executability_results": null,
            "diversity_metric": "Pruning can reduce expressed phenotypic diversity while preserving genotypic material (silenced genes remain available), which can help exploration without immediate loss of genetic variation.",
            "diversity_results": null,
            "novelty_executability_tradeoff": "Silencing/NOOP keeps genotypic novelty available while reducing current phenotype complexity (improving executability/interpretability) — a design to balance novelty retention and immediate simplification.",
            "frontier_characterization": null,
            "benchmark_or_domain": "PushGP / program synthesis tasks",
            "comparison_baseline": "PushGP without simplification",
            "key_findings": "PushGP-specific simplification operators can reduce overfitting and improve generalisation by removing or deactivating nonessential instructions; genotype-level silencing offers a way to retain raw genetic novelty while simplifying expressed behaviour.",
            "uuid": "e1649.13",
            "source_info": {
                "paper_title": "Simplification of genetic programs: a literature survey",
                "publication_date_yy_mm": "2022-04"
            }
        },
        {
            "name_short": "Pruning via permutation tests",
            "name_full": "Pruning of GP trees using permutation tests",
            "brief_description": "A statistical approach proposing pruning based on measuring the contribution of a subtree via permutation tests and validating the effect on parental output using a validation set.",
            "citation_title": "Pruning of genetic programming trees using permutation tests",
            "mention_or_use": "mention",
            "system_name": "Permutation-test-based pruning",
            "system_description": "Propose candidate prunes by estimating subtree contribution, then use a permutation test to assess whether pruning significantly affects parent's outputs; validations on held-out data corroborate acceptance, providing a statistically principled pruning operator.",
            "input_type": "programs",
            "crossover_operation": null,
            "mutation_operation": "Prune proposals act like destructive mutations whose acceptance is determined by permutation-test significance and validation-set corroboration.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Statistical significance (permutation test p-values) and validation-set fitness comparisons used to judge acceptability of prunes.",
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": "Provides a conservative pruning mechanism that aims to preserve executability/performance (statistically validated) while reducing size; tradeoff controlled by significance thresholds.",
            "frontier_characterization": null,
            "benchmark_or_domain": "GP simplification/pruning",
            "comparison_baseline": "Other pruning/simplification heuristics",
            "key_findings": "Statistical testing provides a principled acceptance criterion for pruning proposals, helping avoid harmful simplifications while reducing bloat when prunes are statistically non-significant.",
            "uuid": "e1649.14",
            "source_info": {
                "paper_title": "Simplification of genetic programs: a literature survey",
                "publication_date_yy_mm": "2022-04"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Shorter fitness preserving genetic programs",
            "rating": 2,
            "sanitized_title": "shorter_fitness_preserving_genetic_programs"
        },
        {
            "paper_title": "Evolving a sort: Lessons in genetic programming",
            "rating": 2,
            "sanitized_title": "evolving_a_sort_lessons_in_genetic_programming"
        },
        {
            "paper_title": "Size fair and homologous tree crossovers for tree genetic programming",
            "rating": 2,
            "sanitized_title": "size_fair_and_homologous_tree_crossovers_for_tree_genetic_programming"
        },
        {
            "paper_title": "Uniform subtree mutation",
            "rating": 2,
            "sanitized_title": "uniform_subtree_mutation"
        },
        {
            "paper_title": "Operator equalisation and bloat free GP",
            "rating": 2,
            "sanitized_title": "operator_equalisation_and_bloat_free_gp"
        },
        {
            "paper_title": "Algebraic simplification of GP programs during evolution",
            "rating": 2,
            "sanitized_title": "algebraic_simplification_of_gp_programs_during_evolution"
        },
        {
            "paper_title": "Using numerical simplification to control bloat in genetic programming",
            "rating": 2,
            "sanitized_title": "using_numerical_simplification_to_control_bloat_in_genetic_programming"
        },
        {
            "paper_title": "Improving generalization of evolved programs through automatic simplification",
            "rating": 2,
            "sanitized_title": "improving_generalization_of_evolved_programs_through_automatic_simplification"
        },
        {
            "paper_title": "On-the-fly simplification of genetic programming models",
            "rating": 2,
            "sanitized_title": "onthefly_simplification_of_genetic_programming_models"
        },
        {
            "paper_title": "Pruning of genetic programming trees using permutation tests",
            "rating": 2,
            "sanitized_title": "pruning_of_genetic_programming_trees_using_permutation_tests"
        },
        {
            "paper_title": "Contribution based bloat control in genetic programming",
            "rating": 1,
            "sanitized_title": "contribution_based_bloat_control_in_genetic_programming"
        },
        {
            "paper_title": "Effective simplification of evolved push programs using a simple, stochastic hill-climber",
            "rating": 1,
            "sanitized_title": "effective_simplification_of_evolved_push_programs_using_a_simple_stochastic_hillclimber"
        }
    ],
    "cost": 0.021616499999999997,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>Simplification of genetic programs: a literature survey</p>
<p>Noman Javed n.javed3@lse.ac.uk 
School of Economics and Political Science
CPNSS
London, LondonUK</p>
<p>· Fernand Gobet 
School of Economics and Political Science
CPNSS
London, LondonUK</p>
<p>· Peter Lane 
Department of Computer Science
University of Hertfordshire
HertfordshireUK</p>
<p>Martin Atzmueller 
Johannes Fürnkranz 
Tomáš Kliegr 
Ute Schmid 
Noman Javed 
Fernand Gobet f.gobet@lse.ac.uk 
Peter Lane p.c.lane@herts.ac.uk 
Simplification of genetic programs: a literature survey
10.1007/s10618-022-00830-7Received: 31 March 2021 / Accepted: 17 March 2022 / Published online: 27 April 2022Data Mining and Knowledge Discovery (2022) 36:1279-1300 123 1280 N. Javed et al. two pieces of prior work pointing out the benefits of using time as a measure when controlling bloat.Simplification · Genetic programming · Bloat control · Explainability
Genetic programming (GP), a widely used evolutionary computing technique, suffers from bloat-the problem of excessive growth in individuals' sizes. As a result, its ability to efficiently explore complex search spaces reduces. The resulting solutions are less robust and generalisable. Moreover, it is difficult to understand and explain models which contain bloat. This phenomenon is well researched, primarily from the angle of controlling bloat: instead, our focus in this paper is to review the literature from an explainability point of view, by looking at how simplification can make GP models more explainable by reducing their sizes. Simplification is a code editing technique whose primary purpose is to make GP models more explainable. However, it can offer bloat control as an additional benefit when implemented and applied with caution. Researchers have proposed several simplification techniques and adopted various strategies to implement them. We organise the literature along multiple axes to identify the relative strengths and weaknesses of simplification techniques and to identify emerging trends and areas for future exploration. We highlight design and integration challenges and propose several avenues for research. One of them is to consider simplification as a standalone operator, rather than an extension of the standard crossover or mutation operators. Its role is then more clearly complementary to other GP operators, and it can be integrated as an optional feature into an existing GP setup. Another proposed avenue is to explore the lack of utilisation of complexity measures in simplification. So far, size is the most discussed measure, with only Responsible editor:</p>
<p>two pieces of prior work pointing out the benefits of using time as a measure when controlling bloat.</p>
<p>Keywords Simplification · Genetic programming · Bloat control · Explainability</p>
<p>Introduction</p>
<p>Machine learning has become increasingly popular, and almost ubiquitous, in many diverse areas. Everyone wants high-performing machine learning models producing accurate results, but not everyone is well-placed to make sense of them. It is not simply a question of explaining the results produced by these machine learning models, but how and why these results were generated is often even more critical. What is the role of input features? What are the benefits of using a particular knowledge representation? What parameter settings work well? These are all pertinent questions. So, the demand for transparent and efficient machine-learning algorithms is increasing. These two objectives can, unfortunately, be in conflict. The increase in predictive accuracy often comes as a result of the increased complexity of the underlying algorithm and model. This complexity makes explainability a challenging task. On the other side, an increased focus on reducing complexity results in a compromise to accuracy. So, there is usually a trade-off between accuracy and complexity, which researchers are trying to balance.</p>
<p>The increasing, and unprecedented, rate at which new data are generated and their volume motivate the need to use automated data-mining workflows to uncover new knowledge. Although human involvement will always be required, automating part of the knowledge-discovery process offers the potential to come up with better feature selection, model selection, and hyper-parameter settings. One of the issues is determining what is meant by a "better" model. Usually, the objective of these automated systems is to find highly efficient models in terms of accuracy, but, as discussed above, sometimes "better" may mean more explainable. An interesting question is to decide if these automated systems play their part in addressing the accuracy-complexity tradeoff (Freitas 2019).</p>
<p>We can observe two clear trends in artificial intelligence research. The first one is automation and the second one is explainable artificial intelligence (XAI). Genetic Programming (GP), being an inherently white-box approach, stands a clear chance to deliver on both of these lines. It has been used to automate machine learning pipelines (Olson and Moore 2016). Moreover, it has also been employed to generate explanations for machine learning models (Cavaliere et al. 2020;Hu 2020). One can pose a simple question at this point: how explainable are GP-generated models themselves? The question is a bit vague, as GP is an enabling technology that can generate many kinds of models, ranging from decision trees to neural networks and many others. However, it makes more sense if one thinks of it in terms of understanding of solutions within a specific category. For example, while solving a classification problem using decision trees, how much does GP prefer simpler decision trees over complex ones?</p>
<p>The question of generating explainable models is related to a well-known issue with GP called bloating, where continued evolution of a population leads to an excessive increase in size in the generated programs without improving their overall fitness. Bloated individuals require extra computational resources, such as memory. Also, the unwanted code in a bloated program increases the computational time to evaluate its fitness, thus making the whole evolutionary process slow. This unwanted growth renders individuals less explainable. The good news is that this phenomenon has been understood by the GP community from the very beginning and many techniques have been proposed over the years to tackle the problem. All bloat control techniques at least partially address the issue of explainability because of their focus on controlling the size of individual programs. One particular kind of bloat control technique, called simplification, involves editing the program. It works by converting an individual program to a smaller-sized variant with, usually, identical behaviour. This technique relies on a set of rules or methods for editing a program and thus can help understand the composition of the individual. It does not differentiate individuals on the basis of size and so individuals both large and small can be modified to make them (even) smaller. In this way, simplification not only controls the bloat of large programs, but also works to reduce the size of all candidate solutions, and in general, smaller solutions are easier to understand.</p>
<p>In this paper we review the literature of simplification of GP models with the following objectives:</p>
<ol>
<li>To differentiate simplification from other bloat control techniques in terms of its potential for explainability; 2. To categorise the literature in terms of the major simplification techniques; 3. To identify the important design and integration constraints and organise the existing approaches in terms of these design considerations.</li>
</ol>
<p>The next section introduces GP and highlights its usage for data mining and knowledge discovery. Section 3 discusses complexity and simplification. Section 4 deals with the first objective, by highlighting the major differences between simplification and other bloat control techniques. Section 5 reviews the techniques proposed by researchers. Section 6 presents certain considerations to properly design and integrate simplification into the genetic process and organises the literature in terms of these decisions. Section 7 discusses several opportunities and challenges for simplification. In the final section, we conclude and present some future directions for research.</p>
<p>Genetic programming and knowledge discovery</p>
<p>Genetic programming (Koza 1992) (GP) is a widely used form of Evolutionary Computation (EC). Like other EC methods, it is inspired by the Darwinian process of natural selection in which individuals with a better fit to the environment have more survival chances. Its originality is to evolve entire programs. Programs are represented as combinations of user-defined operators. Each program is a candidate solution and new solutions are generated by gradually evolving a population of programs. Each program is evaluated against a user-defined fitness criterion and those with higher fitness are used to create the next generation using a crossover operator, which splits and recombines two programs into two new children. Mutation is applied to some of the individuals, usually with a very low probability, in order to generate variation. This process is repeated for a number of generations until a predefined stopping criterion is met. There are a number of varieties of GP, including tree-based, linear (Brameier and Banzhaf 2010) and graph-based GP (Banzhaf et al. 1998). In this paper, we cover only tree-based GP as it is one of the most widely used representations. Moreover, the identification and removal of non-effective code in linear GP are quite straightforward. Since its inception, people from different domains responded well to GP and developed various applications. Koza, the founder of GP, tracked the growth of GP and compiled a list of GP applications producing human-competitive results (Koza 2010). He noted that the solutions proposed by GP, although belonging to different domains, share some common characteristics. Moreover, he correlated the increase in usage and efficacy of GP with the growth in computational power. Based on this correlation, he predicted an increased flow of human-competitive results in the future. True to his prediction, we can witness GP venturing in diverse areas and producing impressive results (Krawiec 2015;Acharya et al. 2020;Azzali et al. 2020;Bi et al. 2020). This effectiveness is not just limited to single-objective problems. Many researchers reported supportive evidence for solving multi-objective optimisation problems (Zhang and Rockett 2006;Coelho et al. 2011;Zupančič et al. 2020).</p>
<p>Being a white-box technique, GP can deliver on the promise of XAI (Howard and Edwards 2018). It can not only create interpretable models but can also unlock the behaviour of black-box models. Several researchers have applied GP for this purpose. Genetic programming explainer (GPX) creates local explanation models to fit the data. The data here represents the sample set containing the point of interest plus the newly created noise set in the neighbourhood (Ferreira et al. 2020). Virgolin et al. created a meta-learning system (Virgolin et al. 2020). They first developed an ML model of proxies of human interpretability (PHI) using the data gathered as human feedback. The feedback was about the relationship between mathematical formulas and two forms of interpretability. These two forms were simulatability and decomposability. The model is then plugged into GP with one of the objectives representing human interpretability. The other was the mean square error representing the performance for symbolic regression problems. In another approach (Evans et al. 2019), a group of researchers used multi-objective genetic programming to mimic the working of blackbox ML models. They created a decision tree to guess the predictions of the blackbox while keeping it as simple as possible. This creates a model-agnostic approach independent of the type of the black-box.</p>
<p>Data mining refers to the extraction of knowledge from data. The two essential requirements of a data mining system are its predictive accuracy and how easy its output is to interpret. These are critical requirements for many data mining algorithms. Satisfying these requirements may increase the utility of the algorithm, especially for the domains where transparency and interpretability are of utmost importance. The requirement of transparency is not only restricted to the early phases of the knowledge discovery process. It is also needed for the post-processing of the discovered models. However, at times it becomes difficult to satisfy both these requirements at the same time. Maximising one may result in the loss of the other. In these situations, data mining lends itself as a multi-objective optimisation problem. GP, being a viable option to solve such optimisation problems, has been used to solve and automate different parts of the data mining system (Pappa and Freitas 2009). Freitas (2003) conducted a detailed survey and noted the use of GP for comprehensible rules discovery and attribute selection. Krawiec (2002) employed GP to construct a new set of features based on the original attributes to improve the classification performance. GP represents these features as Lisp-like expressions, thus exposing the algorithmic transformation of input attributes to new features. In a recent paper (Lensen et al. 2020), authors used multi-objective genetic programming for dimensionality reduction of a dataset. Since there is a possibility of a decline in quality while reducing dimensions, the use of multi-objective GP offers different trade-offs between quality and dimensionality. Moreover, the generated mappings are transparent and interpretable. Thus, a GP-driven data mining system, offering a nice trade-off between accuracy and transparency, can solve classification problems, the discovery of if-else rules, the discovery of association rules, and many other problems (Collet and Wong 2012).</p>
<p>Complexity and simplification</p>
<p>Before beginning a review of the simplification literature and related issues, we first provide a definition. However, to define simplification, we must understand complexity. In GP, complexity usually refers to the complexity of an individual. There exist multiple ways in which an individual in GP can be represented. Tree-based GP opts for the tree representation of the individual while linear-GP operates on a sequence of instructions. Graph-based GP uses graphs to represent the individual while grammarbased GP separates the genotype from phenotype and defines a mapping process from genotype to phenotype. In this paper, we are restricting ourselves to tree-based GP because it is one of the most widely used representations and is prone to the phenomenon of bloat, for which simplification is often proposed as a remedy.</p>
<p>There are several ways to calculate the complexity of an individual when it is represented as a tree. Structural complexity refers to the size of the tree, which can mean one of several things: the number of nodes in a tree, the depth of a tree (the number of levels it contains), or the sum of the nodes of all the subtrees of a tree. In most of the simplification schemes reviewed in this paper, the number of nodes in a tree is considered as the measure of the complexity. Only two articles proposed execution time as a measure of complexity. Since one of the objectives of our work is to classify the simplification literature, we consider the tree size as the proxy of complexity. We shall get back to other definitions of complexity later in the discussion section.</p>
<p>Given the above-mentioned definition of complexity, simplification can now be defined as a process of reducing tree size. This reduction may be in the form of deleting some nodes or replacing a subtree with a smaller subtree. So, simplification aims to reduce the complexity of the individual by reducing its size and hence making it more understandable. Since the process involves structural changes, the impact of these modifications may or may not alter the semantics as well. So, for the sake of clarity, we propose the following two types of simplification: Exact simplification: It preserves the semantics of the individual while removing the unwanted parts. Approximate simplification: It is more flexible than the exact simplification, hence compromises the semantics while modifying the structure of the individual.</p>
<p>Simplification and bloat control</p>
<p>As mentioned earlier, bloat is one of the biggest challenges to the successful use of GP. The problems caused by bloat manifest themselves in various forms, including a poor exploration of search space due to lack of diversity, lack of robustness, lack of generalisation-ability and lack of understandability. Researchers of GP have been well aware of these problems from the very start and have proposed several bloatcontrol techniques. We refer to the survey papers (Silva et al. 2012;Alfaro-Cid et al. 2010) for a detailed discussion of bloat and its control techniques. Our objective in this section is twofold: the first is to highlight the fundamental difference between simplification and other bloat-control techniques; and the second is to justify the existence of simplification as more than merely a bloat-control technique.</p>
<p>The easiest to implement and most widely used bloat-control technique puts a limit on the maximum depth of the individual (Koza 1992). The problems with this technique are how to identify the boundary threshold and what to do if good solutions lie on the other side. To address this, researchers have developed alternative ways of controlling the size. One way assigns poor fitness to relatively big individuals, thus limiting their chances of survival in later generations. An alternative way to achieve the same goal uses a waiting room, where newly created individuals have to wait before becoming part of the population. The waiting time is proportional to the individuals' size. Yet another way is to penalise big individuals by reducing their chance of appearing in the next generation. Rather than forcing direct or indirect limits, another way to control bloat is by designing size-aware genetic operators of crossover, mutation, selection and evaluation. These intelligently crafted operators are biased towards smaller sized individuals, thus limiting the number of big individuals and hence limiting their chances of survival. Dignum and Poli (2008) proposed a population-based technique, operator equalisation, to control bloat, and Silva et al. (2012) added some of its variants. The focus is shifted from dealing with a single individual to dealing with the distribution of individuals. Individuals are grouped on the basis of sizes in different buckets. The capacities of these buckets create the distribution of the population and every newly generated population is supposed to maintain this distribution. Several variants of this technique have been proposed, from fixed-bucket capacities to adaptable ones. The idea is to keep checks on the count of individuals of certain sizes. Hence, instead of defining a threshold limiting size, this technique creates various thresholds and maintains the counts within those boundaries.</p>
<p>The common theme in all of the techniques listed so far is the idea of restraining the growth of individuals while respecting their structural integrity. Code editing or simplification differs fundamentally from the other bloat control techniques by violating this principle, thus making changes to the syntactic structures of the individuals by removing or replacing certain parts. In this regard, it resembles the optimisation phase of a compiler. Compilers make multiple passes over the intermediate code to optimise its behaviour by converting the existing form to a reduced and more resource-efficient form (Aho et al. 1986). In this way, simplification can be viewed as an optimisation technique, transforming an individual to its optimised variant. However, this transformation is usually destructive and the resultant individual may be significantly different from the original one, particularly at a syntactic level. Unlike in a compiler, the semantics usually undergoes some change, and the simplified code will only be an approximation to the original.</p>
<p>By following the principle of Occam's Razor, simplification tends to generate smaller-sized variants of complex individuals. This inherent property enables it to tackle the issue of interpretability and understandability in machine learning. Simplified models, being smaller in size, are (usually) more explainable as compared to their larger-sized counterparts. This issue of explainability is now receiving considerable attention from AI researchers. One of the main reasons is that some fields of study, such as psychology and neuroscience, are reluctant to trust black-box solutions. AI has to offer white-box and transparent solutions to win their trust.</p>
<p>An added advantage offered by simplification is increasing the possibility of generating robust and generalisable individuals (Helmuth et al. 2017). It does so by pruning the unnecessary parts of the individuals. How these excess genes appear in the first place can be explained by 'the fitness causes bloat' theory (Langdon 1998). According to this theory, the size of the individuals gradually increases to fit the corner cases of the training data. This fine-tuning leads to overfitting the training data, which results in the loss of generalisability and robustness. Hence, simplification by pruning the unwanted parts of the code keeps overfitting under check, thus boosting the chances of robustness and generalisability. On a side note, pruning is not specific to GP. It is frequently used in other tree-based approaches, such as decision trees, random forests, and boosted trees.</p>
<p>Controlling bloat is one of the advantages of simplification when it runs throughout the evolutionary process. Simplification justifies its existence even without being used as a bloat-control technique. It can work in offline mode on one or several GP-generated solutions. When applied in this way, it exhibits itself purely to achieve the objective of explainability. So, in light of these fundamental differences between bloat control and the potential to generate robust and interpretable solutions, we propose to consider simplification separately from bloat-control mechanisms.</p>
<p>Review of simplification techniques</p>
<p>In the following paragraphs, we review various simplification techniques and group them under different categories. Some of these techniques fall under the category of exact simplification as they do not change the semantics, whereas others do interfere with the semantics and hence lie under the umbrella of approximate simplification.</p>
<p>Removal of Dormant nodes</p>
<p>The simplest form of simplification is the identification and removal of dormant code. By dormant code, we mean the code that is unreachable while executing an individual. Another form of unreachability is where code is executed but has no contribution to the generation of the final output. One example of unreachable code is any statement written after the return statement in C++, Java, and many other programming languages. Song et al. (2010) calculated the contribution of nodes at the time of evaluating fitness. They identify nodes as non-contributing nodes if they make no impact on the state of execution. They remove these nodes before selecting the individual as a parent. Jackson (2010) identified dormant nodes by creating an identical tree and marking all nodes as non-visited. While evaluating the fitness cases, the status of these nodes is changed from non-visited to visited when they are executed. Those having non-visited status at the end of evaluation are considered as dormant nodes. A dormant node implies that the subtree rooted at that node is also dormant. So, all these dormant nodes can be removed without any performance loss. All of these techniques are semantic preserving, and hence belong to the category of exact simplification.</p>
<p>Rule-based simplification</p>
<p>This category refers to approaches inspired by the algebraic simplification of expressions. For instance, an expression like A * 0 can be simplified by replacing it with 0. Similarly, consider the following if statement:
(if (&gt; a 0) b b)
In the lisp code above, no matter what the value of a is the result will be b. So, the whole i f expression can be replaced by b. It is highly unlikely that a human would write such code, but in genetic programming, where the operators are selected randomly for growing individuals, or as a result of crossover or mutation, such a situation may arise. Rule-based simplification works by defining a rule set, where a rule can be replaced by a smaller variant with the same semantics. Wong and Zhang (2006) present a bottom-up greedy approach to replace a subexpression with a smaller expression that is algebraically equivalent. The authors used hashing to find whether two different-looking expressions are similar or not. Their idea is to extend the application of simplification to dissimilar-looking individuals. They applied simplification to every individual. However, it is recommended to use simplification every two generations, otherwise it will be too slow. The authors performed a building-block analysis using numerical nodes as the building blocks. While simplification disrupts the building blocks generated in non-simplified GP, it has the potential to generate new building blocks (Wong and Zhang 2007). Murano et al. (2018) applied algebraic simplification to multimodal genetic programming and reports an improvement in search-ability without compromising performance. Burlacu et al. (2019) used hashing to identify tree isomorphisms and hence create new opportunities to apply algebraic simplification. Borcheninov and Okulovsky (2012) suggested internalising the application of algebraic rules by making it part of the evolutionary operators. Rule-based simplification works by matching the rules, and since these rules are pre-defined by domain experts, it belongs to the category of exact simplification.</p>
<p>Numerical simplification</p>
<p>Rule-based simplification suffers from various limitations. One of them is the definition of a rule set, which requires domain experts with an excellent knowledge of the application area. Another limitation is the application order of the rules. In case more than one rule matches the precondition and can be fired, which one will be preferred? This choice may lead to two completely different outputs. Yet another limitation is the reliance on a hash function to generate the same hashes for different-looking expressions. Chances are high that many simplification opportunities can be missed. To overcome these limitations, researchers propose calculating the contribution of a node while generating the output of its parent node. If the contribution is negligible, the tree rooted at that child node can be completely removed, thus shrinking the size of the individual. c = a + b where a = 3 * 10ˆ8 and b = 0.000001</p>
<p>In the example above, the contribution of b in the value of c is extremely small and can be ignored, at least in the majority of cases. To further complicate the situation, imagine b is not just a single node but a complex calculation rooted in a big subtree. Now, with numerical simplification, you can safely remove this subtree without impacting the final result. Algebraic simplification can never find this kind of opportunity. Kinzett et al. (2008) use an algorithm which calculates the numerical contribution of a node on its parents based on the evaluation of training examples. If the impact is less than a threshold, the subtree rooted at the child node can be deleted. A node can also be replaced by a constant if the difference between its maximum and minimum values is below a threshold. The authors conducted several other studies to analyse the building blocks and propose several minor variants of the approach (Kinzett et al. 2009b(Kinzett et al. , a, 2010. The same set of authors, in another approach, proposed to split the simplification process into two phases: proposers and evaluators. Proposers propose a simplified tree by extending the option of applying algebraic rules. Algebraic rules are approximated by calculating the possibility of predicting a parent node through its child node using linear regression. Evaluators calculate the mean squared error between the simplified and the original tree and accept the proposal if the value is below a certain threshold . Rockett (2020) proposed a pruning technique based on statistical permutation tests. A pruning is proposed based on the contribution of a subtree. The proposal is evaluated using a permutation test to study the effect of pruning at the parental level. A validation set is used to corroborate the proposal.</p>
<p>Fitness-based simplification</p>
<p>This category refers to approaches where a portion of an individual's tree is removed or replaced with a constant. The fitnesses of the original tree and the modified tree are then compared and the best one is retained and undergoes further simplification if required. These fitness-based approaches are very similar to the application of a destructive mutation operator. However, they have to make sure that the individual remains syntactically valid after the removal of one or more branches. This destructive simplification often comes at the cost of changes in semantics, so we categorise it under approximate simplification. Alfaro-Cid et al. (2010) proposed a random pruning approach in which some branches of a tree are pruned and replaced by a terminal. The pruned branches are then planted as separate trees. They reported a significant reduction in mean tree sizes while maintaining the quality of fitness. In a similar study, Spector and Helmuth (2014) define pruning as an iterative process which removes one or more instructions from the Push program and then compares the fitness of the pruned program with the fitness of the original program. Nguyen et al. (2016) applied simplification to surrogate-assisted GP in a top-down way. If the subtree has more than one node, replace it with one; otherwise, if it is a constant, replace it with zero. If the modified tree has better fitness, retain it; otherwise, carry on the simplification process to the next levels of the tree. Helmuth et al. (2017) adopted a similar approach and defined various simplification mechanisms in PushGP, but at the genotype level. One of their simplification operators silences a gene, which hence will not be expressed in the phenotype. Another option is to "NOOP" a gene, that is to replace it with a NOOP instruction which, upon execution, will do nothing. The authors of the paper proposed pruning as an operator (Javed and Gobet 2021). The idea was to split a parent into its children and replace it with the child having the highest fitness.</p>
<p>Semantics-based simplification</p>
<p>Semantics-based approaches extend the fitness-based approaches by trying to keep the semantics of the original tree and the modified tree the same. They achieve this by approximating the semantics of the pruned subtree with the replacement subtree. This process is computationally costly, and hence these approaches are usually slow. Naoki et al. (2009) proposed a semantics-based approach which consists of replacing subtrees with an equivalent but shorter tree picked from a simple set. The semantics equivalence is calculated based on the similarity in the output vector on certain regression points. Chu and Nguyen (2017) propose to replace a randomly selected subtree with a terminal of approximate semantics. They did that by growing a tree, using the selection terminal, of approximate semantics. The idea is that the newly grown tree will be shorter in size than the original one. They extended this technique by using an approximate subtree rather than a terminal. That approximate subtree is picked from a library of trees and then a population is grown to match the approximate semantics (Chu et al. 2018). The same authors, Nguyen and Chu (2020), propose another technique in which a subtree is replaced by a tree of desired semantics rather than the approximate semantics of the original tree.</p>
<p>Population-level simplification</p>
<p>Population-wide simplification is inherently different from all the other simplification approaches. Rather than working on single individuals, it tries to simplify the whole population at once. The authors of this paper proposed generation-wide simplification (Gws) (Javed and Gobet 2021). In Gws, after every k th generation, the new population is created by rupturing the individuals rather than by using the routine genetic operators of crossover and mutation. Rupturing of an individual produces many offspring, where every child is a member of the power set of the parent individual. Every child is stored only once to maintain uniqueness in the population and keep the redundancy under check. Although different individuals may produce children with the same genetic makeup, the uniqueness constraint ensures that no two individuals are genetically identical in the new generation. The resulting population may exceed the population size, in which case, only the fittest individuals are retained. If the number of offspring produced is less than the population size, new members are added following the routine genetic operations of crossover and mutation. Population-wide simplification replaces a parent with one of the fittest children formed by rupturing the parent generation. The semantics of these children may differ from that of the parents: as it does not guarantee to preserve the semantics, it belongs to the category of approximate simplification.</p>
<p>Considerations for the design and integration of GP simplification</p>
<p>The previous section presented a review of various simplification algorithms proposed by GP researchers. The reader will have noticed the subtle variations in these algorithms. These variations raise several questions that researchers need to consider while implementing and integrating simplification into the evolutionary process. These questions are critical design decisions that a researcher needs to make. For example, using simplification as a part of the evolutionary process or using it in an offline mode is a critical consideration. It has significant consequences that we shall discuss later in the relevant subsection. Similarly, the choice of syntax versus semantics-based simplification may alter the course of the evolutionary process if used in an online mode. There are several other decisions that we shall cover in the subsequent subsections.</p>
<p>The choice of simplification technique is also crucial for a user of genetic programming. It has consequences beyond the cost in terms of time and resources. Different simplification schemes may lead to a different set of evolved solutions. These differences originate because the simplification algorithm may change the search process and leads to exploration in distinct areas of the search space. So, this section serves an additional purpose of facilitating the end-user to make better-informed decisions.</p>
<p>The following subsections present an organisation of the literature in terms of the design choices and their associated consequences.  (2014) Nguyen et al. (2016) Helmuth et al. (2017) Howard and Edwards (2018) Wong and Zhang (2006) Wong and Zhang (2007 </p>
<p>Offline versus online simplification</p>
<p>Koza used to edit individuals after a successful run. Later on, researchers started developing simplification algorithms to simplify automatically at the end of an evolutionary run. This type of simplification is called offline simplification. It refers to the process of selecting a few best individuals at the end of a run and simplifies them to generate equally performing but shorter individuals. This type of simplification was common in the early days of GP. But gradually, researchers started using simplification as part of the evolutionary run to tackle the bloat phenomenon. So, the idea is to keep in check the growth of the individuals as the evolution progresses. It was primarily because of this bias towards bloat control that the focus of simplification has shifted from its original purpose, which was making individuals more understandable. Thus, most of the studies present the idea of online simplification, except the earlier works of Koza and the ones listed in Table 1. The choice between offline and online becomes the first decision for an end-user or researcher. Now, this decision depends on the objective for which one wants to employ simplification. If the aim is to make final solutions more understandable without worrying about bloat, then one should go for the offline mode. However, if bloat is a concern, and one wants to use simplification to keep it in check, online simplifi-  (2012) Whole population Wong and Zhang (2006) Wong and Zhang (2007 Howard and Edwards (2018) Top k% Chu and Nguyen (2017) Chu et al. (2018) Nguyen and Chu (2020) cation can be of rescue. But one has to pay some extra price in terms of the increase in execution time and computational resources.</p>
<p>Criteria of individual selection for simplification</p>
<p>Simplification is a costly process and needs time and extra computational resources such as memory and processing cycles. However, it is not much of a concern when used offline as it has to deal with few final solutions only. However, the online mode requires careful considerations to make the process more feasible. For example, it makes sense to simplify only a part of the population rather than all individuals of every generation. One needs to ask two questions: First, whether to use simplification in every generation; second, how many individuals to simplify in a generation, and how to select those individuals. To answer the latter question, we arrange the simplification literature into three categories:</p>
<p>• Probabilistic: A certain number of individuals, selected randomly, will undergo simplification. • All individuals: The whole population will experience simplification • Top k% individuals: Only the k% individuals with the highest fitness values will be selected for simplification Table 2 presents this taxonomy. To save cost, very few researchers use simplification in every generation. The issue with probabilistic selection is that it may choose individuals that do not need to be simplified. The same goes for the top k% selection, as being fittest does not necessarily mean that simplification is needed. Another problem with top k% is the choice of appropriate value of k. A more balanced approach is to use simplification after every few generations, and select individuals not just based on fitness but also based on their sizes.</p>
<p>Syntactic, numerical and semantic simplification</p>
<p>Another decision to make is the selection of the type of simplification. By type, we mean simplification based on syntax or semantics. Syntax-based simplification, as the name suggests, selects part of an individual for replacement or removal by matching it against a pre-specified set of rules as explained in Sect. 5.2. Since domain experts design these rules, they guarantee to preserve the semantics of the expression. So, it belongs to the category of exact simplification. The problem with syntax-based simplification is that it fails to capture the cases where individuals with two different genetic makeup yield the same output. It is also not possible to prune the parts of an individual that are not contributing to the final result.</p>
<p>To overcome the problems of algebraic simplification, researchers came up with the idea of numerical simplification. This identifies the contribution of children in the parent and prunes the non-contributing parts. Because of its nature, there is no need to involve domain experts in creating algebraic rules. However, defining the nodes' contribution thresholds is not straightforward and depends on the nature of the application. But once it is set, the removal of the subtrees does not impact the semantics of the individual. So, numerical simplification also belongs to the Exact simplification category.</p>
<p>Both syntactic and numerical simplifications fail to consider the possibility that two syntactically different individuals may yield the same output. Semantic simplification, as explained in Sect. 3, creates further opportunities for simplifying individuals. It does so at the cost of compromising on the semantics and thus belongs to the category of approximate simplification. The limitation of semantic approaches is that the semantics are also problem-dependent. Moreover, finding the semantic equivalent subtree of a smaller size is a time-consuming task.</p>
<p>It is evident from the above discussion that choosing between one of these options is not an easy choice. It often depends on the application and requires the involvement of the domain expert. Table 3 categorises different papers as syntactic, numerical and semantic-based simplification.</p>
<p>Generalisation-ability of simplification</p>
<p>We define generalisation-ability as the possibility of applying the same simplification techniques to a variety of problems belonging to different domains. Although many simplification schemes exist in the literature, most of them are implemented and tested on only a specific category of applications. Some of them are designed to work on regression problems, while others can simplify the individuals solving classification problems. Without tweaking, it is not possible to scale them and use them on another category of problems.</p>
<p>By contrast, there exist some simplification techniques that can work on a variety of problems. These approaches are domain and problem-independent. So, is  Wong and Zhang (2006) Wong and Zhang (2007) Borcheninov and Okulovsky ( Chu and Nguyen (2017) Howard and Edwards (2018) Chu et al. (2018) Nguyen and Chu (2020) Rockett (2020) generalisation-ability a desirable trait for a simplification algorithm? The performance of problem-specific approaches is usually better than the generic ones. They can create more opportunities for simplification. However, if the goal is to provide a technique that can work on multiple categories of problems without any need for intervention from the domain experts, researchers can prefer more generic approaches. Table 4 organises the papers in terms of domain specific and domain independent approaches.</p>
<p>Discussion</p>
<p>Genetic Programming equipped with simplification offers several opportunities. GPgenerated solutions are inherently understandable as they are generated using a combination of user-defined operators. Since these operators are implemented by programmers and are known to domain experts, it is easier to make sense of their combinations. The generated solutions are like programs and the problem of understanding them is similar to understanding what a program is doing. However, without simplification mechanisms in place, this understanding can still be challenging because of the presence of unwanted code. After reviewing the literature and organising it in terms of the design and integration constraints, we observed the potential of simplification and the advantages it can bring to GP. We also observed the adverse effects of simplification on the evolutionary search. Several of the approaches listed in previous sections may lead towards a local optimum and loss in diversity. For this reason, several researchers have opted to apply simplification after a few generations or only  Wong and Zhang (2006) Wong and Zhang (2007 </p>
<p>Mutation/control operators versus simplification operators</p>
<p>The evolutionary algorithm contains and supports a variety of operators. The core of the algorithm uses mutation and crossover operators to construct new individuals.</p>
<p>In this section, we consider how simplification can be incorporated both into these existing operators and as a separate operator: our contention is that simplification can usefully be considered as a separate, standalone operator. In the early days, when researchers started using simplification as a bloat control technique, evolutionary operators were defined and implemented to incorporate aspects of simplification. Ekart (1999) proposed a mutation operator to identify nonfunctional bits of code-the introns-and remove them. She achieved this by defining algebraic simplification rules and applying them to expressions that can be replaced by a simpler one. This operator guarantees to preserve the semantics and fitness of the original expression. Araujo (2004) proposed a cut operator that randomly cuts a subtree, using a higher probability for individuals larger in length. Although she did not label it as a mutation operator, the cut operator can be thought of as such because of its random application-the percentage of occurrence can be controlled by the user. Belle and Ackley (2002) introduced a Uniform Subtree Mutation with the idea that a tree will undergo mutations proportional to its size, following a binomial distribution. Size-fair mutation works like a normal mutation but ensures that the distribution of sizes before and after the mutation is maintained. Thus, in general, the average sizes of the individuals will remain the same after the mutation.</p>
<p>Mutation was not the only way researchers have tried to implement simplification. Kinnear (1993) proposed hoist-a modified version of single crossover-in which a copy of a randomly selected subtree is obtained from an individual. Following the philosophy of size-fair mutation, size-fair crossover randomly selects a crossover point in the first parent and then calculates the size of the subtree rooted at that point (Langdon 2000). The crossover point in the second parent is then chosen so that the size of the subtree rooted at this point is the same as the size of the first parent's subtree. In this way, it ensures that the size of children will not increase after applying the crossover operator.</p>
<p>Simplification can be implemented using other genetic operators, as some of the cases listed above illustrate. However, there are several drawbacks associated with this approach:</p>
<p>• Mutation and crossover are inherently random in nature and must preserve this randomness as it is a fundamental property of GP stochastic search. By contrast, simplification is akin to tuning rather than random modification. • The primary purpose of mutation and crossover is to produce new individuals.</p>
<p>By contrast, the purpose of simplification is to optimise an individual: these two operator types can be considered as complementary, where the primary role of mutation and crossover is the random exploration and exploitation of the search space, and the role of simplification is more similar to a local search. • These operators have no say after the end of an evolutionary run. By contrast, this is the most important time to analyse the individuals for simplification to a shorter, but equally performant, variant.</p>
<p>Although crossover and mutation operators can be tweaked to act like simplification, this approach does not produce a neat and modular design or implementation. Hence, because of these fundamental differences between simplification and other genetic operators, we argue that simplification should be implemented as a standalone operator and not interfere with the natural flow of GP. In this regard, it will act as a plug-and-play feature of GP working in tandem with other operators.</p>
<p>Potential for creative AI</p>
<p>Creative Artificial Intelligence (CAI) attempts to develop human-like solutions for areas in which good solutions are lacking. CAI poses two main challenges: first, the complexity of the search space and, second, the requirement for explainable solutions. GP, unlike many machine learning approaches, generates interpretable solutions. These solutions can often be trimmed to simpler versions; these simplification procedures usually make the solutions easier to understand. So, GP equipped with simplification can soften the challenge of explainability. The first challenge of complexity stems from the fact that CAI's search space is enormous and high dimensional, with many local optima (Miikkulainen 2021). GP can handle this because of its populationbased nature, in which multiple searches are launched at the same time rather than focusing on just one. GP starts these searches from different random starting points and allows them to progress in parallel, which offers better opportunities to avoid local minima. These challenges posed by CAI are also prevalent in the process of creating automated data mining and knowledge discovery systems.</p>
<p>Consideration of other measures of complexity</p>
<p>To be a feasible approach, simplification-equipped GP needs to address several challenges. One such challenge is the appropriate definition of complexity. The issue of complexity has already been addressed in several studies, but often in the context of model selection and the generalisation of performance on unseen data. These studies defined several types of complexities ranging from genotypic complexity to phenotypic complexity and statistical-based measures. A number of complexity measures could be used when simplifying GP programs, such as Minimum Description Length (MDL), Kolmogorov Complexity, Akaike Information Criterion (AIC), and Bayesian Information Criterion (BIC), to mention just a few. Le et al. (2016) provide a useful review of complexity measures in the framework of GP.</p>
<p>Beyond the complexity of GP programs in a formal sense, one must also consider complexity as experienced by humans when trying to understand GP programs. A substantial amount of literature in psychology and cognitive science indicates that at least three factors affect complexity: (a) cognitive factors (e.g., short-term memory capacity, learning rate, speed of processing information) (Simon 1989;Gobet et al. 2011;Hunt 2011); (b) the level of expertise and domain knowledge (Gobet 2016;Shadbolt and O'Hara 1997), which in our case also includes knowledge of the GP operators used and the type of programs generated; and (c) extrinsic factors (e.g., length of programs, presence of recursion, and type of representations used) (Kotovsky and Simon 1990;Weinberg 1998). Ai et al. (2021) explore such ideas with respect to simple two-person games. Their empirical results suggest that machine-learning explanations are helpful only when their level of complexity is appropriate: explanations should not provide too much information and in particular not more information than the explicit description of the solution to a problem. A suitable level of abstraction is needed to satisfy these desiderata. Whether their conclusions hold with GP programs is an open and important question.</p>
<p>Conclusion and future work</p>
<p>This paper has reviewed the literature on the simplification of genetic programs from several perspectives and has identified various trends. One such trend is the shift in the primary objective of simplification. The work on simplification initially started with the focus on understanding the GP-generated models. Gradually, this focus drifted towards controlling bloat. There is now a need for reverting this drift because of the emerging requirement for explainable solutions. Another prominent trend is the shift from syntax-based approaches to semantic ones. Semantic-based techniques offer the advantage of identifying syntactically different individuals with similar semantics. Hence, they can outperform syntactic ones by identifying more simplification possibilities. However, the challenge is on the implementation side of these semantic-based approaches because they can be computationally demanding.</p>
<p>Integrating simplification into an existing GP setup can be challenging. It can adversely affect evolutionary progress. We found that several of these challenges revolve around making simplification a computationally viable option. Some of the points that need careful consideration are the criteria for the selection of individuals for simplification, the scale of application of the simplification algorithm, and the parallelization of this algorithm. The first one deals with how to choose individuals to undergo simplification. Not all individuals are complex enough to be simplified, and including too many individuals increases the cost of simplification. The second consideration is the scale of applicability, which includes questions such as whether simplification should be a part of the evolutionary run, or whether it should be applied only after a run. Another question with online simplification is finding the threshold beyond which simplification hurts the process of evolution. The last consideration is the development of parallel versions of simplification algorithms to make them more efficient.</p>
<p>While organising the literature on simplification, we identified several potential avenues of research that deserve further attention. Most of the simplification literature assumes size as a measure of an individual's complexity. Only two of the studies used execution time as a measure and developed time-based simplification. Their experiments revealed the potential of time-based simplification and its potential to deal with bloat. Several other complexity measures exist and are used in genetic programming but have not been used to date in simplification algorithms. Thus, exploring other measures of complexity and measuring the impact on bloat and the explainability of solutions is an area to explore further. Another less explored area is the development of domain-independent simplification techniques. In most cases either the proposed solutions are problem-specific, or no evidence is furnished of their applicability to other domains. We suggest exploring further the generalisation-ability of simplification algorithms. Furthermore, there is a rich relationship between simplification and compiler optimisation which we have highlighted here and plan to investigate in future.</p>
<p>portion of the population. The following subsections present the potential of GP simplification and our observations on what further research should focus on.</p>
<p>Table 1 Offline
1versus online 
Paper 
Offline 
Online </p>
<p>Naoki et al. (2009) </p>
<p>Spector and Helmuth </p>
<p>Table 2
2Individual selectionSimplification 
All generations 
After k generations </p>
<p>Probabilistic 
Alfaro-Cid et al. (2010) </p>
<p>Borcheninov and Okulovsky </p>
<p>Table 3
3Syntactic, numerical and semantic simplificationPaper 
Syntactic 
Numerical 
Semantic </p>
<p>Table 4
4Generalisation-abilityPaper 
Domain specific 
Domain independent </p>
<p>Acknowledgements This article is part of the project "Genetically Evolving Models in Science (GEMS)" that has received funding from the European Research Council (ERC) under the grant agreement no. ERC-2018-ADG-835002.Declarations
A novel fitness function in genetic programming to handle unbalanced emotion recognition data. D Acharya, S Goel, R Asthana, A Bhardwaj, Pattern Recognit Lett. 133Acharya D, Goel S, Asthana R, Bhardwaj A (2020) A novel fitness function in genetic programming to handle unbalanced emotion recognition data. Pattern Recognit Lett 133:272-279</p>
<p>Beneficial and harmful explanatory machine learning. A V Aho, R Sethi, Jd ; Ullman, Tools Addison-Wesley Ai, L Muggleton, S H Hocquette, C Gromowski, M Schmid, U , Compilers, principles, techniques. 666Aho AV, Sethi R, Ullman JD (1986) Compilers, principles, techniques, and tools. Addison-Wesley Ai L, Muggleton SH, Hocquette C, Gromowski M, Schmid U (2021) Beneficial and harmful explanatory machine learning. Mach Learn 6:66</p>
<p>Bloat control operators and diversity in genetic programming: a comparative study. E Alfaro-Cid, J Merelo, F F De Vega, A I Esparcia-Alcázar, K Sharman, Evol Comput. 182Alfaro-Cid E, Merelo J, de Vega FF, Esparcia-Alcázar AI, Sharman K (2010) Bloat control operators and diversity in genetic programming: a comparative study. Evol Comput 18(2):305-332</p>
<p>Genetic programming for natural language parsing. L Araujo, European conference on genetic programming (EuroGP). Araujo L (2004) Genetic programming for natural language parsing. In: European conference on genetic programming (EuroGP), pp 230-239</p>
<p>Towards the use of genetic programming in the ecological modelling of mosquito population dynamics. I Azzali, L Vanneschi, A Mosca, L Bertolotti, M Giacobini, Genet Program Evol Mach. 214Azzali I, Vanneschi L, Mosca A, Bertolotti L, Giacobini M (2020) Towards the use of genetic programming in the ecological modelling of mosquito population dynamics. Genet Program Evol Mach 21(4):629- 642</p>
<p>Genetic programming: an introduction: on the automatic evolution of computer programs and its applications. W Banzhaf, F D Francone, R E Keller, P Nordin, European conference on genetic programming (EuroGP). San Francisco Belle TV, Ackley DHMorgan KaufmannUniform subtree mutationBanzhaf W, Francone FD, Keller RE, Nordin P (1998) Genetic programming: an introduction: on the automatic evolution of computer programs and its applications. Morgan Kaufmann, San Francisco Belle TV, Ackley DH (2002) Uniform subtree mutation. In: European conference on genetic programming (EuroGP), pp 152-161</p>
<p>Genetic programming-based feature learning for facial expression classification. Y Bi, B Xue, M Zhang, 2020 IEEE congress on evolutionary computation (CEC). Bi Y, Xue B, Zhang M (2020) Genetic programming-based feature learning for facial expression classifi- cation. In: 2020 IEEE congress on evolutionary computation (CEC), pp 1-8</p>
<p>Hash-based tree similarity and simplification in genetic programming for symbolic regression. Y Borcheninov, Y ; Berlin Okulovsky, B Burlacu, L Kammerer, M Affenzeller, G Kronberger, Proceedings of the Spring/Summer young researchers' colloquium on software engineering Brameier MF, Banzhaf W. the Spring/Summer young researchers' colloquium on software engineering Brameier MF, Banzhaf WSpringerInternal and online simplification in genetic programming: an experimental comparison. International conference on computer aided systems theoryBorcheninov Y, Okulovsky Y (2012) Internal and online simplification in genetic programming: an experi- mental comparison. In: Proceedings of the Spring/Summer young researchers' colloquium on software engineering Brameier MF, Banzhaf W (2010) Linear genetic programming, 1st edn. Springer, Berlin Burlacu B, Kammerer L, Affenzeller M, Kronberger G (2019) Hash-based tree similarity and simplification in genetic programming for symbolic regression. In: International conference on computer aided systems theory, pp 361-369</p>
<p>Parkinson's disease diagnosis: towards grammar-based explainable artificial intelligence. F Cavaliere, Della Cioppa, A Marcelli, A Parziale, A Senatore, R , 2020 IEEE symposium on computers and communications (ISCC). Cavaliere F, Della Cioppa A, Marcelli A, Parziale A, Senatore R (2020) Parkinson's disease diagnosis: towards grammar-based explainable artificial intelligence. In: 2020 IEEE symposium on computers and communications (ISCC), pp 1-6</p>
<p>Reducing code bloat in genetic programming based on subtree substituting technique. T H Chu, Q U Nguyen, 2017 21st Asia Pacific symposium on intelligent and evolutionary systems (IES). Chu TH, Nguyen QU (2017) Reducing code bloat in genetic programming based on subtree substituting technique. In: 2017 21st Asia Pacific symposium on intelligent and evolutionary systems (IES), pp 25-30</p>
<p>Semantics based substituting technique for reducing code bloat in genetic programming. T H Chu, Q U Nguyen, V L Cao, Proceedings of the ninth international symposium on information and communication technology. the ninth international symposium on information and communication technologyChu TH, Nguyen QU, Cao VL (2018) Semantics based substituting technique for reducing code bloat in genetic programming. In: Proceedings of the ninth international symposium on information and communication technology, pp 77-83</p>
<p>Multi-objective design of hierarchical consensus functions for clustering ensembles via genetic programming. Alv Coelho, E Fernandes, K Faceli, Decisi Support Syst. 514Coelho ALV, Fernandes E, Faceli K (2011) Multi-objective design of hierarchical consensus functions for clustering ensembles via genetic programming. Decisi Support Syst 514:794-809</p>
<p>Evolutionary algorithms for data mining. P Collet, M L Wong, Genet Program Evol Mach. 131Collet P, Wong ML (2012) Evolutionary algorithms for data mining. Genet Program Evol Mach 13(1):69-70</p>
<p>Operator equalisation and bloat free GP. S Dignum, R Poli, European conference on genetic programming (EuroGP). Dignum S, Poli R (2008) Operator equalisation and bloat free GP. In: European conference on genetic programming (EuroGP), pp 110-121</p>
<p>Shorter fitness preserving genetic programs. A Ekart, European conference on artificial evolution. Ekart A (1999) Shorter fitness preserving genetic programs. In: European conference on artificial evolution, pp 73-83</p>
<p>What's inside the black-box? A genetic programming method for interpreting complex machine learning models. B P Evans, B Xue, M Zhang, Proceedings of the genetic and evolutionary computation conference (GECCO). the genetic and evolutionary computation conference (GECCO)Evans BP, Xue B, Zhang M (2019) What's inside the black-box? A genetic programming method for inter- preting complex machine learning models. In: Proceedings of the genetic and evolutionary computation conference (GECCO), pp 1012-1020</p>
<p>Applying genetic programming to improve interpretability in machine learning models. L A Ferreira, F G Guimarães, R Silva, 2020 IEEE congress on evolutionary computation (CEC). Ferreira LA, Guimarães FG, Silva R (2020) Applying genetic programming to improve interpretability in machine learning models. In: 2020 IEEE congress on evolutionary computation (CEC), pp 1-8</p>
<p>A survey of evolutionary algorithms for data mining and knowledge discovery. A A Freitas, Advances in evolutionary computing. SpringerFreitas AA (2003) A survey of evolutionary algorithms for data mining and knowledge discovery. In: Advances in evolutionary computing. Springer, pp 819-845</p>
<p>Automated machine learning for studying the trade-off between predictive accuracy and interpretability. In: International cross-domain conference for machine learning and knowledge extraction. A A Freitas, Freitas AA (2019) Automated machine learning for studying the trade-off between predictive accuracy and interpretability. In: International cross-domain conference for machine learning and knowledge extraction, pp 48-66</p>
<p>Improving generalization of evolved programs through automatic simplification. F ; Gobet, London Palgrave, F Gobet, P Chassy, M ; London Bilalić, T Helmuth, N F Mcphee, E Pantridge, L Spector, Proceedings of the genetic and evolutionary computation conference (GECCO). the genetic and evolutionary computation conference (GECCO)McGraw HillUnderstanding expertise: a multi-disciplinary approachGobet F (2016) Understanding expertise: a multi-disciplinary approach. Palgrave, London Gobet F, Chassy P, Bilalić M (2011) Foundations of cognitive psychology. McGraw Hill, London Helmuth T, McPhee NF, Pantridge E, Spector L (2017) Improving generalization of evolved programs through automatic simplification. In: Proceedings of the genetic and evolutionary computation con- ference (GECCO), pp 937-944</p>
<p>Explainable ai: the promise of genetic programming multi-run subtree encapsulation. D Howard, M A Edwards, 2018 international conference on machine learning and data engineering (iCMLDE). Howard D, Edwards MA (2018) Explainable ai: the promise of genetic programming multi-run subtree encapsulation. In: 2018 international conference on machine learning and data engineering (iCMLDE), pp 158-159</p>
<p>Can genetic programming perform explainable machine learning for bioinformatics? In: Genetic programming theory and practice XVII. T Hu, SpringerHu T (2020) Can genetic programming perform explainable machine learning for bioinformatics? In: Genetic programming theory and practice XVII. Springer, pp 63-77</p>
<p>Human intelligence. E Hunt, Cambridge University PressCambridgeHunt E (2011) Human intelligence. Cambridge University Press, Cambridge</p>
<p>The identification and exploitation of dormancy in genetic programming. D Jackson, Genet Program Evol Mach. 111Jackson D (2010) The identification and exploitation of dormancy in genetic programming. Genet Program Evol Mach 11(1):89-121</p>
<p>On-the-fly simplification of genetic programming models. N Javed, F Gobet, Proceedings of the 36th annual ACM symposium on applied computing. the 36th annual ACM symposium on applied computingJaved N, Gobet F (2021) On-the-fly simplification of genetic programming models. In: Proceedings of the 36th annual ACM symposium on applied computing, pp 464-471</p>
<p>A linear regression approach to numerical simplification in treebased genetic programming. M Johnston, T Liddle, M Zhang, New Zealand: Research report 09-7. School of Mathematics Statistics and Operations Research, Victoria University of WellingtonTech. Rep.Johnston M, Liddle T, Zhang M (2009) A linear regression approach to numerical simplification in tree- based genetic programming (Tech. Rep.). New Zealand: Research report 09-7, School of Mathematics Statistics and Operations Research, Victoria University of Wellington</p>
<p>A relaxed approach to simplification in genetic programming. M Johnston, T Liddle, M Zhang, European conference on genetic programming. Johnston M, Liddle T, Zhang M (2010) A relaxed approach to simplification in genetic programming. In: European conference on genetic programming (EuroGP), pp 110-121</p>
<p>Evolving a sort: Lessons in genetic programming. K E Kinnear, IEEE international conference on neural networks. Kinnear KE (1993) Evolving a sort: Lessons in genetic programming. In: IEEE international conference on neural networks, pp 881-888</p>
<p>Using numerical simplification to control bloat in genetic programming. D Kinzett, M Zhang, M Johnston, Asia-Pacific conference on simulated evolution and learning. Kinzett D, Zhang M, Johnston M (2008) Using numerical simplification to control bloat in genetic pro- gramming. In: Asia-Pacific conference on simulated evolution and learning, pp 493-502</p>
<p>How online simplification affects building blocks in genetic programming. D Kinzett, M Johnston, M Zhang, Proceedings of the 11th annual conference on genetic and evolutionary computation (GECCO). the 11th annual conference on genetic and evolutionary computation (GECCO)Kinzett D, Johnston M, Zhang M (2009a) How online simplification affects building blocks in genetic programming. In: Proceedings of the 11th annual conference on genetic and evolutionary computation (GECCO), pp 979-986</p>
<p>Numerical simplification for bloat control and analysis of building blocks in genetic programming. D Kinzett, M Johnston, M Zhang, Evol Intell. 24Kinzett D, Johnston M, Zhang M (2009) Numerical simplification for bloat control and analysis of building blocks in genetic programming. Evol Intell 2(4):151-168</p>
<p>Analysis of building blocks with numerical simplification in genetic programming. D Kinzett, M Zhang, M Johnston, European conference on genetic programming (EuroGP). Kinzett D, Zhang M, Johnston M (2010) Analysis of building blocks with numerical simplification in genetic programming. In: European conference on genetic programming (EuroGP), pp 289-300</p>
<p>What makes some problems really hard: explorations in the problem space of difficulty. K Kotovsky, H A Simon, Cognit Psychol. 22Kotovsky K, Simon HA (1990) What makes some problems really hard: explorations in the problem space of difficulty. Cognit Psychol 22:143-183</p>
<p>Genetic programming: on the programming of computers by means of natural selection. J R Koza, MIT PressCambridgeKoza JR (1992) Genetic programming: on the programming of computers by means of natural selection. MIT Press, Cambridge</p>
<p>Human-competitive results produced by genetic programming. J R Koza, Genet Program Evol Mach. 113-4Koza JR (2010) Human-competitive results produced by genetic programming. Genet Program Evol Mach 11(3-4):251-284</p>
<p>Genetic programming-based construction of features for machine learning and knowledge discovery tasks. K Krawiec, Genet Program Evol Mach. 34Krawiec K (2002) Genetic programming-based construction of features for machine learning and knowledge discovery tasks. Genet Program Evol Mach 34:329-343</p>
<p>Behavioral program synthesis with genetic programming. K Krawiec, Proceedings of the IEEE conference on evolutionary computation (ICEC). the IEEE conference on evolutionary computation (ICEC)SpringerEvolution of size in variable length representationsKrawiec K (2015) Behavioral program synthesis with genetic programming, 1st edn. Springer, Berlin Langdon WB (1998) Evolution of size in variable length representations. In: Proceedings of the IEEE conference on evolutionary computation (ICEC), pp 633-638</p>
<p>Size fair and homologous tree crossovers for tree genetic programming. W B Langdon, Genet Program Evol Mach. 11Langdon WB (2000) Size fair and homologous tree crossovers for tree genetic programming. Genet Program Evol Mach 1(1):95-119</p>
<p>Complexity measures in genetic programming learning: a brief review. N Le, H N Xuan, A Brabazon, T P Thi, IEEE congress on evolutionary computation (CEC). Le N, Xuan HN, Brabazon A, Thi TP (2016) Complexity measures in genetic programming learning: a brief review. In: 2016 IEEE congress on evolutionary computation (CEC), pp 2409-2416</p>
<p>Multi-objective genetic programming for manifold learning: balancing quality and dimensionality. A Lensen, M Zhang, B Xue, Genet Program Evol Mach. 213Lensen A, Zhang M, Xue B (2020) Multi-objective genetic programming for manifold learning: balancing quality and dimensionality. Genet Program Evol Mach 21(3):399-431</p>
<p>Creative AI through evolutionary computation: principles and examples. R Miikkulainen, SN Comput Sci. 23Miikkulainen R (2021) Creative AI through evolutionary computation: principles and examples. SN Comput Sci 2(3):1-7</p>
<p>A study on multimodal genetic programming introducing program simplification. K Murano, S Yoshida, T Harada, R Thawonmas, 2018 Joint 10th international conference on soft computing and intelligent systems (SCIS) and 19th international symposium on advanced intelligent systems (ISIS). Murano K, Yoshida S, Harada T, Thawonmas R (2018) A study on multimodal genetic programming introducing program simplification. In: 2018 Joint 10th international conference on soft computing and intelligent systems (SCIS) and 19th international symposium on advanced intelligent systems (ISIS), pp 109-114</p>
<p>A new method for simplifying algebraic expressions in genetic programming called equivalent decision simplification. M Naoki, B Mckay, Xuan N , Daryl E Takeuchi, S , International workconference on artificial neural networks. Naoki M, McKay B, Xuan N, Daryl E, Takeuchi S (2009) A new method for simplifying algebraic expressions in genetic programming called equivalent decision simplification. In: International work- conference on artificial neural networks, pp 171-178</p>
<p>Semantic approximation for reducing code bloat in genetic programming. Q U Nguyen, T H Chu, Swarm Evol Comput. 58100729Nguyen QU, Chu TH (2020) Semantic approximation for reducing code bloat in genetic programming. Swarm Evol Comput 58:100729</p>
<p>Surrogate-assisted genetic programming with simplified models for automated design of dispatching rules. S Nguyen, M Zhang, K C Tan, IEEE Trans Cybernet. 479Nguyen S, Zhang M, Tan KC (2016) Surrogate-assisted genetic programming with simplified models for automated design of dispatching rules. IEEE Trans Cybernet 47(9):2951-2965</p>
<p>TPOT: a tree-based pipeline optimization tool for automating machine learning. R S Olson, J H Moore, Workshop on automatic machine learning. Olson RS, Moore JH (2016) TPOT: a tree-based pipeline optimization tool for automating machine learning. In: Workshop on automatic machine learning, pp 66-74</p>
<p>Automating the design of data mining algorithms: an evolutionary computation approach. G L Pappa, A A Freitas, SpringerBerlin1st ednPappa GL, Freitas AA (2009) Automating the design of data mining algorithms: an evolutionary computation approach, 1st edn. Springer, Berlin</p>
<p>Pruning of genetic programming trees using permutation tests. P Rockett, Evol Intell. 134Rockett P (2020) Pruning of genetic programming trees using permutation tests. Evol Intell 13(4):649-661</p>
<p>Model-based expert systems and the explanation of expertise. N Shadbolt, K O&apos;hara, Expertise in context: human and machine. Shadbolt N, O'Hara K (1997) Model-based expert systems and the explanation of expertise. In: Expertise in context: human and machine, pp 315-337</p>
<p>Operator equalisation for bloat free genetic programming and a survey of bloat control methods. S Silva, S Dignum, L Vanneschi, Genet Program Evol Mach. 132Silva S, Dignum S, Vanneschi L (2012) Operator equalisation for bloat free genetic programming and a survey of bloat control methods. Genet Program Evol Mach 13(2):197-238</p>
<p>Contribution based bloat control in genetic programming. Ha ; A Simon, D Chen, M Zhang, IEEE congress on evolutionary computation (CEC). Yale University PressModels of thoughtSimon HA (1989) Models of thought, vol II. Yale University Press, New Haven Song A, Chen D, Zhang M (2010) Contribution based bloat control in genetic programming. In: 2010 IEEE congress on evolutionary computation (CEC), pp 1-8</p>
<p>Effective simplification of evolved push programs using a simple, stochastic hill-climber. L Spector, T Helmuth, Proceedings of the companion publication of the 2014 annual conference on genetic and evolutionary computation (GECCO). the companion publication of the 2014 annual conference on genetic and evolutionary computation (GECCO)Spector L, Helmuth T (2014) Effective simplification of evolved push programs using a simple, stochastic hill-climber. In: Proceedings of the companion publication of the 2014 annual conference on genetic and evolutionary computation (GECCO), pp 147-148</p>
<p>Learning a formula of interpretability to learn interpretable formulas. M Virgolin, De Lorenzo, A Medvet, E Randone, F , International conference on parallel problem solving from nature (PPSN). Virgolin M, De Lorenzo A, Medvet E, Randone F (2020) Learning a formula of interpretability to learn interpretable formulas. In: International conference on parallel problem solving from nature (PPSN), pp 79-93</p>
<p>Algebraic simplification of GP programs during evolution. G Weinberg, Proceedings of the 8th annual conference on genetic and evolutionary computation (GECCO). the 8th annual conference on genetic and evolutionary computation (GECCO)Dorset House Pub Wong P, Zhang MWeinberg G (1998) The psychology of computer programming. Dorset House Pub Wong P, Zhang M (2006) Algebraic simplification of GP programs during evolution. In: Proceedings of the 8th annual conference on genetic and evolutionary computation (GECCO), pp 927-934</p>
<p>Effects of program simplification on simple building blocks in genetic programming. P Wong, M Zhang, IEEE congress on evolutionary computation (CEC). Wong P, Zhang M (2007) Effects of program simplification on simple building blocks in genetic program- ming. In: 2007 IEEE congress on evolutionary computation (CEC), pp 1570-1577</p>
<p>Feature extraction using multi-objective genetic programming. Y Zhang, P I Rockett, Multiobjective machine learning. SpringerZhang Y, Rockett PI (2006) Feature extraction using multi-objective genetic programming. In: Multi- objective machine learning. Springer, pp 75-99</p>
<p>Genetic-programming-based multi-objective optimization of strategies for home energy-management systems. J Zupančič, B Filipič, M Gams, 203Zupančič J, Filipič B, Gams M (2020) Genetic-programming-based multi-objective optimization of strate- gies for home energy-management systems. Energy203C</p>
<p>Publisher's Note Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations. Publisher's Note Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>            </div>
        </div>

    </div>
</body>
</html>