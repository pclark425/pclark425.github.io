<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-2139 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-2139</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-2139</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-56.html">extraction-schema-56</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of circuit simulators used for training machine learning or reinforcement learning models, including details about simulation fidelity, component modeling accuracy, and transfer performance to real circuits or hardware.</div>
                <p><strong>Paper ID:</strong> paper-279119520</p>
                <p><strong>Paper Title:</strong> <a href="https://export.arxiv.org/pdf/2506.01497v1.pdf" target="_blank">SpiceMixer -- Netlist-Level Circuit Evolution</a></p>
                <p><strong>Paper Abstract:</strong> This paper introduces SpiceMixer, a genetic algorithm developed to synthesize novel analog circuits by evolving SPICE netlists. Unlike conventional methods, SpiceMixer operates directly on netlist lines, enabling compatibility with any component or subcircuit type and supporting general-purpose genetic operations. By using a normalized netlist format, the algorithm enhances the effectiveness of its genetic operators: crossover, mutation, and pruning. We show that SpiceMixer achieves superior performance in synthesizing standard cells (inverter, two-input NAND, and latch) and in designing an analog classifier circuit for the Iris dataset, reaching an accuracy of 89% on the test set. Across all evaluated tasks, SpiceMixer consistently outperforms existing synthesis methods.</p>
                <p><strong>Cost:</strong> 0.012</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e2139.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e2139.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of circuit simulators used for training machine learning or reinforcement learning models, including details about simulation fidelity, component modeling accuracy, and transfer performance to real circuits or hardware.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>SPICE</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>SPICE (Simulation Program with Integrated Circuit Emphasis)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>General-purpose circuit simulator used to evaluate netlist behavior (transient, timing, voltages, power) during automated circuit synthesis; served as the fitness/evaluation engine for genetic, RL and ES-based synthesis in this work.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>circuit_type</strong></td>
                            <td>digital standard cells (inverter, NAND2, latch) and analog classifier (CMOS analog discriminant circuit)</td>
                        </tr>
                        <tr>
                            <td><strong>simulator_tool</strong></td>
                            <td>SPICE (netlist-level SPICE simulations; transient simulation used)</td>
                        </tr>
                        <tr>
                            <td><strong>component_models</strong></td>
                            <td>Foundry PDK device subcircuits from Skywater 130 nm (sky130_fd_pr__nfet_01v8 and sky130_fd_pr__pfet_01v8) used as transistor models; simulations use full device models provided by the PDK and include sizing (W/L) parameters; for some experiments subcircuits (e.g., inverter, tri-state inverter) from the PDK were used as building blocks and transistor dimensions were sometimes fixed (e.g., latch case).</td>
                        </tr>
                        <tr>
                            <td><strong>parasitics_modeled</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>nonlinearities_modeled</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>tolerances_variations</strong></td>
                            <td>none during training (no Monte Carlo nor process-corner sweeps reported); post-training input perturbation (additive Gaussian input voltage noise) was used to test robustness.</td>
                        </tr>
                        <tr>
                            <td><strong>ml_model_type</strong></td>
                            <td>Genetic algorithm operating on SPICE netlists (SpiceMixer); compared against RL methods (REINFORCE with Leave-One-Out, Evolution Strategies) and CMA-ES (pycma) which also use SPICE evaluations.</td>
                        </tr>
                        <tr>
                            <td><strong>training_task</strong></td>
                            <td>Automated circuit topology search and sizing (synthesize inverter, two-input NAND, static latch) and design of an analog classifier (Iris dataset) where SPICE simulation outputs define the reward/fitness.</td>
                        </tr>
                        <tr>
                            <td><strong>simulation_performance</strong></td>
                            <td>Used to evaluate candidate circuits: inverter synthesis achieved valid solutions and required ~25x fewer SPICE simulations than GraCo ES; NAND2: 28/33 successful syntheses meeting voltage/power constraints, circuits found were on average >200 ps faster than fastest GraCo ES circuit (example best timings quoted: Trise=9.45 ps, Tfall=10.35 ps, Tr2f=7.5 ps, Tf2r=6.93 ps); latch: SpiceMixer found static latch in 2 of 4 runs (validated with long transient); analog classifier: best-validation circuit achieved train 98.1%, val 96.7%, test 88.9% (another best-train netlist: train 98.9%, val 83.3%, test 88.9%).</td>
                        </tr>
                        <tr>
                            <td><strong>real_hardware_tested</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>real_hardware_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_comparison</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_comparison_details</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>minimal_requirements_discussed</strong></td>
                            <td>Paper enforces manufacturing constraints (e.g., force bulk to supply/gnd, prevent supply/gnd as gate) and uses reward components for voltages, timing, and power — implying these physical metrics must be captured in simulation, but the paper does not explicitly state a minimal simulator fidelity for transfer.</td>
                        </tr>
                        <tr>
                            <td><strong>transfer_failure_cases</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>domain_randomization_used</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>physics_informed_approach</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>frequency_range</strong></td>
                            <td>Transient simulations spanning picosecond-to-millisecond timescales depending on task: e.g., latch testing used tstep=1 ps, tstop=16 ns (and long-run tstep=1 ns, tstop=1.6 ms); classifier used pulse-based transient per-sample (input voltages in [0,1] V).</td>
                        </tr>
                        <tr>
                            <td><strong>electromagnetic_effects</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>thermal_effects</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e2139.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e2139.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of circuit simulators used for training machine learning or reinforcement learning models, including details about simulation fidelity, component modeling accuracy, and transfer performance to real circuits or hardware.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>GraCo</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>GraCo - A graph composer for integrated circuits</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A graph-based automated IC synthesis framework referenced and used as the foundation and comparison baseline; GraCo translates graphs to SPICE netlists and uses SPICE simulations together with RL (RLOO and ES) to guide topology generation.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>GraCo -A graph composer for integrated circuits.</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>circuit_type</strong></td>
                            <td>general integrated circuits used for topology synthesis (same domains as SpiceMixer: standard cells and analog blocks)</td>
                        </tr>
                        <tr>
                            <td><strong>simulator_tool</strong></td>
                            <td>SPICE (GraCo translates graphs to netlists evaluated by SPICE simulations for reward computation)</td>
                        </tr>
                        <tr>
                            <td><strong>component_models</strong></td>
                            <td>Uses PDK device/subcircuit models when target PDK is provided (the paper builds on GraCo and uses Skywater 130 nm PDK in experiments), i.e., realistic transistor subcircuits rather than idealized devices.</td>
                        </tr>
                        <tr>
                            <td><strong>parasitics_modeled</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>nonlinearities_modeled</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>tolerances_variations</strong></td>
                            <td>none reported for GraCo in this paper (no Monte Carlo/process corners reported); GraCo reward uses saturation and normalized quadratic errors comparing simulated metrics to targets.</td>
                        </tr>
                        <tr>
                            <td><strong>ml_model_type</strong></td>
                            <td>Reinforcement learning methods: REINFORCE with Leave-One-Out (RLOO) and Evolution Strategies (ES) as implemented in GraCo and compared against SpiceMixer and CMA-ES.</td>
                        </tr>
                        <tr>
                            <td><strong>training_task</strong></td>
                            <td>Topology construction and sizing guided by SPICE-evaluated rewards (voltage levels, timing, power).</td>
                        </tr>
                        <tr>
                            <td><strong>simulation_performance</strong></td>
                            <td>GraCo ES could find valid inverter solutions but required many more SPICE simulations than SpiceMixer (~25× more for inverter); for NAND2 GraCo ES achieved only 2 successful runs out of 48 (much worse success rate and slower circuits than SpiceMixer).</td>
                        </tr>
                        <tr>
                            <td><strong>real_hardware_tested</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>real_hardware_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_comparison</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_comparison_details</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>minimal_requirements_discussed</strong></td>
                            <td>GraCo's reward design relies on SPICE outputs (voltages, timing, power) and uses saturation to consider a subreward fully met; the current paper inherits that reward but does not add minimum-fidelity prescriptions for sim models.</td>
                        </tr>
                        <tr>
                            <td><strong>transfer_failure_cases</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>domain_randomization_used</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>physics_informed_approach</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>frequency_range</strong></td>
                            <td>Same transient regimes as used for tasks; timings measured in picoseconds to nanoseconds for standard-cell evaluation.</td>
                        </tr>
                        <tr>
                            <td><strong>electromagnetic_effects</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>thermal_effects</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e2139.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e2139.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of circuit simulators used for training machine learning or reinforcement learning models, including details about simulation fidelity, component modeling accuracy, and transfer performance to real circuits or hardware.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Skywater PDK</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Skywater 130 nm PDK (sky130_fd_pr__* device/subcircuit models)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Foundry process design kit used to provide device/subcircuit models (NMOS/PMOS and standard-cell subcircuits) for SPICE simulations in all presented synthesis experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Skywater 130nm PDK.</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>circuit_type</strong></td>
                            <td>CMOS digital standard cells and analog CMOS circuits</td>
                        </tr>
                        <tr>
                            <td><strong>simulator_tool</strong></td>
                            <td>Used within SPICE simulations as the device/subcircuit library (netlists reference sky130_fd_pr__nfet_01v8 and sky130_fd_pr__pfet_01v8 and PDK subcircuits for inverters and tri-state inverters).</td>
                        </tr>
                        <tr>
                            <td><strong>component_models</strong></td>
                            <td>Foundry-provided transistor/subcircuit models (PDK); experiments use named PDK transistor subcircuits and explicit W/L sizing; in some experiments entire PDK subcircuits (e.g., sky130_fd_pr__inv_01v8) were used as building blocks.</td>
                        </tr>
                        <tr>
                            <td><strong>parasitics_modeled</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>nonlinearities_modeled</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>tolerances_variations</strong></td>
                            <td>No process corner or Monte Carlo variability reported; manufacturing constraints from the PDK (bulk/supply wiring rules) were enforced during synthesis.</td>
                        </tr>
                        <tr>
                            <td><strong>ml_model_type</strong></td>
                            <td>Not an ML model; used as physical model library for GA/RL/ES evaluations.</td>
                        </tr>
                        <tr>
                            <td><strong>training_task</strong></td>
                            <td>Provide accurate device behavior (I/V characteristics, timing) for topology and sizing synthesis tasks (standard cells and analog classifier).</td>
                        </tr>
                        <tr>
                            <td><strong>simulation_performance</strong></td>
                            <td>Enables realistic timing and voltage evaluation used to judge candidate circuits; specific synthesized circuit metrics (e.g., NAND2 timings and classifier accuracies) are obtained using these PDK models in SPICE.</td>
                        </tr>
                        <tr>
                            <td><strong>real_hardware_tested</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>real_hardware_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_comparison</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_comparison_details</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>minimal_requirements_discussed</strong></td>
                            <td>Paper enforces PDK-consistent wiring/manufacturing constraints and uses PDK device models for evaluation, implying PDK-level models are required for realistic synthesis, but no formal minimal-fidelity study is provided.</td>
                        </tr>
                        <tr>
                            <td><strong>transfer_failure_cases</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>domain_randomization_used</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>physics_informed_approach</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>frequency_range</strong></td>
                            <td>DC to fast transient digital timescales (ps–ms) as used in experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>electromagnetic_effects</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>thermal_effects</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>GraCo -A graph composer for integrated circuits. <em>(Rating: 2)</em></li>
                <li>AutoCkt: Deep reinforcement learning of analog circuit designs. <em>(Rating: 2)</em></li>
                <li>Deep reinforcement learning for analog circuit structure synthesis. <em>(Rating: 2)</em></li>
                <li>AnalogCoder: Analog circuit design via training-free code generation. <em>(Rating: 1)</em></li>
                <li>AnalogGenie: A generative engine for automatic discovery of analog circuit topologies. <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-2139",
    "paper_id": "paper-279119520",
    "extraction_schema_id": "extraction-schema-56",
    "extracted_data": [
        {
            "name_short": "SPICE",
            "name_full": "SPICE (Simulation Program with Integrated Circuit Emphasis)",
            "brief_description": "General-purpose circuit simulator used to evaluate netlist behavior (transient, timing, voltages, power) during automated circuit synthesis; served as the fitness/evaluation engine for genetic, RL and ES-based synthesis in this work.",
            "citation_title": "",
            "mention_or_use": "use",
            "circuit_type": "digital standard cells (inverter, NAND2, latch) and analog classifier (CMOS analog discriminant circuit)",
            "simulator_tool": "SPICE (netlist-level SPICE simulations; transient simulation used)",
            "component_models": "Foundry PDK device subcircuits from Skywater 130 nm (sky130_fd_pr__nfet_01v8 and sky130_fd_pr__pfet_01v8) used as transistor models; simulations use full device models provided by the PDK and include sizing (W/L) parameters; for some experiments subcircuits (e.g., inverter, tri-state inverter) from the PDK were used as building blocks and transistor dimensions were sometimes fixed (e.g., latch case).",
            "parasitics_modeled": null,
            "nonlinearities_modeled": true,
            "tolerances_variations": "none during training (no Monte Carlo nor process-corner sweeps reported); post-training input perturbation (additive Gaussian input voltage noise) was used to test robustness.",
            "ml_model_type": "Genetic algorithm operating on SPICE netlists (SpiceMixer); compared against RL methods (REINFORCE with Leave-One-Out, Evolution Strategies) and CMA-ES (pycma) which also use SPICE evaluations.",
            "training_task": "Automated circuit topology search and sizing (synthesize inverter, two-input NAND, static latch) and design of an analog classifier (Iris dataset) where SPICE simulation outputs define the reward/fitness.",
            "simulation_performance": "Used to evaluate candidate circuits: inverter synthesis achieved valid solutions and required ~25x fewer SPICE simulations than GraCo ES; NAND2: 28/33 successful syntheses meeting voltage/power constraints, circuits found were on average &gt;200 ps faster than fastest GraCo ES circuit (example best timings quoted: Trise=9.45 ps, Tfall=10.35 ps, Tr2f=7.5 ps, Tf2r=6.93 ps); latch: SpiceMixer found static latch in 2 of 4 runs (validated with long transient); analog classifier: best-validation circuit achieved train 98.1%, val 96.7%, test 88.9% (another best-train netlist: train 98.9%, val 83.3%, test 88.9%).",
            "real_hardware_tested": false,
            "real_hardware_performance": null,
            "fidelity_comparison": false,
            "fidelity_comparison_details": "",
            "minimal_requirements_discussed": "Paper enforces manufacturing constraints (e.g., force bulk to supply/gnd, prevent supply/gnd as gate) and uses reward components for voltages, timing, and power — implying these physical metrics must be captured in simulation, but the paper does not explicitly state a minimal simulator fidelity for transfer.",
            "transfer_failure_cases": "",
            "domain_randomization_used": false,
            "physics_informed_approach": true,
            "frequency_range": "Transient simulations spanning picosecond-to-millisecond timescales depending on task: e.g., latch testing used tstep=1 ps, tstop=16 ns (and long-run tstep=1 ns, tstop=1.6 ms); classifier used pulse-based transient per-sample (input voltages in [0,1] V).",
            "electromagnetic_effects": null,
            "thermal_effects": null,
            "uuid": "e2139.0"
        },
        {
            "name_short": "GraCo",
            "name_full": "GraCo - A graph composer for integrated circuits",
            "brief_description": "A graph-based automated IC synthesis framework referenced and used as the foundation and comparison baseline; GraCo translates graphs to SPICE netlists and uses SPICE simulations together with RL (RLOO and ES) to guide topology generation.",
            "citation_title": "GraCo -A graph composer for integrated circuits.",
            "mention_or_use": "use",
            "circuit_type": "general integrated circuits used for topology synthesis (same domains as SpiceMixer: standard cells and analog blocks)",
            "simulator_tool": "SPICE (GraCo translates graphs to netlists evaluated by SPICE simulations for reward computation)",
            "component_models": "Uses PDK device/subcircuit models when target PDK is provided (the paper builds on GraCo and uses Skywater 130 nm PDK in experiments), i.e., realistic transistor subcircuits rather than idealized devices.",
            "parasitics_modeled": null,
            "nonlinearities_modeled": true,
            "tolerances_variations": "none reported for GraCo in this paper (no Monte Carlo/process corners reported); GraCo reward uses saturation and normalized quadratic errors comparing simulated metrics to targets.",
            "ml_model_type": "Reinforcement learning methods: REINFORCE with Leave-One-Out (RLOO) and Evolution Strategies (ES) as implemented in GraCo and compared against SpiceMixer and CMA-ES.",
            "training_task": "Topology construction and sizing guided by SPICE-evaluated rewards (voltage levels, timing, power).",
            "simulation_performance": "GraCo ES could find valid inverter solutions but required many more SPICE simulations than SpiceMixer (~25× more for inverter); for NAND2 GraCo ES achieved only 2 successful runs out of 48 (much worse success rate and slower circuits than SpiceMixer).",
            "real_hardware_tested": false,
            "real_hardware_performance": null,
            "fidelity_comparison": false,
            "fidelity_comparison_details": "",
            "minimal_requirements_discussed": "GraCo's reward design relies on SPICE outputs (voltages, timing, power) and uses saturation to consider a subreward fully met; the current paper inherits that reward but does not add minimum-fidelity prescriptions for sim models.",
            "transfer_failure_cases": "",
            "domain_randomization_used": false,
            "physics_informed_approach": true,
            "frequency_range": "Same transient regimes as used for tasks; timings measured in picoseconds to nanoseconds for standard-cell evaluation.",
            "electromagnetic_effects": null,
            "thermal_effects": null,
            "uuid": "e2139.1"
        },
        {
            "name_short": "Skywater PDK",
            "name_full": "Skywater 130 nm PDK (sky130_fd_pr__* device/subcircuit models)",
            "brief_description": "Foundry process design kit used to provide device/subcircuit models (NMOS/PMOS and standard-cell subcircuits) for SPICE simulations in all presented synthesis experiments.",
            "citation_title": "Skywater 130nm PDK.",
            "mention_or_use": "use",
            "circuit_type": "CMOS digital standard cells and analog CMOS circuits",
            "simulator_tool": "Used within SPICE simulations as the device/subcircuit library (netlists reference sky130_fd_pr__nfet_01v8 and sky130_fd_pr__pfet_01v8 and PDK subcircuits for inverters and tri-state inverters).",
            "component_models": "Foundry-provided transistor/subcircuit models (PDK); experiments use named PDK transistor subcircuits and explicit W/L sizing; in some experiments entire PDK subcircuits (e.g., sky130_fd_pr__inv_01v8) were used as building blocks.",
            "parasitics_modeled": null,
            "nonlinearities_modeled": true,
            "tolerances_variations": "No process corner or Monte Carlo variability reported; manufacturing constraints from the PDK (bulk/supply wiring rules) were enforced during synthesis.",
            "ml_model_type": "Not an ML model; used as physical model library for GA/RL/ES evaluations.",
            "training_task": "Provide accurate device behavior (I/V characteristics, timing) for topology and sizing synthesis tasks (standard cells and analog classifier).",
            "simulation_performance": "Enables realistic timing and voltage evaluation used to judge candidate circuits; specific synthesized circuit metrics (e.g., NAND2 timings and classifier accuracies) are obtained using these PDK models in SPICE.",
            "real_hardware_tested": false,
            "real_hardware_performance": null,
            "fidelity_comparison": false,
            "fidelity_comparison_details": "",
            "minimal_requirements_discussed": "Paper enforces PDK-consistent wiring/manufacturing constraints and uses PDK device models for evaluation, implying PDK-level models are required for realistic synthesis, but no formal minimal-fidelity study is provided.",
            "transfer_failure_cases": "",
            "domain_randomization_used": false,
            "physics_informed_approach": true,
            "frequency_range": "DC to fast transient digital timescales (ps–ms) as used in experiments.",
            "electromagnetic_effects": null,
            "thermal_effects": null,
            "uuid": "e2139.2"
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "GraCo -A graph composer for integrated circuits.",
            "rating": 2
        },
        {
            "paper_title": "AutoCkt: Deep reinforcement learning of analog circuit designs.",
            "rating": 2
        },
        {
            "paper_title": "Deep reinforcement learning for analog circuit structure synthesis.",
            "rating": 2
        },
        {
            "paper_title": "AnalogCoder: Analog circuit design via training-free code generation.",
            "rating": 1
        },
        {
            "paper_title": "AnalogGenie: A generative engine for automatic discovery of analog circuit topologies.",
            "rating": 1
        }
    ],
    "cost": 0.01226075,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>SpiceMixer -Netlist-Level Circuit Evolution</p>
<p>Stefan Uhlich 
Andrea Bonetti 
Arun Venkitaraman 
Chia-Yu Hsieh 
Mustafa Emre Gürsoy 
Ryoga Matsuo 
Lorenzo Servadei 
Sony Semiconductor 
Solutions Europe 
Germany 
Sonyai 
Switzerland 
Switzerland Epfl 
T U Munich 
SpiceMixer -Netlist-Level Circuit Evolution
4F91F2301E83B43A50F9C21C698A0EAAAnalog circuit synthesisgenetic algorithmSPICE netlist evolutionstandard cell synthesisanalog classifier
This paper introduces SpiceMixer, a genetic algorithm developed to synthesize novel analog circuits by evolving SPICE netlists.Unlike conventional methods, SpiceMixer operates directly on netlist lines, enabling compatibility with any component or subcircuit type and supporting general-purpose genetic operations.By using a normalized netlist format, the algorithm enhances the effectiveness of its genetic operators: crossover, mutation, and pruning.We show that SpiceMixer achieves superior performance in synthesizing standard cells (inverter, two-input NAND, and latch) and in designing an analog classifier circuit for the Iris dataset, reaching an accuracy of 89% on the test set.Across all evaluated tasks, SpiceMixer consistently outperforms existing synthesis methods.</p>
<p>I. INTRODUCTION</p>
<p>Despite recent progress, analog circuit design remains a challenging and time-intensive process, often relying heavily on expert knowledge and manual tuning [1], [2].While machine learning and optimization techniques have advanced automated digital design, progress in analog automation has been slower due to the complexity of analog design spaces.</p>
<p>In this work, we present SpiceMixer, a genetic algorithm (GA) framework that evolves SPICE netlists.The general approach is illustrated in Fig. 1.Unlike other methods, SpiceMixer operates directly on SPICE netlists, which motivates its name.By applying genetic operations such as crossover, mutation, and pruning at the netlist level, SpiceMixer avoids the need for abstract graph representations or custom GA chromosome encodings of circuits.This straightforward yet robust approach enables efficient exploration of the analog design space and successfully synthesizes standard cells as well as addresses new tasks, such as constructing analog discriminant functions, outperforming prior methods.The main contributions of this paper are:</p>
<p>• We introduce SpiceMixer, a netlist-level genetic algorithm for analog synthesis with tuned hyperparameters balancing crossover, mutation, and pruning operations.</p>
<p>• We demonstrate its effectiveness in designing standard digital cells (inverter, two-input NAND (NAND2), latch) and compare its performance against existing methods in the literature.• We design an analog classifier that takes input features as voltages and identifies the predicted class via the highest output voltage, functioning similarly to a discriminant function.This paper is structured as follows: Sec.II reviews related work and positions SpiceMixer within that context, including a brief overview of the GraCo framework from [3], which underpins our approach.Sec.III details the SpiceMixer method and its genetic netlist operations.Sec.IV presents experimental results and compares SpiceMixer to two GraCo-based methods and the Covariance Matrix Adaptation Evolution Strategy (CMA-ES) [4].Finally, Sec.V gives our conclusions and an outlook on future work.</p>
<p>II. RELATED WORK</p>
<p>A. Circuit Synthesis Methods</p>
<p>Circuit synthesis generally involves two main steps: (i) determining the appropriate topology, meaning the selection of circuit components and their connections, and (ii) selecting the optimal parameter sizes for these components [5].</p>
<p>Substantial progress has been made in component sizing, as demonstrated in [6]- [11].A recent comprehensive overview can be found in [10].However, identifying the correct topology remains Fig. 1: Proposed SpiceMixer approach.We use three genetic operators: pruning, mutation, and crossover, which apply component mixing or netlist mixing, each with equal probability to generate a new offspring netlist, evaluated using a SPICE simulation.Fig. 2: Example of crossover using netlist mixing.Net names follow a specific naming convention (input, output, internal, supply) allowing SpiceMixer to merge netlists together in a meaningful way to produce an offspring which has a higher reward than its two parents.</p>
<p>a challenging and largely open problem.In recent years, several promising approaches have been proposed.For example, autoregressive models like AnalogCoder [12] or AnalogXpert [13] can translate task descriptions and specifications directly into PySpice netlists or select subcircuit blocks and their connections, while AnalogGenie [14] models Eulerian cycles autoregressively to generate circuit topologies.The analogy between circuits and graphs has also been explored in depth, including the use of graph neural networks trained via supervised or reinforcement learning, as seen in [3], [15], [16].Other strategies leverage predefined library components, as demonstrated in [17], [18].Another notable branch of work applies genetic algorithms (GA) to circuit synthesis, the category into which our proposed SpiceMixer method also falls.GA has been successfully applied not only for sizing [19]- [23] but also for topology search [24]- [31].While some of these works focus on specific applications, such as digital filter design [28]- [30] or operational amplifiers [25], they generally rely on specialized representations (most often chromosome encodings [31], but sometimes also computer programs [32] or connection matrices [27]) to represent the circuit topology.In contrast, SpiceMixer operates directly on the netlist and uses it as its representation, avoiding the need for a specific chromosome encoding, e.g., to handle a new component, and making it naturally applicable to any component type, while also handling circuits of varying sizes, something that would otherwise require a variable-length chromosome representation as in [31] making the genetic operations much more involved, e.g., requiring specialized crossover algorithms that are context-aware.</p>
<p>B. GraCo Framework</p>
<p>Since SpiceMixer builds upon GraCo [3], we begin with a brief overview of this framework before describing our approach.</p>
<p>GraCo is a framework for the automated synthesis of integrated circuits (ICs).It constructs circuit topologies by representing them as graphs, which are then translated into netlists and evaluated using SPICE simulations.To guide the sampling process, GraCo applies design constraints and consistency checks.</p>
<p>In its reinforcement learning setup, GraCo uses a reward function designed to maximize a value between −1 and 1 based on SPICE simulation outcomes.The reward is computed as the average of multiple subrewards, where each subreward compares a simulated metric (such as voltage levels, timing, or power) to its target using a normalized quadratic error.A saturation function ensures that subrewards reach 1 only when the defined specifications are fully met.Once all subrewards achieve 1, the circuit is considered valid, and sampling is terminated.This reward function is also used in SpiceMixer, where it is often referred to as the fitness function in the context of genetic algorithms.</p>
<p>GraCo supports two reinforcement learning methods: REINFORCE with Leave-One-Out (RLOO) [26], [33] and Evolution Strategies (ES) [34].As reported in [3], ES has shown greater effectiveness in exploring complex design spaces and achieving superior synthesis outcomes.</p>
<p>Additionally, a random graph sampler was used in [3] as a baseline.This sampler generates circuits by uniformly selecting components, connections, and sizing parameters, without relying on feedback or prior knowledge.In SpiceMixer, this random sampler is employed to create the initial netlist population, which is then refined through crossover, mutation, or pruning.Notably, the random sampler also applies explicit wiring rules and consistency checks, making it a good initial method to generate the starting population despite its simplicity.</p>
<p>III. SpiceMixer APPROACH</p>
<p>We now describe our SpiceMixer method, which applies a genetic algorithm to synthesize circuits.We first introduce the normalized netlist format used, which makes the two core genetic operations, netlist mixing and component mixing, both reasonable and effective.Finally, we present the complete approach, as summarized in Fig. 1.</p>
<p>A. Normalization of Netlists</p>
<p>All netlists follow a standardized format designed to enhance the performance of the genetic operations.Specifically, we apply consistent net naming conventions: net_input_%d, net_supply_%d, net_output_%d, and net_internal_%d to represent input, supply, output, and internal nets, respectively.In addition, we apply the following normalizations, which preserve the underlying circuit but uniformize the netlist:</p>
<p>• Line sorting: organizes netlist lines (i.e., component definitions) into input, internal, and output blocks based on the net names they connect to and sorts lines within each block alphabetically.following operations, selected randomly with equal probability at each line index:</p>
<p>• Add a line from the first netlist (if available).</p>
<p>• Add a line from the second netlist (if available).</p>
<p>• Add lines from both netlists (if available).</p>
<p>• Skip both lines.</p>
<p>The netlist mixing procedure is summarized in the Appendix as Alg. 1, with an example shown in Fig. 2.After crossover, the resulting offspring netlist is normalized as described in Sec.III-A.</p>
<p>Two key points are worth noting: First, this approach roughly maintains the netlist length since all actions are equally probable; however, netlists can still shrink or grow over time if doing so improves the observed reward as we use roulette-wheel sampling from the elite set.Second, merging is effective because netlists are represented in a normalized form as discussed before.This enables meaningful combinations of netlists drawn from the elite set or the random sampler.</p>
<p>2) Mutation -Mixing of an Elite and a Random Netlist: This genetic operator also uses netlist mixing but combines one elite parent with a randomly generated netlist.This process can introduce novel components with new wirings and sizings into the elite set.</p>
<p>Importantly, we do not select lines from the random netlist with equal probability.As the elite netlists improve over time, mixing them line-wise with equal weights with a random one would typically produce an inferior offspring, which would fail to enter the elite set.To address this, we lower the selection probability for the random netlist such that, on average, 70% of the lines are retained from the elite parent, and only 30% are mutated.This ratio was determined empirically by analyzing which genetic operations successfully contributed to the elite circuits as we will discuss later in Sec.IV-A.</p>
<p>3) Pruning -Mixing of two Components: To produce a new, more compact netlist, we apply component pruning.This involves mixing two component definitions, that is, two netlist lines, which have the same number of elements (i.e., components with the same total count of nets and parameters), and retaining only the newly generated line, replacing the two original ones.Specifically, for each element, we randomly choose with equal probability whether to keep it from the first or the second component definition.Overall, we apply this pruning step up to 1 + ⌊0.1 • L⌋ times, where L is the number of lines in the netlist and ⌊.⌋ denotes rounding down to the nearest integer.The factor 0.1 was determined empirically by analyzing which genetic operations most effectively contributed to elite circuits.This process is summarized in the Appendix as Algs. 2 and 3, with an example shown in Fig. 3.</p>
<p>Note that this operation can sometimes produce invalid netlists if the two component definitions have the same number of lines but completely different meanings (e.g., mixing M1 D G S B NMOS with V1 vdd 0 DC 1.8).However, in all of our examples, we synthesize circuits using only NMOS/PMOS transistors or subcircuits with unique parameter counts, so this issue does not arise.</p>
<p>C. Summary of Full Approach</p>
<p>After initializing the population with the random sampler from GraCo, we apply one of the following three genetic operations, each with equal probability, as introduced in the previous section:</p>
<p>• Crossover between two elite netlists, • Mutation of an elite netlist by mixing it with a random netlist, • Pruning to reduce the number of component definitions.For both mutation and crossover, parent netlists are selected from the best candidates identified so far, the elite set, using roulette-   I: Effect of consistency checks on NAND2 synthesis performance for SpiceMixer.Each sampling method was run three times, with results sorted by value.We show the average train reward (higher is better; averaged over all training steps) and, for convenience, the "Optimality gap" defined as 1−Best reward (lower is better).Gap values below 1/15 = 0.06 have the correct voltage output and do not exceed the maximum power constraints but differ in their timing behavior and are highlighted in blue.We highlight the best and second best circuits where the best one is on average 3 ps faster than the second best.</p>
<p>wheel sampling based on their rank. 1 Roulette-wheel sampling assigns selection probability proportional to rank, i.e., higher-ranked candidates receive larger "slices" of the probability wheel, increasing their selection chances while still allowing lower-ranked candidates some opportunity, thus maintaining genetic diversity.To define the elite set size, we either use a ratio η of all netlists evaluated so far or a fixed size ζ. 2 We will show in Sec.IV-A that ζ = 30 yielded the best performance in our experiments.The complete SpiceMixer algorithm is summarized in the Appendix as Alg. 4. Please note that the best netlist can be visualized using an ML tool such as the LLM-based system [35], which helps designers better understand the discovered solutions.</p>
<p>IV. SYNTHESIS RESULTS</p>
<p>In the following, we first discuss the selection of hyperparameters for SpiceMixer.We then present results for synthesizing standard cells (inverter, NAND2, and latch) as well as an analog classifier for the Iris dataset.All designs use the Skywater 130 nm PDK [36].</p>
<p>A. Optimal SpiceMixer Hyperparameters</p>
<p>Selecting an appropriate elite set size is crucial, as it strongly affects the performance of a genetic algorithm.For SpiceMixer, a small elite set leads to insufficient diversity among offspring circuits, causing convergence to suboptimal solutions.Conversely, a large elite set results in poor exploitation of the most successful circuits.To address this, we performed a grid search to identify the optimal values of η (for defining a relative elite set size) or ζ (for defining an absolute elite set size) when synthesizing an inverter and a NAND2 gate.For both tasks, the synthesis process was terminated either when the overall reward, evaluating output voltages and timings through the reward function, reached a value of 1, indicating successful circuit synthesis, or when the maximum number of simulations was reached.</p>
<p>Fig. 4 shows the number of SPICE simulations required to synthesize an inverter and a NAND2 across 30 runs.The results show that a fixed elite size of ζ = 30 netlists consistently produces the best outcomes, enabling successful synthesis while minimizing the median number of simulations needed.</p>
<p>When designing the genetic operations, two additional hyperparameters must be considered: for "mutation" the number of lines from the elite parent that can be replaced with lines from the random netlist, and for "pruning" the number of lines to be pruned from the parent netlist.Ideally, these parameters should be selected to ensure that the generated offspring circuits are stronger and successfully enter the elite set.We tuned these parameters through preliminary experiments and adopted the values described in Sec.III-B.For these experiments, we analyzed which genetic operations contributed to generating the elite circuits, with the results for the final chosen values shown in Fig. 5 for the NAND2 task.The plots show the number of netlists produced by each genetic operation over 30 runs, along with the corresponding average curve.This analysis indicates that all three operations are similarly effective, as elite circuits are equally likely to result from any of the three, which is a desired feature for a genetic algorithm.</p>
<p>B. Standard Cell Synthesis</p>
<p>We now present the results for synthesizing standard cells, including an inverter, a NAND2 gate, and a latch.</p>
<p>For benchmarking, we compare SpiceMixer with two reinforcement learning (RL) methods from [3] (RLOO and ES) and the Covariance Matrix Adaptation Evolution Strategy (CMA-ES) [4].</p>
<p>1) Inverter: We first evaluate the synthesis of an inverter, using the same setup as described in [3].When comparing the best-case result (ζ = 30) with GraCo RLOO, GraCo ES, and the random sampler from [3], SpiceMixer shows a clear advantage.It consistently finds valid solutions, a capability only matched by GraCo ES, while requiring approximately 25× fewer simulations than GraCo ES.</p>
<p>2) NAND2: Next, we evaluate the synthesis of a NAND2 gate, again using the same setup as in [3], i.e., now applying saturation only to the voltage levels and power consumption and not the timing, meaning the synthesizer is tasked with finding a correctly behaving circuit that achieves the fastest possible timings.Table I summarizes the results for SpiceMixer for different consistency checks.Out of 33 runs, 28 successfully synthesized a NAND2 gate meeting the required voltage levels and power constraints.This success rate is significantly higher than that of GraCo (for example, GraCo ES achieved only 2 successful runs out of 48).Moreover, the circuits found by SpiceMixer are, on average, over 200 ps faster than the fastest circuit identified by GraCo ES, underscoring its superiority. 4e also compare SpiceMixer with CMA-ES [4], a widely used evolution algorithm that iteratively updates a multivariate Gaussian distribution to balance exploration and exploitation of the search space.For CMA-ES, we assume fixed limits on the number of components and internal nets.Each component is represented by six parameters: four integers specifying the component type ("unused", "Skywater NMOS", "Skywater PMOS") and its drain, gate, and source net connections, and two floating-point values for the transistor's width and length. 5As with the GraCo methods, we enforce manufacturing constraints for CMA-ES, specifically: force bulk to supply/gnd and force supply/gnd not to gate.Table II shows the results.Interestingly, when the number of components and internal nets is restricted to the correct values, CMA-ES fails to synthesize a valid NAND2 gate.Relaxing these limits by a factor of two improves the outcomes, and in one out of five runs, CMA-ES successfully finds a correct circuit.Nevertheless, these results remain considerably worse than those achieved by SpiceMixer.</p>
<p>3) Latch: As a final example of a standard cell, we consider the design of a static latch. 6A static latch is a digital storage element that  maintains its state indefinitely as long as power is supplied, unlike a dynamic latch, which requires periodic refreshing to hold its state.</p>
<p>For the design space, we use two subcircuits: (a) an inverter sky130_fd_pr__inv_01v8 with one input and one output net, and (b) a tri-state inverter sky130_fd_pr__invck_01v8 with two input nets (data, clk) and one output net.We fix the transistor dimensions to w = 6 µm and l = 0.15 µm, so the synthesizer's task is solely to discover the correct wiring.Theoretically, one inverter can be used to generate the inverted clock, one tri-state inverter can serve as the input buffer, and a combination of one tri-state inverter and one regular inverter in a cross-coupled loop can provide storage.</p>
<p>To test the synthesis of a static latch, we used a testbench with a time step (tstep) of 1 ps and a total simulation time (tstop) of 16 ns, covering 16 different states, each lasting 1 ns.This setup may only detect dynamic latches, so after synthesis, we also ran a transient simulation over much longer timescales, using a tstep of 1 ns and a tstop of 1.6 ms.We used subrewards with saturation to ensure that correct voltage levels, timings, and power specifications were met.A reward value of 1 indicates that a valid latch circuit was successfully synthesized.</p>
<p>From the results in Table III, we can observe that SpiceMixer worked best and found twice a static latch cell in its four runs.We also could confirm this by inspecting the found netlists.In contrast, none of the three other methods (Random, GraCo RLOO, and GraCo ES) managed to synthesize a static latch.Interestingly, the random baseline outperformed both GraCo RLOO and GraCo ES, as the latter two collapsed too early into suboptimal solutions.</p>
<p>C. Analog Classifier for the Iris Dataset</p>
<p>Finally, we demonstrate that SpiceMixer can synthesize analog circuits for novel tasks.As an example, we design an analog classifier for the Iris dataset [38].The Iris dataset is a well-known multivariate dataset containing 150 samples from three Iris flower species: Iris setosa, Iris versicolor, and Iris virginica.Each sample has four numerical features -sepal length, sepal width, petal length, and petal width -and the dataset is commonly used for pattern recognition and classification tasks.We split the dataset into three parts: 90 samples for training, 30 for validation, and 30 for testing.</p>
<p>The task for SpiceMixer is to learn a circuit that takes as input four voltages representing the four features (normalized to [0 V, 1 V] using min-max normalization) and outputs three voltages representing the three classes, where the highest output voltage indicates the predicted class.In essence, the analog circuit should implement a discriminant function [39].To speed up computation, we use a transient simulation with a pulse representation for each sample.To avoid introducing temporal correlations during training, each dataset split is shuffled three times, and the shuffles are concatenated into one long pulse train.For example, the test split results in 3•30 samples after shuffling, as shown in Fig. 6.All reported numbers in this section are averaged over these three shuffles.The reward combines classification accuracy and a penalty for squared deviations between predicted probabilities computed using softmax and P = 1 for the target class, averaged over the training split.Fig. 7 shows the training curves for the three compared approaches (random, GraCo ES, and SpiceMixer).Each approach was run four times, and the bold curve shows the average.We observe that SpiceMixer consistently produces circuits with higher training rewards, which also translates into a higher training accuracy.</p>
<p>Next, we analyze two circuits synthesized by SpiceMixer: those with highest training and validation rewards.Both netlists, along with a schematic of the best-validation circuit, are provided in the Appendix in Figs. 9, 10 and 11.From the waveforms in Fig. 6, we observe that the circuit with highest training reward shows unstable waveforms with decaying or overshooting edges.While this yields the best training performance, it does not necessarily generalize well to new samples or shuffles.In contrast, the circuit with the highest validation reward produces more stable "digital-like" waveforms, which not only improves validation performance but also suggests that the simulation time per pulse could be significantly reduced.</p>
<p>Finally, we assess the accuracy of the two circuits on all three dataset splits under input perturbations, where the four input voltages V ∈ [0 V, 1 V] 4 are perturbed as V ← V + N (0, σ 2 noise I).This analysis is important because ensuring precise voltage levels is challenging in practice.Fig. 8 shows the results for both circuits, alongside logistic regression and a single hidden layer neural network for comparison.We observe that the synthesized circuits, even though they were not explicitly trained with input voltage noise, remain robust under perturbations.For example, with σnoise = 200 mV, test set accuracy remains around 70% compared to the original 89%.The degradation pattern closely matches what we observe for the logistic regression and neural network classifiers.</p>
<p>V. CONCLUSIONS AND OUTLOOK</p>
<p>In this work, we introduced SpiceMixer, a novel genetic algorithm framework for analog circuit synthesis that operates directly on normalized SPICE netlists.By applying netlist-level genetic operations, crossover, mutation, and pruning, our method effectively explores the design space and consistently outperforms prior approaches such as GraCo and CMA-ES in synthesizing standard cells and analog classifiers.</p>
<p>Looking ahead, we see several promising directions to further improve SpiceMixer.First, addressing the issue of netlist "bloating", where circuits accumulate redundant lines during synthesis.Often, these redundant lines serve to adjust sizing, e.g., parallel MOSFETs can effectively act as a single multi-fingered device.Therefore, tackling this issue could go beyond applying constraints on component counts or reward penalties, as explored in [31], and could include specialized pruning operations that merge redundant lines while adapting the effective sizing.Second, enhancing the genetic operations themselves by incorporating more sophisticated, domainaware crossover and mutation mechanisms could further improve both search efficiency and solution quality.Third, we aim to extend the framework's reach to tackle a broader range of analog ML circuits.Overall, SpiceMixer provides a scalable, automated path for analog design, and we believe these improvements will push its capabilities even further.</p>
<p>APPENDIX</p>
<p>The following algorithms provide further details about SpiceMixer.Alg. 1 illustrates the process of mixing two netlists for crossover.Algs. 2 and 3 describe the implementation of the pruning genetic operation.Lastly, Alg. 4 summarizes the overall workflow of SpiceMixer.</p>
<p>Furthermore, we give the netlists of the best synthesized circuits in terms of training as well as validation reward for the Iris task in Figs. 9 and Fig. 10.Additionally, Fig. 11 shows the schematic of the circuit with the best validation reward.</p>
<p>Algorithm 1: Merge two netlists by line mixing.Generate new netlist based on chosen strategy 13:</p>
<p>if elites and strategy == 'crossover' then # Select two parents using roulette-wheel sampling # (sampling with replacement, i.e., idx1 == idx2 possible)</p>
<p>Fig. 3 :
3
Fig. 3: Example of pruning using component mixing.NMOS X1 and PMOS X4 from the parent are pruned into a new NMOS, which, after netlist normalization, is inserted as new X5 in the offspring netlist.The resulting offspring achieves a higher reward.Net names follow a specific naming convention (input, output, internal, supply).</p>
<p>Fig. 4 :
4
Fig. 4: Number of simulations required to synthesize an inverter and a NAND2 gate for different elite sizes defined by η or ζ, respectively.The orange and green lines show median values for successful runs and for all runs (including failures) that continued up to the limit of 256 • 32 • 3 ≈ 25k simulations.The red numbers indicate the percentage of failed synthesis runs.</p>
<p>Fig. 5 :
5
Fig. 5: Number of circuits in the elite set (ζ = 30, NAND2 task) generated by specific genetic operations.</p>
<p>3
3</p>
<p>= 4 N 1 Ncomponents = 8 N
418
internal nets = 1 1.36 • 10 −1 1.26 • 10 −1 2.00 • 10 −1 1.33 • 10 −1 1.33•10 −internal nets = 2 2.21 • 10 −1 1.15 • 10 −3 2.71 • 10 −1 6.70 • 10 −2 7.44•10 −2</p>
<p>Fig. 6 :
6
Fig. 6: Input/output waveforms on the test split of the Iris dataset.</p>
<p>Fig. 7 :
7
Fig. 7: Training behavior for different methods on Iris dataset (results from four runs, with the average shown in bold).</p>
<p>Fig. 8 :
8
Fig. 8: Classification performance for additive Gaussian noise N (0, σ 2 noise ) applied to the input waveforms which are in [0, 1] V. Gray dashed line indicates the chance level.</p>
<p>Fig. 10 :
10
Fig. 10: Analog classifier circuit for Iris dataset found by SpiceMixer with best validation reward (train accuracy: 98.1%, validation accuracy: 96.7%, test accuracy: 88.9%).</p>
<p>Fig. 11 :
11
Fig. 11: Schematic of the analog classifier circuit for Iris dataset found by SpiceMixer with best validation reward.Interestingly, it only makes use of the features Sepal length and Petal width.</p>
<p>TABLE</p>
<p>TABLE II :
II
Synthesis of NAND2 gate with CMA-ES.Runs differ in their random seed.Only circuits with an optimality gap below 1/15 = 0.06 have the correct voltage output and do not exceed the maximum power constraints.We use the same highlighting scheme as in TableI.</p>
<p>Train reward: 0.7721, Validation reward: 0.6943, Test reward: 0.7221 Fig. 9: Analog classifier circuit for Iris dataset found by SpiceMixer with best training reward (train accuracy: 98.9%, validation accuracy: 83.3%, test accuracy: 88.9%).
X00net_input_2net_output_10sky130_fd_pr__nfet_01v8 w=60.30 l=3.820X10net_input_2net_output_20sky130_fd_pr__nfet_01v8 w=39.50 l=22.00X2net_internal_0net_input_0net_internal_1net_supply_0sky130_fd_pr__pfet_01v8 w=95.70 l=58.10X3net_internal_0net_input_2net_internal_20sky130_fd_pr__nfet_01v8 w=32.10 l=7.150X4net_internal_0net_input_3net_output_00sky130_fd_pr__nfet_01v8 w=32.70 l=7.150X5net_internal_0net_input_3net_output_10sky130_fd_pr__nfet_01v8 w=28.10 l=12.30X6net_internal_0net_input_3net_output_10sky130_fd_pr__nfet_01v8 w=60.50 l=7.290X7net_internal_2net_input_3net_output_00sky130_fd_pr__nfet_01v8 w=14.10 l=7.150X8net_internal_3net_input_2net_internal_3net_supply_0sky130_fd_pr__pfet_01v8 w=58.20 l=30.20X9net_output_0net_input_3net_output_2net_supply_0sky130_fd_pr__pfet_01v8 w=14.90 l=22.00X10net_output_1net_input_1net_output_20sky130_fd_pr__nfet_01v8 w=0.705 l=62.90X11net_output_1net_input_3net_output_20sky130_fd_pr__nfet_01v8 w=2.030 l=87.30X12net_output_2net_input_0net_supply_00sky130_fd_pr__nfet_01v8 l=60.60X13net_output_2net_input_3net_output_20sky130_fd_pr__nfet_01v8 w=26.40 l=24.50X140net_internal_4net_internal_20sky130_fd_pr__nfet_01v8 w=42.30 l=88.90X15net_internal_0net_internal_1net_supply_0net_supply_0sky130_fd_pr__pfet_01v8 w=3.620 l=0.229X16net_internal_2net_internal_3net_internal_3net_supply_0sky130_fd_pr__pfet_01v8 w=0.622 l=29.80X17net_internal_0net_internal_0net_output_10sky130_fd_pr__nfet_01v8 w=60.50 l=7.290X18net_internal_3net_internal_1net_output_2net_supply_0sky130_fd_pr__pfet_01v8 w=36.20 l=25.50X19net_output_0net_internal_0net_output_00sky130_fd_pr__nfet_01v8 w=48.20 l=49.60Train reward: 0.7683, Validation reward: 0.7683, Test reward: 0.7220X0net_internal_0net_input_0net_output_20sky130_fd_pr__nfet_01v8 w=0.540 l=26.40X1net_internal_0net_input_3net_output_10sky130_fd_pr__nfet_01v8 w=64.80 l=2.240X2net_internal_0net_input_3net_output_20sky130_fd_pr__nfet_01v8 w=0.540 l=98.90X3net_internal_1net_input_3net_output_20sky130_fd_pr__nfet_01v8 w=6.750 l=98.90X4net_internal_2net_input_3net_output_0net_supply_0sky130_fd_pr__pfet_01v8 w=50.60 l=10.10X5net_internal_3net_internal_1net_internal_40sky130_fd_pr__nfet_01v8 w=1.120 l=1.610X6net_internal_1net_internal_5net_output_00sky130_fd_pr__nfet_01v8 w=25.90 l=23.90X7net_internal_1net_internal_6net_output_2net_supply_0sky130_fd_pr__pfet_01v8 w=5.880 l=0.547X8net_internal_2net_internal_0net_output_0net_supply_0sky130_fd_pr__pfet_01v8 w=13.80 l=46.90X9net_internal_2net_internal_1net_output_114: net_supply_0 idx1, idx2 ← sky130_fd_pr__pfet_01v8 w=11.80 l=23.20roulette_wheel_selection(ranks, n samples=2)15:parent1, parent2 ← elites[idx1], elites[idx2]# Merge netlists16:offspring ← MixNetlists(parent1, parent2)17:if offspring then# convert netlist to graph18:graph ← netlist2data(offspring)19:else# randomly generate graph as offspring was empty20:graph ← SampleRandomGraph()21:else if elites and strategy == 'mutation' then# select first parent from elite netlists22:idx ←roulette_wheel_selection(ranks, n samples=1)23:parent1 ← elites[idx]# randomly generate second parent24:parent2 ← data2netlist(SampleRandomGraph())# Merge netlists25:offspring ← MixNetlists(parent1, parent2)26:else if not elites or strategy == 'pruning' then# select parent for pruning from elite netlists27:idx ←roulette_wheel_selection(ranks, n samples=1)# prune lines28:offspring ← LinePruning(elites[idx], force bulk)29:if offspring then# convert netlist to graph30:graph ← netlist2data(offspring)31:else# randomly generate graph as offspring was empty32:graph ← SampleRandomGraph()
33:return graph # return generated graph (as PyG data)</p>
<p>Sampling is performed with replacement, meaning the same netlist can be selected twice as a parent in a crossover operation.
For example, if we have already evaluated N = 1000 circuits, then an elite set size based on η = 0.01 would be N • η = 10 and would grow over time, whereas ζ keeps the elite set size fixed throughout synthesis.
As noted in Sec. III-C, we use a random sampler to initialize the genetic algorithm. Thus, while all circuits are initially generated by this method, they are quickly replaced in the elite set by circuits produced through one of the three genetic operations.
More specifically, the best circuit has timings of T rise = 9.45 ps, T fall = 10.35 ps, T r2f = 7.5 ps, and T f2r = 6.93 ps.
We use integer_variables for all discrete variables when setting up the optimization problem with pycma[37] to ensure their standard deviation does not collapse to an excessively small value.
A latch is level-sensitive and transparent when the clock is active, in contrast to a flip-flop, which is edge-triggered.</p>
<p>Design of analog CMOS integrated circuit. B Razavi, 2017McGraw Hill2nd ed</p>
<p>Systematic Design of Analog CMOS Circuits. P Jespers, B Murmann, 2017Cambridge University Press</p>
<p>GraCo -A graph composer for integrated circuits. S Uhlich, A Bonetti, A Venkitaraman, A Momeni, R Matsuo, C.-Y Hsieh, E Ohbuchi, L Servadei, arXiv:2411.138902024arXiv preprint</p>
<p>The CMA evolution strategy: A tutorial. N Hansen, arXiv:1604.007722016arXiv preprint</p>
<p>Generative ai for analog integrated circuit design: Methodologies and applications. D N Zadeh, M B Elamien, IEEE Access. 2025</p>
<p>Smart-MSP: A self-adaptive multiple starting point optimization approach for analog circuit synthesis. Y Yang, H Zhu, Z Bi, C Yan, D Zhou, Y Su, X Zeng, IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems. 3732017</p>
<p>AutoCkt: Deep reinforcement learning of analog circuit designs. K Settaluri, A Haj-Ali, Q Huang, K Hakhamaneshi, B Nikolic, 2020 Design, Automation &amp; Test in Europe Conference &amp; Exhibition (DATE). IEEE2020</p>
<p>DNN-Opt: An rl inspired optimization for analog circuit sizing using deep neural networks. A F Budak, P Bhansali, B Liu, N Sun, D Z Pan, C V Kashyap, 2021 58th ACM/IEEE Design Automation Conference (DAC). IEEE2021</p>
<p>APOSTLE: Asynchronously parallel optimization for sizing analog transistors using dnn learning. A F Budak, D Smart, B Swahn, D Z Pan, Proceedings of the 28th Asia and South Pacific Design Automation Conference. the 28th Asia and South Pacific Design Automation Conference2023</p>
<p>A study on exploring and exploiting the high-dimensional design space for analog circuit design automation. R Lyu, Y Meng, A Zhao, Z Bi, K Zhu, F Yang, C Yan, D Zhou, X Zeng, 2024 29th Asia and South Pacific Design Automation Conference (ASP-DAC). IEEE2024</p>
<p>Locality-aware surrogates for gradient-based black-box optimization. A Momeni, S Uhlich, A Venkitaraman, C.-Y Hsieh, A Bonetti, R Matsuo, E Ohbuchi, L Servadei, arXiv:2501.191612025arXiv preprint</p>
<p>AnalogCoder: Analog circuit design via training-free code generation. Y Lai, S Lee, G Chen, S Poddar, M Hu, D Z Pan, P Luo, Proceedings of the AAAI Conference on Artificial Intelligence. the AAAI Conference on Artificial Intelligence202539</p>
<p>Analogxpert: Automating analog topology synthesis by incorporating circuit design expertise into large language models. H Zhang, S Sun, Y Lin, R Wang, J Bian, arXiv:2412.198242024arXiv preprint</p>
<p>AnalogGenie: A generative engine for automatic discovery of analog circuit topologies. J Gao, W Cao, J Yang, X Zhang, arXiv:2503.002052025arXiv preprint</p>
<p>Deep reinforcement learning for analog circuit structure synthesis. Z Zhao, L Zhang, 2022 Design, Automation &amp; Test in Europe Conference &amp; Exhibition (DATE). IEEE2022</p>
<p>CktGNN: Circuit graph neural network for electronic design automation. Z Dong, W Cao, M Zhang, D Tao, Y Chen, X Zhang, arXiv:2308.164062023arXiv preprint</p>
<p>FEATS: Framework for explorative analog topology synthesis. M Meissner, L Hedrich, IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems. 3422014</p>
<p>An automated topology synthesis framework for analog integrated circuits. Z Zhao, L Zhang, IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems. 39122020</p>
<p>Analog circuit design using genetic algorithms. K V Noren, J E Ross, Second Online Symposium for Electronics Engineers. 2001</p>
<p>A hybrid ga-sqp algorithm for analog circuits sizing. F Yengui, L Labrak, F Frantz, R Daviot, N Abouchi, I O'connor, Circuits and Systems. 322012</p>
<p>Analog circuit design optimization based on evolutionary algorithms. M Barari, H R Karimi, F Razaghian, Mathematical Problems in Engineering. 201415936842014</p>
<p>Circuit-centric genetic algorithm (cga) for analog and radio-frequency circuit optimization. M Kwon, Y Lee, I Song, arXiv:2403.179382023arXiv preprint</p>
<p>Machine learning driven global optimisation framework for analog circuit design. R Rashid, K Krishna, C P George, N Nambath, Microelectronics Journal. 1511063622024</p>
<p>Seas: A simulated evolution approach for analog circuit synthesis. Z.-Q Ning, A Mouthaan, H Wallinga, Proceedings IEEE Custom Integrated Circuits Conference (CICC'91). IEEE Custom Integrated Circuits Conference (CICC'91)San Diego, USAIEEE12-15 May, 1991. 1991IEEE Custom Integrated Circuits Conference, CICC'91</p>
<p>Darwin: Cmos opamp synthesis by means of a genetic algorithm. W Kruiskamp, D Leenaerts, Proceedings of the 32nd annual ACM/IEEE design automation conference. the 32nd annual ACM/IEEE design automation conference1995</p>
<p>Buy 4 reinforce samples, get a baseline for free. W Kool, H Van Hoof, M Welling, Proceedings of the ICLR 2019 Workshop: Deep RL Meets Structured Prediction. the ICLR 2019 Workshop: Deep RL Meets Structured Prediction2019</p>
<p>Evolution of transistor circuits. M A Trefzer, 2006Ph.D. dissertation</p>
<p>Gapsys: A ga-based tool for automated passive analog circuit synthesis. A Das, R Vemuri, 2007 IEEE International Symposium on Circuits and Systems (ISCAS). IEEE2007</p>
<p>A robust evolvable system for the synthesis of analog circuits. A Torres Soto, E E Ponce De León Sentí, A Hernández Aguirre, M D Torres, E Díaz Soto, Díaz, Computación y Sistemas. 1342010</p>
<p>Challenging the evolutionary strategy for synthesis of analogue computational circuits. Y A Sapargaliyev, T G Kalganova, 2010</p>
<p>Analog flat-level circuit synthesis with genetic algorithms. M Campilho-Gomes, R Tavares, J Goes, IEEE Access. 2024</p>
<p>Automated design of both the topology and sizing of analog electrical circuits using genetic programming. J R Koza, F H Bennett, Iii , D Andre, M A Keane, Artificial intelligence in design'96. Springer1996</p>
<p>Simple statistical gradient-following algorithms for connectionist reinforcement learning. R J Williams, Machine learning. 81992</p>
<p>Evolution strategies as a scalable alternative to reinforcement learning. T Salimans, J Ho, X Chen, S Sidor, I Sutskever, arXiv:1703.038642017arXiv preprint</p>
<p>Schemato -An llm for netlist-to-schematic conversion. R Matsuo, S Uhlich, A Venkitaraman, A Bonetti, C.-Y Hsieh, A Momeni, L Mauch, A Capone, E Ohbuchi, L Servadei, arXiv:2411.138992024arXiv preprint</p>
<p>Skywater 130nm PDK. Skywater Google, Foundry Technology, 2020</p>
<p>CMA-ES/pycma on Github. N Hansen, Y Akimoto, P Baudis, 10.5281/zenodo.2559634Zenodo. Feb. 2019</p>
<p>The use of multiple measurements in taxonomic problems. R A Fisher, Annals of eugenics. 721936</p>
<p>Pattern classification. R O Duda, P E Hart, 2000John Wiley &amp; Sons</p>            </div>
        </div>

    </div>
</body>
</html>