<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-600 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-600</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-600</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-17.html">extraction-schema-17</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of hybrid reasoning systems that combine declarative (symbolic, logic-based, rule-based) and imperative (procedural, neural, step-by-step) approaches, including their architectures, integration methods, emergent properties, and performance characteristics.</div>
                <p><strong>Paper ID:</strong> paper-5728919676a85553b3c3063626c220fe7a5634e4</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/5728919676a85553b3c3063626c220fe7a5634e4" target="_blank">Cognitive Graph for Multi-Hop Reading Comprehension at Scale</a></p>
                <p><strong>Paper Venue:</strong> Annual Meeting of the Association for Computational Linguistics</p>
                <p><strong>Paper TL;DR:</strong> The implementation based on BERT and graph neural network efficiently handles millions of documents for multi-hop reasoning questions in the HotpotQA fullwiki dataset, achieving a winning joint F_1 score of 34.9 on the leaderboard.</p>
                <p><strong>Paper Abstract:</strong> We propose a new CogQA framework for multi-hop reading comprehension question answering in web-scale documents. Founded on the dual process theory in cognitive science, the framework gradually builds a cognitive graph in an iterative process by coordinating an implicit extraction module (System 1) and an explicit reasoning module (System 2). While giving accurate answers, our framework further provides explainable reasoning paths. Specifically, our implementation based on BERT and graph neural network efficiently handles millions of documents for multi-hop reasoning questions in the HotpotQA fullwiki dataset, achieving a winning joint F_1 score of 34.9 on the leaderboard, compared to 23.1 of the best competitor.</p>
                <p><strong>Cost:</strong> 0.01</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e600.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e600.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of hybrid reasoning systems that combine declarative (symbolic, logic-based, rule-based) and imperative (procedural, neural, step-by-step) approaches, including their architectures, integration methods, emergent properties, and performance characteristics.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>CogQA</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Cognitive Graph QA (CogQA)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A hybrid, dual-process framework for web-scale multi-hop question answering that combines an explicit, symbolic cognitive graph (entity-level declarative structure) with neural extraction and reasoning modules (BERT and a GNN). It iteratively expands an entity graph via a fast extraction module and performs explicit relational reasoning over that graph with a neural module.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>CogQA (Cognitive Graph QA)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>CogQA is a modular hybrid reasoning system inspired by dual-process cognitive theory. It maintains an explicit directed cognitive graph whose nodes are entities or candidate answers (declarative, symbolic representation). System 1 (fast, implicit) is implemented with BERT and reads an entity's paragraph + predecessor 'clues' to extract next-hop entities and answer spans and to produce a semantic vector for the node. System 2 (slow, explicit) is implemented with a graph neural network (GNN) that updates node hidden representations via graph propagation and produces clues (raw predecessor sentences) to guide further extraction. The system iteratively alternates extraction (System 1) and graph-based reasoning (System 2) to expand the graph until stopping criteria are met, then predicts the final answer from node representations.</td>
                        </tr>
                        <tr>
                            <td><strong>declarative_component</strong></td>
                            <td>An explicit directed cognitive graph (nodes = entities/answer candidates, edges = discovered relations or extraction links). The graph is an explicit symbolic data structure representing entities and reasoning paths (entity-level, ordered explainability). The paper uses raw sentences from predecessor nodes as 'clues' (symbolic/plain-text provenance) rather than learned symbolic formulas or logic-program rules.</td>
                        </tr>
                        <tr>
                            <td><strong>imperative_component</strong></td>
                            <td>Neural modules: (1) System 1 — BERT (Transformer-based pre-trained language model) used for span extraction, next-hop detection, and producing per-node semantic vectors; (2) System 2 — a Graph Neural Network (GNN) variant that propagates and updates node hidden states via matrix operations (localized spectral filtering style propagation with learnable weight matrices W1, W2 and nonlinearities). Training uses gradient-based (Adam) optimization; predictors are small fully-connected networks.</td>
                        </tr>
                        <tr>
                            <td><strong>integration_method</strong></td>
                            <td>Modular, iterative integration: System 1 produces symbolic graph updates (new nodes/edges) plus sem[x,Q,clues] vectors which initialize node hidden states; System 2 performs neural propagation over that explicit graph to update hidden states and selects/collects predecessor raw sentences as 'clues' to feed back into System 1. Integration is trained end-to-end in parts: System 1 (BERT) and System 2 (GNN) are optimized jointly for the downstream answer prediction (System 2 gradients fine-tune System 1 via semantic vectors), but clues are passed as raw text (not as differentiable hidden-state messages) to decouple iterative steps during training for efficiency. The graph structure itself is an explicit (non-differentiable) symbolic artifact manipulated by System 1 outputs.</td>
                        </tr>
                        <tr>
                            <td><strong>emergent_properties</strong></td>
                            <td>1) Ordered, entity-level explainability: explicit reasoning paths (graph walks) can be inspected and backtracked, enabling step-by-step explanations. 2) Improved multi-hop robustness: iterative graph expansion discovers paragraphs that are multi-hop away and share little surface vocabulary with the question (better recovery of distant evidence). 3) Increased logical rigor: higher proportion of answers supported by all necessary supporting facts (JointEM/AnsEM proportion reported much higher than baselines). 4) Scalability: only documents corresponding to visited graph node titles are fetched, limiting workspace dependence on corpus size. These behaviors arise from combining an explicit symbolic memory/structure with neural extraction and neural relational propagation; they are not exhibited by the extraction module alone (System 1) or by naive retrieval–extraction baselines.</td>
                        </tr>
                        <tr>
                            <td><strong>task_or_benchmark</strong></td>
                            <td>Multi-hop reading comprehension / Open-domain QA at scale — evaluated on HotpotQA full-wiki setting (multi-hop question answering with supporting facts required).</td>
                        </tr>
                        <tr>
                            <td><strong>hybrid_performance</strong></td>
                            <td>Test set (HotpotQA fullwiki submission reported by paper): Answer EM 37.1, Answer F1 48.9; Supporting facts EM 22.8, Supporting facts F1 57.7; Joint EM 12.4, Joint F1 34.9.</td>
                        </tr>
                        <tr>
                            <td><strong>declarative_only_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>imperative_only_performance</strong></td>
                            <td>Ablation (System 1 only, named CogQA-sys1): Answer EM 33.6, Answer F1 45.0; Supporting facts EM 23.7, Supporting facts F1 58.3; Joint EM 12.3, Joint F1 32.5. (This ablation retains iterative extraction but lacks the GNN-based System 2 reasoning.)</td>
                        </tr>
                        <tr>
                            <td><strong>has_comparative_results</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>generalization_properties</strong></td>
                            <td>CogQA demonstrates greater robustness as hop count increases: performance degrades far less than retrieval–extraction baselines as required reasoning hops grow, indicating better generalization for multi-hop composition (empirically on HotpotQA dev/test). The paper shows that starting with only entities in the question (CogQA-onlyQ) still outperforms traditional retrieval–extraction baselines, suggesting improved compositional discovery of distant evidence. No formal OOD or theoretical generalization bounds are provided.</td>
                        </tr>
                        <tr>
                            <td><strong>interpretability_properties</strong></td>
                            <td>High interpretability: the explicit cognitive graph records ordered entity-level reasoning paths and the predecessor sentences ('clues') used to expand nodes; these enable inspection, verification of logical steps, and backtracking to see how an answer was derived. The paper quantifies 'logical rigor' by JointEM/AnsEM proportion and presents case studies showing explainable paths (trees, DAGs, cycles).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failures</strong></td>
                            <td>1) The system struggles on alternative/general questions that require judgments not inferable from supporting facts—lack of supervision for such reasoning limits gains. 2) Semantic-retrieval queries lacking explicit entity mentions remain hard (though combining with retrieval can help). 3) The declarative graph is a text-based symbolic structure rather than a formal logic program, so formal symbolic inference/rule-based guarantees are absent. 4) The current System 2 is neural (GNN) rather than rule-based symbolic reasoning; paper notes potential to integrate neural logic techniques for improved reliability. 5) There is an implicit stopping/size cap on graph expansion for efficiency, which can miss distant evidence if not expanded sufficiently.</td>
                        </tr>
                        <tr>
                            <td><strong>theoretical_framework</strong></td>
                            <td>Grounded in Dual Process Theory from cognitive science (System 1: fast, implicit retrieval; System 2: slow, explicit reasoning). The paper proposes a division-of-labor principle: System 1 provides fast retrieval and candidate generation into an explicit declarative workspace (cognitive graph), while System 2 performs controlled relational reasoning over that workspace (neural GNN). This complementary strengths framing is the paper's conceptual theoretical basis; no formal mathematical proof is provided.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Cognitive Graph for Multi-Hop Reading Comprehension at Scale', 'publication_date_yy_mm': '2019-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Relational inductive biases, deep learning, and graph networks <em>(Rating: 2)</em></li>
                <li>HotpotQA: A dataset for diverse, explainable multi-hop question answering <em>(Rating: 2)</em></li>
                <li>BERT: Pre-training of deep bidirectional transformers for language understanding <em>(Rating: 1)</em></li>
                <li>Reading wikipedia to answer open-domain questions <em>(Rating: 1)</em></li>
                <li>Heuristic and analytic processes in reasoning <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-600",
    "paper_id": "paper-5728919676a85553b3c3063626c220fe7a5634e4",
    "extraction_schema_id": "extraction-schema-17",
    "extracted_data": [
        {
            "name_short": "CogQA",
            "name_full": "Cognitive Graph QA (CogQA)",
            "brief_description": "A hybrid, dual-process framework for web-scale multi-hop question answering that combines an explicit, symbolic cognitive graph (entity-level declarative structure) with neural extraction and reasoning modules (BERT and a GNN). It iteratively expands an entity graph via a fast extraction module and performs explicit relational reasoning over that graph with a neural module.",
            "citation_title": "here",
            "mention_or_use": "use",
            "system_name": "CogQA (Cognitive Graph QA)",
            "system_description": "CogQA is a modular hybrid reasoning system inspired by dual-process cognitive theory. It maintains an explicit directed cognitive graph whose nodes are entities or candidate answers (declarative, symbolic representation). System 1 (fast, implicit) is implemented with BERT and reads an entity's paragraph + predecessor 'clues' to extract next-hop entities and answer spans and to produce a semantic vector for the node. System 2 (slow, explicit) is implemented with a graph neural network (GNN) that updates node hidden representations via graph propagation and produces clues (raw predecessor sentences) to guide further extraction. The system iteratively alternates extraction (System 1) and graph-based reasoning (System 2) to expand the graph until stopping criteria are met, then predicts the final answer from node representations.",
            "declarative_component": "An explicit directed cognitive graph (nodes = entities/answer candidates, edges = discovered relations or extraction links). The graph is an explicit symbolic data structure representing entities and reasoning paths (entity-level, ordered explainability). The paper uses raw sentences from predecessor nodes as 'clues' (symbolic/plain-text provenance) rather than learned symbolic formulas or logic-program rules.",
            "imperative_component": "Neural modules: (1) System 1 — BERT (Transformer-based pre-trained language model) used for span extraction, next-hop detection, and producing per-node semantic vectors; (2) System 2 — a Graph Neural Network (GNN) variant that propagates and updates node hidden states via matrix operations (localized spectral filtering style propagation with learnable weight matrices W1, W2 and nonlinearities). Training uses gradient-based (Adam) optimization; predictors are small fully-connected networks.",
            "integration_method": "Modular, iterative integration: System 1 produces symbolic graph updates (new nodes/edges) plus sem[x,Q,clues] vectors which initialize node hidden states; System 2 performs neural propagation over that explicit graph to update hidden states and selects/collects predecessor raw sentences as 'clues' to feed back into System 1. Integration is trained end-to-end in parts: System 1 (BERT) and System 2 (GNN) are optimized jointly for the downstream answer prediction (System 2 gradients fine-tune System 1 via semantic vectors), but clues are passed as raw text (not as differentiable hidden-state messages) to decouple iterative steps during training for efficiency. The graph structure itself is an explicit (non-differentiable) symbolic artifact manipulated by System 1 outputs.",
            "emergent_properties": "1) Ordered, entity-level explainability: explicit reasoning paths (graph walks) can be inspected and backtracked, enabling step-by-step explanations. 2) Improved multi-hop robustness: iterative graph expansion discovers paragraphs that are multi-hop away and share little surface vocabulary with the question (better recovery of distant evidence). 3) Increased logical rigor: higher proportion of answers supported by all necessary supporting facts (JointEM/AnsEM proportion reported much higher than baselines). 4) Scalability: only documents corresponding to visited graph node titles are fetched, limiting workspace dependence on corpus size. These behaviors arise from combining an explicit symbolic memory/structure with neural extraction and neural relational propagation; they are not exhibited by the extraction module alone (System 1) or by naive retrieval–extraction baselines.",
            "task_or_benchmark": "Multi-hop reading comprehension / Open-domain QA at scale — evaluated on HotpotQA full-wiki setting (multi-hop question answering with supporting facts required).",
            "hybrid_performance": "Test set (HotpotQA fullwiki submission reported by paper): Answer EM 37.1, Answer F1 48.9; Supporting facts EM 22.8, Supporting facts F1 57.7; Joint EM 12.4, Joint F1 34.9.",
            "declarative_only_performance": null,
            "imperative_only_performance": "Ablation (System 1 only, named CogQA-sys1): Answer EM 33.6, Answer F1 45.0; Supporting facts EM 23.7, Supporting facts F1 58.3; Joint EM 12.3, Joint F1 32.5. (This ablation retains iterative extraction but lacks the GNN-based System 2 reasoning.)",
            "has_comparative_results": true,
            "generalization_properties": "CogQA demonstrates greater robustness as hop count increases: performance degrades far less than retrieval–extraction baselines as required reasoning hops grow, indicating better generalization for multi-hop composition (empirically on HotpotQA dev/test). The paper shows that starting with only entities in the question (CogQA-onlyQ) still outperforms traditional retrieval–extraction baselines, suggesting improved compositional discovery of distant evidence. No formal OOD or theoretical generalization bounds are provided.",
            "interpretability_properties": "High interpretability: the explicit cognitive graph records ordered entity-level reasoning paths and the predecessor sentences ('clues') used to expand nodes; these enable inspection, verification of logical steps, and backtracking to see how an answer was derived. The paper quantifies 'logical rigor' by JointEM/AnsEM proportion and presents case studies showing explainable paths (trees, DAGs, cycles).",
            "limitations_or_failures": "1) The system struggles on alternative/general questions that require judgments not inferable from supporting facts—lack of supervision for such reasoning limits gains. 2) Semantic-retrieval queries lacking explicit entity mentions remain hard (though combining with retrieval can help). 3) The declarative graph is a text-based symbolic structure rather than a formal logic program, so formal symbolic inference/rule-based guarantees are absent. 4) The current System 2 is neural (GNN) rather than rule-based symbolic reasoning; paper notes potential to integrate neural logic techniques for improved reliability. 5) There is an implicit stopping/size cap on graph expansion for efficiency, which can miss distant evidence if not expanded sufficiently.",
            "theoretical_framework": "Grounded in Dual Process Theory from cognitive science (System 1: fast, implicit retrieval; System 2: slow, explicit reasoning). The paper proposes a division-of-labor principle: System 1 provides fast retrieval and candidate generation into an explicit declarative workspace (cognitive graph), while System 2 performs controlled relational reasoning over that workspace (neural GNN). This complementary strengths framing is the paper's conceptual theoretical basis; no formal mathematical proof is provided.",
            "uuid": "e600.0",
            "source_info": {
                "paper_title": "Cognitive Graph for Multi-Hop Reading Comprehension at Scale",
                "publication_date_yy_mm": "2019-05"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Relational inductive biases, deep learning, and graph networks",
            "rating": 2
        },
        {
            "paper_title": "HotpotQA: A dataset for diverse, explainable multi-hop question answering",
            "rating": 2
        },
        {
            "paper_title": "BERT: Pre-training of deep bidirectional transformers for language understanding",
            "rating": 1
        },
        {
            "paper_title": "Reading wikipedia to answer open-domain questions",
            "rating": 1
        },
        {
            "paper_title": "Heuristic and analytic processes in reasoning",
            "rating": 1
        }
    ],
    "cost": 0.009821749999999999,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Cognitive Graph for Multi-Hop Reading Comprehension at Scale</h1>
<p>Ming Ding ${ }^{\dagger}$, Chang Zhou ${ }^{\ddagger}$, Qibin Chen ${ }^{\dagger}$, Hongxia Yang ${ }^{\ddagger}$, Jie Tang ${ }^{\dagger}$<br>${ }^{\dagger}$ Department of Computer Science and Technology, Tsinghua University<br>${ }^{\ddagger}$ DAMO Academy, Alibaba Group<br>{dm18,chen-qb15}@mails.tsinghua.edu.cn<br>{ericzhou.zc,yang.yhx}@alibaba-inc.com<br>jietang@tsinghua.edu.cn</p>
<h4>Abstract</h4>
<p>We propose a new CogQA framework for multi-hop question answering in web-scale documents. Founded on the dual process theory in cognitive science, the framework gradually builds a cognitive graph in an iterative process by coordinating an implicit extraction module (System 1) and an explicit reasoning module (System 2). While giving accurate answers, our framework further provides explainable reasoning paths. Specifically, our implementation ${ }^{\dagger}$ based on BERT and graph neural network (GNN) efficiently handles millions of documents for multi-hop reasoning questions in the HotpotQA fullwiki dataset, achieving a winning joint $F_{1}$ score of 34.9 on the leaderboard, compared to 23.6 of the best competitor. ${ }^{2}$</p>
<h2>1 Introduction</h2>
<p>Deep learning models have made significant strides in machine reading comprehension and even outperformed human on single paragraph question answering (QA) benchmarks including SQuAD (Wang et al., 2018b; Devlin et al., 2018; Rajpurkar et al., 2016). However, to cross the chasm of reading comprehension ability between machine and human, three main challenges lie ahead: 1) Reasoning ability. As revealed by adversarial tests (Jia and Liang, 2017), models for single paragraph QA tend to seek answers in sentences matched by the question, which does not involve complex reasoning. Therefore, multi-hop QA becomes the next frontier to conquer (Yang et al., 2018). 2) Explainability. Explicit reasoning paths, which enable verification of logical rigor, are vital for the reliability of QA systems. HotpotQA (Yang et al., 2018) requires models to provide supporting sentences, which</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: An example of cognitive graph for multi-hop QA. Each hop node corresponds to an entity (e.g., "Los Angeles") followed by its introductory paragraph. The circles mean ans nodes, answer candidates to the question. Cognitive graph mimics human reasoning process. Edges are built when calling an entity to "mind". The solid black edges are the correct reasoning path.
means unordered and sentence-level explainability, yet humans can interpret answers with step by step solutions, indicating an ordered and entitylevel explainability. 3) Scalability. For any practically useful QA system, scalability is indispensable. Existing QA systems based on machine comprehension generally follow retrievalextraction framework in DrQA (Chen et al., 2017), reducing the scope of sources to a few paragraphs by pre-retrieval. This framework is a simple compromise between single paragraph QA and scalable information retrieval, compared to human's ability to breeze through reasoning with knowledge in massive-capacity memory (Wang et al., 2003).</p>
<p>Therefore, insights on the solutions to these challenges can be drawn from the cognitive process of humans. Dual process theory (Evans, 1984, 2003, 2008; Sloman, 1996) suggests that our brains first retrieve relevant information following attention via an implicit, unconscious and intu-</p>
<p>itive process called System 1, based on which another explicit, conscious and controllable reasoning process, System 2, is then conducted. System 1 could provide resources according to requests, while System 2 enables diving deeper into relational information by performing sequential thinking in the working memory, which is slower but with human-unique rationality (Baddeley, 1992). For complex reasoning, the two systems are coordinated to perform fast and slow thinking (Kahneman and Egan, 2011) iteratively.</p>
<p>In this paper, we propose a framework, namely Cognitive Graph QA (CogQA), contributing to tackling all challenges above. Inspired by the dual process theory, the framework comprises functionally different System 1 and 2 modules. System 1 extracts question-relevant entities and answer candidates from paragraphs and encodes their semantic information. Extracted entities are organized as a cognitive graph (Figure 1), which resembles the working memory. System 2 then conducts the reasoning procedure over the graph, and collects clues to guide System 1 to better extract next-hop entities. The above process is iterated until all possible answers are found, and then the final answer is chosen based on reasoning results from System 2. An efficient implementation based on BERT (Devlin et al., 2018) and graph neural network (GNN) (Battaglia et al., 2018) is introduced.</p>
<p>Our contributions are as follows:</p>
<ul>
<li>We propose the novel CogQA framework for multi-hop reading comprehension QA at scale according to human cognition.</li>
<li>We show that the cognitive graph structure in our framework offers ordered and entitylevel explainability and suits for relational reasoning.</li>
<li>Our implementation based on BERT and GNN surpasses previous works and other competitors substantially on all the metrics.</li>
</ul>
<h2>2 Cognitive Graph QA Framework</h2>
<p>Reasoning ability of humankind depends critically on relational structures of information. Intuitively, we adopt a directed graph structure for step-bystep deduction and exploration in cognitive process of multi-hop QA. In our reading comprehension setting, each node in this cognitive graph $\mathcal{G}$ corresponds with an entity or possible answer $x$, also interchangeably denoted as node $x$. The extraction module System 1, reads the introductory</p>
<div class="codehilite"><pre><span></span><code><span class="n">Algorithm</span><span class="w"> </span><span class="mi">1</span><span class="err">:</span><span class="w"> </span><span class="n">Cognitive</span><span class="w"> </span><span class="n">Graph</span><span class="w"> </span><span class="n">QA</span>
<span class="w">    </span><span class="k">Input</span><span class="err">:</span>
<span class="w">    </span><span class="k">System</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">S</span><span class="err">}</span><span class="n">_</span><span class="err">{</span><span class="mi">1</span><span class="err">}\</span><span class="p">),</span><span class="w"> </span><span class="k">System</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">S</span><span class="err">}</span><span class="n">_</span><span class="err">{</span><span class="mi">2</span><span class="err">}\</span><span class="p">).</span>
<span class="w">    </span><span class="n">Question</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">Q</span><span class="err">\</span><span class="p">),</span><span class="w"> </span><span class="n">Predictor</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">F</span><span class="err">}\</span><span class="p">),</span><span class="w"> </span><span class="n">Wiki</span><span class="w"> </span><span class="k">Database</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">W</span><span class="err">}\</span><span class="p">)</span>
<span class="w">    </span><span class="k">Initialize</span><span class="w"> </span><span class="n">cognitive</span><span class="w"> </span><span class="n">graph</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">G</span><span class="err">}\</span><span class="p">)</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">entities</span><span class="w"> </span><span class="n">mentioned</span><span class="w"> </span><span class="ow">in</span>
<span class="w">    </span><span class="n">Q</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">mark</span><span class="w"> </span><span class="n">them</span><span class="w"> </span><span class="n">frontier</span><span class="w"> </span><span class="n">nodes</span>
<span class="w">    </span><span class="n">repeat</span>
<span class="w">        </span><span class="n">pop</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">x</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">frontier</span><span class="w"> </span><span class="n">nodes</span>
<span class="w">        </span><span class="k">collect</span><span class="w"> </span><span class="n">clues</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="o">[</span><span class="n">x, \mathcal{G}</span><span class="o">]</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">predecessor</span><span class="w"> </span><span class="n">nodes</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">x</span><span class="err">\</span><span class="p">)</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">eg</span><span class="p">.</span><span class="w"> </span><span class="n">clues</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">sentences</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">x</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">mentioned</span>
<span class="w">        </span><span class="k">fetch</span><span class="w"> </span><span class="n">para</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="o">[</span><span class="n">x</span><span class="o">]</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">W</span><span class="err">}\</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="ow">any</span>
<span class="w">        </span><span class="n">generate</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="n">sem</span><span class="err">}</span><span class="o">[</span><span class="n">x, Q\), clues \(</span><span class="o">]</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">S</span><span class="err">}</span><span class="n">_</span><span class="err">{</span><span class="mi">1</span><span class="err">}</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="o">/</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="n">initial</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">mathrm</span><span class="err">{</span><span class="n">X</span><span class="err">}</span><span class="o">[</span><span class="n">x</span><span class="o">]</span><span class="err">\</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">x</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">hop</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="k">then</span>
<span class="w">            </span><span class="n">find</span><span class="w"> </span><span class="n">hop</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">answer</span><span class="w"> </span><span class="n">spans</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">para</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="o">[</span><span class="n">x</span><span class="o">]</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">S</span><span class="err">}</span><span class="n">_</span><span class="err">{</span><span class="mi">1</span><span class="err">}\</span><span class="p">)</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">y</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">hop</span><span class="w"> </span><span class="n">spans</span><span class="w"> </span><span class="n">do</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="err">\</span><span class="n">notin</span><span class="w"> </span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">G</span><span class="err">}\</span><span class="p">)</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="err">\</span><span class="ow">in</span><span class="w"> </span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">W</span><span class="err">}\</span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="w">                </span><span class="k">create</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">hop</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">y</span><span class="err">\</span><span class="p">)</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="err">\</span><span class="ow">in</span><span class="w"> </span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">G</span><span class="err">}\</span><span class="p">)</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="err">\</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="err">\</span><span class="n">notin</span><span class="w"> </span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">G</span><span class="err">}\</span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="w">                </span><span class="k">add</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="err">\</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">G</span><span class="err">}\</span><span class="p">)</span>
<span class="w">                </span><span class="n">mark</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">y</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">frontier</span><span class="w"> </span><span class="n">node</span>
<span class="w">            </span><span class="k">end</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">y</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">answer</span><span class="w"> </span><span class="n">spans</span><span class="w"> </span><span class="n">do</span>
<span class="w">                </span><span class="k">add</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">answer</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">y</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="err">\</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">G</span><span class="err">}\</span><span class="p">)</span>
<span class="w">            </span><span class="k">end</span>
<span class="w">        </span><span class="k">end</span>
<span class="w">        </span><span class="k">update</span><span class="w"> </span><span class="n">hidden</span><span class="w"> </span><span class="n">representation</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">mathbf</span><span class="err">{</span><span class="n">X</span><span class="err">}\</span><span class="p">)</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">S</span><span class="err">}</span><span class="n">_</span><span class="err">{</span><span class="mi">2</span><span class="err">}\</span><span class="p">)</span>
<span class="w">        </span><span class="n">until</span><span class="w"> </span><span class="n">there</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">no</span><span class="w"> </span><span class="n">frontier</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">G</span><span class="err">}\</span><span class="p">)</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">G</span><span class="err">}\</span><span class="p">)</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">large</span><span class="w"> </span><span class="n">enough</span><span class="p">;</span>
<span class="w">        </span><span class="k">Return</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">arg</span><span class="w"> </span><span class="err">\</span><span class="nf">max</span><span class="w"> </span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">F</span><span class="err">}</span><span class="p">(</span><span class="err">\</span><span class="n">mathbf</span><span class="err">{</span><span class="n">X</span><span class="err">}</span><span class="o">[</span><span class="n">x</span><span class="o">]</span><span class="p">)</span><span class="err">\</span><span class="p">)</span>
<span class="w">            </span><span class="n">answer</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">x</span><span class="err">\</span><span class="p">)</span>
</code></pre></div>

<p>paragraph para $[x]$ of entity $x$ and extracts answer candidates and useful next-hop entities from the paragraph. $\mathcal{G}$ is then expanded with these new nodes, providing explicit structure for the reasoning module, System 2. In this paper, we assume that System 2 conducts deep learning based instead of rule-based reasoning by computing hidden representations $\mathbf{X}$ of nodes. Thus System 1 is also required to summarize para $[x]$ into a semantic vector as initial hidden representation when extracting spans. Then System 2 updates $\mathbf{X}$ based on graph structure as reasoning results for downstream prediction.</p>
<p>Explainability is enjoyed owing to explicit reasoning paths in the cognitive graph. Besides simple paths, the cognitive graph can also clearly display joint or loopy reasoning processes, where new predecessors might bring new clues about the answer. Clues in our framework is a form-flexible concept, referring to information from predecessors for guiding System 1 to better extract spans. Apart from newly added nodes, those nodes with new incoming edges also need revisits due to new clues. We refer to both of them as frontier nodes.</p>
<p>Scalability means that the time consumption of QA will not grow significantly along with the number of paragraphs. Our framework can scale in nature since the only operation referred to all</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: Overview of CogQA implementation. When visiting the node <em>x</em>, System 1 generates new hop and answer nodes based on the <em>clues</em>[<em>x</em>, <strong>G</strong>] discovered by System 2. It also creates the initial representation <em>sem</em>[<em>x</em>, <em>Q</em>, <em>clues</em>], based on which the GNN in System 2 updates the hidden representations <strong>X</strong>[<em>x</em>].</p>
<p>paragraphs is to access some specific paragraphs by their title indexes. For multi-hop questions, traditional retrieval-extraction frameworks might sacrifice the potential of follow-up models, because paragraphs multiple hops away from the question could share few common words and little semantic relation with the question, leading to a failed retrieval. However, these paragraphs can be discovered by iteratively expanding with <em>clues</em> in our framework.</p>
<p>Algorithm 1 describes the procedure of our framework CogQA. After initialization, an iterative process for graph expansion and reasoning begins. In each step we visit a frontier node <em>x</em>, and System 1 reads <em>para</em>[<em>x</em>] under the guidance of <em>clues</em> and the question <em>Q</em>, extracts spans and generates semantic vector <em>sem</em>[<em>x</em>, <em>Q</em>, <em>clues</em>]. Meanwhile, System 2 updates hidden representation <strong>X</strong> and prepares <em>clues</em>[<em>y</em>, <strong>G</strong>] for any successor node <em>y</em>. The final prediction is made based on <strong>X</strong>.</p>
<h1>3 Implementation</h1>
<p>The main part to implement the CogQA framework is to determine the concrete models of System 1 and 2, and the form of <em>clues</em>.</p>
<p>Our implementation uses BERT as System 1 and GNN as System 2. Meanwhile, <em>clues</em>[<em>x</em>, <strong>G</strong>] are sentences in paragraphs of <em>x</em>'s predecessor nodes, from which <em>x</em> is extracted. We directly pass raw sentences as <em>clues</em>, rather than any form of computed hidden states, for easy training of System 1. Because raw sentences are self-contained and independent of computations from previous iterative steps, training at different iterative steps is then decoupled, leading to efficiency gains during training. Details are introduced in § 3.4. Hidden representations <strong>X</strong> for graph nodes are updated each time by a propagation step of GNN.</p>
<p>Our overall model is illustrated in Figure 2.</p>
<h3>3.1 System 1</h3>
<p>The extraction capacity of System 1 model is fundamental to construct the cognitive graph, thus a powerful model is needed. Recently, BERT (Devlin et al., 2018) has become one of the most successful language representation models on various NLP tasks, including SQuAD (Rajpurkar et al., 2016). BERT consists of multiple layers of Transformer (Vaswani et al., 2017), a self-attention based architecture, and is elaborately pre-trained on large corpora. Input sentences are composed of two different functional parts A and B.</p>
<p>We use BERT as System 1, and its input when visiting the node <em>x</em> is as follows:</p>
<p>$$
\begin{array}{cc}
\text{[CLS] Question [SEP] clues } [x, \mathcal{G}] &amp; \text{[SEP]} \
\text{Sentence A} &amp; \underbrace{\text{Para}[x]}_{\text{Sentence B}}
\end{array}
$$</p>
<p>where clues $[x, \mathcal{G}]$ are sentences passed from predecessor nodes. The output vectors of BERT are denoted as $\mathbf{T} \in \mathbb{R}^{L \times H}$, where $L$ is the length of the input sequence and $H$ is the dimension size of the hidden representations.</p>
<p>It is worth noting that for answer node $x$, $\operatorname{Para}[x]$ is probably missing. Thus we do not extract spans but can still calculate sem $[x, Q$, clues $]$ based on "Sentence A" part. And when extracting 1-hop nodes from question to initialize $\mathcal{G}$, we do not calculate semantic vectors and only the Question part exists in the input.</p>
<p>Span Extraction Answers and next-hop entities have different properties. Answer extraction relies heavily on the character indicated by the question. For example "New York City" is more possible to be the answer of a where question than "2019", while next-hop entities are often the entities whose description matches statements in the question. Therefore, we predict answer spans and next-hop spans separately.</p>
<p>We introduce "pointer vectors" $\mathbf{S}<em _hop="{hop" _text="\text">{\text {hop }}, \mathbf{E}</em>}}$, $\mathbf{S<em _ans="{ans" _text="\text">{\text {ans }}, \mathbf{E}</em>[i]$ is calculated as follows:}}$ as additional learnable parameters to predict targeted spans. The probability of the $i^{\text {th }}$ input token to be the start of an answer span $P_{\text {ans }}^{\text {start }</p>
<p>$$
P_{\text {ans }}^{\text {start }}[i]=\frac{e^{\mathbf{S}<em i="i">{\text {ans }} \cdot \mathbf{T}</em>}}}{\sum_{j} e^{\mathbf{S<em j="j">{\text {ans }} \cdot \mathbf{T}</em>
$$}}</p>
<p>Let $P_{\text {ans }}^{\text {end }}[i]$ be the probability of the $i^{\text {th }}$ input token to be the end of an answer span, which can be calculated following the same formula. We only focus on the positions with top K start probabilities $\left{\right.$ start $\left.<em k="k">{k}\right}$. For each k , the end position $\operatorname{end}</em>$ is given by:</p>
<p>$$
e n d_{k}=\underset{\text { start }<em k="k">{k} \leq j \leq \text { start }</em>[j]
$$}+\max L}{\arg \max } P_{\text {ans }}^{\text {end }</p>
<p>where $\max L$ is the maximum possible length of spans.</p>
<p>To identify irrelevant paragraphs, we leverage negative sampling introduced in $\S 3.4 .1$ to train System 1 to generate a negative threshold. In top K spans, those whose start probability is less than the negative threshold will be discarded. Because the $0^{\text {th }}$ token $[C L S]$ is pre-trained to synthesize all input tokens for the Next Sentence Prediction task (Devlin et al., 2018), $P_{\text {ans }}^{\text {start }}[0]$ acts as the threshold in our implementation.</p>
<p>We expand the cognitive graph with remaining predicted answer spans as new "answer nodes". The same process is followed to expand "next-hop nodes" by replacing $\mathbf{S}<em _ans="{ans" _text="\text">{\text {ans }}, \mathbf{E}</em>}}$ with $\mathbf{S<em _hop="{hop" _text="\text">{\text {hop }}, \mathbf{E}</em>$.}</p>
<p>Semantics Generation As mentioned above, outputs of BERT at position 0 have the ability to summarize the sequence. Thus the most straightforward method is to use $\mathbf{T}_{0}$ as sem $[x, Q$, clues $]$. However, the last few layers in BERT are mainly in charge of transforming hidden representations for span predictions. In our experiment, the usage of the third-to-last layer output at position 0 as $\operatorname{sem}[x, Q$, clues $]$ performs the best.</p>
<h3>3.2 System 2</h3>
<p>The first function of System 2 is to prepare clues $[x, \mathcal{G}]$ for frontier nodes, which we implement it as collecting the raw sentences of $x$ 's predecessor nodes that mention $x$.</p>
<p>The second function, to update hidden representations $\mathbf{X}$, is the core function of System 2. Hidden representations $\mathbf{X} \in \mathbb{R}^{n \times H}$ stand for the understandings of all $n$ entities in $\mathcal{G}$. To fully understand the relation between an entity $x$ and the question $Q$, barely analyzing semantics $\operatorname{sem}[x, Q$, clues $]$ is insufficient. GNN has been proposed to perform deep learning on graph (Kipf and Welling, 2017), especially relational reasoning owing to the inductive bias of graph structure (Battaglia et al., 2018).</p>
<p>In our implementation, a variant of GNN is designed to serve as System 2. For each node $x$, the initial hidden representation $\mathbf{X}[x] \in \mathbb{R}^{H}$ is the semantic vector sem $[x, Q$, clues $]$ from System 1. Let $\mathbf{X}^{\prime}$ be the new hidden representations after a propagation step of GNN, and $\Delta \in \mathbb{R}^{n \times H}$ be aggregated vectors passed from neighbours in the propagation. The updating formulas of $\mathbf{X}$ are as follows:</p>
<p>$$
\begin{aligned}
&amp; \Delta=\sigma\left(\left(A D^{-1}\right)^{T} \sigma\left(\mathbf{X} W_{1}\right)\right) \
&amp; \mathbf{X}^{\prime}=\sigma\left(\mathbf{X} W_{2}+\Delta\right)
\end{aligned}
$$</p>
<p>where $\sigma$ is the activation function and $W_{1}, W_{2} \in$ $\mathbb{R}^{H \times H}$ are weight matrices. $A$ is the adjacent matrix of $\mathcal{G}$, which is column-normalized to $A D^{-1}$ where $D_{j j}=\sum_{i} A_{i j}$. Transformed hidden vector $\sigma\left(\mathbf{X} W_{1}\right)$ is left multiplied by $\left(A D^{-1}\right)^{T}$, which can be explained as a localized spectral filter by Defferrard et al. (2016).</p>
<p>In the iterative step of visiting frontier node $x$, its hidden representation $\mathbf{X}[x]$ is updated following Equation (3)(4). In experiments, we observe that this "asynchronous updating" shows no apparent difference in performance with updating $\mathbf{X}$ of all the nodes together by multiple steps after $\mathcal{G}$ is</p>
<p>finalized, which is more efficient and adopted in practice.</p>
<h3>3.3 Predictor</h3>
<p>The questions in HotpotQA dataset generally fall into three categories: special question, alternative question and general question, which are treated as three different downstream prediction tasks taking $\mathbf{X}$ as input. In the test set, they can also be easily categorized according to interrogative words.</p>
<p>Special question is the most common case, requesting to find spans such as locations, dates or entity names in paragraphs. We use a two-layer fully connected network (FCN) to serve as predictor $\mathcal{F}$ :</p>
<p>$$
\text { answer }=\underset{\text { answer node } x}{\arg \max } \mathcal{F}(\mathbf{X}[x])
$$</p>
<p>Alternative and general question both aims to compare a certain property of entity $x$ and $y$ in HotpotQA, respectively answered with entity name and "yes or no". These questions are regarded as binary classification with input $\mathbf{X}[x]-$ $\mathbf{X}[y]$ and solved by another two identical FCNs.</p>
<h3>3.4 Training</h3>
<p>Our model is trained under a supervised paradigm with negative sampling. In the training set, the next-hop and answer spans are pre-extracted in paragraphs. More exactly, for each para $[x]$ relevant to question $Q$, we have spans data</p>
<p>$$
\mathcal{D}[x, Q]=\left{\left(y_{1}, \text { start }<em 1="1">{1}, \text { end }</em>}\right), \ldots,\left(y_{n}, \text { start <em n="n">{n}, \text { end }</em>\right)\right}
$$</p>
<p>where the span from start $<em i="i">{i}$ to end $</em>$. See $\S 4.1$ for detail.}$ in para $[x]$ is fuzzy matched with the name of an entity or answer $y_{i</p>
<h3>3.4.1 Task #1: Span Extraction</h3>
<p>The ground truths of $P_{\text {ans }}^{\text {start }}, P_{\text {ans }}^{\text {end }}, P_{\text {hop }}^{\text {start }}, P_{\text {hop }}^{\text {end }}$ are constructed based on $\mathcal{D}[x, Q]$. There is at most one answer span ( $y$, start, end) in every paragraph, thus $\mathbf{g t}<em _ans="{ans" _text="\text">{\text {ans }}^{\text {start }}$ is an one-hot vector where $\mathbf{g t}</em>}}^{\text {start }}[\text { start }]=1$. However, multiple different next-hop spans might appear in one paragraph, so that $\mathbf{g t<em i="i">{\text {hop }}^{\text {start }}\left[\text { start }</em>\right]=1 / k$ where $k$ is the number of next-hop spans.</p>
<p>For the sake of the ability to discriminate irrelevant paragraphs, irrelevant negative hop nodes are added to $\mathcal{G}$ in advance. As mentioned in $\S 3.1$, the output of $[C L S], \mathbf{T}<em _ans="{ans" _text="\text">{0}$, is in charge of generating negative threshold. Therefore, $P</em>[0]=1$.}}^{\text {start }}$ for each negative hop node is the one-hot vector where $\mathbf{g t}_{\text {ans }}^{\text {start }</p>
<p>Cross entropy loss is used to train the span extraction task in System 1. The losses for the end position and for the next-hop spans are defined in the same way as follows.</p>
<p>$$
\mathcal{L}<em i="i">{\text {ans }}^{\text {start }}=-\sum</em>} \mathbf{g t<em _ans="{ans" _text="\text">{\text {ans }}^{\text {start }}[i] \cdot \log P</em>[i]
$$}}^{\text {start }</p>
<h3>3.4.2 Task #2: Answer Node Prediction</h3>
<p>To command the reasoning ability, our model must learn to identify the correct answer node from a cognitive graph. For each question in the training set, we construct a training sample for this task. Each training sample is a composition of the goldonly graph, which is the union of all correct reasoning paths, and negative nodes. Negative nodes include negative hop nodes used in Task #1 and two negative answer nodes. A negative answer node is constructed from a span extracted at random from a randomly chosen hop node.</p>
<p>For special question, we first compute the final answer probabilities for each node by performing softmax on the outputs of $\mathcal{F}$. Loss $\mathcal{L}$ is defined as cross entropy between the probabilities and onehot vector of answer node ans.</p>
<p>$$
\mathcal{L}=-\log (\operatorname{softmax}(\mathcal{F}(\mathbf{X}))[\text { ans }])
$$</p>
<p>Alternative and general questions are optimized by binary cross entropy in similar ways. The losses of this task not only are back-propagated to optimize predictors and System 2, but also fine-tune System 1 through semantic vectors sem $[x, Q$, clues $]$.</p>
<h2>4 Experiment</h2>
<h3>4.1 Dataset</h3>
<p>We use the full-wiki setting of HotpotQA to conduct our experiments. 112,779 questions are collected by crowdsourcing based on the first paragraphs in Wikipedia documents, $84 \%$ of which require multi-hop reasoning. The data are split into a training set ( 90,564 questions), a development set ( 7,405 questions) and a test set ( 7,405 questions). All questions in development and test sets are hard multi-hop cases.</p>
<p>In the training set, for each question, an answer and paragraphs of 2 gold (useful) entities are provided, with multiple supporting facts, sentences containing key information for reasoning, marked out. There are also 8 unhelpful negative paragraphs for training. During evaluation, only questions are offered and meanwhile supporting facts are required besides the answer.</p>
<p>To construct cognitive graphs for training, edges in gold-only cognitive graphs are inferred from supporting facts by fuzzy matching based on Levenshtein distance (Navarro, 2001). For each supporting fact in para $[x]$, if any gold entity or the answer, denoted as $y$, is fuzzy matched with a span in the supporting fact, edge $(x, y)$ is added.</p>
<h3>4.2 Experimental Details</h3>
<p>We use pre-trained BERT-base model released by (Devlin et al., 2018) in System 1. The hidden size $H$ is 768 , unchanged in node vectors of GNN and predictors. All the activation functions in our model are gelu (Hendrycks and Gimpel, 2016). We train models on Task #1 for 1 epoch and then on Task #1 and #2 jointly for 1 epoch. Hyperparameters in training are as follows:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Model</th>
<th style="text-align: center;">Task</th>
<th style="text-align: center;">batch size</th>
<th style="text-align: center;">learning rate</th>
<th style="text-align: center;">weight decay</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">BERT</td>
<td style="text-align: center;">#1,#2</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">$10^{-4}, 4 \times 10^{-5}$</td>
<td style="text-align: center;">0.01</td>
</tr>
<tr>
<td style="text-align: center;">GNN</td>
<td style="text-align: center;">#2</td>
<td style="text-align: center;">graph</td>
<td style="text-align: center;">$10^{-4}$</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<p>BERT and GNN are optimized by two different Adam optimizers, where $\beta_{1}=0.9, \beta_{2}=0.999$. The predictors share the same optimizer as GNN. The learning rate for parameters in BERT warmup over the first $10 \%$ steps, and then linearly decays to zero.</p>
<p>To select out supporting facts, we just regard the sentences in the clues of any node in graph as supporting facts. In the initialization of $\mathcal{G}$, these 1-hop spans exist in the question and can also be detected by fuzzy matching with supporting facts in training set. The extracted 1-hop entities by our framework can improve the retrieval phase of other models (See § 4.3), which motivated us to separate out the extraction of 1-hop entities to another BERT-base model for the purpose of reuse in implementation.</p>
<h3>4.3 Baselines</h3>
<p>The first category is previous work or competitor:</p>
<ul>
<li>Yang et al. (2018) The strong baseline model proposed in the original HotpotQA paper (Yang et al., 2018). It follows the retrieval-extraction framework of DrQA (2017) and subsumes the advanced techniques in QA, such as self-attention, character-level model, bi-attention.</li>
<li>GRN, QFE, DecompRC, MultiQA The other models on the leaderboard. ${ }^{3}$</li>
</ul>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup>- BERT State-of-art model on single-hop QA. BERT in original paper requires singleparagraph input and pre-trained BERT can barely handle paragraphs of at most 512 tokens, much fewer than the average length of concatenated paragraphs. We add relevant sentences from predecessor nodes in the cognitive graph to every paragraphs and report the answer span with maximum start probability in all paragraphs.
- Yang et al. (2018)-IR Yang et al. (2018) with Improved Retrieval. Yang et al. (2018) uses traditional inverted index filtering strategy to retrieve relevant paragraphs. The effectiveness might be challenged due to its failures to find out entities mentioned in question sometimes. The main reason is that word-level matching in retrieval usually neglect language models, which indicates importance and POS of words. We improve the retrieval by adding 1-hop entities spotted in the question by our model, increasing the coverage of supporting facts from $56 \%$ to $72 \%$.
Another category is for ablation study:
- CogQA-onlyR model initializes $\mathcal{G}$ with the same entities retrieved in Yang et al. (2018) as 1-hop entities, mainly for fair comparison.
- CogQA-onlyQ initializes $\mathcal{G}$ only with 1-hop entities extracted from question, free of retrieved paragraphs. Complete CogQA implementation uses both.
- CogQA-sysI only retains System 1 and lacks cascading reasoning in System 2.</p>
<h3>4.4 Results</h3>
<p>Following Yang et al. (2018), the evaluation of answer and supporting facts consists of two metrics: Exact Match (EM) and $F_{1}$ score. Joint EM is 1 only if answer string and supporting facts are both strictly correct. Joint precision and recall are the products of those of Ans and Sup, and then joint $F_{1}$ is calculated. All results of these metrics are averaged over the test set. ${ }^{4}$ Experimental results show superiority of our method in multiple aspects:
Overall Performance Our CogQA outperforms all baselines on all metrics by a significant margin (See Table 1). The leap of performance mainly</p>
<p><sup id="fnref:1"><a class="footnote-ref" href="#fn:1">2</a></sup></p>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">Model</th>
<th style="text-align: center;">Ans</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Sup</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Joint</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">EM</td>
<td style="text-align: center;">$F_{1}$</td>
<td style="text-align: center;">Prec</td>
<td style="text-align: center;">Rec</td>
<td style="text-align: center;">EM</td>
<td style="text-align: center;">$F_{1}$</td>
<td style="text-align: center;">Prec</td>
<td style="text-align: center;">Rec</td>
<td style="text-align: center;">EM</td>
<td style="text-align: center;">$F_{1}$</td>
<td style="text-align: center;">Prec</td>
<td style="text-align: center;">Rec</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Yang et al. (2018)</td>
<td style="text-align: center;">23.9</td>
<td style="text-align: center;">32.9</td>
<td style="text-align: center;">34.9</td>
<td style="text-align: center;">33.9</td>
<td style="text-align: center;">5.1</td>
<td style="text-align: center;">40.9</td>
<td style="text-align: center;">47.2</td>
<td style="text-align: center;">40.8</td>
<td style="text-align: center;">2.5</td>
<td style="text-align: center;">17.2</td>
<td style="text-align: center;">20.4</td>
<td style="text-align: center;">17.8</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Yang et al. (2018)-IR</td>
<td style="text-align: center;">24.6</td>
<td style="text-align: center;">34.0</td>
<td style="text-align: center;">35.7</td>
<td style="text-align: center;">34.8</td>
<td style="text-align: center;">10.9</td>
<td style="text-align: center;">49.3</td>
<td style="text-align: center;">52.5</td>
<td style="text-align: center;">52.1</td>
<td style="text-align: center;">5.2</td>
<td style="text-align: center;">21.1</td>
<td style="text-align: center;">22.7</td>
<td style="text-align: center;">23.2</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">BERT</td>
<td style="text-align: center;">22.7</td>
<td style="text-align: center;">31.6</td>
<td style="text-align: center;">33.4</td>
<td style="text-align: center;">31.9</td>
<td style="text-align: center;">6.5</td>
<td style="text-align: center;">42.4</td>
<td style="text-align: center;">54.6</td>
<td style="text-align: center;">38.7</td>
<td style="text-align: center;">3.1</td>
<td style="text-align: center;">17.8</td>
<td style="text-align: center;">24.3</td>
<td style="text-align: center;">16.2</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">CogQA-sys1</td>
<td style="text-align: center;">33.6</td>
<td style="text-align: center;">45.0</td>
<td style="text-align: center;">47.6</td>
<td style="text-align: center;">45.4</td>
<td style="text-align: center;">23.7</td>
<td style="text-align: center;">58.3</td>
<td style="text-align: center;">67.3</td>
<td style="text-align: center;">56.2</td>
<td style="text-align: center;">12.3</td>
<td style="text-align: center;">32.5</td>
<td style="text-align: center;">39.0</td>
<td style="text-align: center;">31.8</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">CogQA-onlyR</td>
<td style="text-align: center;">34.6</td>
<td style="text-align: center;">46.2</td>
<td style="text-align: center;">48.8</td>
<td style="text-align: center;">46.7</td>
<td style="text-align: center;">14.7</td>
<td style="text-align: center;">48.2</td>
<td style="text-align: center;">56.4</td>
<td style="text-align: center;">47.7</td>
<td style="text-align: center;">8.3</td>
<td style="text-align: center;">29.9</td>
<td style="text-align: center;">36.2</td>
<td style="text-align: center;">30.1</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">CogQA-onlyQ</td>
<td style="text-align: center;">30.7</td>
<td style="text-align: center;">40.4</td>
<td style="text-align: center;">42.9</td>
<td style="text-align: center;">40.7</td>
<td style="text-align: center;">23.4</td>
<td style="text-align: center;">49.9</td>
<td style="text-align: center;">56.5</td>
<td style="text-align: center;">48.5</td>
<td style="text-align: center;">12.4</td>
<td style="text-align: center;">30.1</td>
<td style="text-align: center;">35.2</td>
<td style="text-align: center;">29.9</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">CogQA</td>
<td style="text-align: center;">37.6</td>
<td style="text-align: center;">49.4</td>
<td style="text-align: center;">52.2</td>
<td style="text-align: center;">49.9</td>
<td style="text-align: center;">23.1</td>
<td style="text-align: center;">58.5</td>
<td style="text-align: center;">64.3</td>
<td style="text-align: center;">59.7</td>
<td style="text-align: center;">12.2</td>
<td style="text-align: center;">35.3</td>
<td style="text-align: center;">40.3</td>
<td style="text-align: center;">36.5</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Yang et al. (2018)</td>
<td style="text-align: center;">24.0</td>
<td style="text-align: center;">32.9</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">3.86</td>
<td style="text-align: center;">37.7</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">1.9</td>
<td style="text-align: center;">16.2</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">Test</td>
<td style="text-align: center;">QFE</td>
<td style="text-align: center;">28.7</td>
<td style="text-align: center;">38.1</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">14.2</td>
<td style="text-align: center;">44.4</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">8.7</td>
<td style="text-align: center;">23.1</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">DecompRC</td>
<td style="text-align: center;">30.0</td>
<td style="text-align: center;">40.7</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">MultiQA</td>
<td style="text-align: center;">30.7</td>
<td style="text-align: center;">40.2</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">GRN</td>
<td style="text-align: center;">27.3</td>
<td style="text-align: center;">36.5</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">12.2</td>
<td style="text-align: center;">48.8</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">7.4</td>
<td style="text-align: center;">23.6</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">CogQA</td>
<td style="text-align: center;">37.1</td>
<td style="text-align: center;">48.9</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">22.8</td>
<td style="text-align: center;">57.7</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">12.4</td>
<td style="text-align: center;">34.9</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
</tbody>
</table>
<p>Table 1: Results on HotpotQA (fullwiki setting). The test set is not public. The maintainer of HotpotQA only offers EM and $F_{1}$ for every submission. N/A means the model cannot find supporting facts.
results from the superiority of the CogQA framework over traditional retrieval-extraction methods. Since paragraphs that are multi-hop away may share few common words literally or even little semantic relation with the question, retrievalextraction framework fails to find the paragraphs that become related only after the reasoning clues connected to them are found. Our framework, however, gradually discovers relevant entities following clues.</p>
<p>Logical Rigor QA systems are often criticized to answer questions with shallow pattern matching, not based on reasoning. To evaluate logical rigor of QA, we use $\frac{\text { JointEM }}{\text { AnsEM }}$, the proportion of "joint correct answers" in correct answers. The joint correct answers are those deduced from all necessary and correct supporting facts. Thus, this proportion stands for logical rigor of reasoning. The proportion of our method is up to $33.4 \%$, far outnumbering $7.9 \%$ of Yang et al. (2018) and $30.3 \%$ of QFE.
<img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: Model performance on 8 types of questions with different hops.</p>
<p>Multi-hop Reasoning Figure 3 illustrates joint $F_{1}$ scores and average hops of 8 types of questions, including general, alternative and special
questions with different interrogative word. As the hop number increases, the performance of Yang et al. (2018) and Yang et al. (2018)-IR drops dramatically, while our approach is surprisingly robust. However, there is no improvement in alternative and general questions, because the evidence for judgment cannot be inferred from supporting facts, leading to lack of supervision. Further human labeling is needed to answer these questions.</p>
<p>Ablation Studies To study the impacts of initial entities in cognitive graphs, CogQA-onlyR begins with the same initial paragraphs as (Yang et al., 2018). We find that CogQA-onlyR still performs significantly better. The performance decreases slightly compared to CogQA, indicating that the contribution mainly comes from the framework.</p>
<p>To compare against the retrieval-extraction framework, CogQA-onlyQ is designed that it only starts with the entities that appear in the question. Free of elaborate retrieval methods, this setting can be regarded as a natural thinking pattern of human being, in which only explicit and reliable relations are needed in reasoning. CogQA-onlyQ still outperforms all the baselines, which may reveal the superiority of CogQA framework over the retrieval-extraction framework.</p>
<p>BERT is not the key factor of improvement, although plays a necessary role. Vanilla BERT performs similar or even slightly poorer to (Yang et al., 2018) in this multi-hop QA task, possibly because of the pertinently designed architectures in Yang et al. (2018) to better leverage supervision of supporting facts.</p>
<p>To investigate the impacts of the absence of System 2, we design a System 1 only approach, CogQA-sys1, which inherits the iterative frame-</p>
<p><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 4: Case Study. Different forms of cognitive graphs in our results, i.e., Tree, Directed Acyclic Graph (DAG), Cyclic Graph. Circles are candidate answer nodes while rounded rectangles are hop nodes. Green circles are the final answers given by CogQA and check marks represent the annotated ground truth.
work but outputs answer spans with maximum predicted probability. On Ans metrics, the improvement over the best competitor decreases about $50 \%$, highlighting the reasoning capacity of GNN on cognitive graphs.
Case Study We show how the cognitive graph clearly explains complex reasoning processes in our experiments in Figure 4. The cognitive graph highlights the heart of the question in case (1) i.e., to choose between the number of members in two houses. CogQA makes the right choice based on semantic similarity between "Senate" and "upper house". Case (2) illustrates that the robustness of the answer can be boosted by exploring parallel reasoning paths. Case (3) is a semantic retrieval question without any entity mentioned, which is intractable for CogQA-onlyQ or even human. Once combined with information retrieval, our model finally gets the answer "Marijus Adomaitis" while the annotated ground truth is "Ten Walls". However, when backtracking the reasoning process in cognitive graph, we find that the model has already reached "Ten Walls" and answers with his real name, which is acceptable and even more accurate. Such explainable advantages are not enjoyed by black-box models.</p>
<h2>5 Related work</h2>
<p>Machine Reading Comprehension The research focus of machine reading comprehension (MRC) has been gradually transferred from cloze-style tasks (Hermann et al., 2015; Hill et al., 2015) to more complex QA tasks (Rajpurkar et al., 2016) recent years. Compared to the traditional computational linguistic pipeline (Hermann et al., 2015),
neural network models, for example BiDAF (Seo et al., 2017a) and R-net (Wang et al., 2017), exhibit outstanding capacity for answer extraction in text. Pre-trained on large corpra, recent BERTbased models nearly settle down the single paragraph MRC-QA problem with performances beyond human-level, driving researchers to pay more attention to multi-hop reasoning.</p>
<p>Multi-Hop QA Pioneering datasets of multi-hop QA are either based on limited knowledge base schemas (Talmor and Berant, 2018), or under multiple choices setting (Welbl et al., 2018). The noise in these datasets also restricted the development of multi-hop QA until high-quality HotpotQA (Yang et al., 2018) is released recently. The idea of "multi-step reasoning" also breeds multi-turn methods in single paragraph QA (Kumar et al., 2016; Seo et al., 2017b; Shen et al., 2017), assuming that models can capture information at deeper level implicitly by reading the text again.</p>
<p>Open-Domain QA Open-Domain QA (QA at scale) refers to the setting where the search space of the supporting evidence is extremely large. Approaches to get paragraph-level answers has been thoroughly investigated by the information retrieval community, which can be dated back to the 1990s (Belkin, 1993; Voorhees et al., 1999; Moldovan et al., 2000). Recently, DrQA (Chen et al., 2017) leverages a neural model to extract the accurate answer from retrieved paragraphs, usually called retrieval-extraction framework, greatly advancing this time-honored research topic again. Improvements are made to enhance retrieval by heuristic sampling (Clark and Gardner, 2018) or</p>
<p>reinforcement learning (Hu et al., 2018; Wang et al., 2018a), while for complex reasoning, necessary revisits to the framework are neglected.</p>
<h2>6 Discussion and Conclusion</h2>
<p>We present a new framework CogQA to tackle multi-hop machine reading problem at scale. The reasoning process is organized as cognitive graph, reaching unprecedented entity-level explainability. Our implementation based on BERT and GNN obtains state-of-art results on HotpotQA dataset, which shows the efficacy of our framework.</p>
<p>Multiple future research directions may be envisioned. Benefiting from the explicit structure in the cognitive graph, System 2 in CogQA has potential to leverage neural logic techniques to improve reliability. Moreover, we expect that prospective architectures combining attention and recurrent mechanisms will largely improve the capacity of System 1 by optimizing the interaction between systems. Finally, we believe that our framework can generalize to other cognitive tasks, such as conversational AI and sequential recommendation.</p>
<h2>Acknowledgements</h2>
<p>The work is supported by Development Program of China (2016QY01W0200), NSFC for Distinguished Young Scholar (61825602), NSFC (61836013), and a research fund supported by Alibaba. The authors would like to thank Junyang Lin, Zhilin Yang and Fei Sun for their insightful feedback, and responsible reviewers of ACL 2019 for their valuable suggestions.</p>
<h2>References</h2>
<p>Alan Baddeley. 1992. Working memory. Science, 255(5044):556-559.</p>
<p>Peter W Battaglia, Jessica B Hamrick, Victor Bapst, Alvaro Sanchez-Gonzalez, Vinicius Zambaldi, Mateusz Malinowski, Andrea Tacchetti, David Raposo, Adam Santoro, Ryan Faulkner, et al. 2018. Relational inductive biases, deep learning, and graph networks. arXiv preprint arXiv:1806.01261.</p>
<p>Nicholas J. Belkin. 1993. Interaction with texts: Information retrieval as information-seeking behavior. In Information Retrieval.</p>
<p>Danqi Chen, Adam Fisch, Jason Weston, and Antoine Bordes. 2017. Reading wikipedia to answer opendomain questions. In Proceedings of the 55th Annual Meeting of the Association for Computational</p>
<p>Linguistics (Volume 1: Long Papers), volume 1, pages 1870-1879.</p>
<p>Christopher Clark and Matt Gardner. 2018. Simple and effective multi-paragraph reading comprehension. In Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), volume 1, pages 845-855.</p>
<p>Michaël Defferrard, Xavier Bresson, and Pierre Vandergheynst. 2016. Convolutional neural networks on graphs with fast localized spectral filtering. In Advances in neural information processing systems, pages 3844-3852.</p>
<p>Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2018. BERT: Pre-training of deep bidirectional transformers for language understanding. arXiv preprint arXiv:1810.04805.</p>
<p>Jonathan St BT Evans. 1984. Heuristic and analytic processes in reasoning. British Journal of Psychology, 75(4):451-468.</p>
<p>Jonathan St BT Evans. 2003. In two minds: dualprocess accounts of reasoning. Trends in cognitive sciences, 7(10):454-459.</p>
<p>Jonathan St BT Evans. 2008. Dual-processing accounts of reasoning, judgment, and social cognition. Annu. Rev. Psychol., 59:255-278.</p>
<p>Dan Hendrycks and Kevin Gimpel. 2016. Bridging nonlinearities and stochastic regularizers with gaussian error linear units. arXiv preprint arXiv:1606.08415.</p>
<p>Karl Moritz Hermann, Tomas Kocisky, Edward Grefenstette, Lasse Espeholt, Will Kay, Mustafa Suleyman, and Phil Blunsom. 2015. Teaching machines to read and comprehend. In Advances in Neural Information Processing Systems, pages 16931701 .</p>
<p>Felix Hill, Antoine Bordes, Sumit Chopra, and Jason Weston. 2015. The goldilocks principle: Reading children's books with explicit memory representations. arXiv preprint arXiv:1511.02301.</p>
<p>Minghao Hu, Yuxing Peng, Zhen Huang, Xipeng Qiu, Furu Wei, and Ming Zhou. 2018. Reinforced mnemonic reader for machine reading comprehension. In Proceedings of the 27th International Joint Conference on Artificial Intelligence, pages 40994106. AAAI Press.</p>
<p>Robin Jia and Percy Liang. 2017. Adversarial examples for evaluating reading comprehension systems. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, pages 2021-2031.</p>
<p>Daniel Kahneman and Patrick Egan. 2011. Thinking, fast and slow, volume 1. Farrar, Straus and Giroux New York.</p>
<p>Thomas N Kipf and Max Welling. 2017. Semisupervised classification with graph convolutional networks. In International Conference on Learning Representations.</p>
<p>Ankit Kumar, Ozan Irsoy, Peter Ondruska, Mohit Iyyer, James Bradbury, Ishaan Gulrajani, Victor Zhong, Romain Paulus, and Richard Socher. 2016. Ask me anything: Dynamic memory networks for natural language processing. In International Conference on Machine Learning, pages 1378-1387.</p>
<p>Dan Moldovan, Sanda Harabagiu, Marius Pasca, Rada Mihalcea, Roxana Girju, Richard Goodrum, and Vasile Rus. 2000. The structure and performance of an open-domain question answering system. In Proceedings of the 38th annual meeting on association for computational linguistics, pages 563-570. Association for Computational Linguistics.</p>
<p>Gonzalo Navarro. 2001. A guided tour to approximate string matching. ACM computing surveys (CSUR), 33(1):31-88.</p>
<p>Pranav Rajpurkar, Jian Zhang, Konstantin Lopyrev, and Percy Liang. 2016. Squad: 100,000+ questions for machine comprehension of text. In Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing, pages 2383-2392.</p>
<p>Minjoon Seo, Aniruddha Kembhavi, Ali Farhadi, and Hannaneh Hajishirzi. 2017a. Bidirectional attention flow for machine comprehension. In International Conference on Learning Representations.</p>
<p>Minjoon Seo, Sewon Min, Ali Farhadi, and Hannaneh Hajishirzi. 2017b. Query-reduction networks for question answering. In International Conference on Learning Representations.</p>
<p>Yelong Shen, Po-Sen Huang, Jianfeng Gao, and Weizhu Chen. 2017. Reasonet: Learning to stop reading in machine comprehension. In Proceedings of the 23rd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, pages 1047-1055. ACM.</p>
<p>Steven A Sloman. 1996. The empirical case for two systems of reasoning. Psychological bulletin, 119(1):3.</p>
<p>Alon Talmor and Jonathan Berant. 2018. The web as a knowledge-base for answering complex questions.</p>
<p>In Proceedings of the 2018 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long Papers), volume 1, pages 641-651.</p>
<p>Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Łukasz Kaiser, and Illia Polosukhin. 2017. Attention is all you need. In Advances in Neural Information Processing Systems, pages 5998-6008.</p>
<p>Ellen M Voorhees et al. 1999. The trec-8 question answering track report. In Trec, volume 99, pages 7782. Citeseer.</p>
<p>Shuohang Wang, Mo Yu, Xiaoxiao Guo, Zhiguo Wang, Tim Klinger, Wei Zhang, Shiyu Chang, Gerry Tesauro, Bowen Zhou, and Jing Jiang. 2018a. $r^{3}$ : Reinforced ranker-reader for open-domain question answering. In Thirty-Second AAAI Conference on Artificial Intelligence.</p>
<p>Wei Wang, Ming Yan, and Chen Wu. 2018b. Multigranularity hierarchical attention fusion networks for reading comprehension and question answering. In Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), volume 1, pages 1705-1714.</p>
<p>Wenhui Wang, Nan Yang, Furu Wei, Baobao Chang, and Ming Zhou. 2017. Gated self-matching networks for reading comprehension and question answering. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), volume 1, pages 189-198.</p>
<p>Yingxu Wang, Dong Liu, and Ying Wang. 2003. Discovering the capacity of human memory. Brain and Mind, 4(2):189-198.</p>
<p>Johannes Welbl, Pontus Stenetorp, and Sebastian Riedel. 2018. Constructing datasets for multi-hop reading comprehension across documents. Transactions of the Association of Computational Linguistics, 6:287-302.</p>
<p>Zhilin Yang, Peng Qi, Saizheng Zhang, Yoshua Bengio, William Cohen, Ruslan Salakhutdinov, and Christopher D Manning. 2018. Hotpotqa: A dataset for diverse, explainable multi-hop question answering. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 2369-2380.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{3}$ All these models are unpublished before this paper.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:1">
<p>${ }^{4}$ Thus it is possible that overall $F_{1}$ is lower than both precision and recall.&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>