<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-1584 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-1584</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-1584</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-31.html">extraction-schema-31</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <p><strong>Paper ID:</strong> paper-52305237</p>
                <p><strong>Paper Title:</strong> Novel Methods Generated by Genetic Programming for the Guillotine-Cutting Problem</p>
                <p><strong>Paper Abstract:</strong> New constructive algorithms for the two-dimensional guillotine-cutting problem are presented. The algorithms were produced from elemental algorithmic components using evolutionary computation. A subset of the components was selected from a previously existing constructive algorithm. The algorithms’ evolution and testing process used a set of 46 instances from the literature. The structure of three new algorithms is described, and the results are compared with those of an existing constructive algorithm for the problem. Several of the new algorithms are competitive with respect to a state-of-the-art constructive algorithm. A subset of novel instructions, which are responsible for the majority of the new algorithms’ good performances, has also been found.</p>
                <p><strong>Cost:</strong> 0.011</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e1584.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e1584.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>GP-Constructive-Algo-Evolver</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Genetic Programming system for evolving constructive algorithms for the constrained two-dimensional guillotine-cutting problem (CW_TDC)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A genetic programming system that evolves tree-structured algorithms (heuristics) composed of high-level control instructions and problem-specific terminals to produce novel constructive algorithms for the CW_TDC. The system represents candidate algorithms as syntax trees and applies tournament selection, subtree crossover, and subtree mutations to evolve populations over generations, evaluating candidate algorithms by running them on benchmark instances.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>GP-based algorithm evolution for CW_TDC</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>The paper implements a genetic programming pipeline that constructs new constructive heuristics for the constrained two-dimensional guillotine-cutting problem by evolving tree representations of algorithms. Trees combine a set of basic control nodes (While, If-Then, And, Or, Not, Equal) and problem-specific terminals/functions (Add-p, Cut, BK1..BK4 estimators, ordering/sensor functions, UnionWithTop, etc.). A population of candidate algorithm-trees is evolved by repeated application of selection, crossover and mutation; each candidate is executed (decoded) to produce a solver whose performance on training/test CW_TDC instances is measured and used as fitness. The approach aims to discover compact, executable heuristics that are competitive with hand-designed methods.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs (tree-structured algorithms / pseudocode)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Standard GP subtree crossover implemented by exchanging branches between two parent trees (described in paper as 'exchanging tree branches'); applied with population-level crossover probability 85%. Crossover swaps subtrees to form offspring while preserving syntactic validity (ramped half-and-half initialization and maximum tree height constraints applied).</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Two GP mutation operators were used: 'swap mutation' and 'shrink mutation' (standard GP variants named in the paper) applied with mutation probability 5%. The paper does not fully specify internal mechanics beyond the operator names; swap mutation swaps subtrees or nodes and shrink mutation reduces tree size by replacing a subtree with a child or smaller subtree (operator names taken from GP literature and used by the platform).</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Primary executability/functional metric is empirical solver performance measured by (a) relative error w.r.t. known optimal solution per instance (u_i - z_i)/u_i aggregated over instance sets, and (b) a combined fitness f_p defined in Equation (1) as a weighted sum: alpha*(sum over instances of relative error / n) + (1-alpha)*normalized deviation of algorithm node count from a predefined target l_t (i.e. penalty for complexity). The paper also reports number of hits (instances where optimum found) and CPU time per algorithm as operational executability/functionality metrics.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>Quantitative aggregated results reported in the paper: during evolution (GT1) the 30 best runs produced an average fitness of 5.22% and an average error of 5.93% (over 12 GT1 instances). In evaluation: on GT2 the average fitness ~5.27% and average error ~5.92% (14 instances); on GT3 the average fitness ~3.63% and average error ~4.08% (20 instances). Of the 30 selected best algorithms, 16 reached the optimal value for at least one instance. Evolution wall-clock time per run ranged ~8.2 to 11.0 minutes; evaluation per algorithm on GT2 ranged ~11–30 seconds and on GT3 ranged ~38–51 seconds (per algorithm, per set) as reported.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Constrained two-dimensional guillotine-cutting problem (CW_TDC); constructive heuristic generation for cutting-stock/packing</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>CONS (reference constructive heuristic derived from Álvarez-Valdés et al.), and published metaheuristics GRASP and TABU (from Álvarez-Valdés et al.). The CONS heuristic was also decomposed to provide elemental components/terminals for GP.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>GP with subtree crossover (85% prob.) and swap/shrink mutations (5% prob.) successfully generated compact, executable constructive heuristics that generalize and sometimes outperform the CONS constructive heuristic on benchmark instances. The evolved programs repeatedly implement constructive cycles (While loops) and use problem-specific estimators (BK1..BK4) and ordering/sensor terminals; a small set of novel terminals account for much of the improved performance. The fitness design (combining relative error and node-count penalty) encourages solutions of a target size (the evolutionary process converged to desired sizes). The paper does not define or measure explicit novelty/diversity metrics, nor does it analyze a direct tradeoff between novelty and executability beyond aggregate performance and convergence behavior.</td>
                        </tr>
                        <tr>
                            <td><strong>notes</strong></td>
                            <td>Paper-level experimental GP parameters: population size 1000, generations 100, ramped half-and-half initialization up to height 13, tournament selection, crossover by exchanging tree branches, mutation operators named 'swap mutation' and 'shrink mutation'. Fitness f_p uses parameter alpha to trade off solution error vs tree size (Equation (1)).</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1584.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e1584.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>GPC++-platform</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>GPC++ (Genetic Programming C++ class library) adaptation</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An adaptation of the GPC++ genetic programming C++ library used as the implementation platform to evolve tree-structured candidate algorithms; the paper reports that an adaptation of GPC++ was used to implement the GP operations and evaluation pipeline.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Genetic programming C++ class library</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>GPC++ (adapted)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>The authors adapted an existing GP C++ implementation (GPC++) to evolve tree structures representing constructive algorithms for CW_TDC. The platform provided primitives for population initialization (ramped half-and-half), selection (tournament), crossover (subtree exchange), mutation (swap and shrink mutation), and tree growth control (max height). The adaptation was used as the execution engine for the experimental GP runs.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs (tree-structured algorithm representations)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Described at paper level as subtree branch exchange; implemented by the adapted GPC++ platform. Paper-level crossover probability = 85%.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Implemented via the platform using 'swap mutation' and 'shrink mutation' (paper-level mutation probability = 5%).</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Platform enables execution of candidate algorithm trees and measurement of their empirical performance (relative error per instance, number of hits, runtime) used in the fitness calculation, but the platform itself does not define separate novelty metrics.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Tooling/platform for evolving programmatic heuristics; applied to CW_TDC in the paper</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>GPC++ was a usable basis for implementing the GP experiments; the paper adapted it successfully to run large populations (1000) for 100 generations and to evaluate evolved programs on benchmark instances. The platform supported the GP operators and tree representations needed by the study.</td>
                        </tr>
                        <tr>
                            <td><strong>notes</strong></td>
                            <td>Citation in paper references: Fraser, A. and Weinbrenner, T., 'Genetic programming C++ class library', 1997.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Genetic Programming IV: Routine Human-Competitive Machine Intelligence <em>(Rating: 2)</em></li>
                <li>Human-competitive results produced by genetic programming <em>(Rating: 2)</em></li>
                <li>A Field Guide to Genetic Programming <em>(Rating: 2)</em></li>
                <li>Genetic programming C++ class library <em>(Rating: 1)</em></li>
                <li>Metaheuristics: from Design to Implementation <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-1584",
    "paper_id": "paper-52305237",
    "extraction_schema_id": "extraction-schema-31",
    "extracted_data": [
        {
            "name_short": "GP-Constructive-Algo-Evolver",
            "name_full": "Genetic Programming system for evolving constructive algorithms for the constrained two-dimensional guillotine-cutting problem (CW_TDC)",
            "brief_description": "A genetic programming system that evolves tree-structured algorithms (heuristics) composed of high-level control instructions and problem-specific terminals to produce novel constructive algorithms for the CW_TDC. The system represents candidate algorithms as syntax trees and applies tournament selection, subtree crossover, and subtree mutations to evolve populations over generations, evaluating candidate algorithms by running them on benchmark instances.",
            "citation_title": "here",
            "mention_or_use": "use",
            "system_name": "GP-based algorithm evolution for CW_TDC",
            "system_description": "The paper implements a genetic programming pipeline that constructs new constructive heuristics for the constrained two-dimensional guillotine-cutting problem by evolving tree representations of algorithms. Trees combine a set of basic control nodes (While, If-Then, And, Or, Not, Equal) and problem-specific terminals/functions (Add-p, Cut, BK1..BK4 estimators, ordering/sensor functions, UnionWithTop, etc.). A population of candidate algorithm-trees is evolved by repeated application of selection, crossover and mutation; each candidate is executed (decoded) to produce a solver whose performance on training/test CW_TDC instances is measured and used as fitness. The approach aims to discover compact, executable heuristics that are competitive with hand-designed methods.",
            "input_type": "programs (tree-structured algorithms / pseudocode)",
            "crossover_operation": "Standard GP subtree crossover implemented by exchanging branches between two parent trees (described in paper as 'exchanging tree branches'); applied with population-level crossover probability 85%. Crossover swaps subtrees to form offspring while preserving syntactic validity (ramped half-and-half initialization and maximum tree height constraints applied).",
            "mutation_operation": "Two GP mutation operators were used: 'swap mutation' and 'shrink mutation' (standard GP variants named in the paper) applied with mutation probability 5%. The paper does not fully specify internal mechanics beyond the operator names; swap mutation swaps subtrees or nodes and shrink mutation reduces tree size by replacing a subtree with a child or smaller subtree (operator names taken from GP literature and used by the platform).",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Primary executability/functional metric is empirical solver performance measured by (a) relative error w.r.t. known optimal solution per instance (u_i - z_i)/u_i aggregated over instance sets, and (b) a combined fitness f_p defined in Equation (1) as a weighted sum: alpha*(sum over instances of relative error / n) + (1-alpha)*normalized deviation of algorithm node count from a predefined target l_t (i.e. penalty for complexity). The paper also reports number of hits (instances where optimum found) and CPU time per algorithm as operational executability/functionality metrics.",
            "executability_results": "Quantitative aggregated results reported in the paper: during evolution (GT1) the 30 best runs produced an average fitness of 5.22% and an average error of 5.93% (over 12 GT1 instances). In evaluation: on GT2 the average fitness ~5.27% and average error ~5.92% (14 instances); on GT3 the average fitness ~3.63% and average error ~4.08% (20 instances). Of the 30 selected best algorithms, 16 reached the optimal value for at least one instance. Evolution wall-clock time per run ranged ~8.2 to 11.0 minutes; evaluation per algorithm on GT2 ranged ~11–30 seconds and on GT3 ranged ~38–51 seconds (per algorithm, per set) as reported.",
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Constrained two-dimensional guillotine-cutting problem (CW_TDC); constructive heuristic generation for cutting-stock/packing",
            "comparison_baseline": "CONS (reference constructive heuristic derived from Álvarez-Valdés et al.), and published metaheuristics GRASP and TABU (from Álvarez-Valdés et al.). The CONS heuristic was also decomposed to provide elemental components/terminals for GP.",
            "key_findings": "GP with subtree crossover (85% prob.) and swap/shrink mutations (5% prob.) successfully generated compact, executable constructive heuristics that generalize and sometimes outperform the CONS constructive heuristic on benchmark instances. The evolved programs repeatedly implement constructive cycles (While loops) and use problem-specific estimators (BK1..BK4) and ordering/sensor terminals; a small set of novel terminals account for much of the improved performance. The fitness design (combining relative error and node-count penalty) encourages solutions of a target size (the evolutionary process converged to desired sizes). The paper does not define or measure explicit novelty/diversity metrics, nor does it analyze a direct tradeoff between novelty and executability beyond aggregate performance and convergence behavior.",
            "notes": "Paper-level experimental GP parameters: population size 1000, generations 100, ramped half-and-half initialization up to height 13, tournament selection, crossover by exchanging tree branches, mutation operators named 'swap mutation' and 'shrink mutation'. Fitness f_p uses parameter alpha to trade off solution error vs tree size (Equation (1)).",
            "uuid": "e1584.0"
        },
        {
            "name_short": "GPC++-platform",
            "name_full": "GPC++ (Genetic Programming C++ class library) adaptation",
            "brief_description": "An adaptation of the GPC++ genetic programming C++ library used as the implementation platform to evolve tree-structured candidate algorithms; the paper reports that an adaptation of GPC++ was used to implement the GP operations and evaluation pipeline.",
            "citation_title": "Genetic programming C++ class library",
            "mention_or_use": "use",
            "system_name": "GPC++ (adapted)",
            "system_description": "The authors adapted an existing GP C++ implementation (GPC++) to evolve tree structures representing constructive algorithms for CW_TDC. The platform provided primitives for population initialization (ramped half-and-half), selection (tournament), crossover (subtree exchange), mutation (swap and shrink mutation), and tree growth control (max height). The adaptation was used as the execution engine for the experimental GP runs.",
            "input_type": "programs (tree-structured algorithm representations)",
            "crossover_operation": "Described at paper level as subtree branch exchange; implemented by the adapted GPC++ platform. Paper-level crossover probability = 85%.",
            "mutation_operation": "Implemented via the platform using 'swap mutation' and 'shrink mutation' (paper-level mutation probability = 5%).",
            "uses_literature": null,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Platform enables execution of candidate algorithm trees and measurement of their empirical performance (relative error per instance, number of hits, runtime) used in the fitness calculation, but the platform itself does not define separate novelty metrics.",
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Tooling/platform for evolving programmatic heuristics; applied to CW_TDC in the paper",
            "comparison_baseline": "",
            "key_findings": "GPC++ was a usable basis for implementing the GP experiments; the paper adapted it successfully to run large populations (1000) for 100 generations and to evaluate evolved programs on benchmark instances. The platform supported the GP operators and tree representations needed by the study.",
            "notes": "Citation in paper references: Fraser, A. and Weinbrenner, T., 'Genetic programming C++ class library', 1997.",
            "uuid": "e1584.1"
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Genetic Programming IV: Routine Human-Competitive Machine Intelligence",
            "rating": 2,
            "sanitized_title": "genetic_programming_iv_routine_humancompetitive_machine_intelligence"
        },
        {
            "paper_title": "Human-competitive results produced by genetic programming",
            "rating": 2,
            "sanitized_title": "humancompetitive_results_produced_by_genetic_programming"
        },
        {
            "paper_title": "A Field Guide to Genetic Programming",
            "rating": 2,
            "sanitized_title": "a_field_guide_to_genetic_programming"
        },
        {
            "paper_title": "Genetic programming C++ class library",
            "rating": 1,
            "sanitized_title": "genetic_programming_c_class_library"
        },
        {
            "paper_title": "Metaheuristics: from Design to Implementation",
            "rating": 1,
            "sanitized_title": "metaheuristics_from_design_to_implementation"
        }
    ],
    "cost": 0.01097675,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>Novel Methods Generated by Genetic Programming for the Guillotine-Cutting Problem
2 September 2018</p>
<p>Vittorio Bertolini 
Informatics Engineering Department
University of Santiago of Chile
SantiagoChile</p>
<p>Carlos Rey 
Informatics Engineering Department
University of Santiago of Chile
SantiagoChile</p>
<p>Mauricio Sepulveda 
Informatics Engineering Department
San Sebastián University
SantiagoChile</p>
<p>Victor Parada victor.parada@usach.cl 0000-0002-8649-5694
Informatics Engineering Department
University of Santiago of Chile
SantiagoChile</p>
<p>Novel Methods Generated by Genetic Programming for the Guillotine-Cutting Problem
2 September 2018C87C8E6C22CCD812FBBF82560FCFD88D10.1155/2018/6971827Received 25 January 2018; Revised 2 August 2018; Accepted 7 August 2018;
New constructive algorithms for the two-dimensional guillotine-cutting problem are presented.e algorithms were produced from elemental algorithmic components using evolutionary computation.A subset of the components was selected from a previously existing constructive algorithm.e algorithms' evolution and testing process used a set of 46 instances from the literature.e structure of three new algorithms is described, and the results are compared with those of an existing constructive algorithm for the problem.Several of the new algorithms are competitive with respect to a state-of-the-art constructive algorithm.A subset of novel instructions, which are responsible for the majority of the new algorithms' good performances, has also been found.</p>
<p>Introduction</p>
<p>Various industrial processes exist in which the raw material must be cut into smaller sections that must be assembled to produce the final product, as in the case of cutting plastics, glass, paper, and metals [1][2][3].A typical case occurs in the wooden board cutting industry that requires efficient techniques to minimize the loss of material in furniture manufacturing.A piece of furniture is manufactured from rectangular pieces of wood cut from rectangular wooden plates by a saw which allows an end-to-end cutting of the plate [4,5].In turn, Park et al. [6] describe the situation that occurs during the manufacturing and cutting of glass.In such a case, a continuously produced sheet of glass is cut into large sheets, which in turn are cut into smaller rectangular pieces according to the customer requirements.e cut is made according to an optimal cutting pattern that minimizes wasted glass.</p>
<p>ese kinds of processes generated a family of stock cutting problems, which aim at determining the best method of using raw materials [7].</p>
<p>Often approached from a combinatorial optimization perspective, cutting problems represent an intellectual challenge because of the computational difficulty that arises when attempting to solve them [8].A particular case is the constrained two-dimensional guillotine-cutting problem studied in this paper, which focuses on cutting rectangular plates [9,10].</p>
<p>e statement of the problem considers a rectangular plate of length L and width W that must be cut into a set of m small rectangular pieces p 1 , p 2 ,. .., p m of sizes w i and l i and area s i � w i • l i such that w i ≤ W and l i ≤ L for every i ∈ P � {1,2,. ..,m}.A limit b i &gt; 0 ∀ i ∈ P that corresponds to the number of times that piece i, with profit v i &gt; 0, can be cut from the rectangular plate is considered.A cutting pattern is a feasible configuration of pieces to be cut from the plate.e geometric feasibility of the cutting pattern considers that (i) all cuts must be of the guillotine type, (ii) there should be no overlap among the pieces that constitute the pattern, and (iii) the pieces must be positioned in a fixed orientation.Defining x i ∈ Z + 0 as the number of times that a piece of type i is found in a pattern, the problem lies in determining a cutting pattern with a maximum value z �  i v i x i such that 0 ≤ x i ≤ b i , ∀ i ∈ P. Following the commonly used notation [11,12], the problem corresponds to the constrained weighted version (CW_TDC).Conversely, following the classification of Wäscher et al. [7], this case corresponds to a two-dimensional, rectangular, single large object placement problem.</p>
<p>e problem has been studied not only for its impact on the optimization of raw material use in industrial processes but also for the computational difficulty that arises when attempting to solve it by exact methods.ree initial approaches that are based on the dynamic programming formulation (DPF) have generated these impacts [13]: the solution space formulation using graphs (GF), which produces search methods based on trees [14,15], and the constructive approach (CF), which allows combining rectangles in an increasing manner while retaining the feasibility of the guillotine cuts [16].ese fundamental methods have also been improved by incorporating changes that allow optimal solution searching to be performed with a better computational performance [17][18][19][20][21].</p>
<p>e most efficient results have been achieved with a hybridization of the fundamental ideas, and thus, search methods based on trees have been designed using the hybridization of GF with DPF, which have allowed solving for small-and medium-sized instances of the problem [10,[22][23][24][25].</p>
<p>For large instances of the problem, the heuristic combinations are more complex.Álvarez-Valdés et al. [9] combine constructive procedures that allow for the determination of the upper bounds with path relinking, and they use the GRASP and tabu search [26] metaheuristics as base algorithms.</p>
<p>e authors also present a constructive algorithm (CONS) whereby at each iteration, a new piece is assigned over a rectangle that is dynamically updated.Conversely, Morabito et al. [27] generated a hybrid search strategy by combining depth-first searching with hill climbing.A third hybridization level is incorporated into the method by combining it with an algorithm that solves the problem using a sequence of one-dimensional knapsack subproblems [28].Hybridization between simulated annealing and evolutionary algorithms, considering both GF and CF approaches, has also been explored numerically to solve different sized problems [29].</p>
<p>During the last four decades of research on the CW_TDC problem, researchers have performed computational studies of some specific hybridizations of the existing methods to obtain better performance in terms of both the computational time and the quality of the obtained solution.However, other potential hybridizations have not been explored.is paper proposes that the exploration of those methods can be accelerated with the support of evolutionary computation, specifically using the same ideas that support genetic programming [30,31].</p>
<p>is discipline allows the step-by-step combination of complex structures by following the principles of Darwinian evolution.By combining the elemental components of a constructive algorithm to solve the CW_TDC problem with some components specifically generated for this problem, novel and new algorithms can be produced and analyzed to discover sets of instructions having some logic that may give rise to new algorithmic ideas.In this paper, we describe the performance of a set of created algorithms that are compared with two known heuristics for the problem, estimating their similarities and relative computational designs.A subset of the elemental algorithmic components was selected from the constructive algorithm CONS, aiming to produce other similar algorithms following the same idea.</p>
<p>Design of Elemental</p>
<p>Algorithmic Components e algorithms are generated by genetic programming (GP), a particular technique in the field of evolutionary computation.e latter is an area of knowledge that refers to the study of methods inspired by Darwinian evolution to solve problems in science and engineering [31,32].In GP, the elementary components of computer programs are gradually assembled to generate a piece of computer code that is responsible for performing a specific task.e pieces of code are represented by syntactic trees. is way of automatically producing a computer program starts with some high-level specifications and gradually generates the code for the intended task.Populations evolve gradually through the application of selection, variation, and reproduction operators, so that, population after population, the structures become increasingly specialized in their specific task.e elementary components can be functions such as the typical instructions while, if-then, or, and, among others.Also, GP can consider specific functions for the intended task.When algorithms are automatically generated for a combinatorial optimization problem, such elementary components can be ad-hoc heuristics for the problem.Figure 1 illustrates the generation of algorithms for the CW_TDC.</p>
<p>Algorithms for CW_TDC are gradually built by an evolutionary process.To perform this task, each algorithm is represented as a tree of instructions, where the intermediate nodes are high-level instructions, and leaf nodes corresponding to problem-specific functions are entrusted to build the layout.</p>
<p>e process is outlined in Figure 1.From a population P(k) containing a fixed number of trees, the implementation of the selection, crossover, and mutation operations generates a new population P(k + 1).To evaluate the performance of each tree, the fitness evaluation module uses a set of adaptation problem instances available in the literature for the CW_TDC problem.</p>
<p>e instructions are executed sequentially, traversing the tree with an in-order, depth-first search.e best tree found during the evolutionary process is stored and subsequently decoded into the corresponding pseudocode.</p>
<p>Basic Definitions.</p>
<p>Several definitions are needed to implement this approach.e first is the definition of the sets of high-level instructions and of problem-specific functions for the CW_TDC problem.It is also necessary to have sets of adaptation and testing problem instances.Finally, a fitness function, which is responsible for guiding the evolutionary process, is required.e basic idea is to generate a new algorithm from a well-known, previously existing heuristic for a problem and from there, start an improvement process.In this sense, we consider CONS [9], which efficiently solves several problem instances of CW_TDC as the reference algorithm.First, such an algorithm is decomposed into its elemental components, and then, other similar algorithms are created.e new algorithms are the result of the combination of those elemental components.e CONS constructive algorithm has a main cycle through which, at each iteration, a new piece is assigned over a rectangle R k with dimensions W k and L k .A guillotine-type cut generates four new, smaller external rectangles R 1 k and R 2 k or R 3 k and R 4 k , depending on whether the cut is vertical or horizontal.ose rectangles are stored to be cut in the following iteration by the same logic (Figure 2).e process stops when it is no longer possible to assign a piece to the stored rectangles, and these pieces are considered as a loss of material.</p>
<p>e piece chosen for assigning in a rectangle R k is the one that generates the maximum estimated pro t. is value is calculated as the pro t of the piece plus the sum of the pro ts when assigning, in decreasing order of r i v i /s i , the available pieces in the rectangles R 1 k and R 2 k or R 3 k and R 4 k .Speci cally, this pro t is estimated using an algorithm BK 1 to solve the knapsack problem [33].In this case, the elements of the knapsack are the pieces; the weight corresponds to the area, and the capacity corresponds to the area of each rectangle R 1 k and R 2 k or R 3 k and R 4 k .A procedure BK 2 is also de ned, which, unlike BK 1 , inserts the rst piece available as many times as it ts in the rectangle and applies the estimates based on the knapsack problem for spaces not occupied by the rst piece.</p>
<p>In addition to BK 1 and BK 2 , we de ne two new procedures, namely, BK 3 and BK 4 , to calculate the estimated pro t in the outer rectangles.BK 3 is a variant of BK 2 that assigns available pieces to the horizontal base of the rectangle, in decreasing order of r i v i /s i , until there is no more space for a piece to t (Figure 3).e pro t is then estimated using BK 1 in the rectangles R 1 , R 2 , . .., R q , which are generated by considering a horizontal line drawn from the widest piece already assigned.</p>
<p>BK 4 is de ned by locating the pieces sequentially to di erent rows of the rectangle, as de ned in the work of Co man et al. [34], for a strip of in nite length.In this case, the height of each row is given by the tallest piece when assignment takes place from the bottom left corner without going beyond the limit L k (Figure 4(a)).</p>
<p>e pieces are assigned following the decreasing order of r i v i /s i .During the piece-assigning process, the pieces that do not t in the rectangle being formed (between the height of the row and width W k and between the sum of the lengths of the pieces assigned to the row and L k ) are ignored (Figure 4(b)).A new row is created when the next piece does not t along the length but does t in an upper level.</p>
<p>e algorithms to be constructed must operate on three data structures.First, a list of pieces available (LPA) stores the pieces remaining at each stage.Second, a list of rectangles (LR) is completed as the algorithm advances, with rectangles R k still to be processed.At each step, there is an active rectangle being processed.At the beginning, the list contains only the original rectangle.</p>
<p>ose rectangles in which no Scienti c Programming available piece ts are considered losses.Finally, a stack of blocks (SB) contains blocks of pieces constructed using vertical or horizontal joining operations either between pieces or blocks according to the Wang heuristic [16].Supported by this stack, it is not necessary to assign the selected piece immediately, as occurs with CONS, but it can be stored and therefore joined with the other pieces, forming blocks whose size limit is given by the processed rectangle R k .
P (k) P (k + 1)</p>
<p>De nition of Functions.</p>
<p>e elemental components of the algorithms to be produced are translated into two sets of functions.</p>
<p>e rst set contains the basic instructions in most computer languages and is de ned with the parameters P 1 and P 2 as integer variables, considering that a value greater than 0 corresponds to the "true" logical value and that a value equal to 0 corresponds to "false."All functions return true or false, and they are While (P 1 , P 2 ), If en (P 1 , P 2 ), Not (P 1 ), And (P 1 , P 2 ), Equal (P 1 , P 2 ), and Or (P 1 , P 2 ).</p>
<p>e second set contains speci c functions for the CW_TDC problem that are su cient to allow for the reconstruction of the reference algorithm.Figure 5 depicts the function's mode of operation.It shows a rectangle R k receiving a block and therefore giving rise to two new    2).e pair of rectangles that generates the largest estimated profit using BK 1 is selected.e selected rectangles are stored in LR. en, a new rectangle R k in LR is activated, which corresponds to the rectangle with the largest estimated profit, using BK 1 with the available pieces.e function always returns 1 (true Based on the set of functions and variables OP, BKj, Rk, and SU, the CONS algorithm can be reconstructed as in Algorithm 1.
W k L k R 1 R q R 2 R 3 l1 l2 l3 l4 w 3 Figure 3: Rectangles for evaluating BK 3 : R 1 , R 2 , R 3 , and R q . L k W k R 1 k R 2 k w i l i (a) W k R 4 k w i l i L k R 3 k (b)L k W k h (a) L k W k (b)
To provide greater variability for algorithm construction, new specific functions are generated based on the following four strategies:</p>
<p>(a) Provide greater freedom to join a piece with a block in the SB, according to the horizontal or vertical construction method.With this strategy, the pieces can be assigned as they are selected, and they can also be joined, forming a block to be assigned later.</p>
<p>(b) Establish the order in which the pieces must be inserted in the active rectangle to estimate the profits from using BK 1 , BK 2 , BK 3 , and BK 4 .(c) Establish a selection criterion of the next rectangle R k to be assigned.(d) Define sensors that deliver online information about the characteristics of the problem at any instant of the process.</p>
<p>e new specific functions are as follows:</p>
<p>(i) UnionWithTop(): a function that selects a piece identical to the last one entered into SB and joins it using a horizontal or vertical combination with the block at the top of SB. e function selects the combination that generates the smallest internal loss.In addition, it returns the number of the selected piece; otherwise, it returns 0 (false).(ii) IfPieceRep(P 1 , P 2 ): a function that acts as a sensor to estimate the average number of times that the available pieces fit in the rectangle R k.  1) [9,11,35].e instances are classified into three groups.e first group (GT1) has 12 instances for the evolution stage, and the second and third groups (GT2 and GT3) are used for the evaluation stage.Both groups have 14 and 20 instances, respectively.e criterion used to separate them is to divide the total area of the plate by the sum of the areas of all the available pieces (including the ones that are repeated).Each group has the following instances: (i) GT1: "2s," "Hchl4s," "CHL2s," "CHL5s," "Hchl3s," "OF1," "OF2," "Hchl5s," "A5," "A4," "Hchl6s," and "STS4S."(ii) GT2: "CHL6," "CHL1s," "APT34," "CHL7," "A3," "Hchl7s," "APT35," "APT36," "APT30," "Hchl2," "CU7," "Hchl1," "A2s," and "APT38."(iii) GT3: "CU1," "wang1," "APT37," "APT39," "STS2s," "APT33," "APT32," "CU11," "CU9," "CU8," "CU2," "APT31," "CU10," "A1s," "CU4," "W," "3s," "CU6," "CU5," and "CU3."</p>
<p>e Fitness Function.</p>
<p>e fitness function considers two objectives.e first one is the quality of the algorithm or relative error, whereby the smaller the relative error, the greater the quality.</p>
<p>e second criterion considers the relative deviation of the algorithm's number of nodes related to an initially fixed number of nodes.Both terms are expressed in Equation ( 1). e first term is determined by a mathematical function where u i and z i are the optimum values for instance i and the value obtained by the algorithm when such an instance is solved.Additionally, n represents the total number of instances, and α is a numerical value used to give a certain priority or importance to the different terms in the fitness function.e second term of the fitness function is the limit of the number of nodes that an algorithm can have, where l t represents the initial number of predefined nodes and l a indicates the number of nodes of the generated algorithm.</p>
<p>en, the fitness function f p is the union of both terms and measures the performance of the algorithms:
f p � α n 􏽘 n i�1 u i − z i 􏼌 􏼌 􏼌 􏼌 􏼌 􏼌 􏼌 􏼌 u i +(1 − α) l t − l a 􏼌 􏼌 􏼌 􏼌 􏼌 􏼌 􏼌 􏼌 l t .
(1)</p>
<p>Tools and Parameters.</p>
<p>Performing the evolutionary process uses an adaptation of the platform originally developed to implement the GP application GPC++ and designed to evolve tree structures [36].e process was 6 Scientific Programming performed using Windows 7 on a computer with a 2.5 GHz i5 processor and 8 GB RAM.</p>
<p>A population size of 1000 individuals and 100 generations was used, and the crossover and mutation probabilities were set at 85% and 5%, respectively.e "ramped half-andhalf" method was used to create the initial population, with a controlled initial tree size that could later grow to a height of 13. e selection of the fittest individual was performed by a tournament.e mutations used were "swap mutation" and "shrink mutation" [32], and the crossover was performed by exchanging tree branches.</p>
<p>Results</p>
<p>e experiment is made up of two parts: the evolution process and the evaluation process.In the first process, the new algorithms face the GT1 set of instances, and the experiment is repeated 30 times to select the best algorithm of each execution.With the selected 30 algorithms, the second process follows, which is divided into two parts: First, the algorithms are evaluated with the GT2 set of instances and later, with GT3.</p>
<p>Convergence.</p>
<p>In the 30 executions of the experiment, the convergence curve shows that the individuals of each generation systematically converge until reaching an average error of between 2 and 4%.e graph in Figure 6 shows the convergence of each of the 30 executions considering a population of 1000 individuals per generation and with a total of 100 generations.In general, it is observed that the fitness values for generation 1 begin with values ranging between approximately 104 and 110%, gradually decreasing until the algorithms reach fitness between 14 and 18%.During the first generations, the error is over 100% because the fitness function also considers the number of nodes, and during those generations, there are algorithms that do not assign any piece and that have different number of nodes than in the initial configuration.</p>
<p>Algorithm Generation.</p>
<p>e best resulting algorithm of each of the executions is selected.Table 2 shows the details of the best algorithms found.e first column indicates the name of the best algorithm of the corresponding execution; it is denoted using the letter A followed by a number indicating the number of the execution from which it comes from.e second column indicates the algorithm's average fitness with the 12 instances of GT1. e third column represents the average error.e fourth and fifth columns indicate the best and worst errors found by the algorithm in one of the 12 GT1 instances.e sixth column shows the standard deviation, and the seventh, eighth, and ninth columns show the number of hits (instances where the algorithm finds the optimum solution), the number of nodes, and the height of the algorithm.Finally, the last column shows the computation time each execution required.</p>
<p>Of the 30 selected algorithms, 16 reach optimum values for at least one instance.Consequently, the best error value is 0.00.In general, all the algorithms are capable of determining a near optimum solution for some of the 12 instances.is is evidenced by the best error value of 0.60%.In contrast, an error of 14.85% found as a worst error average shows that all the algorithms face some difficulty with at least one of the instances.e lowest error average is found in execution 12 at approximately 3.96%, and the lowest fitness average is also found in algorithm 12 at 3.49%.</p>
<p>e required computer time for evolution is 8.19 minutes for execution 5, and the greatest time is 10.99 minutes for execution 13. e average fitness is 5.22%, and the best average is 5.93%.</p>
<p>Algorithm Evaluation.</p>
<p>e generated algorithms are robust, and they do not over specialize.To demonstrate this, an evaluation process of the best algorithms found was used.</p>
<p>is process consists of evaluating the 30 best algorithms in instances different from those used in their creation.</p>
<p>erefore, groups of instances GT2 and GT3 were used.Table 3 shows the evaluation results of the 30 algorithms with instances of group GT2.Considering that the number of instances used is greater and that these instances have more combinations, better results are observed compared to the results in the evolution process.Regarding the lower fitness average, there are seven executions under 4.00%, in contrast to the case of evolution that has only two.e highest fitness average value increased by approximately 2.00%, specifically, from 6.52% to 8.33%.e same effect is observed in the error average.In the column that shows the number of hits, it is observed that no algorithm found an optimum value.e computer time required to solve the 14 instances of group GT2 is between 11.0 and 30.0 seconds for each algorithm.</p>
<p>e produced algorithms present similar computational performances in the evolution and evaluation stages.e instances used to evaluate the algorithms present greater flexibility in terms of the ratio area of the plate/area of the pieces.Table 4 shows the evaluation results of the 30 algorithms with instances of group GT3.An improvement in the results is observed compared to the evolution of the instances of group GT1 and the evaluation with instances of group GT2. e lowest fitness average is 2.14%, while the greatest is 5.37%.As observed in the table, the new algorithms find at least one optimum solution for an instance.However, the computer time required by the algorithms increases.</p>
<p>e size of the algorithms tends to stabilize at the initially predefined size.ere is an indirect evolution of the size of an algorithm during its evolutionary construction toward the predefined size, as specified in Equation (1).Specifically, this effect is supervised by the second term of the fitness function.Table 2 shows that the 30 best algorithms found the same number of initially defined nodes.In other words, the evolutionary process converges toward a search region where algorithms of the desired size are found.However, the distribution of nodes in the tree is varied.</p>
<p>Results in Table 2 suggest that is possible to inspect algorithms of a given size by simply fixing the parameter value in the fitness function.us, the search for algorithms may focus on desired regions that may be identified beforehand, considering the sizes of the heuristics that already exist for the problem at hand.An example is algorithm A13 in Table 2, with 13 nodes and a height of 4, which has a fitness average of 3.66% for a total of 46 instances where their performance was measured.Figure 7 shows the A13 algorithm's tree representation that stands out in both stages of evolution and evaluation.e main characteristic of A13 is its left branch, which has an instruction While that generates a constructive cycle as long as one of the available pieces fits into the plate.e Cut terminal begins when the first piece is assigned, and it divides the initial plate, obtaining two new smaller plates.en, the Add-p terminal that selects the first or second plate is executed and generates the unions based on an estimator BKi. e constructive cycle repeats until it meets the finishing criteria.</p>
<p>e found algorithms follow a constructive and an improvement logic.All the generated algorithms have at least one cycle, and within them, they build solutions from an initial plate until no other piece fits in the plate.e algorithms represented in Figure 8 were selected because they were among the five best algorithms of the experiment.Algorithms A4 and A14 have a while cycle composed of a set of functions and terminals, among which Add-p and Cut are   Scienti c Programming focused on the logical constructive steps.Add-p is in charge of joining blocks and Cut and of assigning them to the plate, repeating this process until the plate is completed.e algorithms assemble the location of the pieces using the criteria of best fit. is behavior is found specifically in the BK i estimators because each estimator has a different criteria to fit pieces.If the default BK 1 estimator is not useful for fitting pieces, then it is possible for the algorithm to use a different estimator in one of its tree's branches.Moreover, there is another way to use the best piece, based on the ordered lists that offer the best possible fit, using different methods of sorting the pieces during the selection.ese methods may be from largest to smallest or from smallest to largest, considering its own criterion that indicates the type of sorting applied (width, length, area, etc.).A clear example is algorithm A4 of Figure 8, which has a Cut terminal in its left branch with a BK 2 estimator and an Add-p terminal and two BK 3 terminals in its right branch.</p>
<p>e found algorithms are a generalization of good existing heuristics for this problem.e CONS heuristic is the fundamental base of the generated algorithms.e algorithms find a solution that begins with the greatest loss and gradually decreases as pieces are assigned to the solution.Figure 8 provides two examples that show that the Addp and Cut terminals, which are part of the CONS heuristic, the base for the algorithms to solve the instances.Both algorithms show such terminals, and they are generally preceded by the function while, which produces repetition a number of times until the algorithms reach the optimum or nearly optimum result.</p>
<p>Constructive cycles prevail in the found algorithms.In most of the analyzed algorithms, there are cycles that try to find a possible solution using estimators and piece lists.Always connected by a While cycle, Add-p and Cut prioritize the construction of blocks to find the solution, as can be observed in the right branch of algorithm A14 presented in Figure 8.</p>
<p>is branch, with only seven nodes, executes a number of combinations to solve the problem.Because the While is the base of the branch, the algorithm ensures that the execution is repeated in the other six nodes until the stop criterion is reached.ere are two And functions in the other six nodes, leaving the last four nodes (Add-p with BK 2 and Cut with BK 3 with While) as the base of the constructive cycles.</p>
<p>e cycles in the algorithms operate as instruction compacters.</p>
<p>e resulting algorithms are capable of repeating the process a great number of times, which are not always the same, using few code lines.In this way, a great number of operations are conducted, but instructions are compacted in small and easy to understand branches.An example appears in Figure 8, where the three algorithms have 13 nodes each and are able to solve instances that involve from 10 pieces to over 50 pieces without the need to use more than one While cycle in their structure.</p>
<p>Several algorithms obtained are competitive with respect to a state-of-the-art constructive algorithm.Table 5 shows a summary of the results obtained by CONS, GRASP, and TABU algorithms presented in Álvarez-Valdés et al. [9] for instances GT2 and GT3.It is observed that for "Avg.error (%)," the four evolved constructive algorithms A2, A14, A15, and A29 have a lower value than the value generated by CONS algorithm for both groups of data GT2 and GT3.Additionally, algorithms A4, A23, and A28 have a lower value only with instances in GT2; meanwhile, algorithms A6, A8, A11, A13, A16, A23, and A30 have better performance with instances in GT3.Also, the new algorithms find at least one optimal solution for instances in GT3 compared with none optimal solution found by CONS.GRASP and TABU algorithms are more effective since they obtain a lower average error.With respect to the running time required by CONS, it is lower than the average of the running time required by the new algorithms.</p>
<p>Conclusion</p>
<p>is paper describes a computational model and experiment that allowed for the generation of algorithms to solve a set of instances of the guillotine-cutting problem.e generated algorithms were decoded from tree structures that were evolved with a computational tool based on GP. e functions that constitute the basic components of the produced algorithms were deduced by identifying the basic components of an existing algorithm.Other functions inspired by the geometric and algorithmic solutions of the problem were added to provide greater variability in the algorithm search.e best 30 algorithms were identified and tested with 46 representative instances of the problem.e average error of the algorithms varied between 3.00 and 5.00%.</p>
<p>e generated algorithms are able to find better results by working on instances with more possible combinations among their pieces.e computational results are similar between instances of different combinatory degrees.</p>
<p>Figure 1 :
1
Figure 1: Evolution of algorithms.</p>
<p>Figure 2 :
2
Figure 2: (a) Vertical and (b) horizontal cuts.</p>
<p>Figure 4 :
4
Figure 4: Geometry to obtain the upper bound BK 4 in rectangle R k .(a) Completed and (b) in process.</p>
<p>Figure 7 :Figure 8 :
78
Figure 7: Tree of the algorithm from run 13.</p>
<p>10
10</p>
<p>4</p>
<p>Scienti c Programmingrectangles to be placed in LR.Functions selecting a piece from LPA to be combined with the already existing blocks in SB are also sketched.efollowing variables are necessary:(i) OP: this variable stores the order of the pieces used in the BK i procedures.e default value is Val-Standard_v/s, indicating that a decreasing order r i � v i /s i must be used.(ii) BKj: this variable stores the BK i procedure to be used.e default value is ValStandard_BK 1 , indicating that BK 1 must be used.(iii) R k : this variable stores the mechanism for selecting the next rectangle R k to be assigned to LR. e default value is ValueStandard_BK, indicating that the estimator indicated in BKj must be used.(iv) SU: this variable indicates that the horizontal or vertical joining process for the next piece to be placed in SB must be stopped.</p>
<p>en, the following specific functions are defined: (i) Add-p(): a function that inserts the available piece into SB that maximizes the estimated profit using BK 1 over the active rectangle R k .e function returns the piece number.(ii) Cut(): this function assigns a block from SB to the active rectangle R k and deletes it from LR. Two rectangles are generated, either R 1 k and R 2 k in the horizontal case or R 3 k and R 4 k in the vertical case (Figure</p>
<p>IfCorrelation(P 1 , P 2 ): a function that acts as a sensor that correlates the values of v i and s i of the available pieces that fit in R k .If the pieces are correlated by a value &gt; 0.7, then P 1 is performed; otherwise, P 2 is performed.ecorrelationindex ranges from 0 to 1, with 1 indicating that the variables are completely correlated.ecorrelation is calculated as follows: covariance / (standard deviation v i * standard deviation s i ). e function returns the value of the executed parameter.(iv)IfBigPiece(P 1 , P 2 ): a function that acts as a sensor to estimate the size of the available pieces.If at least 50% of the available pieces have an area greater than one-eighth of the plate, then P 1 is performed; otherwise, P 2 is performed.efunction returns the value of the executed parameter.(v)BK 3 (): a function that acts as a flag to indicate that, in the next execution of the Cut or Add-p function Figure 5: Function operations on the lists LPA, SB, and LR.(whichever occurs first), the indicator BK 3 must be used.e function always returns 3 (true).(vi) BK 4 (): a function that acts as a flag to indicate that, in the next execution of the Cut or Add-p function (whichever occurs first), the indicator BK 4 must be used.e function always returns 4 (true).(vii) StopUnion(): a function that acts as a flag and that can stop the automatic horizontal-vertical joining that occurs in SB when a piece is inserted into the next Add-p execution.e function returns 1 (true).(viii) DescendingArea(): a function indicating that the list to be used in the next execution of a BK i estimator must use the pieces in order from greatest to smallest areas.is function returns 2 (true).(ix) AscendingArea(): a function indicating that the list to be used in the next execution of a BK i estimator must use the pieces in order from smallest to greatest areas.is function returns 2 (true).(x) DescendingProp(): a function indicating that the list to be used during the next execution of a BK i estimator must use the pieces in order from longest to shortest length, as long as the length is greater than the width.If not, the piece is considered to be rotated 90 degrees. is function returns 3 (true).(xi) AscendingProp(): a function indicating that the list to be used during the next execution of a BK i estimator must use the pieces in order from shortest to longest length, as long as the length is greater than the width.If not, the piece is considered to be rotated 90 degrees. is function returns 4 (true).(xii) DescendingLength(): a function indicating that the list to be used during the next execution of a BK i estimator must use the pieces in order from longest to shortest length.is function returns 5 (true).(xiii) DescendingWidth(): a function indicating that the list to be used during the next execution of a BK i estimator must use the pieces in order from greatest to smallest width. is function returns 6 (true).(xiv) UPDOWN_PROP(): a function indicating that the list to be used during the next execution of a BK i estimator must use a decreasing ranking of the pieces for profit versus area v i /s i . is is the default value.is function returns 3 (true).(xv) MAXWL_WASTE(): this function acts as a flag, which indicates that, in the next Cut() execution, the rectangle R k with the largest area must be selected.It returns 1 (false) or 2 (true) if there is a rectangle R k .
Add(); UnionWithTop()Cut()R k 1R k 2LPASBR kLR
If this average is greater than 2, it performs P 1 ; otherwise, it performs P 2 .It returns the value of the parameter that was executed.(iii)2.3.Evolution and Evaluation of the Algorithms.For the evolution and evaluation of algorithms, 46 instances of problem CW_TDC were used (Table</p>
<p>Table 1 :
1
Testing instances.
Convergence curve1.00.8Fitness (FP)0.60.40.20.0147101316192225283134374043464952555861646770737679828588919497100Run 1Run 7Run 13Run 19Run 25Run 2Run 8Run 14Run 20Run 26Run 3Run 9Run 15Run 21Run 27Run 4Run 10Run 16Run 22Run 28Run 5Run 11Run 17Run 23Run 29Run 6Run 12Run 18Run 24Run 30Number of instancesInstancesReference14OF1, OF2, W, CU1, CU2, CU3, CU4, CU5, CU6, CU7, CU8, CU9, CU10, CU11Fayard et al. [11]14STS2, STS4, A1s, A2s, STS2s, STS4s, CHL1s, CHL2s, A3, A4, A5, CHL5, CHL6, CHL7Cung et al. [35]5Hchl3s, Hchl4s, Hchl5s, Hchl6s, Hchl7sÁlvarez-Valdés et al. [9]9APT30, APT31, APT32, APT33, APT34, APT35, APT36, APT37, APT38, APT39Álvarez-Valdés et al. [9]
GenerationsFigure 6: Convergence for the 30 runs.</p>
<p>Table 3 :
3
Evaluation of algorithms with instances from group GT2.
AlgorithmAvg. fitness (%)Avg. error (%)Best error (%)Worst error (%)SD (%)HitsTime (s)A18.339.352.3416.124.43021.0A23.533.971.478.142.20020.0A36.046.803.0816.123.46018.0A43.513.940.887.242.43017.0A54.434.951.4113.893.54025.0A65.646.341.3218.534.61023.0A74.535.091.0111.762.85015.0A85.646.341.3218.534.61014.0A96.046.803.0816.123.46017.0A107.158.033.0916.124.11015.0A114.294.831.3211.762.94013.0A124.565.121.0718.534.57011.0A134.324.841.3812.203.24019.0A143.614.061.598.142.08020.0A153.554.001.2112.203.26022.0A164.294.831.3211.762.94027.0A176.006.731.6418.504.71021.0A186.046.803.0816.123.46022.0A198.339.352.3416.124.43027.0A205.736.461.6416.124.03026.0A216.046.803.0816.123.46020.0A226.307.071.6418.504.70019.0A233.894.381.838.972.18020.0A246.046.803.0816.123.46024.0</p>
<p>Table 2 :
2
Best algorithm of each of the 30 runs.
Algorithm Avg. fitness (%) Avg. error (%) Best error (%) Worst error (%) SD (%) No. of hits No. of nodes Tree height Time (s)A16.527.400.0015.225.171134553.00A24.695.331.3620.755.420134560.82A35.846.630.0014.374.361133592.03A44.384.962.0218.294.510133532.11A55.185.890.8610.573.670135491.15A65.856.661.3612.933.730133595.45A74.284.851.3610.742.910134564.03A85.856.661.3612.933.730134599.26A95.846.630.0014.374.361134603.54A104.635.260.0011.643.791134600.85A115.195.911.3614.963.650133511.67A123.493.960.009.832.631133556.78A134.505.140.0013.873.981134659.11A143.924.450.7510.233.090134597.02A155.636.411.3120.756.470136596.93A164.645.280.7513.173.400134518.51A176.156.980.8617.775.190133607.99A185.846.630.0014.374.361133607.98A196.347.200.0014.824.621134591.04A205.035.700.0012.524.021135618.95A215.846.630.0014.374.361134596.01A225.596.371.3613.144.160135592.75A235.095.810.0017.954.851134598.61A245.846.630.0014.374.361134580.30A254.234.800.0014.484.261135648.99A265.155.860.0017.954.621134516.53A275.846.630.0014.374.361134602.66A284.384.962.0218.294.510134587.45A294.695.331.3620.755.420135549.60A306.257.110.0015.814.821134573.66Average5.225.930.6014.854.290.5134580.16</p>
<p>Table 3 :
3
Continued.
AlgorithmAvg. tness (%)Avg. error (%)Best error (%)Worst error (%)SD (%)HitsTime (s)A255.135.782.0016.123.55015.0A266.066.813.0816.123.38025.0A276.046.803.0816.123.46019.0A283.513.940.887.242.43017.0A293.533.971.478.142.20014.0A305.996.731.3218.534.94015.0Average5.275.921.9014.203.50019.0ANDA13WHILEORORADD-PMAXWL-WASTEBK 2ANDIF-THENBK 4MINWL-WASTECUTBK 4</p>
<p>Table 4 :
4
Evaluation of algorithms with instances from group GT3.
AlgorithmAvg. fitness (%)Avg. error (%)Best error (%)Worst error (%)SD (%)No. of hitsTime (s)A15.095.71012.863.91148.0A22.322.6005.561.33144.0A34.224.7408.962.93151.0A43.333.74011.582.61141.0A54.034.52010.122.74144.0A63.023.3908.232.31146.0A73.413.8308.342.14145.0A83.023.3908.232.31142.0A94.224.7408.962.93140.0A104.214.73011.853.13139.0A112.662.9906.961.82150.0A123.704.15020.424.41149.0A132.142.4107.801.74148.0A142.683.0108.232.09141.0A152.312.5907.802.01143.0A162.662.9906.961.82142.0A175.376.03015.734.14151.0A184.224.7408.962.93142.0A195.095.71012.863.91143.0A204.434.97013.203.43138.0A214.224.7408.962.93145.0A225.376.03015.734.14142.0A232.432.7306.961.76145.0A244.224.7408.962.93148.0A253.523.9608.962.80143.0A264.224.7408.962.93150.0A274.224.7408.962.93151.0A283.333.74011.582.61151.0A292.322.6005.561.33142.0A303.023.3908.232.31146.0Average3.634.0809.892.71145.0</p>
<p>Table 5 :
5
Evaluation of algorithms with instances in groups GT2 and GT3.
AlgorithmAvg. error (%) GT2Hits GT2Time (s) GT2Avg. error (%) GT3Hits GT3Time (s) GT3CONS4.5302.453.3602.75GRASP1.632142.440.737158.4TABU0.345 1459.860.2591730.1
Scientific Programming
Scientific Programming
2s, wang1, wang2, wang3 Others
Acknowledgmentsis research was partially funded by the Complex Engineering Systems Institute (ICM-FIC: P05-004-F, CONICYT: FB0816).Data Availabilitye data set used in this paper is very common in the field of cutting problems and can be obtained from a public web site: http://people.brunel.ac.uk/∼mastjjb/jeb/info.html.Conflicts of Intereste authors declare that they have no conflicts of interest.Computer Games TechnologyInternational Journal ofScienti c ProgrammingSubmit your manuscripts at www.hindawi.com
Optimizing the cutting of wood fibre plates in the hardboard industry. R N Morabito, L Belluzzo, European Journal of Operational Research. 18332007</p>
<p>A coupling cutting stock-lot sizing problem in the paper industry. S C Poltroniere, K C Poldi, F M B Toledo, M N Arenales, Annals of Operations Research. 15712008</p>
<p>On the onedimensional stock cutting problem in the paper tube industry. K Matsumoto, S Umetani, H Nagamochi, Journal of Scheduling. 1432011</p>
<p>Approaches to real world two-dimensional cutting problems. E Malaguti, R Durán, P Toth, Omega. 472014</p>
<p>An information system for the furniture industry to optimize the cutting process and the waste generated. O Oliveira, D Gamboa, P Fernandes, Procedia Computer Science. 1002016</p>
<p>Development of a heuristic algorithm for cutting stock problems in flat glass production processes. K.-T Park, J.-H Ryu, H.-K Lee, I.-B Lee, Journal of Chemical Engineering of Japan. 4532012</p>
<p>An improved typology of cutting and packing problems. G Wäscher, H Haubner, H Schumann, European Journal of Operational Research. 18332007</p>
<p>M R Garey, D S Johnson, Computers and Intractability. A Guide to the eory of NP-Completeness: A Series of Books in the Mathematical Sciences. San Francisco, CA, USAWH Freeman and Company1979</p>
<p>A tabu search algorithm for large-scale guillotine (un)constrained two-dimensional cutting problems. R Álvarez-Valdés, A Parajon, J M Tamarit, Computers &amp; Operations Research. 2972002</p>
<p>A heuristic approach based on dynamic programming and and/or-graph search for the constrained two-dimensional guillotine cutting problem. R N Morabito, V Pureza, Annals of Operations Research. 17912010</p>
<p>An efficient approach for large-scale two-dimensional guillotine cutting stock problems. D Fayard, M Hifi, V Zissimopoulos, Journal of the Operational Research Society. 49121998</p>
<p>A worst case analysis of a dynamic programming-based heuristic algorithm for 2D unconstrained guillotine cutting. X Song, C B Chu, R Lewis, Y Y Nie, J Ompson, European Journal of Operational Research. 20222010</p>
<p>A linear programming approach to the cutting stock problem-Part II. P C Gilmore, R E Gomory, Operations Research. 1161963</p>
<p>e trim-loss and assortment problems: a survey. A I Hinxman, European Journal of Operational Research. 511980</p>
<p>An algorithm for twodimensional cutting problems. N Christofides, C Whitlock, Operations Research. 2511977</p>
<p>Two algorithms for constrained twodimensional cutting stock problems. P Y Wang, Operations Research. 3131983</p>
<p>Recursive computational procedure for twodimensional stock cutting. J C Herz, IBM Journal of Research and Development. 1651972</p>
<p>Constrained two-dimensional cutting: an improvement of Christofides and Whitlock's exact algorithm. M Hifi, V Zissimopoulos, Journal of the Operational Research Society. 4831997</p>
<p>A computational improvement to Wang's twodimensional cutting stock algorithm. F Vasko, Computers &amp; Industrial Engineering. 1611989</p>
<p>Two-stage general block patterns for the two-dimensional cutting problem. Y Cui, X Zhang, Computers &amp; Operations Research. 34102007</p>
<p>Partial enumeration algorithms for two-dimensional bin packing problem with guillotine constraints. A Lodi, M Monaci, E Pietrobuoni, Discrete Applied Mathematics. 2172017</p>
<p>An exact algorithm for orthogonal 2-D cutting problems using guillotine cuts. N Christofides, E Hadjiconstantinou, European Journal of Operational Research. 8311995</p>
<p>Algorithms for unconstrained two-dimensional guillotine cutting. J E Beasley, Journal of the Operational Research Society. 3641985</p>
<p>Algorithms for two-dimensional cutting stock and strip packing problems using dynamic programming and column generation. F G Cintra, F K Miyazawa, Y Wakabayashi, E C Xavier, European Journal of Operational Research. 19112008</p>
<p>A recursive algorithm for constrained twodimensional cutting problems. Y Chen, Computational Optimization and Applications. 4132007</p>
<p>E Talbi, Metaheuristics: from Design to Implementation. Hoboken, NJ, USAJohn Wiley and Sons2009</p>
<p>An andor-graph approach for two-dimensional cutting problems. R N Morabito, M N Arenales, V F Arcaro, European Journal of Operational Research. 5821992</p>
<p>e DH/KD algorithm: a hybrid approach for unconstrained two-dimensional cutting problems. M Hifi, European Journal of Operational Research. 9711997</p>
<p>A comparative numerical analysis for the guillotine two-dimensional cutting problem. V Parada, R Palma, D Sales, A Gomes, Annals of Operations Research. 961-42000</p>
<p>Genetic Programming IV: Routine Human-Competitive Machine Intelligence. J R Koza, M A Keane, M J Streeter, W Mydlowec, J Yu, G Lanza, 2005Kluwer Academic PublishersNorwell, MA, USA</p>
<p>Human-competitive results produced by genetic programming. J R Koza, Genetic Programming and Evolvable Machines. 113-42010</p>
<p>R Poli, W B Langdon, N F Mcphee, A Field Guide to Genetic Programming. London, UKLulu Enterprises UK Ltd2008</p>
<p>S Martello, P Toth, Knapsack Problems: Algorithms and Computer Implementations. Bologna, ItalyJohn Wiley &amp; Sons1990</p>
<p>Approximation algorithms for bin packing: a survey. E G CoffmanJr, M R Garey, D S Johnson, Approximation Algorithms for NP-Hard Problems. D S Hochbaum, Boston, MA, USAPWS Publishing Co1997</p>
<p>Constrained twodimensional cutting stock problems a best-first branchand-bound algorithm. V Cung, M Hifi, B Le Cun, International Transactions in Operational Research. 732000</p>
<p>Genetic programming C++ class library. A Fraser, T Weinbrenner, 1997</p>            </div>
        </div>

    </div>
</body>
</html>