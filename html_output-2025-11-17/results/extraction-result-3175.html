<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-3175 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-3175</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-3175</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-74.html">extraction-schema-74</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the agent, the memory mechanism, the tasks, and performance comparisons.</div>
                <p><strong>Paper ID:</strong> paper-c1126fbffd6b8547a44c58b192b36b08b18299de</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/c1126fbffd6b8547a44c58b192b36b08b18299de" target="_blank">Neural Turing Machines</a></p>
                <p><strong>Paper Venue:</strong> arXiv.org</p>
                <p><strong>Paper TL;DR:</strong> A combined system is analogous to a Turing Machine or Von Neumann architecture but is differentiable end-toend, allowing it to be efficiently trained with gradient descent.</p>
                <p><strong>Paper Abstract:</strong> We extend the capabilities of neural networks by coupling them to external memory resources, which they can interact with by attentional processes. The combined system is analogous to a Turing Machine or Von Neumann architecture but is differentiable end-toend, allowing it to be efficiently trained with gradient descent. Preliminary results demonstrate that Neural Turing Machines can infer simple algorithms such as copying, sorting, and associative recall from input and output examples.</p>
                <p><strong>Cost:</strong> 0.011</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e3175.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e3175.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the agent, the memory mechanism, the tasks, and performance comparisons.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>NTM (feedforward controller)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Neural Turing Machine with feedforward controller</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A neural network controller coupled to an external differentiable memory matrix (N x M) accessed by multiple read/write heads using content-based and location-based (interpolation, circular shift, sharpening) addressing; trained end-to-end by gradient descent to learn algorithms such as copy, sort, and associative recall.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>Neural Turing Machine (feedforward controller)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Controller: feedforward neural network; Memory: external N x M differentiable memory matrix; Access: multiple parallel read and write heads that emit weightings over memory locations, use content-based key lookup (cosine similarity with key strength), interpolation gate, circular-shift-based location addressing, and sharpening; Writes are erase-then-add vectors. Entire system is differentiable and trained with gradient descent.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>external differentiable memory matrix (addressable by content and location)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism_description</strong></td>
                            <td>Memory is an N x M matrix. Read vectors = weighted sum over rows using normalized weightings from read heads. Writes use per-location weighted erase followed by add vectors. Addressing combines content-based lookup (cosine similarity with a key and key strength) with interpolation to previous weighting, a shift (circular convolution over discrete shifts) and sharpening (exponentiation and renormalization). Controllers emit keys, gates, shift distributions, erase/add vectors and head weightings; memory is updated each time-step differentiably and can be iterated by relative shifts.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Copy; Repeat Copy; Associative Recall; Dynamic N-Grams; Priority Sort</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>A suite of algorithmic sequence tasks: Copy (store and perfectly recall arbitrary sequences); Repeat Copy (output a sequence multiple times and emit end token); Associative Recall (store items and on query output the subsequent item); Dynamic N-Grams (rapidly adapt to a newly sampled 6-gram distribution from observed counts); Priority Sort (sort vectors by continuous priority and output top-K). Challenges: long-term storage and retrieval, indirection, rapid online adaptation, and sorting.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>algorithmic sequence manipulation / memory-augmented tasks</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_comparison</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>NTM with a feedforward controller learned faster and generalised far better than a standard LSTM baseline on these algorithmic tasks: it learned copy and repeat-copy algorithms that generalised to sequences longer than seen in training (trained up to length 20, NTM generalised to lengths up to memory limits like 120 with high fidelity), solved associative recall to near-zero cost within ≈30,000 episodes (where LSTM did not reach zero after 1,000,000 episodes), implemented approximate counting for dynamic N-grams yielding a small but significant advantage over LSTM, and learned to use priorities as write locations to perform sorting; using multiple parallel heads improved performance on tasks like Priority Sort.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Limited by finite memory size (e.g., 128 locations caused wrap-around and overwrite when sequences exceeded capacity); some generalisation limits (e.g., repeat-count numeric input did not generalise well beyond training range so end-marker timing failed beyond ~11 repeats); occasional addressing mistakes (dynamic n-gram task produced specific misaddressing errors); feedforward controller imposes bottleneck (number of read/write heads limits concurrent operations), and some tasks required many heads (eight heads for best Priority Sort performance).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Neural Turing Machines', 'publication_date_yy_mm': '2014-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3175.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e3175.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the agent, the memory mechanism, the tasks, and performance comparisons.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>NTM (LSTM controller)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Neural Turing Machine with recurrent (LSTM) controller</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An NTM variant that uses an LSTM as the controller so the controller retains internal recurrent state (register-like) in addition to external memory, combining controller internal memory with an addressable external memory matrix and the same differentiable read/write/addressing mechanisms.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>Neural Turing Machine (LSTM controller)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Controller: LSTM recurrent network (internal hidden state and memory cells); Memory: external differentiable N x M matrix accessed by heads (same erase/add, content and location addressing as other NTM variants). The LSTM controller can store intermediate read vectors and state across time-steps, complementing external memory.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>external differentiable memory matrix (addressable by content and location) plus controller internal recurrent memory</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism_description</strong></td>
                            <td>As for NTM: external memory with read/write heads (content-based cosine-similarity keys with key strength, interpolation gate blending with previous weightings, shift via circular convolution, sharpening). Additionally, the LSTM controller maintains internal gated recurrent state (cell and hidden vectors) that it uses alongside read vectors to produce head parameters and outputs; this allows storing intermediate results without requiring extra heads.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Copy; Repeat Copy; Associative Recall; Dynamic N-Grams; Priority Sort</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Same suite of algorithmic sequence and memory tasks as above (store/recall sequences, repeat copies with counters, associative indirection, rapid adaptation to new n-gram distributions, and priority-based sorting).</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>algorithmic sequence manipulation / memory-augmented tasks</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_comparison</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>NTM with an LSTM controller also outperformed a standard LSTM on most tasks and learned useful algorithms; in some tasks (e.g., associative recall) NTM with a feedforward controller learned faster than NTM with an LSTM controller, suggesting external memory can be more effective for certain data-structure tasks; the LSTM controller adds flexibility (can store prior read vectors) but did not eliminate the benefits of the external memory.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Although combining LSTM controller and external memory helps, the architecture still inherits NTM limitations: memory size bounds generalisation, addressing errors can occur, and training complexity; in some tasks feedforward controllers learned faster, indicating controller choice interacts non-trivially with task and memory use.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Neural Turing Machines', 'publication_date_yy_mm': '2014-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3175.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e3175.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the agent, the memory mechanism, the tasks, and performance comparisons.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Standard LSTM baseline</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Long Short-Term Memory (stacked LSTM baseline)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A standard recurrent neural network with LSTM cells (three stacked hidden LSTM layers in experiments) used as the baseline; it relies on internal recurrent state for memory rather than an external addressable memory matrix.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>Standard LSTM (stacked 3-layer baseline)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Three stacked LSTM layers (internal gated recurrent memory/cells) with logistic sigmoid output predicting targets; trained with RMSProp on same supervised tasks as NTMs. No external addressable memory matrix; memory is internal to recurrent state.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>internal recurrent memory (LSTM hidden/cell state)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism_description</strong></td>
                            <td>Uses gated recurrent cells (LSTM) to selectively integrate inputs over time, providing persistent internal state (cell vectors) that acts as working memory; lacks explicit external read/write addressing mechanisms.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Copy; Repeat Copy; Associative Recall; Dynamic N-Grams; Priority Sort</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Same set of algorithmic sequence tasks used to compare capacity for long-term storage, indirection, rapid adaptation, and sorting, testing LSTM's ability to learn and generalise these algorithms using internal recurrent memory alone.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>algorithmic sequence manipulation / memory-augmented tasks</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_comparison</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Standard LSTM baseline often learned more slowly, converged to higher cost, and generalised poorly compared to NTMs: e.g., on Copy trained up to length 20, LSTM rapidly degrades beyond 20 while NTM generalises to much longer lengths; on Associative Recall LSTM failed to reach near-zero cost after 1,000,000 episodes whereas NTM reached near zero by ≈30,000 episodes; on Repeat Copy LSTM solved the task but generalised poorly in sequence length and repetitions; on Dynamic N-Grams LSTM performed worse than NTM (NTM had a small but significant advantage).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Internal recurrent memory scales poorly for long sequences and complex data-structure operations: poor generalisation to sequence lengths beyond training range, slower learning on many algorithmic tasks, and inability to implement explicit addressable indirection or large random-access memory without greatly increasing network size.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Neural Turing Machines', 'publication_date_yy_mm': '2014-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Long Short-Term Memory <em>(Rating: 2)</em></li>
                <li>Differentiable Neural Computers and Neural Turing Machines (follow-up literature) <em>(Rating: 1)</em></li>
                <li>Learning to Transduce with Unbounded Memory (Hochreiter et al. / related program search literature) <em>(Rating: 1)</em></li>
                <li>A Neural Probabilistic Language Model (context on early memory and modelling) <em>(Rating: 1)</em></li>
                <li>Neural Machine Translation by Jointly Learning to Align and Translate <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-3175",
    "paper_id": "paper-c1126fbffd6b8547a44c58b192b36b08b18299de",
    "extraction_schema_id": "extraction-schema-74",
    "extracted_data": [
        {
            "name_short": "NTM (feedforward controller)",
            "name_full": "Neural Turing Machine with feedforward controller",
            "brief_description": "A neural network controller coupled to an external differentiable memory matrix (N x M) accessed by multiple read/write heads using content-based and location-based (interpolation, circular shift, sharpening) addressing; trained end-to-end by gradient descent to learn algorithms such as copy, sort, and associative recall.",
            "citation_title": "here",
            "mention_or_use": "use",
            "agent_name": "Neural Turing Machine (feedforward controller)",
            "agent_description": "Controller: feedforward neural network; Memory: external N x M differentiable memory matrix; Access: multiple parallel read and write heads that emit weightings over memory locations, use content-based key lookup (cosine similarity with key strength), interpolation gate, circular-shift-based location addressing, and sharpening; Writes are erase-then-add vectors. Entire system is differentiable and trained with gradient descent.",
            "memory_used": true,
            "memory_type": "external differentiable memory matrix (addressable by content and location)",
            "memory_mechanism_description": "Memory is an N x M matrix. Read vectors = weighted sum over rows using normalized weightings from read heads. Writes use per-location weighted erase followed by add vectors. Addressing combines content-based lookup (cosine similarity with a key and key strength) with interpolation to previous weighting, a shift (circular convolution over discrete shifts) and sharpening (exponentiation and renormalization). Controllers emit keys, gates, shift distributions, erase/add vectors and head weightings; memory is updated each time-step differentiably and can be iterated by relative shifts.",
            "task_name": "Copy; Repeat Copy; Associative Recall; Dynamic N-Grams; Priority Sort",
            "task_description": "A suite of algorithmic sequence tasks: Copy (store and perfectly recall arbitrary sequences); Repeat Copy (output a sequence multiple times and emit end token); Associative Recall (store items and on query output the subsequent item); Dynamic N-Grams (rapidly adapt to a newly sampled 6-gram distribution from observed counts); Priority Sort (sort vectors by continuous priority and output top-K). Challenges: long-term storage and retrieval, indirection, rapid online adaptation, and sorting.",
            "task_type": "algorithmic sequence manipulation / memory-augmented tasks",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_performance_comparison": true,
            "key_findings": "NTM with a feedforward controller learned faster and generalised far better than a standard LSTM baseline on these algorithmic tasks: it learned copy and repeat-copy algorithms that generalised to sequences longer than seen in training (trained up to length 20, NTM generalised to lengths up to memory limits like 120 with high fidelity), solved associative recall to near-zero cost within ≈30,000 episodes (where LSTM did not reach zero after 1,000,000 episodes), implemented approximate counting for dynamic N-grams yielding a small but significant advantage over LSTM, and learned to use priorities as write locations to perform sorting; using multiple parallel heads improved performance on tasks like Priority Sort.",
            "limitations_or_challenges": "Limited by finite memory size (e.g., 128 locations caused wrap-around and overwrite when sequences exceeded capacity); some generalisation limits (e.g., repeat-count numeric input did not generalise well beyond training range so end-marker timing failed beyond ~11 repeats); occasional addressing mistakes (dynamic n-gram task produced specific misaddressing errors); feedforward controller imposes bottleneck (number of read/write heads limits concurrent operations), and some tasks required many heads (eight heads for best Priority Sort performance).",
            "uuid": "e3175.0",
            "source_info": {
                "paper_title": "Neural Turing Machines",
                "publication_date_yy_mm": "2014-10"
            }
        },
        {
            "name_short": "NTM (LSTM controller)",
            "name_full": "Neural Turing Machine with recurrent (LSTM) controller",
            "brief_description": "An NTM variant that uses an LSTM as the controller so the controller retains internal recurrent state (register-like) in addition to external memory, combining controller internal memory with an addressable external memory matrix and the same differentiable read/write/addressing mechanisms.",
            "citation_title": "here",
            "mention_or_use": "use",
            "agent_name": "Neural Turing Machine (LSTM controller)",
            "agent_description": "Controller: LSTM recurrent network (internal hidden state and memory cells); Memory: external differentiable N x M matrix accessed by heads (same erase/add, content and location addressing as other NTM variants). The LSTM controller can store intermediate read vectors and state across time-steps, complementing external memory.",
            "memory_used": true,
            "memory_type": "external differentiable memory matrix (addressable by content and location) plus controller internal recurrent memory",
            "memory_mechanism_description": "As for NTM: external memory with read/write heads (content-based cosine-similarity keys with key strength, interpolation gate blending with previous weightings, shift via circular convolution, sharpening). Additionally, the LSTM controller maintains internal gated recurrent state (cell and hidden vectors) that it uses alongside read vectors to produce head parameters and outputs; this allows storing intermediate results without requiring extra heads.",
            "task_name": "Copy; Repeat Copy; Associative Recall; Dynamic N-Grams; Priority Sort",
            "task_description": "Same suite of algorithmic sequence and memory tasks as above (store/recall sequences, repeat copies with counters, associative indirection, rapid adaptation to new n-gram distributions, and priority-based sorting).",
            "task_type": "algorithmic sequence manipulation / memory-augmented tasks",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_performance_comparison": true,
            "key_findings": "NTM with an LSTM controller also outperformed a standard LSTM on most tasks and learned useful algorithms; in some tasks (e.g., associative recall) NTM with a feedforward controller learned faster than NTM with an LSTM controller, suggesting external memory can be more effective for certain data-structure tasks; the LSTM controller adds flexibility (can store prior read vectors) but did not eliminate the benefits of the external memory.",
            "limitations_or_challenges": "Although combining LSTM controller and external memory helps, the architecture still inherits NTM limitations: memory size bounds generalisation, addressing errors can occur, and training complexity; in some tasks feedforward controllers learned faster, indicating controller choice interacts non-trivially with task and memory use.",
            "uuid": "e3175.1",
            "source_info": {
                "paper_title": "Neural Turing Machines",
                "publication_date_yy_mm": "2014-10"
            }
        },
        {
            "name_short": "Standard LSTM baseline",
            "name_full": "Long Short-Term Memory (stacked LSTM baseline)",
            "brief_description": "A standard recurrent neural network with LSTM cells (three stacked hidden LSTM layers in experiments) used as the baseline; it relies on internal recurrent state for memory rather than an external addressable memory matrix.",
            "citation_title": "",
            "mention_or_use": "use",
            "agent_name": "Standard LSTM (stacked 3-layer baseline)",
            "agent_description": "Three stacked LSTM layers (internal gated recurrent memory/cells) with logistic sigmoid output predicting targets; trained with RMSProp on same supervised tasks as NTMs. No external addressable memory matrix; memory is internal to recurrent state.",
            "memory_used": false,
            "memory_type": "internal recurrent memory (LSTM hidden/cell state)",
            "memory_mechanism_description": "Uses gated recurrent cells (LSTM) to selectively integrate inputs over time, providing persistent internal state (cell vectors) that acts as working memory; lacks explicit external read/write addressing mechanisms.",
            "task_name": "Copy; Repeat Copy; Associative Recall; Dynamic N-Grams; Priority Sort",
            "task_description": "Same set of algorithmic sequence tasks used to compare capacity for long-term storage, indirection, rapid adaptation, and sorting, testing LSTM's ability to learn and generalise these algorithms using internal recurrent memory alone.",
            "task_type": "algorithmic sequence manipulation / memory-augmented tasks",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_performance_comparison": true,
            "key_findings": "Standard LSTM baseline often learned more slowly, converged to higher cost, and generalised poorly compared to NTMs: e.g., on Copy trained up to length 20, LSTM rapidly degrades beyond 20 while NTM generalises to much longer lengths; on Associative Recall LSTM failed to reach near-zero cost after 1,000,000 episodes whereas NTM reached near zero by ≈30,000 episodes; on Repeat Copy LSTM solved the task but generalised poorly in sequence length and repetitions; on Dynamic N-Grams LSTM performed worse than NTM (NTM had a small but significant advantage).",
            "limitations_or_challenges": "Internal recurrent memory scales poorly for long sequences and complex data-structure operations: poor generalisation to sequence lengths beyond training range, slower learning on many algorithmic tasks, and inability to implement explicit addressable indirection or large random-access memory without greatly increasing network size.",
            "uuid": "e3175.2",
            "source_info": {
                "paper_title": "Neural Turing Machines",
                "publication_date_yy_mm": "2014-10"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Long Short-Term Memory",
            "rating": 2
        },
        {
            "paper_title": "Differentiable Neural Computers and Neural Turing Machines (follow-up literature)",
            "rating": 1
        },
        {
            "paper_title": "Learning to Transduce with Unbounded Memory (Hochreiter et al. / related program search literature)",
            "rating": 1
        },
        {
            "paper_title": "A Neural Probabilistic Language Model (context on early memory and modelling)",
            "rating": 1
        },
        {
            "paper_title": "Neural Machine Translation by Jointly Learning to Align and Translate",
            "rating": 1
        }
    ],
    "cost": 0.01073175,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Neural Turing Machines</h1>
<p>Alex Graves gravesa@google.com<br>Greg Wayne gregwayne@google.com<br>Ivo Danihelka danihelka@google.com<br>Google DeepMind, London, UK</p>
<h4>Abstract</h4>
<p>We extend the capabilities of neural networks by coupling them to external memory resources, which they can interact with by attentional processes. The combined system is analogous to a Turing Machine or Von Neumann architecture but is differentiable end-toend, allowing it to be efficiently trained with gradient descent. Preliminary results demonstrate that Neural Turing Machines can infer simple algorithms such as copying, sorting, and associative recall from input and output examples.</p>
<h2>1 Introduction</h2>
<p>Computer programs make use of three fundamental mechanisms: elementary operations (e.g., arithmetic operations), logical flow control (branching), and external memory, which can be written to and read from in the course of computation (Von Neumann, 1945). Despite its wide-ranging success in modelling complicated data, modern machine learning has largely neglected the use of logical flow control and external memory.</p>
<p>Recurrent neural networks (RNNs) stand out from other machine learning methods for their ability to learn and carry out complicated transformations of data over extended periods of time. Moreover, it is known that RNNs are Turing-Complete (Siegelmann and Sontag, 1995), and therefore have the capacity to simulate arbitrary procedures, if properly wired. Yet what is possible in principle is not always what is simple in practice. We therefore enrich the capabilities of standard recurrent networks to simplify the solution of algorithmic tasks. This enrichment is primarily via a large, addressable memory, so, by analogy to Turing's enrichment of finite-state machines by an infinite memory tape, we</p>
<p>dub our device a "Neural Turing Machine" (NTM). Unlike a Turing machine, an NTM is a differentiable computer that can be trained by gradient descent, yielding a practical mechanism for learning programs.</p>
<p>In human cognition, the process that shares the most similarity to algorithmic operation is known as "working memory." While the mechanisms of working memory remain somewhat obscure at the level of neurophysiology, the verbal definition is understood to mean a capacity for short-term storage of information and its rule-based manipulation (Baddeley et al., 2009). In computational terms, these rules are simple programs, and the stored information constitutes the arguments of these programs. Therefore, an NTM resembles a working memory system, as it is designed to solve tasks that require the application of approximate rules to "rapidly-created variables." Rapidly-created variables (Hadley, 2009) are data that are quickly bound to memory slots, in the same way that the number 3 and the number 4 are put inside registers in a conventional computer and added to make 7 (Minsky, 1967). An NTM bears another close resemblance to models of working memory since the NTM architecture uses an attentional process to read from and write to memory selectively. In contrast to most models of working memory, our architecture can learn to use its working memory instead of deploying a fixed set of procedures over symbolic data.</p>
<p>The organisation of this report begins with a brief review of germane research on working memory in psychology, linguistics, and neuroscience, along with related research in artificial intelligence and neural networks. We then describe our basic contribution, a memory architecture and attentional controller that we believe is well-suited to the performance of tasks that require the induction and execution of simple programs. To test this architecture, we have constructed a battery of problems, and we present their precise descriptions along with our results. We conclude by summarising the strengths of the architecture.</p>
<h1>2 Foundational Research</h1>
<h3>2.1 Psychology and Neuroscience</h3>
<p>The concept of working memory has been most heavily developed in psychology to explain the performance of tasks involving the short-term manipulation of information. The broad picture is that a "central executive" focuses attention and performs operations on data in a memory buffer (Baddeley et al., 2009). Psychologists have extensively studied the capacity limitations of working memory, which is often quantified by the number of "chunks" of information that can be readily recalled (Miller, 1956). ${ }^{1}$ These capacity limitations lead toward an understanding of structural constraints in the human working memory system, but in our own work we are happy to exceed them.</p>
<p>In neuroscience, the working memory process has been ascribed to the functioning of a system composed of the prefrontal cortex and basal ganglia (Goldman-Rakic, 1995). Typ-</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>ical experiments involve recording from a single neuron or group of neurons in prefrontal cortex while a monkey is performing a task that involves observing a transient cue, waiting through a "delay period," then responding in a manner dependent on the cue. Certain tasks elicit persistent firing from individual neurons during the delay period or more complicated neural dynamics. A recent study quantified delay period activity in prefrontal cortex for a complex, context-dependent task based on measures of "dimensionality" of the population code and showed that it predicted memory performance (Rigotti et al., 2013).</p>
<p>Modeling studies of working memory range from those that consider how biophysical circuits could implement persistent neuronal firing (Wang, 1999) to those that try to solve explicit tasks (Hazy et al., 2006) (Dayan, 2008) (Eliasmith, 2013). Of these, Hazy et al.'s model is the most relevant to our work, as it is itself analogous to the Long Short-Term Memory architecture, which we have modified ourselves. As in our architecture, Hazy et al.'s has mechanisms to gate information into memory slots, which they use to solve a memory task constructed of nested rules. In contrast to our work, the authors include no sophisticated notion of memory addressing, which limits the system to storage and recall of relatively simple, atomic data. Addressing, fundamental to our work, is usually left out from computational models in neuroscience, though it deserves to be mentioned that Gallistel and King (Gallistel and King, 2009) and Marcus (Marcus, 2003) have argued that addressing must be implicated in the operation of the brain.</p>
<h1>2.2 Cognitive Science and Linguistics</h1>
<p>Historically, cognitive science and linguistics emerged as fields at roughly the same time as artificial intelligence, all deeply influenced by the advent of the computer (Chomsky, 1956) (Miller, 2003). Their intentions were to explain human mental behaviour based on information or symbol-processing metaphors. In the early 1980s, both fields considered recursive or procedural (rule-based) symbol-processing to be the highest mark of cognition. The Parallel Distributed Processing (PDP) or connectionist revolution cast aside the symbol-processing metaphor in favour of a so-called "sub-symbolic" description of thought processes (Rumelhart et al., 1986).</p>
<p>Fodor and Pylyshyn (Fodor and Pylyshyn, 1988) famously made two barbed claims about the limitations of neural networks for cognitive modeling. They first objected that connectionist theories were incapable of variable-binding, or the assignment of a particular datum to a particular slot in a data structure. In language, variable-binding is ubiquitous; for example, when one produces or interprets a sentence of the form, "Mary spoke to John," one has assigned "Mary" the role of subject, "John" the role of object, and "spoke to" the role of the transitive verb. Fodor and Pylyshyn also argued that neural networks with fixedlength input domains could not reproduce human capabilities in tasks that involve processing variable-length structures. In response to this criticism, neural network researchers including Hinton (Hinton, 1986), Smolensky (Smolensky, 1990), Touretzky (Touretzky, 1990), Pollack (Pollack, 1990), Plate (Plate, 2003), and Kanerva (Kanerva, 2009) investigated specific mechanisms that could support both variable-binding and variable-length</p>
<p>structure within a connectionist framework. Our architecture draws on and potentiates this work.</p>
<p>Recursive processing of variable-length structures continues to be regarded as a hallmark of human cognition. In the last decade, a firefight in the linguistics community staked several leaders of the field against one another. At issue was whether recursive processing is the "uniquely human" evolutionary innovation that enables language and is specialized to language, a view supported by Fitch, Hauser, and Chomsky (Fitch et al., 2005), or whether multiple new adaptations are responsible for human language evolution and recursive processing predates language (Jackendoff and Pinker, 2005). Regardless of recursive processing's evolutionary origins, all agreed that it is essential to human cognitive flexibility.</p>
<h1>2.3 Recurrent Neural Networks</h1>
<p>Recurrent neural networks constitute a broad class of machines with dynamic state; that is, they have state whose evolution depends both on the input to the system and on the current state. In comparison to hidden Markov models, which also contain dynamic state, RNNs have a distributed state and therefore have significantly larger and richer memory and computational capacity. Dynamic state is crucial because it affords the possibility of context-dependent computation; a signal entering at a given moment can alter the behaviour of the network at a much later moment.</p>
<p>A crucial innovation to recurrent networks was the Long Short-Term Memory (LSTM) (Hochreiter and Schmidhuber, 1997). This very general architecture was developed for a specific purpose, to address the "vanishing and exploding gradient" problem (Hochreiter et al., 2001a), which we might relabel the problem of "vanishing and exploding sensitivity." LSTM ameliorates the problem by embedding perfect integrators (Seung, 1998) for memory storage in the network. The simplest example of a perfect integrator is the equation $\mathbf{x}(t+1)=\mathbf{x}(t)+\mathbf{i}(t)$, where $\mathbf{i}(t)$ is an input to the system. The implicit identity matrix $I \mathbf{x}(t)$ means that signals do not dynamically vanish or explode. If we attach a mechanism to this integrator that allows an enclosing network to choose when the integrator listens to inputs, namely, a programmable gate depending on context, we have an equation of the form $\mathbf{x}(t+1)=\mathbf{x}(t)+g($ context $) \mathbf{i}(t)$. We can now selectively store information for an indefinite length of time.</p>
<p>Recurrent networks readily process variable-length structures without modification. In sequential problems, inputs to the network arrive at different times, allowing variablelength or composite structures to be processed over multiple steps. Because they natively handle variable-length structures, they have recently been used in a variety of cognitive problems, including speech recognition (Graves et al., 2013; Graves and Jaitly, 2014), text generation (Sutskever et al., 2011), handwriting generation (Graves, 2013) and machine translation (Sutskever et al., 2014). Considering this property, we do not feel that it is urgent or even necessarily valuable to build explicit parse trees to merge composite structures greedily (Pollack, 1990) (Socher et al., 2012) (Frasconi et al., 1998).</p>
<p>Other important precursors to our work include differentiable models of attention (Graves,</p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Neural Turing Machine Architecture. During each update cycle, the controller network receives inputs from an external environment and emits outputs in response. It also reads to and writes from a memory matrix via a set of parallel read and write heads. The dashed line indicates the division between the NTM circuit and the outside world.
2013) (Bahdanau et al., 2014) and program search (Hochreiter et al., 2001b) (Das et al., 1992), constructed with recurrent neural networks.</p>
<h1>3 Neural Turing Machines</h1>
<p>A Neural Turing Machine (NTM) architecture contains two basic components: a neural network controller and a memory bank. Figure 1 presents a high-level diagram of the NTM architecture. Like most neural networks, the controller interacts with the external world via input and output vectors. Unlike a standard network, it also interacts with a memory matrix using selective read and write operations. By analogy to the Turing machine we refer to the network outputs that parametrise these operations as "heads."</p>
<p>Crucially, every component of the architecture is differentiable, making it straightforward to train with gradient descent. We achieved this by defining 'blurry' read and write operations that interact to a greater or lesser degree with all the elements in memory (rather than addressing a single element, as in a normal Turing machine or digital computer). The degree of blurriness is determined by an attentional "focus" mechanism that constrains each read and write operation to interact with a small portion of the memory, while ignoring the rest. Because interaction with the memory is highly sparse, the NTM is biased towards storing data without interference. The memory location brought into attentional focus is determined by specialised outputs emitted by the heads. These outputs define a normalised weighting over the rows in the memory matrix (referred to as memory "locations"). Each weighting, one per read or write head, defines the degree to which the head reads or writes</p>
<p>at each location. A head can thereby attend sharply to the memory at a single location or weakly to the memory at many locations.</p>
<h1>3.1 Reading</h1>
<p>Let $\mathbf{M}<em t="t">{t}$ be the contents of the $N \times M$ memory matrix at time t , where $N$ is the number of memory locations, and $M$ is the vector size at each location. Let $\mathbf{w}</em>$ obey the following constraints:}$ be a vector of weightings over the $N$ locations emitted by a read head at time $t$. Since all weightings are normalised, the $N$ elements $w_{t}(i)$ of $\mathbf{w}_{t</p>
<p>$$
\sum_{i} w_{t}(i)=1, \quad 0 \leq w_{t}(i) \leq 1, \forall i
$$</p>
<p>The length $M$ read vector $\mathbf{r}<em t="t">{t}$ returned by the head is defined as a convex combination of the row-vectors $\mathbf{M}</em>(i)$ in memory:</p>
<p>$$
\mathbf{r}<em i="i">{t} \longleftarrow \sum</em>(i)
$$} w_{t}(i) \mathbf{M}_{t</p>
<p>which is clearly differentiable with respect to both the memory and the weighting.</p>
<h3>3.2 Writing</h3>
<p>Taking inspiration from the input and forget gates in LSTM, we decompose each write into two parts: an erase followed by an add.</p>
<p>Given a weighting $\mathbf{w}<em t="t">{t}$ emitted by a write head at time $t$, along with an erase vector $\mathbf{e}</em>(i)$ from the previous time-step are modified as follows:}$ whose $M$ elements all lie in the range $(0,1)$, the memory vectors $\mathbf{M}_{t-1</p>
<p>$$
\tilde{\mathbf{M}}<em t-1="t-1">{t}(i) \longleftarrow \mathbf{M}</em>\right]
$$}(i)\left[\mathbf{1}-w_{t}(i) \mathbf{e}_{t</p>
<p>where $\mathbf{1}$ is a row-vector of all 1 -s, and the multiplication against the memory location acts point-wise. Therefore, the elements of a memory location are reset to zero only if both the weighting at the location and the erase element are one; if either the weighting or the erase is zero, the memory is left unchanged. When multiple write heads are present, the erasures can be performed in any order, as multiplication is commutative.</p>
<p>Each write head also produces a length $M$ add vector $\mathbf{a}_{t}$, which is added to the memory after the erase step has been performed:</p>
<p>$$
\mathbf{M}<em t="t">{t}(i) \longleftarrow \tilde{\mathbf{M}}</em>
$$}(i)+w_{t}(i) \mathbf{a}_{t</p>
<p>Once again, the order in which the adds are performed by multiple heads is irrelevant. The combined erase and add operations of all the write heads produces the final content of the memory at time $t$. Since both erase and add are differentiable, the composite write operation is differentiable too. Note that both the erase and add vectors have $M$ independent components, allowing fine-grained control over which elements in each memory location are modified.</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: Flow Diagram of the Addressing Mechanism. The key vector, $\mathbf{k}<em t="t">{t}$, and key strength, $\beta</em>}$, are used to perform content-based addressing of the memory matrix, $\mathbf{M<em t="t">{t}$. The resulting content-based weighting is interpolated with the weighting from the previous time step based on the value of the interpolation gate, $g</em>}$. The shift weighting, $\mathbf{s<em t="t">{t}$, determines whether and by how much the weighting is rotated. Finally, depending on $\gamma</em>$, the weighting is sharpened and used for memory access.</p>
<h1>3.3 Addressing Mechanisms</h1>
<p>Although we have now shown the equations of reading and writing, we have not described how the weightings are produced. These weightings arise by combining two addressing mechanisms with complementary facilities. The first mechanism, "content-based addressing," focuses attention on locations based on the similarity between their current values and values emitted by the controller. This is related to the content-addressing of Hopfield networks (Hopfield, 1982). The advantage of content-based addressing is that retrieval is simple, merely requiring the controller to produce an approximation to a part of the stored data, which is then compared to memory to yield the exact stored value.</p>
<p>However, not all problems are well-suited to content-based addressing. In certain tasks the content of a variable is arbitrary, but the variable still needs a recognisable name or address. Arithmetic problems fall into this category: the variable $x$ and the variable $y$ can take on any two values, but the procedure $f(x, y)=x \times y$ should still be defined. A controller for this task could take the values of the variables $x$ and $y$, store them in different addresses, then retrieve them and perform a multiplication algorithm. In this case, the variables are addressed by location, not by content. We call this form of addressing "location-based addressing." Content-based addressing is strictly more general than location-based addressing as the content of a memory location could include location information inside it. In our experiments however, providing location-based addressing as a primitive operation proved essential for some forms of generalisation, so we employ both mechanisms concurrently.</p>
<p>Figure 2 presents a flow diagram of the entire addressing system that shows the order of operations for constructing a weighting vector when reading or writing.</p>
<h1>3.3.1 Focusing by Content</h1>
<p>For content-addressing, each head (whether employed for reading or writing) first produces a length $M$ key vector $\mathbf{k}<em t="t">{t}$ that is compared to each vector $\mathbf{M}</em>$, which can amplify or attenuate the precision of the focus:}(i)$ by a similarity measure $K[\cdot, \cdot]$. The content-based system produces a normalised weighting $w_{t}^{c}$ based on the similarity and a positive key strength, $\beta_{t</p>
<p>$$
w_{t}^{c}(i) \longleftarrow \frac{\exp \left(\beta_{t} K\left[\mathbf{k}<em t="t">{t}, \mathbf{M}</em>}(i)\right]\right)}{\sum_{j} \exp \left(\beta_{t} K\left[\mathbf{k<em t="t">{t}, \mathbf{M}</em>
$$}(j)\right]\right)</p>
<p>In our current implementation, the similarity measure is cosine similarity:</p>
<p>$$
K[\mathbf{u}, \mathbf{v}]=\frac{\mathbf{u} \cdot \mathbf{v}}{|\mathbf{u}| \cdot|\mathbf{v}|}
$$</p>
<h3>3.3.2 Focusing by Location</h3>
<p>The location-based addressing mechanism is designed to facilitate both simple iteration across the locations of the memory and random-access jumps. It does so by implementing a rotational shift of a weighting. For example, if the current weighting focuses entirely on a single location, a rotation of 1 would shift the focus to the next location. A negative shift would move the weighting in the opposite direction.</p>
<p>Prior to rotation, each head emits a scalar interpolation gate $g_{t}$ in the range $(0,1)$. The value of $g$ is used to blend between the weighting $\mathbf{w}<em t="t">{t-1}$ produced by the head at the previous time-step and the weighting $\mathbf{w}</em>$ :}^{c}$ produced by the content system at the current time-step, yielding the gated weighting $\mathbf{w}_{t}^{g</p>
<p>$$
\mathbf{w}<em t="t">{t}^{g} \longleftarrow g</em>} \mathbf{w<em t="t">{t}^{c}+\left(1-g</em>
$$}\right) \mathbf{w}_{t-1</p>
<p>If the gate is zero, then the content weighting is entirely ignored, and the weighting from the previous time step is used. Conversely, if the gate is one, the weighting from the previous iteration is ignored, and the system applies content-based addressing.</p>
<p>After interpolation, each head emits a shift weighting $\mathbf{s}<em t="t">{t}$ that defines a normalised distribution over the allowed integer shifts. For example, if shifts between -1 and 1 are allowed, $\mathbf{s}</em>$ is zero.}$ has three elements corresponding to the degree to which shifts of $-1,0$ and 1 are performed. The simplest way to define the shift weightings is to use a softmax layer of the appropriate size attached to the controller. We also experimented with another technique, where the controller emits a single scalar that is interpreted as the lower bound of a width one uniform distribution over shifts. For example, if the shift scalar is 6.7 , then $s_{t}(6)=0.3$, $s_{t}(7)=0.7$, and the rest of $\mathbf{s}_{t</p>
<p>If we index the $N$ memory locations from 0 to $N-1$, the rotation applied to $\mathbf{w}<em t="t">{t}^{g}$ by $\mathbf{s}</em>$ can be expressed as the following circular convolution:</p>
<p>$$
\tilde{w}<em j="0">{t}(i) \longleftarrow \sum</em>(i-j)
$$}^{N-1} w_{t}^{g}(j) s_{t</p>
<p>where all index arithmetic is computed modulo $N$. The convolution operation in Equation (8) can cause leakage or dispersion of weightings over time if the shift weighting is not sharp. For example, if shifts of $-1,0$ and 1 are given weights of $0.1,0.8$ and 0.1 , the rotation will transform a weighting focused at a single point into one slightly blurred over three points. To combat this, each head emits one further scalar $\gamma_{t} \geq 1$ whose effect is to sharpen the final weighting as follows:</p>
<p>$$
w_{t}(i) \longleftarrow \frac{\tilde{w}<em t="t">{t}(i)^{\gamma</em>}}}{\sum_{j} \tilde{w<em t="t">{t}(j)^{\gamma</em>
$$}}</p>
<p>The combined addressing system of weighting interpolation and content and locationbased addressing can operate in three complementary modes. One, a weighting can be chosen by the content system without any modification by the location system. Two, a weighting produced by the content addressing system can be chosen and then shifted. This allows the focus to jump to a location next to, but not on, an address accessed by content; in computational terms this allows a head to find a contiguous block of data, then access a particular element within that block. Three, a weighting from the previous time step can be rotated without any input from the content-based addressing system. This allows the weighting to iterate through a sequence of addresses by advancing the same distance at each time-step.</p>
<h1>3.4 Controller Network</h1>
<p>The NTM architecture architecture described above has several free parameters, including the size of the memory, the number of read and write heads, and the range of allowed location shifts. But perhaps the most significant architectural choice is the type of neural network used as the controller. In particular, one has to decide whether to use a recurrent or feedforward network. A recurrent controller such as LSTM has its own internal memory that can complement the larger memory in the matrix. If one compares the controller to the central processing unit in a digital computer (albeit with adaptive rather than predefined instructions) and the memory matrix to RAM, then the hidden activations of the recurrent controller are akin to the registers in the processor. They allow the controller to mix information across multiple time steps of operation. On the other hand a feedforward controller can mimic a recurrent network by reading and writing at the same location in memory at every step. Furthermore, feedforward controllers often confer greater transparency to the network's operation because the pattern of reading from and writing to the memory matrix is usually easier to interpret than the internal state of an RNN. However, one limitation of</p>
<p>a feedforward controller is that the number of concurrent read and write heads imposes a bottleneck on the type of computation the NTM can perform. With a single read head, it can perform only a unary transform on a single memory vector at each time-step, with two read heads it can perform binary vector transforms, and so on. Recurrent controllers can internally store read vectors from previous time-steps, so do not suffer from this limitation.</p>
<h1>4 Experiments</h1>
<p>This section presents preliminary experiments on a set of simple algorithmic tasks such as copying and sorting data sequences. The goal was not only to establish that NTM is able to solve the problems, but also that it is able to do so by learning compact internal programs. The hallmark of such solutions is that they generalise well beyond the range of the training data. For example, we were curious to see if a network that had been trained to copy sequences of length up to 20 could copy a sequence of length 100 with no further training.</p>
<p>For all the experiments we compared three architectures: NTM with a feedforward controller, NTM with an LSTM controller, and a standard LSTM network. Because all the tasks were episodic, we reset the dynamic state of the networks at the start of each input sequence. For the LSTM networks, this meant setting the previous hidden state equal to a learned bias vector. For NTM the previous state of the controller, the value of the previous read vectors, and the contents of the memory were all reset to bias values. All the tasks were supervised learning problems with binary targets; all networks had logistic sigmoid output layers and were trained with the cross-entropy objective function. Sequence prediction errors are reported in bits-per-sequence. For more details about the experimental parameters see Section 4.6.</p>
<h3>4.1 Copy</h3>
<p>The copy task tests whether NTM can store and recall a long sequence of arbitrary information. The network is presented with an input sequence of random binary vectors followed by a delimiter flag. Storage and access of information over long time periods has always been problematic for RNNs and other dynamic architectures. We were particularly interested to see if an NTM is able to bridge longer time delays than LSTM.</p>
<p>The networks were trained to copy sequences of eight bit random vectors, where the sequence lengths were randomised between 1 and 20. The target sequence was simply a copy of the input sequence (without the delimiter flag). Note that no inputs were presented to the network while it receives the targets, to ensure that it recalls the entire sequence with no intermediate assistance.</p>
<p>As can be seen from Figure 3, NTM (with either a feedforward or LSTM controller) learned much faster than LSTM alone, and converged to a lower cost. The disparity between the NTM and LSTM learning curves is dramatic enough to suggest a qualitative,</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: Copy Learning Curves.
rather than quantitative, difference in the way the two models solve the problem.
We also studied the ability of the networks to generalise to longer sequences than seen during training (that they can generalise to novel vectors is clear from the training error). Figures 4 and 5 demonstrate that the behaviour of LSTM and NTM in this regime is radically different. NTM continues to copy as the length increases ${ }^{2}$, while LSTM rapidly degrades beyond length 20 .</p>
<p>The preceding analysis suggests that NTM, unlike LSTM, has learned some form of copy algorithm. To determine what this algorithm is, we examined the interaction between the controller and the memory (Figure 6). We believe that the sequence of operations performed by the network can be summarised by the following pseudocode:
initialise: move head to start location
while input delimiter not seen do
receive input vector
write input to head location
increment head location by 1
end while
return head to start location
while true do
read output vector from head location
emit output
increment head location by 1
end while</p>
<p>This is essentially how a human programmer would perform the same task in a low-</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 4: NTM Generalisation on the Copy Task. The four pairs of plots in the top row depict network outputs and corresponding copy targets for test sequences of length 10, 20, 30, and 50, respectively. The plots in the bottom row are for a length 120 sequence. The network was only trained on sequences of up to length 20. The first four sequences are reproduced with high confidence and very few mistakes. The longest one has a few more local errors and one global error: at the point indicated by the red arrow at the bottom, a single vector is duplicated, pushing all subsequent vectors one step back. Despite being subjectively close to a correct copy, this leads to a high loss.
level programming language. In terms of data structures, we could say that NTM has learned how to create and iterate through arrays. Note that the algorithm combines both content-based addressing (to jump to start of the sequence) and location-based addressing (to move along the sequence). Also note that the iteration would not generalise to long sequences without the ability to use relative shifts from the previous read and write weightings (Equation 7), and that without the focus-sharpening mechanism (Equation 9) the weightings would probably lose precision over time.</p>
<h1>4.2 Repeat Copy</h1>
<p>The repeat copy task extends copy by requiring the network to output the copied sequence a specified number of times and then emit an end-of-sequence marker. The main motivation was to see if the NTM could learn a simple nested function. Ideally, we would like it to be able to execute a "for loop" containing any subroutine it has already learned.</p>
<p>The network receives random-length sequences of random binary vectors, followed by a scalar value indicating the desired number of copies, which appears on a separate input channel. To emit the end marker at the correct time the network must be both able to interpret the extra input and keep count of the number of copies it has performed so far. As with the copy task, no inputs are provided to the network after the initial sequence and repeat number. The networks were trained to reproduce sequences of size eight random binary vectors, where both the sequence length and the number of repetitions were chosen randomly from one to ten. The input representing the repeat number was normalised to have mean zero and variance one.</p>
<p><img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 5: LSTM Generalisation on the Copy Task. The plots show inputs and outputs for the same sequence lengths as Figure 4. Like NTM, LSTM learns to reproduce sequences of up to length 20 almost perfectly. However it clearly fails to generalise to longer sequences. Also note that the length of the accurate prefix decreases as the sequence length increases, suggesting that the network has trouble retaining information for long periods.
<img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>Figure 6: NTM Memory Use During the Copy Task. The plots in the left column depict the inputs to the network (top), the vectors added to memory (middle) and the corresponding write weightings (bottom) during a single test sequence for the copy task. The plots on the right show the outputs from the network (top), the vectors read from memory (middle) and the read weightings (bottom). Only a subset of memory locations are shown. Notice the sharp focus of all the weightings on a single location in memory (black is weight zero, white is weight one). Also note the translation of the focal point over time, reflects the network's use of iterative shifts for location-based addressing, as described in Section 3.3.2. Lastly, observe that the read locations exactly match the write locations, and the read vectors match the add vectors. This suggests that the network writes each input vector in turn to a specific memory location during the input phase, then reads from the same location sequence during the output phase.</p>
<p><img alt="img-6.jpeg" src="img-6.jpeg" /></p>
<p>Figure 7: Repeat Copy Learning Curves.</p>
<p>Figure 7 shows that NTM learns the task much faster than LSTM, but both were able to solve it perfectly. ${ }^{3}$ The difference between the two architectures only becomes clear when they are asked to generalise beyond the training data. In this case we were interested in generalisation along two dimensions: sequence length and number of repetitions. Figure 8 illustrates the effect of doubling first one, then the other, for both LSTM and NTM. Whereas LSTM fails both tests, NTM succeeds with longer sequences and is able to perform more than ten repetitions; however it is unable to keep count of of how many repeats it has completed, and does not predict the end marker correctly. This is probably a consequence of representing the number of repetitions numerically, which does not easily generalise beyond a fixed range.</p>
<p>Figure 9 suggests that NTM learns a simple extension of the copy algorithm in the previous section, where the sequential read is repeated as many times as necessary.</p>
<h1>4.3 Associative Recall</h1>
<p>The previous tasks show that the NTM can apply algorithms to relatively simple, linear data structures. The next order of complexity in organising data arises from "indirection"-that is, when one data item points to another. We test the NTM's capability for learning an instance of this more interesting class by constructing a list of items so that querying with one of the items demands that the network return the subsequent item. More specifically, we define an item as a sequence of binary vectors that is bounded on the left and right by delimiter symbols. After several items have been propagated to the network, we query by showing a random item, and we ask the network to produce the next item. In our experiments, each item consisted of three six-bit binary vectors (giving a total of 18 bits</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-7.jpeg" src="img-7.jpeg" /></p>
<p>Figure 8: NTM and LSTM Generalisation for the Repeat Copy Task. NTM generalises almost perfectly to longer sequences than seen during training. When the number of repeats is increased it is able to continue duplicating the input sequence fairly accurately; but it is unable to predict when the sequence will end, emitting the end marker after the end of every repetition beyond the eleventh. LSTM struggles with both increased length and number, rapidly diverging from the input sequence in both cases.
per item). During training, we used a minimum of 2 items and a maximum of 6 items in a single episode.</p>
<p>Figure 10 shows that NTM learns this task significantly faster than LSTM, terminating at near zero cost within approximately 30,000 episodes, whereas LSTM does not reach zero cost after a million episodes. Additionally, NTM with a feedforward controller learns faster than NTM with an LSTM controller. These two results suggest that NTM's external memory is a more effective way of maintaining the data structure than LSTM's internal state. NTM also generalises much better to longer sequences than LSTM, as can be seen in Figure 11. NTM with a feedforward controller is nearly perfect for sequences of up to 12 items (twice the maximum length used in training), and still has an average cost below 1 bit per sequence for sequences of 15 items.</p>
<p>In Figure 12, we show the operation of the NTM memory, controlled by an LSTM with one head, on a single test episode. In "Inputs," we see that the input denotes item delimiters as single bits in row 7. After the sequence of items has been propagated, a</p>
<p><img alt="img-8.jpeg" src="img-8.jpeg" /></p>
<p>Figure 9: NTM Memory Use During the Repeat Copy Task. As with the copy task the network first writes the input vectors to memory using iterative shifts. It then reads through the sequence to replicate the input as many times as necessary (six in this case). The white dot at the bottom of the read weightings seems to correspond to an intermediate location used to redirect the head to the start of the sequence (The NTM equivalent of a goto statement).
<img alt="img-9.jpeg" src="img-9.jpeg" /></p>
<p>Figure 10: Associative Recall Learning Curves for NTM and LSTM.</p>
<p><img alt="img-10.jpeg" src="img-10.jpeg" /></p>
<p>Figure 11: Generalisation Performance on Associative Recall for Longer Item Sequences. The NTM with either a feedforward or LSTM controller generalises to much longer sequences of items than the LSTM alone. In particular, the NTM with a feedforward controller is nearly perfect for item sequences of twice the length of sequences in its training set.
delimiter in row 8 prepares the network to receive a query item. In this case, the query item corresponds to the second item in the sequence (contained in the green box). In "Outputs," we see that the network crisply outputs item 3 in the sequence (from the red box). In "Read Weightings," on the last three time steps, we see that the controller reads from contiguous locations that each store the time slices of item 3. This is curious because it appears that the network has jumped directly to the correct location storing item 3. However we can explain this behaviour by looking at "Write Weightings." Here we see that the memory is written to even when the input presents a delimiter symbol between items. One can confirm in "Adds" that data are indeed written to memory when the delimiters are presented (e.g., the data within the black box); furthermore, each time a delimiter is presented, the vector added to memory is different. Further analysis of the memory reveals that the network accesses the location it reads after the query by using a content-based lookup that produces a weighting that is shifted by one. Additionally, the key used for content-lookup corresponds to the vector that was added in the black box. This implies the following memory-access algorithm: when each item delimiter is presented, the controller writes a compressed representation of the previous three time slices of the item. After the query arrives, the controller recomputes the same compressed representation of the query item, uses a content-based lookup to find the location where it wrote the first representation, and then shifts by one to produce the subsequent item in the sequence (thereby combining content-based lookup with location-based offsetting).</p>
<h1>4.4 Dynamic N-Grams</h1>
<p>The goal of the dynamic N-Grams task was to test whether NTM could rapidly adapt to new predictive distributions. In particular we were interested to see if it were able to use its</p>
<p><img alt="img-11.jpeg" src="img-11.jpeg" /></p>
<p>Figure 12: NTM Memory Use During the Associative Recall Task. In "Inputs," a sequence of items, each composed of three consecutive binary random vectors is propagated to the controller. The distinction between items is designated by delimiter symbols (row 7 in "Inputs"). After several items have been presented, a delimiter that designates a query is presented (row 8 in "Inputs"). A single query item is presented (green box), and the network target corresponds to the subsequent item in the sequence (red box). In "Outputs," we see that the network correctly produces the target item. The red boxes in the read and write weightings highlight the three locations where the target item was written and then read. The solution the network finds is to form a compressed representation (black box in "Adds") of each item that it can store in a single location. For further analysis, see the main text.
memory as a re-writable table that it could use to keep count of transition statistics, thereby emulating a conventional N-Gram model.</p>
<p>We considered the set of all possible 6-Gram distributions over binary sequences. Each 6-Gram distribution can be expressed as a table of $2^{5}=32$ numbers, specifying the probability that the next bit will be one, given all possible length five binary histories. For each training example, we first generated random 6-Gram probabilities by independently drawing all 32 probabilities from the $\operatorname{Beta}\left(\frac{1}{2}, \frac{1}{2}\right)$ distribution.</p>
<p>We then generated a particular training sequence by drawing 200 successive bits using the current lookup table. ${ }^{4}$ The network observes the sequence one bit at a time and is then asked to predict the next bit. The optimal estimator for the problem can be determined by</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-12.jpeg" src="img-12.jpeg" /></p>
<p>Figure 13: Dynamic N-Gram Learning Curves.</p>
<p>Bayesian analysis (Murphy, 2012):</p>
<p>$$
P\left(B=1 \mid N_{1}, N_{0}, \mathbf{c}\right)=\frac{N_{1}+\frac{1}{2}}{N_{1}+N_{0}+1}
$$</p>
<p>where $\mathbf{c}$ is the five bit previous context, $B$ is the value of the next bit and $N_{0}$ and $N_{1}$ are respectively the number of zeros and ones observed after $\mathbf{c}$ so far in the sequence. We can therefore compare NTM to the optimal predictor as well as LSTM. To assess performance we used a validation set of 1000 length 200 sequences sampled from the same distribution as the training data. As shown in Figure 13, NTM achieves a small, but significant performance advantage over LSTM, but never quite reaches the optimum cost.</p>
<p>The evolution of the two architecture's predictions as they observe new inputs is shown in Figure 14, along with the optimal predictions. Close analysis of NTM's memory usage (Figure 15) suggests that the controller uses the memory to count how many ones and zeros it has observed in different contexts, allowing it to implement an algorithm similar to the optimal estimator.</p>
<h1>4.5 Priority Sort</h1>
<p>This task tests whether the NTM can sort data-an important elementary algorithm. A sequence of random binary vectors is input to the network along with a scalar priority rating for each vector. The priority is drawn uniformly from the range $[-1,1]$. The target sequence contains the binary vectors sorted according to their priorities, as depicted in Figure 16.</p>
<p>Each input sequence contained 20 binary vectors with corresponding priorities, and each target sequence was the 16 highest-priority vectors in the input. ${ }^{5}$ Inspection of NTM's</p>
<p><sup id="fnref5:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-13.jpeg" src="img-13.jpeg" /></p>
<p>Figure 14: Dynamic N-Gram Inference. The top row shows a test sequence from the N-Gram task, and the rows below show the corresponding predictive distributions emitted by the optimal estimator, NTM, and LSTM. In most places the NTM predictions are almost indistinguishable from the optimal ones. However at the points indicated by the two arrows it makes clear mistakes, one of which is explained in Figure 15. LSTM follows the optimal predictions closely in some places but appears to diverge further as the sequence progresses; we speculate that this is due to LSTM "forgetting" the observations at the start of the sequence.
<img alt="img-14.jpeg" src="img-14.jpeg" /></p>
<p>Figure 15: NTM Memory Use During the Dynamic N-Gram Task. The red and green arrows indicate point where the same context is repeatedly observed during the test sequence ("00010" for the green arrows, "01111" for the red arrows). At each such point the same location is accessed by the read head, and then, on the next time-step, accessed by the write head. We postulate that the network uses the writes to keep count of the fraction of ones and zeros following each context in the sequence so far. This is supported by the add vectors, which are clearly anti-correlated at places where the input is one or zero, suggesting a distributed "counter." Note that the write weightings grow fainter as the same context is repeatedly seen; this may be because the memory records a ratio of ones to zeros, rather than absolute counts. The red box in the prediction sequence corresponds to the mistake at the first red arrow in Figure 14; the controller appears to have accessed the wrong memory location, as the previous context was "01101" and not "01111."</p>
<p><img alt="img-15.jpeg" src="img-15.jpeg" /></p>
<p>Figure 16: Example Input and Target Sequence for the Priority Sort Task. The input sequence contains random binary vectors and random scalar priorities. The target sequence is a subset of the input vectors sorted by the priorities.</p>
<p><img alt="img-16.jpeg" src="img-16.jpeg" /></p>
<p>Figure 17: NTM Memory Use During the Priority Sort Task. Left: Write locations returned by fitting a linear function of the priorities to the observed write locations. Middle: Observed write locations. Right: Read locations.
memory use led us to hypothesise that it uses the priorities to determine the relative location of each write. To test this hypothesis we fitted a linear function of the priority to the observed write locations. Figure 17 shows that the locations returned by the linear function closely match the observed write locations. It also shows that the network reads from the memory locations in increasing order, thereby traversing the sorted sequence.</p>
<p>The learning curves in Figure 18 demonstrate that NTM with both feedforward and LSTM controllers substantially outperform LSTM on this task. Note that eight parallel read and write heads were needed for best performance with a feedforward controller on this task; this may reflect the difficulty of sorting vectors using only unary vector operations (see Section 3.4).</p>
<h1>4.6 Experimental Details</h1>
<p>For all experiments, the RMSProp algorithm was used for training in the form described in (Graves, 2013) with momentum of 0.9 . Tables 1 to 3 give details about the network configurations and learning rates used in the experiments. All LSTM networks had three stacked hidden layers. Note that the number of LSTM parameters grows quadratically with</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{5}$ We limited the sort to size 16 because we were interested to see if NTM would solve the task using a binary heap sort of depth 4 .&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref5:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>