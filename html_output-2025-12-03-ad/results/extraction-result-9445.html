<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-9445 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-9445</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-9445</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-163.html">extraction-schema-163</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how different problem or prompt presentation formats affect the performance of large language models (LLMs) on tasks, including details about the formats, tasks, models, performance metrics, comparisons, and any explanations or findings.</div>
                <p><strong>Paper ID:</strong> paper-85e7d63f75c0916bd350a229e040c5fbb1472e7a</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/85e7d63f75c0916bd350a229e040c5fbb1472e7a" target="_blank">Making Pre-trained Language Models Better Few-shot Learners</a></p>
                <p><strong>Paper Venue:</strong> Annual Meeting of the Association for Computational Linguistics</p>
                <p><strong>Paper TL;DR:</strong> The LM-BFF approach makes minimal assumptions on task resources and domain expertise, and hence constitutes a strong task-agnostic method for few-shot learning.</p>
                <p><strong>Paper Abstract:</strong> The recent GPT-3 model (Brown et al., 2020) achieves remarkable few-shot performance solely by leveraging a natural-language prompt and a few task demonstrations as input context. Inspired by their findings, we study few-shot learning in a more practical scenario, where we use smaller language models for which fine-tuning is computationally efficient. We present LM-BFF—better few-shot fine-tuning of language models—a suite of simple and complementary techniques for fine-tuning language models on a small number of annotated examples. Our approach includes (1) prompt-based fine-tuning together with a novel pipeline for automating prompt generation; and (2) a refined strategy for dynamically and selectively incorporating demonstrations into each context. Finally, we present a systematic evaluation for analyzing few-shot performance on a range of NLP tasks, including classification and regression. Our experiments demonstrate that our methods combine to dramatically outperform standard fine-tuning procedures in this low resource setting, achieving up to 30% absolute improvement, and 11% on average across all tasks. Our approach makes minimal assumptions on task resources and domain expertise, and hence constitutes a strong task-agnostic method for few-shot learning.</p>
                <p><strong>Cost:</strong> 0.019</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e9445.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e9445.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how different problem or prompt presentation formats affect the performance of large language models (LLMs) on tasks, including details about the formats, tasks, models, performance metrics, comparisons, and any explanations or findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>LM-BFF (prompt-based fine-tuning)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>LM-BFF: Better Few-shot Fine-tuning of Language Models (prompt-based fine-tuning with demonstrations and automatic prompt search)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A prompt-based fine-tuning paradigm that converts downstream tasks into masked-language modeling problems (fill-in-the-blank), re-uses pre-trained MLM output vectors as verbalizers, and fine-tunes the LM on a few labeled examples; combined with automated prompt search and selective demonstrations.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>RoBERTa-large (primary experiments)</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Multiple sentence-classification and regression tasks (e.g., SST-2, SNLI, MNLI, MNLI-mm, QNLI, RTE, MRPC, QQP, TREC, CoLA, STS-B, etc.)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Binary and multi-class sentence and sentence-pair classification tasks and one regression task (STS-B), evaluated in a K-shot few-shot setting.</td>
                        </tr>
                        <tr>
                            <td><strong>presentation_format</strong></td>
                            <td>Prompt-based fine-tuning: transform input into a template containing one [MASK] token; map classes to label words (verbalizer) and fine-tune the LM to predict the verbalizer word at the [MASK]. Optionally include demonstrations (concatenated masked examples) sampled per input.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_format</strong></td>
                            <td>Standard fine-tuning with a randomly initialized classification head (softmax on [CLS]); also compared to prompt-based zero-shot (no fine-tuning) and GPT-3 style in-context learning (concatenate up to 32 randomly sampled demonstrations).</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>Example: SST-2 (K=16 per class): prompt-based FT (manual) accuracy 92.7 (std 0.9); SNLI: prompt-based FT (manual) accuracy 77.2 (3.7). Results reported as mean (std) over 5 data splits.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_comparison</strong></td>
                            <td>Example comparisons (K=16): SST-2 standard fine-tuning accuracy 81.4 (3.8) vs prompt-based FT 92.7 (0.9) (+11.3% absolute). SNLI standard fine-tuning 48.4 (4.8) vs prompt-based FT 77.2 (3.7) (+28.8% absolute). Paper reports up to +30% absolute and +11% average improvement across tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>format_effect_size</strong></td>
                            <td>+11% average across tasks; up to +30% absolute on SNLI (prompt-based FT vs standard fine-tuning) as reported.</td>
                        </tr>
                        <tr>
                            <td><strong>explanation_or_hypothesis</strong></td>
                            <td>Prompt-based fine-tuning reduces the gap between pre-training and fine-tuning by re-using pre-trained MLM output vectors (no new task head parameters), making the learning objective closer to pre-training; this is particularly effective in extreme few-shot regimes where adding randomly initialized classifier parameters is hard to learn.</td>
                        </tr>
                        <tr>
                            <td><strong>null_or_negative_result</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>experimental_details</strong></td>
                            <td>Main setup: RoBERTa-large, K=16 examples per class (K_tot = K * |Y|), average over 5 random train/dev splits; hyperparameter grid search per split; templates and label words either manual or generated; demonstrations: sample 16 demonstration sets per input at inference and average predicted log-probs.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Making Pre-trained Language Models Better Few-shot Learners', 'publication_date_yy_mm': '2021-01'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e9445.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e9445.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how different problem or prompt presentation formats affect the performance of large language models (LLMs) on tasks, including details about the formats, tasks, models, performance metrics, comparisons, and any explanations or findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Prompt-based zero-shot vs majority baseline / in-context</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Prompt-based zero-shot prediction and in-context demonstration concatenation (GPT-3 style) evaluated with RoBERTa-large</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Evaluates (1) using manual prompt templates with no fine-tuning (zero-shot prompt evaluation) and (2) concatenating randomly sampled demonstrations (up to 32) a la GPT-3, applied to RoBERTa-large as baselines.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Language models are few-shot learners</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>RoBERTa-large (used to emulate GPT-3 in-context by concatenation of demonstrations)</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Same suite of classification/regression tasks (see main experiments)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Prompt-based zero-shot: feed template with [MASK] to LM and read verbalizer probability without weight updates. GPT-3 style in-context: augment template with 32 randomly sampled demonstrations concatenated in-context and no fine-tuning.</td>
                        </tr>
                        <tr>
                            <td><strong>presentation_format</strong></td>
                            <td>Zero-shot prompt-based (manual templates) and GPT-3-style in-context learning (random concatenation of up to 32 demonstrations into the input context).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_format</strong></td>
                            <td>Compared to prompt-based fine-tuning and to majority-class baseline.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>Example zero-shot: SST-2 zero-shot prompt accuracy 83.6; 'GPT-3' in-context (RoBERTa-large with 32 random demos) SST-2 84.8 (1.3). Zero-shot often far above majority baseline (e.g., SST-2 majority 50.9).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_comparison</strong></td>
                            <td>Zero-shot prompt-based (SST-2 83.6) vs majority (50.9); 'GPT-3' in-context sometimes gives small improvements over zero-shot for some tasks but is inconsistent across tasks (e.g., SNLI zero-shot 49.5 vs in-context 47.1).</td>
                        </tr>
                        <tr>
                            <td><strong>format_effect_size</strong></td>
                            <td>Varies by task; e.g., SST-2 +1.2% (in-context vs zero-shot), but in other tasks in-context can be worse (SNLI -2.4% in this setup). No consistent large gain for smaller LMs.</td>
                        </tr>
                        <tr>
                            <td><strong>explanation_or_hypothesis</strong></td>
                            <td>Smaller language models (e.g., RoBERTa-large) are not as capable as GPT-3 to exploit raw in-context demonstrations without parameter updates; concatenating many random demonstrations can produce long, noisy contexts that smaller models struggle to use effectively.</td>
                        </tr>
                        <tr>
                            <td><strong>null_or_negative_result</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>experimental_details</strong></td>
                            <td>In-context experiments used RoBERTa-large, concatenating up to 32 randomly sampled demonstrations (no parameter updates). Evaluations report mean and std across splits when applicable.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Making Pre-trained Language Models Better Few-shot Learners', 'publication_date_yy_mm': '2021-01'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e9445.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e9445.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how different problem or prompt presentation formats affect the performance of large language models (LLMs) on tasks, including details about the formats, tasks, models, performance metrics, comparisons, and any explanations or findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Manual prompt sensitivity</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Sensitivity of LM performance to manual template wording and label-word choices</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Empirical study showing that small changes in template phrasing, [MASK] position, sentence order, and the particular choice/order of label words can cause large swings in few-shot accuracy.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>RoBERTa-large</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>SST-2 (binary sentiment), SNLI (3-way NLI) (pilot analysis)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Evaluate how swapping label words (verbalizers) and changing template placement affects classification accuracy in K-shot fine-tuning.</td>
                        </tr>
                        <tr>
                            <td><strong>presentation_format</strong></td>
                            <td>Different manual templates and different label-word mappings (e.g., SST-2 templates 'It was [MASK].' with label pairs {great/terrible, good/bad, cat/dog, dog/cat, terrible/great}); for SNLI variants of template placement and mask location and sentence order.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_format</strong></td>
                            <td>Multiple alternative templates and label-word mappings tested against each other and against standard fine-tuning.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>SST-2 (K=16): 'great/terrible' 92.7 (0.9); 'good/bad' 92.5 (1.0); 'cat/dog' 91.5 (1.4); 'dog/cat' 86.2 (5.4); 'terrible/great' 83.2 (6.9); fine-tuning baseline 81.4 (3.8). SNLI templates where mask placed at end or swapped sentence order caused >10% drops relative to best template.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_comparison</strong></td>
                            <td>Choice of label words and template placement produced differences up to ~9–10+ percentage points (and in some swaps produced very large drops compared to best prompt), and substantial increases over standard fine-tuning.</td>
                        </tr>
                        <tr>
                            <td><strong>format_effect_size</strong></td>
                            <td>SST-2 example: best manual verbalizer vs worst verbalizer observed ~92.7 - 83.2 = +9.5% absolute; SNLI template changes could cause >10% drops.</td>
                        </tr>
                        <tr>
                            <td><strong>explanation_or_hypothesis</strong></td>
                            <td>Performance depends on semantic alignment between verbalizer tokens and label semantics and on making the MLM task resemble natural text the model saw during pretraining; small mismatches (e.g., swapping polarity order) can push the model away from learned priors and degrade predictions.</td>
                        </tr>
                        <tr>
                            <td><strong>null_or_negative_result</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>experimental_details</strong></td>
                            <td>Pilot experiments with K=16 per class, RoBERTa-large; results averaged over 5 splits; table enumerates multiple template/label-word choices and reports accuracy mean (std).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Making Pre-trained Language Models Better Few-shot Learners', 'publication_date_yy_mm': '2021-01'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e9445.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e9445.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how different problem or prompt presentation formats affect the performance of large language models (LLMs) on tasks, including details about the formats, tasks, models, performance metrics, comparisons, and any explanations or findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Automatic prompt generation (Auto T / Auto L)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Automatic template generation using T5 (Auto T) and automatic label-word selection via pruned brute-force search (Auto L)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Automated methods: Auto T uses a pre-trained T5 model to generate templates from a few labeled examples (decoded with wide beam search) and then fine-tunes/evaluates candidate templates; Auto L constructs per-class candidate verbalizers by ranking vocabulary words by conditional likelihood under the LM and pruned brute-force / reranking.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>RoBERTa-large (LM used for fine-tuning); T5-3B used for template generation</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Same multi-task suite (e.g., SST-2, SNLI, TREC, MRPC, etc.)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Compare manual prompts to automatically generated templates (Auto T), automatically selected label words (Auto L), and their combination (Auto T + L) in the few-shot setting.</td>
                        </tr>
                        <tr>
                            <td><strong>presentation_format</strong></td>
                            <td>Auto T: generate diverse templates from labeled examples via T5 span-filling and beam search, fine-tune per-template and select via dev; Auto L: for each class take top-k vocabulary words by conditional likelihood and brute-force top-n combinations, fine-tune and rerank on dev.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_format</strong></td>
                            <td>Compared against manual templates/label words and their prompt-based fine-tuning variants; also ensembles of many auto-generated templates.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>Examples (K=16): SST-2 manual 92.7 vs Auto T 92.3; SNLI manual 77.2 vs Auto T 77.1; TREC manual 84.8 vs Auto T 88.2 (Auto T better on some tasks). Auto L gave mixed results: improved TREC/MRPC but worse on SNLI.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_comparison</strong></td>
                            <td>Auto T often matches or slightly outperforms manual templates on several tasks; Auto L can help some tasks but may hurt others (task-dependent). Ensembles of many Auto T templates further improve performance.</td>
                        </tr>
                        <tr>
                            <td><strong>format_effect_size</strong></td>
                            <td>Task-dependent: e.g., TREC +3.4% absolute improvement (Auto T vs manual in single-prompt setting); other tasks show small ± differences (~0–1%).</td>
                        </tr>
                        <tr>
                            <td><strong>explanation_or_hypothesis</strong></td>
                            <td>T5-generated templates provide diverse, high-quality ways to phrase the fill-in-the-blank problem and avoid manual trial-and-error; Auto L prunes verbalizers to words that LM assigns high conditional likelihood given examples, but label-word choice can still be idiosyncratic and task-dependent.</td>
                        </tr>
                        <tr>
                            <td><strong>null_or_negative_result</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>experimental_details</strong></td>
                            <td>T5-3B used for template generation; for Auto L k=100 (vocab candidates) and n=100 (top assignments) except special handling for SST-5 and TREC; fine-tune and re-rank candidates on dev;训练 hyperparameters fixed for Auto search (batch size 8, LR 1e-5).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Making Pre-trained Language Models Better Few-shot Learners', 'publication_date_yy_mm': '2021-01'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e9445.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e9445.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how different problem or prompt presentation formats affect the performance of large language models (LLMs) on tasks, including details about the formats, tasks, models, performance metrics, comparisons, and any explanations or findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Demonstration sampling formats</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Demonstration inclusion and selective sampling strategies (one-per-class minimal demonstrations and semantically similar demonstration selection using SBERT)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Alternative ways to include demonstrations in the prompt during fine-tuning/inference: (a) GPT-3 style random concatenation of many examples; (b) LM-BFF's minimal demonstration sets sampling one example per class per training step; (c) selective sampling by semantic similarity (SBERT) to the query.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>RoBERTa-large (primary); also experiments on BERT-large</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Multiple classification tasks (e.g., MNLI, SNLI, SST-2, MRPC, TREC, etc.)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Evaluate whether including training examples as demonstrations in the input helps few-shot fine-tuning, and whether how demonstrations are selected matters.</td>
                        </tr>
                        <tr>
                            <td><strong>presentation_format</strong></td>
                            <td>Formats compared: (i) concatenating many random demos (GPT-3 style), (ii) sample one example per class and concatenate minimal demonstration set per input (LM-BFF), (iii) selective sampling where demonstrations are chosen from top r=50% semantically similar examples per class measured by SBERT cosine similarity; at inference sample 16 demo sets and average logits.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_format</strong></td>
                            <td>Uniform random sampling vs SBERT selective sampling vs RoBERTa-based selection in some ablations; also compared to no demonstrations.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>Examples (K=16): On MNLI prompt-based FT (manual) 68.3 -> +demonstrations 70.7 (+2.4). SNLI 77.2 -> +demonstrations 79.7 (+2.5). MRPC: manual prompt-based FT 74.5 -> +demonstrations 77.8 (+3.3). Table 7 shows SBERT selection often best: SNLI uniform 78.8 vs SBERT 79.7; MRPC uniform 70.9 vs SBERT 77.8 (+6.9).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_comparison</strong></td>
                            <td>Selective (SBERT) sampling consistently outperformed uniform sampling across tasks tested; LM-BFF minimal one-per-class demonstration sets outperformed naive concatenation of many random demos (GPT-3 style) for smaller models.</td>
                        </tr>
                        <tr>
                            <td><strong>format_effect_size</strong></td>
                            <td>Improvement examples: SNLI +~0.9% (uniform -> SBERT), MRPC +6.9% (uniform -> SBERT); adding demonstrations to prompt-based FT commonly yields +~1–4% absolute on many tasks (task-dependent).</td>
                        </tr>
                        <tr>
                            <td><strong>explanation_or_hypothesis</strong></td>
                            <td>Long contexts with many random demonstrations are noisy and harder for smaller LMs to use; pairing the query with semantically similar, class-contrastive examples provides more discriminative comparisons and a clearer learning signal; sampling one per class yields compact, informative contexts and avoids context-length limits.</td>
                        </tr>
                        <tr>
                            <td><strong>null_or_negative_result</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>experimental_details</strong></td>
                            <td>During training and testing, sample one example per class to build demonstration set; sample 16 different demonstration sets per input and average predicted log-probs at inference; SBERT (roberta-large-nli-stsb-mean-tokens) used to compute sentence embeddings and cosine similarity; selective sampling restricts to top r=50% similar instances per class.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Making Pre-trained Language Models Better Few-shot Learners', 'publication_date_yy_mm': '2021-01'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e9445.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e9445.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how different problem or prompt presentation formats affect the performance of large language models (LLMs) on tasks, including details about the formats, tasks, models, performance metrics, comparisons, and any explanations or findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Prompt ensembles</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Ensembling multiple templates (manual or auto-generated) to improve robustness and accuracy</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Train separate models (or fine-tune with different templates) and ensemble their predictions; automatic prompt search facilitates constructing large ensembles of diverse templates.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>RoBERTa-large</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>MNLI, RTE (demonstrated), and generally other tasks</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Compare single-template models to ensembles built from PET manual prompts or many automatically generated templates.</td>
                        </tr>
                        <tr>
                            <td><strong>presentation_format</strong></td>
                            <td>Ensemble of models each trained with a different prompt/template (e.g., PET used 4 prompts for MNLI, 5 for RTE; the paper compares ensembles of equal size built from auto templates).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_format</strong></td>
                            <td>Single-prompt vs ensemble of PET prompts vs ensemble of automatically generated templates.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>MNLI single manual prompt 68.3 (2.3) -> ensemble of Auto templates (|P_ours|=20) + demonstrations 75.4 (1.6). RTE single manual 69.1 (3.6) -> Auto ensemble (20) 73.1 (3.3).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_comparison</strong></td>
                            <td>Ensembling many automatic templates outperforms single prompts and achieves comparable or better performance than PET ensembles with the same number of prompts; gains can be several absolute points (e.g., MNLI +~7.1% from single manual -> Auto ensemble + demos).</td>
                        </tr>
                        <tr>
                            <td><strong>format_effect_size</strong></td>
                            <td>Ensemble gains appear substantial; e.g., MNLI single manual 68.3 -> ensemble + demos 75.4 (~+7.1% absolute).</td>
                        </tr>
                        <tr>
                            <td><strong>explanation_or_hypothesis</strong></td>
                            <td>Diverse phrasing of prompts yields complementary views of the task; ensembling reduces variance inherent in few-shot fine-tuning and mitigates sensitivity to a single prompt choice.</td>
                        </tr>
                        <tr>
                            <td><strong>null_or_negative_result</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>experimental_details</strong></td>
                            <td>Auto template generation via T5 with wide beam, fine-tune each candidate, select or ensemble top-k by dev performance; PET prompt sets used for comparison; results averaged over 5 splits.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Making Pre-trained Language Models Better Few-shot Learners', 'publication_date_yy_mm': '2021-01'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e9445.6">
                <h3 class="extraction-instance">Extracted Data Instance 6 (e9445.6)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how different problem or prompt presentation formats affect the performance of large language models (LLMs) on tasks, including details about the formats, tasks, models, performance metrics, comparisons, and any explanations or findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>BERT segment strategies for demonstrations</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Use of BERT segment (token type) embeddings when concatenating multiple sentences/demonstrations</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>When incorporating demonstrations into BERT-based models, the assignment of segment embeddings (A/B or multi-segment) affects performance; strategies include 1-seg (all A), 2-seg (A for query, B for all demos), and n-seg (separate new randomly initialized segments for each sentence).</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>BERT-large (uncased) (comparison experiments)</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>SST-2, SNLI, TREC, MRPC (reported in Appendix D)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Evaluate prompt-based FT and demonstration formats on BERT-large and compare to RoBERTa-large.</td>
                        </tr>
                        <tr>
                            <td><strong>presentation_format</strong></td>
                            <td>Prompt-based FT with demonstrations and alternative segment-embedding assignment strategies: 1-seg (all sentences use segment A), 2-seg (query A, demonstrations B), n-seg (introduce and learn additional segment embeddings for each sentence).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_format</strong></td>
                            <td>Different segment assignment formats compared on BERT-large.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>Examples: BERT-large SST-2 prompt-based FT 85.6 -> +demo (1-seg) 87.5 -> +demo (2-seg) 86.1 -> +demo (n-seg) 86.4; SNLI prompt-based FT 59.2 -> +demo (2-seg) 61.3 (best for SNLI on BERT variants).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_comparison</strong></td>
                            <td>Segment strategy affects measured gain from demonstrations; 2-seg often works best on BERT for multi-sentence demonstration concatenation.</td>
                        </tr>
                        <tr>
                            <td><strong>format_effect_size</strong></td>
                            <td>Variations are modest but measurable (e.g., SST-2 +1.9% from prompt-based FT to +demo (1-seg) for BERT; SNLI +2.1% from prompt-based FT to +demo (2-seg)).</td>
                        </tr>
                        <tr>
                            <td><strong>explanation_or_hypothesis</strong></td>
                            <td>BERT's pretraining uses two segment embeddings; when concatenating many sentences/demos, appropriate assignment of token-type/segment embeddings helps the model distinguish query vs demonstration contexts; without appropriate segments, the model may confuse roles of different sentences.</td>
                        </tr>
                        <tr>
                            <td><strong>null_or_negative_result</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>experimental_details</strong></td>
                            <td>Experiments in Appendix D compare BERT-large and RoBERTa-large using manual prompts; when using n-seg introduce randomly initialized extra segment embeddings (learned during fine-tuning).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Making Pre-trained Language Models Better Few-shot Learners', 'publication_date_yy_mm': '2021-01'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Language models are few-shot learners <em>(Rating: 2)</em></li>
                <li>Exploiting cloze questions for few-shot text classification and natural language inference <em>(Rating: 2)</em></li>
                <li>Exploring the limits of transfer learning with a unified text-to-text Transformer <em>(Rating: 2)</em></li>
                <li>SentenceBERT: Sentence embeddings using Siamese BERT-networks <em>(Rating: 2)</em></li>
                <li>Automatically identifying words that can serve as labels for few-shot text classification <em>(Rating: 1)</em></li>
                <li>AutoPrompt: Automatic prompt construction for masked language models <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-9445",
    "paper_id": "paper-85e7d63f75c0916bd350a229e040c5fbb1472e7a",
    "extraction_schema_id": "extraction-schema-163",
    "extracted_data": [
        {
            "name_short": "LM-BFF (prompt-based fine-tuning)",
            "name_full": "LM-BFF: Better Few-shot Fine-tuning of Language Models (prompt-based fine-tuning with demonstrations and automatic prompt search)",
            "brief_description": "A prompt-based fine-tuning paradigm that converts downstream tasks into masked-language modeling problems (fill-in-the-blank), re-uses pre-trained MLM output vectors as verbalizers, and fine-tunes the LM on a few labeled examples; combined with automated prompt search and selective demonstrations.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "RoBERTa-large (primary experiments)",
            "model_size": null,
            "task_name": "Multiple sentence-classification and regression tasks (e.g., SST-2, SNLI, MNLI, MNLI-mm, QNLI, RTE, MRPC, QQP, TREC, CoLA, STS-B, etc.)",
            "task_description": "Binary and multi-class sentence and sentence-pair classification tasks and one regression task (STS-B), evaluated in a K-shot few-shot setting.",
            "presentation_format": "Prompt-based fine-tuning: transform input into a template containing one [MASK] token; map classes to label words (verbalizer) and fine-tune the LM to predict the verbalizer word at the [MASK]. Optionally include demonstrations (concatenated masked examples) sampled per input.",
            "comparison_format": "Standard fine-tuning with a randomly initialized classification head (softmax on [CLS]); also compared to prompt-based zero-shot (no fine-tuning) and GPT-3 style in-context learning (concatenate up to 32 randomly sampled demonstrations).",
            "performance": "Example: SST-2 (K=16 per class): prompt-based FT (manual) accuracy 92.7 (std 0.9); SNLI: prompt-based FT (manual) accuracy 77.2 (3.7). Results reported as mean (std) over 5 data splits.",
            "performance_comparison": "Example comparisons (K=16): SST-2 standard fine-tuning accuracy 81.4 (3.8) vs prompt-based FT 92.7 (0.9) (+11.3% absolute). SNLI standard fine-tuning 48.4 (4.8) vs prompt-based FT 77.2 (3.7) (+28.8% absolute). Paper reports up to +30% absolute and +11% average improvement across tasks.",
            "format_effect_size": "+11% average across tasks; up to +30% absolute on SNLI (prompt-based FT vs standard fine-tuning) as reported.",
            "explanation_or_hypothesis": "Prompt-based fine-tuning reduces the gap between pre-training and fine-tuning by re-using pre-trained MLM output vectors (no new task head parameters), making the learning objective closer to pre-training; this is particularly effective in extreme few-shot regimes where adding randomly initialized classifier parameters is hard to learn.",
            "null_or_negative_result": false,
            "experimental_details": "Main setup: RoBERTa-large, K=16 examples per class (K_tot = K * |Y|), average over 5 random train/dev splits; hyperparameter grid search per split; templates and label words either manual or generated; demonstrations: sample 16 demonstration sets per input at inference and average predicted log-probs.",
            "uuid": "e9445.0",
            "source_info": {
                "paper_title": "Making Pre-trained Language Models Better Few-shot Learners",
                "publication_date_yy_mm": "2021-01"
            }
        },
        {
            "name_short": "Prompt-based zero-shot vs majority baseline / in-context",
            "name_full": "Prompt-based zero-shot prediction and in-context demonstration concatenation (GPT-3 style) evaluated with RoBERTa-large",
            "brief_description": "Evaluates (1) using manual prompt templates with no fine-tuning (zero-shot prompt evaluation) and (2) concatenating randomly sampled demonstrations (up to 32) a la GPT-3, applied to RoBERTa-large as baselines.",
            "citation_title": "Language models are few-shot learners",
            "mention_or_use": "use",
            "model_name": "RoBERTa-large (used to emulate GPT-3 in-context by concatenation of demonstrations)",
            "model_size": null,
            "task_name": "Same suite of classification/regression tasks (see main experiments)",
            "task_description": "Prompt-based zero-shot: feed template with [MASK] to LM and read verbalizer probability without weight updates. GPT-3 style in-context: augment template with 32 randomly sampled demonstrations concatenated in-context and no fine-tuning.",
            "presentation_format": "Zero-shot prompt-based (manual templates) and GPT-3-style in-context learning (random concatenation of up to 32 demonstrations into the input context).",
            "comparison_format": "Compared to prompt-based fine-tuning and to majority-class baseline.",
            "performance": "Example zero-shot: SST-2 zero-shot prompt accuracy 83.6; 'GPT-3' in-context (RoBERTa-large with 32 random demos) SST-2 84.8 (1.3). Zero-shot often far above majority baseline (e.g., SST-2 majority 50.9).",
            "performance_comparison": "Zero-shot prompt-based (SST-2 83.6) vs majority (50.9); 'GPT-3' in-context sometimes gives small improvements over zero-shot for some tasks but is inconsistent across tasks (e.g., SNLI zero-shot 49.5 vs in-context 47.1).",
            "format_effect_size": "Varies by task; e.g., SST-2 +1.2% (in-context vs zero-shot), but in other tasks in-context can be worse (SNLI -2.4% in this setup). No consistent large gain for smaller LMs.",
            "explanation_or_hypothesis": "Smaller language models (e.g., RoBERTa-large) are not as capable as GPT-3 to exploit raw in-context demonstrations without parameter updates; concatenating many random demonstrations can produce long, noisy contexts that smaller models struggle to use effectively.",
            "null_or_negative_result": true,
            "experimental_details": "In-context experiments used RoBERTa-large, concatenating up to 32 randomly sampled demonstrations (no parameter updates). Evaluations report mean and std across splits when applicable.",
            "uuid": "e9445.1",
            "source_info": {
                "paper_title": "Making Pre-trained Language Models Better Few-shot Learners",
                "publication_date_yy_mm": "2021-01"
            }
        },
        {
            "name_short": "Manual prompt sensitivity",
            "name_full": "Sensitivity of LM performance to manual template wording and label-word choices",
            "brief_description": "Empirical study showing that small changes in template phrasing, [MASK] position, sentence order, and the particular choice/order of label words can cause large swings in few-shot accuracy.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "RoBERTa-large",
            "model_size": null,
            "task_name": "SST-2 (binary sentiment), SNLI (3-way NLI) (pilot analysis)",
            "task_description": "Evaluate how swapping label words (verbalizers) and changing template placement affects classification accuracy in K-shot fine-tuning.",
            "presentation_format": "Different manual templates and different label-word mappings (e.g., SST-2 templates 'It was [MASK].' with label pairs {great/terrible, good/bad, cat/dog, dog/cat, terrible/great}); for SNLI variants of template placement and mask location and sentence order.",
            "comparison_format": "Multiple alternative templates and label-word mappings tested against each other and against standard fine-tuning.",
            "performance": "SST-2 (K=16): 'great/terrible' 92.7 (0.9); 'good/bad' 92.5 (1.0); 'cat/dog' 91.5 (1.4); 'dog/cat' 86.2 (5.4); 'terrible/great' 83.2 (6.9); fine-tuning baseline 81.4 (3.8). SNLI templates where mask placed at end or swapped sentence order caused &gt;10% drops relative to best template.",
            "performance_comparison": "Choice of label words and template placement produced differences up to ~9–10+ percentage points (and in some swaps produced very large drops compared to best prompt), and substantial increases over standard fine-tuning.",
            "format_effect_size": "SST-2 example: best manual verbalizer vs worst verbalizer observed ~92.7 - 83.2 = +9.5% absolute; SNLI template changes could cause &gt;10% drops.",
            "explanation_or_hypothesis": "Performance depends on semantic alignment between verbalizer tokens and label semantics and on making the MLM task resemble natural text the model saw during pretraining; small mismatches (e.g., swapping polarity order) can push the model away from learned priors and degrade predictions.",
            "null_or_negative_result": false,
            "experimental_details": "Pilot experiments with K=16 per class, RoBERTa-large; results averaged over 5 splits; table enumerates multiple template/label-word choices and reports accuracy mean (std).",
            "uuid": "e9445.2",
            "source_info": {
                "paper_title": "Making Pre-trained Language Models Better Few-shot Learners",
                "publication_date_yy_mm": "2021-01"
            }
        },
        {
            "name_short": "Automatic prompt generation (Auto T / Auto L)",
            "name_full": "Automatic template generation using T5 (Auto T) and automatic label-word selection via pruned brute-force search (Auto L)",
            "brief_description": "Automated methods: Auto T uses a pre-trained T5 model to generate templates from a few labeled examples (decoded with wide beam search) and then fine-tunes/evaluates candidate templates; Auto L constructs per-class candidate verbalizers by ranking vocabulary words by conditional likelihood under the LM and pruned brute-force / reranking.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "RoBERTa-large (LM used for fine-tuning); T5-3B used for template generation",
            "model_size": null,
            "task_name": "Same multi-task suite (e.g., SST-2, SNLI, TREC, MRPC, etc.)",
            "task_description": "Compare manual prompts to automatically generated templates (Auto T), automatically selected label words (Auto L), and their combination (Auto T + L) in the few-shot setting.",
            "presentation_format": "Auto T: generate diverse templates from labeled examples via T5 span-filling and beam search, fine-tune per-template and select via dev; Auto L: for each class take top-k vocabulary words by conditional likelihood and brute-force top-n combinations, fine-tune and rerank on dev.",
            "comparison_format": "Compared against manual templates/label words and their prompt-based fine-tuning variants; also ensembles of many auto-generated templates.",
            "performance": "Examples (K=16): SST-2 manual 92.7 vs Auto T 92.3; SNLI manual 77.2 vs Auto T 77.1; TREC manual 84.8 vs Auto T 88.2 (Auto T better on some tasks). Auto L gave mixed results: improved TREC/MRPC but worse on SNLI.",
            "performance_comparison": "Auto T often matches or slightly outperforms manual templates on several tasks; Auto L can help some tasks but may hurt others (task-dependent). Ensembles of many Auto T templates further improve performance.",
            "format_effect_size": "Task-dependent: e.g., TREC +3.4% absolute improvement (Auto T vs manual in single-prompt setting); other tasks show small ± differences (~0–1%).",
            "explanation_or_hypothesis": "T5-generated templates provide diverse, high-quality ways to phrase the fill-in-the-blank problem and avoid manual trial-and-error; Auto L prunes verbalizers to words that LM assigns high conditional likelihood given examples, but label-word choice can still be idiosyncratic and task-dependent.",
            "null_or_negative_result": false,
            "experimental_details": "T5-3B used for template generation; for Auto L k=100 (vocab candidates) and n=100 (top assignments) except special handling for SST-5 and TREC; fine-tune and re-rank candidates on dev;训练 hyperparameters fixed for Auto search (batch size 8, LR 1e-5).",
            "uuid": "e9445.3",
            "source_info": {
                "paper_title": "Making Pre-trained Language Models Better Few-shot Learners",
                "publication_date_yy_mm": "2021-01"
            }
        },
        {
            "name_short": "Demonstration sampling formats",
            "name_full": "Demonstration inclusion and selective sampling strategies (one-per-class minimal demonstrations and semantically similar demonstration selection using SBERT)",
            "brief_description": "Alternative ways to include demonstrations in the prompt during fine-tuning/inference: (a) GPT-3 style random concatenation of many examples; (b) LM-BFF's minimal demonstration sets sampling one example per class per training step; (c) selective sampling by semantic similarity (SBERT) to the query.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "RoBERTa-large (primary); also experiments on BERT-large",
            "model_size": null,
            "task_name": "Multiple classification tasks (e.g., MNLI, SNLI, SST-2, MRPC, TREC, etc.)",
            "task_description": "Evaluate whether including training examples as demonstrations in the input helps few-shot fine-tuning, and whether how demonstrations are selected matters.",
            "presentation_format": "Formats compared: (i) concatenating many random demos (GPT-3 style), (ii) sample one example per class and concatenate minimal demonstration set per input (LM-BFF), (iii) selective sampling where demonstrations are chosen from top r=50% semantically similar examples per class measured by SBERT cosine similarity; at inference sample 16 demo sets and average logits.",
            "comparison_format": "Uniform random sampling vs SBERT selective sampling vs RoBERTa-based selection in some ablations; also compared to no demonstrations.",
            "performance": "Examples (K=16): On MNLI prompt-based FT (manual) 68.3 -&gt; +demonstrations 70.7 (+2.4). SNLI 77.2 -&gt; +demonstrations 79.7 (+2.5). MRPC: manual prompt-based FT 74.5 -&gt; +demonstrations 77.8 (+3.3). Table 7 shows SBERT selection often best: SNLI uniform 78.8 vs SBERT 79.7; MRPC uniform 70.9 vs SBERT 77.8 (+6.9).",
            "performance_comparison": "Selective (SBERT) sampling consistently outperformed uniform sampling across tasks tested; LM-BFF minimal one-per-class demonstration sets outperformed naive concatenation of many random demos (GPT-3 style) for smaller models.",
            "format_effect_size": "Improvement examples: SNLI +~0.9% (uniform -&gt; SBERT), MRPC +6.9% (uniform -&gt; SBERT); adding demonstrations to prompt-based FT commonly yields +~1–4% absolute on many tasks (task-dependent).",
            "explanation_or_hypothesis": "Long contexts with many random demonstrations are noisy and harder for smaller LMs to use; pairing the query with semantically similar, class-contrastive examples provides more discriminative comparisons and a clearer learning signal; sampling one per class yields compact, informative contexts and avoids context-length limits.",
            "null_or_negative_result": false,
            "experimental_details": "During training and testing, sample one example per class to build demonstration set; sample 16 different demonstration sets per input and average predicted log-probs at inference; SBERT (roberta-large-nli-stsb-mean-tokens) used to compute sentence embeddings and cosine similarity; selective sampling restricts to top r=50% similar instances per class.",
            "uuid": "e9445.4",
            "source_info": {
                "paper_title": "Making Pre-trained Language Models Better Few-shot Learners",
                "publication_date_yy_mm": "2021-01"
            }
        },
        {
            "name_short": "Prompt ensembles",
            "name_full": "Ensembling multiple templates (manual or auto-generated) to improve robustness and accuracy",
            "brief_description": "Train separate models (or fine-tune with different templates) and ensemble their predictions; automatic prompt search facilitates constructing large ensembles of diverse templates.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "RoBERTa-large",
            "model_size": null,
            "task_name": "MNLI, RTE (demonstrated), and generally other tasks",
            "task_description": "Compare single-template models to ensembles built from PET manual prompts or many automatically generated templates.",
            "presentation_format": "Ensemble of models each trained with a different prompt/template (e.g., PET used 4 prompts for MNLI, 5 for RTE; the paper compares ensembles of equal size built from auto templates).",
            "comparison_format": "Single-prompt vs ensemble of PET prompts vs ensemble of automatically generated templates.",
            "performance": "MNLI single manual prompt 68.3 (2.3) -&gt; ensemble of Auto templates (|P_ours|=20) + demonstrations 75.4 (1.6). RTE single manual 69.1 (3.6) -&gt; Auto ensemble (20) 73.1 (3.3).",
            "performance_comparison": "Ensembling many automatic templates outperforms single prompts and achieves comparable or better performance than PET ensembles with the same number of prompts; gains can be several absolute points (e.g., MNLI +~7.1% from single manual -&gt; Auto ensemble + demos).",
            "format_effect_size": "Ensemble gains appear substantial; e.g., MNLI single manual 68.3 -&gt; ensemble + demos 75.4 (~+7.1% absolute).",
            "explanation_or_hypothesis": "Diverse phrasing of prompts yields complementary views of the task; ensembling reduces variance inherent in few-shot fine-tuning and mitigates sensitivity to a single prompt choice.",
            "null_or_negative_result": false,
            "experimental_details": "Auto template generation via T5 with wide beam, fine-tune each candidate, select or ensemble top-k by dev performance; PET prompt sets used for comparison; results averaged over 5 splits.",
            "uuid": "e9445.5",
            "source_info": {
                "paper_title": "Making Pre-trained Language Models Better Few-shot Learners",
                "publication_date_yy_mm": "2021-01"
            }
        },
        {
            "name_short": "BERT segment strategies for demonstrations",
            "name_full": "Use of BERT segment (token type) embeddings when concatenating multiple sentences/demonstrations",
            "brief_description": "When incorporating demonstrations into BERT-based models, the assignment of segment embeddings (A/B or multi-segment) affects performance; strategies include 1-seg (all A), 2-seg (A for query, B for all demos), and n-seg (separate new randomly initialized segments for each sentence).",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "BERT-large (uncased) (comparison experiments)",
            "model_size": null,
            "task_name": "SST-2, SNLI, TREC, MRPC (reported in Appendix D)",
            "task_description": "Evaluate prompt-based FT and demonstration formats on BERT-large and compare to RoBERTa-large.",
            "presentation_format": "Prompt-based FT with demonstrations and alternative segment-embedding assignment strategies: 1-seg (all sentences use segment A), 2-seg (query A, demonstrations B), n-seg (introduce and learn additional segment embeddings for each sentence).",
            "comparison_format": "Different segment assignment formats compared on BERT-large.",
            "performance": "Examples: BERT-large SST-2 prompt-based FT 85.6 -&gt; +demo (1-seg) 87.5 -&gt; +demo (2-seg) 86.1 -&gt; +demo (n-seg) 86.4; SNLI prompt-based FT 59.2 -&gt; +demo (2-seg) 61.3 (best for SNLI on BERT variants).",
            "performance_comparison": "Segment strategy affects measured gain from demonstrations; 2-seg often works best on BERT for multi-sentence demonstration concatenation.",
            "format_effect_size": "Variations are modest but measurable (e.g., SST-2 +1.9% from prompt-based FT to +demo (1-seg) for BERT; SNLI +2.1% from prompt-based FT to +demo (2-seg)).",
            "explanation_or_hypothesis": "BERT's pretraining uses two segment embeddings; when concatenating many sentences/demos, appropriate assignment of token-type/segment embeddings helps the model distinguish query vs demonstration contexts; without appropriate segments, the model may confuse roles of different sentences.",
            "null_or_negative_result": false,
            "experimental_details": "Experiments in Appendix D compare BERT-large and RoBERTa-large using manual prompts; when using n-seg introduce randomly initialized extra segment embeddings (learned during fine-tuning).",
            "uuid": "e9445.6",
            "source_info": {
                "paper_title": "Making Pre-trained Language Models Better Few-shot Learners",
                "publication_date_yy_mm": "2021-01"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Language models are few-shot learners",
            "rating": 2
        },
        {
            "paper_title": "Exploiting cloze questions for few-shot text classification and natural language inference",
            "rating": 2
        },
        {
            "paper_title": "Exploring the limits of transfer learning with a unified text-to-text Transformer",
            "rating": 2
        },
        {
            "paper_title": "SentenceBERT: Sentence embeddings using Siamese BERT-networks",
            "rating": 2
        },
        {
            "paper_title": "Automatically identifying words that can serve as labels for few-shot text classification",
            "rating": 1
        },
        {
            "paper_title": "AutoPrompt: Automatic prompt construction for masked language models",
            "rating": 1
        }
    ],
    "cost": 0.019246,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Making Pre-trained Language Models Better Few-shot Learners</h1>
<p>Tianyu Gao ${ }^{\dagger <em>}$ Adam Fisch ${ }^{\ddagger </em>}$ Danqi Chen ${ }^{\dagger}$<br>${ }^{\dagger}$ Princeton University ${ }^{\ddagger}$ Massachusetts Institute of Technology<br>{tianyug, danqic}@cs.princeton.edu<br>fisch@csail.mit.edu</p>
<h4>Abstract</h4>
<p>The recent GPT-3 model (Brown et al., 2020) achieves remarkable few-shot performance solely by leveraging a natural-language prompt and a few task demonstrations as input context. Inspired by their findings, we study few-shot learning in a more practical scenario, where we use smaller language models for which fine-tuning is computationally efficient. We present LM-BFF—better few-shot fine-tuning of language models ${ }^{\dagger}$-a suite of simple and complementary techniques for finetuning language models on a small number of annotated examples. Our approach includes (1) prompt-based fine-tuning together with a novel pipeline for automating prompt generation; and (2) a refined strategy for dynamically and selectively incorporating demonstrations into each context. Finally, we present a systematic evaluation for analyzing few-shot performance on a range of NLP tasks, including classification and regression. Our experiments demonstrate that our methods combine to dramatically outperform standard fine-tuning procedures in this low resource setting, achieving up to $30 \%$ absolute improvement, and $11 \%$ on average across all tasks. Our approach makes minimal assumptions on task resources and domain expertise, and hence constitutes a strong task-agnostic method for few-shot learning. ${ }^{2}$</p>
<h2>1 Introduction</h2>
<p>The GPT-3 model (Brown et al., 2020) has made waves in the NLP community by demonstrating astounding few-shot capabilities on myriad language understanding tasks. Given only a natural language prompt and a few demonstrations of the task, GPT-3 is able to make accurate predictions without updating any of the weights of its underlying lan-</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup>guage model. However, while remarkable, GPT-3 consists of 175B parameters, which makes it challenging to use in most real-wold applications.</p>
<p>In this work, we study a more practical scenario in which we only assume access to a moderatelysized language model such as BERT (Devlin et al., 2019) or RoBERTa (Liu et al., 2019), and a small number of examples (i.e., a few-shot setting), which we can use to fine-tune the weights of the language model. This setting is appealing as (1) such models can be trained on typical research hardware; (2) few-shot settings are realistic, as it is generally both easy to acquire a few annotations (e.g., 32 examples) and efficient to train on them; and (3) updating parameters typically leads to better performance. Inspired by GPT-3's findings, we propose several novel strategies for expanding its few-shot learning abilities to our setting, considering both classification and-for the first time-regression.</p>
<p>First, we follow the route of prompt-based prediction, first developed by the GPT series (Radford et al., 2018, 2019; Brown et al., 2020) for zero-shot prediction and recently studied by PET (Schick and Schütze, 2021a,b) for fine-tuning. Prompt-based prediction treats the downstream task as a (masked) language modeling problem, where the model directly generates a textual response (referred to as a label word) to a given prompt defined by a taskspecific template (see Figure 1(c)). Finding the right prompts, however, is an art-requiring both domain expertise and an understanding of the language model's inner workings. Even if significant effort is invested, manual prompts are likely to be suboptimal. We address this issue by introducing automatic prompt generation, including a pruned brute-force search to identify the best working label words, and a novel decoding objective to automatically generate templates using the generative T5 model (Raffel et al., 2020)—all of which only require the few-shot training data. This allows us</p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: An illustration of (a) masked language model (MLM) pre-training, (b) standard fine-tuning, and (c) our proposed LM-BFF using prompt-based fine-tuning with demonstrations. The underlined text is the task-specific template, and colored words are label words.</p>
<p>to cheaply obtain effective prompts that match or outperform our manually chosen ones.</p>
<p>Second, we adopt the idea of incorporating demonstrations as additional context. GPT-3's naive "in-context learning" paradigm picks up to 32 randomly sampled examples, and concatenates them with the input. This method is not guaranteed to prioritize the most informative demonstrations, and mixing random examples from different classes together creates long contexts which can be hard to learn from. Additionally, the number of usable demonstrations is bounded by the model's maximum input length. We develop a more refined strategy, where, for each input, we randomly sample a single example at a time from each class to create multiple, minimal demonstration sets. We also devise a novel sampling strategy that pairs inputs with similar examples, thereby providing the model with more discriminative comparisons.</p>
<p>We present a systematic evaluation for analyzing few-shot performance on 8 single-sentence and 7 sentence-pair NLP tasks. We observe that given a small number of training examples, (1) prompt-based fine-tuning largely outperforms standard fine-tuning; (2) our automatic prompt search method matches or outperforms manual prompts; and (3) incorporating demonstrations is effective for fine-tuning, and boosts few-shot performance. Together, these simple-yet-effective methods contribute towards a dramatic improvement across the tasks we evaluate on, and we obtain gains up to 30% absolute improvement (11% on average) compared to standard fine-tuning. For instance, we find that a RoBERTa-large model achieves around 90% accuracy on most binary sentence classification tasks, while only relying on 32 training examples. We refer to our approach as LM-BFF, better few-shot fine-tuning of language models: a strong, task-agnostic method for few-shot learning.</p>
<h2>2 Related Work</h2>
<p>Language model prompting. The GPT series (Radford et al., 2018, 2019; Brown et al., 2020) fueled the development of prompt-based learning, and we follow many of its core concepts. We are also greatly inspired by the recent PET work (Schick and Schütze, 2021a,b), although they mainly focus on a semi-supervised setting where a large set of unlabeled examples are provided. We only use a few annotated examples as supervision, and also explore automatically generated prompts and fine-tuning with demonstrations. Furthermore, we deviate from their evaluation by providing a more rigorous framework, as we will discuss in §3. Finally, there is a large body of work on prompting for mining knowledge from pre-trained models (Trinh and Le, 2018; Petroni et al., 2019; Davison et al., 2019; Talmor et al., 2020, inter alia). Different from these works, we focus on leveraging prompting for fine-tuning on downstream tasks.</p>
<p>Automatic prompt search. Schick and Schütze (2021a) and Schick et al. (2020) explore ways of identifying label words automatically, however, none of these results lead to better performance compared to hand-picked ones. In contrast, our method searches over both templates and label words, and is able to match or outperform our manual prompts. Several other attempts have been made in addition—yet these approaches either op-</p>
<p>erate in limited domains, such as finding patterns to express specific relations (Jiang et al., 2020), or require a large number of examples for gradientguided search (Shin et al., 2020; Zhong et al., 2021). Our approach aims to develop general-purpose search methods that rely only on a few annotations.</p>
<p>Fine-tuning of language models. A number of recent studies have focused on better methods for fine-tuning language models (Howard and Ruder, 2018; Dodge et al., 2020; Lee et al., 2020; Zhang et al., 2021). These works mainly focus on optimization and regularization techniques to stabilize fine-tuning. Here we use standard optimization techniques, and instead mainly focus our efforts on better prompt-based fine-tuning in a more extreme few-shot setting. We anticipate that results of these studies are largely complementary to ours.</p>
<p>Few-shot learning. Broadly speaking, our setting is also connected to other few-shot learning paradigms in NLP, including (1) semi-supervised learning (Miyato et al., 2017; Xie et al., 2020; Chen et al., 2020), where a set of unlabeled examples are given; (2) meta-learning (Yu et al., 2018; Han et al., 2018; Bansal et al., 2020a,b; Bao et al., 2020), where a set of auxiliary tasks are given; and (3) intermediate training (Phang et al., 2018; Yin et al., 2020), where a related, intermediate task is given. We deviate from these settings by making minimal assumptions about available resources: we only assume a few annotated examples and a pre-trained language model. Our focus is on understanding how far we can push without any other advantages.</p>
<h2>3 Problem Setup</h2>
<p>Task formulation. In this work, we assume access to a pre-trained language model $\mathcal{L}$ that we wish to fine-tune on a task $\mathcal{D}$ with a label space $\mathcal{Y}$. For the task, we only assume $K$ training examples per class $^{3}$ for the task's training set $\mathcal{D}<em _text="\text" _tot="{tot">{\text {train }}$, such that the total number of examples is $K</em>}}=K \times|\mathcal{Y}|$, and $\mathcal{D<em _mathrm_in="\mathrm{in">{\text {train }}=\left{\left(x</em>\right)\right}}}^{i}, y^{i<em _text="\text" _tot="{tot">{i=1}^{K</em>}}}$. Our goal is then to develop task-agnostic learning strategies that generalize well to an unseen test set $\left(x_{\mathrm{in}}^{\text {test }}, y^{\text {test }}\right) \sim \mathcal{D<em _dev="{dev" _text="\text">{\text {test }}$. For model selection and hyper-parameter tuning, we assume a development set $\mathcal{D}</em>}}$, of the same size as the few-shot training set, i.e., $\left|\mathcal{D<em _text="\text" _train="{train">{\text {dev }}\right|=\left|\mathcal{D}</em>\right|$. This distinction is important: using a larger development set confers a significant advantage (see our}</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup>experiments in Appendix A), and subverts our initial goal of learning from limited data. ${ }^{4}$ For all of the following experiments (unless specified otherwise), we take $\mathcal{L}=$ RoBERTa-large and $K=16$.</p>
<p>Evaluation datasets. We conduct a systematic study across 8 single-sentence and 7 sentence-pair English tasks, including 8 tasks from the GLUE benchmark (Wang et al., 2019), SNLI (Bowman et al., 2015), and 6 other popular sentence classification tasks (SST-5, MR, CR, MPQA, Subj, TREC). All of the dataset details are provided in Appendix B. For single-sentence tasks, the goal is to make a prediction based on an input sentence $x_{\text {in }}=x_{1}$, such as whether a movie review is positive or not. For sentence-pair tasks, the goal is to take a pair of input sentences $x_{\text {in }}=\left(x_{1}, x_{2}\right)$ and predict the relationship between them. We also interchangeably refer to the inputs as $\left\langle S_{1}\right\rangle$ or ( $\left\langle S_{1}\right\rangle$, $\left\langle S_{2}\right\rangle$ ). Note that we mainly use SST-2 and SNLI for pilot experiments and model development, making it close to a true few-shot setting, at least for all the other datasets we evaluate on.</p>
<p>Evaluation protocol. Systematically evaluating few-shot performance can be tricky. It is wellknown that fine-tuning on small datasets can suffer from instability (Dodge et al., 2020; Zhang et al., 2021), and results may change dramatically given a new split of data. To account for this, we measure average performance across 5 different randomly sampled $\mathcal{D}<em _dev="{dev" _text="\text">{\text {train }}$ and $\mathcal{D}</em>$ of that sample (see Appendix C.1).}}$ splits. This issue has also been discussed in Schick and Schütze (2021b) they suggest using a fixed set of training examples. We argue that sampling multiple splits gives a more robust measure of performance, and a better estimate of the variance. We also observe that hyperparameters can make a significant difference, thus we sweep multiple hyper-parameters for each data sample, and take the best setting as measured on the $\mathcal{D}_{\text {dev }</p>
<h2>4 Prompt-based Fine-tuning</h2>
<p>Given a masked language model $\mathcal{L}$, we first convert input $x_{\text {in }}$ to a token sequence $\tilde{x}$, and the language model $\mathcal{L}$ then maps $\tilde{x}$ to a sequence of hidden vectors $\left{\mathbf{h}<em _single="{single" _text="\text">{k} \in \mathbb{R}^{d}\right}$. During standard finetuning, we usually take $\tilde{x}</em>}}=\left[\right.$ CLS $] x_{1}[$ SEP $]$ or $\tilde{x<em 1="1">{\text {pair }}=\left[\right.$ CLS $\left] x</em>[\right.$ SEP $]$. For down-}[\right.$ SEP $\left.] x_{2</p>
<p><sup id="fnref:1"><a class="footnote-ref" href="#fn:1">2</a></sup></p>
<table>
<thead>
<tr>
<th style="text-align: center;">Task</th>
<th style="text-align: center;">Template</th>
<th style="text-align: center;">Label words</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">SST-2</td>
<td style="text-align: center;">$<S_{1}>$ It was [MASK] .</td>
<td style="text-align: center;">positive: great, negative: terrible</td>
</tr>
<tr>
<td style="text-align: center;">SST-5</td>
<td style="text-align: center;">$<S_{1}>$ It was [MASK] .</td>
<td style="text-align: center;">v.positive: great, positive: good, neutral: okay, negative: bad, v.negative: terrible</td>
</tr>
<tr>
<td style="text-align: center;">MR</td>
<td style="text-align: center;">$<S_{1}>$ It was [MASK] .</td>
<td style="text-align: center;">positive: great, negative: terrible</td>
</tr>
<tr>
<td style="text-align: center;">CR</td>
<td style="text-align: center;">$<S_{1}>$ It was [MASK] .</td>
<td style="text-align: center;">positive: great, negative: terrible</td>
</tr>
<tr>
<td style="text-align: center;">Subj</td>
<td style="text-align: center;">$<S_{1}>$ This is [MASK] .</td>
<td style="text-align: center;">subjective: subjective, objective: objective</td>
</tr>
<tr>
<td style="text-align: center;">TREC</td>
<td style="text-align: center;">[MASK] : $<S_{1}>$</td>
<td style="text-align: center;">abbreviation: Expression, entity: Entity, description: Description</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">human: Human, location: Location, numeric: Number</td>
</tr>
<tr>
<td style="text-align: center;">COLA</td>
<td style="text-align: center;">$<S_{1}>$ This is [MASK] .</td>
<td style="text-align: center;">grammatical: correct, not.grammatical: incorrect</td>
</tr>
<tr>
<td style="text-align: center;">MNLI</td>
<td style="text-align: center;">$<S_{1}>$ ? [MASK] , $<S_{2}>$</td>
<td style="text-align: center;">entailment: Yes, netural: Maybe, contradiction: No</td>
</tr>
<tr>
<td style="text-align: center;">SNLI</td>
<td style="text-align: center;">$<S_{1}>$ ? [MASK] , $<S_{2}>$</td>
<td style="text-align: center;">entailment: Yes, netural: Maybe, contradiction: No</td>
</tr>
<tr>
<td style="text-align: center;">QNLI</td>
<td style="text-align: center;">$<S_{1}>$ ? [MASK] , $<S_{2}>$</td>
<td style="text-align: center;">entailment: Yes, not.entailment: No</td>
</tr>
<tr>
<td style="text-align: center;">RTE</td>
<td style="text-align: center;">$<S_{1}>$ ? [MASK] , $<S_{2}>$</td>
<td style="text-align: center;">entailment: Yes, not.entailment: No</td>
</tr>
<tr>
<td style="text-align: center;">MRPC</td>
<td style="text-align: center;">$<S_{1}>[$ MASK] , $<S_{2}>$</td>
<td style="text-align: center;">equivalent: Yes, not.equivalent: No</td>
</tr>
<tr>
<td style="text-align: center;">QQP</td>
<td style="text-align: center;">$<S_{1}>[$ MASK] , $<S_{2}>$</td>
<td style="text-align: center;">equivalent: Yes, not.equivalent: No</td>
</tr>
<tr>
<td style="text-align: center;">STS-B</td>
<td style="text-align: center;">$<S_{1}>[$ MASK $],<S_{2}>$</td>
<td style="text-align: center;">$y_{u}:$ Yes, $y_{l}:$ No</td>
</tr>
</tbody>
</table>
<p>Table 1: Manual templates and label words that we used in our experiments. STS-B is a regression task (§4.2).
stream classification tasks with a label space $\mathcal{Y}$, we train a task-specific head, $\operatorname{softmax}\left(\mathbf{W}<em _CLS_="{[CLS]" _text="\text">{o} \mathbf{h}</em>}}\right)$, by maximizing the log-probability of the correct label, where $\mathbf{h<em o="o">{\text {[CLS] }}$ is the hidden vector of [CLS], and $\mathbf{W}</em>} \in \mathbb{R}^{|\mathcal{Y}| \times d}$ is a set of randomly initialized parameters introduced at the start of fine-tuning. Similarly, for a regression task, we can introduce $\mathbf{w<em o="o">{o} \in \mathbb{R}^{d}$ and optimize the mean squared error between $\mathbf{w}</em>$ and the gold label. In either case, the number of new parameters can be substantialfor example, a simple binary classification task will introduce 2,048 new parameters for a RoBERTa-large model-making it challenging to learn from a small amount of annotated data (e.g., 32 examples).} \cdot \mathbf{h}_{\text {[CLS] }</p>
<p>An alternative approach to solving this problem is prompt-based fine-tuning, in which $\mathcal{L}$ is directly tasked with "auto-completing" natural language prompts. For instance, we can formulate a binary sentiment classification task using a prompt with input $x_{1}$ (e.g., "No reason to watch it .") as:</p>
<p>$$
x_{\text {prompt }}=[\text { CLS }] x_{1} \text { It was [MASK] } .[\text { SEP }]
$$</p>
<p>and let $\mathcal{L}$ decide whether it is more appropriate to fill in "great" (positive) or "terrible" (negative) for [MASK]. We now formalize this approach for classification and regression (§4.1 and §4.2), and discuss the importance of prompt selection (§4.3).</p>
<h3>4.1 Classification</h3>
<p>Let $\mathcal{M}: \mathcal{Y} \rightarrow \mathcal{V}$ be a mapping from the task label space to individual words ${ }^{5}$ in the vocabulary</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup>$\mathcal{V}$ of $\mathcal{L}$. Then for each $x_{\text {in }}$, let the manipulation $x_{\text {prompt }}=\mathcal{T}\left(x_{\text {in }}\right)$ be a masked language modeling (MLM) input which contains one [MASK] token. In this way, we can treat our task as an MLM, and model the probability of predicting class $y \in \mathcal{Y}$ as:</p>
<p>$$
\begin{aligned}
p\left(y \mid x_{\text {in }}\right) &amp; =p\left(\left[\mathrm{MASK}\right]=\mathcal{M}(y) \mid x_{\text {prompt }}\right) \
&amp; =\frac{\exp \left(\mathbf{w}<em _MASK_="{[MASK]" _text="\text">{\mathcal{M}(y)} \cdot \mathbf{h}</em>}}\right)}{\sum_{y^{\prime} \in \mathcal{Y}} \exp \left(\mathbf{w<em _MASK_="{[MASK]" _text="\text">{\mathcal{M}\left(y^{\prime}\right)} \cdot \mathbf{h}</em>
\end{aligned}
$$}}\right)</p>
<p>where $\mathbf{h}<em v="v">{\text {[MASK] }}$ is the hidden vector of [MASK] and $\mathbf{w}</em>$ and does not introduce any new parameters. It also reduces the gap between pre-training and fine-tuning, making it more effective in few-shot scenarios.}$ denotes the pre-softmax vector corresponding to $v \in \mathcal{V}$. When supervised examples $\left{\left(x_{\text {in }}, y\right)\right}$ are available, $\mathcal{L}$ can be fine-tuned to minimize the cross-entropy loss. It is important to note that this approach re-uses the pre-trained weights $\mathbf{w}_{v</p>
<h3>4.2 Regression</h3>
<p>We assume the same basic setup as in classification, but treat the label space $\mathcal{Y}$ as a bounded interval $\left[v_{l}, v_{u}\right]$. Inspired by Mettes et al. (2019), we model the problem as an interpolation between two opposing poles, $\left{y_{l}, y_{u}\right}$, with values $v_{l}$ and $v_{u}$ respectively. For instance, we can formulate our previous sentiment analysis task as a regression problem in the range $[0,1]$, where we slide between "terrible" $\left(v_{l}=0\right)$ and "great" $\left(v_{u}=1\right)$. In this way, we can express $y$ as a mixture model:</p>
<p>$$
y=v_{l} \cdot p\left(y_{l} \mid x_{\text {in }}\right)+v_{u} \cdot p\left(y_{u} \mid x_{\text {in }}\right)
$$</p>
<p>where $p\left(y_{u} \mid x_{\text {in }}\right)$ is the probability of $y_{u}$, and $p\left(y_{l} \mid x_{\text {in }}\right)=1-p\left(y_{u} \mid x_{\text {in }}\right)$. Then we define</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Template</th>
<th style="text-align: center;">Label words</th>
<th style="text-align: center;">Accuracy</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">SST-2 (positive/negative)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">mean (std)</td>
</tr>
<tr>
<td style="text-align: left;">$<S_{1}>$ It was [MASK] .</td>
<td style="text-align: center;">great/terrible</td>
<td style="text-align: center;">$\mathbf{9 2 . 7}(\mathbf{0 . 9})$</td>
</tr>
<tr>
<td style="text-align: left;">$<S_{1}>$ It was [MASK] .</td>
<td style="text-align: center;">good/bad</td>
<td style="text-align: center;">$92.5(1.0)$</td>
</tr>
<tr>
<td style="text-align: left;">$<S_{1}>$ It was [MASK] .</td>
<td style="text-align: center;">cat/dog</td>
<td style="text-align: center;">$91.5(1.4)$</td>
</tr>
<tr>
<td style="text-align: left;">$<S_{1}>$ It was [MASK] .</td>
<td style="text-align: center;">dog/cat</td>
<td style="text-align: center;">$86.2(5.4)$</td>
</tr>
<tr>
<td style="text-align: left;">$<S_{1}>$ It was [MASK] .</td>
<td style="text-align: center;">terrible/great</td>
<td style="text-align: center;">$83.2(6.9)$</td>
</tr>
<tr>
<td style="text-align: left;">Fine-tuning</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">$81.4(3.8)$</td>
</tr>
<tr>
<td style="text-align: left;">SNLI (entailment/neutral/contradiction)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">mean (std)</td>
</tr>
<tr>
<td style="text-align: left;">$<S_{1}>$ ? [MASK], &lt;S</td>
<td style="text-align: center;">Yes/Maybe/No</td>
<td style="text-align: center;">$\mathbf{7 7 . 2 ( 3 . 7 )}$</td>
</tr>
<tr>
<td style="text-align: left;">$<S_{1}>$. [MASK], &lt;S</td>
<td style="text-align: center;">Yes/Maybe/No</td>
<td style="text-align: center;">$76.2(3.3)$</td>
</tr>
<tr>
<td style="text-align: left;">$<S_{1}>$ ? [MASK] &lt;S</td>
<td style="text-align: center;">Yes/Maybe/No</td>
<td style="text-align: center;">$74.9(3.0)$</td>
</tr>
<tr>
<td style="text-align: left;">$<S_{1}><S_{2}>$ [MASK]</td>
<td style="text-align: center;">Yes/Maybe/No</td>
<td style="text-align: center;">$65.8(2.4)$</td>
</tr>
<tr>
<td style="text-align: left;">$<S_{2}>$ ? [MASK], &lt;S</td>
<td style="text-align: center;">Yes/Maybe/No</td>
<td style="text-align: center;">$62.9(4.1)$</td>
</tr>
<tr>
<td style="text-align: left;">$<S_{1}>$ ? [MASK], &lt;S</td>
<td style="text-align: center;">Maybe/No/Yes</td>
<td style="text-align: center;">$60.6(4.8)$</td>
</tr>
<tr>
<td style="text-align: left;">Fine-tuning</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">$48.4(4.8)$</td>
</tr>
</tbody>
</table>
<p>Table 2: The impact of templates and label words on prompt-based fine-tuning $(K=16)$.
$\mathcal{M}:\left{y_{l}, y_{u}\right} \rightarrow \mathcal{V}$, and model $p\left(y_{u} \mid x_{\text {in }}\right)$ the same as Eq. (1). We fine-tune $\mathcal{L}$ to minimize the KL-divergence between the inferred $p\left(y_{u} \mid x_{\text {in }}\right)$ and the observed mixture weight, $\left(y-v_{l}\right) /\left(v_{u}-v_{l}\right)$.</p>
<h3>4.3 Manual prompts: the good and the bad</h3>
<p>The key challenge is to construct the template $\mathcal{T}$ and label words $\mathcal{M}(\mathcal{Y})$ —we refer to these two together as a prompt $\mathcal{P}$. Previous works (Schick and Schütze, 2021a,b) hand-craft both the templates and label words, which usually requires domain expertise and trial-and-error. Table 1 summarizes manual templates and label words chosen for each dataset in our experiments. These templates and label words were designed by intuition, and by considering formats used in previous literature.</p>
<p>To better understand what constitutes a good template or label word, we conduct a pilot study on SST-2 and SNLI. Table 2 shows that different prompts can lead to substantial differences in final accuracy. Specifically, when a template is fixed, the better the label words match the "semantic classes", the better the final accuracy is (great/terrible $&gt;$ good/bad $&gt;$ cat/dog). In extreme cases where we swap plausible label words (e.g., terrible/great), we achieve the worst overall performance. ${ }^{6}$ Furthermore, with the same set of label words, even a small change in the template can make a difference. For example, for SNLI, if we put [MASK] at the end, or swap sentence order, we observe a $&gt;10 \%$ drop. The above evidence clearly underlines the</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup>importance of selecting good templates and label words. Searching for prompts, however, is hard, as the search space can be very large-especially for the template. Even worse, we only have a few examples to use to guide our search, which can easily overfit. We will address these issues next.</p>
<h2>5 Automatic Prompt Generation</h2>
<p>We now explore principled ways of automating the search process for label words (§5.1) and templates (§5.2). Our goals are to reduce the human involvement required to design prompts, and to find more optimal settings than those that we manually choose. Here, we assume a classification task, but the process for regression is analogous.</p>
<h3>5.1 Automatic selection of label words</h3>
<p>We first study how to construct a label word mapping $\mathcal{M}$ that maximizes accuracy on $\mathcal{D}<em _text="\text" _train="{train">{\text {dev }}$ after fine-tuning, given a fixed template $\mathcal{T}$. Naively searching all possible assignments, however, is (1) generally intractable, as the search space is exponential in the number of classes; and (2) prone to overfitting, as we will tend to uncover spurious correlations given only a few annotations. As a simple solution, for each class $c \in \mathcal{Y}$, we construct a pruned set $\mathcal{V}^{c} \subset \mathcal{V}$ of the top $k$ vocabulary words based on their conditional likelihood using the initial $\mathcal{L}$. That is, let $\mathcal{D}</em>$ as}}^{c} \subset \mathcal{D}_{\text {train }}$ be the subset of all examples of class $c$. We take $\mathcal{V}^{c</p>
<p>$$
\operatorname{Top-} k\left{\sum_{x_{\text {in }} \in \mathcal{D}<em _mathcal_L="\mathcal{L">{\text {train }}^{c}} \log P</em>\right)\right)\right}
$$}}\left(\left[\operatorname{MASK}\right]=v \mid \mathcal{T}\left(x_{\text {in }</p>
<p>where $P_{\mathcal{L}}$ denotes the output probability distribution of $\mathcal{L}$. To further narrow down the search space, we find the top $n$ assignments over the pruned space that maximize zero-shot accuracy on $\mathcal{D}<em _dev="{dev" _text="\text">{\text {train }}$ (both $n$ and $k$ are hyper-parameters, see Appendix C.2). Then we fine-tune all top $n$ assignments, and rerank to find the best one using $\mathcal{D}</em>$. This approach is similar to the automatic verbalizer search methods in Schick and Schütze (2021a); Schick et al. (2020), except that we use a much simpler search process (brute-force) and also apply re-rankingwhich we find to be quite helpful.}</p>
<h3>5.2 Automatic generation of templates</h3>
<p>Next, we study how to generate a diverse set of templates ${\mathcal{T}}$ automatically from a fixed set of label words $\mathcal{M}(\mathcal{Y})$. To address this challenging problem, we propose to use T5 (Raffel et al., 2020),</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: Our approach for template generation.
a large pre-trained text-to-text Transformer. T5 is pre-trained to fill in missing spans (replaced by T5 mask tokens, e.g., $\langle X\rangle$ or $\langle Y\rangle$ ) in its input. For example, given the input "Thank you $\langle X\rangle$ me to your party $\langle Y\rangle$ week", T5 is trained to generate " $\langle X\rangle$ for inviting $\langle Y\rangle$ last $\langle Z\rangle$ ", meaning that "for inviting" is the replacement for $\langle X\rangle$ and "last" is the replacement for $\langle Y\rangle$. This is well suited for prompt generation: we can simply take input sentences from $\mathcal{D}_{\text {train }}$ and let the T5 model construct the template $\mathcal{T}$, without having to specify a predefined number of tokens for it.</p>
<p>Given an input example $\left(x_{\text {in }}, y\right) \in \mathcal{D}<em _mathrm_g="\mathrm{g">{\text {train }}$, we consider the following simple conversions, denoted as $\mathcal{T}</em>$}}\left(x_{\text {in }}, y\right)$, for formulating the T5 model inputs: ${ }^{7</p>
<p>$$
\begin{aligned}
&amp; \left\langle S_{1}\right\rangle \longrightarrow&lt;<em _mathrm_Y="\mathrm{Y">{\mathrm{X}}&gt;\mathcal{M}(y)&lt;</em>\right\rangle, \
&amp; \left\langle S_{1}\right\rangle \longrightarrow\left\langle S_{1}\right\rangle&lt;}}&gt;\left\langle S_{1<em _mathrm_Y="\mathrm{Y">{\mathrm{X}}&gt;\mathcal{M}(y)&lt;</em>&gt; \
&amp; \left\langle S_{1}\right\rangle,\left\langle S_{2}\right\rangle \longrightarrow\left\langle S_{1}\right\rangle&lt;}<em _mathrm_Y="\mathrm{Y">{\mathrm{X}}&gt;\mathcal{M}(y)&lt;</em>\right\rangle .
\end{aligned}
$$}}&gt;\left\langle S_{2</p>
<p>As shown in Figure 2, we rely on the T5 model to fill in the placeholders. When decoding, our goal here is to find an output that can work well for all examples in $\mathcal{D}<em _in="{in" _left_x__text="\left(x_{\text">{\text {train }}$, i.e., the output template $\mathcal{T}$ that maximizes $\sum</em>}}, y\right) \in \mathcal{D<em _mathrm_T="\mathrm{T">{\text {train }}} \log P</em>} 5}\left(\mathcal{T} \mid \mathcal{T<em _in="{in" _text="\text">{\mathrm{g}}\left(x</em>$ denotes the output probability distribution of T5. It can be decomposed according to:}}, y\right)\right)$, where $P_{\mathrm{T} 5</p>
<p>$$
\sum_{j=1}^{|\mathcal{T}|} \sum_{\left(x_{\text {in }}, y\right) \in \mathcal{D}<em _mathrm_T="\mathrm{T">{\text {train }}} \log P</em>} 5}\left(t_{j} \mid t_{1}, \ldots, t_{j-1}, \mathcal{T<em _in="{in" _text="\text">{\mathrm{g}}\left(x</em>, y\right)\right)
$$}</p>
<p>where $\left(t_{1}, \ldots, t_{|\mathcal{T}|}\right)$ are the template tokens.
We use beam search to decode multiple template candidates. Concretely, we use a wide beam width (e.g., 100) to cheaply obtain a large set of diverse templates. We then fine-tune each generated template on $\mathcal{D}<em _dev="{dev" _text="\text">{\text {train }}$ and use $\mathcal{D}</em>$ to either pick the single template with the best performance (Table 3), or}</p>
<p><sup id="fnref5:0"><a class="footnote-ref" href="#fn:0">1</a></sup>the top $k$ templates to use as an ensemble (Table 4). Though it might appear to be expensive to fine-tune the model on each individual template, this is fast in practice due to the small size of $\mathcal{D}_{\text {train }}$, and is also fully automated: making it easy to use, compared to manually tuning prompts for each dataset.</p>
<h2>6 Fine-tuning with Demonstrations</h2>
<p>In this section, we study whether we can leverage demonstrations when fine-tuning medium-sized LMs, and find better ways to exploit them.</p>
<h3>6.1 Training examples as demonstrations</h3>
<p>GPT-3's naive approach to in-context learning simply involves concatenating the input with up to 32 examples randomly drawn from the training set. This approach is suboptimal as (1) the number of available demonstrations is bounded by the model's maximum input length; ${ }^{8}$ and (2) mixing numerous random examples from different classes together creates extremely long contexts which can be hard to leverage, especially for a smaller model. To address these issues, we propose a simpler solution: at each training step, we randomly sample one ${ }^{9}$ example $\left(x_{\text {in }}^{(c)}, y^{(c)}\right) \in \mathcal{D}<em _in="{in" _text="\text">{\text {train }}$ from each class, convert it into $\mathcal{T}\left(x</em>$ (Figure 1(c)):}}^{(c)}\right)$ with [MASK] replaced by $\mathcal{M}\left(y^{(c)}\right)$ —we denote this as $\hat{\mathcal{T}}\left(x_{\text {in }}^{(c)}, y^{(c)}\right)$ —and then concatenate them with $x_{\text {in }</p>
<p>$$
\mathcal{T}\left(x_{\text {in }}\right) \oplus \hat{\mathcal{T}}\left(x_{\text {in }}^{(1)}, y^{(1)}\right) \oplus \cdots \oplus \hat{\mathcal{T}}\left(x_{\text {in }}^{(\mathcal{Y})}, y^{(\mathcal{Y} \mid)}\right)
$$</p>
<p>Here $\oplus$ denotes concatenation of input sequences. During both training and inference we sample multiple demonstration sets for each $x_{\text {in }}$. Note that both $x_{\text {in }}$ and demonstration examples are sampled from the same set $\mathcal{D}<em _text="\text" _train="{train">{\text {train }}$ during training. At testing time, we still sample demonstration sets from $\mathcal{D}</em>$ and ensemble predictions across all sets.}</p>
<h3>6.2 Sampling similar demonstrations</h3>
<p>We observe that controlling the construction of the demonstration examples $\left{\left(x_{\text {in }}^{(c)}, y^{(c)}\right)\right}$ is crucial for good final performance. For example, if the set of contrastive demonstrations $x_{\text {in }}^{(c)}$ are all dramatically different-from each other, or from the query $x_{\text {in }}$-then it becomes challenging for the language model to decipher meaningful patterns. As a result, the model may simply ignore</p>
<p><sup id="fnref2:1"><a class="footnote-ref" href="#fn:1">2</a></sup></p>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">SST-2 <br> (acc)</th>
<th style="text-align: center;">SST-5 <br> (acc)</th>
<th style="text-align: center;">MR <br> (acc)</th>
<th style="text-align: center;">CR <br> (acc)</th>
<th style="text-align: center;">MPQA <br> (acc)</th>
<th style="text-align: center;">Subj <br> (acc)</th>
<th style="text-align: center;">TREC <br> (acc)</th>
<th style="text-align: center;">CoLA <br> (Matt.)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Majority ${ }^{\dagger}$</td>
<td style="text-align: center;">50.9</td>
<td style="text-align: center;">23.1</td>
<td style="text-align: center;">50.0</td>
<td style="text-align: center;">50.0</td>
<td style="text-align: center;">50.0</td>
<td style="text-align: center;">50.0</td>
<td style="text-align: center;">18.8</td>
<td style="text-align: center;">0.0</td>
</tr>
<tr>
<td style="text-align: center;">Prompt-based zero-shot ${ }^{\ddagger}$</td>
<td style="text-align: center;">83.6</td>
<td style="text-align: center;">35.0</td>
<td style="text-align: center;">80.8</td>
<td style="text-align: center;">79.5</td>
<td style="text-align: center;">67.6</td>
<td style="text-align: center;">51.4</td>
<td style="text-align: center;">32.0</td>
<td style="text-align: center;">2.0</td>
</tr>
<tr>
<td style="text-align: center;">"GPT-3" in-context learning</td>
<td style="text-align: center;">84.8 (1.3)</td>
<td style="text-align: center;">30.6 (0.9)</td>
<td style="text-align: center;">80.5 (1.7)</td>
<td style="text-align: center;">87.4 (0.8)</td>
<td style="text-align: center;">63.8 (2.1)</td>
<td style="text-align: center;">53.6 (1.0)</td>
<td style="text-align: center;">26.2 (2.4)</td>
<td style="text-align: center;">-1.5 (2.4)</td>
</tr>
<tr>
<td style="text-align: center;">Fine-tuning</td>
<td style="text-align: center;">81.4 (3.8)</td>
<td style="text-align: center;">43.9 (2.0)</td>
<td style="text-align: center;">76.9 (5.9)</td>
<td style="text-align: center;">75.8 (3.2)</td>
<td style="text-align: center;">72.0 (3.8)</td>
<td style="text-align: center;">90.8 (1.8)</td>
<td style="text-align: center;">88.8 (2.1)</td>
<td style="text-align: center;">33.9 (14.3)</td>
</tr>
<tr>
<td style="text-align: center;">Prompt-based FT (man)</td>
<td style="text-align: center;">92.7 (0.9)</td>
<td style="text-align: center;">47.4 (2.5)</td>
<td style="text-align: center;">87.0 (1.2)</td>
<td style="text-align: center;">90.3 (1.0)</td>
<td style="text-align: center;">84.7 (2.2)</td>
<td style="text-align: center;">91.2 (1.1)</td>
<td style="text-align: center;">84.8 (5.1)</td>
<td style="text-align: center;">9.3 (7.3)</td>
</tr>
<tr>
<td style="text-align: center;">+ demonstrations</td>
<td style="text-align: center;">92.6 (0.5)</td>
<td style="text-align: center;">50.6 (1.4)</td>
<td style="text-align: center;">86.6 (2.2)</td>
<td style="text-align: center;">90.2 (1.2)</td>
<td style="text-align: center;">87.0 (1.1)</td>
<td style="text-align: center;">92.3 (0.8)</td>
<td style="text-align: center;">87.5 (3.2)</td>
<td style="text-align: center;">18.7 (8.8)</td>
</tr>
<tr>
<td style="text-align: center;">Prompt-based FT (auto)</td>
<td style="text-align: center;">92.3 (1.0)</td>
<td style="text-align: center;">49.2 (1.6)</td>
<td style="text-align: center;">85.5 (2.8)</td>
<td style="text-align: center;">89.0 (1.4)</td>
<td style="text-align: center;">85.8 (1.9)</td>
<td style="text-align: center;">91.2 (1.1)</td>
<td style="text-align: center;">88.2 (2.0)</td>
<td style="text-align: center;">14.0 (14.1)</td>
</tr>
<tr>
<td style="text-align: center;">+ demonstrations</td>
<td style="text-align: center;">93.0 (0.6)</td>
<td style="text-align: center;">49.5 (1.7)</td>
<td style="text-align: center;">87.7 (1.4)</td>
<td style="text-align: center;">91.0 (0.9)</td>
<td style="text-align: center;">86.5 (2.6)</td>
<td style="text-align: center;">91.4 (1.8)</td>
<td style="text-align: center;">89.4 (1.7)</td>
<td style="text-align: center;">21.8 (15.9)</td>
</tr>
<tr>
<td style="text-align: center;">Fine-tuning (full) ${ }^{\ddagger}$</td>
<td style="text-align: center;">95.0</td>
<td style="text-align: center;">58.7</td>
<td style="text-align: center;">90.8</td>
<td style="text-align: center;">89.4</td>
<td style="text-align: center;">87.8</td>
<td style="text-align: center;">97.0</td>
<td style="text-align: center;">97.4</td>
<td style="text-align: center;">62.6</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">MNLI <br> (acc)</td>
<td style="text-align: center;">MNLI-mm <br> (acc)</td>
<td style="text-align: center;">SNLI <br> (acc)</td>
<td style="text-align: center;">QNLI <br> (acc)</td>
<td style="text-align: center;">RTE <br> (acc)</td>
<td style="text-align: center;">MRPC <br> (F1)</td>
<td style="text-align: center;">QQP <br> (F1)</td>
<td style="text-align: center;">STS-B <br> (Pear.)</td>
</tr>
<tr>
<td style="text-align: center;">Majority ${ }^{\dagger}$</td>
<td style="text-align: center;">32.7</td>
<td style="text-align: center;">33.0</td>
<td style="text-align: center;">33.8</td>
<td style="text-align: center;">49.5</td>
<td style="text-align: center;">52.7</td>
<td style="text-align: center;">81.2</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">Prompt-based zero-shot ${ }^{\ddagger}$</td>
<td style="text-align: center;">50.8</td>
<td style="text-align: center;">51.7</td>
<td style="text-align: center;">49.5</td>
<td style="text-align: center;">50.8</td>
<td style="text-align: center;">51.3</td>
<td style="text-align: center;">61.9</td>
<td style="text-align: center;">49.7</td>
<td style="text-align: center;">-3.2</td>
</tr>
<tr>
<td style="text-align: center;">"GPT-3" in-context learning</td>
<td style="text-align: center;">52.0 (0.7)</td>
<td style="text-align: center;">53.4 (0.6)</td>
<td style="text-align: center;">47.1 (0.6)</td>
<td style="text-align: center;">53.8 (0.4)</td>
<td style="text-align: center;">60.4 (1.4)</td>
<td style="text-align: center;">45.7 (6.0)</td>
<td style="text-align: center;">36.1 (5.2)</td>
<td style="text-align: center;">14.3 (2.8)</td>
</tr>
<tr>
<td style="text-align: center;">Fine-tuning</td>
<td style="text-align: center;">45.8 (6.4)</td>
<td style="text-align: center;">47.8 (6.8)</td>
<td style="text-align: center;">48.4 (4.8)</td>
<td style="text-align: center;">60.2 (6.5)</td>
<td style="text-align: center;">54.4 (3.9)</td>
<td style="text-align: center;">76.6 (2.5)</td>
<td style="text-align: center;">60.7 (4.3)</td>
<td style="text-align: center;">53.5 (8.5)</td>
</tr>
<tr>
<td style="text-align: center;">Prompt-based FT (man)</td>
<td style="text-align: center;">68.3 (2.3)</td>
<td style="text-align: center;">70.5 (1.9)</td>
<td style="text-align: center;">77.2 (3.7)</td>
<td style="text-align: center;">64.5 (4.2)</td>
<td style="text-align: center;">69.1 (3.6)</td>
<td style="text-align: center;">74.5 (5.3)</td>
<td style="text-align: center;">65.5 (5.3)</td>
<td style="text-align: center;">71.0 (7.0)</td>
</tr>
<tr>
<td style="text-align: center;">+ demonstrations</td>
<td style="text-align: center;">70.7 (1.3)</td>
<td style="text-align: center;">72.0 (1.2)</td>
<td style="text-align: center;">79.7 (1.5)</td>
<td style="text-align: center;">69.2 (1.9)</td>
<td style="text-align: center;">68.7 (2.3)</td>
<td style="text-align: center;">77.8 (2.0)</td>
<td style="text-align: center;">69.8 (1.8)</td>
<td style="text-align: center;">73.5 (5.1)</td>
</tr>
<tr>
<td style="text-align: center;">Prompt-based FT (auto)</td>
<td style="text-align: center;">68.3 (2.5)</td>
<td style="text-align: center;">70.1 (2.6)</td>
<td style="text-align: center;">77.1 (2.1)</td>
<td style="text-align: center;">68.3 (7.4)</td>
<td style="text-align: center;">73.9 (2.2)</td>
<td style="text-align: center;">76.2 (2.3)</td>
<td style="text-align: center;">67.0 (3.0)</td>
<td style="text-align: center;">75.0 (3.3)</td>
</tr>
<tr>
<td style="text-align: center;">+ demonstrations</td>
<td style="text-align: center;">70.0 (3.6)</td>
<td style="text-align: center;">72.0 (3.1)</td>
<td style="text-align: center;">77.5 (3.5)</td>
<td style="text-align: center;">68.5 (5.4)</td>
<td style="text-align: center;">71.1 (5.3)</td>
<td style="text-align: center;">78.1 (3.4)</td>
<td style="text-align: center;">67.7 (5.8)</td>
<td style="text-align: center;">76.4 (6.2)</td>
</tr>
<tr>
<td style="text-align: center;">Fine-tuning (full) ${ }^{\ddagger}$</td>
<td style="text-align: center;">89.8</td>
<td style="text-align: center;">89.5</td>
<td style="text-align: center;">92.6</td>
<td style="text-align: center;">93.3</td>
<td style="text-align: center;">80.9</td>
<td style="text-align: center;">91.4</td>
<td style="text-align: center;">81.7</td>
<td style="text-align: center;">91.9</td>
</tr>
</tbody>
</table>
<p>Table 3: Our main results using RoBERTa-large. $\dagger$ : full training set is used (see dataset sizes in Table B.1); $\ddagger$ : no training examples are used; otherwise we use $K=16$ (per class) for few-shot experiments. We report mean (and standard deviation) performance over 5 different splits (§3). Majority: majority class; FT: fine-tuning; man: manual prompt (Table 1); auto: automatically searched templates (§5.2); "GPT-3" in-context learning: using the in-context learning proposed in Brown et al. (2020) with RoBERTa-large (no parameter updates).
the context, or even get confused by the additional examples. To address this issue, we devise a simple strategy in which we only sample examples that are semantically close to $x_{\text {in }}$. Specifically, we use a pre-trained SBERT (Reimers and Gurevych, 2019) model to obtain embeddings for all input sentences (for sentence-pair tasks, we use the concatenation of the two sentences). Here we just feed the raw sentences without the templates into SBERT. For each query $x_{\text {in }}$ and each label $c \in \mathcal{Y}$, we sort all training instances with the label $x \in \mathcal{D}<em _in="{in" _text="\text">{\text {train }}^{c}$ by their similarity score to the query $\cos \left(\mathbf{e}\left(x</em>(x)\right)$, and only sample from the top $r=50 \%$ instances for each class to use as demonstrations.}}\right), \mathbf{e</p>
<h2>7 Experiments</h2>
<p>We present our main results, and address several research questions pertaining to our LM-BFF approach. Implementation details are in Appendix C.</p>
<h3>7.1 Main results</h3>
<p>We use a RoBERTa-large model and set $K=$ 16 in our experiments. A comparison of using RoBERTa vs BERT can be found in Appendix D. For automatic prompt search, in our main table
we report automatic template search only (which consistently performs the best, see Table 5). To put our results in perspective, we compare to a number of baselines, namely (1) standard fine-tuning in our few-shot setting; (2) standard fine-tuning using the full training set; (3) simply taking the most frequent class (measured on the full training set); (4) prompt-based zero-shot prediction where we take our manual prompts and use $\mathcal{L}$ "out-of-thebox" without using any training examples; and (5) "GPT-3" in-context learning, where we use the same prompt-based zero-shot setting, but augment the context with randomly sampled 32 demonstrations (and still use RoBERTa-large, not GPT-3).</p>
<p>Single-prompt results. Table 3 shows our main results using a single prompt, either from our manually designed ones (Table 1), or the best generated ones. First, prompt-based zero-shot prediction achieves much better performance than the majority class, showing the pre-encoded knowledge in RoBERTa. Also, "GPT-3" in-context learning does not always improve over zero-shot prediction, likely because smaller language models are not expressive enough to use off-the-shelf like GPT-3.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Prompt-based Fine-tuning</th>
<th style="text-align: center;">MNLI</th>
<th style="text-align: center;">RTE</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Our single manual $\mathcal{P}$</td>
<td style="text-align: center;">$68.3(2.3)$</td>
<td style="text-align: center;">$69.1(3.6)$</td>
</tr>
<tr>
<td style="text-align: left;">$\mathcal{P}_{\text {PET }}$</td>
<td style="text-align: center;">$71.9(1.5)$</td>
<td style="text-align: center;">$69.2(4.0)$</td>
</tr>
<tr>
<td style="text-align: left;">$\mathcal{P}_{\text {ours }},</td>
<td style="text-align: center;">\mathcal{P}_{\text {ours }}</td>
<td style="text-align: center;">=\left</td>
</tr>
<tr>
<td style="text-align: left;">+ demonstrations</td>
<td style="text-align: center;">$74.0(1.9)$</td>
<td style="text-align: center;">$71.9(4.6)$</td>
</tr>
<tr>
<td style="text-align: left;">$\mathcal{P}_{\text {ours }},\left</td>
<td style="text-align: center;">\mathcal{P}_{\text {ours }}\right</td>
<td style="text-align: center;">=20$</td>
</tr>
<tr>
<td style="text-align: left;">+ demonstrations</td>
<td style="text-align: center;">$\mathbf{7 5 . 4}(1.6)$</td>
<td style="text-align: center;">$72.3(4.5)$</td>
</tr>
</tbody>
</table>
<p>Table 4: Ensemble models using manual prompts from PET (Schick and Schütze, 2021a,b) and our automatic templates. PET uses 4 prompts for MNLI and 5 for RTE. We also use an equal number of templates in $\left|\mathcal{P}<em _PET="{PET" _text="\text">{\text {ours }}\right|=\left|\mathcal{P}</em>\right|$ for a fair comparison.}</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: center;">SST-2</th>
<th style="text-align: center;">SNLI</th>
<th style="text-align: center;">TREC</th>
<th style="text-align: center;">MRPC</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Manual</td>
<td style="text-align: center;">$\mathbf{9 2 . 7}$</td>
<td style="text-align: center;">$\mathbf{7 7 . 2}$</td>
<td style="text-align: center;">84.8</td>
<td style="text-align: center;">74.5</td>
</tr>
<tr>
<td style="text-align: left;">Auto T</td>
<td style="text-align: center;">92.3</td>
<td style="text-align: center;">77.1</td>
<td style="text-align: center;">88.2</td>
<td style="text-align: center;">76.2</td>
</tr>
<tr>
<td style="text-align: left;">Auto L</td>
<td style="text-align: center;">91.5</td>
<td style="text-align: center;">75.6</td>
<td style="text-align: center;">87.0</td>
<td style="text-align: center;">$\mathbf{7 7 . 2}$</td>
</tr>
<tr>
<td style="text-align: left;">Auto T + L</td>
<td style="text-align: center;">92.1</td>
<td style="text-align: center;">77.0</td>
<td style="text-align: center;">$\mathbf{8 9 . 2}$</td>
<td style="text-align: center;">74.0</td>
</tr>
</tbody>
</table>
<p>Table 5: Comparison between manual prompts and different automatic prompt generation methods: autogenerated templates (Auto T), auto-generated label words (Auto L), and their combination (Auto T + L).</p>
<p>Second, prompt-based fine-tuning can greatly outperform standard fine-tuning, both when using a manual prompt or a generated one. CoLA is one interesting exception, as the input may be a nongrammatical sentence which is out of the distribution of $\mathcal{L}$. Generally, our automatically searched templates can achieve comparable or even higher results than manual ones, especially for tasks in which constructing strong manual templates is less intuitive (e.g., TREC, QNLI and MRPC).</p>
<p>Finally, using demonstrations in context leads to consistent gains in a majority of tasks. In summary, our combined solution-fine-tuning with automatically searched templates and sampled demonstration sets-achieves a $30 \%$ gain on SNLI compared to standard fine-tuning, and $11 \%$ gain on average.</p>
<p>Ensemble results. An advantage of automatic prompt search is that we can generate as many prompts as we want, train individual models, and create large ensembles. PET (Schick and Schütze, 2021a,b) also ensembles multiple models trained with manual prompts. ${ }^{10}$ In Table 4, we make a direct comparison of our searched prompts and PET's manual prompts on MNLI and RTE (two</p>
<p><sup id="fnref6:0"><a class="footnote-ref" href="#fn:0">1</a></sup>| SST-2 | (positive/negative) |
| :--: | :--: |
| Auto T | $\mathcal{M}(\mathcal{Y})={$ great, terrible $}$ <br> #1. $<S_{1}>$ A [MASK] one . <br> #2. $<S_{1}>$ A [MASK] piece . <br> #3. $<S_{1}>$ All in all [MASK] . |
| Auto L | $\mathcal{T}\left(x_{\text {in }}\right)=<S_{1}>$ It was [MASK]. <br> #1. irresistible/pathetic <br> #2. wonderful/bad <br> #3. delicious/bad |
| SNLI | (entailment/neutral/contradiction) |
| Auto T | $\mathcal{M}(\mathcal{Y})={$ Yes, Maybe, No $}$ <br> #1. $<S_{1}>$. [MASK], no , $<S_{2}>$ <br> #2. $<S_{1}>$. [MASK], in this case $<S_{2}>$ <br> #3. $<S_{1}>$. [MASK] this time $<S_{2}>$ |
| Auto L | $\mathcal{T}\left(x_{\text {in }}\right)=<S_{1}>$ ? [MASK], $<S_{2}>$ <br> #1. Alright/Watch/Except <br> #2. Hi/Watch/Worse <br> #3. Regardless/Fortunately/Unless |</p>
<p>Table 6: Examples of our automatically generated templates (Auto T) and label words (Auto L).
datasets that we evaluate in common). ${ }^{11}$ As the results show, an ensemble with multiple templates always improves performance. An ensemble of the same number of automatic templates achieves comparable or better performance than the ensemble of PET's manual prompts. Increasing the number of automatic templates brings further gains.</p>
<h3>7.2 Analysis of generated prompts</h3>
<p>Table 5 gives the results of using manual vs automatic prompts. For automatic prompts, we compare template search (Auto T), label word search (Auto L), and a joint variant (Auto T + L) in which we start from manual label words, apply Auto T, and then Auto L. In most cases, Auto T achieves comparable or higher performance than manual ones, and is consistently the best variant. Auto L outperforms manual prompts on TREC and MRPC—but is considerably worse on SNLI. Auto $\mathrm{T}+\mathrm{L}$ is often better than Auto L, but only sometimes better than Auto T. Table 6 shows examples from Auto T and Auto L (A full list in Appendix E). Auto T templates generally fit the context and label words well, but can contain biased peculiarities (e.g., " ${$ Yes/No $}$, no" in SNLI). For Auto L words, things are mixed: while most look intuitively reasonable, there are also some mysterious abnormalities (e.g., "Hi" for the "entailment" class in SNLI).</p>
<p><sup id="fnref3:1"><a class="footnote-ref" href="#fn:1">2</a></sup></p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: center;">SST-2</th>
<th style="text-align: center;">SNLI</th>
<th style="text-align: center;">TREC</th>
<th style="text-align: center;">MRPC</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Prompt-based FT</td>
<td style="text-align: center;">$\mathbf{9 2 . 7}$</td>
<td style="text-align: center;">77.2</td>
<td style="text-align: center;">84.8</td>
<td style="text-align: center;">74.5</td>
</tr>
<tr>
<td style="text-align: left;">Uniform sampling</td>
<td style="text-align: center;">92.3</td>
<td style="text-align: center;">78.8</td>
<td style="text-align: center;">85.6</td>
<td style="text-align: center;">70.9</td>
</tr>
<tr>
<td style="text-align: left;">+ RoBERTa sel.</td>
<td style="text-align: center;">$\mathbf{9 2 . 7}$</td>
<td style="text-align: center;">79.5</td>
<td style="text-align: center;">83.4</td>
<td style="text-align: center;">76.6</td>
</tr>
<tr>
<td style="text-align: left;">+ SBERT sel.</td>
<td style="text-align: center;">92.6</td>
<td style="text-align: center;">$\mathbf{7 9 . 7}$</td>
<td style="text-align: center;">$\mathbf{8 7 . 5}$</td>
<td style="text-align: center;">$\mathbf{7 7 . 8}$</td>
</tr>
</tbody>
</table>
<p>Table 7: Impact of demonstration sampling strategies. Uniform sampling randomly samples demonstrations, while selective (sel.) sampling only takes top sentences measured by the sentence encoders (§6).</p>
<h3>7.3 Analysis of demonstration sampling</h3>
<p>Table 7 compares the performance of demonstrations using uniform sampling to selective sampling by SBERT. We acknowledge that SBERT is trained on SNLI and MNLI datasets, thus we also tried a simple sentence encoder using mean pooling of hidden representations from RoBERTa-large. We find that in either case, using selective sampling outperforms uniform sampling, highlighting the importance of sampling similar examples for incorporating demonstrations in context.</p>
<h3>7.4 Sample efficiency</h3>
<p>Figure 3 illustrates how standard fine-tuning and our LM-BFF compare as $K$ increases. For a simple task such as SST-2 (also see MR, CR and MPQA in Table 3), despite using only 32 total examples, LMBFF has already nearly saturated its performance and is comparable to standard fine-tuning over the entire dataset. On the harder task of SNLI, LMBFF continues to improve as $K$ increases while still maintaining a performance gap over standard finetuning, until the two converge around $K=256$.</p>
<h2>8 Discussion</h2>
<p>Reformulating NLP tasks as MLM has exciting implications for few-shot learning, but also has limitations. First, while LM-BFF greatly outperforms standard fine-tuning, Table 3 shows that, overall, the performance still substantially lags behind finetuning with thousands of examples, especially for harder tasks. Additionally, just like standard finetuning, our results also suffer from high variance. As described in $\S 2$, several recent studies have tried to counter instability in few-shot fine-tuning and we expect these methods to also help here.</p>
<p>With respect to automatic prompt generation, despite its effectiveness, we still find it practically challenging to expand the search space, or generalize well based on only approximately 32 examples.
<img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: Standard fine-tuning vs our LM-BFF as a function of $K$ (# instances per class). For lower $K$, our method consistently outperforms standard fine-tuning.</p>
<p>This is partly due to our lingering reliance on some manual design-either manual templates (for label word search) or manual label words (for template search), which allows us to get our search off the ground, but does also bias it towards areas of the search space that we might have already imagined.</p>
<p>Finally, it is important to clarify that LM-BFF favors certain tasks which (1) can be naturally posed as a "fill-in-the-blank" problem; (2) have relatively short input sequences; and (3) do not contain many output classes. Issues (2) and (3) might be ameliorated with longer-context language models (e.g., Beltagy et al., 2020). For tasks that are not straightforward to formulate in prompting, such as structured prediction, issue (1) is more fundamental. We leave it as an open question for future work.</p>
<h2>9 Conclusion</h2>
<p>In this paper we presented LM-BFF, a set of simple but effective techniques for fine-tuning language models using only a few examples. Our approach proposes to (1) use prompt-based finetuning with automatically searched prompts; and (2) include selected task demonstrations (training examples) as part of the input context. We show that our method outperforms vanilla fine-tuning by up to $30 \%$ (and $11 \%$ on average). We concluded by discussing the limitations of our approach, and posed open questions for future study.</p>
<h2>Acknowledgements</h2>
<p>We thank the members of Princeton, MIT, Tsinghua NLP groups and the anonymous reviewers for their valuable feedback. TG is supported by a Graduate Fellowship at Princeton University and AF is supported by an NSF Graduate Research Fellowship. This research is also partly supported by a Google Research Scholar Award.</p>
<h2>References</h2>
<p>Trapit Bansal, Rishikesh Jha, and Andrew McCallum. 2020a. Learning to few-shot learn across diverse natural language classification tasks. In International Conference on Computational Linguistics (COLING).</p>
<p>Trapit Bansal, Rishikesh Jha, Tsendsuren Munkhdalai, and Andrew McCallum. 2020b. Self-supervised meta-learning for few-shot natural language classification tasks. In Empirical Methods in Natural Language Processing (EMNLP).</p>
<p>Yujia Bao, Menghua Wu, Shiyu Chang, and Regina Barzilay. 2020. Few-shot text classification with distributional signatures. In International Conference on Learning Representations (ICLR).</p>
<p>Roy Bar Haim, Ido Dagan, Bill Dolan, Lisa Ferro, Danilo Giampiccolo, Bernardo Magnini, and Idan Szpektor. 2006. The second PASCAL recognising textual entailment challenge.</p>
<p>Iz Beltagy, Matthew E. Peters, and Arman Cohan. 2020. Longformer: The long-document Transformer. arXiv:2004.05150.</p>
<p>Luisa Bentivogli, Peter Clark, Ido Dagan, and Danilo Giampiccolo. 2009. The fifth PASCAL recognizing textual entailment challenge. In TAC.</p>
<p>Samuel Bowman, Gabor Angeli, Christopher Potts, and Christopher D Manning. 2015. A large annotated corpus for learning natural language inference. In Empirical Methods in Natural Language Processing (EMNLP).</p>
<p>Tom B Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, et al. 2020. Language models are few-shot learners. In Advances in Neural Information Processing Systems (NeurIPS).</p>
<p>Daniel Cer, Mona Diab, Eneko Agirre, Iñigo LopezGazpio, and Lucia Specia. 2017. SemEval-2017 task 1: Semantic textual similarity multilingual and crosslingual focused evaluation. In the 11th International Workshop on Semantic Evaluation (SemEval2017).</p>
<p>Jiaao Chen, Zichao Yang, and Diyi Yang. 2020. MixText: Linguistically-informed interpolation of hidden space for semi-supervised text classification. In Association for Computational Linguistics (ACL).</p>
<p>Ido Dagan, Oren Glickman, and Bernardo Magnini. 2005. The PASCAL recognising textual entailment challenge. In the First International Conference on Machine Learning Challenges: Evaluating Predictive Uncertainty Visual Object Classification, and Recognizing Textual Entailment.</p>
<p>Joe Davison, Joshua Feldman, and Alexander M Rush. 2019. Commonsense knowledge mining from pretrained models. In Empirical Methods in Natural Language Processing (EMNLP).</p>
<p>Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2019. BERT: Pre-training of deep bidirectional Transformers for language understanding. In North American Chapter of the Association for Computational Linguistics (NAACL).</p>
<p>Jesse Dodge, Gabriel Ilharco, Roy Schwartz, Ali Farhadi, Hannaneh Hajishirzi, and Noah Smith. 2020. Fine-tuning pretrained language models: Weight initializations, data orders, and early stopping. arXiv preprint arXiv:2002.06305.</p>
<p>William B. Dolan and Chris Brockett. 2005. Automatically constructing a corpus of sentential paraphrases. In the Third International Workshop on Paraphrasing (IWP2005).</p>
<p>Danilo Giampiccolo, Bernardo Magnini, Ido Dagan, and Bill Dolan. 2007. The third PASCAL recognizing textual entailment challenge. In the ACLPASCAL Workshop on Textual Entailment and Paraphrasing.</p>
<p>Xu Han, Hao Zhu, Pengfei Yu, Ziyun Wang, Yuan Yao, Zhiyuan Liu, and Maosong Sun. 2018. Fewrel: A large-scale supervised few-shot relation classification dataset with state-of-the-art evaluation. In Empirical Methods in Natural Language Processing (EMNLP).</p>
<p>Jeremy Howard and Sebastian Ruder. 2018. Universal language model fine-tuning for text classification. In Association for Computational Linguistics (ACL).</p>
<p>Minqing Hu and Bing Liu. 2004. Mining and summarizing customer reviews. In ACM SIGKDD international conference on Knowledge discovery and data mining.</p>
<p>Zhengbao Jiang, Frank F Xu, Jun Araki, and Graham Neubig. 2020. How can we know what language models know? Transactions of the Association of Computational Linguistics (TACL).</p>
<p>Cheolhyoung Lee, Kyunghyun Cho, and Wanmo Kang. 2020. Mixout: Effective regularization to finetune large-scale pretrained language models. In International Conference on Learning Representations (ICLR).</p>
<p>Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Danqi Chen, Omer Levy, Mike Lewis, Luke Zettlemoyer, and Veselin Stoyanov. 2019. RoBERTa: A robustly optimized BERT pretraining approach. arXiv preprint arXiv:1907.11692.</p>
<p>Pascal Mettes, Elise van der Pol, and Cees Snoek. 2019. Hyperspherical prototype networks. In Advances in Neural Information Processing Systems (NeurIPS).</p>
<p>Takeru Miyato, Andrew M Dai, and Ian Goodfellow. 2017. Adversarial training methods for semisupervised text classification. In International Conference on Learning Representations (ICLR).</p>
<p>Bo Pang and Lillian Lee. 2004. A sentimental education: Sentiment analysis using subjectivity summarization based on minimum cuts. In Association for Computational Linguistics (ACL).</p>
<p>Bo Pang and Lillian Lee. 2005. Seeing stars: Exploiting class relationships for sentiment categorization with respect to rating scales. In Association for Computational Linguistics (ACL).</p>
<p>Fabio Petroni, Tim Rocktäschel, Sebastian Riedel, Patrick Lewis, Anton Bakhtin, Yuxiang Wu, and Alexander Miller. 2019. Language models as knowledge bases? In Empirical Methods in Natural Language Processing (EMNLP).</p>
<p>Jason Phang, Thibault Févry, and Samuel R Bowman. 2018. Sentence encoders on STILTs: Supplementary training on intermediate labeled-data tasks. arXiv preprint arXiv:1811.01088.</p>
<p>Alec Radford, Karthik Narasimhan, Tim Salimans, and Ilya Sutskever. 2018. Improving language understanding by generative pre-training. Technical report, OpenAI.</p>
<p>Alec Radford, Jeff Wu, Rewon Child, David Luan, Dario Amodei, and Ilya Sutskever. 2019. Language models are unsupervised multitask learners. Technical report, OpenAI.</p>
<p>Colin Raffel, Noam Shazeer, Adam Roberts, Katherine Lee, Sharan Narang, Michael Matena, Yanqi Zhou, Wei Li, and Peter J Liu. 2020. Exploring the limits of transfer learning with a unified text-to-text Transformer. The Journal of Machine Learning Research (JMLR), 21(140).</p>
<p>Pranav Rajpurkar, Jian Zhang, Konstantin Lopyrev, and Percy Liang. 2016. SQuAD: 100,000+ questions for machine comprehension of text. In Empirical Methods in Natural Language Processing (EMNLP).</p>
<p>Nils Reimers and Iryna Gurevych. 2019. SentenceBERT: Sentence embeddings using Siamese BERTnetworks. In Empirical Methods in Natural Language Processing and International Joint Conference on Natural Language Processing (EMNLPIJCNLP).</p>
<p>Timo Schick, Helmut Schmid, and Hinrich Schütze. 2020. Automatically identifying words that can serve as labels for few-shot text classification. In International Conference on Computational Linguistics (COLING).</p>
<p>Timo Schick and Hinrich Schütze. 2021a. Exploiting cloze questions for few-shot text classification and natural language inference. In European Chapter of the Association for Computational Linguistics (EACL).</p>
<p>Timo Schick and Hinrich Schütze. 2021b. It's not just size that matters: Small language models are also few-shot learners. In North American Chapter of the Association for Computational Linguistics (NAACL).</p>
<p>Taylor Shin, Yasaman Razeghi, Robert L. Logan IV, Eric Wallace, and Sameer Singh. 2020. AutoPrompt: Automatic prompt construction for masked language models. In Empirical Methods in Natural Language Processing (EMNLP).</p>
<p>Richard Socher, Alex Perelygin, Jean Wu, Jason Chuang, Christopher D. Manning, Andrew Ng, and Christopher Potts. 2013. Recursive deep models for semantic compositionality over a sentiment treebank. In Empirical Methods in Natural Language Processing (EMNLP).</p>
<p>Alon Talmor, Yanai Elazar, Yoav Goldberg, and Jonathan Berant. 2020. oLMpics-on what language model pre-training captures. Transactions of the Association of Computational Linguistics (TACL), 8.</p>
<p>Trieu H Trinh and Quoc V Le. 2018. A simple method for commonsense reasoning. arXiv preprint arXiv:1806.02847.</p>
<p>Ellen M Voorhees and Dawn M Tice. 2000. Building a question answering test collection. In the 23rd annual international ACM SIGIR conference on Research and development in information retrieval.</p>
<p>Alex Wang, Amanpreet Singh, Julian Michael, Felix Hill, Omer Levy, and Samuel R Bowman. 2019. GLUE: A multi-task benchmark and analysis platform for natural language understanding. In International Conference on Learning Representations (ICLR).</p>
<p>Alex Warstadt, Amanpreet Singh, and Samuel R. Bowman. 2019. Neural network acceptability judgments. Transactions of the Association of Computational Linguistics (TACL), 7.</p>
<p>Janyce Wiebe, Theresa Wilson, and Claire Cardie. 2005. Annotating expressions of opinions and emotions in language. Language resources and evaluation, 39(2-3).</p>
<p>Adina Williams, Nikita Nangia, and Samuel Bowman. 2018. A broad-coverage challenge corpus for sentence understanding through inference. In North American Chapter of the Association for Computational Linguistics: Human Language Technologies (NAACL-HLT).</p>
<p>Qizhe Xie, Zihang Dai, Eduard Hovy, Thang Luong, and Quoc Le. 2020. Unsupervised data augmentation for consistency training. Advances in Neural Information Processing Systems (NeurIPS), 33.</p>
<p>Wenpeng Yin, Nazneen Fatema Rajani, Dragomir Radev, Richard Socher, and Caiming Xiong. 2020. Universal natural language processing with limited annotations: Try few-shot textual entailment as a start. In Empirical Methods in Natural Language Processing (EMNLP).</p>
<p>Mo Yu, Xiaoxiao Guo, Jinfeng Yi, Shiyu Chang, Saloni Potdar, Yu Cheng, Gerald Tesauro, Haoyu Wang,</p>
<p>and Bowen Zhou. 2018. Diverse few-shot text classification with multiple metrics. In North American Chapter of the Association for Computational Linguistics (NAACL).</p>
<p>Tianyi Zhang, Felix Wu, Arzoo Katiyar, Kilian Q Weinberger, and Yoav Artzi. 2021. Revisiting fewsample BERT fine-tuning. In International Conference on Learning Representations (ICLR).</p>
<p>Zexuan Zhong, Dan Friedman, and Danqi Chen. 2021. Factual probing is [MASK]: Learning vs. learning to recall. In North American Association for Computational Linguistics (NAACL).</p>
<h1>A Impact of Development Sets</h1>
<p>Table A. 1 shows how the size of the development sets can affect the final performance of the model. For "No $\mathcal{D}<em _text="\text" _train="{train">{\text {dev }}$ ", we take the same hyper-parameters from Schick and Schütze (2021a,b): batch size $=$ 16, learning rate $=1 \mathrm{e}-5$ and training steps $=250$. We also experiment with a variant that we sample a development set of 10 times larger than the training set. We can see that using larger development sets leads to better performance, and this is why we stick to $\left|\mathcal{D}</em>\right|$ in our few-shot setting.}}\right|=\left|\mathcal{D}_{\text {dev }</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Fine-tuning</th>
<th style="text-align: center;">SST-2</th>
<th style="text-align: center;">SNLI</th>
<th style="text-align: center;">TREC</th>
<th style="text-align: center;">MRPC</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">No $\mathcal{D}_{\text {dev }}$</td>
<td style="text-align: center;">79.5</td>
<td style="text-align: center;">49.2</td>
<td style="text-align: center;">83.9</td>
<td style="text-align: center;">77.8</td>
</tr>
<tr>
<td style="text-align: left;">$\left\lvert\, \mathcal{D}_{\text {dev }}\right.$</td>
<td style="text-align: center;">$=\left\lvert\, \mathcal{D}_{\text {train }}\right.$</td>
<td style="text-align: center;">81.4</td>
<td style="text-align: center;">48.4</td>
<td style="text-align: center;">88.8</td>
</tr>
<tr>
<td style="text-align: left;">$\left\lvert\, \mathcal{D}_{\text {dev }}\right.$</td>
<td style="text-align: center;">$=10\left\lvert\, \mathcal{D}_{\text {train }}\right.$</td>
<td style="text-align: center;">83.5</td>
<td style="text-align: center;">52.0</td>
<td style="text-align: center;">89.4</td>
</tr>
<tr>
<td style="text-align: left;">Prompt-based FT</td>
<td style="text-align: center;">SST-2</td>
<td style="text-align: center;">SNLI</td>
<td style="text-align: center;">TREC</td>
<td style="text-align: center;">MRPC</td>
</tr>
<tr>
<td style="text-align: left;">No $\mathcal{D}_{\text {dev }}$</td>
<td style="text-align: center;">92.1</td>
<td style="text-align: center;">75.3</td>
<td style="text-align: center;">84.8</td>
<td style="text-align: center;">70.2</td>
</tr>
<tr>
<td style="text-align: left;">$\left\lvert\, \mathcal{D}_{\text {dev }}\right.$</td>
<td style="text-align: center;">$=\left\lvert\, \mathcal{D}_{\text {train }}\right.$</td>
<td style="text-align: center;">92.7</td>
<td style="text-align: center;">77.2</td>
<td style="text-align: center;">84.8</td>
</tr>
<tr>
<td style="text-align: left;">$\left\lvert\, \mathcal{D}_{\text {dev }}\right.$</td>
<td style="text-align: center;">$=10\left\lvert\, \mathcal{D}_{\text {train }}\right.$</td>
<td style="text-align: center;">93.0</td>
<td style="text-align: center;">79.7</td>
<td style="text-align: center;">89.3</td>
</tr>
</tbody>
</table>
<p>Table A.1: Impact of different sizes of development sets. Standard deviations are omitted here to save space. For No $\left|\mathcal{D}_{\text {dev }}\right|$, we use the same set of hyper-parameters as Schick and Schütze (2021a,b).</p>
<h2>B Datasets</h2>
<p>For SNLI (Bowman et al., 2015) and datasets from GLUE (Wang et al., 2019), including SST2 (Socher et al., 2013), CoLA (Warstadt et al., 2019), MNLI (Williams et al., 2018), QNLI (Rajpurkar et al., 2016), RTE (Dagan et al., 2005; Bar Haim et al., 2006; Giampiccolo et al., 2007; Bentivogli et al., 2009), MRPC (Dolan and Brockett, 2005), QQP ${ }^{12}$ and STS-B (Cer et al., 2017), we follow Zhang et al. (2021) and use their original development sets for testing. For datasets which require a cross-validation evaluation-MR (Pang and Lee, 2005), CR (Hu and Liu, 2004), MPQA (Wiebe et al., 2005), Subj (Pang and Lee, 2004)—we simply randomly sample 2,000 examples as the testing set and leave them out from training. For SST5 (Socher et al., 2013) and TREC (Voorhees and Tice, 2000), we use their official test sets. We show dataset statistics in Table B.1.</p>
<h2>C Experimental Details</h2>
<h2>C. 1 Hyper-parameter selection</h2>
<p>For grid search, we take learning rates from ${1 \mathrm{e}-$ $5,2 \mathrm{e}-5,5 \mathrm{e}-5}$ and batch sizes from ${2,4,8}$. These</p>
<p><sup id="fnref7:0"><a class="footnote-ref" href="#fn:0">1</a></sup>numbers are picked by pilot experiments on the SST-2 and SNLI datasets. We also use early stopping to avoid overfitting. For each trial, we train the model for 1,000 steps, validate the performance every 100 steps, and take the best checkpoint.</p>
<h2>C. 2 Prompt-based fine-tuning</h2>
<p>Table 1 shows all the manual templates and label words we use in experiment. For automatically template generation, we take the T5-3B ${ }^{13}$ model, which is the largest publicly available one that can fit on a single GPU. For automatically searching label words, we set $k$ to 100 for all tasks except SST-5 and TREC. For SST-5 we set a smaller $k=30$, as it is a 5 -way classification task. For TREC, we observe that filtering $\mathcal{V}^{c}$ using conditional likelihood alone is still noisy, thus we set $k=1000$, and then re-rank $\mathcal{V}^{c}$ by the nearest neighbors of the original manual label words and take the top 30 per class. We set $n$ to 100 in all experiments. Due to the large number of trials in automatic search, we take a fixed set of hyper-parameters in this part: batch size of 8 and learning rate of $1 \mathrm{e}-5$.</p>
<p>Since the idea of prompt-based fine-tuning is to make the input and output distribution close to the pre-training, the implementation details are crucial. For templates, we put extra space before sentences if it is not at the beginning of the input. Also, we lowercase the first letter of the sentence if it is concatenated with a prefix (e.g., $<S_{2}>$ in Table 1). Also if one sentence is appended any punctuation (e.g., $<S_{1}>$ in Table 1), then the last character of the original sentence is discarded. Finally, we prepend a space for label words in $\mathcal{M}(\mathcal{Y})$. For example, we use "..great" instead of "great" in the RoBERTa vocabulary, where ".." stands for space.</p>
<h2>C. 3 Fine-tuning with demonstrations</h2>
<p>When using demonstrations, we sample 16 different sets of demonstrations for each input and average the predicted log probability for each class during inference. We find that further increasing the number of samples does not bring substantial improvement. Additional, we have tried different aggregation methods like taking the result with the maximum confidence and we did not find a meaningful improvement. For selective demonstrations, we take roberta-large-nli-stsb</p>
<p><sup id="fnref4:1"><a class="footnote-ref" href="#fn:1">2</a></sup></p>
<p>| Category | Dataset | $|\mathcal{Y}|$ | $L$ | #Train | #Test | Type | Labels (classification tasks) |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| single- <br> sentence | SST-2 | 2 | 19 | 6,920 | 872 | sentiment | positive, negative |
|  | SST-5 | 5 | 18 | 8,544 | 2,210 | sentiment | v. pos., positive, neutral, negative, v. neg. |
|  | MR | 2 | 20 | 8,662 | 2,000 | sentiment | positive, negative |
|  | CR | 2 | 19 | 1,775 | 2,000 | sentiment | positive, negative |
|  | MPQA | 2 | 3 | 8,606 | 2,000 | opinion polarity | positive, negative |
|  | Subj | 2 | 23 | 8,000 | 2,000 | subjectivity | subjective, objective |
|  | TREC | 6 | 10 | 5,452 | 500 | question cls. | abbr., entity, description, human, loc., num. |
|  | CoLA | 2 | 8 | 8,551 | 1,042 | acceptability | grammatical, not_grammatical |
| sentence- <br> pair | MNLI | 3 | 22/11 | 392,702 | 9,815 | NLI | entailment, neutral, contradiction |
|  | SNLI | 3 | 14/8 | 549,367 | 9,842 | NLI | entailment, neutral, contradiction |
|  | QNLI | 2 | 11/30 | 104,743 | 5,463 | NLI | entailment, not_entailment |
|  | RTE | 2 | 49/10 | 2,490 | 277 | NLI | entailment, not_entailment |
|  | MRPC | 2 | 22/21 | 3,668 | 408 | paraphrase | equivalent, not_equivalent |
|  | QQP | 2 | 12/12 | 363,846 | 40,431 | paraphrase | equivalent, not_equivalent |
|  | STS-B | $\mathcal{R}$ | 11/11 | 5,749 | 1,500 | sent. similarity | - |</p>
<p>Table B.1: The datasets evaluated in this work. $|\mathcal{Y}|: #$ of classes for classification tasks (with one exception: STS-B is a real-valued regression task over the interval $[0,5]$ ). $L$ : average # of words in input sentence(s). Note that we only sample $\mathcal{D}<em _dev="{dev" _text="\text">{\text {train }}$ and $\mathcal{D}</em>|$ examples from the original training set in our few-shot experiments (§3).}}$ of $K \times|\mathcal{Y</p>
<table>
<thead>
<tr>
<th style="text-align: left;">BERT-large</th>
<th style="text-align: center;">SST-2</th>
<th style="text-align: center;">SNLI</th>
<th style="text-align: center;">TREC</th>
<th style="text-align: center;">MRPC</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Fine-tuning</td>
<td style="text-align: center;">79.5</td>
<td style="text-align: center;">51.4</td>
<td style="text-align: center;">80.3</td>
<td style="text-align: center;">$\mathbf{7 4 . 4}$</td>
</tr>
<tr>
<td style="text-align: left;">Prompt-based FT</td>
<td style="text-align: center;">85.6</td>
<td style="text-align: center;">59.2</td>
<td style="text-align: center;">79.0</td>
<td style="text-align: center;">66.8</td>
</tr>
<tr>
<td style="text-align: left;">+ demo (1-seg)</td>
<td style="text-align: center;">$\mathbf{8 7 . 5}$</td>
<td style="text-align: center;">50.4</td>
<td style="text-align: center;">77.2</td>
<td style="text-align: center;">68.5</td>
</tr>
<tr>
<td style="text-align: left;">+ demo (2-seg)</td>
<td style="text-align: center;">86.1</td>
<td style="text-align: center;">$\mathbf{6 1 . 3}$</td>
<td style="text-align: center;">77.9</td>
<td style="text-align: center;">73.2</td>
</tr>
<tr>
<td style="text-align: left;">+ demo ( $n$-seg)</td>
<td style="text-align: center;">86.4</td>
<td style="text-align: center;">58.6</td>
<td style="text-align: center;">$\mathbf{7 9 . 6}$</td>
<td style="text-align: center;">71.0</td>
</tr>
<tr>
<td style="text-align: left;">RoBERTa-large</td>
<td style="text-align: center;">SST-2</td>
<td style="text-align: center;">SNLI</td>
<td style="text-align: center;">TREC</td>
<td style="text-align: center;">MRPC</td>
</tr>
<tr>
<td style="text-align: left;">Fine-tuning</td>
<td style="text-align: center;">81.4</td>
<td style="text-align: center;">48.4</td>
<td style="text-align: center;">$\mathbf{8 8 . 8}$</td>
<td style="text-align: center;">76.6</td>
</tr>
<tr>
<td style="text-align: left;">Prompt-based FT</td>
<td style="text-align: center;">$\mathbf{9 2 . 7}$</td>
<td style="text-align: center;">77.2</td>
<td style="text-align: center;">84.8</td>
<td style="text-align: center;">74.5</td>
</tr>
<tr>
<td style="text-align: left;">+ demonstrations</td>
<td style="text-align: center;">92.6</td>
<td style="text-align: center;">$\mathbf{7 9 . 7}$</td>
<td style="text-align: center;">87.5</td>
<td style="text-align: center;">$\mathbf{7 7 . 8}$</td>
</tr>
</tbody>
</table>
<p>Table D.1: A comparison of BERT-large vs RoBERTalarge. We use manual prompts in these experiments.
mean-tokens ${ }^{14}$ from Reimers and Gurevych (2019) as our sentence embedding model.</p>
<h2>D Comparisons of BERT vs RoBERTa</h2>
<p>Table D. 1 compares the results of BERT-large (uncased) and RoBERTa-large in our settings. Pretrained BERT provides two segment embeddings $(\mathrm{A} / \mathrm{B})$ for different parts of input. The common practice, when fine-tuning BERT, is that using only segment A for single-sentence tasks, and using segment A/B for the two sentences in sentence-pair tasks. In our case of incorporating demonstrations, however, we have more than two sentences. Thus we explore the following different strategies for segments: (1) using the A segment for all sentences</p>
<p><sup id="fnref8:0"><a class="footnote-ref" href="#fn:0">1</a></sup>(1-seg); (2) using the A segment for the original input and the B segment for the demonstrations (2-seg); (3) using different segment embeddings for each sentence ( $n$-seg), e.g., for SNLI, we use different segments for each premise and hypothesis in both the original input and the demonstrations, which leads to a total number of 8 segment embeddings. This introduces new segment embeddings (randomly initialized and learned during fine-tuning) as the pre-trained BERT only has two.</p>
<p>Table D. 1 shows that prompt-based fine-tuning with demonstrations also works for BERT, and 2seg works the best when incorporating demonstrations. Still, we take RoBERTa-large as our main model, for RoBERTa performs much better than BERT and RoBERTa saves the trouble to tune the usage of segment embeddings.</p>
<h2>E Generated Prompts</h2>
<p>We demonstrate the top 3 automatically generated templates and label words for all tasks in Table E.1. In general, most automatic templates are reasonable and grammatically correct. For the label words, the generated results look intuitive for most single sentence tasks. For other tasks, the automatic ones can be counterintuitive in some cases. It is still unclear why the language model picks these words and sometimes they actually work well. We leave this for future study.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Task</th>
<th style="text-align: center;">Auto template</th>
<th style="text-align: center;">Auto label words</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">SST-2</td>
<td style="text-align: center;">(positive/negative) <br> $<S_{1}>$ A [MASK] one <br> $<S_{1}>$ A [MASK] piece <br> $<S_{1}>$ All in all [MASK] .</td>
<td style="text-align: center;">irresistible/pathetic <br> wonderful/bad <br> delicious/bad</td>
</tr>
<tr>
<td style="text-align: center;">SST-5</td>
<td style="text-align: center;">(very positive/positive/neutral/negative/very negative) <br> $<S_{1}>$ The movie is [MASK] <br> $<S_{1}>$ The music is [MASK] <br> $<S_{1}>$ But it is [MASK] .</td>
<td style="text-align: center;">wonderful/remarkable/hilarious/better/awful wonderful/perfect/hilarious/better/awful unforgettable/extraordinary/good/better/terrible</td>
</tr>
<tr>
<td style="text-align: center;">MR</td>
<td style="text-align: center;">(positive/negative) <br> It was [MASK] ! $<S_{1}>$ <br> $<S_{1}>$ It's [MASK] <br> $<S_{1}>$ A [MASK] piece of work .</td>
<td style="text-align: center;">epic/terrible <br> epic/awful <br> exquisite/horrible</td>
</tr>
<tr>
<td style="text-align: center;">CR</td>
<td style="text-align: center;">(positive/negative) <br> $<S_{1}>$ It's [MASK] ! <br> $<S_{1}>$ The quality is [MASK] <br> $<S_{1}>$ That is [MASK] .</td>
<td style="text-align: center;">fantastic/horrible <br> neat/pointless <br> magnificent/unacceptable</td>
</tr>
<tr>
<td style="text-align: center;">MPQA</td>
<td style="text-align: center;">(positive/negative) <br> $<S_{1}>$ is [MASK] <br> $<S_{1}>$, [MASK] ! <br> $<S_{1}>$. [MASK] .</td>
<td style="text-align: center;">important/close needed/bad unexpected/shocking</td>
</tr>
<tr>
<td style="text-align: center;">Subj</td>
<td style="text-align: center;">(subjective/objective) <br> $<S_{1}>$ It's all [MASK] <br> $<S_{1}>$ It's [MASK] <br> $<S_{1}>$ Is it [MASK] ?</td>
<td style="text-align: center;">everywhere/tragic everywhere/horrifying something/surreal</td>
</tr>
<tr>
<td style="text-align: center;">TREC</td>
<td style="text-align: center;">(abbreviation/entity/description/human/location/numeric) <br> Q: [MASK] : $<S_{1}>$ <br> $<S_{1}>$ Why [MASK]? <br> $<S_{1}>$ Answer: [MASK] .</td>
<td style="text-align: center;">Application/Advisor/Discussion/Culture/Assignment/Minute Production/AE/Context/Artist/Assignment/Minute Personality/Advisor/Conclusion/Hum/Assignment/Minute</td>
</tr>
<tr>
<td style="text-align: center;">CoLA</td>
<td style="text-align: center;">(grammatical/not_grammatical) <br> $<S_{1}>$ You are [MASK] <br> It is [MASK] . $<S_{1}>$ <br> I am [MASK] . $<S_{1}>$</td>
<td style="text-align: center;">one/proof <br> wrong/sad <br> misleading/disappointing</td>
</tr>
<tr>
<td style="text-align: center;">MNLI</td>
<td style="text-align: center;">(entailment/neutral/contradiction) <br> $<S_{1}>$. [MASK] , you are right , $<S_{2}>$ <br> $<S_{1}>$. [MASK] you're right $<S_{2}>$ <br> $<S_{1}>$. [MASK] ! $<S_{2}>$</td>
<td style="text-align: center;">Fine/Plus/Otherwise <br> There/Plus/Otherwise <br> Meaning/Plus/Otherwise</td>
</tr>
<tr>
<td style="text-align: center;">SNLI</td>
<td style="text-align: center;">(entailment/neutral/contradiction) <br> $<S_{1}>$. [MASK] , no , $<S_{2}>$ <br> $<S_{1}>$. [MASK] , in this case $<S_{2}>$ <br> $<S_{1}>$. [MASK] this time $<S_{2}>$</td>
<td style="text-align: center;">Alright/Watch/Except <br> Hi/Watch/Worse <br> Regardless/Fortunately/Unless</td>
</tr>
<tr>
<td style="text-align: center;">QNLI</td>
<td style="text-align: center;">(entailment/not entailment) <br> $<S_{1}>$ ? [MASK] . Yes , $<S_{2}>$ <br> $<S_{1}>$ ? [MASK] . It is known that $<S_{2}>$ <br> $<S_{1}>$ ? [MASK] , however , $<S_{2}>$</td>
<td style="text-align: center;">Okay/Nonetheless <br> Notably/Yet <br> Specifically/Notably</td>
</tr>
<tr>
<td style="text-align: center;">RTE</td>
<td style="text-align: center;">(entailment/not entailment) <br> $<S_{1}>$. [MASK] , I believe $<S_{2}>$ <br> $<S_{1}>$. [MASK] , I think that $<S_{2}>$ <br> $<S_{1}>$. [MASK] , I think $<S_{2}>$</td>
<td style="text-align: center;">Clearly/Yet <br> Accordingly/meanwhile <br> So/Meanwhile</td>
</tr>
<tr>
<td style="text-align: center;">MRPC</td>
<td style="text-align: center;">(equivalent/not equivalent) <br> $<S_{1}>$. [MASK] ! $<S_{2}>$ <br> $<S_{1}>$. [MASK] . This is the first time $<S_{2}>$ <br> $<S_{1}>$. [MASK] . That's right . $<S_{2}>$</td>
<td style="text-align: center;">Rather/Alas <br> At/Thus <br> Instead/Moreover</td>
</tr>
<tr>
<td style="text-align: center;">QQP</td>
<td style="text-align: center;">(equivalent/not equivalent) <br> $<S_{1}>$ ? [MASK] , but $<S_{2}>$ <br> $<S_{1}>$ ? [MASK] , please , $<S_{2}>$ <br> $<S_{1}>$ ? [MASK] , I want to know $<S_{2}>$</td>
<td style="text-align: center;">Me/Since <br> Um/Best <br> Ironically/Beyond</td>
</tr>
<tr>
<td style="text-align: center;">STS-B</td>
<td style="text-align: center;">$(\mathrm{n}_{\mathrm{e}} / \mathrm{B})$ <br> $<S_{1}>$. [MASK] sir $<S_{2}>$ <br> $<S_{1}>$. [MASK] , it is not . $<S_{2}>$ <br> $<S_{1}>$. [MASK] . It is $<S_{2}>$</td>
<td style="text-align: center;">Note/Next <br> Yesterday/meanwhile <br> Yeah/meanwhile</td>
</tr>
</tbody>
</table>
<p>Table E.1: Top 3 automatically generated templates and label words for all tasks based on one split of $K=16$ training examples. Note that automatic template results are based on manual label words and automatic label word results are based on manual templates provided in Table 1.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{14}$ https://github.com/UKPLab/
sentence-transformers&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref5:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref6:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref7:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref8:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:1">
<p>${ }^{13}$ We take the T5 1.0 checkpoint, which is trained on both unsupervised and downstream task data. We compared it to T5 1.1 (without downstream task data) and did not find a significant difference in generated templates.&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 2 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:1" title="Jump back to footnote 2 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:1" title="Jump back to footnote 2 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:1" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>