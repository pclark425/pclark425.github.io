<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-8417 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-8417</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-8417</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-150.html">extraction-schema-150</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the memory mechanism, tasks, comparative results, ablations, and key findings.</div>
                <p><strong>Paper ID:</strong> paper-b26f2037f769d5ffc5f7bdcec2de8da28ec14bee</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/b26f2037f769d5ffc5f7bdcec2de8da28ec14bee" target="_blank">Dense Passage Retrieval for Open-Domain Question Answering</a></p>
                <p><strong>Paper Venue:</strong> Conference on Empirical Methods in Natural Language Processing</p>
                <p><strong>Paper TL;DR:</strong> This work shows that retrieval can be practically implemented using dense representations alone, where embeddings are learned from a small number of questions and passages by a simple dual-encoder framework.</p>
                <p><strong>Paper Abstract:</strong> Open-domain question answering relies on efficient passage retrieval to select candidate contexts, where traditional sparse vector space models, such as TF-IDF or BM25, are the de facto method. In this work, we show that retrieval can be practically implemented using dense representations alone, where embeddings are learned from a small number of questions and passages by a simple dual-encoder framework. When evaluated on a wide range of open-domain QA datasets, our dense retriever outperforms a strong Lucene-BM25 system largely by 9%-19% absolute in terms of top-20 passage retrieval accuracy, and helps our end-to-end QA system establish new state-of-the-art on multiple open-domain QA benchmarks.</p>
                <p><strong>Cost:</strong> 0.015</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e8417.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e8417.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the memory mechanism, tasks, comparative results, ablations, and key findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>DPR</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Dense Passage Retriever</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A retrieval component that encodes questions and passages into dense vectors (two independent BERT-base encoders) and performs retrieval by maximum inner product search over a FAISS index of passage embeddings to support open-domain question answering.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>DPR (retrieval-augmented QA pipeline)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Dual-encoder retrieval module using two independent BERT-base (uncased) encoders: one for questions E_Q and one for passages E_P. Passage vectors are precomputed and indexed; at query time a question vector retrieves top-k passages via dot product (inner product) similarity.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>BERT-base (uncased) dual encoders</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Two independent BERT-base models (768 hidden units) used to produce CLS token embeddings for question and passage; dense vectors (d=768) are stored for passages and used with FAISS for approximate nearest neighbor inner-product search.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Open-domain question answering (multiple datasets: Natural Questions, TriviaQA, WebQuestions, CuratedTREC, SQuAD v1.1)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Given a factoid question, retrieve a small set of candidate passages from a large corpus (Wikipedia split into ~21M fixed-length passages) that contain the answer span; a reader model then extracts the final answer.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>question answering (retrieval-augmented / open-domain QA)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>retrieval-augmented external database (indexed passage memory)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism</strong></td>
                            <td>Precompute dense passage embeddings with the passage encoder E_P, index them in FAISS (HNSW index), and at query time compute E_Q(q) and retrieve top-k passages by maximizing inner product (dot product) between query and passage vectors. Optionally rerank union of BM25 and DPR candidates via BM25(q,p) + lambda * sim(q,p).</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Fixed-length passage texts encoded into 768-dimensional vectors (BERT [CLS] embeddings); optionally titles prepended and passages are 100-word blocks.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>Semantic vector search (inner product / approximate nearest neighbor via FAISS HNSW); also experimented with L2 and cosine, and linear combination with BM25 scores for reranking.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>Retrieval (Natural Questions, Single dataset): Top-20 retrieval accuracy 78.4% (DPR) vs BM25 59.1%; Top-100 85.4% vs BM25 73.7%. End-to-end QA (Exact Match on NQ): DPR 41.5% vs BM25 32.6% (Table 2 & 4).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_with_without_memory</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_comparison</strong></td>
                            <td>Extensive ablations: (1) Sample efficiency: DPR trained with only 1k examples already outperforms BM25. (2) Negative sampling: in-batch negatives substantially improve performance; best setup uses in-batch gold negatives plus one BM25 hard negative. Table 3 shows adding one BM25 hard negative increases Top-5 from ~55.8% to 65.8% (depending on config) and Top-20 to ~78.0% in best setting. (3) Similarity/loss: dot product and L2 perform comparably and superior to cosine; triplet loss similar but not superior. (4) Cross-dataset: training on NQ only loses 3-5 points when applied to WebQuestions / TREC but still outperforms BM25. (5) Joint training: jointly training retriever+reader (with frozen passage encoder) yielded 39.8 EM (NQ dev), worse than the pipeline DPR+reader (41.5 EM).</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>A simple dual-encoder dense retriever trained on question–passage pairs with in-batch negatives (and a single BM25 hard negative) yields large gains over BM25 in retrieval precision and translates to higher end-to-end QA accuracy; dense retrieval can be practical and efficient when combined with FAISS and is sample-efficient with pretrained language models.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Index construction and embedding all passages is resource-intensive (computing embeddings for 21M passages ~8.8 hours on 8 GPUs; FAISS index build ~8.5 hours on a single server). DPR underperforms BM25 on SQuAD due to distributional biases and high lexical overlap in SQuAD. DPR may miss rare, highly-salient phrases that sparse methods capture (qualitative failure modes).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Dense Passage Retrieval for Open-Domain Question Answering', 'publication_date_yy_mm': '2020-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8417.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e8417.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the memory mechanism, tasks, comparative results, ablations, and key findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>ORQA</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>ORQA (Latent Retrieval for Weakly Supervised Open Domain QA)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A retrieval-augmented QA approach that uses an inverse cloze task (ICT) for pretraining and jointly trains question encoder and reader; a previous state-of-the-art dense retrieval method compared to DPR.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Latent retrieval for weakly supervised open domain question answering</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>ORQA</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Retrieval-augmented QA system that includes an ICT pretraining objective to learn passage/question encoders and performs joint fine-tuning of retriever and reader.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Uses pretrained encoders with additional ICT pretraining (predicting masked sentence blocks) and joint training of question encoder and reader; specifics are given in the ORQA paper (Lee et al., 2019).</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Open-domain question answering (Natural Questions, etc.)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Retrieve passages and extract answers in an open-domain setting; ORQA focuses on latent retrieval learned with additional pretraining.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>question answering (retrieval-augmented)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>retrieval-augmented (pretrained retrieval memory over passages)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism</strong></td>
                            <td>ICT pretraining to learn encoders that map passages and pseudo-questions to vectors used for retrieval; joint training couples retriever and reader (ORQA reindexes during training in some variants).</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Passages / sentence blocks encoded into dense vectors as learned by ICT pretraining.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>Dense retrieval using learned encoders (similarity-based nearest neighbor retrieval).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>Reported in this paper: ORQA (Single) end-to-end QA Exact Match on NQ = 33.3% (Table 4).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_with_without_memory</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_comparison</strong></td>
                            <td>Paper compares DPR to ORQA: DPR (41.5% NQ EM) outperforms ORQA (33.3% NQ EM) despite ORQA using additional pretraining (ICT). The authors note ORQA's weaknesses: ICT pretraining is computationally intensive and the context encoder is not fine-tuned directly on question–answer pairs, potentially leading to suboptimal contexts.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>ORQA showed that dense retrieval with additional pretraining can beat BM25, but DPR demonstrates that simpler fine-tuning on question–passage pairs without ICT pretraining can yield better performance on some datasets.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>ICT pretraining is computationally expensive; joint training and pretraining choices may not optimally tune the passage encoder when compared to direct fine-tuning on question–passage pairs.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Dense Passage Retrieval for Open-Domain Question Answering', 'publication_date_yy_mm': '2020-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8417.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e8417.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the memory mechanism, tasks, comparative results, ablations, and key findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>REALM</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>REALM (Retrieval-Augmented Language Model Pre-training)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A retrieval-augmented pretraining approach that integrates retrieval into language model pretraining, asynchronously tuning passage encoder by re-indexing passages during training.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>REALM: Retrieval-augmented language model pre-training</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>REALM</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>A language model pretraining framework that augments masked language model objectives with retrieved passages and updates retrieval indices during pretraining so the LM can access external knowledge via retrieval.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>REALM (pretrained retrieval-augmented LM variants)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Language models pretrained with retrieval in the loop; REALM was reported with variants pretrained on Wikipedia and CC-News and used for open-domain QA.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Open-domain question answering / knowledge-intensive tasks</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Leverage retrieval during pretraining so the model can use external documents as a memory source to answer questions.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>question answering (retrieval-augmented pretraining)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>retrieval-augmented external corpus used during LM pretraining</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism</strong></td>
                            <td>During pretraining, the model retrieves passages relevant to the current input and conditions predictions on them; the passage encoder and index may be asynchronously updated (re-indexed) during training.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Retrieved documents/passages represented as dense vectors accessible during model pretraining and inference.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>Dense retrieval into the training loop with periodic reindexing of passages (asynchronous update), enabling LM to attend to retrieved passages.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>Reported in this paper: REALM_Wiki NQ EM = 39.2% and REALM_News NQ EM = 40.4% (Table 4).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_with_without_memory</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_comparison</strong></td>
                            <td>Compared to DPR: REALM uses additional pretraining and jointly trains retrieval with LM objectives; DPR without such pretraining still outperforms REALM on NQ in this paper (DPR 41.5% vs REALM ~39-40%).</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Retrieval-augmented pretraining (REALM) is effective, but DPR shows that strong retrieval models can be learned without expensive retrieval-centric pretraining when sufficient question–passage pairs are available.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Additional pretraining may be most useful when target training data is small; asynchronous reindexing and pretraining add complexity and computational cost.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Dense Passage Retrieval for Open-Domain Question Answering', 'publication_date_yy_mm': '2020-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8417.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e8417.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the memory mechanism, tasks, comparative results, ablations, and key findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>ColBERT</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>ColBERT (Contextualized Late Interaction over BERT)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A concurrent dense retrieval method that applies a late-interaction operator on top of BERT encoders to enable effective and efficient passage search, mentioned as related work.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>ColBERT: Efficient and effective passage search via contextualized late interaction over BERT</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>ColBERT</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Dense retrieval approach that retains contextualized token-level representations from BERT and uses a late-interaction mechanism to compute efficient similarity between query and passages.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>BERT-based representations with late interaction (token-wise) instead of pure dual-encoder inner-product over CLS vectors.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Information retrieval / passage retrieval for QA</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Efficient passage search that better captures token-level interactions while remaining computationally feasible for large corpora.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>retrieval (information retrieval / QA retrieval)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>retrieval-augmented (dense indexed representations allowing late interaction)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism</strong></td>
                            <td>Late-interaction between query and passage token vectors stored/indexed for efficient scoring (details in ColBERT paper).</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Contextualized token vectors from BERT for query and passages.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>Approximate nearest neighbor and late token-wise similarity aggregation for ranking.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_with_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_comparison</strong></td>
                            <td>Mentioned as concurrent work demonstrating feasibility of dense retrieval and introducing a token-level late interaction instead of strict dual-encoder dot-product.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Demonstrates an alternative dense retrieval design (late interaction) that can trade off some precomputation for richer query-passage matching compared to pure CLS-based dual encoders.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Not evaluated in this paper; referenced as concurrent approach with different design tradeoffs.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Dense Passage Retrieval for Open-Domain Question Answering', 'publication_date_yy_mm': '2020-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8417.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e8417.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the memory mechanism, tasks, comparative results, ablations, and key findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>RAG / Retrieval-augmented generation (Lewis et al.)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Retrieval-augmented generation for knowledge-intensive NLP tasks</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A retrieval-augmented generation paradigm that combines a retriever (e.g., DPR) with a generative model to condition generation on retrieved passages for knowledge-intensive tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Retrieval-augmented generation for knowledge-intensive NLP tasks</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>Retrieval-augmented generation (RAG)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Framework combining a retriever (often DPR or similar dense retriever) with a sequence-to-sequence generative model to produce answers conditioned on retrieved documents.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Generative models (e.g., BART, T5) conditioned on retrieved passages; retrieval component provides external memory of documents.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Knowledge-intensive NLP tasks / open-domain QA / generation</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Generate answers or text that requires factual knowledge by conditioning on retrieved passages from a large corpus.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>generation conditioned on retrieval (QA, knowledge tasks)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>retrieval-augmented external document memory</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism</strong></td>
                            <td>Retriever (DPR or similar) supplies passages which are concatenated/conditioned into the generator's input or latent conditioning; memory is accessed via semantic retrieval.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Retrieved passages (documents) represented as text and/or encoded vectors fed into the generator.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>Semantic search via dense retrieval (DPR) or hybrid with BM25; retrieved passages are provided to generator during inference/training.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_with_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_comparison</strong></td>
                            <td>Referenced as work that combines DPR with generation (Lewis et al., 2020b) and as an application area where DPR is a useful memory module.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>DPR can be effectively combined with generative models to improve performance on knowledge-intensive tasks; retrieval provides a scalable external memory for generation.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Not evaluated in detail in this paper; combination introduces complexity of integrating retrieval and generation and requires careful engineering.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Dense Passage Retrieval for Open-Domain Question Answering', 'publication_date_yy_mm': '2020-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Latent retrieval for weakly supervised open domain question answering <em>(Rating: 2)</em></li>
                <li>REALM: Retrieval-augmented language model pre-training <em>(Rating: 2)</em></li>
                <li>Retrieval-augmented generation for knowledge-intensive NLP tasks <em>(Rating: 2)</em></li>
                <li>ColBERT: Efficient and effective passage search via contextualized late interaction over BERT <em>(Rating: 2)</em></li>
                <li>Approximate nearest neighbor negative contrastive learning for dense text retrieval <em>(Rating: 1)</em></li>
                <li>Leveraging passage retrieval with generative models for open domain question answering <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-8417",
    "paper_id": "paper-b26f2037f769d5ffc5f7bdcec2de8da28ec14bee",
    "extraction_schema_id": "extraction-schema-150",
    "extracted_data": [
        {
            "name_short": "DPR",
            "name_full": "Dense Passage Retriever",
            "brief_description": "A retrieval component that encodes questions and passages into dense vectors (two independent BERT-base encoders) and performs retrieval by maximum inner product search over a FAISS index of passage embeddings to support open-domain question answering.",
            "citation_title": "here",
            "mention_or_use": "use",
            "agent_name": "DPR (retrieval-augmented QA pipeline)",
            "agent_description": "Dual-encoder retrieval module using two independent BERT-base (uncased) encoders: one for questions E_Q and one for passages E_P. Passage vectors are precomputed and indexed; at query time a question vector retrieves top-k passages via dot product (inner product) similarity.",
            "model_name": "BERT-base (uncased) dual encoders",
            "model_description": "Two independent BERT-base models (768 hidden units) used to produce CLS token embeddings for question and passage; dense vectors (d=768) are stored for passages and used with FAISS for approximate nearest neighbor inner-product search.",
            "task_name": "Open-domain question answering (multiple datasets: Natural Questions, TriviaQA, WebQuestions, CuratedTREC, SQuAD v1.1)",
            "task_description": "Given a factoid question, retrieve a small set of candidate passages from a large corpus (Wikipedia split into ~21M fixed-length passages) that contain the answer span; a reader model then extracts the final answer.",
            "task_type": "question answering (retrieval-augmented / open-domain QA)",
            "memory_used": true,
            "memory_type": "retrieval-augmented external database (indexed passage memory)",
            "memory_mechanism": "Precompute dense passage embeddings with the passage encoder E_P, index them in FAISS (HNSW index), and at query time compute E_Q(q) and retrieve top-k passages by maximizing inner product (dot product) between query and passage vectors. Optionally rerank union of BM25 and DPR candidates via BM25(q,p) + lambda * sim(q,p).",
            "memory_representation": "Fixed-length passage texts encoded into 768-dimensional vectors (BERT [CLS] embeddings); optionally titles prepended and passages are 100-word blocks.",
            "memory_retrieval_method": "Semantic vector search (inner product / approximate nearest neighbor via FAISS HNSW); also experimented with L2 and cosine, and linear combination with BM25 scores for reranking.",
            "performance_with_memory": "Retrieval (Natural Questions, Single dataset): Top-20 retrieval accuracy 78.4% (DPR) vs BM25 59.1%; Top-100 85.4% vs BM25 73.7%. End-to-end QA (Exact Match on NQ): DPR 41.5% vs BM25 32.6% (Table 2 & 4).",
            "performance_without_memory": null,
            "has_performance_with_without_memory": false,
            "ablation_or_comparison": "Extensive ablations: (1) Sample efficiency: DPR trained with only 1k examples already outperforms BM25. (2) Negative sampling: in-batch negatives substantially improve performance; best setup uses in-batch gold negatives plus one BM25 hard negative. Table 3 shows adding one BM25 hard negative increases Top-5 from ~55.8% to 65.8% (depending on config) and Top-20 to ~78.0% in best setting. (3) Similarity/loss: dot product and L2 perform comparably and superior to cosine; triplet loss similar but not superior. (4) Cross-dataset: training on NQ only loses 3-5 points when applied to WebQuestions / TREC but still outperforms BM25. (5) Joint training: jointly training retriever+reader (with frozen passage encoder) yielded 39.8 EM (NQ dev), worse than the pipeline DPR+reader (41.5 EM).",
            "key_findings": "A simple dual-encoder dense retriever trained on question–passage pairs with in-batch negatives (and a single BM25 hard negative) yields large gains over BM25 in retrieval precision and translates to higher end-to-end QA accuracy; dense retrieval can be practical and efficient when combined with FAISS and is sample-efficient with pretrained language models.",
            "limitations_or_challenges": "Index construction and embedding all passages is resource-intensive (computing embeddings for 21M passages ~8.8 hours on 8 GPUs; FAISS index build ~8.5 hours on a single server). DPR underperforms BM25 on SQuAD due to distributional biases and high lexical overlap in SQuAD. DPR may miss rare, highly-salient phrases that sparse methods capture (qualitative failure modes).",
            "uuid": "e8417.0",
            "source_info": {
                "paper_title": "Dense Passage Retrieval for Open-Domain Question Answering",
                "publication_date_yy_mm": "2020-04"
            }
        },
        {
            "name_short": "ORQA",
            "name_full": "ORQA (Latent Retrieval for Weakly Supervised Open Domain QA)",
            "brief_description": "A retrieval-augmented QA approach that uses an inverse cloze task (ICT) for pretraining and jointly trains question encoder and reader; a previous state-of-the-art dense retrieval method compared to DPR.",
            "citation_title": "Latent retrieval for weakly supervised open domain question answering",
            "mention_or_use": "mention",
            "agent_name": "ORQA",
            "agent_description": "Retrieval-augmented QA system that includes an ICT pretraining objective to learn passage/question encoders and performs joint fine-tuning of retriever and reader.",
            "model_name": null,
            "model_description": "Uses pretrained encoders with additional ICT pretraining (predicting masked sentence blocks) and joint training of question encoder and reader; specifics are given in the ORQA paper (Lee et al., 2019).",
            "task_name": "Open-domain question answering (Natural Questions, etc.)",
            "task_description": "Retrieve passages and extract answers in an open-domain setting; ORQA focuses on latent retrieval learned with additional pretraining.",
            "task_type": "question answering (retrieval-augmented)",
            "memory_used": true,
            "memory_type": "retrieval-augmented (pretrained retrieval memory over passages)",
            "memory_mechanism": "ICT pretraining to learn encoders that map passages and pseudo-questions to vectors used for retrieval; joint training couples retriever and reader (ORQA reindexes during training in some variants).",
            "memory_representation": "Passages / sentence blocks encoded into dense vectors as learned by ICT pretraining.",
            "memory_retrieval_method": "Dense retrieval using learned encoders (similarity-based nearest neighbor retrieval).",
            "performance_with_memory": "Reported in this paper: ORQA (Single) end-to-end QA Exact Match on NQ = 33.3% (Table 4).",
            "performance_without_memory": null,
            "has_performance_with_without_memory": false,
            "ablation_or_comparison": "Paper compares DPR to ORQA: DPR (41.5% NQ EM) outperforms ORQA (33.3% NQ EM) despite ORQA using additional pretraining (ICT). The authors note ORQA's weaknesses: ICT pretraining is computationally intensive and the context encoder is not fine-tuned directly on question–answer pairs, potentially leading to suboptimal contexts.",
            "key_findings": "ORQA showed that dense retrieval with additional pretraining can beat BM25, but DPR demonstrates that simpler fine-tuning on question–passage pairs without ICT pretraining can yield better performance on some datasets.",
            "limitations_or_challenges": "ICT pretraining is computationally expensive; joint training and pretraining choices may not optimally tune the passage encoder when compared to direct fine-tuning on question–passage pairs.",
            "uuid": "e8417.1",
            "source_info": {
                "paper_title": "Dense Passage Retrieval for Open-Domain Question Answering",
                "publication_date_yy_mm": "2020-04"
            }
        },
        {
            "name_short": "REALM",
            "name_full": "REALM (Retrieval-Augmented Language Model Pre-training)",
            "brief_description": "A retrieval-augmented pretraining approach that integrates retrieval into language model pretraining, asynchronously tuning passage encoder by re-indexing passages during training.",
            "citation_title": "REALM: Retrieval-augmented language model pre-training",
            "mention_or_use": "mention",
            "agent_name": "REALM",
            "agent_description": "A language model pretraining framework that augments masked language model objectives with retrieved passages and updates retrieval indices during pretraining so the LM can access external knowledge via retrieval.",
            "model_name": "REALM (pretrained retrieval-augmented LM variants)",
            "model_description": "Language models pretrained with retrieval in the loop; REALM was reported with variants pretrained on Wikipedia and CC-News and used for open-domain QA.",
            "task_name": "Open-domain question answering / knowledge-intensive tasks",
            "task_description": "Leverage retrieval during pretraining so the model can use external documents as a memory source to answer questions.",
            "task_type": "question answering (retrieval-augmented pretraining)",
            "memory_used": true,
            "memory_type": "retrieval-augmented external corpus used during LM pretraining",
            "memory_mechanism": "During pretraining, the model retrieves passages relevant to the current input and conditions predictions on them; the passage encoder and index may be asynchronously updated (re-indexed) during training.",
            "memory_representation": "Retrieved documents/passages represented as dense vectors accessible during model pretraining and inference.",
            "memory_retrieval_method": "Dense retrieval into the training loop with periodic reindexing of passages (asynchronous update), enabling LM to attend to retrieved passages.",
            "performance_with_memory": "Reported in this paper: REALM_Wiki NQ EM = 39.2% and REALM_News NQ EM = 40.4% (Table 4).",
            "performance_without_memory": null,
            "has_performance_with_without_memory": false,
            "ablation_or_comparison": "Compared to DPR: REALM uses additional pretraining and jointly trains retrieval with LM objectives; DPR without such pretraining still outperforms REALM on NQ in this paper (DPR 41.5% vs REALM ~39-40%).",
            "key_findings": "Retrieval-augmented pretraining (REALM) is effective, but DPR shows that strong retrieval models can be learned without expensive retrieval-centric pretraining when sufficient question–passage pairs are available.",
            "limitations_or_challenges": "Additional pretraining may be most useful when target training data is small; asynchronous reindexing and pretraining add complexity and computational cost.",
            "uuid": "e8417.2",
            "source_info": {
                "paper_title": "Dense Passage Retrieval for Open-Domain Question Answering",
                "publication_date_yy_mm": "2020-04"
            }
        },
        {
            "name_short": "ColBERT",
            "name_full": "ColBERT (Contextualized Late Interaction over BERT)",
            "brief_description": "A concurrent dense retrieval method that applies a late-interaction operator on top of BERT encoders to enable effective and efficient passage search, mentioned as related work.",
            "citation_title": "ColBERT: Efficient and effective passage search via contextualized late interaction over BERT",
            "mention_or_use": "mention",
            "agent_name": "ColBERT",
            "agent_description": "Dense retrieval approach that retains contextualized token-level representations from BERT and uses a late-interaction mechanism to compute efficient similarity between query and passages.",
            "model_name": null,
            "model_description": "BERT-based representations with late interaction (token-wise) instead of pure dual-encoder inner-product over CLS vectors.",
            "task_name": "Information retrieval / passage retrieval for QA",
            "task_description": "Efficient passage search that better captures token-level interactions while remaining computationally feasible for large corpora.",
            "task_type": "retrieval (information retrieval / QA retrieval)",
            "memory_used": true,
            "memory_type": "retrieval-augmented (dense indexed representations allowing late interaction)",
            "memory_mechanism": "Late-interaction between query and passage token vectors stored/indexed for efficient scoring (details in ColBERT paper).",
            "memory_representation": "Contextualized token vectors from BERT for query and passages.",
            "memory_retrieval_method": "Approximate nearest neighbor and late token-wise similarity aggregation for ranking.",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_performance_with_without_memory": null,
            "ablation_or_comparison": "Mentioned as concurrent work demonstrating feasibility of dense retrieval and introducing a token-level late interaction instead of strict dual-encoder dot-product.",
            "key_findings": "Demonstrates an alternative dense retrieval design (late interaction) that can trade off some precomputation for richer query-passage matching compared to pure CLS-based dual encoders.",
            "limitations_or_challenges": "Not evaluated in this paper; referenced as concurrent approach with different design tradeoffs.",
            "uuid": "e8417.3",
            "source_info": {
                "paper_title": "Dense Passage Retrieval for Open-Domain Question Answering",
                "publication_date_yy_mm": "2020-04"
            }
        },
        {
            "name_short": "RAG / Retrieval-augmented generation (Lewis et al.)",
            "name_full": "Retrieval-augmented generation for knowledge-intensive NLP tasks",
            "brief_description": "A retrieval-augmented generation paradigm that combines a retriever (e.g., DPR) with a generative model to condition generation on retrieved passages for knowledge-intensive tasks.",
            "citation_title": "Retrieval-augmented generation for knowledge-intensive NLP tasks",
            "mention_or_use": "mention",
            "agent_name": "Retrieval-augmented generation (RAG)",
            "agent_description": "Framework combining a retriever (often DPR or similar dense retriever) with a sequence-to-sequence generative model to produce answers conditioned on retrieved documents.",
            "model_name": null,
            "model_description": "Generative models (e.g., BART, T5) conditioned on retrieved passages; retrieval component provides external memory of documents.",
            "task_name": "Knowledge-intensive NLP tasks / open-domain QA / generation",
            "task_description": "Generate answers or text that requires factual knowledge by conditioning on retrieved passages from a large corpus.",
            "task_type": "generation conditioned on retrieval (QA, knowledge tasks)",
            "memory_used": true,
            "memory_type": "retrieval-augmented external document memory",
            "memory_mechanism": "Retriever (DPR or similar) supplies passages which are concatenated/conditioned into the generator's input or latent conditioning; memory is accessed via semantic retrieval.",
            "memory_representation": "Retrieved passages (documents) represented as text and/or encoded vectors fed into the generator.",
            "memory_retrieval_method": "Semantic search via dense retrieval (DPR) or hybrid with BM25; retrieved passages are provided to generator during inference/training.",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_performance_with_without_memory": null,
            "ablation_or_comparison": "Referenced as work that combines DPR with generation (Lewis et al., 2020b) and as an application area where DPR is a useful memory module.",
            "key_findings": "DPR can be effectively combined with generative models to improve performance on knowledge-intensive tasks; retrieval provides a scalable external memory for generation.",
            "limitations_or_challenges": "Not evaluated in detail in this paper; combination introduces complexity of integrating retrieval and generation and requires careful engineering.",
            "uuid": "e8417.4",
            "source_info": {
                "paper_title": "Dense Passage Retrieval for Open-Domain Question Answering",
                "publication_date_yy_mm": "2020-04"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Latent retrieval for weakly supervised open domain question answering",
            "rating": 2
        },
        {
            "paper_title": "REALM: Retrieval-augmented language model pre-training",
            "rating": 2
        },
        {
            "paper_title": "Retrieval-augmented generation for knowledge-intensive NLP tasks",
            "rating": 2
        },
        {
            "paper_title": "ColBERT: Efficient and effective passage search via contextualized late interaction over BERT",
            "rating": 2
        },
        {
            "paper_title": "Approximate nearest neighbor negative contrastive learning for dense text retrieval",
            "rating": 1
        },
        {
            "paper_title": "Leveraging passage retrieval with generative models for open domain question answering",
            "rating": 1
        }
    ],
    "cost": 0.014527,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Dense Passage Retrieval for Open-Domain Question Answering</h1>
<p>Vladimir Karpukhin, Barlas Oğuz, Sewon Min ${ }^{1}$, Patrick Lewis,<br>Ledell Wu, Sergey Edunov, Danqi Chen ${ }^{1}$, Wen-tau Yih<br>Facebook AI ${ }^{\dagger}$ University of Washington ${ }^{\ddagger}$ Princeton University<br>{vladk, barlaso, plewis, ledell, edunov, scottyih}@fb.com<br>sewon@cs.washington.edu<br>danqic@cs.princeton.edu</p>
<h4>Abstract</h4>
<p>Open-domain question answering relies on efficient passage retrieval to select candidate contexts, where traditional sparse vector space models, such as TF-IDF or BM25, are the de facto method. In this work, we show that retrieval can be practically implemented using dense representations alone, where embeddings are learned from a small number of questions and passages by a simple dualencoder framework. When evaluated on a wide range of open-domain QA datasets, our dense retriever outperforms a strong LuceneBM25 system greatly by $9 \%-19 \%$ absolute in terms of top-20 passage retrieval accuracy, and helps our end-to-end QA system establish new state-of-the-art on multiple open-domain QA benchmarks. ${ }^{1}$</p>
<h2>1 Introduction</h2>
<p>Open-domain question answering (QA) (Voorhees, 1999) is a task that answers factoid questions using a large collection of documents. While early QA systems are often complicated and consist of multiple components (Ferrucci (2012); Moldovan et al. (2003), inter alia), the advances of reading comprehension models suggest a much simplified two-stage framework: (1) a context retriever first selects a small subset of passages where some of them contain the answer to the question, and then (2) a machine reader can thoroughly examine the retrieved contexts and identify the correct answer (Chen et al., 2017). Although reducing open-domain QA to machine reading is a very reasonable strategy, a huge performance degradation is often observed in practice ${ }^{2}$, indicating the needs of improving retrieval.</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup>Retrieval in open-domain QA is usually implemented using TF-IDF or BM25 (Robertson and Zaragoza, 2009), which matches keywords efficiently with an inverted index and can be seen as representing the question and context in highdimensional, sparse vectors (with weighting). Conversely, the dense, latent semantic encoding is complementary to sparse representations by design. For example, synonyms or paraphrases that consist of completely different tokens may still be mapped to vectors close to each other. Consider the question "Who is the bad guy in lord of the rings?", which can be answered from the context "Sala Baker is best known for portraying the villain Sauron in the Lord of the Rings trilogy." A term-based system would have difficulty retrieving such a context, while a dense retrieval system would be able to better match "bad guy" with "villain" and fetch the correct context. Dense encodings are also learnable by adjusting the embedding functions, which provides additional flexibility to have a task-specific representation. With special in-memory data structures and indexing schemes, retrieval can be done efficiently using maximum inner product search (MIPS) algorithms (e.g., Shrivastava and Li (2014); Guo et al. (2016)).</p>
<p>However, it is generally believed that learning a good dense vector representation needs a large number of labeled pairs of question and contexts. Dense retrieval methods have thus never be shown to outperform TF-IDF/BM25 for opendomain QA before ORQA (Lee et al., 2019), which proposes a sophisticated inverse cloze task (ICT) objective, predicting the blocks that contain the masked sentence, for additional pretraining. The question encoder and the reader model are then finetuned using pairs of questions and answers jointly. Although ORQA successfully demonstrates that dense retrieval can outperform BM25, setting new state-of-the-art results on multiple open-domain</p>
<p>QA datasets, it also suffers from two weaknesses. First, ICT pretraining is computationally intensive and it is not completely clear that regular sentences are good surrogates of questions in the objective function. Second, because the context encoder is not fine-tuned using pairs of questions and answers, the corresponding representations could be suboptimal.</p>
<p>In this paper, we address the question: can we train a better dense embedding model using only pairs of questions and passages (or answers), without additional pretraining? By leveraging the now standard BERT pretrained model (Devlin et al., 2019) and a dual-encoder architecture (Bromley et al., 1994), we focus on developing the right training scheme using a relatively small number of question and passage pairs. Through a series of careful ablation studies, our final solution is surprisingly simple: the embedding is optimized for maximizing inner products of the question and relevant passage vectors, with an objective comparing all pairs of questions and passages in a batch. Our Dense Passage Retriever (DPR) is exceptionally strong. It not only outperforms BM25 by a large margin ( $65.2 \%$ vs. $42.9 \%$ in Top-5 accuracy), but also results in a substantial improvement on the end-to-end QA accuracy compared to ORQA ( $41.5 \%$ vs. $33.3 \%$ ) in the open Natural Questions setting (Lee et al., 2019; Kwiatkowski et al., 2019).</p>
<p>Our contributions are twofold. First, we demonstrate that with the proper training setup, simply fine-tuning the question and passage encoders on existing question-passage pairs is sufficient to greatly outperform BM25. Our empirical results also suggest that additional pretraining may not be needed. Second, we verify that, in the context of open-domain question answering, a higher retrieval precision indeed translates to a higher end-to-end QA accuracy. By applying a modern reader model to the top retrieved passages, we achieve comparable or better results on multiple QA datasets in the open-retrieval setting, compared to several, much complicated systems.</p>
<h2>2 Background</h2>
<p>The problem of open-domain QA studied in this paper can be described as follows. Given a factoid question, such as "Who first voiced Meg on Family Guy?" or "Where was the 8th Dalai Lama born?", a system is required to answer it using a large corpus of diversified topics. More specifically, we assume
the extractive QA setting, in which the answer is restricted to a span appearing in one or more passages in the corpus. Assume that our collection contains $D$ documents, $d_{1}, d_{2}, \cdots, d_{D}$. We first split each of the documents into text passages of equal lengths as the basic retrieval units ${ }^{3}$ and get $M$ total passages in our corpus $\mathcal{C}=\left{p_{1}, p_{2}, \ldots, p_{M}\right}$, where each passage $p_{i}$ can be viewed as a sequence of tokens $w_{1}^{(i)}, w_{2}^{(i)}, \cdots, w_{\left|p_{i}\right|}^{(i)}$. Given a question $q$, the task is to find a span $w_{s}^{(i)}, w_{s+1}^{(i)}, \cdots, w_{e}^{(i)}$ from one of the passages $p_{i}$ that can answer the question. Notice that to cover a wide variety of domains, the corpus size can easily range from millions of documents (e.g., Wikipedia) to billions (e.g., the Web). As a result, any open-domain QA system needs to include an efficient retriever component that can select a small set of relevant texts, before applying the reader to extract the answer (Chen et al., 2017). ${ }^{4}$ Formally speaking, a retriever $R:(q, \mathcal{C}) \rightarrow \mathcal{C}<em _mathcal_F="\mathcal{F">{\mathcal{F}}$ is a function that takes as input a question $q$ and a corpus $\mathcal{C}$ and returns a much smaller filter set of texts $\mathcal{C}</em>}} \subset \mathcal{C}$, where $\left|\mathcal{C<em _mathcal_F="\mathcal{F">{\mathcal{F}}\right|=k \ll|\mathcal{C}|$. For a fixed $k$, a retriever can be evaluated in isolation on top- $k$ retrieval accuracy, which is the fraction of questions for which $\mathcal{C}</em>$ contains a span that answers the question.}</p>
<h2>3 Dense Passage Retriever (DPR)</h2>
<p>We focus our research in this work on improving the retrieval component in open-domain QA. Given a collection of $M$ text passages, the goal of our dense passage retriever (DPR) is to index all the passages in a low-dimensional and continuous space, such that it can retrieve efficiently the top $k$ passages relevant to the input question for the reader at run-time. Note that $M$ can be very large (e.g., 21 million passages in our experiments, described in Section 4.1) and $k$ is usually small, such as $20-100$.</p>
<h3>3.1 Overview</h3>
<p>Our dense passage retriever (DPR) uses a dense encoder $E_{P}(\cdot)$ which maps any text passage to a $d$ dimensional real-valued vectors and builds an index for all the $M$ passages that we will use for retrieval.</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>At run-time, DPR applies a different encoder $E_{Q}(\cdot)$ that maps the input question to a $d$-dimensional vector, and retrieves $k$ passages of which vectors are the closest to the question vector. We define the similarity between the question and the passage using the dot product of their vectors:</p>
<p>$$
\operatorname{sim}(q, p)=E_{Q}(q)^{\top} E_{P}(p)
$$</p>
<p>Although more expressive model forms for measuring the similarity between a question and a passage do exist, such as networks consisting of multiple layers of cross attentions, the similarity function needs to be decomposable so that the representations of the collection of passages can be precomputed. Most decomposable similarity functions are some transformations of Euclidean distance (L2). For instance, cosine is equivalent to inner product for unit vectors and the Mahalanobis distance is equivalent to L2 distance in a transformed space. Inner product search has been widely used and studied, as well as its connection to cosine similarity and L2 distance (Mussmann and Ermon, 2016; Ram and Gray, 2012). As our ablation study finds other similarity functions perform comparably (Section 5.2; Appendix B), we thus choose the simpler inner product function and improve the dense passage retriever by learning better encoders.</p>
<p>Encoders Although in principle the question and passage encoders can be implemented by any neural networks, in this work we use two independent BERT (Devlin et al., 2019) networks (base, uncased) and take the representation at the [CLS] token as the output, so $d=768$.</p>
<p>Inference During inference time, we apply the passage encoder $E_{P}$ to all the passages and index them using FAISS (Johnson et al., 2017) offline. FAISS is an extremely efficient, open-source library for similarity search and clustering of dense vectors, which can easily be applied to billions of vectors. Given a question $q$ at run-time, we derive its embedding $v_{q}=E_{Q}(q)$ and retrieve the top $k$ passages with embeddings closest to $v_{q}$.</p>
<h3>3.2 Training</h3>
<p>Training the encoders so that the dot-product similarity (Eq. (1)) becomes a good ranking function for retrieval is essentially a metric learning problem (Kulis, 2013). The goal is to create a vector space such that relevant pairs of questions and passages will have smaller distance (i.e., higher simi-
larity) than the irrelevant ones, by learning a better embedding function.</p>
<p>Let $\mathcal{D}=\left{\left\langle q_{i}, p_{i}^{+}, p_{i, 1}^{-}, \cdots, p_{i, n}^{-}\right\rangle\right}<em i="i">{i=1}^{m}$ be the training data that consists of $m$ instances. Each instance contains one question $q</em>$. We optimize the loss function as the negative log likelihood of the positive passage:}$ and one relevant (positive) passage $p_{i}^{+}$, along with $n$ irrelevant (negative) passages $p_{i, j}^{-</p>
<p>$$
\begin{aligned}
&amp; L\left(q_{i}, p_{i}^{+}, p_{i, 1}^{-}, \cdots, p_{i, n}^{-}\right) \
= &amp; -\log \frac{e^{\operatorname{sim}\left(q_{i}, p_{i}^{+}\right)}}{e^{\operatorname{sim}\left(q_{i}, p_{i}^{+}\right)}+\sum_{j=1}^{n} e^{\operatorname{sim}\left(q_{i}, p_{i, j}^{-}\right)}}
\end{aligned}
$$</p>
<p>Positive and negative passages For retrieval problems, it is often the case that positive examples are available explicitly, while negative examples need to be selected from an extremely large pool. For instance, passages relevant to a question may be given in a QA dataset, or can be found using the answer. All other passages in the collection, while not specified explicitly, can be viewed as irrelevant by default. In practice, how to select negative examples is often overlooked but could be decisive for learning a high-quality encoder. We consider three different types of negatives: (1) Random: any random passage from the corpus; (2) BM25: top passages returned by BM25 which don't contain the answer but match most question tokens; (3) Gold: positive passages paired with other questions which appear in the training set. We will discuss the impact of different types of negative passages and training schemes in Section 5.2. Our best model uses gold passages from the same mini-batch and one BM25 negative passage. In particular, re-using gold passages from the same batch as negatives can make the computation efficient while achieving great performance. We discuss this approach below.</p>
<p>In-batch negatives Assume that we have $B$ questions in a mini-batch and each one is associated with a relevant passage. Let $\mathbf{Q}$ and $\mathbf{P}$ be the $(B \times d)$ matrix of question and passage embeddings in a batch of size $B . \mathbf{S}=\mathbf{Q P}^{T}$ is a $(B \times B)$ matrix of similarity scores, where each row of which corresponds to a question, paired with $B$ passages. In this way, we reuse computation and effectively train on $B^{2}\left(q_{i}, p_{j}\right)$ question/passage pairs in each batch. Any $\left(q_{i}, p_{j}\right)$ pair is a positive example when $i=j$, and negative otherwise. This creates $B$ training instances in each batch, where there are $B-1$</p>
<p>negative passages for each question.
The trick of in-batch negatives has been used in the full batch setting (Yih et al., 2011) and more recently for mini-batch (Henderson et al., 2017; Gillick et al., 2019). It has been shown to be an effective strategy for learning a dual-encoder model that boosts the number of training examples.</p>
<h2>4 Experimental Setup</h2>
<p>In this section, we describe the data we used for experiments and the basic setup.</p>
<h3>4.1 Wikipedia Data Pre-processing</h3>
<p>Following (Lee et al., 2019), we use the English Wikipedia dump from Dec. 20, 2018 as the source documents for answering questions. We first apply the pre-processing code released in DrQA (Chen et al., 2017) to extract the clean, text-portion of articles from the Wikipedia dump. This step removes semi-structured data, such as tables, infoboxes, lists, as well as the disambiguation pages. We then split each article into multiple, disjoint text blocks of 100 words as passages, serving as our basic retrieval units, following (Wang et al., 2019), which results in $21,015,324$ passages in the end. ${ }^{5}$ Each passage is also prepended with the title of the Wikipedia article where the passage is from, along with an [SEP] token.</p>
<h3>4.2 Question Answering Datasets</h3>
<p>We use the same five QA datasets and training/dev/testing splitting method as in previous work (Lee et al., 2019). Below we briefly describe each dataset and refer readers to their paper for the details of data preparation.
Natural Questions (NQ) (Kwiatkowski et al., 2019) was designed for end-to-end question answering. The questions were mined from real Google search queries and the answers were spans in Wikipedia articles identified by annotators.
TriviaQA (Joshi et al., 2017) contains a set of trivia questions with answers that were originally scraped from the Web.
WebQuestions (WQ) (Berant et al., 2013) consists of questions selected using Google Suggest API, where the answers are entities in Freebase.
CuratedTREC (TREC) (Baudiš and Šedivỳ, 2015) sources questions from TREC QA tracks</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup>Table 1: Number of questions in each QA dataset. The two columns of Train denote the original training examples in the dataset and the actual questions used for training DPR after filtering. See text for more details.
as well as various Web sources and is intended for open-domain QA from unstructured corpora.
SQuAD v1.1 (Rajpurkar et al., 2016) is a popular benchmark dataset for reading comprehension. Annotators were presented with a Wikipedia paragraph, and asked to write questions that could be answered from the given text. Although SQuAD has been used previously for open-domain QA research, it is not ideal because many questions lack context in absence of the provided paragraph. We still include it in our experiments for providing a fair comparison to previous work and we will discuss more in Section 5.1.</p>
<p>Selection of positive passages Because only pairs of questions and answers are provided in TREC, WebQuestions and TriviaQA ${ }^{6}$, we use the highest-ranked passage from BM25 that contains the answer as the positive passage. If none of the top 100 retrieved passages has the answer, the question will be discarded. For SQuAD and Natural Questions, since the original passages have been split and processed differently than our pool of candidate passages, we match and replace each gold passage with the corresponding passage in the candidate pool. ${ }^{7}$ We discard the questions when the matching is failed due to different Wikipedia versions or pre-processing. Table 1 shows the number of questions in training/dev/test sets for all the datasets and the actual questions used for training the retriever.</p>
<h2>5 Experiments: Passage Retrieval</h2>
<p>In this section, we evaluate the retrieval performance of our Dense Passage Retriever (DPR), along with analysis on how its output differs from</p>
<p><sup id="fnref:1"><a class="footnote-ref" href="#fn:1">2</a></sup></p>
<table>
<thead>
<tr>
<th>Training</th>
<th>Retriever</th>
<th>Top-20</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>Top-100</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>NQ</td>
<td>TriviaQA</td>
<td>WQ</td>
<td>TREC</td>
<td>SQuAD</td>
<td>NQ</td>
<td>TriviaQA</td>
<td>WQ</td>
<td>TREC</td>
<td>SQuAD</td>
</tr>
<tr>
<td>None</td>
<td>BM25</td>
<td>59.1</td>
<td>66.9</td>
<td>55.0</td>
<td>70.9</td>
<td>68.8</td>
<td>73.7</td>
<td>76.7</td>
<td>71.1</td>
<td>84.1</td>
<td>80.0</td>
</tr>
<tr>
<td>Single</td>
<td>DPR</td>
<td>78.4</td>
<td>79.4</td>
<td>73.2</td>
<td>79.8</td>
<td>63.2</td>
<td>85.4</td>
<td>85.0</td>
<td>81.4</td>
<td>89.1</td>
<td>77.2</td>
</tr>
<tr>
<td></td>
<td>BM25 + DPR</td>
<td>76.6</td>
<td>79.8</td>
<td>71.0</td>
<td>85.2</td>
<td>71.5</td>
<td>83.8</td>
<td>84.5</td>
<td>80.5</td>
<td>92.7</td>
<td>81.3</td>
</tr>
<tr>
<td>Multi</td>
<td>DPR</td>
<td>79.4</td>
<td>78.8</td>
<td>75.0</td>
<td>89.1</td>
<td>51.6</td>
<td>86.0</td>
<td>84.7</td>
<td>82.9</td>
<td>93.9</td>
<td>67.6</td>
</tr>
<tr>
<td></td>
<td>BM25 + DPR</td>
<td>78.0</td>
<td>79.9</td>
<td>74.7</td>
<td>88.5</td>
<td>66.2</td>
<td>83.9</td>
<td>84.4</td>
<td>82.3</td>
<td>94.1</td>
<td>78.6</td>
</tr>
</tbody>
</table>
<p>Table 2: Top-20 \&amp; Top-100 retrieval accuracy on test sets, measured as the percentage of top 20/100 retrieved passages that contain the answer. Single and Multi denote that our Dense Passage Retriever (DPR) was trained using individial or combined training datasets (all the datasets excluding SQuAD). See text for more details.
traditional retrieval methods, the effects of different training schemes and the run-time efficiency.</p>
<p>The DPR model used in our main experiments is trained using the in-batch negative setting (Section 3.2) with a batch size of 128 and one additional BM25 negative passage per question. We trained the question and passage encoders for up to 40 epochs for large datasets (NQ, TriviaQA, SQuAD) and 100 epochs for small datasets (TREC, WQ), with a learning rate of $10^{-5}$ using Adam, linear scheduling with warm-up and dropout rate 0.1 .</p>
<p>While it is good to have the flexibility to adapt the retriever to each dataset, it would also be desirable to obtain a single retriever that works well across the board. To this end, we train a multidataset encoder by combining training data from all datasets excluding SQuAD. ${ }^{8}$ In addition to DPR, we also present the results of BM25, the traditional retrieval method ${ }^{9}$ and BM25+DPR, using a linear combination of their scores as the new ranking function. Specifically, we obtain two initial sets of top-2000 passages based on BM25 and DPR, respectively, and rerank the union of them using BM25 $(q, p)+\lambda \cdot \operatorname{sim}(q, p)$ as the ranking function. We used $\lambda=1.1$ based on the retrieval accuracy in the development set.</p>
<h3>5.1 Main Results</h3>
<p>Table 2 compares different passage retrieval systems on five QA datasets, using the top- $k$ accuracy $(k \in{20,100})$. With the exception of SQuAD, DPR performs consistently better than BM25 on all datasets. The gap is especially large when $k$ is small (e.g., $78.4 \%$ vs. $59.1 \%$ for top- 20 accuracy on Natural Questions). When training with mul-</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Retriever top- $k$ accuracy with different numbers of training examples used in our dense passage retriever vs BM25. The results are measured on the development set of Natural Questions. Our DPR trained using 1,000 examples already outperforms BM25.
tiple datasets, TREC, the smallest dataset of the five, benefits greatly from more training examples. In contrast, Natural Questions and WebQuestions improve modestly and TriviaQA degrades slightly. Results can be improved further in some cases by combining DPR with BM25 in both single- and multi-dataset settings.</p>
<p>We conjecture that the lower performance on SQuAD is due to two reasons. First, the annotators wrote questions after seeing the passage. As a result, there is a high lexical overlap between passages and questions, which gives BM25 a clear advantage. Second, the data was collected from only 500+ Wikipedia articles and thus the distribution of training examples is extremely biased, as argued previously by Lee et al. (2019).</p>
<h3>5.2 Ablation Study on Model Training</h3>
<p>To understand further how different model training options affect the results, we conduct several additional experiments and discuss our findings below.</p>
<p>Sample efficiency We explore how many training examples are needed to achieve good passage retrieval performance. Figure 1 illustrates the top- $k$ retrieval accuracy with respect to different numbers of training examples, measured on the development set of Natural Questions. As is shown, a dense passage retriever trained using only 1,000 examples already outperforms BM25. This suggests that with a general pretrained language model, it is possible to train a high-quality dense retriever with a small number of question-passage pairs. Adding more training examples (from 1 k to 59 k ) further improves the retrieval accuracy consistently.</p>
<p>In-batch negative training We test different training schemes on the development set of Natural Questions and summarize the results in Table 3. The top block is the standard 1-of- $N$ training setting, where each question in the batch is paired with a positive passage and its own set of $n$ negative passages (Eq. (2)). We find that the choice of negatives - random, BM25 or gold passages (positive passages from other questions) - does not impact the top- $k$ accuracy much in this setting when $k \geq 20$.</p>
<p>The middle bock is the in-batch negative training (Section 3.2) setting. We find that using a similar configuration ( 7 gold negative passages), in-batch negative training improves the results substantially. The key difference between the two is whether the gold negative passages come from the same batch or from the whole training set. Effectively, in-batch negative training is an easy and memory-efficient way to reuse the negative examples already in the batch rather than creating new ones. It produces more pairs and thus increases the number of training examples, which might contribute to the good model performance. As a result, accuracy consistently improves as the batch size grows.</p>
<p>Finally, we explore in-batch negative training with additional "hard" negative passages that have high BM25 scores given the question, but do not contain the answer string (the bottom block). These additional passages are used as negative passages for all questions in the same batch. We find that adding a single BM25 negative passage improves the result substantially while adding two does not help further.</p>
<p>Impact of gold passages We use passages that match the gold contexts in the original datasets (when available) as positive examples (Section 4.2).</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">#N</th>
<th style="text-align: left;">IB</th>
<th style="text-align: left;">Top-5</th>
<th style="text-align: left;">Top-20</th>
<th style="text-align: left;">Top-100</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Random</td>
<td style="text-align: left;">7</td>
<td style="text-align: left;">$\boldsymbol{X}$</td>
<td style="text-align: left;">47.0</td>
<td style="text-align: left;">64.3</td>
<td style="text-align: left;">77.8</td>
</tr>
<tr>
<td style="text-align: left;">BM25</td>
<td style="text-align: left;">7</td>
<td style="text-align: left;">$\boldsymbol{X}$</td>
<td style="text-align: left;">50.0</td>
<td style="text-align: left;">63.3</td>
<td style="text-align: left;">74.8</td>
</tr>
<tr>
<td style="text-align: left;">Gold</td>
<td style="text-align: left;">7</td>
<td style="text-align: left;">$\boldsymbol{X}$</td>
<td style="text-align: left;">42.6</td>
<td style="text-align: left;">63.1</td>
<td style="text-align: left;">78.3</td>
</tr>
<tr>
<td style="text-align: left;">Gold</td>
<td style="text-align: left;">7</td>
<td style="text-align: left;">$\checkmark$</td>
<td style="text-align: left;">51.1</td>
<td style="text-align: left;">69.1</td>
<td style="text-align: left;">80.8</td>
</tr>
<tr>
<td style="text-align: left;">Gold</td>
<td style="text-align: left;">31</td>
<td style="text-align: left;">$\checkmark$</td>
<td style="text-align: left;">52.1</td>
<td style="text-align: left;">70.8</td>
<td style="text-align: left;">82.1</td>
</tr>
<tr>
<td style="text-align: left;">Gold</td>
<td style="text-align: left;">127</td>
<td style="text-align: left;">$\checkmark$</td>
<td style="text-align: left;">55.8</td>
<td style="text-align: left;">73.0</td>
<td style="text-align: left;">83.1</td>
</tr>
<tr>
<td style="text-align: left;">G.+BM25 ${ }^{(1)}$</td>
<td style="text-align: left;">$31+32$</td>
<td style="text-align: left;">$\checkmark$</td>
<td style="text-align: left;">65.0</td>
<td style="text-align: left;">77.3</td>
<td style="text-align: left;">84.4</td>
</tr>
<tr>
<td style="text-align: left;">G.+BM25 ${ }^{(2)}$</td>
<td style="text-align: left;">$31+64$</td>
<td style="text-align: left;">$\checkmark$</td>
<td style="text-align: left;">64.5</td>
<td style="text-align: left;">76.4</td>
<td style="text-align: left;">84.0</td>
</tr>
<tr>
<td style="text-align: left;">G.+BM25 ${ }^{(1)}$</td>
<td style="text-align: left;">$127+128$</td>
<td style="text-align: left;">$\checkmark$</td>
<td style="text-align: left;">$\mathbf{6 5 . 8}$</td>
<td style="text-align: left;">$\mathbf{7 8 . 0}$</td>
<td style="text-align: left;">$\mathbf{8 4 . 9}$</td>
</tr>
</tbody>
</table>
<p>Table 3: Comparison of different training schemes, measured as top- $k$ retrieval accuracy on Natural Questions (development set). #N: number of negative examples, IB: in-batch training. G.+BM25 ${ }^{(1)}$ and G.+BM25 ${ }^{(2)}$ denote in-batch training with 1 or 2 additional BM25 negatives, which serve as negative passages for all questions in the batch.</p>
<p>Our experiments on Natural Questions show that switching to distantly-supervised passages (using the highest-ranked BM25 passage that contains the answer), has only a small impact: 1 point lower top- $k$ accuracy for retrieval. Appendix A contains more details.</p>
<p>Similarity and loss Besides dot product, cosine and Euclidean L2 distance are also commonly used as decomposable similarity functions. We test these alternatives and find that L2 performs comparable to dot product, and both of them are superior to cosine. Similarly, in addition to negative loglikelihood, a popular option for ranking is triplet loss, which compares a positive passage and a negative one directly with respect to a question (Burges et al., 2005). Our experiments show that using triplet loss does not affect the results much. More details can be found in Appendix B.</p>
<p>Cross-dataset generalization One interesting question regarding DPR's discriminative training is how much performance degradation it may suffer from a non-iid setting. In other words, can it still generalize well when directly applied to a different dataset without additional fine-tuning? To test the cross-dataset generalization, we train DPR on Natural Questions only and test it directly on the smaller WebQuestions and CuratedTREC datasets. We find that DPR generalizes well, with 3-5 points loss from the best performing fine-tuned model in top-20 retrieval accuracy (69.9/86.3 vs. 75.0/89.1 for WebQuestions and TREC, respectively), while still greatly outperforming the BM25 baseline (55.0/70.9).</p>
<h3>5.3 Qualitative Analysis</h3>
<p>Although DPR performs better than BM25 in general, passages retrieved by these two methods differ qualitatively. Term-matching methods like BM25 are sensitive to highly selective keywords and phrases, while DPR captures lexical variations or semantic relationships better. See Appendix C for examples and more discussion.</p>
<h3>5.4 Run-time Efficiency</h3>
<p>The main reason that we require a retrieval component for open-domain QA is to reduce the number of candidate passages that the reader needs to consider, which is crucial for answering user's questions in real-time. We profiled the passage retrieval speed on a server with Intel Xeon CPU E5-2698 v4 @ 2.20 GHz and 512 GB memory. With the help of FAISS in-memory index for real-valued vectors ${ }^{10}$, DPR can be made incredibly efficient, processing 995.0 questions per second, returning top 100 passages per question. In contrast, BM25/Lucene (implemented in Java, using file index) processes 23.7 questions per second per CPU thread.</p>
<p>On the other hand, the time required for building an index for dense vectors is much longer. Computing dense embeddings on 21-million passages is resource intensive, but can be easily parallelized, taking roughly 8.8 hours on 8 GPUs. However, building the FAISS index on 21-million vectors on a single server takes 8.5 hours. In comparison, building an inverted index using Lucene is much cheaper and takes only about 30 minutes in total.</p>
<h2>6 Experiments: Question Answering</h2>
<p>In this section, we experiment with how different passage retrievers affect the final QA accuracy.</p>
<h3>6.1 End-to-end QA System</h3>
<p>We implement an end-to-end question answering system in which we can plug different retriever systems directly. Besides the retriever, our QA system consists of a neural reader that outputs the answer to the question. Given the top $k$ retrieved passages (up to 100 in our experiments), the reader assigns a passage selection score to each passage. In addition, it extracts an answer span from each passage and assigns a span score. The best span from the passage with the highest passage selection</p>
<p><sup id="fnref5:0"><a class="footnote-ref" href="#fn:0">1</a></sup>score is chosen as the final answer. The passage selection model serves as a reranker through crossattention between the question and the passage. Although cross-attention is not feasible for retrieving relevant passages in a large corpus due to its nondecomposable nature, it has more capacity than the dual-encoder model $\operatorname{sim}(q, p)$ as in Eq. (1). Applying it to selecting the passage from a small number of retrieved candidates has been shown to work well (Wang et al., 2019, 2018; Lin et al., 2018).</p>
<p>Specifically, let $\mathbf{P}_{i} \in \mathbb{R}^{L \times h}(1 \leq i \leq k)$ be a BERT (base, uncased in our experiments) representation for the $i$-th passage, where $L$ is the maximum length of the passage and $h$ the hidden dimension. The probabilities of a token being the starting/ending positions of an answer span and a passage being selected are defined as:</p>
<p>$$
\begin{aligned}
P_{\text {start }, i}(s) &amp; =\operatorname{softmax}\left(\mathbf{P}<em _start="{start" _text="\text">{i} \mathbf{w}</em>\right)}<em _end="{end" _text="\text">{s} \
P</em>}, i}(t) &amp; =\operatorname{softmax}\left(\mathbf{P<em _end="{end" _text="\text">{i} \mathbf{w}</em>\right)}<em _selected="{selected" _text="\text">{t} \
P</em>}}(i) &amp; =\operatorname{softmax}\left(\tilde{\mathbf{P}}^{\mathrm{T}} \mathbf{w<em i="i">{\text {selected }}\right)</em>
\end{aligned}
$$</p>
<p>where $\tilde{\mathbf{P}}=\left[\mathbf{P}<em k="k">{1}^{[\mathrm{CLS}]}, \ldots, \mathbf{P}</em>}^{[\mathrm{CLS}]}\right] \in \mathbb{R}^{h \times k}$ and $\mathbf{w<em _end="{end" _text="\text">{\text {start }}, \mathbf{w}</em>}}, \mathbf{w<em _start="{start" _text="\text">{\text {selected }} \in \mathbb{R}^{h}$ are learnable vectors. We compute a span score of the $s$-th to $t$-th words from the $i$-th passage as $P</em>(i)$.}, i}(s) \times P_{\text {end }, i}(t)$, and a passage selection score of the $i$-th passage as $P_{\text {selected }</p>
<p>During training, we sample one positive and $\tilde{m}-1$ negative passages from the top 100 passages returned by the retrieval system (BM25 or DPR) for each question. $\tilde{m}$ is a hyper-parameter and we use $\tilde{m}=24$ in all the experiments. The training objective is to maximize the marginal log-likelihood of all the correct answer spans in the positive passage (the answer string may appear multiple times in one passage), combined with the log-likelihood of the positive passage being selected. We use the batch size of 16 for large (NQ, TriviaQA, SQuAD) and 4 for small (TREC, WQ) datasets, and tune $k$ on the development set. For experiments on small datasets under the Multi setting, in which using other datasets is allowed, we fine-tune the reader trained on Natural Questions to the target dataset. All experiments were done on eight 32GB GPUs.</p>
<h3>6.2 Results</h3>
<p>Table 4 summarizes our final end-to-end QA results, measured by exact match with the reference answer after minor normalization as in (Chen et al., 2017; Lee et al., 2019). From the table, we can</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Training</th>
<th style="text-align: center;">Model</th>
<th style="text-align: center;">NQ</th>
<th style="text-align: center;">TriviaQA</th>
<th style="text-align: center;">WQ</th>
<th style="text-align: center;">TREC</th>
<th style="text-align: center;">SQuAD</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Single</td>
<td style="text-align: center;">BM25+BERT (Lee et al., 2019)</td>
<td style="text-align: center;">26.5</td>
<td style="text-align: center;">47.1</td>
<td style="text-align: center;">17.7</td>
<td style="text-align: center;">21.3</td>
<td style="text-align: center;">33.2</td>
</tr>
<tr>
<td style="text-align: center;">Single</td>
<td style="text-align: center;">ORQA (Lee et al., 2019)</td>
<td style="text-align: center;">33.3</td>
<td style="text-align: center;">45.0</td>
<td style="text-align: center;">36.4</td>
<td style="text-align: center;">30.1</td>
<td style="text-align: center;">20.2</td>
</tr>
<tr>
<td style="text-align: center;">Single</td>
<td style="text-align: center;">HardEM (Min et al., 2019a)</td>
<td style="text-align: center;">28.1</td>
<td style="text-align: center;">50.9</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">Single</td>
<td style="text-align: center;">GraphRetriever (Min et al., 2019b)</td>
<td style="text-align: center;">34.5</td>
<td style="text-align: center;">56.0</td>
<td style="text-align: center;">36.4</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">Single</td>
<td style="text-align: center;">PathRetriever (Asai et al., 2020)</td>
<td style="text-align: center;">32.6</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">56.5</td>
</tr>
<tr>
<td style="text-align: center;">Single</td>
<td style="text-align: center;">REALM $_{\text {Wiki }}$ (Guu et al., 2020)</td>
<td style="text-align: center;">39.2</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">40.2</td>
<td style="text-align: center;">46.8</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">Single</td>
<td style="text-align: center;">REALM $_{\text {News }}$ (Guu et al., 2020)</td>
<td style="text-align: center;">40.4</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">40.7</td>
<td style="text-align: center;">42.9</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">Single</td>
<td style="text-align: center;">BM25</td>
<td style="text-align: center;">32.6</td>
<td style="text-align: center;">52.4</td>
<td style="text-align: center;">29.9</td>
<td style="text-align: center;">24.9</td>
<td style="text-align: center;">38.1</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">DPR</td>
<td style="text-align: center;">41.5</td>
<td style="text-align: center;">56.8</td>
<td style="text-align: center;">34.6</td>
<td style="text-align: center;">25.9</td>
<td style="text-align: center;">29.8</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">BM25+DPR</td>
<td style="text-align: center;">39.0</td>
<td style="text-align: center;">57.0</td>
<td style="text-align: center;">35.2</td>
<td style="text-align: center;">28.0</td>
<td style="text-align: center;">36.7</td>
</tr>
<tr>
<td style="text-align: center;">Multi</td>
<td style="text-align: center;">DPR</td>
<td style="text-align: center;">41.5</td>
<td style="text-align: center;">56.8</td>
<td style="text-align: center;">42.4</td>
<td style="text-align: center;">49.4</td>
<td style="text-align: center;">24.1</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">BM25+DPR</td>
<td style="text-align: center;">38.8</td>
<td style="text-align: center;">57.9</td>
<td style="text-align: center;">41.1</td>
<td style="text-align: center;">50.6</td>
<td style="text-align: center;">35.8</td>
</tr>
</tbody>
</table>
<p>Table 4: End-to-end QA (Exact Match) Accuracy. The first block of results are copied from their cited papers. REALM $<em _News="{News" _text="\text">{\text {Wiki }}$ and REALM $</em>$ are the same model but pretrained on Wikipedia and CC-News, respectively. Single and Multi denote that our Dense Passage Retriever (DPR) is trained using individual or combined training datasets (all except SQuAD). For WQ and TREC in the Multi setting, we fine-tune the reader trained on NQ.
see that higher retriever accuracy typically leads to better final QA results: in all cases except SQuAD, answers extracted from the passages retrieved by DPR are more likely to be correct, compared to those from BM25. For large datasets like NQ and TriviaQA, models trained using multiple datasets (Multi) perform comparably to those trained using the individual training set (Single). Conversely, on smaller datasets like WQ and TREC, the multidataset setting has a clear advantage. Overall, our DPR-based models outperform the previous state-of-the-art results on four out of the five datasets, with $1 \%$ to $12 \%$ absolute differences in exact match accuracy. It is interesting to contrast our results to those of ORQA (Lee et al., 2019) and also the concurrently developed approach, REALM (Guu et al., 2020). While both methods include additional pretraining tasks and employ an expensive end-to-end training regime, DPR manages to outperform them on both NQ and TriviaQA, simply by focusing on learning a strong passage retrieval model using pairs of questions and answers. The additional pretraining tasks are likely more useful only when the target training sets are small. Although the results of DPR on WQ and TREC in the single-dataset setting are less competitive, adding more question-answer pairs helps boost the performance, achieving the new state of the art.}</p>
<p>To compare our pipeline training approach with joint learning, we run an ablation on Natural Questions where the retriever and reader are jointly
trained, following Lee et al. (2019). This approach obtains a score of 39.8 EM, which suggests that our strategy of training a strong retriever and reader in isolation can leverage effectively available supervision, while outperforming a comparable joint training approach with a simpler design (Appendix D).</p>
<p>One thing worth noticing is that our reader does consider more passages compared to ORQA, although it is not completely clear how much more time it takes for inference. While DPR processes up to 100 passages for each question, the reader is able to fit all of them into one batch on a single 32GB GPU, thus the latency remains almost identical to the single passage case (around 20ms). The exact impact on throughput is harder to measure: ORQA uses 2-3x longer passages compared to DPR ( 288 word pieces compared to our 100 tokens) and the computational complexity is superlinear in passage length. We also note that we found $k=50$ to be optimal for NQ , and $k=10$ leads to only marginal loss in exact match accuracy ( 40.8 vs. 41.5 EM on NQ), which should be roughly comparable to ORQA's 5-passage setup.</p>
<h2>7 Related Work</h2>
<p>Passage retrieval has been an important component for open-domain QA (Voorhees, 1999). It not only effectively reduces the search space for answer extraction, but also identifies the support context for users to verify the answer. Strong sparse vector space models like TF-IDF or BM25 have</p>
<p>been used as the standard method applied broadly to various QA tasks (e.g., Chen et al., 2017; Yang et al., 2019a,b; Nie et al., 2019; Min et al., 2019a; Wolfson et al., 2020). Augmenting text-based retrieval with external structured information, such as knowledge graph and Wikipedia hyperlinks, has also been explored recently (Min et al., 2019b; Asai et al., 2020).</p>
<p>The use of dense vector representations for retrieval has a long history since Latent Semantic Analysis (Deerwester et al., 1990). Using labeled pairs of queries and documents, discriminatively trained dense encoders have become popular recently (Yih et al., 2011; Huang et al., 2013; Gillick et al., 2019), with applications to cross-lingual document retrieval, ad relevance prediction, Web search and entity retrieval. Such approaches complement the sparse vector methods as they can potentially give high similarity scores to semantically relevant text pairs, even without exact token matching. The dense representation alone, however, is typically inferior to the sparse one. While not the focus of this work, dense representations from pretrained models, along with cross-attention mechanisms, have also been shown effective in passage or dialogue re-ranking tasks (Nogueira and Cho, 2019; Humeau et al., 2020). Finally, a concurrent work (Khattab and Zaharia, 2020) demonstrates the feasibility of full dense retrieval in IR tasks. Instead of employing the dual-encoder framework, they introduced a late-interaction operator on top of the BERT encoders.</p>
<p>Dense retrieval for open-domain QA has been explored by Das et al. (2019), who propose to retrieve relevant passages iteratively using reformulated question vectors. As an alternative approach that skips passage retrieval, Seo et al. (2019) propose to encode candidate answer phrases as vectors and directly retrieve the answers to the input questions efficiently. Using additional pretraining with the objective that matches surrogates of questions and relevant passages, Lee et al. (2019) jointly train the question encoder and reader. Their approach outperforms the BM25 plus reader paradigm on multiple open-domain QA datasets in QA accuracy, and is further extended by REALM (Guu et al., 2020), which includes tuning the passage encoder asynchronously by re-indexing the passages during training. The pretraining objective has also recently been improved by Xiong et al. (2020b). In contrast, our model provides a simple and yet
effective solution that shows stronger empirical performance, without relying on additional pretraining or complex joint training schemes.</p>
<p>DPR has also been used as an important module in very recent work. For instance, extending the idea of leveraging hard negatives, Xiong et al. (2020a) use the retrieval model trained in the previous iteration to discover new negatives and construct a different set of examples in each training iteration. Starting from our trained DPR model, they show that the retrieval performance can be further improved. Recent work (Izacard and Grave, 2020; Lewis et al., 2020b) have also shown that DPR can be combined with generation models such as BART (Lewis et al., 2020a) and T5 (Raffel et al., 2019), achieving good performance on open-domain QA and other knowledge-intensive tasks.</p>
<h2>8 Conclusion</h2>
<p>In this work, we demonstrated that dense retrieval can outperform and potentially replace the traditional sparse retrieval component in open-domain question answering. While a simple dual-encoder approach can be made to work surprisingly well, we showed that there are some critical ingredients to training a dense retriever successfully. Moreover, our empirical analysis and ablation studies indicate that more complex model frameworks or similarity functions do not necessarily provide additional values. As a result of improved retrieval performance, we obtained new state-of-the-art results on multiple open-domain question answering benchmarks.</p>
<h2>Acknowledgments</h2>
<p>We thank the anonymous reviewers for their helpful comments and suggestions.</p>
<h2>References</h2>
<p>Akari Asai, Kazuma Hashimoto, Hannaneh Hajishirzi, Richard Socher, and Caiming Xiong. 2020. Learning to retrieve reasoning paths over Wikipedia graph for question answering. In International Conference on Learning Representations (ICLR).</p>
<p>Petr Baudiš and Jan Šedivỳ. 2015. Modeling of the question answering task in the yodaqa system. In International Conference of the Cross-Language Evaluation Forum for European Languages, pages 222228. Springer.</p>
<p>Jonathan Berant, Andrew Chou, Roy Frostig, and Percy Liang. 2013. Semantic parsing on Freebase from</p>
<p>question-answer pairs. In Empirical Methods in Natural Language Processing (EMNLP).</p>
<p>Jane Bromley, Isabelle Guyon, Yann LeCun, Eduard Säckinger, and Roopak Shah. 1994. Signature verification using a "Siamese" time delay neural network. In NIPS, pages 737-744.</p>
<p>Chris Burges, Tal Shaked, Erin Renshaw, Ari Lazier, Matt Deeds, Nicole Hamilton, and Greg Hullender. 2005. Learning to rank using gradient descent. In Proceedings of the 22nd international conference on Machine learning, pages 89-96.</p>
<p>Danqi Chen, Adam Fisch, Jason Weston, and Antoine Bordes. 2017. Reading Wikipedia to answer opendomain questions. In Association for Computational Linguistics (ACL), pages 1870-1879.</p>
<p>Rajarshi Das, Shehzaad Dhuliawala, Manzil Zaheer, and Andrew McCallum. 2019. Multi-step retrieverreader interaction for scalable open-domain question answering. In International Conference on Learning Representations (ICLR).</p>
<p>Scott Deerwester, Susan T Dumais, George W Furnas, Thomas K Landauer, and Richard Harshman. 1990. Indexing by latent semantic analysis. Journal of the American society for information science, 41(6):391-407.</p>
<p>Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2019. BERT: Pre-training of deep bidirectional transformers for language understanding. In North American Association for Computational Linguistics (NAACL).</p>
<p>David A Ferrucci. 2012. Introduction to "This is Watson". IBM Journal of Research and Development, 56(3.4):1-1.</p>
<p>Daniel Gillick, Sayali Kulkarni, Larry Lansing, Alessandro Presta, Jason Baldridge, Eugene Ie, and Diego Garcia-Olano. 2019. Learning dense representations for entity retrieval. In Computational Natural Language Learning (CoNLL).</p>
<p>Ruiqi Guo, Sanjiv Kumar, Krzysztof Choromanski, and David Simcha. 2016. Quantization based fast inner product search. In Artificial Intelligence and Statistics, pages 482-490.</p>
<p>Kelvin Guu, Kenton Lee, Zora Tung, Panupong Pasupat, and Ming-Wei Chang. 2020. REALM: Retrieval-augmented language model pre-training. ArXiv, abs/2002.08909.</p>
<p>Matthew Henderson, Rami Al-Rfou, Brian Strope, Yunhsuan Sung, László Lukács, Ruiqi Guo, Sanjiv Kumar, Balint Miklos, and Ray Kurzweil. 2017. Efficient natural language response suggestion for smart reply. ArXiv, abs/1705.00652.</p>
<p>Po-Sen Huang, Xiaodong He, Jianfeng Gao, Li Deng, Alex Acero, and Larry Heck. 2013. Learning deep structured semantic models for Web search using
clickthrough data. In ACM International Conference on Information and Knowledge Management (CIKM), pages 2333-2338.</p>
<p>Samuel Humeau, Kurt Shuster, Marie-Anne Lachaux, and Jason Weston. 2020. Poly-encoders: Architectures and pre-training strategies for fast and accurate multi-sentence scoring. In International Conference on Learning Representations (ICLR).</p>
<p>Gautier Izacard and Edouard Grave. 2020. Leveraging passage retrieval with generative models for open domain question answering. ArXiv, abs/2007.01282.</p>
<p>Jeff Johnson, Matthijs Douze, and Hervé Jégou. 2017. Billion-scale similarity search with GPUs. ArXiv, abs/1702.08734.</p>
<p>Mandar Joshi, Eunsol Choi, Daniel Weld, and Luke Zettlemoyer. 2017. TriviaQA: A large scale distantly supervised challenge dataset for reading comprehension. In Association for Computational Linguistics (ACL), pages 1601-1611.</p>
<p>Omar Khattab and Matei Zaharia. 2020. ColBERT: Efficient and effective passage search via contextualized late interaction over BERT. In ACM SIGIR Conference on Research and Development in Information Retrieval (SIGIR), pages 39-48.</p>
<p>Brian Kulis. 2013. Metric learning: A survey. Foundations and Trends in Machine Learning, 5(4):287364.</p>
<p>Tom Kwiatkowski, Jennimaria Palomaki, Olivia Redfield, Michael Collins, Ankur Parikh, Chris Alberti, Danielle Epstein, Illia Polosukhin, Matthew Kelcey, Jacob Devlin, Kenton Lee, Kristina N. Toutanova, Llion Jones, Ming-Wei Chang, Andrew Dai, Jakob Uszkoreit, Quoc Le, and Slav Petrov. 2019. Natural questions: a benchmark for question answering research. Transactions of the Association of Computational Linguistics (TACL).</p>
<p>Kenton Lee, Ming-Wei Chang, and Kristina Toutanova. 2019. Latent retrieval for weakly supervised open domain question answering. In Association for Computational Linguistics (ACL), pages 6086-6096.</p>
<p>Mike Lewis, Yinhan Liu, Naman Goyal, Marjan Ghazvininejad, Abdelrahman Mohamed, Omer Levy, Veselin Stoyanov, and Luke Zettlemoyer. 2020a. BART: Denoising sequence-to-sequence pretraining for natural language generation, translation, and comprehension. In Association for Computational Linguistics (ACL), pages 7871-7880.</p>
<p>Patrick Lewis, Ethan Perez, Aleksandara Piktus, Fabio Petroni, Vladimir Karpukhin, Naman Goyal, Heinrich Küttler, Mike Lewis, Wen-tau Yih, Tim Rocktäschel, Sebastian Riedel, and Douwe Kiela. 2020b. Retrieval-augmented generation for knowledge-intensive NLP tasks. In Advances in Neural Information Processing Systems (NeurIPS).</p>
<p>Yankai Lin, Haozhe Ji, Zhiyuan Liu, and Maosong Sun. 2018. Denoising distantly supervised open-domain question answering. In Association for Computational Linguistics (ACL), pages 1736-1745.</p>
<p>Sewon Min, Danqi Chen, Hannaneh Hajishirzi, and Luke Zettlemoyer. 2019a. A discrete hard EM approach for weakly supervised question answering. In Empirical Methods in Natural Language Processing (EMNLP).</p>
<p>Sewon Min, Danqi Chen, Luke Zettlemoyer, and Hannaneh Hajishirzi. 2019b. Knowledge guided text retrieval and reading for open domain question answering. ArXiv, abs/1911.03868.</p>
<p>Dan Moldovan, Marius Paşca, Sanda Harabagiu, and Mihai Surdeanu. 2003. Performance issues and error analysis in an open-domain question answering system. ACM Transactions on Information Systems (TOIS), 21(2):133-154.</p>
<p>Stephen Mussmann and Stefano Ermon. 2016. Learning and inference via maximum inner product search. In International Conference on Machine Learning (ICML), pages 2587-2596.</p>
<p>Yixin Nie, Songhe Wang, and Mohit Bansal. 2019. Revealing the importance of semantic retrieval for machine reading at scale. In Empirical Methods in Natural Language Processing (EMNLP).</p>
<p>Rodrigo Nogueira and Kyunghyun Cho. 2019. Passage re-ranking with BERT. ArXiv, abs/1901.04085.</p>
<p>Colin Raffel, Noam Shazeer, Adam Roberts, Katherine Lee, Sharan Narang, Michael Matena, Yanqi Zhou, Wei Li, and Peter J Liu. 2019. Exploring the limits of transfer learning with a unified text-to-text transformer. ArXiv, abs/1910.10683.</p>
<p>Pranav Rajpurkar, Jian Zhang, Konstantin Lopyrev, and Percy Liang. 2016. SQuAD: 100,000+ questions for machine comprehension of text. In Empirical Methods in Natural Language Processing (EMNLP), pages 2383-2392.</p>
<p>Parikshit Ram and Alexander G Gray. 2012. Maximum inner-product search using cone trees. In Proceedings of the 18th ACM SIGKDD international conference on Knowledge discovery and data mining, pages 931-939.</p>
<p>Adam Roberts, Colin Raffel, and Noam Shazeer. 2020. How much knowledge can you pack into the parameters of a language model? ArXiv, abs/2002.08910.</p>
<p>Stephen Robertson and Hugo Zaragoza. 2009. The probabilistic relevance framework: BM25 and beyond. Foundations and Trends in Information Retrieval, 3(4):333-389.</p>
<p>Minjoon Seo, Jinhyuk Lee, Tom Kwiatkowski, Ankur Parikh, Ali Farhadi, and Hannaneh Hajishirzi. 2019. Real-time open-domain question answering with dense-sparse phrase index. In Association for Computational Linguistics (ACL).</p>
<p>Anshumali Shrivastava and Ping Li. 2014. Asymmetric LSH (ALSH) for sublinear time maximum inner product search (MIPS). In Advances in Neural Information Processing Systems (NIPS), pages 23212329.</p>
<p>Ellen M Voorhees. 1999. The TREC-8 question answering track report. In TREC, volume 99, pages $77-82$.</p>
<p>Shuohang Wang, Mo Yu, Xiaoxiao Guo, Zhiguo Wang, Tim Klinger, Wei Zhang, Shiyu Chang, Gerry Tesauro, Bowen Zhou, and Jing Jiang. 2018. R'3: Reinforced ranker-reader for open-domain question answering. In Conference on Artificial Intelligence (AAAI).</p>
<p>Zhiguo Wang, Patrick Ng, Xiaofei Ma, Ramesh Nallapati, and Bing Xiang. 2019. Multi-passage BERT: A globally normalized bert model for open-domain question answering. In Empirical Methods in Natural Language Processing (EMNLP).</p>
<p>Tomer Wolfson, Mor Geva, Ankit Gupta, Matt Gardner, Yoav Goldberg, Daniel Deutch, and Jonathan Berant. 2020. Break it down: A question understanding benchmark. Transactions of the Association of Computational Linguistics (TACL).</p>
<p>Lee Xiong, Chenyan Xiong, Ye Li, Kwok-Fung Tang, Jialin Liu, Paul Bennett, Junaid Ahmed, and Arnold Overwijk. 2020a. Approximate nearest neighbor negative contrastive learning for dense text retrieval. ArXiv, abs/2007.00808.</p>
<p>Wenhan Xiong, Hankang Wang, and William Yang Wang. 2020b. Progressively pretrained dense corpus index for open-domain question answering. ArXiv, abs/2005.00038.</p>
<p>Wei Yang, Yuqing Xie, Aileen Lin, Xingyu Li, Luchen Tan, Kun Xiong, Ming Li, and Jimmy Lin. 2019a. End-to-end open-domain question answering with bertserini. In North American Association for Computational Linguistics (NAACL), pages 72-77.</p>
<p>Wei Yang, Yuqing Xie, Luchen Tan, Kun Xiong, Ming Li, and Jimmy Lin. 2019b. Data augmentation for bert fine-tuning in open-domain question answering. ArXiv, abs/1904.06652.</p>
<p>Wen-tau Yih, Kristina Toutanova, John C Platt, and Christopher Meek. 2011. Learning discriminative projections for text similarity measures. In Computational Natural Language Learning (CoNLL), pages 247-256.</p>
<h2>A Distant Supervision</h2>
<p>When training our final DPR model using Natural Questions, we use the passages in our collection that best match the gold context as the positive passages. As some QA datasets contain only the question and answer pairs, it is thus interesting to see when using the passages that contain the answers as positives (i.e., the distant supervision setting), whether there is a significant performance degradation. Using the question and answer together as the query, we run Lucene-BM25 and pick the top passage that contains the answer as the positive passage. Table 5 shows the performance of DPR when trained using the original setting and the distant supervision setting.</p>
<h2>B Alternative Similarity Functions \&amp; Triplet Loss</h2>
<p>In addition to dot product (DP) and negative loglikelihood based on softmax (NLL), we also experiment with Euclidean distance (L2) and the triplet loss. We negate L2 similarity scores before applying softmax and change signs of question-topositive and question-to-negative similarities when applying the triplet loss on dot product scores. The margin value of the triplet loss is set to 1 . Table 6 summarizes the results. All these additional experiments are conducted using the same hyperparameters tuned for the baseline (DP, NLL).</p>
<p>Note that the retrieval accuracy for our "baseline" settings reported in Table 5 (Gold) and Table 6 (DP, NLL) is slightly better than those reported in Table 3. This is due to a better hyper-parameter setting used in these analysis experiments, which is documented in our code release.</p>
<h2>C Qualitative Analysis</h2>
<p>Although DPR performs better than BM25 in general, the retrieved passages of these two retrievers actually differ qualitatively. Methods like BM25 are sensitive to highly selective keywords and phrases, but cannot capture lexical variations or semantic relationships well. In contrast, DPR excels at semantic representation, but might lack sufficient capacity to represent salient phrases which appear rarely. Table 7 illustrates this phenomenon with two examples. In the first example, the top scoring passage from BM25 is irrelevant, even though keywords such as England and Ireland appear multiple times. In comparison, DPR is able to return</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: center;">Top-1</th>
<th style="text-align: center;">Top-5</th>
<th style="text-align: center;">Top-20</th>
<th style="text-align: center;">Top-100</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Gold</td>
<td style="text-align: center;">44.9</td>
<td style="text-align: center;">66.8</td>
<td style="text-align: center;">78.1</td>
<td style="text-align: center;">85.0</td>
</tr>
<tr>
<td style="text-align: left;">Dist. Sup.</td>
<td style="text-align: center;">43.9</td>
<td style="text-align: center;">65.3</td>
<td style="text-align: center;">77.1</td>
<td style="text-align: center;">84.4</td>
</tr>
</tbody>
</table>
<p>Table 5: Retrieval accuracy on the development set of Natural Questions, trained on passages that match the gold context (Gold) or the top BM25 passage that contains the answer (Dist. Sup.).</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Sim</th>
<th style="text-align: center;">Loss</th>
<th style="text-align: center;">Retrieval Accuracy</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Top-1</td>
<td style="text-align: center;">Top-5</td>
<td style="text-align: center;">Top-20</td>
<td style="text-align: center;">Top-100</td>
</tr>
<tr>
<td style="text-align: center;">DP</td>
<td style="text-align: center;">NLL</td>
<td style="text-align: center;">44.9</td>
<td style="text-align: center;">66.8</td>
<td style="text-align: center;">78.1</td>
<td style="text-align: center;">85.0</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Triplet</td>
<td style="text-align: center;">41.6</td>
<td style="text-align: center;">65.0</td>
<td style="text-align: center;">77.2</td>
<td style="text-align: center;">84.5</td>
</tr>
<tr>
<td style="text-align: center;">L2</td>
<td style="text-align: center;">NLL</td>
<td style="text-align: center;">43.5</td>
<td style="text-align: center;">64.7</td>
<td style="text-align: center;">76.1</td>
<td style="text-align: center;">83.1</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Triplet</td>
<td style="text-align: center;">42.2</td>
<td style="text-align: center;">66.0</td>
<td style="text-align: center;">78.1</td>
<td style="text-align: center;">84.9</td>
</tr>
</tbody>
</table>
<p>Table 6: Retrieval Top- $k$ accuracy on the development set of Natural Questions using different similarity and loss functions.
the correct answer, presumably by matching "body of water" with semantic neighbors such as sea and channel, even though no lexical overlap exists. The second example is one where BM25 does better. The salient phrase "Thoros of Myr" is critical, and DPR is unable to capture it.</p>
<h2>D Joint Training of Retriever and Reader</h2>
<p>We fix the passage encoder in our joint-training scheme while allowing only the question encoder to receive backpropagation signal from the combined (retriever + reader) loss function. This allows us to leverage the HNSW-based FAISS index for efficient low-latency retrieving, without reindexing the passages during model updates. Our loss function largely follows ORQA's approach, which uses log probabilities of positive passages selected from the retriever model, and correct spans and passages selected from the reader model. Since the passage encoder is fixed, we could use larger amount of retrieved passages when calculating the retriever loss. Specifically, we get top 100 passages for each question in a mini-batch and use the method similar to in-batch negative training: all retrieved passages' vectors participate in the loss calculation for all questions in a batch. Our training batch size is set to 16 , which effectively gives 1,600 passages per question to calculate retriever loss. The reader still uses 24 passages per question, which are selected</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Question</th>
<th style="text-align: center;">Passage received by BM25</th>
<th style="text-align: center;">Passage retrieved by DPR</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">What is the body of water between England and Ireland?</td>
<td style="text-align: center;">Title:British Cycling <br> ...England is not recognised as a region by the UCI, and there is no English cycling team outside the Commonwealth Games. For those occasions, British Cycling selects and supports the England team. Cycling is represented on the Isle of Man by the Isle of Man Cycling Association. Cycling in Northern Ireland is organised under Cycling Ulster, part of the all-Ireland governing body Cycling Ireland. Until 2006, a rival governing body existed, ...</td>
<td style="text-align: center;">Title: Irish Sea <br> ...Annual traffic between Great Britain and Ireland amounts to over 12 million passengers and of traded goods. The Irish Sea is connected to the North Atlantic at both its northern and southern ends. To the north, the connection is through the North Channel between Scotland and Northern Ireland and the Malin Sea. The southern end is linked to the Atlantic through the St George's Channel between Ireland and Pembrokeshire, and the Celtic Sea. ...</td>
</tr>
<tr>
<td style="text-align: center;">Who plays Thoros of Myr in Game of Thrones?</td>
<td style="text-align: center;">Title: No One (Game of Thrones) <br> ...He may be "no one," but there's still enough of a person left in him to respect, and admire who this girl is and what she's become. Arya finally tells us something that we've kind of known all along, that she's not no one, she's Arya Stark of Winterfell." "No One" saw the reintroduction of Richard Dormer and Paul Kaye, who portrayed Beric Donifarion and Thoros of Myr, respectively, in the third season, ...</td>
<td style="text-align: center;">Title: Pål Sverre Hagen <br> Pål Sverre Valheim Hagen (born 6 November 1980) is a Norwegian stage and screen actor. He appeared in the Norwegian film "Max Manus" and played Thor Heyerdahl in the Oscar-nominated 2012 film "Kon-Tiki". Pl Hagen was born in Stavanger, Norway, the son of Roar Hagen, a Norwegian cartoonist who has long been associated with Norways largest daily, "VG". He lived in Jtten, a neighborhood in the city of Stavanger in south-western Norway. ...</td>
</tr>
</tbody>
</table>
<p>Table 7: Examples of passages returned from BM25 and DPR. Correct answers are written in blue and the content words in the question are written in bold.
from the top 5 positive and top 30 negative passages (from the set of top 100 passages retrieved from the same question). The question encoder's initial state is taken from a DPR model previously trained on the NQ dataset. The reader's initial state is a BERT-base model. In terms of the end-to-end QA results, our joint-training scheme does not provide better results compared to the usual retriever/reader training pipeline, resulting in the same 39.8 exact match score on NQ dev as in our regular reader model training.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{10}$ FAISS configuration: we used HNSW index type on CPU, neighbors to store per node $=512$, construction time search depth $=200$, search depth $=128$.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref5:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:1">
<p>${ }^{6}$ We use the unfiltered TriviaQA version and discard the noisy evidence documents mined from Bing.
${ }^{7}$ The improvement of using gold contexts over passages that contain answers is small. See Section 5.2 and Appendix A.&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>