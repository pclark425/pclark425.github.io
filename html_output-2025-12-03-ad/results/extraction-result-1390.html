<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-1390 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-1390</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-1390</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-27.html">extraction-schema-27</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of world models used in AI systems, including details about their fidelity, interpretability, computational efficiency, and task-specific utility.</div>
                <p><strong>Paper ID:</strong> paper-1fd4694e7c2d9c872a427d50e81b5475056de6bc</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/1fd4694e7c2d9c872a427d50e81b5475056de6bc" target="_blank">Model-Based Reinforcement Learning for Atari</a></p>
                <p><strong>Paper Venue:</strong> International Conference on Learning Representations</p>
                <p><strong>Paper TL;DR:</strong> Simulated Policy Learning (SimPLe), a complete model-based deep RL algorithm based on video prediction models, is described and a comparison of several model architectures is presented, including a novel architecture that yields the best results in the authors' setting.</p>
                <p><strong>Paper Abstract:</strong> Model-free reinforcement learning (RL) can be used to learn effective policies for complex tasks, such as Atari games, even from image observations. However, this typically requires very large amounts of interaction -- substantially more, in fact, than a human would need to learn the same games. How can people learn so quickly? Part of the answer may be that people can learn how the game works and predict which actions will lead to desirable outcomes. In this paper, we explore how video prediction models can similarly enable agents to solve Atari games with fewer interactions than model-free methods. We describe Simulated Policy Learning (SimPLe), a complete model-based deep RL algorithm based on video prediction models and present a comparison of several model architectures, including a novel architecture that yields the best results in our setting. Our experiments evaluate SimPLe on a range of Atari games in low data regime of 100k interactions between the agent and the environment, which corresponds to two hours of real-time play. In most games SimPLe outperforms state-of-the-art model-free algorithms, in some games by over an order of magnitude.</p>
                <p><strong>Cost:</strong> 0.016</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e1390.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e1390.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of world models used in AI systems, including details about their fidelity, interpretability, computational efficiency, and task-specific utility.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>SD (stochastic discrete)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Stochastic video prediction model with discrete latent variables (proposed)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A novel action-conditioned stochastic video-prediction world model that discretizes latent variables into bits, uses an LSTM to autoregressively predict those bits at inference, and outputs next-frame pixels plus reward; designed to capture stochasticity (occlusions, sprite spawn variation) and improve policy learning in Atari with high sample-efficiency.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Stochastic discrete latent world model (SD)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Convolutional encoder-decoder that takes 4 stacked frames and action embedding, produces next-frame prediction (per-pixel output via either real-valued or 256-way per-channel softmax) and predicted reward; includes an inference network (convolutional) during training to approximate posterior latent bits which are discretized into binary codes; an auxiliary LSTM autoregressively predicts latent bits at inference; uses scheduled sampling, clipped losses, action-conditioning via channel-wise multiplication, dropout and layer normalization.</td>
                        </tr>
                        <tr>
                            <td><strong>model_type</strong></td>
                            <td>latent world model / neural simulator (stochastic, discrete latent)</td>
                        </tr>
                        <tr>
                            <td><strong>task_domain</strong></td>
                            <td>Atari games (Atari Learning Environment)</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_metric</strong></td>
                            <td>Per-pixel loss (L2) or categorical cross-entropy on 256-color softmax; clipped loss used (clipping threshold C=10 for L2, C=0.03 for softmax); reward prediction accuracy per sequence; qualitative metrics such as 'pixel-perfect' prediction intervals and downstream policy score (SimPLe score@100K).</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_performance</strong></td>
                            <td>Qualitative: achieves sharp, plausible stochastic samples and can produce 'pixel-perfect' predictions for short horizons (episodes up to ~50 timesteps observed); no single-number MSE provided in paper. Empirically enabled policies that reach competitive scores within 100K interactions (e.g., >10x sample-efficiency on Freeway vs tuned Rainbow in their evaluation).</td>
                        </tr>
                        <tr>
                            <td><strong>interpretability_assessment</strong></td>
                            <td>Primarily a black-box neural model; limited interpretability via inspection of predicted frames and sampled latent bit configurations (visualized samples show plausible alternatives, e.g., different opponent sets). Latent bits are discrete which may ease inspection but no formal disentanglement claims are made.</td>
                        </tr>
                        <tr>
                            <td><strong>interpretability_method</strong></td>
                            <td>Visualization of predicted frames and sampled stochastic trajectories; qualitative case studies (videos) comparing model rollouts to real environment; no explicit latent disentanglement or attention analyses reported.</td>
                        </tr>
                        <tr>
                            <td><strong>computational_cost</strong></td>
                            <td>Model ≈74M parameters (full model); inference/backprop reported ~0.5s / 0.7s for batch sizes (inference batch 16, backprop batch 2) on NVIDIA Tesla P100; approximately 32 ms per simulated frame from the learned simulator vs ~0.4 ms per frame for the native ALE emulator; world-model training costs substantial compute (world model trained 45K steps first iteration, then 15K steps in later iterations; overall many simulated interactions: ~15.2M in experiments).</td>
                        </tr>
                        <tr>
                            <td><strong>efficiency_comparison</strong></td>
                            <td>Sample efficiency: substantially better than model-free baselines in low-data regime (100K interactions) across many games—on >50% of tested games requires fewer than half the samples of tuned Rainbow; on Freeway >10x more sample-efficient. Computational efficiency: simulator is ~80x slower per frame than native ALE (32ms vs 0.4ms), and training the model is computationally heavy compared to model-free rollouts in the real emulator.</td>
                        </tr>
                        <tr>
                            <td><strong>task_performance</strong></td>
                            <td>When used in SimPLe, policies trained inside this model achieved strong sample-efficiency: on many Atari games SimPLe with SD matched or exceeded the performance of tuned Rainbow and PPO at far fewer real-environment interactions (100K); in specific games achieved pixel-perfect short-term predictions and policy success (e.g., Pong and Freeway solved within 100K).</td>
                        </tr>
                        <tr>
                            <td><strong>task_utility_analysis</strong></td>
                            <td>High-fidelity short-term predictions and plausible stochastic sampling translated to effective policy training in low-data regimes; stochasticity modeling was crucial for games where next outcomes depend on unobserved state (e.g., opponent spawns). However, imperfections and compounding errors limit long-horizon planning; short rollouts and random restarts mitigated but do not fully remove mismatch.</td>
                        </tr>
                        <tr>
                            <td><strong>tradeoffs_observed</strong></td>
                            <td>Design trades off fidelity vs compounding-error-induced utility: higher-fidelity/stochastic modeling (SD) improved task utility and sample-efficiency but increased computational cost. Short rollouts (25–50 steps) reduce model error accumulation but limit learning of long-horizon effects. Discrete latent approach trades off complexity of prior sampling (solved by autoregressive predictor) against increased model machinery and compute. Overall, SD gave best task-utility at the cost of heavier compute and slower per-frame simulation.</td>
                        </tr>
                        <tr>
                            <td><strong>design_choices</strong></td>
                            <td>Discrete binary latent codes predicted autoregressively by an LSTM at inference; add uniform noise before discretization and dropout on bits to improve robustness; action embedding multiplied channel-wise in decoder; per-pixel softmax (256 colors) option; scheduled sampling; clipped loss thresholds; layer normalization and dropout in convolutions; short simulated rollouts with random restarts from buffer D; iterative dataset aggregation (train model —> train policy in model —> collect new real data).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_alternatives</strong></td>
                            <td>Directly compared to deterministic feedforward and deterministic recurrent models: SD performed best (Table 1: SD achieved best score in 8 games and at-least-median in 16; 'default' SD configuration best in 10 / 21). Compared to stochastic Gaussian VAE: SD avoids game-dependent KL weighting and prior mismatch issues and yields sharper samples; compared to model-free RL (Rainbow, PPO): SimPLe+SD is more sample-efficient in low-data regime but yields lower asymptotic scores in many cases and is computationally heavier for simulation and training.</td>
                        </tr>
                        <tr>
                            <td><strong>optimal_configuration</strong></td>
                            <td>Paper recommends the stochastic discrete latent model as preferred for Atari low-data regime; rollout lengths of 25–50 steps with random starts, discount γ≈0.95, iterative dataset aggregation (~15 iterations), scheduled sampling, and substantial model training (longer training improves results). For robustness and future improvements, authors recommend ensembles or Bayesian parameter posteriors.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Model-Based Reinforcement Learning for Atari', 'publication_date_yy_mm': '2019-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1390.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e1390.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of world models used in AI systems, including details about their fidelity, interpretability, computational efficiency, and task-specific utility.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Deterministic feedforward</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Deterministic convolutional action-conditional video prediction model</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A feedforward convolutional encoder-decoder that conditions on past stacked frames and the action to predict the next frame and reward deterministically (architecture based on prior work, used here as a baseline).</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Action-conditional video prediction using deep networks in atari games</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Deterministic action-conditional convolutional model</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Stacked convolutional encoder from four input frames, action one-hot embedding multiplied channel-wise with dense layers, deconvolutional decoder outputs next frame and reward; options for real-valued pixel outputs or 256-way per-channel softmax outputs; trained with clipped L2 or softmax loss and scheduled sampling.</td>
                        </tr>
                        <tr>
                            <td><strong>model_type</strong></td>
                            <td>neural simulator / deterministic world model</td>
                        </tr>
                        <tr>
                            <td><strong>task_domain</strong></td>
                            <td>Atari games</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_metric</strong></td>
                            <td>Per-pixel L2 loss (clipped), categorical cross-entropy on per-pixel softmax; reward prediction accuracy. Prior work reported L2 error over long horizons in some settings.</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_performance</strong></td>
                            <td>Variable: can achieve low L2 error in some games over reasonably long horizons (Oh et al. 2015 reported low L2 error in some cases), but tends to produce blurred predictions when environment exhibits stochasticity or partial observability; in this paper deterministic model performed worse than stochastic discrete and sometimes produced blurred superpositions of possible outcomes.</td>
                        </tr>
                        <tr>
                            <td><strong>interpretability_assessment</strong></td>
                            <td>Black-box neural network with limited interpretability; outputs directly visualizable as predicted frames which provide the main transparency into behavior.</td>
                        </tr>
                        <tr>
                            <td><strong>interpretability_method</strong></td>
                            <td>Visual comparison of predicted frames to ground truth; qualitative analyses of prediction errors and their impact on policy training.</td>
                        </tr>
                        <tr>
                            <td><strong>computational_cost</strong></td>
                            <td>Smaller than the SD model variant (SD uses extra inference and autoregressive latent predictor networks), but still substantial; specific parameter counts for this variant not separately listed; uses same convolutional/deconv stacks and training regime as other models.</td>
                        </tr>
                        <tr>
                            <td><strong>efficiency_comparison</strong></td>
                            <td>Less computationally intensive than stochastic discrete because no inference network and autoregressive latent predictor, but tends to underperform on games where stochasticity matters, reducing task-utility despite lower compute.</td>
                        </tr>
                        <tr>
                            <td><strong>task_performance</strong></td>
                            <td>In ablations deterministic model achieved best score in 0 games (Table 1) and at least median in 7 games; overall inferior to stochastic discrete model in sample-efficient policy learning.</td>
                        </tr>
                        <tr>
                            <td><strong>task_utility_analysis</strong></td>
                            <td>Deterministic predictions can be sufficient when environment is nearly deterministic at the observation horizon, but fail to capture unobserved stochastic events (sprite spawns), producing blurred averages that hurt policy learning; thus lower fidelity in stochastic settings leads to lower task utility.</td>
                        </tr>
                        <tr>
                            <td><strong>tradeoffs_observed</strong></td>
                            <td>Simplicity and lower compute vs inability to model stochasticity and consequent degraded policy training; deterministic models reduce simulator complexity but suffer in games with unobserved randomness.</td>
                        </tr>
                        <tr>
                            <td><strong>design_choices</strong></td>
                            <td>Action-conditioning via embedding multiplied with decoder channels; per-pixel softmax option; scheduled sampling; clipped loss thresholds used to focus gradients on important areas.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_alternatives</strong></td>
                            <td>Compared to SD: deterministic is computationally cheaper but less effective for sample-efficiency and final scores in many games. Compared to deterministic recurrent: recurrent variant sometimes better (det. recurrent best in 3 games). Compared to model-free: as a component of SimPLe, deterministic model led to inferior sample-efficiency versus SD-driven SimPLe.</td>
                        </tr>
                        <tr>
                            <td><strong>optimal_configuration</strong></td>
                            <td>Sufficient for some simple games or short horizons but not recommended when partial observability/stochasticity is significant; scheduled sampling and clipping help, but stochastic latent mechanisms are preferable.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Model-Based Reinforcement Learning for Atari', 'publication_date_yy_mm': '2019-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1390.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e1390.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of world models used in AI systems, including details about their fidelity, interpretability, computational efficiency, and task-specific utility.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Stochastic VAE</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Stochastic variational video prediction model (Gaussian latent VAE)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An action-conditioned stochastic video-prediction model using a VAE-style approximate posterior over continuous Gaussian latents to capture uncertainty; latent sampled from posterior during training and from a Gaussian prior at test time.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Stochastic variational video prediction</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Stochastic VAE latent world model</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Predictive network similar to deterministic model but augmented with a variational posterior network that conditions on the future frame to produce a Gaussian latent z_t; during training z_t is sampled from posterior and fed to predictive model; training includes reconstruction loss plus KL divergence between posterior and N(0,I) prior.</td>
                        </tr>
                        <tr>
                            <td><strong>model_type</strong></td>
                            <td>latent world model (stochastic, continuous Gaussian latent / VAE)</td>
                        </tr>
                        <tr>
                            <td><strong>task_domain</strong></td>
                            <td>Atari games</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_metric</strong></td>
                            <td>Reconstruction loss (per-pixel L2 or categorical), plus KL divergence term; reward prediction accuracy; qualitative sample sharpness.</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_performance</strong></td>
                            <td>Can improve sharpness over deterministic baselines in some cases, but authors observed practical issues: KL weight required tuning per game (typically very small, 1e-3 to 1e-5), leading to posterior-prior mismatch and poor behavior at inference when latent samples from prior differ from training posterior; no single-number fidelity reported in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>interpretability_assessment</strong></td>
                            <td>Black-box latent space; continuous latent not directly interpretable. No explicit interpretability analyses reported for latent factors.</td>
                        </tr>
                        <tr>
                            <td><strong>interpretability_method</strong></td>
                            <td>Visual inspection of sampled frame predictions; qualitative analysis of sample diversity vs realism.</td>
                        </tr>
                        <tr>
                            <td><strong>computational_cost</strong></td>
                            <td>Adds inference network and KL loss, increasing training complexity; authors found the need for careful tuning and saw instability across games, but exact parameter counts/time not separately reported.</td>
                        </tr>
                        <tr>
                            <td><strong>efficiency_comparison</strong></td>
                            <td>Compared to SD: VAE approach required game-dependent KL tuning and often performed worse in practice due to prior mismatch; authors moved to discrete latent approach to avoid these issues. Compared to deterministic: VAE can model stochasticity better but practical challenges limited utility.</td>
                        </tr>
                        <tr>
                            <td><strong>task_performance</strong></td>
                            <td>Used as a candidate stochastic model but found to underperform relative to the proposed discrete-latent SD model due to sensitivity to KL weighting and prior mismatch; specific downstream policy metrics not favorable compared to SD.</td>
                        </tr>
                        <tr>
                            <td><strong>task_utility_analysis</strong></td>
                            <td>Modeling stochasticity with continuous latent can in principle increase task-utility by representing multiple plausible futures, but in practice the VAE's posterior-prior mismatch reduced predictive realism at inference and thus harmed policy training utility.</td>
                        </tr>
                        <tr>
                            <td><strong>tradeoffs_observed</strong></td>
                            <td>VAE introduces additional hyperparameter (KL weight) that is game-dependent; small KL weights lead to posterior divergence and poor sampling from prior at test time. Trade-off between expressive continuous latents vs robustness/tractability—motivated shift to discrete latents.</td>
                        </tr>
                        <tr>
                            <td><strong>design_choices</strong></td>
                            <td>Used approximate posterior network that conditions on future frame; KL regularization term included in loss; at test time latent sampled from N(0,I).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_alternatives</strong></td>
                            <td>Compared unfavorably to discrete-latent SD model in this work due to sensitivity to KL weight and prior mismatch; deterministic models produce blurring while VAE can avoid blurring but suffers from practical inference issues.</td>
                        </tr>
                        <tr>
                            <td><strong>optimal_configuration</strong></td>
                            <td>Authors do not recommend vanilla VAE variant without careful per-game KL tuning; their experiments suggest discrete latent autoregressive prediction is a more robust choice for Atari-like partial observability.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Model-Based Reinforcement Learning for Atari', 'publication_date_yy_mm': '2019-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1390.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e1390.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of world models used in AI systems, including details about their fidelity, interpretability, computational efficiency, and task-specific utility.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>SimPLe world-model pipeline</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Simulated Policy Learning (SimPLe) world-model-based RL pipeline</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An iterative model-based RL system that trains a video-prediction world model from collected real interactions, trains a policy inside that learned simulator (using PPO), and aggregates new real data to retrain the model, achieving high sample-efficiency in Atari low-data regimes.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>SimPLe world-model pipeline (model + policy loop)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Pipeline alternates: collect D <- COLLECT(env, π) using current policy in real env; TRAIN_SUPERVISED(env', D) to update learned world model (deterministic or stochastic); TRAIN_RL(π, env') to optimize policy inside world model using PPO with short simulated rollouts and random restarts from D; iterate (authors used 15 iterations, with 6400 interactions per iteration, totaling ≈102.4K interactions).</td>
                        </tr>
                        <tr>
                            <td><strong>model_type</strong></td>
                            <td>system-level model-based RL pipeline (uses neural simulators for internal training)</td>
                        </tr>
                        <tr>
                            <td><strong>task_domain</strong></td>
                            <td>Atari games</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_metric</strong></td>
                            <td>Downstream policy performance after N real interactions (primary metric); per-pixel predictive losses used for world-model training; reward-prediction correctness per sequence also tracked; ablations examine iteration count, rollout length, γ.</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_performance</strong></td>
                            <td>Enables policies that reach the SimPLe_score@100K across many games; empirical fidelity sufficient to permit successful policy transfer in many games though not perfect—examples of pixel-perfect short predictions (~50 steps) in Pong/Freeway/Breakout; model failures exist for very small objects or large global scene changes.</td>
                        </tr>
                        <tr>
                            <td><strong>interpretability_assessment</strong></td>
                            <td>Pipeline-level interpretability derives from inspecting model rollouts vs real gameplay and qualitative failure modes; no formal interpretability beyond visual analyses and ablations.</td>
                        </tr>
                        <tr>
                            <td><strong>interpretability_method</strong></td>
                            <td>Visualization of rollouts, videos, per-game qualitative case studies; ablation studies to understand effects of rollout length, stochasticity, recurrence, γ, and training length.</td>
                        </tr>
                        <tr>
                            <td><strong>computational_cost</strong></td>
                            <td>Significant: world model ~74M params, heavy training (45K steps first iteration, then 15K), 15.2M simulated env interactions during policy training; learned simulator inference ~32ms/frame on P100 vs ALE ~0.4ms/frame; overall pipeline requires substantial GPU/CPU resources and wall-clock time.</td>
                        </tr>
                        <tr>
                            <td><strong>efficiency_comparison</strong></td>
                            <td>In sample-efficiency (real interactions) SimPLe outperforms tuned Rainbow and PPO across many games at 100K interactions; computationally more expensive in terms of model training and per-frame simulation than model-free training in native emulator; advantage narrows or disappears with large amounts of real data (>500K).</td>
                        </tr>
                        <tr>
                            <td><strong>task_performance</strong></td>
                            <td>SimPLe (with SD model) achieves better sample-efficiency in low-data regime: on more than half the tested games it reaches target scores with less than half the samples required by Rainbow; on Freeway more than 10x more sample-efficient; however final asymptotic scores generally lower than best model-free methods.</td>
                        </tr>
                        <tr>
                            <td><strong>task_utility_analysis</strong></td>
                            <td>Learned simulator enabled efficient policy learning when model was accurate on task-relevant aspects (e.g., moving objects, rewards); short rollouts and random restarts mitigated compounding errors and preserved policy utility; when models failed to capture tiny bullets or large scene teleports, policy performance suffered—so task-utility depends on model fidelity to task-relevant features rather than perfect reconstruction.</td>
                        </tr>
                        <tr>
                            <td><strong>tradeoffs_observed</strong></td>
                            <td>Primary trade-offs: sample-efficiency (real env interactions) vs computational/training cost; model complexity (stochastic discrete) vs simulator speed and stability; short rollouts reduce compounding error but limit learning of long-term dependencies; stochastic modeling improves realism but increases model and inference complexity.</td>
                        </tr>
                        <tr>
                            <td><strong>design_choices</strong></td>
                            <td>Iterative dataset aggregation (train model on aggregated D), PPO inside learned model with short rollouts (N=25–50) and random starts from D, scheduled sampling in model training, clipped pixel losses, use of discrete stochastic latents (recommended), and substantial world-model training early in loop.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_alternatives</strong></td>
                            <td>Compared to model-free RL (Rainbow, PPO): SimPLe is more real-sample-efficient in low-data regimes but computationally heavier and tends to lower asymptotic performance; compared to prior model-based attempts (Oh et al. 2015/2017, Babaeizadeh et al. 2017a, Ha & Schmidhuber 2018), SimPLe demonstrates successful planning/control across a wider set of Atari games and introduces discrete latent approach to improve robustness.</td>
                        </tr>
                        <tr>
                            <td><strong>optimal_configuration</strong></td>
                            <td>Authors' recommended configuration: stochastic discrete latent model, rollout length N in [25,50], γ≈0.95, scheduled sampling, clipped losses, iterative aggregation (~15 iterations), longer world-model training (45K initial steps), and random restarts from real data buffer; suggest future use of ensembles/Bayesian approaches to improve robustness.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Model-Based Reinforcement Learning for Atari', 'publication_date_yy_mm': '2019-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Action-conditional video prediction using deep networks in atari games <em>(Rating: 2)</em></li>
                <li>Stochastic variational video prediction <em>(Rating: 2)</em></li>
                <li>Recurrent environment simulators <em>(Rating: 2)</em></li>
                <li>Recurrent world models facilitate policy evolution <em>(Rating: 2)</em></li>
                <li>Learning latent dynamics for planning from pixels <em>(Rating: 2)</em></li>
                <li>Model-ensemble trust-region policy optimization <em>(Rating: 1)</em></li>
                <li>Woulda, coulda, shoulda: Counterfactually-guided policy search <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-1390",
    "paper_id": "paper-1fd4694e7c2d9c872a427d50e81b5475056de6bc",
    "extraction_schema_id": "extraction-schema-27",
    "extracted_data": [
        {
            "name_short": "SD (stochastic discrete)",
            "name_full": "Stochastic video prediction model with discrete latent variables (proposed)",
            "brief_description": "A novel action-conditioned stochastic video-prediction world model that discretizes latent variables into bits, uses an LSTM to autoregressively predict those bits at inference, and outputs next-frame pixels plus reward; designed to capture stochasticity (occlusions, sprite spawn variation) and improve policy learning in Atari with high sample-efficiency.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "Stochastic discrete latent world model (SD)",
            "model_description": "Convolutional encoder-decoder that takes 4 stacked frames and action embedding, produces next-frame prediction (per-pixel output via either real-valued or 256-way per-channel softmax) and predicted reward; includes an inference network (convolutional) during training to approximate posterior latent bits which are discretized into binary codes; an auxiliary LSTM autoregressively predicts latent bits at inference; uses scheduled sampling, clipped losses, action-conditioning via channel-wise multiplication, dropout and layer normalization.",
            "model_type": "latent world model / neural simulator (stochastic, discrete latent)",
            "task_domain": "Atari games (Atari Learning Environment)",
            "fidelity_metric": "Per-pixel loss (L2) or categorical cross-entropy on 256-color softmax; clipped loss used (clipping threshold C=10 for L2, C=0.03 for softmax); reward prediction accuracy per sequence; qualitative metrics such as 'pixel-perfect' prediction intervals and downstream policy score (SimPLe score@100K).",
            "fidelity_performance": "Qualitative: achieves sharp, plausible stochastic samples and can produce 'pixel-perfect' predictions for short horizons (episodes up to ~50 timesteps observed); no single-number MSE provided in paper. Empirically enabled policies that reach competitive scores within 100K interactions (e.g., &gt;10x sample-efficiency on Freeway vs tuned Rainbow in their evaluation).",
            "interpretability_assessment": "Primarily a black-box neural model; limited interpretability via inspection of predicted frames and sampled latent bit configurations (visualized samples show plausible alternatives, e.g., different opponent sets). Latent bits are discrete which may ease inspection but no formal disentanglement claims are made.",
            "interpretability_method": "Visualization of predicted frames and sampled stochastic trajectories; qualitative case studies (videos) comparing model rollouts to real environment; no explicit latent disentanglement or attention analyses reported.",
            "computational_cost": "Model ≈74M parameters (full model); inference/backprop reported ~0.5s / 0.7s for batch sizes (inference batch 16, backprop batch 2) on NVIDIA Tesla P100; approximately 32 ms per simulated frame from the learned simulator vs ~0.4 ms per frame for the native ALE emulator; world-model training costs substantial compute (world model trained 45K steps first iteration, then 15K steps in later iterations; overall many simulated interactions: ~15.2M in experiments).",
            "efficiency_comparison": "Sample efficiency: substantially better than model-free baselines in low-data regime (100K interactions) across many games—on &gt;50% of tested games requires fewer than half the samples of tuned Rainbow; on Freeway &gt;10x more sample-efficient. Computational efficiency: simulator is ~80x slower per frame than native ALE (32ms vs 0.4ms), and training the model is computationally heavy compared to model-free rollouts in the real emulator.",
            "task_performance": "When used in SimPLe, policies trained inside this model achieved strong sample-efficiency: on many Atari games SimPLe with SD matched or exceeded the performance of tuned Rainbow and PPO at far fewer real-environment interactions (100K); in specific games achieved pixel-perfect short-term predictions and policy success (e.g., Pong and Freeway solved within 100K).",
            "task_utility_analysis": "High-fidelity short-term predictions and plausible stochastic sampling translated to effective policy training in low-data regimes; stochasticity modeling was crucial for games where next outcomes depend on unobserved state (e.g., opponent spawns). However, imperfections and compounding errors limit long-horizon planning; short rollouts and random restarts mitigated but do not fully remove mismatch.",
            "tradeoffs_observed": "Design trades off fidelity vs compounding-error-induced utility: higher-fidelity/stochastic modeling (SD) improved task utility and sample-efficiency but increased computational cost. Short rollouts (25–50 steps) reduce model error accumulation but limit learning of long-horizon effects. Discrete latent approach trades off complexity of prior sampling (solved by autoregressive predictor) against increased model machinery and compute. Overall, SD gave best task-utility at the cost of heavier compute and slower per-frame simulation.",
            "design_choices": "Discrete binary latent codes predicted autoregressively by an LSTM at inference; add uniform noise before discretization and dropout on bits to improve robustness; action embedding multiplied channel-wise in decoder; per-pixel softmax (256 colors) option; scheduled sampling; clipped loss thresholds; layer normalization and dropout in convolutions; short simulated rollouts with random restarts from buffer D; iterative dataset aggregation (train model —&gt; train policy in model —&gt; collect new real data).",
            "comparison_to_alternatives": "Directly compared to deterministic feedforward and deterministic recurrent models: SD performed best (Table 1: SD achieved best score in 8 games and at-least-median in 16; 'default' SD configuration best in 10 / 21). Compared to stochastic Gaussian VAE: SD avoids game-dependent KL weighting and prior mismatch issues and yields sharper samples; compared to model-free RL (Rainbow, PPO): SimPLe+SD is more sample-efficient in low-data regime but yields lower asymptotic scores in many cases and is computationally heavier for simulation and training.",
            "optimal_configuration": "Paper recommends the stochastic discrete latent model as preferred for Atari low-data regime; rollout lengths of 25–50 steps with random starts, discount γ≈0.95, iterative dataset aggregation (~15 iterations), scheduled sampling, and substantial model training (longer training improves results). For robustness and future improvements, authors recommend ensembles or Bayesian parameter posteriors.",
            "uuid": "e1390.0",
            "source_info": {
                "paper_title": "Model-Based Reinforcement Learning for Atari",
                "publication_date_yy_mm": "2019-03"
            }
        },
        {
            "name_short": "Deterministic feedforward",
            "name_full": "Deterministic convolutional action-conditional video prediction model",
            "brief_description": "A feedforward convolutional encoder-decoder that conditions on past stacked frames and the action to predict the next frame and reward deterministically (architecture based on prior work, used here as a baseline).",
            "citation_title": "Action-conditional video prediction using deep networks in atari games",
            "mention_or_use": "use",
            "model_name": "Deterministic action-conditional convolutional model",
            "model_description": "Stacked convolutional encoder from four input frames, action one-hot embedding multiplied channel-wise with dense layers, deconvolutional decoder outputs next frame and reward; options for real-valued pixel outputs or 256-way per-channel softmax outputs; trained with clipped L2 or softmax loss and scheduled sampling.",
            "model_type": "neural simulator / deterministic world model",
            "task_domain": "Atari games",
            "fidelity_metric": "Per-pixel L2 loss (clipped), categorical cross-entropy on per-pixel softmax; reward prediction accuracy. Prior work reported L2 error over long horizons in some settings.",
            "fidelity_performance": "Variable: can achieve low L2 error in some games over reasonably long horizons (Oh et al. 2015 reported low L2 error in some cases), but tends to produce blurred predictions when environment exhibits stochasticity or partial observability; in this paper deterministic model performed worse than stochastic discrete and sometimes produced blurred superpositions of possible outcomes.",
            "interpretability_assessment": "Black-box neural network with limited interpretability; outputs directly visualizable as predicted frames which provide the main transparency into behavior.",
            "interpretability_method": "Visual comparison of predicted frames to ground truth; qualitative analyses of prediction errors and their impact on policy training.",
            "computational_cost": "Smaller than the SD model variant (SD uses extra inference and autoregressive latent predictor networks), but still substantial; specific parameter counts for this variant not separately listed; uses same convolutional/deconv stacks and training regime as other models.",
            "efficiency_comparison": "Less computationally intensive than stochastic discrete because no inference network and autoregressive latent predictor, but tends to underperform on games where stochasticity matters, reducing task-utility despite lower compute.",
            "task_performance": "In ablations deterministic model achieved best score in 0 games (Table 1) and at least median in 7 games; overall inferior to stochastic discrete model in sample-efficient policy learning.",
            "task_utility_analysis": "Deterministic predictions can be sufficient when environment is nearly deterministic at the observation horizon, but fail to capture unobserved stochastic events (sprite spawns), producing blurred averages that hurt policy learning; thus lower fidelity in stochastic settings leads to lower task utility.",
            "tradeoffs_observed": "Simplicity and lower compute vs inability to model stochasticity and consequent degraded policy training; deterministic models reduce simulator complexity but suffer in games with unobserved randomness.",
            "design_choices": "Action-conditioning via embedding multiplied with decoder channels; per-pixel softmax option; scheduled sampling; clipped loss thresholds used to focus gradients on important areas.",
            "comparison_to_alternatives": "Compared to SD: deterministic is computationally cheaper but less effective for sample-efficiency and final scores in many games. Compared to deterministic recurrent: recurrent variant sometimes better (det. recurrent best in 3 games). Compared to model-free: as a component of SimPLe, deterministic model led to inferior sample-efficiency versus SD-driven SimPLe.",
            "optimal_configuration": "Sufficient for some simple games or short horizons but not recommended when partial observability/stochasticity is significant; scheduled sampling and clipping help, but stochastic latent mechanisms are preferable.",
            "uuid": "e1390.1",
            "source_info": {
                "paper_title": "Model-Based Reinforcement Learning for Atari",
                "publication_date_yy_mm": "2019-03"
            }
        },
        {
            "name_short": "Stochastic VAE",
            "name_full": "Stochastic variational video prediction model (Gaussian latent VAE)",
            "brief_description": "An action-conditioned stochastic video-prediction model using a VAE-style approximate posterior over continuous Gaussian latents to capture uncertainty; latent sampled from posterior during training and from a Gaussian prior at test time.",
            "citation_title": "Stochastic variational video prediction",
            "mention_or_use": "use",
            "model_name": "Stochastic VAE latent world model",
            "model_description": "Predictive network similar to deterministic model but augmented with a variational posterior network that conditions on the future frame to produce a Gaussian latent z_t; during training z_t is sampled from posterior and fed to predictive model; training includes reconstruction loss plus KL divergence between posterior and N(0,I) prior.",
            "model_type": "latent world model (stochastic, continuous Gaussian latent / VAE)",
            "task_domain": "Atari games",
            "fidelity_metric": "Reconstruction loss (per-pixel L2 or categorical), plus KL divergence term; reward prediction accuracy; qualitative sample sharpness.",
            "fidelity_performance": "Can improve sharpness over deterministic baselines in some cases, but authors observed practical issues: KL weight required tuning per game (typically very small, 1e-3 to 1e-5), leading to posterior-prior mismatch and poor behavior at inference when latent samples from prior differ from training posterior; no single-number fidelity reported in this paper.",
            "interpretability_assessment": "Black-box latent space; continuous latent not directly interpretable. No explicit interpretability analyses reported for latent factors.",
            "interpretability_method": "Visual inspection of sampled frame predictions; qualitative analysis of sample diversity vs realism.",
            "computational_cost": "Adds inference network and KL loss, increasing training complexity; authors found the need for careful tuning and saw instability across games, but exact parameter counts/time not separately reported.",
            "efficiency_comparison": "Compared to SD: VAE approach required game-dependent KL tuning and often performed worse in practice due to prior mismatch; authors moved to discrete latent approach to avoid these issues. Compared to deterministic: VAE can model stochasticity better but practical challenges limited utility.",
            "task_performance": "Used as a candidate stochastic model but found to underperform relative to the proposed discrete-latent SD model due to sensitivity to KL weighting and prior mismatch; specific downstream policy metrics not favorable compared to SD.",
            "task_utility_analysis": "Modeling stochasticity with continuous latent can in principle increase task-utility by representing multiple plausible futures, but in practice the VAE's posterior-prior mismatch reduced predictive realism at inference and thus harmed policy training utility.",
            "tradeoffs_observed": "VAE introduces additional hyperparameter (KL weight) that is game-dependent; small KL weights lead to posterior divergence and poor sampling from prior at test time. Trade-off between expressive continuous latents vs robustness/tractability—motivated shift to discrete latents.",
            "design_choices": "Used approximate posterior network that conditions on future frame; KL regularization term included in loss; at test time latent sampled from N(0,I).",
            "comparison_to_alternatives": "Compared unfavorably to discrete-latent SD model in this work due to sensitivity to KL weight and prior mismatch; deterministic models produce blurring while VAE can avoid blurring but suffers from practical inference issues.",
            "optimal_configuration": "Authors do not recommend vanilla VAE variant without careful per-game KL tuning; their experiments suggest discrete latent autoregressive prediction is a more robust choice for Atari-like partial observability.",
            "uuid": "e1390.2",
            "source_info": {
                "paper_title": "Model-Based Reinforcement Learning for Atari",
                "publication_date_yy_mm": "2019-03"
            }
        },
        {
            "name_short": "SimPLe world-model pipeline",
            "name_full": "Simulated Policy Learning (SimPLe) world-model-based RL pipeline",
            "brief_description": "An iterative model-based RL system that trains a video-prediction world model from collected real interactions, trains a policy inside that learned simulator (using PPO), and aggregates new real data to retrain the model, achieving high sample-efficiency in Atari low-data regimes.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "SimPLe world-model pipeline (model + policy loop)",
            "model_description": "Pipeline alternates: collect D &lt;- COLLECT(env, π) using current policy in real env; TRAIN_SUPERVISED(env', D) to update learned world model (deterministic or stochastic); TRAIN_RL(π, env') to optimize policy inside world model using PPO with short simulated rollouts and random restarts from D; iterate (authors used 15 iterations, with 6400 interactions per iteration, totaling ≈102.4K interactions).",
            "model_type": "system-level model-based RL pipeline (uses neural simulators for internal training)",
            "task_domain": "Atari games",
            "fidelity_metric": "Downstream policy performance after N real interactions (primary metric); per-pixel predictive losses used for world-model training; reward-prediction correctness per sequence also tracked; ablations examine iteration count, rollout length, γ.",
            "fidelity_performance": "Enables policies that reach the SimPLe_score@100K across many games; empirical fidelity sufficient to permit successful policy transfer in many games though not perfect—examples of pixel-perfect short predictions (~50 steps) in Pong/Freeway/Breakout; model failures exist for very small objects or large global scene changes.",
            "interpretability_assessment": "Pipeline-level interpretability derives from inspecting model rollouts vs real gameplay and qualitative failure modes; no formal interpretability beyond visual analyses and ablations.",
            "interpretability_method": "Visualization of rollouts, videos, per-game qualitative case studies; ablation studies to understand effects of rollout length, stochasticity, recurrence, γ, and training length.",
            "computational_cost": "Significant: world model ~74M params, heavy training (45K steps first iteration, then 15K), 15.2M simulated env interactions during policy training; learned simulator inference ~32ms/frame on P100 vs ALE ~0.4ms/frame; overall pipeline requires substantial GPU/CPU resources and wall-clock time.",
            "efficiency_comparison": "In sample-efficiency (real interactions) SimPLe outperforms tuned Rainbow and PPO across many games at 100K interactions; computationally more expensive in terms of model training and per-frame simulation than model-free training in native emulator; advantage narrows or disappears with large amounts of real data (&gt;500K).",
            "task_performance": "SimPLe (with SD model) achieves better sample-efficiency in low-data regime: on more than half the tested games it reaches target scores with less than half the samples required by Rainbow; on Freeway more than 10x more sample-efficient; however final asymptotic scores generally lower than best model-free methods.",
            "task_utility_analysis": "Learned simulator enabled efficient policy learning when model was accurate on task-relevant aspects (e.g., moving objects, rewards); short rollouts and random restarts mitigated compounding errors and preserved policy utility; when models failed to capture tiny bullets or large scene teleports, policy performance suffered—so task-utility depends on model fidelity to task-relevant features rather than perfect reconstruction.",
            "tradeoffs_observed": "Primary trade-offs: sample-efficiency (real env interactions) vs computational/training cost; model complexity (stochastic discrete) vs simulator speed and stability; short rollouts reduce compounding error but limit learning of long-term dependencies; stochastic modeling improves realism but increases model and inference complexity.",
            "design_choices": "Iterative dataset aggregation (train model on aggregated D), PPO inside learned model with short rollouts (N=25–50) and random starts from D, scheduled sampling in model training, clipped pixel losses, use of discrete stochastic latents (recommended), and substantial world-model training early in loop.",
            "comparison_to_alternatives": "Compared to model-free RL (Rainbow, PPO): SimPLe is more real-sample-efficient in low-data regimes but computationally heavier and tends to lower asymptotic performance; compared to prior model-based attempts (Oh et al. 2015/2017, Babaeizadeh et al. 2017a, Ha & Schmidhuber 2018), SimPLe demonstrates successful planning/control across a wider set of Atari games and introduces discrete latent approach to improve robustness.",
            "optimal_configuration": "Authors' recommended configuration: stochastic discrete latent model, rollout length N in [25,50], γ≈0.95, scheduled sampling, clipped losses, iterative aggregation (~15 iterations), longer world-model training (45K initial steps), and random restarts from real data buffer; suggest future use of ensembles/Bayesian approaches to improve robustness.",
            "uuid": "e1390.3",
            "source_info": {
                "paper_title": "Model-Based Reinforcement Learning for Atari",
                "publication_date_yy_mm": "2019-03"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Action-conditional video prediction using deep networks in atari games",
            "rating": 2
        },
        {
            "paper_title": "Stochastic variational video prediction",
            "rating": 2
        },
        {
            "paper_title": "Recurrent environment simulators",
            "rating": 2
        },
        {
            "paper_title": "Recurrent world models facilitate policy evolution",
            "rating": 2
        },
        {
            "paper_title": "Learning latent dynamics for planning from pixels",
            "rating": 2
        },
        {
            "paper_title": "Model-ensemble trust-region policy optimization",
            "rating": 1
        },
        {
            "paper_title": "Woulda, coulda, shoulda: Counterfactually-guided policy search",
            "rating": 1
        }
    ],
    "cost": 0.015965999999999998,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>MODEL BASED REINFORCEMENT LEARNING FOR ATARI</h1>
<p>Łukasz Kaiser ${ }^{1, <em>}$, Mohammad Babaeizadeh ${ }^{1, </em>}$, Piotr Miłos ${ }^{2,3, <em>}$, Błażej Osiński ${ }^{2,4, </em>}$ Roy H. Campbell ${ }^{5}$, Konrad Czechowski ${ }^{4}$, Dumitru Erhan ${ }^{1}$, Chelsea Finn ${ }^{1,6}$, Piotr Kozakowski ${ }^{4}$, Sergey Levine ${ }^{1}$, Afroz Mohiuddin ${ }^{1}$, Ryan Sepassi ${ }^{1}$, George Tucker ${ }^{1}$, Henryk Michalewski ${ }^{4}$<br>${ }^{1}$ Google Brain, ${ }^{2}$ deepsense.ai, ${ }^{3}$ Institute of Mathematics of the Polish Academy of Sciences, ${ }^{4}$ Faculty of Mathematics, Informatics and Mechanics, University of Warsaw, ${ }^{5}$ University of Illinois at Urbana-Champaign, ${ }^{6}$ Stanford University</p>
<h4>Abstract</h4>
<p>Model-free reinforcement learning (RL) can be used to learn effective policies for complex tasks, such as Atari games, even from image observations. However, this typically requires very large amounts of interaction - substantially more, in fact, than a human would need to learn the same games. How can people learn so quickly? Part of the answer may be that people can learn how the game works and predict which actions will lead to desirable outcomes. In this paper, we explore how video prediction models can similarly enable agents to solve Atari games with fewer interactions than model-free methods. We describe Simulated Policy Learning (SimPLe), a complete model-based deep RL algorithm based on video prediction models and present a comparison of several model architectures, including a novel architecture that yields the best results in our setting. Our experiments evaluate SimPLe on a range of Atari games in low data regime of 100k interactions between the agent and the environment, which corresponds to two hours of real-time play. In most games SimPLe outperforms state-of-the-art model-free algorithms, in some games by over an order of magnitude.</p>
<h2>1 INTRODUCTION</h2>
<p>Human players can learn to play Atari games in minutes (Tsividis et al., 2017). However, some of the best model-free reinforcement learning algorithms require tens or hundreds of millions of time steps - the equivalent of several weeks of training in real time. How is it that humans can learn these games so much faster? Perhaps part of the puzzle is that humans possess an intuitive understanding of the physical processes that are represented in the game: we know that planes can fly, balls can roll, and bullets can destroy aliens. We can therefore predict the outcomes of our actions. In this paper, we explore how learned video models can enable learning in the Atari Learning Environment (ALE) benchmark Bellemare et al. (2015); Machado et al. (2018) with a budget restricted to 100K time steps - roughly to two hours of a play time.</p>
<p>Although prior works have proposed training predictive models for next-frame, future-frame, as well as combined future-frame and reward predictions in Atari games (Oh et al. (2015); Chiappa et al. (2017); Leibfried et al. (2016)), no prior work has successfully demonstrated model-based control via predictive models that achieve competitive results with model-free RL. Indeed, in a recent survey (Section 7.2 in Machado et al. (2018)) this was formulated as the following challenge: "So far, there has been no clear demonstration of successful planning with a learned model in the ALE".</p>
<p>Using models of environments, or informally giving the agent ability to predict its future, has a fundamental appeal for reinforcement learning. The spectrum of possible applications is vast, including learning policies from the model (Watter et al., 2015; Finn et al., 2016; Finn \&amp; Levine, 2017; Ebert et al., 2017; Hafner et al., 2019; Piergiovanni et al., 2018; Rybkin et al., 2018; Sutton \&amp; Barto,</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Main loop of SimPLe. 1) the agent starts interacting with the real environment following the latest policy (initialized to random). 2) the collected observations will be used to train (update) the current world model. 3) the agent updates the policy by acting inside the world model. The new policy will be evaluated to measure the performance of the agent as well as collecting more data (back to 1). Note that world model training is self-supervised for the observed states and supervised for the reward.</p>
<p>2017, Chapter 8), capturing important details of the scene (Ha \&amp; Schmidhuber, 2018), encouraging exploration (Oh et al., 2015), creating intrinsic motivation (Schmidhuber, 2010) or counterfactual reasoning (Buesing et al., 2019). One of the exciting benefits of model-based learning is the promise to substantially improve sample efficiency of deep reinforcement learning (see Chapter 8 in Sutton \&amp; Barto (2017)).
Our work advances the state-of-the-art in model-based reinforcement learning by introducing a system that, to our knowledge, is the first to successfully handle a variety of challenging games in the ALE benchmark. To that end, we experiment with several stochastic video prediction techniques, including a novel model based on discrete latent variables. We present an approach, called Simulated Policy Learning (SimPLe), that utilizes these video prediction techniques and trains a policy to play the game within the learned model. With several iterations of dataset aggregation, where the policy is deployed to collect more data in the original game, we learn a policy that, for many games, successfully plays the game in the real environment (see videos on the project webpage https://goo.gl/itykP8).
In our empirical evaluation, we find that SimPLe is significantly more sample-efficient than a highly tuned version of the state-of-the-art Rainbow algorithm (Hessel et al., 2018) on almost all games. In particular, in low data regime of 100 k samples, on more than half of the games, our method achieves a score which Rainbow requires at least twice as many samples. In the best case of Freeway, our method is more than 10x more sample-efficient, see Figure 3. Since the publication of the first preprint of this work, it has been shown in van Hasselt et al. (2019); Kielak (2020) that Rainbow can be tuned to have better results in low data regime. The results are on a par with SimPLe - both of the model-free methods are better in 13 games, while SimPLe is better in the other 13 out of the total 26 games tested (note that in Section 4.2 van Hasselt et al. (2019) compares with the results of our first preprint, later improved).</p>
<h1>2 Related Work</h1>
<p>Atari games gained prominence as a benchmark for reinforcement learning with the introduction of the Arcade Learning Environment (ALE) Bellemare et al. (2015). The combination of reinforcement learning and deep models then enabled RL algorithms to learn to play Atari games directly from images of the game screen, using variants of the DQN algorithm (Mnih et al., 2013; 2015; Hessel et al., 2018) and actor-critic algorithms (Mnih et al., 2016; Schulman et al., 2017; Babaeizadeh et al., 2017b; Wu et al., 2017; Espeholt et al., 2018). The most successful methods in this domain remain model-free algorithms (Hessel et al., 2018; Espeholt et al., 2018). Although the sample complexity of these methods has substantially improved recently, it remains far higher than the amount of experience required for human players to learn each game (Tsividis et al., 2017). In this work, we aim to learn Atari games with a budget of just 100 K agent steps ( 400 K frames), corresponding to about two hours</p>
<p>of play time. Prior methods are generally not evaluated in this regime, and we therefore optimized Rainbow (Hessel et al., 2018) for optimal performance on 1M steps, see Appendix E for details.</p>
<p>Oh et al. (2015) and Chiappa et al. (2017) show that learning predictive models of Atari 2600 environments is possible using appropriately chosen deep learning architectures. Impressively, in some cases the predictions maintain low $L_{2}$ error over timespans of hundreds of steps. As learned simulators of Atari environments are core ingredients of our approach, in many aspects our work is motivated by Oh et al. (2015) and Chiappa et al. (2017), however we focus on using video prediction in the context of learning how to play the game well and positively verify that learned simulators can be used to train a policy useful in original environments. An important step in this direction was made by Leibfried et al. (2016), which extends the work of Oh et al. (2015) by including reward prediction, but does not use the model to learn policies that play the games. Most of these approaches, including ours, encode knowledge of the game in implicit way. Unlike this, there are works in which modeling is more explicit, for example Ersen \&amp; Sariel (2014) uses testbed of the Incredible Machines to learn objects behaviors and their interactions. Similarly Guzdial et al. (2017) learns an engine predicting interactions of predefined set of sprites in the domain of Super Mario Bros.</p>
<p>Perhaps surprisingly, there is virtually no work on model-based RL in video games from images. Notable exceptions are the works of Oh et al. (2017), Sodhani et al. (2019), Ha \&amp; Schmidhuber (2018), Holland et al. (2018), Leibfried et al. (2018) and Azizzadenesheli et al. (2018). Oh et al. (2017) use a model of rewards to augment model-free learning with good results on a number of Atari games. However, this method does not actually aim to model or predict future frames, and achieves clear but relatively modest gains in efficiency. Sodhani et al. (2019) proposes learning a model consistent with RNN policy which helps to train policies that are more powerful than their model-free baseline. Ha \&amp; Schmidhuber (2018) present a way to compose a variational autoencoder with a recurrent neural network into an architecture that is successfully evaluated in the VizDoom environment and on a 2D racing game. The training procedure is similar to Algorithm 1, but only one iteration of the loop is needed as the environments are simple enough to be fully explored with random exploration. Similarly, Alaniz (2018) utilizes a transition model with Monte Carlo tree search to solve a block-placing task in Minecraft. Holland et al. (2018) use a variant of Dyna (Sutton, 1991) to learn a model of the environment and generate experience for policy training in the context of Atari games. Using six Atari games as a benchmark Holland et al. (2018) measure the impact of planning shapes on performance of the Dyna-DQN algorithm and include ablations comparing scores obtained with perfect and imperfect models. Our method achieves around $330 \%$ of the Dyna-DQN score on Asterix, $120 \%$ on Q-Bert, $150 \%$ on Seaquest and $80 \%$ on Ms. Pac-Man. Azizzadenesheli et al. (2018) propose an algorithm called Generative Adversarial Tree Search (GATS) and for five Atari games train a GAN-based world model along with a Q-function. Azizzadenesheli et al. (2018) primarily discuss various failure modes of the GATS algorithm. Our method achieves around 64 times the score of GATS on Pong and 10 times on Breakout. ${ }^{1}$</p>
<p>Outside of games, model-based reinforcement learning has been investigated at length for applications such as robotics (Deisenroth et al., 2013). Though most of such works do not use image observations, several recent works have incorporated images into real-world (Finn et al., 2016; Finn \&amp; Levine, 2017; Babaeizadeh et al., 2017a; Ebert et al., 2017; Piergiovanni et al., 2018; Paxton et al., 2019; Rybkin et al., 2018; Ebert et al., 2018) and simulated (Watter et al., 2015; Hafner et al., 2019) robotic control. Our video models of Atari environments described in Section 4 are motivated by models developed in the context of robotics. Another source of inspiration are discrete autoencoders proposed by van den Oord et al. (2017) and Kaiser \&amp; Bengio (2018).</p>
<p>The structure of the model-based RL algorithm that we employ consists of alternating between learning a model, and then using this model to optimize a policy with model-free reinforcement learning. Variants of this basic algorithm have been proposed in a number of prior works, starting from Dyna Q Sutton (1991) to more recent methods that incorporate deep networks Heess et al. (2015); Feinberg et al. (2018); Kalweit \&amp; Boedecker (2017); Kurutach et al. (2018).</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: Architecture of the proposed stochastic model with discrete latent. The input to the model is four stacked frames (as well as the action selected by the agent) while the output is the next predicted frame and expected reward. Input pixels and action are embedded using fully connected layers, and there is per-pixel softmax (256 colors) in the output. This model has two main components. First, the bottom part of the network which consists of a skip-connected convolutional encoder and decoder. To condition the output on the actions of the agent, the output of each layer in the decoder is multiplied with the (learned) embedded action. Second part of the model is a convolutional inference network which approximates the posterior given the next frame, similarly to Babaeizadeh et al. (2017a). At training time, the sampled latent values from the approximated posterior will be discretized into bits. To keep the model differentiable, the backpropagation bypasses the discretization following Kaiser \&amp; Bengio (2018). A third LSTM based network is trained to approximate each bit given the previous ones. At inference time, the latent bits are predicted auto-regressively using this network. The deterministic model has the same architecture as this figure but without the inference network.</p>
<h1>3 Simulated Policy Learning (SimPLe)</h1>
<p>Reinforcement learning is formalized in Markov decision processes (MDP). An MDP is defined as a tuple $(\mathcal{S}, \mathcal{A}, P, r, \gamma)$, where $\mathcal{S}$ is a state space, $\mathcal{A}$ is a set of actions available to an agent, $P$ is the unknown transition kernel, $r$ is the reward function and $\gamma \in(0,1)$ is the discount factor. In this work we refer to MDPs as environments and assume that environments do not provide direct access to the state (i.e., the RAM of Atari 2600 emulator). Instead we use visual observations, typically $210 \times 160$ RGB images. A single image does not determine the state. In order to reduce environment's partial observability, we stack four consecutive frames and use it as the observation. A reinforcement learning agent interacts with the MDP by issuing actions according to a policy. Formally, policy $\pi$ is a mapping from states to probability distributions over $\mathcal{A}$. The quality of a policy is measured by the value function $\mathbb{E}<em t="0">{\pi}\left(\sum</em>=s\right)\right.$, which for a starting state $s$ estimates the total discounted reward gathered by the agent.}^{+\infty} \gamma^{t} r_{t+1}\left|s_{0</p>
<p>In Atari 2600 games our goal is to find a policy which maximizes the value function from the beginning of the game. Crucially, apart from an Atari 2600 emulator environment env we will use a neural network simulated environment $e n v^{\prime}$ which we call a world model and describe in detail in Section 4. The environment $e n v^{\prime}$ shares the action space and reward space with $e n v$ and produces visual observations in the same format, as it will be trained to mimic $e n v$. Our principal aim is to train a policy $\pi$ using a simulated environment $e n v^{\prime}$ so that $\pi$ achieves good performance in the original environment $e n v$. In this training process we aim to use as few interactions with $e n v$ as possible. The initial data to train $e n v^{\prime}$ comes from random rollouts of $e n v$. As this is unlikely to capture all aspects of $e n v$, we use the iterative method presented in Algorithm 1.</p>
<p>Algorithm 1: Pseudocode for SimPLe
Initialize policy $\pi$
Initialize model parameters $\boldsymbol{\theta}$ of $e n v^{\prime}$
Initialize empty set $\mathbf{D}$
while not done do
$\triangleright$ collect observations from real env.
$\mathbf{D} \leftarrow \mathbf{D} \cup \operatorname{COLLECT}(e n v, \pi)$
$\triangleright$ update model using collected data.
$\overline{\boldsymbol{\theta}} \leftarrow \overline{\text { TRAIN_SUPERVISED }\left(e n v^{\prime}, \mathbf{D}\right)}$
$\triangleright$ update policy using world model.
$\overline{\boldsymbol{\pi}} \leftarrow \overline{\text { TRAIN_RL }\left(\boldsymbol{\pi}, \text { env }^{\prime}\right)}$
end while</p>
<h1>4 World Models</h1>
<p>In search for an effective world model we experimented with various architectures, both new and modified versions of existing ones. This search resulted in a novel stochastic video prediction model (visualized in Figure 2) which achieved superior results compared to other previously proposed models. In this section, we describe the details of this architecture and the rationale behind our design decisions. In Section 6 we compare the performance of these models.</p>
<p>Deterministic Model. Our basic architecture, presented as part of Figure 2, resembles the convolutional feedforward network from Oh et al. (2015). The input $X$ consists of four consecutive game frames and an action $a$. Stacked convolution layers process the visual input. The actions are one-hot-encoded and embedded in a vector which is multiplied channel-wise with the output of the convolutional layers. The network outputs the next frame of the game and the value of the reward.</p>
<p>In our experiments, we varied details of the architecture above. In most cases, we use a stack of four convolutional layers with 64 filters followed by three dense layers (the first two have 1024 neurons). The dense layers are concatenated with 64 dimensional vector with a learnable action embedding. Next, three deconvolutional layers of 64 filters follow. An additional deconvolutional layer outputs an image of the original $105 \times 80$ size. The number of filters is either 3 or $3 \times 256$. In the first case, the output is a real-valued approximation of pixel's RGB value. In the second case, filters are followed by softmax producing a probability distribution on the color space. The reward is predicted by a softmax attached to the last fully connected layer. We used dropout equal to 0.2 and layer normalization.</p>
<p>Loss functions. The visual output of our networks is either one float per pixel/channel or the categorical 256-dimensional softmax. In both cases, we used the clipped loss $\max (L o s s, C)$ for a constant $C$. We found that clipping was crucial for improving the models (measured with the correct reward predictions per sequence metric and successful training using Algorithm 1). We conjecture that clipping substantially decreases the magnitude of gradients stemming from fine-tuning of big areas of background consequently letting the optimization process concentrate on small but important areas (e.g. the ball in Pong). In our experiments, we set $C=10$ for $L_{2}$ loss on pixel values and to $C=0.03$ for softmax loss. Note that this means that when the level of confidence about the correct pixel value exceeds $97 \%$ (as $-\ln (0.97) \approx 0.03$ ) we get no gradients from that pixel any longer.</p>
<p>Scheduled sampling. The model $e n v^{\prime}$ consumes its own predictions from previous steps and due to compounding errors, the model may drift out of the area of its applicability. Following Bengio et al. (2015); Venkatraman et al. (2016), we mitigate this problem by randomly replacing in training some frames of the input $X$ by the prediction from the previous step while linearly increasing the mixing probability to $100 \%$ around the middle of the first iteration of the training loop.</p>
<p>Stochastic Models. A stochastic model can be used to deal with limited horizon of past observed frames as well as sprites occlusion and flickering which results to higher quality predictions. Inspired by Babaeizadeh et al. (2017a), we tried a variational autoencoder (Kingma \&amp; Welling, 2014) to model the stochasticity of the environment. In this model, an additional network receives the input frames as well as the future target frame as input and approximates the distribution of the posterior. At each timestep, a latent value $z_{t}$ is sampled from this distribution and passed as input to the original predictive model. At test time, the latent values are sampled from an assumed prior $\mathcal{N}(\mathbf{0}, \mathbf{I})$. To match the assumed prior and the approximate, we use the Kullback-Leibler divergence term as an additional loss term (Babaeizadeh et al., 2017a).</p>
<p>We noticed two major issues with the above model. First, the weight of the KL divergence loss term is game dependent, which is not practical if one wants to deal with a broad portfolio of Atari games. Second, this weight is usually a very small number in the range of $\left[10^{-3}, 10^{-5}\right]$ which means that the approximated posterior can diverge significantly from the assumed prior. This can result in previously unseen latent values at inference time that lead to poor predictions. We address these issues by utilizing a discrete latent variable similar to Kaiser \&amp; Bengio (2018).</p>
<p>As visualized in Figure 2, the proposed stochastic model with discrete latent variables discretizes the latent values into bits (zeros and ones) while training an auxiliary LSTM-based Hochreiter \&amp; Schmidhuber (1997) recurrent network to predict these bits autoregressively. At inference time, the latent bits will be generated by this auxiliary network in contrast to sampling from a prior. To make the predictive model more robust to unseen latent bits, we add uniform noise to approximated latent</p>
<p>values before discretization and apply dropout (Srivastava et al., 2014) on bits after discretization. More details about the architecture is in Appendix C.</p>
<h1>5 Policy Training</h1>
<p>We will now describe the details of SimPLe, outlined in Algorithm 1. In step 6 we use the proximal policy optimization (PPO) algorithm (Schulman et al., 2017) with $\gamma=0.95$. The algorithm generates rollouts in the simulated environment $e n v^{\prime}$ and uses them to improve policy $\pi$. The fundamental difficulty lays in imperfections of the model compounding over time. To mitigate this problem we use short rollouts of $e n v^{\prime}$. Typically every $N=50$ steps we uniformly sample the starting state from the ground-truth buffer $D$ and restart $e n v^{\prime}$ (for experiments with the value of $\gamma$ and $N$ see Section 6.4). Using short rollouts may have a degrading effect as the PPO algorithm does not have a way to infer effects longer than the rollout length. To ease this problem, in the last step of a rollout we add to the reward the evaluation of the value function. Training with multiple iterations re-starting from trajectories gathered in the real environment is new to our knowledge. It was inspired by the classical Dyna-Q algorithm and, notably, in the Atari domain no comparable results have been achieved.</p>
<p>The main loop in Algorithm 1 is iterated 15 times (cf. Section 6.4). The world model is trained for 45 K steps in the first iteration and for 15 K steps in each of the following ones. Shorter training in later iterations does not degrade the performance because the world model after first iteration captures already part of the game dynamics and only needs to be extended to novel situations.</p>
<p>In each of the iterations, the agent is trained inside the latest world model using PPO. In every PPO epoch we used 16 parallel agents collecting 25, 50 or 100 steps from the simulated environment $e n v^{\prime}$ (see Section 6.4 for ablations). The number of PPO epochs is $z \cdot 1000$, where $z$ equals to 1 in all passes except last one (where $z=3$ ) and two passes number 8 and 12 (where $z=2$ ). This gives $800 \mathrm{~K} \cdot z$ interactions with the simulated environment in each of the loop passes. In the process of training the agent performs 15.2 M interactions with the simulated environment $e n v^{\prime}$.</p>
<h2>6 EXPERIMENTS</h2>
<p>We evaluate SimPLe on a suite of Atari games from Atari Learning Environment (ALE) benchmark. In our experiments, the training loop is repeated for 15 iterations, with 6400 interactions with the environment collected in each iteration. We apply a standard pre-processing for Atari games: a frame skip equal to 4 , that is every action is repeated 4 times. The frames are down-scaled by a factor of 2 .</p>
<p>Because some data is collected before the first iteration of the loop, altogether $6400 \cdot 16=102,400$ interactions with the Atari environment are used during training. This is equivalent to 409,600 frames from the Atari game ( 114 minutes at 60 FPS ). At every iteration, the latest policy trained under the learned model is used to collect data in the real environment env. The data is also directly used to train the policy with PPO. Due to vast difference between number of training data from simulated environment and real environment ( 15 M vs 100 K ) the impact of the latter on policy is negligible.</p>
<p>We evaluate our method on 26 games selected on the basis of being solvable with existing state-of-the-art model-free deep RL algorithms ${ }^{2}$, which in our comparisons are Rainbow Hessel et al. (2018) and PPO Schulman et al. (2017). For Rainbow, we used the implementation from the Dopamine package and spent considerable time tuning it for sample efficiency (see Appendix E).</p>
<p>For visualization of all experiments see https://goo.gl/itykP8 and for a summary see Figure 3. It can be seen that our method is more sample-efficient than a highly tuned Rainbow baseline on almost all games, requires less than half of the samples on more than half of the games and, on Freeway, is more than 10x more sample-efficient. Our method outperforms PPO by an even larger margin. We also compare our method with fixed score baselines (for different baselines) rather than counting how many steps are required to match our score, see Figure 4 for the results. For the</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: Comparison with Rainbow and PPO. Each bar illustrates the number of interactions with environment required by Rainbow (left) or PPO (right) to achieve the same score as our method (SimPLe). The red line indicates the 100K interactions threshold which is used by the our method.
qualitative analysis of performance on different games see Appendix B. The source code is available as part of the Tensor2Tensor library and it includes instructions on how to run the experiments ${ }^{3}$.</p>
<h1>6.1 SAMPLE EFFICIENCY</h1>
<p>The primary evaluation in our experiments studies the sample efficiency of SimPLe, in comparison with state-of-the-art model-free deep RL methods in the literature. To that end, we compare with Rainbow (Hessel et al., 2018; Castro et al., 2018), which represents the state-of-the-art Q-learning method for Atari games, and PPO (Schulman et al., 2017), a model-free policy gradient algorithm (see Appendix E for details of tuning of Rainbow and PPO). The results of the comparison are presented in Figure 3. For each game, we plot the number of time steps needed for either Rainbow or PPO to reach the same score that our method reaches after 100 K interaction steps. The red line indicates 100 K steps: any bar larger than this indicates a game where the model-free method required more steps. SimPLe outperforms the model-free algorithms in terms of learning speed on nearly all of the games, and in the case of a few games, does so by over an order of magnitude. For some games, it reaches the same performance that our PPO implementation reaches at 10 M steps. This indicates that model-based reinforcement learning provides an effective approach to learning Atari games, at a fraction of the sample complexity.
The results in these figures are generated by averaging 5 runs for each game. The model-based agent is better than a random policy for all the games except Bank Heist. Interestingly, we observed that the best of the 5 runs was often significantly better. For 6 of the games, it exceeds the average human score (as reported in Table 3 of Pohlen et al. (2018)). This suggests that further stabilizing SimPLe should improve its performance, indicating an important direction for future work. In some cases during training we observed high variance of the results during each step of the loop. There are a number of possible reasons, such as mutual interactions of the policy training and the supervised training or domain mismatch between the model and the real environment. We present detailed numerical results, including best scores and standard deviations, in Appendix D.</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 4: Fractions of Rainbow and PPO scores at different numbers of interactions calculated with the formula (SimPLe_score@100K-random_score)/(baseline_score-random_score); if denominator is smaller than 0, both nominator and denominator are increased by 1. From left to right, the baselines are: Rainbow at 100K, Rainbow at 200K, PPO at 100K, PPO at 200K. SimPLe outperforms Rainbow and PPO even when those are given twice as many interactions.
<img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 5: Behaviour with respect to the number of used samples. We report number of frames required by PPO to reach the score of our models. Results are averaged over all games.</p>
<h1>6.2 NUMBER OF FRAMES</h1>
<p>We focused our work on learning games with 100 K interaction steps with the environment. In this section we present additional results for settings with $20 \mathrm{~K}, 50 \mathrm{~K}, 200 \mathrm{~K}, 500 \mathrm{~K}$ and 1 M interactions; see Figure 5 (a). Our results are poor with 20 K interactions. For 50 K they are already almost as good as with 100 K interactions. From there the results improve until 500 K samples - it is also the point at which they are on par with model-free PPO. Detailed per game results can be found in Appendix F.</p>
<p>This demonstrates that SimPLe excels in a low data regime, but its advantage disappears with a bigger amount of data. Such a behavior, with fast growth at the beginning of training, but lower asymptotic performance is commonly observed when comparing model-based and model-free methods (Wang et al. (2019)). As observed in Section 6.4 assigning bigger computational budget helps in 100K setting. We suspect that gains would be even bigger for the settings with more samples.</p>
<p>Finally, we verified if a model obtained with SimPLe using 100 K is a useful initialization for modellfree PPO training. Based on the results depicted in Figure 5 (b) we can positively answer this conjecture. Lower asymptotic performance is probably due to worse exploration. A policy pre-trained with SimPLe was meant to obtain the best performance on 100 K , at which point its entropy is very low thus hindering further PPO training.</p>
<h1>6.3 ENVIRONMENT STOCHASTICITY</h1>
<p>A crucial decision in the design of world models is the inclusion of stochasticity. Although Atari is known to be a deterministic environment, it is stochastic given only a limited horizon of past observed frames (in our case 4 frames). The level of stochasticity is game dependent; however, it can be observed in many Atari games. An example of such behavior can be observed in the game Kung Fu Master - after eliminating the current set of opponents, the game screen always looks the same (it contains only player's character and the background). The game dispatches diverse sets of new opponents, which cannot be inferred from the visual observation alone (without access to the game's internal state) and thus cannot be predicted by a deterministic model. Similar issues have been reported in Babaeizadeh et al. (2017a), where the output of their baseline deterministic model was a blurred superposition of possible random object movements. As can be seen in Figure 11 in the Appendix, the stochastic model learns a reasonable behavior - samples potential opponents and renders them sharply.</p>
<p>Given the stochasticity of the proposed model, SimPLe can be used with truly stochastic environments. To demonstrate this, we ran an experiment where the full pipeline (both the world model and the policy) was trained in the presence of sticky actions, as recommended in (Machado et al., 2018, Section 5). Our world model learned to account for the stickiness of actions and in most cases the end results were very similar to the ones for the deterministic case even without any tuning, see Figure 6.</p>
<h3>6.4 Ablations</h3>
<p>To evaluate the design of our method, we independently varied a number of the design decisions. Here we present an overview; see Appendix A for detailed results.
Model architecture and hyperparameters. We evaluated a few choices for the world model and our proposed stochastic discrete model performs best by a significant margin. The second most important parameter was the length of world model's training. We verified that a longer training would be beneficial, however we had to restrict it in all other ablation studies due to a high cost of training on all games. As for the length of rollouts from simulated $e n v^{\prime}$, we use $N=50$ by default. We experimentally shown that $N=25$ performs roughly on par, while $N=100$ is
<img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>Figure 6: Impact of the environment stochasticity. The graphs are in the same format as Figure 3: each bar illustrates the number of interactions with environment required by Rainbow to achieve the same score as SimPLe (with stochastic discrete world model) using 100k steps in an environment with and without sticky actions.
slightly worse, likely due to compounding model errors. The discount factor was set to $\gamma=0.99$ unless specified otherwise. We see that $\gamma=0.95$ is slightly better than other values, and we hypothesize that it is due to better tolerance to model imperfections. But overall, all three values of $\gamma$ perform comparably.
Model-based iterations. The iterative process of training the model, training the policy, and collecting data is crucial for non-trivial tasks where random data collection is insufficient. In a game-by-game analysis, we quantified the number of games where the best results were obtained in later iterations of training. In some games, good policies could be learned very early. While this might have been due to the high variability of training, it does suggest the possibility of much faster training (i.e. in fewer step than 100k) with more directed exploration policies. In Figure 9 in the Appendix we present the cumulative distribution plot for the (first) point during learning when the maximum score for the run was achieved in the main training loop of Algorithm 1.
Random starts. Using short rollouts is crucial to mitigate the compounding errors in the model. To ensure exploration, SimPLe starts rollouts from randomly selected states taken from the real data</p>
<p>buffer D. Figure 9 compares the baseline with an experiment without random starts and rollouts of length 1000 on Seaquest which shows much worse results without random starts.</p>
<h1>7 Conclusions and Future Work</h1>
<p>We presented SimPLe, a model-based reinforcement learning approach that operates directly on raw pixel observations and learns effective policies to play games in the Atari Learning Environment. Our experiments demonstrate that SimPLe learns to play many of the games with just 100 K interactions with the environment, corresponding to 2 hours of play time. In many cases, the number of samples required for prior methods to learn to reach the same reward value is several times larger.</p>
<p>Our predictive model has stochastic latent variables so it can be applied in highly stochastic environments. Studying such environments is an exciting direction for future work, as is the study of other ways in which the predictive neural network model could be used. Our approach uses the model as a learned simulator and directly applies model-free policy learning to acquire the policy. However, we could use the model for planning. Also, since our model is differentiable, the additional information contained in its gradients could be incorporated into the reinforcement learning process. Finally, the representation learned by the predictive model is likely be more meaningful by itself than the raw pixel observations from the environment. Incorporating this representation into the policy could further accelerate and improve the reinforcement learning process.</p>
<p>While SimPLe is able to learn more quickly than model-free methods, it does have limitations. First, the final scores are on the whole lower than the best state-of-the-art model-free methods. This can be improved with better dynamics models and, while generally common with model-based RL algorithms, suggests an important direction for future work. Another, less obvious limitation is that the performance of our method generally varied substantially between different runs on the same game. The complex interactions between the model, policy, and data collection were likely responsible for this. In future work, models that capture uncertainty via Bayesian parameter posteriors or ensembles (Kurutach et al., 2018; Chua et al., 2018) may improve robustness. Finally, the computational and time requirement of training inside world model are substantial (see Appendix C), which makes developing lighter models an important research direction.</p>
<p>In this paper our focus was to demonstrate the capability and generality of SimPLe only across a suite of Atari games, however, we believe similar methods can be applied to other environments and tasks which is one of our main directions for future work. As a long-term challenge, we believe that model-based reinforcement learning based on stochastic predictive models represents a promising and highly efficient alternative to model-free RL. Applications of such approaches to both high-fidelity simulated environments and real-world data represent an exciting direction for future work that can enable highly efficient learning of behaviors from raw sensory inputs in domains such as robotics and autonomous driving.</p>
<h2>ACKNOWLEDGMENTS</h2>
<p>We thank Marc Bellemare and Pablo Castro for their help with Rainbow and Dopamine. The work of Konrad Czechowski, Piotr Kozakowski and Piotr Miłoś was supported by the Polish National Science Center grants UMO-2017/26/E/ST6/00622. The work of Henryk Michalewski was supported by the Polish National Science Center grant UMO-2018/29/B/ST6/02959. We gratefully acknowledge Polish high-performance computing infrastructure PLGrid (HPC Centers: ACK Cyfronet AGH, PCSS) for providing computer facilities and support within computational grants no. PLG/2019/012497 and PLG/2019/012784. Some of the experiments were managed using https://neptune.ai. We would like to thank the Neptune team for providing us access to the team version and technical support.</p>
<h2>REFERENCES</h2>
<p>Stephan Alaniz. Deep reinforcement learning with model learning and monte carlo tree search in minecraft. arXiv preprint arXiv:1803.08456, 2018.</p>
<p>Kamyar Azizzadenesheli, Brandon Yang, Weitang Liu, Emma Brunskill, Zachary C. Lipton, and Animashree Anandkumar. Sample-efficient deep RL with generative adversarial tree search. CoRR, abs/1806.05780, 2018.
Mohammad Babaeizadeh, Chelsea Finn, Dumitru Erhan, Roy H. Campbell, and Sergey Levine. Stochastic variational video prediction. ICLR, 2017a.
Mohammad Babaeizadeh, Iuri Frosio, Stephen Tyree, Jason Clemons, and Jan Kautz. Reinforcement learning through asynchronous advantage actor-critic on a GPU. In 5th International Conference on Learning Representations, ICLR 2017, Toulon, France, April 24-26, 2017, Conference Track Proceedings. OpenReview.net, 2017b. URL https://openreview.net/forum? id=r1VGvBcxl.
Marc G. Bellemare, Yavar Naddaf, Joel Veness, and Michael Bowling. The arcade learning environment: An evaluation platform for general agents (extended abstract). In Proceedings of the Twenty-Fourth International Joint Conference on Artificial Intelligence, IJCAI, pp. 4148-4152, 2015.</p>
<p>Samy Bengio, Oriol Vinyals, Navdeep Jaitly, and Noam Shazeer. Scheduled sampling for sequence prediction with recurrent neural networks. In Advances in Neural Information Processing Systems 28: Annual Conference on Neural Information Processing Systems 2015, December 7-12, 2015, Montreal, Quebec, Canada, pp. 1171-1179, 2015.
Lars Buesing, Theophane Weber, Yori Zwols, Nicolas Heess, Sébastien Racanière, Arthur Guez, and Jean-Baptiste Lespiau. Woulda, coulda, shoulda: Counterfactually-guided policy search. In 7th International Conference on Learning Representations, ICLR 2019, New Orleans, LA, USA, May 6-9, 2019. OpenReview.net, 2019. URL https://openreview.net/forum? id=BJG0voC9YQ.
Pablo Samuel Castro, Subhodeep Moitra, Carles Gelada, Saurabh Kumar, and Marc G. Bellemare. Dopamine: A research framework for deep reinforcement learning. CoRR, abs/1812.06110, 2018.
Silvia Chiappa, Sébastien Racanière, Daan Wierstra, and Shakir Mohamed. Recurrent environment simulators. In 5th International Conference on Learning Representations, ICLR 2017, Toulon, France, April 24-26, 2017, Conference Track Proceedings. OpenReview.net, 2017. URL https : //openreview.net/forum?id=B1s6xvqlx.
Kurtland Chua, Roberto Calandra, Rowan McAllister, and Sergey Levine. Deep reinforcement learning in a handful of trials using probabilistic dynamics models. In Advances in Neural Information Processing Systems, pp. 4759-4770, 2018.
Marc Peter Deisenroth, Gerhard Neumann, and Jan Peters. A survey on policy search for robotics. Foundations and Trends in Robotics, 2(1-2), 2013.
Frederik Ebert, Chelsea Finn, Alex X. Lee, and Sergey Levine. Self-supervised visual planning with temporal skip connections. In 1st Annual Conference on Robot Learning, CoRL 2017, Mountain View, California, USA, November 13-15, 2017, Proceedings, volume 78 of Proceedings of Machine Learning Research, pp. 344-356. PMLR, 2017.
Frederik Ebert, Chelsea Finn, Sudeep Dasari, Annie Xie, Alex Lee, and Sergey Levine. Visual foresight: Model-based deep reinforcement learning for vision-based robotic control. arXiv preprint arXiv:1812.00568, 2018.
Mustafa Ersen and Sanem Sariel. Learning behaviors of and interactions among objects through spatio-temporal reasoning. IEEE Transactions on Computational Intelligence and AI in Games, 7 (1):75-87, 2014.</p>
<p>Lasse Espeholt, Hubert Soyer, Rémi Munos, Karen Simonyan, Volodymyr Mnih, Tom Ward, Yotam Doron, Vlad Firoiu, Tim Harley, Iain Dunning, Shane Legg, and Koray Kavukcuoglu. IMPALA: scalable distributed deep-rl with importance weighted actor-learner architectures. In Proceedings of the 35th International Conference on Machine Learning, ICML, pp. 1406-1415, 2018.
Vladimir Feinberg, Alvin Wan, Ion Stoica, Michael I. Jordan, Joseph E. Gonzalez, and Sergey Levine. Model-based value estimation for efficient model-free reinforcement learning. CoRR, abs/1803.00101, 2018.
Chelsea Finn and Sergey Levine. Deep visual foresight for planning robot motion. In 2017 IEEE International Conference on Robotics and Automation, ICRA 2017, Singapore, Singapore, May 29 - June 3, 2017, pp. 2786-2793. IEEE, 2017. doi: 10.1109/ICRA.2017.7989324.
Chelsea Finn, Xin Yu Tan, Yan Duan, Trevor Darrell, Sergey Levine, and Pieter Abbeel. Deep spatial autoencoders for visuomotor learning. In IEEE International Conference on Robotics and Automation, ICRA, pp. 512-519, 2016.</p>
<p>Matthew Guzdial, Boyang Li, and Mark O. Riedl. Game engine learning from video. In Proceedings of the Twenty-Sixth International Joint Conference on Artificial Intelligence, IJCAI 2017, Melbourne, Australia, August 19-25, 2017, pp. 3707-3713, 2017. doi: 10.24963/ijcai.2017/518.
David Ha and Jürgen Schmidhuber. Recurrent world models facilitate policy evolution. In Samy Bengio, Hanna M. Wallach, Hugo Larochelle, Kristen Grauman, Nicolò Cesa-Bianchi, and Roman Garnett (eds.), Advances in Neural Information Processing Systems 31: Annual Conference on Neural Information Processing Systems 2018, NeurIPS 2018, 3-8 December 2018, Montréal, Canada, pp. 2455-2467, 2018.
Danijar Hafner, Timothy P. Lillicrap, Ian Fischer, Ruben Villegas, David Ha, Honglak Lee, and James Davidson. Learning latent dynamics for planning from pixels. In Kamalika Chaudhuri and Ruslan Salakhutdinov (eds.), Proceedings of the 36th International Conference on Machine Learning, ICML 2019, 9-15 June 2019, Long Beach, California, USA, volume 97 of Proceedings of Machine Learning Research, pp. 2555-2565. PMLR, 2019.
Nicolas Heess, Gregory Wayne, David Silver, Timothy P. Lillicrap, Tom Erez, and Yuval Tassa. Learning continuous control policies by stochastic value gradients. In Corinna Cortes, Neil D. Lawrence, Daniel D. Lee, Masashi Sugiyama, and Roman Garnett (eds.), Advances in Neural Information Processing Systems 28: Annual Conference on Neural Information Processing Systems 2015, December 7-12, 2015, Montreal, Quebec, Canada, pp. 2944-2952, 2015.
Matteo Hessel, Joseph Modayil, Hado van Hasselt, Tom Schaul, Georg Ostrovski, Will Dabney, Dan Horgan, Bilal Piot, Mohammad Gheshlaghi Azar, and David Silver. Rainbow: Combining improvements in deep reinforcement learning. In Sheila A. McIlraith and Kilian Q. Weinberger (eds.), Proceedings of the Thirty-Second AAAI Conference on Artificial Intelligence, (AAAI-18), the 30th innovative Applications of Artificial Intelligence (IAAI-18), and the 8th AAAI Symposium on Educational Advances in Artificial Intelligence (EAAI-18), New Orleans, Louisiana, USA, February 2-7, 2018, pp. 3215-3222. AAAI Press, 2018.
Sepp Hochreiter and Jürgen Schmidhuber. Long short-term memory. Neural computation, 9(8): $1735-1780,1997$.
G. Zacharias Holland, Erik Talvitie, and Michael Bowling. The effect of planning shape on dyna-style planning in high-dimensional state spaces. CoRR, abs/1806.01825, 2018.
Lukasz Kaiser and Samy Bengio. Discrete autoencoders for sequence models. CoRR, abs/1801.09797, 2018.</p>
<p>Gabriel Kalweit and Joschka Boedecker. Uncertainty-driven imagination for continuous deep reinforcement learning. In Sergey Levine, Vincent Vanhoucke, and Ken Goldberg (eds.), Proceedings of the 1st Annual Conference on Robot Learning, volume 78 of Proceedings of Machine Learning Research, pp. 195-206. PMLR, 13-15 Nov 2017.
Kacper Piotr Kielak. Do recent advancements in model-based deep reinforcement learning really improve data efficiency?, 2020. URL https://openreview.net/forum?id= Bke9u1HFwB.
Diederik P. Kingma and Max Welling. Auto-encoding variational bayes. In Yoshua Bengio and Yann LeCun (eds.), 2nd International Conference on Learning Representations, ICLR 2014, Banff, AB, Canada, April 14-16, 2014, Conference Track Proceedings, 2014.
Thanard Kurutach, Ignasi Clavera, Yan Duan, Aviv Tamar, and Pieter Abbeel. Model-ensemble trust-region policy optimization. In 6th International Conference on Learning Representations, ICLR 2018, Vancouver, BC, Canada, April 30 - May 3, 2018, Conference Track Proceedings. OpenReview.net, 2018. URL https://openreview.net/forum?id=SJJinbWRZ.
Felix Leibfried, Nate Kushman, and Katja Hofmann. A deep learning approach for joint video frame and reward prediction in Atari games. CoRR, abs/1611.07078, 2016.
Felix Leibfried, Rasul Tutunov, Peter Vrancx, and Haitham Bou-Ammar. Model-based regularization for deep reinforcement learning with transcoder networks. arXiv preprint arXiv:1809.01906, 2018.
Marlos C. Machado, Marc G. Bellemare, Erik Talvitie, Joel Veness, Matthew J. Hausknecht, and Michael Bowling. Revisiting the arcade learning environment: Evaluation protocols and open problems for general agents. J. Artif. Intell. Res., 61:523-562, 2018. doi: 10.1613/jair. 5699.
Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Alex Graves, Ioannis Antonoglou, Daan Wierstra, and Martin A. Riedmiller. Playing atari with deep reinforcement learning. CoRR, abs/1312.5602, 2013.
Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Andrei A. Rusu, Joel Veness, Marc G. Bellemare, Alex Graves, Martin A. Riedmiller, Andreas Fidjeland, Georg Ostrovski, Stig Petersen, Charles Beattie, Amir Sadik, Ioannis Antonoglou, Helen King, Dharshan Kumaran, Daan Wierstra,</p>
<p>Shane Legg, and Demis Hassabis. Human-level control through deep reinforcement learning. Nature, 518(7540):529-533, 2015.
Volodymyr Mnih, Adrià Puigdomènech Badia, Mehdi Mirza, Alex Graves, Timothy P. Lillicrap, Tim Harley, David Silver, and Koray Kavukcuoglu. Asynchronous methods for deep reinforcement learning. In Proceedings of the 33nd International Conference on Machine Learning, ICML, pp. 1928-1937, 2016.
Junhyuk Oh, Xiaoxiao Guo, Honglak Lee, Richard L. Lewis, and Satinder P. Singh. Actionconditional video prediction using deep networks in atari games. In NIPS, pp. 2863-2871, 2015.
Junhyuk Oh, Satinder Singh, and Honglak Lee. Value prediction network. In I. Guyon, U. V. Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett (eds.), Advances in Neural Information Processing Systems 30, pp. 6118-6128. Curran Associates, Inc., 2017.
Chris Paxton, Yotam Barnoy, Kapil D. Katyal, Raman Arora, and Gregory D. Hager. Visual robot task planning. In International Conference on Robotics and Automation, ICRA 2019, Montreal, QC, Canada, May 20-24, 2019, pp. 8832-8838. IEEE, 2019. doi: 10.1109/ICRA.2019.8793736.
A. J. Piergiovanni, Alan Wu, and Michael S. Ryoo. Learning real-world robot policies by dreaming. CoRR, abs/1805.07813, 2018.
Tobias Pohlen, Bilal Piot, Todd Hester, Mohammad Gheshlaghi Azar, Dan Horgan, David Budden, Gabriel Barth-Maron, Hado van Hasselt, John Quan, Mel Vecerík, Matteo Hessel, Rémi Munos, and Olivier Pietquin. Observe and look further: Achieving consistent performance on atari. CoRR, abs/1805.11593, 2018.
Oleh Rybkin, Karl Pertsch, Andrew Jaegle, Konstantinos G. Derpanis, and Kostas Daniilidis. Unsupervised learning of sensorimotor affordances by stochastic future prediction. CoRR, abs/1806.09655, 2018.</p>
<p>Jürgen Schmidhuber. Formal theory of creativity, fun, and intrinsic motivation (1990-2010). IEEE Trans. Autonomous Mental Development, 2(3):230-247, 2010.
John Schulman, Filip Wolski, Prafulla Dhariwal, Alec Radford, and Oleg Klimov. Proximal policy optimization algorithms. CoRR, abs/1707.06347, 2017.
Shagun Sodhani, Anirudh Goyal, Tristan Deleu, Yoshua Bengio, Sergey Levine, and Jian Tang. Learning powerful policies by using consistent dynamics model. arXiv preprint arXiv:1906.04355, 2019.</p>
<p>Nitish Srivastava, Geoffrey Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov. Dropout: a simple way to prevent neural networks from overfitting. The Journal of Machine Learning Research, 15(1):1929-1958, 2014.
Richard S. Sutton. Dyna, an integrated architecture for learning, planning, and reacting. SIGART Bull., 2(4):160-163, July 1991.
Richard S. Sutton and Andrew G. Barto. Reinforcement learning - an introduction, 2nd edition (work in progress). Adaptive computation and machine learning. MIT Press, 2017.
Pedro Tsividis, Thomas Pouncy, Jaqueline L. Xu, Joshua B. Tenenbaum, and Samuel J. Gershman. Human learning in atari. In 2017 AAAI Spring Symposia, Stanford University, Palo Alto, California, USA, March 27-29, 2017, 2017.
Aïron van den Oord, Oriol Vinyals, and Koray Kavukcuoglu. Neural discrete representation learning. In Isabelle Guyon, Ulrike von Luxburg, Samy Bengio, Hanna M. Wallach, Rob Fergus, S. V. N. Vishwanathan, and Roman Garnett (eds.), Advances in Neural Information Processing Systems 30: Annual Conference on Neural Information Processing Systems 2017, 4-9 December 2017, Long Beach, CA, USA, pp. 6306-6315, 2017.
Hado van Hasselt, Matteo Hessel, and John Aslanides. When to use parametric models in reinforcement learning? In Hanna M. Wallach, Hugo Larochelle, Alina Beygelzimer, Florence d'Alché-Buc, Emily B. Fox, and Roman Garnett (eds.), Advances in Neural Information Processing Systems 32: Annual Conference on Neural Information Processing Systems 2019, NeurIPS 2019, 8-14 December 2019, Vancouver, BC, Canada, pp. 14322-14333, 2019.
Arun Venkatraman, Roberto Capobianco, Lerrel Pinto, Martial Hebert, Daniele Nardi, and J. Andrew Bagnell. Improved learning of dynamics models for control. In International Symposium on Experimental Robotics, ISER 2016, Tokyo, Japan, October 3-6, 2016., pp. 703-713, 2016.
Tingwu Wang, Xuchan Bao, Ignasi Clavera, Jerrick Hoang, Yeming Wen, Eric Langlois, Shunshi Zhang, Guodong Zhang, Pieter Abbeel, and Jimmy Ba. Benchmarking model-based reinforcement learning. CoRR, abs/1907.02057, 2019.
Manuel Watter, Jost Tobias Springenberg, Joschka Boedecker, and Martin A. Riedmiller. Embed to control: A locally linear latent dynamics model for control from raw images. In Advances in</p>
<p>Neural Information Processing Systems, pp. 2746-2754, 2015.
Yuhuai Wu, Elman Mansimov, Roger B. Grosse, Shun Liao, and Jimmy Ba. Scalable trust-region method for deep reinforcement learning using kronecker-factored approximation. In Isabelle Guyon, Ulrike von Luxburg, Samy Bengio, Hanna M. Wallach, Rob Fergus, S. V. N. Vishwanathan, and Roman Garnett (eds.), Advances in Neural Information Processing Systems 30: Annual Conference on Neural Information Processing Systems 2017, 4-9 December 2017, Long Beach, CA, USA, pp. 5279-5288, 2017.</p>
<p>Table 1: Summary of SimPLe ablations. For each game, a configuration was assigned a score being the mean over 5 experiments. The best and median scores were calculated per game. The table reports the number of games a given configuration achieved the best score or at least the median score, respectively.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">model</th>
<th style="text-align: right;">best</th>
<th style="text-align: right;">at least median</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">deterministic</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">7</td>
</tr>
<tr>
<td style="text-align: left;">det. recurrent</td>
<td style="text-align: right;">3</td>
<td style="text-align: right;">13</td>
</tr>
<tr>
<td style="text-align: left;">SD</td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">16</td>
</tr>
<tr>
<td style="text-align: left;">SD $\gamma=0.9$</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">14</td>
</tr>
<tr>
<td style="text-align: left;">default</td>
<td style="text-align: right;">10</td>
<td style="text-align: right;">21</td>
</tr>
<tr>
<td style="text-align: left;">SD 100 steps</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">14</td>
</tr>
<tr>
<td style="text-align: left;">SD 25 steps</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">19</td>
</tr>
</tbody>
</table>
<p>All our code is available as part of the Tensor2Tensor library and it includes instructions on how to run our experiments: https://github.com/tensorflow/tensor2tensor/tree/ master/tensor2tensor/rl.</p>
<h1>A Ablations</h1>
<p>To evaluate the design of our method, we independently varied a number of the design decisions: the choice of the model, the $\gamma$ parameter and the length of PPO rollouts. The results for 7 experimental configurations are summarized in the Table 1.</p>
<p>Models. To assess the model choice, we evaluated the following models: deterministic, deterministic recurrent, and stochastic discrete (see Section 4). Based on Table 1 it can be seen that our proposed stochastic discrete model performs best. Figures 7a and 7b show the role of stochasticity and recurrence.</p>
<p>Steps. See Figure 7d. As described in Section 5 every $N$ steps we reinitialize the simulated environment with ground-truth data. By default we use $N=50$, in some experiments we set $N=25$ or $N=100$. It is clear from the table above and Figure 7d that 100 is a bit worse than either 25 or 50 , likely due to compounding model errors, but this effect is much smaller than the effect of model architecture.</p>
<p>Gamma. See Figure 8b. We used the discount factor $\gamma=0.99$ unless specified otherwise. We see that $\gamma=0.95$ is slightly better than other values, and we hypothesize that it is due to better tolerance to model imperfections. But overall, all three values of $\gamma$ seem to perform comparably at the same number of steps.</p>
<p>Model-based iterations. The iterative process of training the model, training the policy, and collecting data is crucial for non-trivial tasks where simple random data collection is insufficient. In the game-by-game analysis, we quantified the number of games where the best results were obtained in later iterations of training. In some games, good policies could be learned very early. While this might have been due simply to the high variability of training, it does suggest the possibility that much faster training - in many fewer than 100k steps - could be obtained in future work with more directed exploration policies. We leave this question to future work.</p>
<p>In Figure 9 we present the cumulative distribution plot for the (first) point during learning when the maximum score for the run was achieved in the main training loop of Algorithm 1.</p>
<p>On Figure 7c we show results for experiments in which the number samples was fixed to be 100 K but the number of training loop varied. We conclude that 15 is beneficial for training.</p>
<p>Long model training Our best results were obtained with much 5 times longer training of the world models, see Figure 8a for comparison with shorter training. Due to our resources constraints other ablations were made with the short model training setting.</p>
<p>Random starts. Using short rollouts is crucial to mitigate the compounding errors under the model. To ensure exploration SimPLe starts rollouts from randomly selected states taken from the real data buffer D. In Figure 9 we present a comparison with an experiment without random starts and rollouts of length 1000 on Seaquest. These data strongly indicate that ablating random starts substantially deteriorate results.</p>
<h1>B Qualitative Analysis</h1>
<p>This section provides a qualitative analysis and case studies of individual games. We emphasize that we did not adjust the method nor hyperparameters individually for each game, but we provide specific qualitative analysis to better understand the predictions from the model. ${ }^{4}$</p>
<p>Solved games. The primary goal of our paper was to use model-based methods to achieve good performance within a modest budget of 100 k interactions. For two games, Pong and Freeway, our method, SimPLe, was able to achieve the maximum score.</p>
<p>Exploration. Freeway is a particularly interesting game. Though simple, it presents a substantial exploration challenge. The chicken, controlled by the agents, is quite slow to ascend when exploring randomly as it constantly gets bumped down by the cars (see the left video https://goo.gl/YHbKZ6). This makes it very unlikely to fully cross the road and obtain a non-zero reward. Nevertheless, SimPLe is able to capture such rare events, internalize them into the predictive model and then successfully learn a successful policy.</p>
<p>However, this good performance did not happen on every run. We conjecture the following scenario in failing cases. If at early stages the entropy of the policy decayed too rapidly the collected experience stayed limited leading to a poor world model, which was not powerful enough to support exploration (e.g. the chicken disappears when moving to high). In one of our experiments, we observed that the final policy was that the chicken moved up only to the second lane and stayed waiting to be hit by the car and so on so forth.</p>
<p>Pixel-perfect games. In some cases (for Pong, Freeway, Breakout) our models were able to predict the future perfectly, down to every pixel. This property holds for rather short time intervals, we observed episodes lasting up to 50 time-steps. Extending it to long sequences would be a very exciting research direction. See videos https://goo.gl/uyfNnW.</p>
<p>Benign errors. Despite the aforementioned positive examples, accurate models are difficult to acquire for some games, especially at early stages of learning. However, model-based RL should be tolerant to modest model errors. Interestingly, in some cases our models differed from the original games in a way that was harmless or only mildly harmful for policy training.</p>
<p>For example, in Bowling and Pong, the ball sometimes splits into two. While nonphysical, seemingly these errors did not distort much the objective of the game, see Figure 10 and also https://goo.gl/JPi7rB.</p>
<p>In Kung Fu Master our model's predictions deviate from the real game by spawning a different number of opponents, see Figure 11. In Crazy Climber we observed the bird appearing earlier in the game. These cases are probably to be attributed to the stochasticity in the model. Though not aligned with the true environment, the predicted behaviors are plausible, and the resulting policy can still play the original game.</p>
<p>Failures on hard games. On some of the games, our models simply failed to produce useful predictions. We believe that listing such errors may be helpful in designing better training protocols and building better models. The most common failure was due to the presence of very small but highly relevant objects. For example, in Atlantis and Battle Zone bullets are so small that they tend to disappear. Interestingly, Battle Zone has pseudo-3D graphics, which may have added to the difficulty. See videos https://goo.gl/uiccKU.</p>
<p><sup id="fnref5:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-6.jpeg" src="img-6.jpeg" />
(a) Effect of stochasticity.
<img alt="img-7.jpeg" src="img-7.jpeg" />
(c) Effect of adjusting of number of epochs.
<img alt="img-8.jpeg" src="img-8.jpeg" />
(b) Effect of recurrent architecture.
<img alt="img-9.jpeg" src="img-9.jpeg" /></p>
<p>Figure 7: Ablations part 1. The graphs are in the same format as Figure 3: each bar illustrates the number of interactions with environment required by Rainbow to achieve the same score as a particular variant of SimPLe. The red line indicates the 100K interactions threshold which is used by SimPLe.</p>
<p><img alt="img-10.jpeg" src="img-10.jpeg" /></p>
<p>Figure 8: Ablations part 2. The graphs are in the same format as Figure 3: each bar illustrates the number of interactions with environment required by Rainbow to achieve the same score as a particular variant of SimPLe. The red line indicates the 100K interactions threshold which is used by SimPLe.
<img alt="img-11.jpeg" src="img-11.jpeg" /></p>
<p>Figure 9: (left) CDF of the number of iterations to acquire maximum score. The vertical axis represents the fraction of all games. (right) Comparison of random starts vs no random starts on Seaquest (for better readability we clip game rewards to ${-1,0,1}$ ). The vertical axis shows a mean reward and the horizontal axis the number of iterations of Algorithm 1.</p>
<p><img alt="img-12.jpeg" src="img-12.jpeg" /></p>
<p>Figure 10: Frames from the Pong environment.
<img alt="img-13.jpeg" src="img-13.jpeg" /></p>
<p>Figure 11: Frames from the Kung Fu Master environment (left) and its model (right).</p>
<p>Another interesting example comes from Private Eye in which the agent traverses different scenes, teleporting from one to the other. We found that our model generally struggled to capture such large global changes.</p>
<h1>C ARCHITECTURE DETAILS</h1>
<p>The world model is a crucial ingredient of our algorithm. Therefore the neural-network architecture of the model plays a crucial role. The high-level overview of the architecture is given in Section 4 and Figure 2. We stress that the model is general, not Atari specific, and we believe it could handle other visual prediction tasks. The whole model has around 74 M parameters and the inference/backpropagation time is approx. $0.5 \mathrm{~s} / 0.7 \mathrm{~s}$ respectively, where inference is on batch size 16 and backpropagation on batch size 2, running on NVIDIA Tesla P100. This gives us around 32 ms per frame from our simulator, in comparison one step of the ALE simulator takes approximately 0.4 ms .
Below we give more details of the architecture. First, the frame prediction network:</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Layer</th>
<th style="text-align: center;">Number of outputs</th>
<th style="text-align: center;">Other details</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Input frame dense</td>
<td style="text-align: center;">96</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">Downscale convolution 1</td>
<td style="text-align: center;">192</td>
<td style="text-align: center;">kernel $4 \times 4$, stride $2 \times 2$</td>
</tr>
<tr>
<td style="text-align: left;">Downscale convolution 2</td>
<td style="text-align: center;">384</td>
<td style="text-align: center;">kernel $4 \times 4$, stride $2 \times 2$</td>
</tr>
<tr>
<td style="text-align: left;">Downscale convolution 3</td>
<td style="text-align: center;">768</td>
<td style="text-align: center;">kernel $4 \times 4$, stride $2 \times 2$</td>
</tr>
<tr>
<td style="text-align: left;">Downscale convolution 4</td>
<td style="text-align: center;">768</td>
<td style="text-align: center;">kernel $4 \times 4$, stride $2 \times 2$</td>
</tr>
<tr>
<td style="text-align: left;">Downscale convolution 5</td>
<td style="text-align: center;">768</td>
<td style="text-align: center;">kernel $4 \times 4$, stride $2 \times 2$</td>
</tr>
<tr>
<td style="text-align: left;">Downscale convolution 6</td>
<td style="text-align: center;">768</td>
<td style="text-align: center;">kernel $4 \times 4$, stride $2 \times 2$</td>
</tr>
<tr>
<td style="text-align: left;">Action embedding</td>
<td style="text-align: center;">768</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">Latent predictor embedding</td>
<td style="text-align: center;">128</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">Latent predictor LSTM</td>
<td style="text-align: center;">128</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">Latent predictor output dense</td>
<td style="text-align: center;">256</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">Reward predictor hidden</td>
<td style="text-align: center;">128</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">Reward predictor output dense</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">Middle convolution 1</td>
<td style="text-align: center;">768</td>
<td style="text-align: center;">kernel $3 \times 3$, stride $1 \times 1$</td>
</tr>
<tr>
<td style="text-align: left;">Middle convolution 2</td>
<td style="text-align: center;">768</td>
<td style="text-align: center;">kernel $3 \times 3$, stride $1 \times 1$</td>
</tr>
<tr>
<td style="text-align: left;">Upscale transposed convolution 1</td>
<td style="text-align: center;">768</td>
<td style="text-align: center;">kernel $4 \times 4$, stride $2 \times 2$</td>
</tr>
<tr>
<td style="text-align: left;">Upscale transposed convolution 2</td>
<td style="text-align: center;">768</td>
<td style="text-align: center;">kernel $4 \times 4$, stride $2 \times 2$</td>
</tr>
<tr>
<td style="text-align: left;">Upscale transposed convolution 3</td>
<td style="text-align: center;">768</td>
<td style="text-align: center;">kernel $4 \times 4$, stride $2 \times 2$</td>
</tr>
<tr>
<td style="text-align: left;">Upscale transposed convolution 4</td>
<td style="text-align: center;">384</td>
<td style="text-align: center;">kernel $4 \times 4$, stride $2 \times 2$</td>
</tr>
<tr>
<td style="text-align: left;">Upscale transposed convolution 5</td>
<td style="text-align: center;">192</td>
<td style="text-align: center;">kernel $4 \times 4$, stride $2 \times 2$</td>
</tr>
<tr>
<td style="text-align: left;">Upscale transposed convolution 6</td>
<td style="text-align: center;">96</td>
<td style="text-align: center;">kernel $4 \times 4$, stride $2 \times 2$</td>
</tr>
<tr>
<td style="text-align: left;">Output frame dense</td>
<td style="text-align: center;">768</td>
<td style="text-align: center;">-</td>
</tr>
</tbody>
</table>
<p>The latent inference network, used just during training:</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Layer</th>
<th style="text-align: center;">Number of outputs</th>
<th style="text-align: left;">Other details</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Downscale convolution 1</td>
<td style="text-align: center;">128</td>
<td style="text-align: left;">kernel $8 \times 8$, stride $4 \times 4$</td>
</tr>
<tr>
<td style="text-align: left;">Downscale convolution 2</td>
<td style="text-align: center;">512</td>
<td style="text-align: left;">kernel $8 \times 8$, stride $4 \times 4$</td>
</tr>
</tbody>
</table>
<p>All activation functions are ReLU, except for the layers marked as "output", which have softmax activations, and LSTM internal layers. In the frame prediction network, the downscale layers are connected to the corresponding upscale layers with residual connections. All convolution and transposed convolution layers are preceded by dropout 0.15 and followed by layer normalization. The latent predictor outputs 128 bits sequentially, in chunks of 8 .</p>
<h1>D NUMERICAL RESULTS</h1>
<p>Below we present numerical results of our experiments. We tested SimPLe on 7 configurations (see description in Section A). For each configuration we run 5 experiments. For the evaluation of the $i$-th experiments we used the policy given by $\operatorname{softmax}\left(\operatorname{logits}\left(\pi_{i}\right) / T\right)$, where $\pi_{i}$ is the final learnt policy in the experiment and $T$ is the temperature parameter. We found empirically that $T=0.5$ worked best in most cases. A tentative explanation is that polices with temperatures smaller than 1 are less stochastic and thus more stable. However, going down to $T=0$ proved to be detrimental in many cases as, possibly, it makes policies more prone to imperfections of models.</p>
<p>In Table 2 we present the mean and standard deviation of the 5 experiments. We observed that the median behaves rather similarly, which is reported it in Table 4. In this table we also show maximal scores over 5 runs. Interestingly, in many cases they turned out to be much higher. This, we hope, indicates that our methods has a further potential of reaching these higher scores.</p>
<p>Human scores are "Avg. Human" from Table 3 in Pohlen et al. (2018).</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{4}$ We strongly encourage the reader to watch accompanying videos https://goo.gl/itykP8&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref5:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>