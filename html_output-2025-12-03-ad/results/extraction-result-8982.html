<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-8982 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-8982</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-8982</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-158.html">extraction-schema-158</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for representing or converting graphs into text for language model training, including details of the representation, the type of graph, the conversion process, downstream tasks, performance metrics, comparisons to other methods, and any reported advantages, disadvantages, or failure cases.</div>
                <p><strong>Paper ID:</strong> paper-afc1824a051f686e18ad87e1244bb0926a361021</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/afc1824a051f686e18ad87e1244bb0926a361021" target="_blank">Modeling Graph Structure in Transformer for Better AMR-to-Text Generation</a></p>
                <p><strong>Paper Venue:</strong> Conference on Empirical Methods in Natural Language Processing</p>
                <p><strong>Paper TL;DR:</strong> This paper proposes a novel structure-aware self-attention approach to better model the relations between indirectly connected concepts in the state-of-the-art seq2seq model, i.e. the Transformer.</p>
                <p><strong>Paper Abstract:</strong> Recent studies on AMR-to-text generation often formalize the task as a sequence-to-sequence (seq2seq) learning problem by converting an Abstract Meaning Representation (AMR) graph into a word sequences. Graph structures are further modeled into the seq2seq framework in order to utilize the structural information in the AMR graphs. However, previous approaches only consider the relations between directly connected concepts while ignoring the rich structure in AMR graphs. In this paper we eliminate such a strong limitation and propose a novel structure-aware self-attention approach to better model the relations between indirectly connected concepts in the state-of-the-art seq2seq model, i.e. the Transformer. In particular, a few different methods are explored to learn structural representations between two concepts. Experimental results on English AMR benchmark datasets show that our approach significantly outperforms the state-of-the-art with 29.66 and 31.82 BLEU scores on LDC2015E86 and LDC2017T10, respectively. To the best of our knowledge, these are the best results achieved so far by supervised models on the benchmarks.</p>
                <p><strong>Cost:</strong> 0.016</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e8982.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e8982.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for representing or converting graphs into text for language model training, including details of the representation, the type of graph, the conversion process, downstream tasks, performance metrics, comparisons to other methods, and any reported advantages, disadvantages, or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>DFS-linearization</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Depth-first traversal linearization of AMR graphs (Konstas et al., 2017)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A serialization of AMR graphs into a token sequence using depth-first traversal after removing variables, wiki links and sense tags; reentrant nodes become repeated tokens in the linearized sequence.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Neural AMR: Sequence-to-sequence models for parsing and generation</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>linearization (depth-first traversal)</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Traverse the AMR graph in depth-first order to output a linear token sequence of concept labels and edge labels (after simplifying the AMR by removing variables/wiki/sense tags). Reentrancies are represented by repeating the same concept token each time it is encountered in traversal.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>Abstract Meaning Representation (AMR) semantic graphs</td>
                        </tr>
                        <tr>
                            <td><strong>conversion_method</strong></td>
                            <td>Depth-first traversal of the AMR graph; remove variables, wiki links, sense tags; emit concept/edge tokens in traversal order; reentrant nodes map to multiple occurrences.</td>
                        </tr>
                        <tr>
                            <td><strong>downstream_task</strong></td>
                            <td>AMR-to-text generation (sentence generation)</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Used in baseline seq2seq Transformer: BLEU 25.50 (LDC2015E86), Meteor 33.16, CHRF++ 59.88; BLEU 27.43 (LDC2017T10), Meteor 34.62, CHRF++ 61.85 (Table 3).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_others</strong></td>
                            <td>Baseline linearization-based seq2seq is outperformed by structure-aware graph modeling approaches in this paper; linearization is simpler than explicit graph encoders (e.g., graph-to-sequence, GCN), but loses structural information such as reentrancies and long-distance relations.</td>
                        </tr>
                        <tr>
                            <td><strong>advantages</strong></td>
                            <td>Simple to implement; compatible with sequence models (Transformer/seq2seq); benefits from BPE and shared vocabulary to mitigate sparsity.</td>
                        </tr>
                        <tr>
                            <td><strong>disadvantages</strong></td>
                            <td>Loses explicit graph structure (especially reentrancies and long-distance relations); may map distinct graph structure to ambiguous sequences; long graphs produce long sequences and can cause decoding issues (early stopping).</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>Performs particularly poorly on AMR graphs with many reentrancies or many concepts (large graphs), where structural information is important; baseline often fails to indicate reentrant identity (e.g., repeated 'he' tokens ambiguous).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Modeling Graph Structure in Transformer for Better AMR-to-Text Generation', 'publication_date_yy_mm': '2019-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8982.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e8982.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for representing or converting graphs into text for language model training, including details of the representation, the type of graph, the conversion process, downstream tasks, performance metrics, comparisons to other methods, and any reported advantages, disadvantages, or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Subword-graph-extension</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Graph structure extension to sub-word units (BPE-compatible AMR nodes)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>When input tokens are split into BPE sub-word units, the original AMR node is split into multiple connected sub-nodes and edges are adjusted so sub-units keep the original incoming edge label, preserving graph structure at sub-word granularity.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>sub-word-graph extension</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Extend AMR nodes to multiple nodes when a concept/token is segmented into BPE sub-words; connect the sub-nodes with an edge labeled as the incoming edge of the first sub-unit, so the AMR structure aligns with sub-word tokenization.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>AMR semantic graphs adapted to sub-word tokenization</td>
                        </tr>
                        <tr>
                            <td><strong>conversion_method</strong></td>
                            <td>Apply BPE to concepts; split a node into multiple connected nodes (one per subword) and add an internal edge bearing the original incoming relation for compatibility with sub-word inputs.</td>
                        </tr>
                        <tr>
                            <td><strong>downstream_task</strong></td>
                            <td>AMR-to-text generation using Transformer with BPE vocabulary</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Ablation indicates that BPE and shared vocabulary are critical; text reports improvement attributed to these techniques (text cites an improvement from 18.77 to 24.93 BLEU in ablation context).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_others</strong></td>
                            <td>Compared implicitly against not using sub-word graph extension; necessary to make graph-based representations compatible with shared BPE vocab used by seq2seq/Transformer.</td>
                        </tr>
                        <tr>
                            <td><strong>advantages</strong></td>
                            <td>Reduces data sparsity by enabling BPE subword modeling while preserving graph connectivity; allows shared source-target vocabulary.</td>
                        </tr>
                        <tr>
                            <td><strong>disadvantages</strong></td>
                            <td>Increases the number of graph nodes and edges (graph size), slightly complicating structure modeling.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>No explicit failure cases reported, but splitting increases graph size which may exacerbate processing costs or require truncation of path lengths for efficiency.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Modeling Graph Structure in Transformer for Better AMR-to-Text Generation', 'publication_date_yy_mm': '2019-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8982.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e8982.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for representing or converting graphs into text for language model training, including details of the representation, the type of graph, the conversion process, downstream tasks, performance metrics, comparisons to other methods, and any reported advantages, disadvantages, or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Structure-aware self-attention</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Structure-aware self-attention encoding in Transformer (this paper)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An extension of Transformer self-attention that injects learned structural relation vectors r_ij (derived from label sequences along shortest graph paths) into the key and value transformations so each token-to-token attention can be conditioned on AMR graph structure between the two concepts.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>structure-aware self-attention (relation-conditioned attention)</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Compute alignment score e_ij = (x_i W^Q) (x_j W^K + r_ij W^R)^T / sqrt(d_z) and output z_i = sum_j alpha_ij (x_j W^V + r_ij W^F), where r_ij is a learned vector representation of the structural label sequence along the shortest path between concept i and j (directions encoded).</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>AMR semantic graphs (concept nodes and labeled semantic edges), applied to arbitrary concept pairs including indirectly connected nodes</td>
                        </tr>
                        <tr>
                            <td><strong>conversion_method</strong></td>
                            <td>Precompute for every concept pair the shortest-path label sequence (edge labels with direction markers ↑/↓); map that label sequence to a vector r_ij via one of several encoders (feature, avg, sum, SA-based, CNN-based); supply r_ij to modify attention keys and values.</td>
                        </tr>
                        <tr>
                            <td><strong>downstream_task</strong></td>
                            <td>AMR-to-text generation (neural sentence generation from AMR)</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Best-performing systems using structure-aware self-attention achieved (Table 3): SA-based: BLEU 29.66 (LDC2015E86), Meteor 35.45, CHRF++ 63.00; BLEU 31.54 (LDC2017T10), Meteor 36.02, CHRF++ 63.84. CNN-based: BLEU 29.10 and 31.82 respectively (LDC2015E86 and LDC2017T10). Baseline (no structure-aware): BLEU 25.50 and 27.43.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_others</strong></td>
                            <td>Significantly outperforms baseline Transformer that uses only linearized inputs and prior graph-to-sequence models that only model one-hop (directly connected) relations; continuous r_ij encoders (SA-based, CNN-based) outperform discrete feature-based encodings; adds minimal model parameters (~49.1M -> ~49.2–49.4M).</td>
                        </tr>
                        <tr>
                            <td><strong>advantages</strong></td>
                            <td>Encodes both direct and indirect (multi-hop) graph relations into Transformer attention, explicitly models reentrancies and long-distance relations, yields substantial BLEU gains (up to +4.16 and +4.39 BLEU over baseline); particularly effective on graphs with many reentrancies or large graphs.</td>
                        </tr>
                        <tr>
                            <td><strong>disadvantages</strong></td>
                            <td>Requires precomputing pairwise shortest-path label sequences and encoding them (computation/memory overhead); for efficiency the paper limits structural label sequence length to 4, ignoring longer paths; slight parameter increase; adds modeling complexity.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>Performance still degrades on very large AMR graphs (long inputs) due to general seq2seq decoding issues; AMR lacks tense/number so generation may default to past/ plural forms; mapping indirectly connected pairs to None drops BLEU from 31.82 to 29.92 showing dependence on modeling indirect relations; truncation of path lengths (>4) causes ignored structure.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Modeling Graph Structure in Transformer for Better AMR-to-Text Generation', 'publication_date_yy_mm': '2019-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8982.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e8982.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for representing or converting graphs into text for language model training, including details of the representation, the type of graph, the conversion process, downstream tasks, performance metrics, comparisons to other methods, and any reported advantages, disadvantages, or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Feature-based path</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Feature-based structural path representation (discrete path features)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Represent each structural label sequence (shortest-path edge label string with direction markers) as a discrete string feature; retain top-K frequent features (20K) and map others to UNK, each feature mapped to an embedding vector.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>discrete feature string for path</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Concatenate the edge labels (with ↑/↓ direction markers) along the shortest path into a single string token representing that path; use a feature vocabulary of top-20K most frequent path strings and map to embedding vectors; rare paths mapped to UNK.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>AMR graphs (shortest-path label sequences between concept pairs)</td>
                        </tr>
                        <tr>
                            <td><strong>conversion_method</strong></td>
                            <td>Shortest-path label sequence -> concatenated string feature -> lookup embedding (top-K retained; others UNK).</td>
                        </tr>
                        <tr>
                            <td><strong>downstream_task</strong></td>
                            <td>AMR-to-text generation within structure-aware Transformer attention</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Table 3: BLEU 27.23 (LDC2015E86), Meteor 34.53, CHRF++ 61.55; BLEU 30.18 (LDC2017T10), Meteor 35.83, CHRF++ 63.20.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_others</strong></td>
                            <td>Underperforms continuous representation methods (avg/sum/SA/CNN); suffers from data sparsity; continuous encoders (SA-based, CNN-based) show higher BLEU.</td>
                        </tr>
                        <tr>
                            <td><strong>advantages</strong></td>
                            <td>Simple, interpretable discrete representation of exact path labels; direct capture of label-order as an atomic feature when frequent.</td>
                        </tr>
                        <tr>
                            <td><strong>disadvantages</strong></td>
                            <td>Large feature vocabulary and severe data sparsity; many rare paths collapsed to UNK which loses information; requires storage of large feature table.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>Poor performance when path vocabulary is large or many unique paths are rare (common in AMR), as shown by lower BLEU than continuous approaches.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Modeling Graph Structure in Transformer for Better AMR-to-Text Generation', 'publication_date_yy_mm': '2019-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8982.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e8982.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for representing or converting graphs into text for language model training, including details of the representation, the type of graph, the conversion process, downstream tasks, performance metrics, comparisons to other methods, and any reported advantages, disadvantages, or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Avg-based path</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Average-pooled label-embedding path representation</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Represent a structural path by averaging the embeddings of each label along the path, producing a fixed-size continuous vector.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>average of label embeddings</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Map each label in the path to an embedding vector and compute the mean of these label embeddings to form r_ij.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>AMR graphs (label sequences on shortest paths)</td>
                        </tr>
                        <tr>
                            <td><strong>conversion_method</strong></td>
                            <td>Shortest-path labels -> lookup label embeddings -> mean pooling over the sequence (r = sum l_i / k).</td>
                        </tr>
                        <tr>
                            <td><strong>downstream_task</strong></td>
                            <td>AMR-to-text generation via structure-aware Transformer</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Table 3: BLEU 28.37 (LDC2015E86), Meteor 35.10, CHRF++ 62.29; BLEU 29.56 (LDC2017T10), Meteor 35.24, CHRF++ 62.86.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_others</strong></td>
                            <td>Better than discrete feature-based encoding but slightly worse than sum-based, SA-based, and CNN-based continuous methods on some metrics.</td>
                        </tr>
                        <tr>
                            <td><strong>advantages</strong></td>
                            <td>Simple continuous representation that mitigates sparsity and is cheap to compute.</td>
                        </tr>
                        <tr>
                            <td><strong>disadvantages</strong></td>
                            <td>Loses position/order information of labels along the path; treats all labels equally regardless of position or interaction.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>May fail to capture ordered relational patterns important for some multi-hop relations; inferior to more expressive encoders on benchmark BLEU.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Modeling Graph Structure in Transformer for Better AMR-to-Text Generation', 'publication_date_yy_mm': '2019-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8982.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e8982.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for representing or converting graphs into text for language model training, including details of the representation, the type of graph, the conversion process, downstream tasks, performance metrics, comparisons to other methods, and any reported advantages, disadvantages, or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Sum-based path</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Sum-pooled label-embedding path representation</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Represent a structural path by summing label embeddings (no length normalization), yielding a continuous vector for r_ij.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>sum of label embeddings</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Map each path label to an embedding and sum them to create a fixed-size path vector (r = sum l_i).</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>AMR graphs (shortest-path label sequences)</td>
                        </tr>
                        <tr>
                            <td><strong>conversion_method</strong></td>
                            <td>Shortest-path labels -> lookup embeddings -> sum pooling.</td>
                        </tr>
                        <tr>
                            <td><strong>downstream_task</strong></td>
                            <td>AMR-to-text generation</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Table 3: BLEU 28.69 (LDC2015E86), Meteor 34.97, CHRF++ 62.05; BLEU 29.92 (LDC2017T10), Meteor 35.68, CHRF++ 63.04.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_others</strong></td>
                            <td>Slightly better than avg-based on LDC2015E86 and LDC2017T10 in BLEU for some settings; still below SA-based and CNN-based continuous encoders.</td>
                        </tr>
                        <tr>
                            <td><strong>advantages</strong></td>
                            <td>Simple continuous encoding; mitigates feature sparsity while preserving additive label information.</td>
                        </tr>
                        <tr>
                            <td><strong>disadvantages</strong></td>
                            <td>Still ignores label order beyond additive contribution; unnormalized sum may bias by path length.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>May misrepresent longer vs shorter paths due to additive scaling; less expressive than attention/CNN encoders.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Modeling Graph Structure in Transformer for Better AMR-to-Text Generation', 'publication_date_yy_mm': '2019-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8982.6">
                <h3 class="extraction-instance">Extracted Data Instance 6 (e8982.6)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for representing or converting graphs into text for language model training, including details of the representation, the type of graph, the conversion process, downstream tasks, performance metrics, comparisons to other methods, and any reported advantages, disadvantages, or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>SA-based path</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Self-Attention-based label-sequence path encoder</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Encode a structural label sequence with a self-attention encoder over label embeddings and a learned attention pooling to produce a fixed-size path vector r_ij.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>self-attention (label sequence encoder)</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Embed labels and positions, run a self-attention block to get hidden states h_i, compute an attention-weighted sum r = sum alpha_i h_i where alpha = softmax(W^2 tanh(W^1 h^T)), producing an order-aware continuous vector.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>AMR graphs (label sequences along shortest paths)</td>
                        </tr>
                        <tr>
                            <td><strong>conversion_method</strong></td>
                            <td>Shortest-path label sequence -> label embeddings + position embeddings -> self-attention encoder -> attention pooling -> r_ij.</td>
                        </tr>
                        <tr>
                            <td><strong>downstream_task</strong></td>
                            <td>AMR-to-text generation</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Table 3: BLEU 29.66 (LDC2015E86), Meteor 35.45, CHRF++ 63.00; BLEU 31.54 (LDC2017T10), Meteor 36.02, CHRF++ 63.84.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_others</strong></td>
                            <td>One of the top-performing continuous encoders; outperforms feature-based, avg, and sum; comparable to CNN-based (SA-based highest on LDC2015E86, CNN-based highest on LDC2017T10 in this paper).</td>
                        </tr>
                        <tr>
                            <td><strong>advantages</strong></td>
                            <td>Order-sensitive and expressive; can model interactions between labels along a path; substantially reduces sparsity and improves BLEU.</td>
                        </tr>
                        <tr>
                            <td><strong>disadvantages</strong></td>
                            <td>Computationally more expensive than simple pooling; requires choosing hyperparameters (d_w); paper limits max path length to 4 for efficiency.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>May miss information from paths longer than the truncated length (4); increased encoder cost and complexity.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Modeling Graph Structure in Transformer for Better AMR-to-Text Generation', 'publication_date_yy_mm': '2019-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8982.7">
                <h3 class="extraction-instance">Extracted Data Instance 7 (e8982.7)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for representing or converting graphs into text for language model training, including details of the representation, the type of graph, the conversion process, downstream tasks, performance metrics, comparisons to other methods, and any reported advantages, disadvantages, or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>CNN-based path</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Convolutional neural network path encoder (1D CNN)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Use a 1D convolutional neural network over label embedding sequences (kernel size 4, relu) to produce a fixed-size path representation r_ij.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>CNN-based label-sequence encoder</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Apply 1D Conv (kernel_size=4, filters=d_z, stride=1, relu) over the sequence of label embeddings, producing r by applying the conv filters and obtaining a fixed-sized output vector.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>AMR graphs (label sequences along shortest paths)</td>
                        </tr>
                        <tr>
                            <td><strong>conversion_method</strong></td>
                            <td>Shortest-path label sequence -> label embeddings -> 1D convolution (kernel size 4) -> output vector r_ij.</td>
                        </tr>
                        <tr>
                            <td><strong>downstream_task</strong></td>
                            <td>AMR-to-text generation</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Table 3: BLEU 29.10 (LDC2015E86), Meteor 35.00, CHRF++ 62.10; BLEU 31.82 (LDC2017T10), Meteor 36.38, CHRF++ 64.05 (CNN-based yields best LDC2017T10 BLEU 31.82).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_others</strong></td>
                            <td>Performs comparably to SA-based and is competitive with the best methods; outperforms discrete feature-based and simple pooling methods.</td>
                        </tr>
                        <tr>
                            <td><strong>advantages</strong></td>
                            <td>Computationally efficient and expressive for local label patterns; achieved the best BLEU on LDC2017T10 in the paper.</td>
                        </tr>
                        <tr>
                            <td><strong>disadvantages</strong></td>
                            <td>Kernel size and receptive field limit the range of interactions captured; path-length truncation still applies (max length 4).</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>May fail to capture long-range dependencies beyond CNN receptive field or truncated path length; kernel hyperparameters can affect performance.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Modeling Graph Structure in Transformer for Better AMR-to-Text Generation', 'publication_date_yy_mm': '2019-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Neural AMR: Sequence-to-sequence models for parsing and generation <em>(Rating: 2)</em></li>
                <li>Self-attention with relative position representations <em>(Rating: 2)</em></li>
                <li>A graph-to-sequence model for AMR-to-text generation <em>(Rating: 2)</em></li>
                <li>Structural neural encoders for AMR-to-text generation <em>(Rating: 2)</em></li>
                <li>Graph-to-sequence learning using gated graph neural networks <em>(Rating: 2)</em></li>
                <li>Densely connected graph convolutional networks for graph-to-sequence learning <em>(Rating: 2)</em></li>
                <li>Text generation from knowledge graphs with graph transformers <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-8982",
    "paper_id": "paper-afc1824a051f686e18ad87e1244bb0926a361021",
    "extraction_schema_id": "extraction-schema-158",
    "extracted_data": [
        {
            "name_short": "DFS-linearization",
            "name_full": "Depth-first traversal linearization of AMR graphs (Konstas et al., 2017)",
            "brief_description": "A serialization of AMR graphs into a token sequence using depth-first traversal after removing variables, wiki links and sense tags; reentrant nodes become repeated tokens in the linearized sequence.",
            "citation_title": "Neural AMR: Sequence-to-sequence models for parsing and generation",
            "mention_or_use": "use",
            "representation_name": "linearization (depth-first traversal)",
            "representation_description": "Traverse the AMR graph in depth-first order to output a linear token sequence of concept labels and edge labels (after simplifying the AMR by removing variables/wiki/sense tags). Reentrancies are represented by repeating the same concept token each time it is encountered in traversal.",
            "graph_type": "Abstract Meaning Representation (AMR) semantic graphs",
            "conversion_method": "Depth-first traversal of the AMR graph; remove variables, wiki links, sense tags; emit concept/edge tokens in traversal order; reentrant nodes map to multiple occurrences.",
            "downstream_task": "AMR-to-text generation (sentence generation)",
            "performance_metrics": "Used in baseline seq2seq Transformer: BLEU 25.50 (LDC2015E86), Meteor 33.16, CHRF++ 59.88; BLEU 27.43 (LDC2017T10), Meteor 34.62, CHRF++ 61.85 (Table 3).",
            "comparison_to_others": "Baseline linearization-based seq2seq is outperformed by structure-aware graph modeling approaches in this paper; linearization is simpler than explicit graph encoders (e.g., graph-to-sequence, GCN), but loses structural information such as reentrancies and long-distance relations.",
            "advantages": "Simple to implement; compatible with sequence models (Transformer/seq2seq); benefits from BPE and shared vocabulary to mitigate sparsity.",
            "disadvantages": "Loses explicit graph structure (especially reentrancies and long-distance relations); may map distinct graph structure to ambiguous sequences; long graphs produce long sequences and can cause decoding issues (early stopping).",
            "failure_cases": "Performs particularly poorly on AMR graphs with many reentrancies or many concepts (large graphs), where structural information is important; baseline often fails to indicate reentrant identity (e.g., repeated 'he' tokens ambiguous).",
            "uuid": "e8982.0",
            "source_info": {
                "paper_title": "Modeling Graph Structure in Transformer for Better AMR-to-Text Generation",
                "publication_date_yy_mm": "2019-08"
            }
        },
        {
            "name_short": "Subword-graph-extension",
            "name_full": "Graph structure extension to sub-word units (BPE-compatible AMR nodes)",
            "brief_description": "When input tokens are split into BPE sub-word units, the original AMR node is split into multiple connected sub-nodes and edges are adjusted so sub-units keep the original incoming edge label, preserving graph structure at sub-word granularity.",
            "citation_title": "here",
            "mention_or_use": "use",
            "representation_name": "sub-word-graph extension",
            "representation_description": "Extend AMR nodes to multiple nodes when a concept/token is segmented into BPE sub-words; connect the sub-nodes with an edge labeled as the incoming edge of the first sub-unit, so the AMR structure aligns with sub-word tokenization.",
            "graph_type": "AMR semantic graphs adapted to sub-word tokenization",
            "conversion_method": "Apply BPE to concepts; split a node into multiple connected nodes (one per subword) and add an internal edge bearing the original incoming relation for compatibility with sub-word inputs.",
            "downstream_task": "AMR-to-text generation using Transformer with BPE vocabulary",
            "performance_metrics": "Ablation indicates that BPE and shared vocabulary are critical; text reports improvement attributed to these techniques (text cites an improvement from 18.77 to 24.93 BLEU in ablation context).",
            "comparison_to_others": "Compared implicitly against not using sub-word graph extension; necessary to make graph-based representations compatible with shared BPE vocab used by seq2seq/Transformer.",
            "advantages": "Reduces data sparsity by enabling BPE subword modeling while preserving graph connectivity; allows shared source-target vocabulary.",
            "disadvantages": "Increases the number of graph nodes and edges (graph size), slightly complicating structure modeling.",
            "failure_cases": "No explicit failure cases reported, but splitting increases graph size which may exacerbate processing costs or require truncation of path lengths for efficiency.",
            "uuid": "e8982.1",
            "source_info": {
                "paper_title": "Modeling Graph Structure in Transformer for Better AMR-to-Text Generation",
                "publication_date_yy_mm": "2019-08"
            }
        },
        {
            "name_short": "Structure-aware self-attention",
            "name_full": "Structure-aware self-attention encoding in Transformer (this paper)",
            "brief_description": "An extension of Transformer self-attention that injects learned structural relation vectors r_ij (derived from label sequences along shortest graph paths) into the key and value transformations so each token-to-token attention can be conditioned on AMR graph structure between the two concepts.",
            "citation_title": "here",
            "mention_or_use": "use",
            "representation_name": "structure-aware self-attention (relation-conditioned attention)",
            "representation_description": "Compute alignment score e_ij = (x_i W^Q) (x_j W^K + r_ij W^R)^T / sqrt(d_z) and output z_i = sum_j alpha_ij (x_j W^V + r_ij W^F), where r_ij is a learned vector representation of the structural label sequence along the shortest path between concept i and j (directions encoded).",
            "graph_type": "AMR semantic graphs (concept nodes and labeled semantic edges), applied to arbitrary concept pairs including indirectly connected nodes",
            "conversion_method": "Precompute for every concept pair the shortest-path label sequence (edge labels with direction markers ↑/↓); map that label sequence to a vector r_ij via one of several encoders (feature, avg, sum, SA-based, CNN-based); supply r_ij to modify attention keys and values.",
            "downstream_task": "AMR-to-text generation (neural sentence generation from AMR)",
            "performance_metrics": "Best-performing systems using structure-aware self-attention achieved (Table 3): SA-based: BLEU 29.66 (LDC2015E86), Meteor 35.45, CHRF++ 63.00; BLEU 31.54 (LDC2017T10), Meteor 36.02, CHRF++ 63.84. CNN-based: BLEU 29.10 and 31.82 respectively (LDC2015E86 and LDC2017T10). Baseline (no structure-aware): BLEU 25.50 and 27.43.",
            "comparison_to_others": "Significantly outperforms baseline Transformer that uses only linearized inputs and prior graph-to-sequence models that only model one-hop (directly connected) relations; continuous r_ij encoders (SA-based, CNN-based) outperform discrete feature-based encodings; adds minimal model parameters (~49.1M -&gt; ~49.2–49.4M).",
            "advantages": "Encodes both direct and indirect (multi-hop) graph relations into Transformer attention, explicitly models reentrancies and long-distance relations, yields substantial BLEU gains (up to +4.16 and +4.39 BLEU over baseline); particularly effective on graphs with many reentrancies or large graphs.",
            "disadvantages": "Requires precomputing pairwise shortest-path label sequences and encoding them (computation/memory overhead); for efficiency the paper limits structural label sequence length to 4, ignoring longer paths; slight parameter increase; adds modeling complexity.",
            "failure_cases": "Performance still degrades on very large AMR graphs (long inputs) due to general seq2seq decoding issues; AMR lacks tense/number so generation may default to past/ plural forms; mapping indirectly connected pairs to None drops BLEU from 31.82 to 29.92 showing dependence on modeling indirect relations; truncation of path lengths (&gt;4) causes ignored structure.",
            "uuid": "e8982.2",
            "source_info": {
                "paper_title": "Modeling Graph Structure in Transformer for Better AMR-to-Text Generation",
                "publication_date_yy_mm": "2019-08"
            }
        },
        {
            "name_short": "Feature-based path",
            "name_full": "Feature-based structural path representation (discrete path features)",
            "brief_description": "Represent each structural label sequence (shortest-path edge label string with direction markers) as a discrete string feature; retain top-K frequent features (20K) and map others to UNK, each feature mapped to an embedding vector.",
            "citation_title": "here",
            "mention_or_use": "use",
            "representation_name": "discrete feature string for path",
            "representation_description": "Concatenate the edge labels (with ↑/↓ direction markers) along the shortest path into a single string token representing that path; use a feature vocabulary of top-20K most frequent path strings and map to embedding vectors; rare paths mapped to UNK.",
            "graph_type": "AMR graphs (shortest-path label sequences between concept pairs)",
            "conversion_method": "Shortest-path label sequence -&gt; concatenated string feature -&gt; lookup embedding (top-K retained; others UNK).",
            "downstream_task": "AMR-to-text generation within structure-aware Transformer attention",
            "performance_metrics": "Table 3: BLEU 27.23 (LDC2015E86), Meteor 34.53, CHRF++ 61.55; BLEU 30.18 (LDC2017T10), Meteor 35.83, CHRF++ 63.20.",
            "comparison_to_others": "Underperforms continuous representation methods (avg/sum/SA/CNN); suffers from data sparsity; continuous encoders (SA-based, CNN-based) show higher BLEU.",
            "advantages": "Simple, interpretable discrete representation of exact path labels; direct capture of label-order as an atomic feature when frequent.",
            "disadvantages": "Large feature vocabulary and severe data sparsity; many rare paths collapsed to UNK which loses information; requires storage of large feature table.",
            "failure_cases": "Poor performance when path vocabulary is large or many unique paths are rare (common in AMR), as shown by lower BLEU than continuous approaches.",
            "uuid": "e8982.3",
            "source_info": {
                "paper_title": "Modeling Graph Structure in Transformer for Better AMR-to-Text Generation",
                "publication_date_yy_mm": "2019-08"
            }
        },
        {
            "name_short": "Avg-based path",
            "name_full": "Average-pooled label-embedding path representation",
            "brief_description": "Represent a structural path by averaging the embeddings of each label along the path, producing a fixed-size continuous vector.",
            "citation_title": "here",
            "mention_or_use": "use",
            "representation_name": "average of label embeddings",
            "representation_description": "Map each label in the path to an embedding vector and compute the mean of these label embeddings to form r_ij.",
            "graph_type": "AMR graphs (label sequences on shortest paths)",
            "conversion_method": "Shortest-path labels -&gt; lookup label embeddings -&gt; mean pooling over the sequence (r = sum l_i / k).",
            "downstream_task": "AMR-to-text generation via structure-aware Transformer",
            "performance_metrics": "Table 3: BLEU 28.37 (LDC2015E86), Meteor 35.10, CHRF++ 62.29; BLEU 29.56 (LDC2017T10), Meteor 35.24, CHRF++ 62.86.",
            "comparison_to_others": "Better than discrete feature-based encoding but slightly worse than sum-based, SA-based, and CNN-based continuous methods on some metrics.",
            "advantages": "Simple continuous representation that mitigates sparsity and is cheap to compute.",
            "disadvantages": "Loses position/order information of labels along the path; treats all labels equally regardless of position or interaction.",
            "failure_cases": "May fail to capture ordered relational patterns important for some multi-hop relations; inferior to more expressive encoders on benchmark BLEU.",
            "uuid": "e8982.4",
            "source_info": {
                "paper_title": "Modeling Graph Structure in Transformer for Better AMR-to-Text Generation",
                "publication_date_yy_mm": "2019-08"
            }
        },
        {
            "name_short": "Sum-based path",
            "name_full": "Sum-pooled label-embedding path representation",
            "brief_description": "Represent a structural path by summing label embeddings (no length normalization), yielding a continuous vector for r_ij.",
            "citation_title": "here",
            "mention_or_use": "use",
            "representation_name": "sum of label embeddings",
            "representation_description": "Map each path label to an embedding and sum them to create a fixed-size path vector (r = sum l_i).",
            "graph_type": "AMR graphs (shortest-path label sequences)",
            "conversion_method": "Shortest-path labels -&gt; lookup embeddings -&gt; sum pooling.",
            "downstream_task": "AMR-to-text generation",
            "performance_metrics": "Table 3: BLEU 28.69 (LDC2015E86), Meteor 34.97, CHRF++ 62.05; BLEU 29.92 (LDC2017T10), Meteor 35.68, CHRF++ 63.04.",
            "comparison_to_others": "Slightly better than avg-based on LDC2015E86 and LDC2017T10 in BLEU for some settings; still below SA-based and CNN-based continuous encoders.",
            "advantages": "Simple continuous encoding; mitigates feature sparsity while preserving additive label information.",
            "disadvantages": "Still ignores label order beyond additive contribution; unnormalized sum may bias by path length.",
            "failure_cases": "May misrepresent longer vs shorter paths due to additive scaling; less expressive than attention/CNN encoders.",
            "uuid": "e8982.5",
            "source_info": {
                "paper_title": "Modeling Graph Structure in Transformer for Better AMR-to-Text Generation",
                "publication_date_yy_mm": "2019-08"
            }
        },
        {
            "name_short": "SA-based path",
            "name_full": "Self-Attention-based label-sequence path encoder",
            "brief_description": "Encode a structural label sequence with a self-attention encoder over label embeddings and a learned attention pooling to produce a fixed-size path vector r_ij.",
            "citation_title": "here",
            "mention_or_use": "use",
            "representation_name": "self-attention (label sequence encoder)",
            "representation_description": "Embed labels and positions, run a self-attention block to get hidden states h_i, compute an attention-weighted sum r = sum alpha_i h_i where alpha = softmax(W^2 tanh(W^1 h^T)), producing an order-aware continuous vector.",
            "graph_type": "AMR graphs (label sequences along shortest paths)",
            "conversion_method": "Shortest-path label sequence -&gt; label embeddings + position embeddings -&gt; self-attention encoder -&gt; attention pooling -&gt; r_ij.",
            "downstream_task": "AMR-to-text generation",
            "performance_metrics": "Table 3: BLEU 29.66 (LDC2015E86), Meteor 35.45, CHRF++ 63.00; BLEU 31.54 (LDC2017T10), Meteor 36.02, CHRF++ 63.84.",
            "comparison_to_others": "One of the top-performing continuous encoders; outperforms feature-based, avg, and sum; comparable to CNN-based (SA-based highest on LDC2015E86, CNN-based highest on LDC2017T10 in this paper).",
            "advantages": "Order-sensitive and expressive; can model interactions between labels along a path; substantially reduces sparsity and improves BLEU.",
            "disadvantages": "Computationally more expensive than simple pooling; requires choosing hyperparameters (d_w); paper limits max path length to 4 for efficiency.",
            "failure_cases": "May miss information from paths longer than the truncated length (4); increased encoder cost and complexity.",
            "uuid": "e8982.6",
            "source_info": {
                "paper_title": "Modeling Graph Structure in Transformer for Better AMR-to-Text Generation",
                "publication_date_yy_mm": "2019-08"
            }
        },
        {
            "name_short": "CNN-based path",
            "name_full": "Convolutional neural network path encoder (1D CNN)",
            "brief_description": "Use a 1D convolutional neural network over label embedding sequences (kernel size 4, relu) to produce a fixed-size path representation r_ij.",
            "citation_title": "here",
            "mention_or_use": "use",
            "representation_name": "CNN-based label-sequence encoder",
            "representation_description": "Apply 1D Conv (kernel_size=4, filters=d_z, stride=1, relu) over the sequence of label embeddings, producing r by applying the conv filters and obtaining a fixed-sized output vector.",
            "graph_type": "AMR graphs (label sequences along shortest paths)",
            "conversion_method": "Shortest-path label sequence -&gt; label embeddings -&gt; 1D convolution (kernel size 4) -&gt; output vector r_ij.",
            "downstream_task": "AMR-to-text generation",
            "performance_metrics": "Table 3: BLEU 29.10 (LDC2015E86), Meteor 35.00, CHRF++ 62.10; BLEU 31.82 (LDC2017T10), Meteor 36.38, CHRF++ 64.05 (CNN-based yields best LDC2017T10 BLEU 31.82).",
            "comparison_to_others": "Performs comparably to SA-based and is competitive with the best methods; outperforms discrete feature-based and simple pooling methods.",
            "advantages": "Computationally efficient and expressive for local label patterns; achieved the best BLEU on LDC2017T10 in the paper.",
            "disadvantages": "Kernel size and receptive field limit the range of interactions captured; path-length truncation still applies (max length 4).",
            "failure_cases": "May fail to capture long-range dependencies beyond CNN receptive field or truncated path length; kernel hyperparameters can affect performance.",
            "uuid": "e8982.7",
            "source_info": {
                "paper_title": "Modeling Graph Structure in Transformer for Better AMR-to-Text Generation",
                "publication_date_yy_mm": "2019-08"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Neural AMR: Sequence-to-sequence models for parsing and generation",
            "rating": 2
        },
        {
            "paper_title": "Self-attention with relative position representations",
            "rating": 2
        },
        {
            "paper_title": "A graph-to-sequence model for AMR-to-text generation",
            "rating": 2
        },
        {
            "paper_title": "Structural neural encoders for AMR-to-text generation",
            "rating": 2
        },
        {
            "paper_title": "Graph-to-sequence learning using gated graph neural networks",
            "rating": 2
        },
        {
            "paper_title": "Densely connected graph convolutional networks for graph-to-sequence learning",
            "rating": 2
        },
        {
            "paper_title": "Text generation from knowledge graphs with graph transformers",
            "rating": 1
        }
    ],
    "cost": 0.01560375,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Modeling Graph Structure in Transformer for Better AMR-to-Text Generation</h1>
<p>Jie Zhu ${ }^{1}$<br>Longhua Qian ${ }^{1}$<br>Junhui $\mathrm{Li}^{1 *}$<br>Min Zhang ${ }^{1}$<br>Muhua Zhu ${ }^{2}$<br>Guodong Zhou ${ }^{1}$<br>${ }^{1}$ School of Computer Science and Technology, Soochow University, Suzhou, China<br>${ }^{2}$ Alibaba Group, Hangzhou, China<br>zhujie951121@gmail.com, {lijunhui, qianlonghua, minzhang, gdzhou}@suda.edu.cn<br>muhua.zmh@alibaba-inc.com</p>
<h4>Abstract</h4>
<p>Recent studies on AMR-to-text generation often formalize the task as a sequence-tosequence (seq2seq) learning problem by converting an Abstract Meaning Representation (AMR) graph into a word sequence. Graph structures are further modeled into the seq2seq framework in order to utilize the structural information in the AMR graphs. However, previous approaches only consider the relations between directly connected concepts while ignoring the rich structure in AMR graphs. In this paper we eliminate such a strong limitation and propose a novel structure-aware selfattention approach to better modeling the relations between indirectly connected concepts in the state-of-the-art seq2seq model, i.e., the Transformer. In particular, a few different methods are explored to learn structural representations between two concepts. Experimental results on English AMR benchmark datasets show that our approach significantly outperforms the state of the art with 29.66 and 31.82 BLEU scores on LDC2015E86 and LDC2017T10, respectively. To the best of our knowledge, these are the best results achieved so far by supervised models on the benchmarks.</p>
<h2>1 Introduction</h2>
<p>AMR-to-text generation is a task of automatically generating a natural language sentence from an Abstract Meaning Representation (AMR) graph. Due to the importance of AMR as a widely adopted semantic formalism in representing the meaning of a sentence (Banarescu et al., 2013), AMR has become popular in semantic representation and AMR-to-text generation has been drawing more and more attention in the last decade. As the example in Figure 1(a) shows, nodes, such as he and convict-01, represent semantic concepts</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup>and edges, such as ":ARG1" and ":quant", refer to semantic relations between the concepts. Since two concepts close in an AMR graph may map into two segments that are distant in the corresponding sentence, AMR-to-text generation is challenging. For example in Figure 1, the neighboring concepts he and convict-01 correspond to the words he and convicted which locate at the different ends of the sentence.</p>
<p>To address the above mentioned challenge, recent studies on AMR-to-text generation regard the task as a sequence-to-sequence (seq2seq) learning problem by properly linearizing an AMR graph into a sequence (Konstas et al., 2017). Such an input representation, however, is apt to lose useful structural information due to the removal of reentrant structures for linearization. To better model graph structures, previous studies propose various graph-based seq2seq models to incorporate graphs as an additional input representation (Song et al., 2018; Beck et al., 2018; Damonte and Cohen, 2019). Although such graph-to-sequence models can achieve the state-of-the-art results, they focus on modeling one-hop relations only. That is, they only model concept pairs connected directly by an edge (Song et al., 2018; Beck et al., 2018), and as a result, ignore explicit structural information of indirectly connected concepts in AMR graphs, e.g. the relation between concepts he and possible in Figure 1.</p>
<p>To make better use of structural information in an AMR graph, we attempt to model arbitrary concept pairs no matter whether directly connected or not. To this end, we extend the encoder in the state-of-the-art seq2seq model, i.e., the Transformer (Vaswani et al., 2017) and propose structure-aware self-attention encoding approach. In particular, several distinct methods are proposed to learn structure representations for the new self-attention mechanism.</p>
<p>Empirical studies on two English benchmarks show that our approach significantly advances the state of the art for AMR-to-text generation, with the performance improvement of 4.16 BLEU score on LDC2015E86 and 4.39 BLEU score on LDC2017T10 respectively over the strong baseline. Overall, this paper makes the following contributions.</p>
<ul>
<li>To the best of our knowledge, this is the first work that applies the Transformer to the task of AMR-to-text generation. On the basis of the Transformer, we build a strong baseline that reaches the state of the art.</li>
<li>We propose a new self-attention mechanism to incorporate richer structural information in AMR graphs. Experimental results on two benchmarks demonstrate the effectiveness of the proposed approach.</li>
<li>Benefiting from the strong baseline and the structure-aware self-attention mechanism, we greatly advance the state of the art in the task.</li>
</ul>
<h2>2 AMR-to-Text Generation with Graph Structure Modeling</h2>
<p>We start by describing the implementation of our baseline system, a state-of-the-art seq2seq model which is originally used for neural machine translation and syntactic parsing (Vaswani et al., 2017). Then we detail the proposed approach to incorporating structural information from AMR graphs.</p>
<h3>2.1 Transformer-based Baseline</h3>
<p>Transformer: Our baseline system builds on the Transformer which employs an encoder-decoder framework, consisting of stacked encoder and decoder layers. Each encoder layer has two sublayers: self-attention layer followed by a positionwise feed forward layer. Self-attention layer employs multiple attention heads and the results from each attention head are concatenated and transformed to form the output of the self-attention layer. Each attention head uses scaled dotproduct attention which takes a sequence $x=$ $\left(x_{1}, \cdots, x_{n}\right)$ of $n$ elements as input and computes a new sequence $z=\left(z_{1}, \cdots, z_{n}\right)$ of the same length:</p>
<p>$$
z=\operatorname{Attention}(x)
$$</p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" />
(b)
( possible :arg1 ( sentence :arg1 he :arg2 ( temporalquantity :quant 7 :unit year :location prison ) :condition ( convict :arg1 he ) ) )
(c)
possible sentence he temporal-quantity 7 year prison convict
<img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 1: (a) An example of AMR graph for the sentence of He could be sentenced to 7 years in prison if convicted. (b) input to our baseline system, the seq2seq Transformer. (c) input to our proposed system based on structure-aware self-attention. (d) An example of graph structure extensions to sub-word units.</p>
<p>where $x_{i} \in \mathbb{R}^{d_{x}}$ and $z \in \mathbb{R}^{n \times d_{z}}$. Each output element $z_{i}$ is a weighted sum of a linear transformation of input elements:</p>
<p>$$
z_{i}=\sum_{j=1}^{n} \alpha_{i j}\left(x_{j} W^{V}\right)
$$</p>
<p>where $W^{V} \in \mathbb{R}^{d_{x} \times d_{z}}$ is matrix of parameters. The vectors $\alpha_{i}=\left(\alpha_{i 1}, \cdots, \alpha_{i n}\right)$ in Equation 2 are obtained by the self-attention model, which captures the correspondences between $x_{i}$ and others. Specifically, the attention weight $\alpha_{i j}$ of each element $x_{j}$ is computed using a softmax function:</p>
<p>$$
\alpha_{i j}=\frac{\exp \left(e_{i j}\right)}{\sum_{k=1}^{n} \exp \left(e_{i k}\right)}
$$</p>
<p>where</p>
<p>$$
e_{i j}=\frac{\left(x_{i} W^{Q}\right)\left(x_{j} W^{K}\right)^{T}}{\sqrt{d_{z}}}
$$</p>
<p>is an alignment function which measures how well the input elements $x_{i}$ and $x_{j}$ match. $W^{Q}, W^{K} \in$ $\mathbb{R}^{d_{x} \times d_{z}}$ are parameters to be learned.
Input Representation: We use the depth-first traversal strategy as in Konstas et al. (2017) to linearize AMR graphs and to obtain simplified AMRs. We remove variables, wiki links and sense tags before linearization. Figure 1(b) shows an example linearization result for the AMR graph in Figure 1(a). Note that the reentrant concept he in Figure 1 (a) maps to two different tokens in the linearized sequence.
Vocabulary: Training AMR-to-text generation systems solely on labeled data may suffer from data sparseness. To attack this problem, previous works adopt techniques like anonymization to remove named entities and rare words (Konstas et al., 2017), or apply a copy mechanism (Gulcehre et al., 2016) such that the models can learn to copy rare words from the input sequence. In this paper we instead use two simple yet effective techniques. One is to apply Byte Pair Encoding (BPE) (Sennrich et al., 2016) to split words into smaller, more frequent sub-word units. The other is to use a shared vocabulary for both source and target sides. Experiments in Section 3.2 demonstrate the necessity of the techniques in building a strong baseline.</p>
<h3>2.2 Modeling Graph Structures in Transformer</h3>
<p>Input Representation: We also use the depthfirst traversal strategy to linearize AMR graphs
and to obtain simplified AMRs which only consist of concepts. As shown in Figure 1 (c), the input sequence is much shorter than the input sequence in the baseline. Besides, we also obtain a matrix which records the graph structure between every concept pair, which implies their semantic relationship (Section2.3).
Vocabulary: To be compatible with sub-words, we extend the original AMR graph, if necessary, to include the structures of sub-words. As sentence01 in Figure 1(a) is segmented into sent@ @ ence01, we split the original node into two connected ones with an edge labeled as the incoming edge of the first unit. Figure 1(d) shows the graph structure for sub-words sent@ @ ence-01.
Structure-Aware Self-Attention: Motivated by Shaw et al. (2018), we extend the conventional self-attention architecture to explicitly encode the relation between an element pair $\left(x_{i}, x_{j}\right)$ in the alignment model by replacing Equation 4 with Equation 5. Note that the relation $r_{i j} \in \mathbb{R}^{d_{z}}$ is the vector representation for element pair $\left(x_{i}, x_{j}\right)$, and will be learned in Section 2.3.</p>
<p>$$
e_{i j}=\frac{\left(x_{i} W^{Q}\right)\left(x_{j} W^{K}+r_{i j} W^{R}\right)^{T}}{\sqrt{d_{z}}}
$$</p>
<p>where $W^{R} \in \mathbb{R}^{d_{z} \times d_{z}}$ is a parameter matrix. Then, we update Equation 2 accordingly to propagate structure information to the sublayer output by:</p>
<p>$$
z_{i}=\sum_{j=1}^{n} \alpha_{i j}\left(x_{j} W^{V}+r_{i j} W^{F}\right)
$$</p>
<p>where $W^{F} \in \mathbb{R}^{d_{z} \times d_{z}}$ is a parameter matrix.</p>
<h3>2.3 Learning Graph Structure Representation for Concept Pairs</h3>
<p>The above structure-aware self-attention is capable of incorporating graph structure between concept pairs. In this section, we explore a few methods to learn the representation for concept pairs. We use a sequence of edge labels, along the path from $x_{i}$ to $x_{j}$ to indicate the AMR graph structure between concepts $x_{i}$ and $x_{j} .{ }^{1}$ In order to distinguish the edge direction, we add a direction symbol to each label with $\uparrow$ for climbing up along the path, and $\downarrow$ for going down. Specifically, for the special case of $i==j$, we use None as the path. Table 1 demonstrates structural label sequences between a few concept pairs in Figure 1.</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<table>
<thead>
<tr>
<th style="text-align: left;">$x_{i}$</th>
<th style="text-align: center;">$x_{j}$</th>
<th style="text-align: center;">Structural label sequence</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">he</td>
<td style="text-align: center;">convict-01</td>
<td style="text-align: center;">:ARG1 $\uparrow$</td>
</tr>
<tr>
<td style="text-align: left;">he</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">:ARG1 $\uparrow$ :ARG2 $\downarrow:$ quant $\downarrow$</td>
</tr>
<tr>
<td style="text-align: left;">he</td>
<td style="text-align: center;">he</td>
<td style="text-align: center;">None</td>
</tr>
</tbody>
</table>
<p>Table 1: Examples of structural path between a few concept pairs in Figure 1.</p>
<p>Now, given a structural path with a label sequence $s=s_{1}, \cdots, s_{k}$ and its $d_{x}$-sized corresponding label embedding sequence $l=$ $l_{1}, \cdots, l_{k}$, we use the following methods to obtain its representation vector $r$, which maps to $r_{i j}$ in Equation 5 and Equation 6.</p>
<h2>Feature-based</h2>
<p>A natural way to represent the structural path is to view it as a string feature. To this end, we combine the labels in the structural path into a string. Unsurprisingly, this will end up with a large number of features. We keep the most frequent ones (i.e., 20 K in our experiments) in the feature vocabulary and map all others into a special feature $U N K$. Each feature in the vocabulary will be mapped into a randomly initialized vector.</p>
<h2>Avg-based</h2>
<p>To overcome the data sparsity in the above featurebased method, we view the structural path as a label sequence. Then we simply use the averaged label embedding as the representation vector of the sequence, i.e.,</p>
<p>$$
r=\frac{\sum_{i=1}^{k} l_{i}}{k}
$$</p>
<h2>Sum-based</h2>
<p>Sum-based method simply returns the sum of all label embeddings in the sequence, i.e.,</p>
<p>$$
r=\sum_{i=1}^{k} l_{i}
$$</p>
<h2>Self-Attention-based (SA-based for short)</h2>
<p>As shown in Figure 2, given the label sequence $s=s_{1}, \cdots, s_{k}$, we first obtain the sequence $e$, whose element is the addition of a word embedding and the corresponding position embedding. Then we use the self-attention, as presented in Eq. 1 to obtain its hidden states $h$, i.e, $h=\operatorname{Attention}(e)$, where $h_{i} \in \mathbb{R}^{d_{z}}$. Our aim is to encode a variable length sentence into a $d_{z^{-}}$ sized vector. Motivated by (Lin et al., 2017), we achieve this by choosing a linear combination of
<img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 2: Self-Attention-based method.
the $k$ vectors in $h$. Computing the linear combination requires an attention mechanism which takes the whole hidden states $h$ as input, and outputs a vector of weights $\alpha$ :</p>
<p>$$
\alpha=\operatorname{softmax}\left(W^{2} \tanh \left(W^{1} h^{T}\right)\right)
$$</p>
<p>where $W^{1} \in \mathbb{R}^{d_{w} \times d_{z}}$ and $W^{2} \in \mathbb{R}^{d_{w}}$. Then the label sequence representation vector is the weighted sum of its hidden states:</p>
<p>$$
r=\sum_{i=1}^{k} \alpha_{i} h_{i}
$$</p>
<h2>CNN-based</h2>
<p>Motivated by (Kalchbrenner et al., 2014), we use convolutional neural network (CNN) to convolute the label sequence $l$ into a vector $r$, as follow:</p>
<p>$$
\begin{aligned}
\operatorname{conv}=\operatorname{Conv} 1 D(\text { kernel_size } &amp; =(m) \
\text { strides } &amp; =1 \
\text { filters } &amp; =d_{z} \
\text { input_shape } &amp; =d_{z} \
\text { activation } &amp; =^{\prime} \operatorname{relu}^{\prime} \
r=\operatorname{conv}(l)
\end{aligned}
$$</p>
<p>where kernel size $m$ is set to 4 in our experiments.</p>
<h2>3 Experimentation</h2>
<h3>3.1 Experimental Settings</h3>
<p>For evaluation of our approach, we use the sentences annotated with AMRs from the LDC release LDC2015E86 and LDC2017T10. The two datasets contain 16,833 and 36,521 training AMRs, respectively, and share 1,368 development AMRs and 1,371 testing AMRs. We segment words into sub-word units by BPE (Sennrich et al., 2016) with 10K operations on LDC2015E86 and 20K operations on LDC2017T10.</p>
<p>For efficiently learning graph structure representation for concept pairs (except the featurebased method), we limit the maximum label sequence length to 4 and ignore the labels exceeding the maximum. In SA-based method, we set the filter size $d_{w}$ as 128 .</p>
<p>We use OpenNMT (Klein et al., 2017) as the implementation of the Transformer seq2seq model. ${ }^{2}$ In parameter setting, we set the number of layers in both the encoder and decoder to 6 . For optimization we use Adam with $\beta 1=0.1$ (Kingma and $\mathrm{Ba}, 2015$ ). The number of heads is set to 8 . In addition, we set the embedding and the hidden sizes to 512 and the batch token-size to 4096 . Accordingly, the $d_{x}$ and $d_{z}$ in Section 2 are 64. In all experiments, we train the models for 300 K steps on a single K40 GPU.</p>
<p>For performance evaluation, we use BLEU (Papineni et al., 2002), Meteor (Banerjee and Lavie, 2005; Denkowski and Lavie, 2014), and CHRF++ (Popovi, 2017) as metrics. We report results of single models that are tuned on the development set.</p>
<p>We make our code available at https://github.com/Amazing-J/ structural-transformer.</p>
<h3>3.2 Experimental Results</h3>
<p>We first show the performance of our baseline system. As mentioned before, BPE and sharing vocabulary are two techniques we applied to relieving data sparsity. Table 2 presents the results of the ablation test on the development set of LDC2015E86 by either removing BPE, or vocabulary sharing, or both of them from the baseline system. From the results we can see that BPE and vocabulary sharing are critical to building our base-</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup>Table 2: Ablation results of our baseline system on the LDC2015E86 development set.
line system (an improvement from 18.77 to 24.93 in BLEU), revealing the fact that they are two effective ways to address the issue of data sparseness for AMR-to-text generation.</p>
<p>Table 3 presents the comparison of our approach and related works on the test sets of LDC2015E86 and LDC2017T10. From the results we can see that the Transformer-based baseline outperforms most of graph-to-sequence models and is comparable with the latest work by Guo et al. (2019). The strong performance of the baseline is attributed to the capability of the Transformer to encode global and implicit structural information in AMR graphs. By comparing the five methods of learning graph structure representations, we have the following observations.</p>
<ul>
<li>All of them achieve significant improvements over the baseline: the biggest improvements are 4.16 and 4.39 BLEU scores on LDC2015E86 and LDC2017T10, respectively.</li>
<li>Methods using continuous representations (such as SA-based and CNN-based) outperform the methods using discrete representations (such as feature-based).</li>
<li>Compared to the baseline, the methods have very limited affect on the sizes of model parameters (see the column of $# P(M)$ in Table 3).</li>
</ul>
<p>Finally, our best-performing models are the best among all the single and supervised models.</p>
<h2>4 Analysis</h2>
<p>In this section, we use LDC2017T10 as our benchmark dataset to demonstrate how our proposed approach achieves higher performance than the baseline. As representative, we use CNN-based method to obtain structural representation.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">System</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">LDC2015E86</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">LDC2017T10</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">BLEU</td>
<td style="text-align: center;">Meteor</td>
<td style="text-align: center;">CHRF++</td>
<td style="text-align: center;">#P (M)</td>
<td style="text-align: center;">BLEU</td>
<td style="text-align: center;">Meteor</td>
<td style="text-align: center;">CHRF++</td>
</tr>
<tr>
<td style="text-align: center;">Baseline</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">25.50</td>
<td style="text-align: center;">33.16</td>
<td style="text-align: center;">59.88</td>
<td style="text-align: center;">49.1</td>
<td style="text-align: center;">27.43</td>
<td style="text-align: center;">34.62</td>
<td style="text-align: center;">61.85</td>
</tr>
<tr>
<td style="text-align: center;">Our Approach</td>
<td style="text-align: center;">feature-based</td>
<td style="text-align: center;">27.23</td>
<td style="text-align: center;">34.53</td>
<td style="text-align: center;">61.55</td>
<td style="text-align: center;">49.4</td>
<td style="text-align: center;">30.18</td>
<td style="text-align: center;">35.83</td>
<td style="text-align: center;">63.20</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">avg-based</td>
<td style="text-align: center;">28.37</td>
<td style="text-align: center;">35.10</td>
<td style="text-align: center;">62.29</td>
<td style="text-align: center;">49.1</td>
<td style="text-align: center;">29.56</td>
<td style="text-align: center;">35.24</td>
<td style="text-align: center;">62.86</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">sum-based</td>
<td style="text-align: center;">28.69</td>
<td style="text-align: center;">34.97</td>
<td style="text-align: center;">62.05</td>
<td style="text-align: center;">49.1</td>
<td style="text-align: center;">29.92</td>
<td style="text-align: center;">35.68</td>
<td style="text-align: center;">63.04</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">SA-based</td>
<td style="text-align: center;">29.66</td>
<td style="text-align: center;">35.45</td>
<td style="text-align: center;">63.00</td>
<td style="text-align: center;">49.3</td>
<td style="text-align: center;">31.54</td>
<td style="text-align: center;">36.02</td>
<td style="text-align: center;">63.84</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">CNN-based</td>
<td style="text-align: center;">29.10</td>
<td style="text-align: center;">35.00</td>
<td style="text-align: center;">62.10</td>
<td style="text-align: center;">49.2</td>
<td style="text-align: center;">31.82</td>
<td style="text-align: center;">36.38</td>
<td style="text-align: center;">64.05</td>
</tr>
<tr>
<td style="text-align: center;">Previous works with single models</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Konstas et al. (2017)*</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">22.00</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">Cao and Clark (2019)*</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">23.5</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">26.8</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">Song et al. (2018) ${ }^{\ddagger}$</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">23.30</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">Beck et al. (2018) ${ }^{\ddagger}$</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">23.3</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">50.4</td>
</tr>
<tr>
<td style="text-align: center;">Damonte and Cohen (2019) ${ }^{\ddagger}$</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">24.40</td>
<td style="text-align: center;">23.60</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">24.54</td>
<td style="text-align: center;">24.07</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">Guo et al. (2019) ${ }^{\ddagger}$</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">25.7</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">27.6</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">57.3</td>
</tr>
<tr>
<td style="text-align: center;">Song et al. (2016) ${ }^{\ddagger}$</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">22.44</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">Previous works with either ensemble models or unlabelled data, or both</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Konstas et al. (2017)*</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">33.8</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">Song et al. (2018) ${ }^{\ddagger}$</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">33.0</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">Beck et al. (2018) ${ }^{\ddagger}$</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">27.5</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">53.5</td>
</tr>
<tr>
<td style="text-align: center;">Guo et al. (2019) ${ }^{\ddagger}$</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">35.3</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
</tbody>
</table>
<p>Table 3: Comparison results of our approaches and related studies on the test sets of LDC2015E86 and LDC2017T10. #P indicates the size of parameters in millions. * indicates seq2seq-based systems while ${ }^{\dagger}$ for graph-based models, and ${ }^{\ddagger}$ for other models. All our proposed systems are significant over the baseline at 0.01 , tested by bootstrap resampling (Koehn, 2004).</p>
<table>
<thead>
<tr>
<th style="text-align: center;">System</th>
<th style="text-align: center;">BLEU</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Baseline</td>
<td style="text-align: center;">27.43</td>
</tr>
<tr>
<td style="text-align: center;">Our approach</td>
<td style="text-align: center;">31.82</td>
</tr>
<tr>
<td style="text-align: center;">No indirectly connected concept pairs</td>
<td style="text-align: center;">29.92</td>
</tr>
</tbody>
</table>
<p>Table 4: Performance on the test set of our approach with or without modeling structural information of indirectly connected concept pairs.</p>
<h3>4.1 Effect of Modeling Structural Information of Indirectly Connected Concept Pairs</h3>
<p>Our approach is capable of modeling arbitrary concept pairs no matter whether directly connected or not. To investigate the effect of modeling structural information of indirectly connected concept pairs, we ignore their structural information by mapping all structural label sequences between two indirectly connected concept pairs into None. In this way, the structural label sequence for he and 7 in Table 1, for example, will be None.</p>
<p>Table 4 compares the performance of our approach with or without modeling structural information of indirectly connected concept pairs. It
shows that by modeling structural information of indirectly connected concept pairs, our approach improves the performance on the test set from 29.92 to 31.82 in BLEU scores. It also shows that even without modeling structural information of indirectly connected concept pairs, our approach achieves better performance than the baseline.</p>
<h3>4.2 Effect on AMR Graphs with Different Sizes of Reentrancies</h3>
<p>Linearizing an AMR graph into a sequence unavoidably loses information about reentrancies (nodes with multiple parents). This poses a challenge for the baseline since there exists on obvious sign that the first he and the second he, as shown in Figure 1 (b), refer to the same person. By contrast, our approach models reentrancies explicitly. Therefore, it is expected that the benefit of our approach is more evident for those AMR graphs containing more reentrancies. To test this hypothesis, we partition source AMR graphs to different groups by their numbers of reentrancies and evaluate their performance respectively. As shown in Figure 3, the performance gap be-</p>
<p><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 3: Performance (in BLEU) on the test set with respect to the reentrancy numbers of the input AMR graphs.
tween our approach and the baseline goes widest for AMR graphs with more than 5 reentrancies, on which our approach outperforms the baseline by 6.61 BLEU scores.</p>
<h3>4.3 Effect on AMR Graphs with Different Sizes</h3>
<p>When we encode an AMR graph with plenty concepts, linearizing it into a sequence tends to lose great amount of structural information. In order to test the hypothesis that graphs with more concepts contribute more to the improvement, we partition source AMR graphs to different groups by their sizes (i.e., numbers of concepts) and evaluate their performance respectively. Figure 4 shows the results which indicate that modeling graph structures significantly outperforms the baseline over all AMR lengths. We also observe that the performance gap between the baseline and our approach increases when AMR graphs become big, revealing that the baseline seq2seq model is far from capturing deep structural details of big AMR graphs. Figure 4 also indicates that text generation becomes difficult for big AMR graphs. We think that the low performance on big AMR graphs is mainly attributed to two reasons:</p>
<ul>
<li>Big AMR graphs are usually mapped into long sentences while seq2seq model tends to stop early for long inputs. As a result, the length ratio ${ }^{3}$ for AMRs with more than 40 concepts is 0.906 , much lower than that for AMRs with less concepts.</li>
</ul>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup><img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 4: Performance (in BLEU) on the test set with respect to the size of the input AMR graphs.</p>
<ul>
<li>Big AMR graphs are more likely to have reentrancies, which makes the generation more challenging.</li>
</ul>
<h3>4.4 Case Study</h3>
<p>In order to better understand the model performance, Figure 5 presents a few examples studied in Song et al. (2018) (Example (1)) and Damonte and Cohen (2019) (Examples (2) - (5)).</p>
<p>In Example (1), though our baseline recovers a propositional phrase for the noun staff and another one for the noun funding, it fails to recognize the anaphora and antecedent relation between the two propositional phrases. In contrast, our approach successfully recognizes :prep-for $c$ as a reentrancy node and generates one propositional phrase shared by both nouns staff and funding. In Example (2), we note that although AMR graphs lack tense information, the baseline generates output with inconsistent tense (i.e., do and found) while our approach consistently prefers past tense for the two clauses. In Example (3), only our approach correctly uses people as the subject of the predicate can. In Example (4), the baseline fails to predict the direct object you for predicate recommend. Finally in Example (5), the baseline fails to recognize the subject-predicate relation between noun communicate and verb need. Overall, we note that compared to the baseline, our approach produces more accurate output and deal with reentrancies more properly.</p>
<p>Comparing the generation of our approach and graph-based models in Song et al. (2018) and Damonte and Cohen (2019), we observe that our generation is more close to the reference in sentence structure. Due to the absence of tense informa-</p>
<p><img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>Figure 5: Examples of generation from AMR graphs. (1) is from Song et al. (2018), (2) - (5) are from Damonte and Cohen (2019). REF is the reference sentence. SEQ1 and G2S are the outputs of the seq2seq and the graph2seq models in Song et al. (2018), respectively. SEQ2 and GRAPH are the outputs of the seq2seq and the graph models in Damonte and Cohen (2019), respectively.
tion in AMR graphs, our model tends to use past tense, as provided and did in Example (1) and (2). Similarly, without information concerning singular form and plural form, our model is more likely to use plural nouns, as centers and lawyers in Example (1) and (5).</p>
<h2>5 Related Work</h2>
<p>Most studies in AMR-to-text generation regard it as a translation problem and are motivated by the recent advances in both statistical machine translation (SMT) and neural machine translation (NMT). Flanigan et al. (2016) first transform an AMR graph into a tree, then specify a number of tree-to-string transduction rules based on align-
ments that are used to drive a tree-based SMT model (Graehl and Knight, 2004). Pourdamghani et al. (2016) develop a method that learns to linearize AMR graphs into AMR strings, and then feed them into a phrase-based SMT model (Koehn et al., 2003). Song et al. (2017) use synchronous node replacement grammar (SNRG) to generate text. Different from synchronous context-free grammar in hierarchical phrase-based SMT (Chiang, 2007), SNRG is a grammar over graphs.</p>
<p>Moving to neural seq2seq approaches, Konstas et al. (2017) successfully apply seq2seq model together with large-scale unlabeled data for both text-to-AMR parsing and AMR-to-text generation. With special interest in the target side syn-</p>
<p>tax, Cao and Clark (2019) use seq2seq models to generate target syntactic structure, and then the surface form. To prevent the information loss in linearizing AMR graphs into sequences, (Song et al., 2018; Beck et al., 2018) propose graph-to-sequence models to encode graph structure directly. Focusing on reentrancies, Damonte and Cohen (2019) propose stacking encoders which consist of BiLSTM (Graves et al., 2013), TreeLSTMs (Tai et al., 2015), and Graph Convolutional Network (GCN) (Duvenaud et al., 2015; Kipf and Welling, 2016). Guo et al. (2019) propose densely connected GCN to better capture both local and non-local features. However, all the aforementioned graph-based models only consider the relations between nodes that are directly connected, thus lose the structural information between nodes that are indirectly connected via an edge path.</p>
<p>Recent studies also extend the Transformer to encode structural information for other NLP applications. Shaw et al. (2018) propose relationaware self-attention to capture relative positions of word pairs for neural machine translation. Ge et al. (2019) extend the relation-aware selfattention to capture syntactic and semantic structures. Our model is inspired by theirs but aims to encode structural label sequences of concept pairs. Koncel-Kedziorski et al. (2019) propose graph Transformer to encode graph structure. Similar to the GCN, it focuses on the relations between directly connected nodes.</p>
<h2>6 Conclusion and Future Work</h2>
<p>In this paper we proposed a structure-aware selfattention for the task of AMR-to-text generation. The major idea of our approach is to encode long-distance relations between concepts in AMR graphs into the self-attention encoder in the Transformer. In the setting of supervised learning, our models achieved the best experimental results ever reported on two English benchmarks.</p>
<p>Previous studies have shown the effectiveness of using large-scale unlabelled data. In future work, we would like to do semi-supervised learning and use silver data to test how much improvements could be further achieved.</p>
<h2>Acknowledgments</h2>
<p>We thank the anonymous reviewers for their insightful comments and suggestions. We are grateful to Linfeng Song for fruitful discussions. This
work is supported by the National Natural Science Foundation of China (Grant No. 61876120, 61673290, 61525205), and the Priority Academic Program Development of Jiangsu Higher Education Institutions.</p>
<h2>References</h2>
<p>Laura Banarescu, Claire Bonial, Shu Cai, Madalina Georgescu, Kira Griffitt, Ulf Hermjakob, Kevin Knight, Philipp Koehn, Martha Palmer, and Nathan Schneider. 2013. Abstract meaning representation for sembanking. In Proceedings of 7th Linguistic Annotation Workshop \&amp; Interoperability with Discourse, pages 178-186.</p>
<p>Satanjeev Banerjee and Alon Lavie. 2005. Meteor: An automatic metric for mt evaluation with improved correlation with human judgments. In Proceedings of $A C L$, pages $65-72$.</p>
<p>Daniel Beck, Gholamreza Haffari, and Trevor Cohn. 2018. Graph-to-sequence learning using gated graph neural networks. In Proceedings of ACL, pages 273-283.</p>
<p>Kris Cao and Stephen Clark. 2019. Factorising amr generation through syntax. In Proceedings of NAACL, pages 2157-2163.</p>
<p>David Chiang. 2007. Hierarchical phrase-based translation. Computational Linguistics, 33:201-228.</p>
<p>Marco Damonte and Shay B. Cohen. 2019. Structural neural encoders for AMR-to-text generation. In Proceedings of NAACL, pages 3649-3658.</p>
<p>Michael Denkowski and Alon Lavie. 2014. Meteor universal: Language specific translation evaluation for any target language. In Proceedings of WMT, pages 376-380.</p>
<p>David K Duvenaud, Dougal Maclaurin, Jorge Iparraguirre, Rafael Bombarell, Timonthy Hirzel, Alan Aspuru-Guzik, and Ryan P Adams. 2015. Convolutional networks on graphs for learning molecular fingerprints. In Proceedings of NIPS, pages 22242232.</p>
<p>Jeffrey Flanigan, Chris Dyer, Noah A. Smith, and Jaime Carbonell. 2016. Generation from abstract meaning representation using tree transducers. In Proceedings of NAACL, pages 731-739.</p>
<p>DongLai Ge, Junhui Li, Muhua Zhu, and Shoushan Li. 2019. Modeling source syntax and semantics for neural amr parsing. In Proceedings of IJCAI, pages 4975-4981.</p>
<p>Jonathan Graehl and Kevin Knight. 2004. Training tree transducers. In Proceedings of NAACL, pages 105112 .</p>
<p>Alex Graves, Abdel rahman Mohamed, and Geoffrey Hinton. 2013. Speech recognition with deep recurrent neural networks. In Proceedings of ICASSP, pages 6645-6649.</p>
<p>Caglar Gulcehre, Sungjin Ahn, Ramesh Nallapati, Bowen Zhou, and Yoshua Bengio. 2016. Pointing the unknown words. In Proceedings of ACL, pages $140-149$.</p>
<p>Zhijiang Guo, Yan Zhang, Zhiyang Teng, and Wei Lu. 2019. Densely connected graph convolutional networks for graph-to-sequence learning. Transactions of the Association of Computational Linguistics, 7:297-312.</p>
<p>Nal Kalchbrenner, Edward Grefenstette, and Phil Blunsom. 2014. A convolutional neural network for modelling sentences. In Proceedings of ACL, pages $655-665$.</p>
<p>Diederik P. Kingma and Jimmy Ba. 2015. Adam: A method for stochastic optimization. In Proceedings of $I C L R$.</p>
<p>Thomas N Kipf and Max Welling. 2016. Semisupervised classification with graph convolutional networks. In Proceedings of $I C L R$.</p>
<p>Guillaume Klein, Yoon Kim, Yuntian Deng, Jean Senellart, and Alexander M. Rush. 2017. Opennmt: Open-source toolkit for neural machine translation. In Proceedings of ACL, System Demonstrations, pages 67-72.</p>
<p>Philipp Koehn. 2004. Statistical significance tests for machine translation evaluation. In Proceedings of EMNLP, pages 388-395.</p>
<p>Philipp Koehn, Franz J. Och, and Daniel Marcu. 2003. Statistical phrase-based translation. In Proceedings of NAACL, pages 127-133.</p>
<p>Rik Koncel-Kedziorski, Dhanush Bekal, Yi Luan, Mirella Lapata, and Hannaneh Hajishirzi. 2019. Text generation from knowledge graphs with graph transformers. In Proceedings of NAACL, pages 2284-2293.</p>
<p>Ioannis Konstas, Srinivasan Iyer, Mark Yatskar, Yejin Choi, and Luke Zettlemoyer. 2017. Neural AMR: Sequence-to-sequence models for parsing and generation. In Proceedings of ACL, pages 146-157.</p>
<p>Zhouhan Lin, Minwei Feng, Cicero Nogueira dos Santos, Mo Yu, Bing Xiang, Bowen Zhou, and Yoshua Bengio. 2017. A structured self-attentive sentence embedding. In Proceedings of $I C L R$.</p>
<p>Kishore Papineni, Salim Roukos, Ward Todd, and WeiJing Zhu. 2002. Bleu: a method for automatic evaluation of machine translation. In Proceedings of $A C L$, pages 311-318.</p>
<p>Maja Popovi. 2017. chrf++: words helping character n-grams. In Proceedings of WMT, pages 612-618.</p>
<p>Nima Pourdamghani, Kevin Knight, and Ulf Hermjakob. 2016. Generating english from abstract meaning representations. In Proceedings of the 9th International Natural Language Generation conference, pages 21-25.</p>
<p>Rico Sennrich, Barry Haddow, and Alexandra Birch. 2016. Neural machine translation of rare words with subword units. In Proceedings of ACL, pages 17151725.</p>
<p>Peter Shaw, Jakob Uszkoreit, and Ashish Vaswani. 2018. Self-attention with relative position representations. In Proceedings of NAACL, pages 464-468.</p>
<p>Linfeng Song, Xiaochang Peng, Yue Zhang, Zhiguo Wang, and Daniel Gildea. 2017. Amr-to-text generation with synchronous node replacement grammar. In Proceedings of $A C L$, pages 7-13.</p>
<p>Linfeng Song, Yue Zhang, Xiaochang Peng, Zhiguo Wang, and Daniel Gildea. 2016. Amr-to-text generation as a traveling salesman problem. In Proceedings of EMNLP, pages 2084-2089.</p>
<p>Linfeng Song, Yue Zhang, Zhiguo Wang, and Daniel Gildea. 2018. A graph-to-sequence model for AMR-to-text generation. In Proceedings of ACL, pages 1616-1626.</p>
<p>Kai Sheng Tai, Richard Socher, and Christopher D. Manning. 2015. Improved semantic representations from tree-structured long short-term memory networks. In Proceedings of ACL, pages 1556-1566.</p>
<p>Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N.Gomez, Lukasz Kaiser, and Illia Polosukhin. 2017. Attention is all you need. In Proceedings of NIPS, pages 59986008.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{3}$ Length ratio is the length of generation output, divided by the length of reference.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>