<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-6455 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-6455</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-6455</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-127.html">extraction-schema-127</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents that employ a memory mechanism to solve tasks, including details of the memory type, how it is accessed or updated, the tasks/benchmarks evaluated, performance with and without the memory, and any reported trade‑offs or limitations.</div>
                <p><strong>Paper ID:</strong> paper-f47374c67ae0d45454feb2ba354d05f0da2889d7</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/f47374c67ae0d45454feb2ba354d05f0da2889d7" target="_blank">Generalization of Reinforcement Learners with Working and Episodic Memory</a></p>
                <p><strong>Paper Venue:</strong> Neural Information Processing Systems</p>
                <p><strong>Paper TL;DR:</strong> This paper develops a comprehensive methodology to test different kinds of memory in an agent and assess how well the agent can apply what it learns in training to a holdout set that differs from the training set along dimensions that are relevant for evaluating memory-specific generalization.</p>
                <p><strong>Paper Abstract:</strong> Memory is an important aspect of intelligence and plays a role in many deep reinforcement learning models. However, little progress has been made in understanding when specific memory systems help more than others and how well they generalize. The field also has yet to see a prevalent consistent and rigorous approach for evaluating agent performance on holdout data. In this paper, we aim to develop a comprehensive methodology to test different kinds of memory in an agent and assess how well the agent can apply what it learns in training to a holdout set that differs from the training set along dimensions that we suggest are relevant for evaluating memory-specific generalization. To that end, we first construct a diverse set of memory tasks that allow us to evaluate test-time generalization across multiple dimensions. Second, we develop and perform multiple ablations on an agent architecture that combines multiple memory systems, observe its baseline models, and investigate its performance against the task suite.</p>
                <p><strong>Cost:</strong> 0.017</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e6455.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e6455.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents that employ a memory mechanism to solve tasks, including details of the memory type, how it is accessed or updated, the tasks/benchmarks evaluated, performance with and without the memory, and any reported trade‑offs or limitations.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>MRA</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Memory Recall Agent</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An RL agent combining a pixel CNN + LSTM working memory controller, a slot-based episodic key-value memory buffer, an auxiliary Contrastive Predictive Coding loss, and a 'jumpy' backpropagation scheme to enable scalable long-term credit assignment.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>Memory Recall Agent (MRA)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Pixel-input CNN -> residual encoder produces embeddings x_t; an LSTM controller (working memory) receives concatenated pixel embedding and retrieved episodic memory m_t and outputs policy/value; a slot-based episodic memory (MEM) stores triplets (p_i = pixel embedding, v_i = LSTM hidden state, k_i = cached key) in a fixed-size circular buffer; CPC auxiliary loss applied to LSTM hidden state; jumpy backpropagation with stop-gradient on stored p_i,v_i to bound computational cost.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>slot-based episodic memory (key-value circular buffer) + recurrent working memory (LSTM)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Each memory slot stores a pixel embedding p_i (x_{t_i}), the LSTM hidden state v_i (h_{t_i}), and a cached key k_i computed as a linear projection of [p_i, v_i].</td>
                        </tr>
                        <tr>
                            <td><strong>memory_access_mechanism</strong></td>
                            <td>Writes: FIFO circular buffer writes of (p_i,v_i,k_i) performed without propagating gradients into p_i/v_i (stop-gradient). Keys k_i = W_k[ p_i, v_i ] + b_k are cached. Reads: compute query q_t = W_q[x_t, h_{t-1}] + b_q, find K nearest neighbors in MEM by L2 distance between q_t and stored keys (recomputed for nearest neighbors via W_k,b_k), aggregate retrieved values m_t = sum_j w_j v_j with weights w_j proportional to inverse (epsilon + ||q_t - k_j||^2).</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Memory Tasks Suite (13 tasks) including PsychLab tasks: Arbitrary Visuomotor Mapping, Continuous Recognition, Change Detection, What Then Where; Spot the Difference family (Basic, Passive, Multi-Object, Motion); Goal Navigation family (Visible/Invisible with/without buildings, Procedural Maze); Transitive Inference.</td>
                        </tr>
                        <tr>
                            <td><strong>task_category</strong></td>
                            <td>Reinforcement learning memory benchmarks (episodic & working memory evaluation)</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>Qualitative: MRA (LSTM + MEM + CPC) broadly outperformed other ablations across the suite; adding MEM improved scores on 9 tasks in training and on 6 tasks in each holdout level; MRA achieved superhuman normalized scores on Visible Goal Procedural Maze and on Transitive Inference (training and holdout) and was the top-ranked model by average human-normalized score. Exact numeric scores are reported in the paper's appendices (human-normalized scores).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td>Qualitative: LSTM-only (IMPALA) and FF baselines without the slot MEM achieved lower average human-normalized scores; on several tasks (e.g., AVM, Continuous Recognition, many Spot-the-Difference variants and Goal Navigation variants) adding MEM to controller improved training and holdout performance; however on a few tasks (notably 'What Then Where' and some hard Spot-the-Difference variants) MEM did not improve and could hurt relative to LSTM-only.</td>
                        </tr>
                        <tr>
                            <td><strong>has_comparative_results</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td>Human-normalized score (averaged across tasks) plus task-specific metrics (accuracy for PsychLab tasks, success rate/time-to-goal for navigation tasks); detailed curves and normalized-scores in appendices.</td>
                        </tr>
                        <tr>
                            <td><strong>tradeoffs_reported</strong></td>
                            <td>Jumpy backpropagation (stop-gradient on stored p_i,v_i) trades full credit assignment for tractable computation and memory: it bounds computational complexity but prevents gradients from flowing through intermediate timesteps to writes. Keys cached can become stale as W_k,b_k are learned (authors observed no adverse effect). Episodic MEM is per-episode and is wiped at episode end (limits cross-episode retention). Using MEM + CPC increases complexity (indexing/nearest-neighbor) but yields better generalization; computational overhead is modest since keys recomputed only for nearest neighbors.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>On What Then Where the LSTM-only baseline outperformed MEM-augmented models (auxiliary reconstruction loss actually hurt). Spot the Difference: Multi-Object and Spot the Difference: Motion were very challenging and MEM alone often had minimal or negative effect; combining MEM with CPC sometimes was synergistic but still failed to generalize on hardest extrapolation levels. Change Detection: adding MEM to a FF controller hurt slightly. None of the models fully generalize on the hardest holdout-extrapolate levels and performance degrades with task difficulty.</td>
                        </tr>
                        <tr>
                            <td><strong>citation</strong></td>
                            <td>Ryan Faulkner, Steven Hansen, Adrià Puigdomènech Badia, Gavin Buttimore, Charlie Deck, Joel Z Leibo, Charles Blundell. Generalization of Reinforcement Learners with Working and Episodic Memory. DeepMind.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Generalization of Reinforcement Learners with Working and Episodic Memory', 'publication_date_yy_mm': '2019-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6455.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e6455.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents that employ a memory mechanism to solve tasks, including details of the memory type, how it is accessed or updated, the tasks/benchmarks evaluated, performance with and without the memory, and any reported trade‑offs or limitations.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>IMPALA (LSTM-only)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>IMPALA baseline with LSTM controller</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>The IMPALA distributed RL architecture used as a strong baseline here, implemented with an LSTM controller that provides working memory via recurrent hidden state (this is the LSTM-only condition in ablations).</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>IMPALA: scalable distributed deep-rl with importance weighted actor-learner architectures</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>IMPALA (LSTM-only baseline)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Pixel encoder feeding an LSTM controller which produces policy and value heads; trained with IMPALA distributed actor-learner scheme and truncated BPTT for the recurrent controller.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>working memory (recurrent LSTM)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>LSTM hidden state vectors h_t serve as short-term working memory.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_access_mechanism</strong></td>
                            <td>Internal recurrence: hidden state updated each step with input and previous hidden state; trained with truncated backpropagation-through-time.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Memory Tasks Suite (same suite as MRA)</td>
                        </tr>
                        <tr>
                            <td><strong>task_category</strong></td>
                            <td>Reinforcement learning memory benchmarks (working memory evaluation)</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>Serves as baseline; performed strongly on some tasks (notably it outperformed MEM-augmented models on 'What Then Where'); overall typically lower average human-normalized score than MRA (LSTM + MEM + CPC).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td>N/A (this entry is the working-memory-only baseline). Compared to FF (no recurrence) the LSTM baseline often performed better on tasks requiring short-term computation.</td>
                        </tr>
                        <tr>
                            <td><strong>has_comparative_results</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td>Human-normalized score; task-specific accuracy or success-rate metrics</td>
                        </tr>
                        <tr>
                            <td><strong>tradeoffs_reported</strong></td>
                            <td>Recurrent working memory (LSTM) is limited by truncated BPTT, susceptible to vanishing/exploding gradients and struggles with very long-term dependencies; less reliable for long-term storage compared to slot-based episodic memory.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Limited ability to represent variables over long time spans; performs worse than MEM-augmented agents on tasks that require retrieval of specific earlier observations (e.g., AVM, Continuous Recognition, some Spot-the-Difference and Transitive Inference cases).</td>
                        </tr>
                        <tr>
                            <td><strong>citation</strong></td>
                            <td>Espeholt et al., 2018. IMPALA: scalable distributed deep-rl with importance weighted actor-learner architectures.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Generalization of Reinforcement Learners with Working and Episodic Memory', 'publication_date_yy_mm': '2019-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6455.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e6455.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents that employ a memory mechanism to solve tasks, including details of the memory type, how it is accessed or updated, the tasks/benchmarks evaluated, performance with and without the memory, and any reported trade‑offs or limitations.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>FF baseline</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Feedforward controller baseline (no recurrence)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A feedforward (non-recurrent) controller used as an ablation to evaluate the role of working memory; relies on episodic memory or auxiliary losses to provide temporal/contextual information.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>Feedforward (FF) controller baseline</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Pixel encoder followed by a feedforward controller (no recurrent hidden state). When combined with MEM or auxiliary losses, FF can sometimes approach LSTM performance; otherwise lacks internal working memory.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>none (relies on external episodic MEM when combined)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_access_mechanism</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Memory Tasks Suite (same suite)</td>
                        </tr>
                        <tr>
                            <td><strong>task_category</strong></td>
                            <td>Reinforcement learning memory benchmarks (control ablation)</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>When augmented with MEM + CPC or MEM + REC, FF controller improved significantly on several tasks (e.g., Transitive Inference with MEM + CPC/REC); however, FF+MEM sometimes benefited less than LSTM+MEM.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td>As pure FF (no MEM), performance was substantially worse on tasks requiring memory; many tasks required either recurrence or external MEM to solve.</td>
                        </tr>
                        <tr>
                            <td><strong>has_comparative_results</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td>Human-normalized score; task-specific accuracy/success metrics</td>
                        </tr>
                        <tr>
                            <td><strong>tradeoffs_reported</strong></td>
                            <td>FF is simpler and cheaper but lacks temporal state; depends heavily on external episodic memory or auxiliary representation losses to solve temporal tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Cannot perform tasks requiring short-term temporal integration unless augmented with MEM or strong auxiliary losses; on some PsychLab tasks MEM helped only when combined with auxiliary loss for FF.</td>
                        </tr>
                        <tr>
                            <td><strong>citation</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Generalization of Reinforcement Learners with Working and Episodic Memory', 'publication_date_yy_mm': '2019-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6455.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e6455.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents that employ a memory mechanism to solve tasks, including details of the memory type, how it is accessed or updated, the tasks/benchmarks evaluated, performance with and without the memory, and any reported trade‑offs or limitations.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>MEM (slot-based episodic memory)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Slot-based Episodic Memory module (MEM)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A fixed-size circular key-value buffer that caches pixel embeddings and LSTM hidden states as values with cached keys for nearest-neighbor retrieval, used to provide long-term episodic recall to the controller.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>Episodic Memory module (MEM)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Stores triplets (p_i, v_i, k_i) where p_i is pixel embedding, v_i is LSTM hidden state at write time, and k_i is a cached key computed via a learned linear projection; writes are FIFO and non-differentiable (stop-gradient), reads are nearest-neighbor retrieval by L2 distance in key space and weighted aggregation of stored v_j.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>external slot-based episodic memory (key-value buffer)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Token: (pixel embedding p_i, controller hidden state v_i, cached key k_i).</td>
                        </tr>
                        <tr>
                            <td><strong>memory_access_mechanism</strong></td>
                            <td>Nearest-neighbor retrieval (K-NN) by L2 distance between query q_t and stored keys; weighted aggregation of retrieved values; writes overwrite oldest slot when full; stop-gradient applied to stored p_i,v_i at write time (jumpy backpropagation).</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Used across Memory Tasks Suite (improves AVM, Continuous Recognition, many Spot-the-Difference and Goal Navigation variants, Transitive Inference)</td>
                        </tr>
                        <tr>
                            <td><strong>task_category</strong></td>
                            <td>Episodic recall / retrieval for RL tasks</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>Adding MEM improved scores on nine tasks in training and on six tasks in each holdout level; significantly boosted holdout performance for Transitive Inference, AVM, and Continuous Recognition.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td>Without MEM, many controllers (especially FF) performed worse on tasks requiring recall of specific past observations; LSTM-only could solve some short-term tasks but underperformed on tasks requiring explicit episodic recall.</td>
                        </tr>
                        <tr>
                            <td><strong>has_comparative_results</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td>Human-normalized score; task-specific accuracy/success-rate</td>
                        </tr>
                        <tr>
                            <td><strong>tradeoffs_reported</strong></td>
                            <td>Writes performed without gradients bound computational cost but limit end-to-end credit assignment; keys cached may become stale as key-projection parameters change, although this was not observed to harm performance in experiments; episodic buffer cleared each episode (no across-episode retention).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>MEM alone sometimes had little or negative effect (e.g., Spot-the-Difference: Multi-Object, Change Detection for FF); required pairing with auxiliary losses (CPC/REC) and/or LSTM to obtain best generalization on many tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>citation</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Generalization of Reinforcement Learners with Working and Episodic Memory', 'publication_date_yy_mm': '2019-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6455.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e6455.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents that employ a memory mechanism to solve tasks, including details of the memory type, how it is accessed or updated, the tasks/benchmarks evaluated, performance with and without the memory, and any reported trade‑offs or limitations.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>NEC</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Neural Episodic Control</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A previously proposed RL approach that uses a differentiable episodic memory / table for fast value estimation; referenced as related work and as an example of episodic memory architectures.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Neural episodic control</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>Neural Episodic Control (NEC)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>High-level: nonparametric episodic memory for value estimates based on nearest-neighbor lookups (mentioned as related work). Not used in experiments in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>nonparametric episodic memory / table with nearest-neighbor lookup</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Stored state embeddings and associated value estimates.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_access_mechanism</strong></td>
                            <td>Nearest-neighbor lookup / kernel regression over stored embeddings (as in Pritzel et al., 2017).</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_category</strong></td>
                            <td>mention (related episodic-memory RL methods)</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_comparative_results</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>tradeoffs_reported</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>citation</strong></td>
                            <td>Pritzel et al., Neural episodic control (2017)</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Generalization of Reinforcement Learners with Working and Episodic Memory', 'publication_date_yy_mm': '2019-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6455.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e6455.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents that employ a memory mechanism to solve tasks, including details of the memory type, how it is accessed or updated, the tasks/benchmarks evaluated, performance with and without the memory, and any reported trade‑offs or limitations.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>DNC</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Differentiable Neural Computer</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A neural network with a differentiable external memory (DNC) enabling algorithmic tasks and long-term storage; cited as an example of external-memory architectures in related work.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Hybrid computing using a neural network with dynamic external memory</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>Differentiable Neural Computer (DNC)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Network augmented with differentiable read/write memory capable of learning data-structure-like algorithms (cited as background related work). Not used in experiments here.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>differentiable external memory (addressable memory matrix)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Memory matrix of vectors with learned addressing weights.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_access_mechanism</strong></td>
                            <td>Differentiable read/write heads with attention-like addressing; full backprop through memory writes (unlike MRA's stop-gradient writes).</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_category</strong></td>
                            <td>mention (related external-memory architectures)</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_comparative_results</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>tradeoffs_reported</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>citation</strong></td>
                            <td>Graves et al., Hybrid computing using a neural network with dynamic external memory (2016)</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Generalization of Reinforcement Learners with Working and Episodic Memory', 'publication_date_yy_mm': '2019-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6455.6">
                <h3 class="extraction-instance">Extracted Data Instance 6 (e6455.6)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents that employ a memory mechanism to solve tasks, including details of the memory type, how it is accessed or updated, the tasks/benchmarks evaluated, performance with and without the memory, and any reported trade‑offs or limitations.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>SAB</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Sparse Attentive Backtracking</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A method that passes gradients only through selected past memories (sparse replay) to enable temporal credit assignment; referenced as conceptually related to the paper's jumpy backpropagation idea.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Sparse attentive backtracking: Temporal creditassignment through reminding</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>Sparse Attentive Backtracking (SAB)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Maintains sparse replay/backpropagation through selected past states to assign long-term credit (mentioned as related prior work).</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>sparse replay memory / selected past-state backprop</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Stored past activations used for sparse gradient propagation.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_access_mechanism</strong></td>
                            <td>Selectively pass gradients through memories chosen as relevant (sparse attentive mechanism).</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_category</strong></td>
                            <td>mention (related long-term credit assignment methods)</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_comparative_results</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>tradeoffs_reported</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>citation</strong></td>
                            <td>Ke et al., Sparse attentive backtracking (2018)</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Generalization of Reinforcement Learners with Working and Episodic Memory', 'publication_date_yy_mm': '2019-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Hybrid computing using a neural network with dynamic external memory <em>(Rating: 2)</em></li>
                <li>Neural episodic control <em>(Rating: 2)</em></li>
                <li>Sparse attentive backtracking: Temporal creditassignment through reminding <em>(Rating: 2)</em></li>
                <li>Model-free episodic control <em>(Rating: 2)</em></li>
                <li>Been there, done that: Meta-learning with episodic recall <em>(Rating: 2)</em></li>
                <li>Representation learning with contrastive predictive coding <em>(Rating: 1)</em></li>
                <li>IMPALA: scalable distributed deep-rl with importance weighted actor-learner architectures <em>(Rating: 2)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-6455",
    "paper_id": "paper-f47374c67ae0d45454feb2ba354d05f0da2889d7",
    "extraction_schema_id": "extraction-schema-127",
    "extracted_data": [
        {
            "name_short": "MRA",
            "name_full": "Memory Recall Agent",
            "brief_description": "An RL agent combining a pixel CNN + LSTM working memory controller, a slot-based episodic key-value memory buffer, an auxiliary Contrastive Predictive Coding loss, and a 'jumpy' backpropagation scheme to enable scalable long-term credit assignment.",
            "citation_title": "here",
            "mention_or_use": "use",
            "agent_name": "Memory Recall Agent (MRA)",
            "agent_description": "Pixel-input CNN -&gt; residual encoder produces embeddings x_t; an LSTM controller (working memory) receives concatenated pixel embedding and retrieved episodic memory m_t and outputs policy/value; a slot-based episodic memory (MEM) stores triplets (p_i = pixel embedding, v_i = LSTM hidden state, k_i = cached key) in a fixed-size circular buffer; CPC auxiliary loss applied to LSTM hidden state; jumpy backpropagation with stop-gradient on stored p_i,v_i to bound computational cost.",
            "model_size": null,
            "memory_used": true,
            "memory_type": "slot-based episodic memory (key-value circular buffer) + recurrent working memory (LSTM)",
            "memory_representation": "Each memory slot stores a pixel embedding p_i (x_{t_i}), the LSTM hidden state v_i (h_{t_i}), and a cached key k_i computed as a linear projection of [p_i, v_i].",
            "memory_access_mechanism": "Writes: FIFO circular buffer writes of (p_i,v_i,k_i) performed without propagating gradients into p_i/v_i (stop-gradient). Keys k_i = W_k[ p_i, v_i ] + b_k are cached. Reads: compute query q_t = W_q[x_t, h_{t-1}] + b_q, find K nearest neighbors in MEM by L2 distance between q_t and stored keys (recomputed for nearest neighbors via W_k,b_k), aggregate retrieved values m_t = sum_j w_j v_j with weights w_j proportional to inverse (epsilon + ||q_t - k_j||^2).",
            "task_name": "Memory Tasks Suite (13 tasks) including PsychLab tasks: Arbitrary Visuomotor Mapping, Continuous Recognition, Change Detection, What Then Where; Spot the Difference family (Basic, Passive, Multi-Object, Motion); Goal Navigation family (Visible/Invisible with/without buildings, Procedural Maze); Transitive Inference.",
            "task_category": "Reinforcement learning memory benchmarks (episodic & working memory evaluation)",
            "performance_with_memory": "Qualitative: MRA (LSTM + MEM + CPC) broadly outperformed other ablations across the suite; adding MEM improved scores on 9 tasks in training and on 6 tasks in each holdout level; MRA achieved superhuman normalized scores on Visible Goal Procedural Maze and on Transitive Inference (training and holdout) and was the top-ranked model by average human-normalized score. Exact numeric scores are reported in the paper's appendices (human-normalized scores).",
            "performance_without_memory": "Qualitative: LSTM-only (IMPALA) and FF baselines without the slot MEM achieved lower average human-normalized scores; on several tasks (e.g., AVM, Continuous Recognition, many Spot-the-Difference variants and Goal Navigation variants) adding MEM to controller improved training and holdout performance; however on a few tasks (notably 'What Then Where' and some hard Spot-the-Difference variants) MEM did not improve and could hurt relative to LSTM-only.",
            "has_comparative_results": true,
            "performance_metric": "Human-normalized score (averaged across tasks) plus task-specific metrics (accuracy for PsychLab tasks, success rate/time-to-goal for navigation tasks); detailed curves and normalized-scores in appendices.",
            "tradeoffs_reported": "Jumpy backpropagation (stop-gradient on stored p_i,v_i) trades full credit assignment for tractable computation and memory: it bounds computational complexity but prevents gradients from flowing through intermediate timesteps to writes. Keys cached can become stale as W_k,b_k are learned (authors observed no adverse effect). Episodic MEM is per-episode and is wiped at episode end (limits cross-episode retention). Using MEM + CPC increases complexity (indexing/nearest-neighbor) but yields better generalization; computational overhead is modest since keys recomputed only for nearest neighbors.",
            "limitations_or_failure_cases": "On What Then Where the LSTM-only baseline outperformed MEM-augmented models (auxiliary reconstruction loss actually hurt). Spot the Difference: Multi-Object and Spot the Difference: Motion were very challenging and MEM alone often had minimal or negative effect; combining MEM with CPC sometimes was synergistic but still failed to generalize on hardest extrapolation levels. Change Detection: adding MEM to a FF controller hurt slightly. None of the models fully generalize on the hardest holdout-extrapolate levels and performance degrades with task difficulty.",
            "citation": "Ryan Faulkner, Steven Hansen, Adrià Puigdomènech Badia, Gavin Buttimore, Charlie Deck, Joel Z Leibo, Charles Blundell. Generalization of Reinforcement Learners with Working and Episodic Memory. DeepMind.",
            "uuid": "e6455.0",
            "source_info": {
                "paper_title": "Generalization of Reinforcement Learners with Working and Episodic Memory",
                "publication_date_yy_mm": "2019-10"
            }
        },
        {
            "name_short": "IMPALA (LSTM-only)",
            "name_full": "IMPALA baseline with LSTM controller",
            "brief_description": "The IMPALA distributed RL architecture used as a strong baseline here, implemented with an LSTM controller that provides working memory via recurrent hidden state (this is the LSTM-only condition in ablations).",
            "citation_title": "IMPALA: scalable distributed deep-rl with importance weighted actor-learner architectures",
            "mention_or_use": "use",
            "agent_name": "IMPALA (LSTM-only baseline)",
            "agent_description": "Pixel encoder feeding an LSTM controller which produces policy and value heads; trained with IMPALA distributed actor-learner scheme and truncated BPTT for the recurrent controller.",
            "model_size": null,
            "memory_used": true,
            "memory_type": "working memory (recurrent LSTM)",
            "memory_representation": "LSTM hidden state vectors h_t serve as short-term working memory.",
            "memory_access_mechanism": "Internal recurrence: hidden state updated each step with input and previous hidden state; trained with truncated backpropagation-through-time.",
            "task_name": "Memory Tasks Suite (same suite as MRA)",
            "task_category": "Reinforcement learning memory benchmarks (working memory evaluation)",
            "performance_with_memory": "Serves as baseline; performed strongly on some tasks (notably it outperformed MEM-augmented models on 'What Then Where'); overall typically lower average human-normalized score than MRA (LSTM + MEM + CPC).",
            "performance_without_memory": "N/A (this entry is the working-memory-only baseline). Compared to FF (no recurrence) the LSTM baseline often performed better on tasks requiring short-term computation.",
            "has_comparative_results": true,
            "performance_metric": "Human-normalized score; task-specific accuracy or success-rate metrics",
            "tradeoffs_reported": "Recurrent working memory (LSTM) is limited by truncated BPTT, susceptible to vanishing/exploding gradients and struggles with very long-term dependencies; less reliable for long-term storage compared to slot-based episodic memory.",
            "limitations_or_failure_cases": "Limited ability to represent variables over long time spans; performs worse than MEM-augmented agents on tasks that require retrieval of specific earlier observations (e.g., AVM, Continuous Recognition, some Spot-the-Difference and Transitive Inference cases).",
            "citation": "Espeholt et al., 2018. IMPALA: scalable distributed deep-rl with importance weighted actor-learner architectures.",
            "uuid": "e6455.1",
            "source_info": {
                "paper_title": "Generalization of Reinforcement Learners with Working and Episodic Memory",
                "publication_date_yy_mm": "2019-10"
            }
        },
        {
            "name_short": "FF baseline",
            "name_full": "Feedforward controller baseline (no recurrence)",
            "brief_description": "A feedforward (non-recurrent) controller used as an ablation to evaluate the role of working memory; relies on episodic memory or auxiliary losses to provide temporal/contextual information.",
            "citation_title": "",
            "mention_or_use": "use",
            "agent_name": "Feedforward (FF) controller baseline",
            "agent_description": "Pixel encoder followed by a feedforward controller (no recurrent hidden state). When combined with MEM or auxiliary losses, FF can sometimes approach LSTM performance; otherwise lacks internal working memory.",
            "model_size": null,
            "memory_used": false,
            "memory_type": "none (relies on external episodic MEM when combined)",
            "memory_representation": null,
            "memory_access_mechanism": null,
            "task_name": "Memory Tasks Suite (same suite)",
            "task_category": "Reinforcement learning memory benchmarks (control ablation)",
            "performance_with_memory": "When augmented with MEM + CPC or MEM + REC, FF controller improved significantly on several tasks (e.g., Transitive Inference with MEM + CPC/REC); however, FF+MEM sometimes benefited less than LSTM+MEM.",
            "performance_without_memory": "As pure FF (no MEM), performance was substantially worse on tasks requiring memory; many tasks required either recurrence or external MEM to solve.",
            "has_comparative_results": true,
            "performance_metric": "Human-normalized score; task-specific accuracy/success metrics",
            "tradeoffs_reported": "FF is simpler and cheaper but lacks temporal state; depends heavily on external episodic memory or auxiliary representation losses to solve temporal tasks.",
            "limitations_or_failure_cases": "Cannot perform tasks requiring short-term temporal integration unless augmented with MEM or strong auxiliary losses; on some PsychLab tasks MEM helped only when combined with auxiliary loss for FF.",
            "citation": "",
            "uuid": "e6455.2",
            "source_info": {
                "paper_title": "Generalization of Reinforcement Learners with Working and Episodic Memory",
                "publication_date_yy_mm": "2019-10"
            }
        },
        {
            "name_short": "MEM (slot-based episodic memory)",
            "name_full": "Slot-based Episodic Memory module (MEM)",
            "brief_description": "A fixed-size circular key-value buffer that caches pixel embeddings and LSTM hidden states as values with cached keys for nearest-neighbor retrieval, used to provide long-term episodic recall to the controller.",
            "citation_title": "",
            "mention_or_use": "use",
            "agent_name": "Episodic Memory module (MEM)",
            "agent_description": "Stores triplets (p_i, v_i, k_i) where p_i is pixel embedding, v_i is LSTM hidden state at write time, and k_i is a cached key computed via a learned linear projection; writes are FIFO and non-differentiable (stop-gradient), reads are nearest-neighbor retrieval by L2 distance in key space and weighted aggregation of stored v_j.",
            "model_size": null,
            "memory_used": true,
            "memory_type": "external slot-based episodic memory (key-value buffer)",
            "memory_representation": "Token: (pixel embedding p_i, controller hidden state v_i, cached key k_i).",
            "memory_access_mechanism": "Nearest-neighbor retrieval (K-NN) by L2 distance between query q_t and stored keys; weighted aggregation of retrieved values; writes overwrite oldest slot when full; stop-gradient applied to stored p_i,v_i at write time (jumpy backpropagation).",
            "task_name": "Used across Memory Tasks Suite (improves AVM, Continuous Recognition, many Spot-the-Difference and Goal Navigation variants, Transitive Inference)",
            "task_category": "Episodic recall / retrieval for RL tasks",
            "performance_with_memory": "Adding MEM improved scores on nine tasks in training and on six tasks in each holdout level; significantly boosted holdout performance for Transitive Inference, AVM, and Continuous Recognition.",
            "performance_without_memory": "Without MEM, many controllers (especially FF) performed worse on tasks requiring recall of specific past observations; LSTM-only could solve some short-term tasks but underperformed on tasks requiring explicit episodic recall.",
            "has_comparative_results": true,
            "performance_metric": "Human-normalized score; task-specific accuracy/success-rate",
            "tradeoffs_reported": "Writes performed without gradients bound computational cost but limit end-to-end credit assignment; keys cached may become stale as key-projection parameters change, although this was not observed to harm performance in experiments; episodic buffer cleared each episode (no across-episode retention).",
            "limitations_or_failure_cases": "MEM alone sometimes had little or negative effect (e.g., Spot-the-Difference: Multi-Object, Change Detection for FF); required pairing with auxiliary losses (CPC/REC) and/or LSTM to obtain best generalization on many tasks.",
            "citation": "",
            "uuid": "e6455.3",
            "source_info": {
                "paper_title": "Generalization of Reinforcement Learners with Working and Episodic Memory",
                "publication_date_yy_mm": "2019-10"
            }
        },
        {
            "name_short": "NEC",
            "name_full": "Neural Episodic Control",
            "brief_description": "A previously proposed RL approach that uses a differentiable episodic memory / table for fast value estimation; referenced as related work and as an example of episodic memory architectures.",
            "citation_title": "Neural episodic control",
            "mention_or_use": "mention",
            "agent_name": "Neural Episodic Control (NEC)",
            "agent_description": "High-level: nonparametric episodic memory for value estimates based on nearest-neighbor lookups (mentioned as related work). Not used in experiments in this paper.",
            "model_size": null,
            "memory_used": true,
            "memory_type": "nonparametric episodic memory / table with nearest-neighbor lookup",
            "memory_representation": "Stored state embeddings and associated value estimates.",
            "memory_access_mechanism": "Nearest-neighbor lookup / kernel regression over stored embeddings (as in Pritzel et al., 2017).",
            "task_name": null,
            "task_category": "mention (related episodic-memory RL methods)",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_comparative_results": false,
            "performance_metric": null,
            "tradeoffs_reported": null,
            "limitations_or_failure_cases": null,
            "citation": "Pritzel et al., Neural episodic control (2017)",
            "uuid": "e6455.4",
            "source_info": {
                "paper_title": "Generalization of Reinforcement Learners with Working and Episodic Memory",
                "publication_date_yy_mm": "2019-10"
            }
        },
        {
            "name_short": "DNC",
            "name_full": "Differentiable Neural Computer",
            "brief_description": "A neural network with a differentiable external memory (DNC) enabling algorithmic tasks and long-term storage; cited as an example of external-memory architectures in related work.",
            "citation_title": "Hybrid computing using a neural network with dynamic external memory",
            "mention_or_use": "mention",
            "agent_name": "Differentiable Neural Computer (DNC)",
            "agent_description": "Network augmented with differentiable read/write memory capable of learning data-structure-like algorithms (cited as background related work). Not used in experiments here.",
            "model_size": null,
            "memory_used": true,
            "memory_type": "differentiable external memory (addressable memory matrix)",
            "memory_representation": "Memory matrix of vectors with learned addressing weights.",
            "memory_access_mechanism": "Differentiable read/write heads with attention-like addressing; full backprop through memory writes (unlike MRA's stop-gradient writes).",
            "task_name": null,
            "task_category": "mention (related external-memory architectures)",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_comparative_results": false,
            "performance_metric": null,
            "tradeoffs_reported": null,
            "limitations_or_failure_cases": null,
            "citation": "Graves et al., Hybrid computing using a neural network with dynamic external memory (2016)",
            "uuid": "e6455.5",
            "source_info": {
                "paper_title": "Generalization of Reinforcement Learners with Working and Episodic Memory",
                "publication_date_yy_mm": "2019-10"
            }
        },
        {
            "name_short": "SAB",
            "name_full": "Sparse Attentive Backtracking",
            "brief_description": "A method that passes gradients only through selected past memories (sparse replay) to enable temporal credit assignment; referenced as conceptually related to the paper's jumpy backpropagation idea.",
            "citation_title": "Sparse attentive backtracking: Temporal creditassignment through reminding",
            "mention_or_use": "mention",
            "agent_name": "Sparse Attentive Backtracking (SAB)",
            "agent_description": "Maintains sparse replay/backpropagation through selected past states to assign long-term credit (mentioned as related prior work).",
            "model_size": null,
            "memory_used": true,
            "memory_type": "sparse replay memory / selected past-state backprop",
            "memory_representation": "Stored past activations used for sparse gradient propagation.",
            "memory_access_mechanism": "Selectively pass gradients through memories chosen as relevant (sparse attentive mechanism).",
            "task_name": null,
            "task_category": "mention (related long-term credit assignment methods)",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_comparative_results": false,
            "performance_metric": null,
            "tradeoffs_reported": null,
            "limitations_or_failure_cases": null,
            "citation": "Ke et al., Sparse attentive backtracking (2018)",
            "uuid": "e6455.6",
            "source_info": {
                "paper_title": "Generalization of Reinforcement Learners with Working and Episodic Memory",
                "publication_date_yy_mm": "2019-10"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Hybrid computing using a neural network with dynamic external memory",
            "rating": 2,
            "sanitized_title": "hybrid_computing_using_a_neural_network_with_dynamic_external_memory"
        },
        {
            "paper_title": "Neural episodic control",
            "rating": 2,
            "sanitized_title": "neural_episodic_control"
        },
        {
            "paper_title": "Sparse attentive backtracking: Temporal creditassignment through reminding",
            "rating": 2,
            "sanitized_title": "sparse_attentive_backtracking_temporal_creditassignment_through_reminding"
        },
        {
            "paper_title": "Model-free episodic control",
            "rating": 2,
            "sanitized_title": "modelfree_episodic_control"
        },
        {
            "paper_title": "Been there, done that: Meta-learning with episodic recall",
            "rating": 2,
            "sanitized_title": "been_there_done_that_metalearning_with_episodic_recall"
        },
        {
            "paper_title": "Representation learning with contrastive predictive coding",
            "rating": 1,
            "sanitized_title": "representation_learning_with_contrastive_predictive_coding"
        },
        {
            "paper_title": "IMPALA: scalable distributed deep-rl with importance weighted actor-learner architectures",
            "rating": 2,
            "sanitized_title": "impala_scalable_distributed_deeprl_with_importance_weighted_actorlearner_architectures"
        }
    ],
    "cost": 0.01709275,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Generalization of Reinforcement Learners with Working and Episodic Memory</h1>
<p>$\square$<br>Ryan Faulkner<em> Steven Hansen</em> Adrià Puigdomènech Badia Gavin Buttimore Charlie Deck Joel Z Leibo Charles Blundell<br>DeepMind<br>{meirefortunato, melissatan, rfaulk, stevenhansen, adriap, buttimore, cdeck, jzl, cblundell}@google.com<br>(* Equal Contribution)</p>
<h4>Abstract</h4>
<p>Memory is an important aspect of intelligence and plays a role in many deep reinforcement learning models. However, little progress has been made in understanding when specific memory systems help more than others and how well they generalize. The field also has yet to see a prevalent consistent and rigorous approach for evaluating agent performance on holdout data. In this paper, we aim to develop a comprehensive methodology to test different kinds of memory in an agent and assess how well the agent can apply what it learns in training to a holdout set that differs from the training set along dimensions that we suggest are relevant for evaluating memory-specific generalization. To that end, we first construct a diverse set of memory tasks ${ }^{1}$ that allow us to evaluate test-time generalization across multiple dimensions. Second, we develop and perform multiple ablations on an agent architecture that combines multiple memory systems, observe its baseline models, and investigate its performance against the task suite.</p>
<h2>1 Introduction</h2>
<p>Humans use memory to reason, imagine, plan, and learn. Memory is a foundational component of intelligence, and enables information from past events and contexts to inform decision-making in the present and future. Recently, agents that utilize memory systems have advanced the state of the art in various research areas including reasoning, planning, program execution and navigation, among others (Graves et al., 2016; Zambaldi et al., 2018; Santoro et al., 2018; Banino et al., 2018; Vaswani et al., 2017; Sukhbaatar et al., 2015).</p>
<p>Memory has many aspects, and having access to different kinds allows intelligent organisms to bring the most relevant past information to bear on different sets of circumstances. In cognitive psychology and neuroscience, two commonly studied types of memory are working and episodic memory. Working memory (Miyake and Shah, 1999) is a short-term temporary store with limited capacity.</p>
<p>In contrast, episodic memory (Tulving and Murray, 1985) is typically a larger autobiographical database of experience (e.g. recalling a meal eaten last month) that lets one store information over a longer time scale and compile sequences of events into episodes (Tulving, 2002). Episodic memory has been shown to help reinforcement learning agents adapt more quickly and thereby boost data</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>efficiency (Blundell et al., 2016; Pritzel et al., 2017; Hansen et al., 2018). More recently, Ritter et al. (2018) shows how episodic memory can be used to provide agents with context-switching abilities in contextual bandit problems. The transformer (Vaswani et al., 2017) can be viewed as a hybrid of working memory and episodic memory that has been successfully applied to many supervised learning problems.
In this work, we explore adding such memory systems to agents and propose a consistent and rigorous approach for evaluating whether an agent demonstrates generalization-enabling memory capabilities similar to those seen in animals and humans.
One fundamental principle in machine learning is to train on one set of data and test on an unseen holdout set, but it has to date been common in reinforcement learning to evaluate agent performance solely on the training set which is suboptimal for testing generalization (Pineau, 2018). Also, though advances have recently been made on evaluating generalization in reinforcement learning (Cobbe et al., 2018) these have not been specific to memory.
Our approach is to construct a train-holdout split where the holdout set differs from the training set along axes that we propose are relevant specifically to memory, i.e. the scale of the task and precise objects used in the task environments. For instance, if an agent learns in training to travel to an apple placed in a room, altering the room size or apple color as part of a generalization test should ideally not throw it off.
We propose a set of environments that possess such a split and test different aspects of working and episodic memory, to help us better understand when different kinds of memory systems are most helpful and identify memory architectures in agents with memory abilities that cognitive scientists and psychologists have observed in humans.
Alongside these tasks, we develop a benchmark memory-based agent, the Memory Recall Agent (MRA), that brings together previously developed systems thought to mimic working memory and episodic memory. This combination of a controller that models working memory, an external episodic memory, and an architecture that encourages long-term representational credit assignment via an auxiliary unsupervised loss and backpropagation through time that can 'jump' over several time-steps obtains better performance than baselines across the suite. In particular, episodic memory and learning good representations both prove crucial and in some cases stack synergistically.
To summarize, our contribution is to:</p>
<ul>
<li>Introduce a suite of tasks that require an agent to utilize fundamental functional properties of memory in order to solve in a way that generalizes to holdout data.</li>
<li>Develop an agent architecture that explicitly models the operation of memory by integrating components that functionally mimic humans' episodic and working memory.</li>
<li>Show that different components of our agent's memory have different effectiveness in training and in generalizing to holdout sets.</li>
<li>Show that none of the models fully generalize outside of the train set on the more challenging tasks, and that the extrapolation incurs a greater level of degradation.</li>
</ul>
<h1>2 Task suite overview</h1>
<p>We define a suite of 13 tasks designed to test different aspects of memory, with train-test splits that test for generalization across multiple dimensions (https://github.com/deepmind/dm _memorytasks). These include cognitive psychology tasks adapted from PsychLab (Leibo et al., 2018) and DMLab (Beattie et al., 2016), and new tasks built with the Unity 3D game engine (uni) that require the agent to 1) spot the difference between two scenes; 2) remember the location of a goal and navigate to it; or 3) infer an indirect transitive relation between objects. Videos with task descriptions are at https://sites.google.com/view/memory-tasks-suite.</p>
<h3>2.1 PsychLab</h3>
<p>Four tasks in the Memory Tasks Suite use the PsychLab environment (Leibo et al., 2018), which simulates a psychology laboratory in first-person. The agent is presented with a set of one or multiple consecutive images, where each set is called a 'trial'. Each episode has multiple trials.</p>
<p>In Arbitrary Visuomotor Mapping (AVM) a series of objects is presented, each with an associated look-direction (e.g. up,left). The agent is rewarded if it looks in the associated direction the next time it sees a given object in the episode (Fig 8(a) in App. B). Continuous Recognition presents a series of images with rewards given for correctly indicating whether an image has been previously shown in the episode (Fig 8(b) in App. B). In Change Detection the agent sees two consecutive images, separated by a variable-length delay, and has to correctly indicate if the two images differ (Fig 8(c) in App. B). In What Then Where the agent is shown a single 'challenge' MNIST digit, then an image of that digit with three other digits, each placed along an edge of the rectangular screen. It next has to correctly indicate the location of the 'challenge' digit (Fig 8(d) in App. B).</p>
<h1>2.2 3D tasks</h1>
<p><img alt="img-0.jpeg" src="img-0.jpeg" />
(a) Spot the Difference basic
<img alt="img-1.jpeg" src="img-1.jpeg" />
(b) Navigate to Goal
<img alt="img-2.jpeg" src="img-2.jpeg" />
(c) Transitive Inference</p>
<p>Figure 1: Task layouts for Spot the Difference, Goal Navigation, and Transitive Inference. In (a), the agent has to identify the difference between the two rooms. In (b), the agent has to go to the goal. which is represented by an oval symbol here and may be visible or not to the agent. In (c), the agent has to go to the higher-valued object in each pair. The value order is given by the transitive chain outside the room. It is shown here solely for illustration; the agent cannot see it.</p>
<p>Spot the Difference: This tests whether the agent can correctly identify the difference between two nearly identical scenes (Figure 1(a)). The agent has to move from the first to the second room, with a 'delay' corridor in between. See Fig. 2 for the four different variants.
<img alt="img-3.jpeg" src="img-3.jpeg" />
(a) Spot the Difference Basic
<img alt="img-4.jpeg" src="img-4.jpeg" />
(b) Spot the Difference Passive
<img alt="img-5.jpeg" src="img-5.jpeg" />
(c) Spot the Difference Multi-Object
<img alt="img-6.jpeg" src="img-6.jpeg" />
(d) Spot the Difference Motion</p>
<p>Figure 2: Spot the Difference tasks. (a) All the tasks in this family are variants of this basic setup, where each room contains two blocks. (b) By placing Room 1's blocks right next to the corridor entrance, we guarantee that the agent will always see them. (c) The number of objects varies. (d) Instead of differing in color between rooms, the altered block follows a different motion pattern.</p>
<p>Goal Navigation: This task family was inspired by the Morris Watermaze (Miyake and Shah, 1999) setup used with rodents in behavioral neuroscience. The agent is rewarded every time it successfully reaches the goal; once it gets there it is respawned randomly in the arena and has to find its way back to the goal. The goal location is re-randomized at the start of episode (Fig. 1(b), Fig. 3).</p>
<h2>Transitive Inference:</h2>
<p>This task tests if an agent can learn an overall transitive ordering over a chain of objects, through being presented with ordered pairs of adjacent objects (See Fig. 1(c) and App. B).</p>
<h3>2.3 Scale and Stimulus Split</h3>
<p>To test how well the agent can generalize to holdout data after training, we create per-task holdout levels that differ from the training level along a scale and a stimulus dimension. The scale dimension is intended to capture something about the memory demand of the task: e.g., a task with a longer time delay between events that must be related should be harder than one with a short delay. The stimulus dimension is to guard against trivial overfitting to the particular visual input presented to the input: the memory representation should be more abstract than the particular colour of an object.</p>
<p><img alt="img-7.jpeg" src="img-7.jpeg" /></p>
<p>Figure 3: Goal Navigation tasks. (a) The arena has no buildings, agent must navigate by skybox. (b) There are rectangular buildings at fixed, non-randomized locations in the arena. (c) As in (b), but the goal appears as an oval. (d) A visible goal in a procedurally generated maze.</p>
<p>The training level comprises a 'small' and 'large' scale version of the task. When training the agent we uniformly sample between these two scales. As for the holdout levels, one of them - 'holdout-interpolate' - corresponds to an interpolation between those two scales (call it 'medium') and the other, 'holdout-extrapolate', corresponds to an extrapolation beyond the 'large' scale (call it 'extra-large'). Alterations made for each task split and their settings are in Table 2 in App. A.</p>
<h1>3 The Memory Recall Agent</h1>
<p>Our agent, the Memory Recall Agent (MRA), incorporates five components: 1) a pixel-input convolutional, residual network, 2) a working memory, 3) a slot-based episodic memory, 4) an auxiliary contrastive loss for representation learning (van den Oord et al., 2018), 5) a jumpy backpropagation-through-time training regime. Our agent architecture is shown in Figure 4(a). The overall agent is built on top of the IMPALA model (Espeholt et al., 2018) and is trained in the same way with the exceptions described below. Component descriptions are below.</p>
<p>Pixel Input Pixel input is fed to a convolutional neural network, as is common in recent agents, followed by a residual block (He et al., 2015). The precise hyper-parameters are given in C.2: we use three convolutional layers followed by two residual layers. The output of this process is $x_{t}$ in Figure 4(a) and serves as input to three other parts of the network: 1) part of the input to the working memory module, 2) in the formation of keys and queries for the episodic memory, 3) as part of the target for the contrastive predictive coding.</p>
<p>Working Memory Working memory is often realized through latent recurrent neural networks (RNNs) with some form of gating, such as LSTMs and Relational Memory architectures (Hochreiter and Schmidhuber, 1997; Santoro et al., 2018). These working memory models calculate the next set of hidden units using the current input and the previous hidden units. Although models which rely on working memory can perform well on a variety of problems, their ability to tackle dependencies and represent variables over long time periods is limited. The short-term nature of working memory is pragmatically, and perhaps unintentionally, reflected in the use of truncated backprop through time and the tendency for gradients through these RNNs to explode or vanish. Our agent uses an LSTM as a model of working memory. As we shall see in experiments, this module is able to perform working memory-like operations on tasks: i.e., learn calculations involving short-term memory. As depicted in Figure 4(a), the LSTM takes as input $x_{t}$ from the pixel input network and $m_{t}$ from the episodic memory module. As in Espeholt et al. (2018), the LSTM has two heads as output, producing the policy $\pi$ and the baseline value function $V$. In our architecture these are derived from the output from the LSTM, $h_{t} . h_{t}$ is also used to form episodic memories, as described below.</p>
<p>Episodic Memory (MEM) If our agent only consisted of the working memory and pixel input described above, it would be almost identical to the model in IMPALA (Espeholt et al., 2018), an already powerful RL agent. But MRA also includes a slot-based episodic memory module as that can store values more reliably and longer-term than an LSTM, is less susceptible to the intricacies of gradient propagation, and its fundamental operations afford the agent different abilities (as observed in our experiments). The MEM in MRA has a key-value structure which the agent reads from and writes to at every time-step (see Fig. 4(a)). MRA implements a mechanism to learn how to store summaries</p>
<p>of past experiences and retrieve relevant information when it encounters similar contexts. The reads from memory are used as additional inputs to the neural network (controller), which produces the model predictions. This effectively augments the controller’s working memory capabilities with experiences from different time scales retrieved from the MEM, which facilitate learning long-term dependencies, a difficult task when relying entirely on backpropagation in recurrent architectures (Hochreiter and Schmidhuber, 1997; Graves et al., 2016; Vaswani et al., 2017).</p>
<p>(a) Architecture of the MRA.</p>
<p>(b) Contrastive Predictive Coding loss for MRA.</p>
<p>Figure 4: The Memory Recall Agent (MRA) architecture. Here $p_{i}$ is the pixel input embedding $x_{t}$ from step $t$, and $v_{i}$ is the LSTM hidden state $h_{t}$. $k_{i}$ is the key used for reading; we compute it from $p_{i}$ and $v_{i}$. $q_{t}$ is the query we use to compare against keys to find nearest neighbors.</p>
<p>The MEM has a number of slots, indexed by $i$. Each slot stores activations from the pixel input network and LSTM from previous times $t_{i}$ in the past. The MEM acts as a fixed-size circular (first-in-first-out) buffer: New keys and values are added, overwriting the least recently added entry if there are no unused slots available. The contents of the episodic memory buffer is wiped at the end of each episode.</p>
<p>Memory Writing Crucially, writing to episodic memory is done without gradients. At each step a free slot is chosen for writing, denoted $i$. Next, the following is stored:</p>
<p>$p_{i}\leftarrow x_{t} ;\quad v_{i}\leftarrow h_{t} ;\quad k_{i}\leftarrow W_{k}[p_{i},v_{i}]+b_{k}$</p>
<p>where $p_{i}$ is the pixel input embedding from step $t$ and $v_{i}$ is the LSTM hidden state (if the working memory is something else, e.g. a feedforward, this would be the output activations). $k_{i}$ is the key, used for reading (described below), computed as a simple linear function of the other two values stored. Caching the key speeds up memory reads significantly. However, the key can become stale as the weights and biases, $W_{k}$ and $b_{k}$ are learnt (the procedure for learning them is described below under Jumpy Backpropagation). In our experiments we did not see an adverse effect of this staleness.</p>
<p>Memory Reading The agent uses a form of dot-product attention (Bahdanau et al., 2015) over its MEM, to select the most relevant events to provide as input $m_{t}$ to the LSTM. The query $q_{t}$ is a linear transform of the pixel input embedding $x_{t}$ and the LSTM hidden state from the previous time-step $h_{t-1}$, with weight $W_{q}$ and bias $b_{q}$.</p>
<p>$q_{t}=W_{q}[x_{t},h_{t-1}]+b_{q}$</p>
<p>The query $q_{t}$ is then compared against the keys in MEM as in Pritzel et al. (2017): Let $(p_{j},v_{j},k_{j})$, $1\leq j\leq K$ be the $K$ nearest neighbors to $q_{t}$ from MEM, under an L2 norm between $k_{j}$ and $q_{t}$.</p>
<p>$m_{t}=\sum_{j=1}^{K}{w_{j}v_{j}}\quad$ where $\quad w_{j}\propto\frac{1}{\epsilon+||q_{t}-W_{k}[p_{j},v_{j}]-b_{k}||_{2}^{2}}$</p>
<p>We compute a weighted aggregate of the values $(v_{j})$ of the $K$ nearest neighbors, weighted by the inverse of each neighbor-key’s distance to the query. Note that the distance is re-calculated from values stored in the MEM, via the linear projection $W_{k},b_{k}$ in (1). We concatenate the resulting weighted aggregate memory $m_{t}$ with the embedded pixel input $x_{t}$, and pass it as input to the working memory as shown in Figure 4(a).</p>
<p>Jumpy backpropagation We now turn to how gradients flow into memory writes. Full backpropagation can become computationally infeasible as this would require backpropagation into every write that is read from and so on. Thus as a new $\left(p_{i}, v_{i}, k_{i}\right)$-triplet is added to the MEM, there are trade-offs to be made regarding computational complexity versus performance of the agent. To make it more computationally tractable, we place a stop-gradient in the memory write. In particular, the write operation for the key in (1) becomes:</p>
<p>$$
k_{i} \leftarrow W_{k}\left[\operatorname{SG}\left(p_{i}\right), \operatorname{SG}\left(v_{i}\right)\right]+b_{k}
$$</p>
<p>where $\mathrm{SG}(\cdot)$ denote that the gradients are stopped. This allows the parameters $W_{k}$ and $b_{k}$ to receive gradients from the loss during writing and reading, while at the same time bounding the computational complexity as the gradients do not flow back into the recurrent working memory (or via that back into the MEM). To re-calculate the distances, we want to use these learnt parameters rather than, say, random projection, so we need to store the arguments $x_{t}$ and $h_{t}$ of the key-generating linear transform $W_{k}, b_{k}$ for all previous time-steps. Thus in the MEM we store the full $\left(p_{i}, v_{i}, k_{i}\right)$-triplet, where $p_{i}=x_{t_{i}}, v_{i}=h_{t_{i}}$ and $t_{i}$ is the step that write $i$ was made. We call this technique 'jumpy backpropagation' because the intermediate steps between the current time-step $t$ and the memory write step $t_{i}$ are not taken into account in the gradient updates.</p>
<p>This approach is similar to Sparse Attentive Backtracking (Ke et al., 2018, SAB) which uses sparse replay by passing gradients only through memories selected as relevant at each step. Our model differs in that it does not have a fixed chunking scheme and does not do full backpropagation through the architecture (which in our case becomes quickly intractable). Our approach has minimal computational overhead as we only recompute the keys for the nearest neighbors.</p>
<p>Auxiliary Unsupervised Losses An agent with good memory provides a good basis for forming a rich representation of the environment, as it captures a history of the states visited by the agent. This is the primary basis for many rich probabilistic state representations in reinforcement learning such as belief states and predictive state representations (Littman and Sutton, 2002). Auxiliary unsupervised losses can significantly improve agent performance (Jaderberg et al., 2016). Recently it has been shown that agents augmented with one-step contrastive predictive coding (van den Oord et al., 2018, CPC) can learn belief state representations of the environment (Guo et al., 2018). Thus in MRA we combine the working and episodic memory mechanisms listed above with a CPC unsupervised loss to imbue the agent with a rich state representation. The CPC auxiliary loss is added to the usual RL losses, and is of the following form:</p>
<p>$$
\sum_{\tau=1}^{N} \text { CPCLoss }\left[h_{t} ; x_{t+1}, x_{t+2}, \ldots, x_{t+\tau}\right]
$$</p>
<p>where CPCLoss is from van den Oord et al. (2018), $h_{t}$ is the working memory hidden state, and $x_{t+\tau}$ is the encoding pixel input at $\tau$ steps in the future. $N$ is the number of CPC steps (typically 10 or 50 in our experiments). See Figure 4(b) for an illustration and further details and equations elaborating on this loss in App. C.3.</p>
<p>Reconstruction losses have also been used as an auxiliary task (Jaderberg et al., 2016; Wayne et al., 2018) and we include this as a baseline in our experiments. Our reconstruction baseline minimizes the L2 distance between the predicted reward and predicted pixel input and the true reward and pixel input, using the working memory state $h_{t}$ as input. Details of this baseline are given in App. C.4.</p>
<h1>4 Experiments</h1>
<p>Setup We ran 10 ablations on the MRA architecture, on the training and the two holdout levels:</p>
<ul>
<li>Working Memory component: Either feedforward neural network ('FF' for short) or LSTM. The LSTM-only baseline corresponds to IMPALA (Espeholt et al., 2018).</li>
<li>With or without using episodic memory module ('MEM').</li>
<li>With or without auxiliary unsupervised loss (either CPC or reconstruction loss ('REC')).</li>
<li>With or without jumpy backpropagation, for MRA (i.e. LSTM + MEM + CPC)</li>
</ul>
<p>Given that the experiments are computationally demanding, we only performed small variations within as part of our hyper-parameter tuning process for each task (see App. D).</p>
<p>We hypothesize that in general the agent should perform the best in training, somewhat worse on the holdout-interpolation level and the worst on the holdout-extrapolation level. That is, we expect to see a generalization gap. Our results validated this hypothesis for the tasks that were much harder for agents than for humans.</p>
<h1>4.1 Full comparison</h1>
<p>We computed human-normalized scores (details in App. B) and plotted them into a heatmap (Fig 5) sorted such that the model with the highest train scores on average is the top row and the task with highest train scores on average is the leftmost column. The heatmap suggests that the MRA architecture, LSTM + MEM + CPC, broadly outperforms the other models (App. B Table 3). This ranking was almost always maintained across train and holdout levels, despite MRA performing worse than the LSTM-only baseline on What Then Where. What Then Where was one of the tasks where all models did poorly, along with Spot the Difference: Multi-Object, Spot the Difference: Multi-Object, Spot the Difference: Multi-Object (rightmost columns in heatmap). At the other end of the difficulty spectrum, LSTM + MEM had superhuman scores on Visible Goal Procedural Maze in training and on Transitive Inference in training and holdout, and further adding CPC or REC boosted the scores even higher.
<img alt="img-8.jpeg" src="img-8.jpeg" /></p>
<p>Figure 5: Heatmap of ablations per task sorted by normalized score for Train, Holdout-Interpolate, Holdout-Extrapolate. The same plot with standard errors is in App. B Fig. 14.</p>
<h3>4.2 Results</h3>
<p>Different memory systems worked best for different kinds of tasks, but the MRA architecture's combination of LSTM + MEM + CPC did the best overall on training and holdout (Fig. 6). Removing jumpy backpropagation from MRA hurt performance in five Memory Suite tasks (App. B Fig. 10), while performance was the same in the remaining ones (App. B Fig. 11 and 12).</p>
<p>Generalization gap widens as task difficulty increases The hypothesized generalization gap was minimal for some tasks e.g. $A V M$ and Continuous Recognition but significant for others e.g. What Then Where and Spot the Difference: Multi-Object (Fig 7). We observed that the gap tended to be wider as the task difficulty
<img alt="img-9.jpeg" src="img-9.jpeg" /></p>
<p>Figure 6: Normalized scores averaged across tasks.
went up, and that in PsychLab, the two tasks where the scale was the number of trials seemed to be easier than the other two tasks where the scale was the delay duration.</p>
<p>MEM critical on some tasks, is enhanced by auxiliary unsupervised loss Adding MEM improved scores on nine tasks in training, six in holdout-interpolate, and six in holdout-extrapolate. Adding MEM alone, without an auxiliary unsupervised loss, was enough to improve scores on $A V M$</p>
<p>and Continuous Recognition, all Spot the Difference tasks except Spot the Difference: Multi-Object, all Goal Navigation tasks except Visible Goal Procedural Maze, and also for Transitive Inference.</p>
<p>Adding MEM helped to significantly boost holdout performance for Transitive Inference, AVM, and Continuous Recognition. For the two PsychLab tasks this finding was in line with our expectations, since they both can be solved by memorizing single images and determining exact matches and thus an external episodic memory would be the most useful. For Transitive Inference, in training MEM helped when the working memory was FF but made little difference on an LSTM, but on holdout MEM helped noticeably for both FF and LSTM. In Change Detection and Multi-Object, adding MEM alone had little or no effect but combining it with CPC or REC provided a noticeable boost.</p>
<p>Synergistic effect of MEM + CPC, for LSTM On average, adding either the MEM + CPC stack or MEM + REC stack to any working memory appeared to improve the agent's ability to generalize to holdout levels (Fig. 6). Interestingly, on several tasks we found that combining MEM + CPC had a synergistic effect when the working memory was LSTM: The performance boost from adding MEM + CPC was larger than the sum of the boost from adding MEM or CPC alone. We observed this phenomenon in seven tasks in training, six in holdout-interpolate, and six in holdout-extrapolate. Among these, the tasks where there was MEM + CPC synergy across training, holdout-interpolate, and holdout-extrapolate were: the easiest task, Visible Goal Procedural Maze; Visible Goal with Buildings; Spot the Difference: Basic; and the hardest task, Spot the Difference: Multi-Object.</p>
<p>CPC vs. REC CPC was better than REC on all Spot the Difference tasks, and the two harder PsychLab tasks Change Detection and What Then Where. On the other two PsychLab tasks there was no difference between CPC and REC. However, REC was better on all Goal Navigation tasks except Invisible Goal Empty Arena. When averaged out, REC was more useful when the working memory was FF, but CPC was more useful for an LSTM working memory.
<img alt="img-10.jpeg" src="img-10.jpeg" /></p>
<p>Figure 7: Generalization gap is smaller for AVM and Continuous Recognition, larger for What Then Where and Spot the Difference: Multi-Object. Dotted lines indicate human baseline scores. See other curves in App. B Fig. 13.</p>
<h1>5 Discussion \&amp; Future Work</h1>
<p>We constructed a diverse set of environments ${ }^{2}$ to test memory-specific generalization, based on tasks designed to identify working memory and episodic memory in humans, and also developed an agent that demonstrates many of these cognitive abilities. We propose both a testbed and benchmark for further work on agents with memory, and demonstrate how better understanding the memory and generalization abilities of reinforcement learning agents can point to new avenues of research to improve agent performance and data efficiency. There is still room for improvement on the trickiest tasks in the suite where the agent fared relatively poorly. In particular, solving Spot the Difference:</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>Motion might need a generative model that enables forward planning to imagine how future motion unrolls (e.g., (Racanière et al., 2017)). Our results indicate that adding an auxiliary loss such as CPC or reconstruction loss to an architecture that already has an external episodic memory improves generalization performance on holdout sets, sometimes synergistically. This suggests that existing agents that use episodic memory, such as DNC and NEC, could potentially boost performance by implementing an additional auxiliary unsupervised loss.</p>
<h1>Acknowledgements</h1>
<p>We would like to thank Jessica Hamrick, Jean-Baptiste Lespiau, Frederic Besse, Josh Abramson, Oriol Vinyals, Federico Carnevale, Charlie Beattie, Piotr Trochim, Piermaria Mendolicchio, Aaron van den Oord, Chloe Hillier, Tom Ward, Ricardo Barreira, Matthew Mauger, Thomas Köppe, Pauline Coquinot and many others at DeepMind for insightful discussions, comments and feedback on this work.</p>
<h2>References</h2>
<p>Unity. http://unity3d.com/.
D. Bahdanau, K. Cho, and Y. Bengio. Neural machine translation by jointly learning to align and translate. In 3rd International Conference on Learning Representations, ICLR 2015, San Diego, CA, USA, May 7-9, 2015, Conference Track Proceedings, 2015. URL http://arxiv.org/abs/1409.0473.
A. Banino, C. Barry, B. Uria, C. Blundell, T. Lillicrap, P. Mirowski, A. Pritzel, M. J. Chadwick, T. Degris, J. Modayil, et al. Vector-based navigation using grid-like representations in artificial agents. Nature, 557 (7705):429, 2018.
C. Beattie, J. Z. Leibo, D. Teplyashin, T. Ward, M. Wainwright, H. Küttler, A. Lefrancq, S. Green, V. Valdés, A. Sadik, J. Schrittwieser, K. Anderson, S. York, M. Cant, A. Cain, A. Bolton, S. Gaffney, H. King, D. Hassabis, S. Legg, and S. Petersen. Deepmind lab. CoRR, abs/1612.03801, 2016.
C. Blundell, B. Uria, A. Pritzel, Y. Li, A. Ruderman, J. Z. Leibo, J. Rae, D. Wierstra, and D. Hassabis. Model-free episodic control. arXiv preprint arXiv:1606.04460, 2016.
K. Cobbe, O. Klimov, C. Hesse, T. Kim, and J. Schulman. Quantifying generalization in reinforcement learning. arXiv preprint arXiv:1812.02341, 2018.
L. Espeholt, H. Soyer, R. Munos, K. Simonyan, V. Mnih, T. Ward, Y. Doron, V. Firoiu, T. Harley, I. Dunning, S. Legg, and K. Kavukcuoglu. IMPALA: scalable distributed deep-rl with importance weighted actor-learner architectures. CoRR, abs/1802.01561, 2018. URL http://arxiv.org/abs/1802.01561.
A. Graves, G. Wayne, M. Reynolds, T. Harley, I. Danihelka, A. Grabska-Barwinska, S. G. Colmenarejo, E. Grefenstette, T. Ramalho, J. Agapiou, A. P. Badia, K. M. Hermann, Y. Zwols, G. Ostrovski, A. Cain, H. King, C. Summerfield, P. Blunsom, K. Kavukcuoglu, and D. Hassabis. Hybrid computing using a neural network with dynamic external memory. Nature, 538(7626):471-476, 2016. doi: 10.1038/nature20101. URL https://doi.org/10.1038/nature20101.
Z. D. Guo, M. G. Azar, B. Piot, B. A. Pires, T. Pohlen, and R. Munos. Neural predictive belief representations. CoRR, abs/1811.06407, 2018. URL http://arxiv.org/abs/1811.06407.
S. Hansen, A. Pritzel, P. Sprechmann, A. Barreto, and C. Blundell. Fast deep reinforcement learning using online adjustments from the past. In Advances in Neural Information Processing Systems, pages 10567-10577, 2018.
K. He, X. Zhang, S. Ren, and J. Sun. Deep residual learning for image recognition. CoRR, abs/1512.03385, 2015. URL http://arxiv.org/abs/1512.03385.
S. Hochreiter and J. Schmidhuber. Long short-term memory. Neural Comput., 9(8):1735-1780, Nov. 1997. ISSN 0899-7667. doi: 10.1162/neco.1997.9.8.1735. URL http://dx.doi.org/10.1162/neco.1997.9. 8.1735 .
M. Jaderberg, V. Mnih, W. M. Czarnecki, T. Schaul, J. Z. Leibo, D. Silver, and K. Kavukcuoglu. Reinforcement learning with unsupervised auxiliary tasks. arXiv preprint arXiv:1611.05397, 2016.</p>
<p>N. R. Ke, A. Goyal, O. Bilaniuk, J. Binas, M. C. Mozer, C. Pal, and Y. Bengio. Sparse attentive backtracking: Temporal creditassignment through reminding. CoRR, abs/1809.03702, 2018. URL http://arxiv.org/ abs/1809.03702.
J. Z. Leibo, C. de Masson d’Autume, D. Zoran, D. Amos, C. Beattie, K. Anderson, A. G. Castañeda, M. Sanchez, S. Green, A. Gruslys, S. Legg, D. Hassabis, and M. Botvinick. Psychlab: A psychology laboratory for deep reinforcement learning agents. CoRR, abs/1801.08116, 2018.
M. L. Littman and R. S. Sutton. Predictive representations of state. In Advances in neural information processing systems, pages 1555-1561, 2002.
A. Miyake and P. Shah. Models of working memory: Mechanisms of active maintenance and executive control. Cambridge University Press, 1999. doi: 10.1017/CBO9781139174909.
V. Mnih, A. P. Badia, M. Mirza, A. Graves, T. P. Lillicrap, T. Harley, D. Silver, and K. Kavukcuoglu. Asynchronous methods for deep reinforcement learning. CoRR, abs/1602.01783, 2016.
J. Pineau. Oreproducible, reusable, and robust reinforcement learning (invited talk). Advances in Neural Information Processing Systems, 2018, 2018.
A. Pritzel, B. Uria, S. Srinivasan, A. P. Badia, O. Vinyals, D. Hassabis, D. Wierstra, and C. Blundell. Neural episodic control. In Proceedings of the 34th International Conference on Machine Learning-Volume 70, pages 2827-2836. JMLR.org, 2017.
S. Racanière, T. Weber, D. Reichert, L. Buesing, A. Guez, D. J. Rezende, A. P. Badia, O. Vinyals, N. Heess, Y. Li, et al. Imagination-augmented agents for deep reinforcement learning. In Advances in neural information processing systems, pages 5690-5701, 2017.
S. Ritter, J. X. Wang, Z. Kurth-Nelson, S. M. Jayakumar, C. Blundell, R. Pascanu, and M. Botvinick. Been there, done that: Meta-learning with episodic recall. arXiv preprint arXiv:1805.09692, 2018.
A. Santoro, R. Faulkner, D. Raposo, J. W. Rae, M. Chrzanowski, T. Weber, D. Wierstra, O. Vinyals, R. Pascanu, and T. P. Lillicrap. Relational recurrent neural networks. CoRR, abs/1806.01822, 2018. URL http: //arxiv.org/abs/1806.01822.
C. Smith and L. R. Squire. Declarative memory, awareness, and transitive inference. Journal of Neuroscience, 25(44):10138-10146, 2005. ISSN 0270-6474. doi: 10.1523/JNEUROSCI.2731-05.2005. URL http: //www.jneurosci.org/content/25/44/10138.
S. Sukhbaatar, A. Szlam, J. Weston, and R. Fergus. Weakly supervised memory networks. CoRR, abs/1503.08895, 2015. URL http://arxiv.org/abs/1503.08895.
E. Tulving. Episodic memory: From mind to brain. Annual Review of Psychology, 53(1):1-25, 2002. doi: 10.1146/annurev.psych.53.100901.135114. URL https://doi.org/10.1146/annurev.psych. 53.100901.135114. PMID: 11752477.
E. Tulving and D. Murray. Elements of episodic memory. Canadian Psychology, 26(3):235-238, 1985.
A. van den Oord, Y. Li, and O. Vinyals. Representation learning with contrastive predictive coding. CoRR, abs/1807.03748, 2018. URL http://arxiv.org/abs/1807.03748.
A. Vaswani, N. Shazeer, N. Parmar, J. Uszkoreit, L. Jones, A. N. Gomez, L. Kaiser, and I. Polosukhin. Attention is all you need. CoRR, abs/1706.03762, 2017. URL http://arxiv.org/abs/1706.03762.
G. Wayne, C. Hung, D. Amos, M. Mirza, A. Ahuja, A. Grabska-Barwinska, J. W. Rae, P. Mirowski, J. Z. Leibo, A. Santoro, M. Gemici, M. Reynolds, T. Harley, J. Abramson, S. Mohamed, D. J. Rezende, D. Saxton, A. Cain, C. Hillier, D. Silver, K. Kavukcuoglu, M. Botvinick, D. Hassabis, and T. P. Lillicrap. Unsupervised predictive memory in a goal-directed agent. CoRR, abs/1803.10760, 2018.
V. F. Zambaldi, D. Raposo, A. Santoro, V. Bapst, Y. Li, I. Babuschkin, K. Tuyls, D. P. Reichert, T. P. Lillicrap, E. Lockhart, M. Shanahan, V. Langston, R. Pascanu, M. Botvinick, O. Vinyals, and P. Battaglia. Relational deep reinforcement learning. CoRR, abs/1806.01830, 2018. URL http://arxiv.org/abs/1806. 01830 .</p>
<h1>A Level descriptions and further experimental findings</h1>
<p>As described in Section 2.3, for each task in the Suite we construct a small training level, a large training level, a 'holdout-interpolation' level and a 'holdout-extrapolation' level.</p>
<p>During training the environment uniformly samples from the small and large training levels. The interpolation level has a scale somewhere in between 'small' and 'large' while the extrapolation level corresponds to 'extralarge' (Table 1). A summary of the alterations made for each task split is in Table 2. The settings used in each level per task are described below.</p>
<p>Table 1: Overall structure for scale and stimulus split.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Stimuli</th>
<th style="text-align: center;">Training set</th>
<th style="text-align: center;">Holdout set</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Scale</td>
<td style="text-align: center;">Used for training</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">Small</td>
<td style="text-align: center;">Used for training</td>
<td style="text-align: center;">Used for interpolation</td>
</tr>
<tr>
<td style="text-align: left;">Medium</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">Large</td>
<td style="text-align: center;">Used for training</td>
<td style="text-align: center;">Used for extrapolation</td>
</tr>
<tr>
<td style="text-align: left;">Extra-large</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>The dashed ('-') settings in Table 1 are not reported nor used, since they lack a clear interpretation in terms of generalization.</p>
<p>Table 2: Scale and stimulus alterations across task families</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Task</th>
<th style="text-align: center;">Scale</th>
<th style="text-align: center;">Stimulus</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">AVM</td>
<td style="text-align: center;">Number of trials</td>
<td style="text-align: center;">Image</td>
</tr>
<tr>
<td style="text-align: left;">Continuous Recognition</td>
<td style="text-align: center;">Number of trials</td>
<td style="text-align: center;">Image</td>
</tr>
<tr>
<td style="text-align: left;">Change Detection</td>
<td style="text-align: center;">Delay study/test</td>
<td style="text-align: center;">Color</td>
</tr>
<tr>
<td style="text-align: left;">What Then Where</td>
<td style="text-align: center;">Delay study/query</td>
<td style="text-align: center;">Digit image</td>
</tr>
<tr>
<td style="text-align: left;">Spot Diff Basic</td>
<td style="text-align: center;">Corridor delay</td>
<td style="text-align: center;">Color</td>
</tr>
<tr>
<td style="text-align: left;">Spot Diff Passive</td>
<td style="text-align: center;">Corridor delay duration</td>
<td style="text-align: center;">Color</td>
</tr>
<tr>
<td style="text-align: left;">Spot Diff Multi-object</td>
<td style="text-align: center;">Number of objects</td>
<td style="text-align: center;">Color</td>
</tr>
<tr>
<td style="text-align: left;">Spot Diff Motion</td>
<td style="text-align: center;">Corridor delay</td>
<td style="text-align: center;">Motion pattern</td>
</tr>
<tr>
<td style="text-align: left;">All Goal Navigation tasks</td>
<td style="text-align: center;">Arena size</td>
<td style="text-align: center;">Goal spawn</td>
</tr>
<tr>
<td style="text-align: left;">Transitive Inference</td>
<td style="text-align: center;">Length of transitive chain</td>
<td style="text-align: center;">Object color</td>
</tr>
</tbody>
</table>
<h2>A. 1 PsychLab</h2>
<p>Our Memory Tasks Suite has four PsychLab tasks: Arbitrary Visuomotor Mapping (AVM), Continuous Recognition, Change Detection and What Then Where. The description of each task is found in Figure 8. Videos with agent play and the https://sites.google.com/view/memory-tasks-suite.</p>
<p>Scale Either number of trials per episode or delay duration.
For Arbitrary Visuomotor Mapping and Continuous Recognition, every episode lasts at most 300 seconds, except for the Extrapolate level where the cap is set to 450 seconds to accommodate the larger number of trials. In Change Detection an episode lasts at most 300 seconds, while for What Then Where it is 600 seconds.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Task</th>
<th style="text-align: center;">AVM and Cont. Recog.: <br> Trials per episode</th>
<th style="text-align: center;">Change Detection: <br> delay (seconds)</th>
<th style="text-align: center;">What Then Where: <br> delay (seconds)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Small</td>
<td style="text-align: center;">50</td>
<td style="text-align: center;">$2,4,8$</td>
<td style="text-align: center;">4,8</td>
</tr>
<tr>
<td style="text-align: left;">Interpolate</td>
<td style="text-align: center;">40</td>
<td style="text-align: center;">16,32</td>
<td style="text-align: center;">16,64</td>
</tr>
<tr>
<td style="text-align: left;">Large</td>
<td style="text-align: center;">50</td>
<td style="text-align: center;">64,128</td>
<td style="text-align: center;">32,128</td>
</tr>
<tr>
<td style="text-align: left;">Extrapolate</td>
<td style="text-align: center;">75</td>
<td style="text-align: center;">$130,150,200,250$</td>
<td style="text-align: center;">$132,156,200,256$</td>
</tr>
</tbody>
</table>
<p>Stimulus Either color set or image set.</p>
<p><img alt="img-11.jpeg" src="img-11.jpeg" /></p>
<p>Figure 8: All PsychLab tasks have multiple trials within an episode. Each trial consists of a single image being displayed on the panel. In (a), when the agent sees an image for the first time, the associated direction is indicated on the screen (green box on the left). By executing the indicated pattern, the agent receives a reward. When the agent is presented with an image it has already seen during the episode, the associated direction is no longer indicated (middle), and the agent must remember it from its previous experience in order to get a reward (right). In (b), the agent is shown a pattern (left), and after a delay (middle), a second pattern is shown (right). The agent has to indicate if there was a change between the two patterns or not by looking right or left, respectively. The delay period separating the two patterns varies in length. In (c), the agent indicates if it has seen the image in the current episode by looking left or right, respectively. In (d), in the 'what' study phase, an MNIST digit is displayed (left). In the 'where' study period, four distinct MNIST digits are displayed including the one from the 'what' period (middle). In the test phase (right), the agent must remember what digit was displayed in the 'what' period, see where it is located during the study where period, and then respond by looking to that location. In this example it has to look left.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Task</th>
<th style="text-align: center;">AVM and Cont. Recog</th>
<th style="text-align: center;">Change Detection</th>
<th style="text-align: center;">What Then Where</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Stimulus</td>
<td style="text-align: center;">Different images</td>
<td style="text-align: center;">Color set</td>
<td style="text-align: center;">MNIST digits</td>
</tr>
<tr>
<td style="text-align: center;">Training</td>
<td style="text-align: center;">Images with even ID</td>
<td style="text-align: center;">Amethyst, Caramel, <br> Honeydew, Jade, Mallow</td>
<td style="text-align: center;">$0,1,2,3,4$</td>
</tr>
<tr>
<td style="text-align: center;">Holdout</td>
<td style="text-align: center;">Images with odd ID</td>
<td style="text-align: center;">Yellow, Lime, Pink, Sky, Violet</td>
<td style="text-align: center;">$5,6,7,8,9$</td>
</tr>
</tbody>
</table>
<h1>A.1.1 PsychLab: main experimental findings</h1>
<p>AVM: in this task, the agent must remember associations between images and specific movement patterns (Figure 8 (a)).
The most useful component turned out to be MEM. This is in line with earlier findings that an external episodic memory is a prerequisite for solving AVM (Wayne et al., 2018). Adding an auxiliary loss helped when the controller was FF but made no difference for an LSTM. Also, choosing between CPC or REC for auxiliary unsupervised loss did not make a major difference for either controller.</p>
<p>Continuous Recognition: in this task, the agent must remember if it has seen a particular image before by looking left or right (Figure 8 (b)).
MEM was the most useful component when added to an LSTM, but made no difference when added alone to an FF controller. However, adding a stack of MEM plus either CPC or REC provided a substantial performance boost for both FF and LSTM.</p>
<p>Change Detection: in this task, agent sees two images separated by a delay and has to correctly indicate if the two images are different (Figure 8 (c)).
CPC brought the largest benefit. Interestingly the addition of MEM to the FF baseline actually hurt performance slightly, and made no difference for LSTM.</p>
<p>What Then Where: this task consists of a 'what' and 'where' study phase, followed by a test phase where the agent must remember what image was displayed and where it was located (Figure 8 (d)).
This was the trickiest task in the Psychlab family. This task was an outlier in the sense that unlike any other task in the suite, the LSTM baseline beat all other models. The worst additional component was REC which dragged down performance to below random.</p>
<h1>A. 2 Spot the Difference (SD)</h1>
<p>The tasks were built in Unity, and each episode lasts 120 seconds except for Spot the Difference: Motion which has a 240 -second timeout.</p>
<p>Scale Either corridor delay duration or number of objects in room.
In Spot the Difference Multi-Object, Room 2 has the exact same number of objects as Room 1.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Task</th>
<th style="text-align: center;">SD Basic, Passive and Motion: <br> Corridor delay (seconds)</th>
<th style="text-align: center;">SD Multi-Object: <br> Number of objects in Room 1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Small</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">2 or 3</td>
</tr>
<tr>
<td style="text-align: left;">Interpolate</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">4</td>
</tr>
<tr>
<td style="text-align: left;">Large</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">5 or 6</td>
</tr>
<tr>
<td style="text-align: left;">Extrapolate</td>
<td style="text-align: center;">15</td>
<td style="text-align: center;">7</td>
</tr>
</tbody>
</table>
<p>Stimulus Either color set or motion pattern set.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Task</th>
<th style="text-align: center;">SD Basic, Passive and Motion</th>
<th style="text-align: center;">SD Multi-Object</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Stimulus</td>
<td style="text-align: center;">Color Set</td>
<td style="text-align: center;">Motion Pattern Set</td>
</tr>
<tr>
<td style="text-align: left;">Training</td>
<td style="text-align: center;">Red, Green, Blue, <br> White, Slate</td>
<td style="text-align: center;">Circle, Square, Five-point star, Hexagon <br> Linear along X-axis, Linear along Y = X diagonal</td>
</tr>
<tr>
<td style="text-align: left;">Holdout</td>
<td style="text-align: center;">Yellow, Brown, Pink, <br> Orange, Purple</td>
<td style="text-align: center;">No motion, Triangle, Pentagon, Figure-eight <br> Linear along Y-axis, Linear along Y = -X diagonal</td>
</tr>
</tbody>
</table>
<h2>A.2.1 Spot the Diff: main experimental findings</h2>
<p>Every task in this family consists of two rooms connected by a short corridor. There is a set of gates in the middle of the corridor that can trap the agent there for a configurable delay duration.</p>
<p>Basic In the basic Spot the Difference task, where the agent is not forced to see any of the blocks in Room 1 before it goes to the next room, adding MEM alone to the controller had minimal effect, and using REC with MEM also did not make much difference. Adding CPC to an LSTM helped performance but it turned out that using the combination of MEM + CPC provided the biggest gain and was synergistic.</p>
<p>Passive In this task the agent is guaranteed to see the two blocks in the first room before it enters the second room. Adding MEM alone to the controller made the biggest positive difference, which makes sense since that hypothetically would make it possible for the agent to solve the task by remembering a single snapshot. CPC helped when added to FF together with MEM, but hurt when added to LSTM alone. REC helped performance when added to $\mathrm{FF}+$ MEM, but not as much as CPC did in that case, and actually hurt performance when added to LSTM + MEM.</p>
<p>Motion Nothing did well on train or holdout sets, and curves took longer to take off in general. This is likely due to the highly challenging nature of the task, which requires the agent to memorize 3D motion patterns traced out over some time period by multiple objects and then compare motion patterns against each other. Results would potentially be improved by hyperparameter tuning or further improvements to agent architecture.</p>
<p>Multi-object This was the hardest task in the family, and nothing did well here either. This could be due to there being a variable number of objects in each room, rather than always exactly two objects per room. When added by itself to a controller MEM either had no effect or hurt performance. The combined synergistic stack of MEM + CPC was the most useful addition on this task when the working memory was LSTM. That said, no models fared well on Holdout-Interpolate and Holdout-Extrapolate for this task.</p>
<h1>A. 3 Navigate to Goal</h1>
<p>These tasks are in Unity and have an episode timeout of 200 seconds, except Visible Goal Procedural Maze which is a modification of DMLab's Explore Goal Locations task and has episodes lasting 120 seconds each.</p>
<p>Scale Size of square arena, in terms of in-game metric units.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Task</th>
<th style="text-align: center;">Visible Goal Procedural Maze: <br> Arena Size</th>
<th style="text-align: center;">All but Visible Goal Procedural Maze: <br> Arena Size</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Small</td>
<td style="text-align: center;">$11 \times 11$</td>
<td style="text-align: center;">$10 \times 10$</td>
</tr>
<tr>
<td style="text-align: left;">Interpolate</td>
<td style="text-align: center;">$15 \times 15$</td>
<td style="text-align: center;">$15 \times 15$</td>
</tr>
<tr>
<td style="text-align: left;">Large</td>
<td style="text-align: center;">$21 \times 21$</td>
<td style="text-align: center;">$20 \times 20$</td>
</tr>
<tr>
<td style="text-align: left;">Extrapolate</td>
<td style="text-align: center;">$27 \times 27$</td>
<td style="text-align: center;">$25 \times 25$</td>
</tr>
</tbody>
</table>
<p>Stimulus Goal spawn region.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Task</th>
<th style="text-align: center;">Visible Goal Procedural Maze: <br> Goal spawn region</th>
<th style="text-align: center;">All but Visible Goal Procedural Maze: <br> Goal spawn region</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Training</td>
<td style="text-align: center;">North half</td>
<td style="text-align: center;">Northwest and southeast quadrants</td>
</tr>
<tr>
<td style="text-align: left;">Holdout</td>
<td style="text-align: center;">South half</td>
<td style="text-align: center;">The other two quadrants</td>
</tr>
</tbody>
</table>
<h2>A.3.1 Navigate to Goal: main experimental findings</h2>
<p>Using an auxiliary unsupervised reconstruction loss to learn high-quality representations turned out to be the most useful component for this task family.</p>
<p>We also observed that in successful models such as LSTM + MEM + CPC, which is the MRA architecture, the agent is able to do better than simply memorizing a route to the invisible goal. Rather, it learns the location of the goal, and the time it takes to reach the goal location grows shorter every time it respawns within an episode (see example trajectory in Fig 9(a) and time-to-goal plot in Fig 9(b)).</p>
<p>Visible Goal Procedural Maze Using REC with LSTM + MEM performed the best here, and FF + MEM + REC was the next best. The MEM + CPC stack was a distant runner-up compared with the MEM + REC stack for both controllers.</p>
<p>Visible Goal With Buildings Like in the other Visible Goal task, LSTM + MEM + REC was the most successful model. MEM was slightly more helpful than CPC when used in conjunction with an LSTM (we did not have bandwidth to run the FF + CPC ablation). MEM + CPC also had a synergistic effect when stacked with an LSTM.</p>
<p>Invisible Goal With Buildings Adding MEM + REC was the most useful, for both FF and LSTM.</p>
<p>Invisible Goal Empty Arena This task can be expected to be the most difficult in the family due to the relative sparsity of visual spatial cues. Adding MEM alone to a controller always helped slightly. REC helped more than CPC did when used with an FF controller but for an LSTM controller CPC had a slight edge.</p>
<p><img alt="img-12.jpeg" src="img-12.jpeg" /></p>
<p>Figure 9: Trajectories and time-to-goal for Invisible Goal with Buildings. In (a), our MRA (LSTM + MEM + CPC) agent learns to take increasingly shorter routes to the goal. Note: The end-points of each trial trajectory appear to be in slightly different locations. This is because the goal is on a map tile rather than a single coordinate, and also due to manual adjustments we made to account for the agent avatar in Unity continuing to move for a small number of frames immediately after reaching the goal but before it is respawned. In (b), the number of time-steps taken per trial is plotted for Train, Holdout-Interpolate, Holdout-Extrapolate, along with standard error bars. Note: Some points at the rightmost end of each curve will have no error bar if there was only one data point.</p>
<h1>A. 4 Transitive Inference</h1>
<p>The task was built in Unity and has an episode timeout of 200 seconds.
Scale: Number of objects in transitive chain. Stimulus: Color set.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Scale</th>
<th style="text-align: center;">Transitive chain length</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Small</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td style="text-align: left;">Interpolate</td>
<td style="text-align: center;">6</td>
</tr>
<tr>
<td style="text-align: left;">Large</td>
<td style="text-align: center;">7</td>
</tr>
<tr>
<td style="text-align: left;">Extrapolate</td>
<td style="text-align: center;">8</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: left;">Stimulus</th>
<th style="text-align: center;">Color set</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Training</td>
<td style="text-align: center;">Red, Green, Blue, White, Black,</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;">Pink, Orange, Purple, Grey, Tan</td>
</tr>
<tr>
<td style="text-align: left;">Holdout</td>
<td style="text-align: center;">Slate, Yellow, Brown, Lime, Magenta</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;">Mint, Navy, Olive, Teal, Turquoise</td>
</tr>
</tbody>
</table>
<h2>A.4.1 Transitive Inference: main experimental findings</h2>
<p>Transitive inference is a form of reasoning where one infers a relation between items that have not been explicitly directly compared to each other. In humans, performance on probe pairs and anchor pairs with symbolic distance of greater than one excluding anchor objects tends to correlate with awareness of the implied hierarchy (Smith and Squire, 2005).</p>
<p>As an illustrative example: Given a 'transitive chain' of five objects $A, B, C, D, E$ where we assume $A$ is the lowest-valued object and $E$ the highest, we begin with a demonstration phase in which we present the agent with pairs of adjacent objects $\langle A, B\rangle,\langle B, C\rangle,\langle C, D\rangle,\langle D, E\rangle$.</p>
<p>In this demo phase we scramble the order in which the pairs are presented and also scramble the objects in the pair such that an agent may see $\langle D, C\rangle$ followed by $\langle A, B\rangle$, etc. The pairs are presented one at a time, and the agent needs to correctly identify the higher-valued object in the current pair in order to proceed to seeing the next pair.</p>
<p>Once the demo phase is completed, we show the agent a single, possibly-scrambled challenge pair. This challenge pair always consists of the object second from the left and the object second from the right in the transitive chain, in this case $\langle B, D\rangle$. The agent's task is again to go to the higher-valued object.</p>
<p>In our results, we found that stacking MEM with auxiliary loss was crucial. For an FF controller CPC was more useful than REC, but for LSTM it was the other way round. Also, although both LSTM + MEM + CPC and LSTM + MEM + REC achieved normalized scores that were not too far apart, REC was more data-efficient and took off earlier than the former. We observed a synergistic effect when combining MEM with CPC for an LSTM, but that was still outdone by using MEM + REC.</p>
<h2>A. 5 Jumpy Backpropagation (JB) ablation</h2>
<p>We studied the impact of having Jumpy Backpropagation (JB) as described in Section 3. In Fig 10, we can see the set of tasks where adding the JB yields improvements on performance both at training time and on the holdout test levels. Figures 11 and 12 show the performance on the remaining levels from the Memory Task Suite, where having the JB feature did not hurt performance. We conclude that JB is an important component of the MRA architecture.</p>
<p><img alt="img-13.jpeg" src="img-13.jpeg" /></p>
<p>Figure 10: Comparison between MRA (LSTM + MEM +CPC) and its version without the jumpy backpropagation feature on MEM: LSTM + MEM (no JB) + CPC. Here we show the tasks where JB yields improvements on performance both at training time and on the holdout test levels. The dotted lines indicate human baseline scores for each task.</p>
<p><img alt="img-14.jpeg" src="img-14.jpeg" /></p>
<p>Figure 11: [1/2] Comparison between MRA and its version without the jumpy backpropagation (JB) feature. Here we show the tasks where JB makes little difference on performance. The dotted lines indicate human baseline scores for each task.</p>
<p>Visible Goal With Buildings
<img alt="img-15.jpeg" src="img-15.jpeg" /></p>
<p>Figure 12: [2/2] Comparison between MRA and its version without the jumpy backpropagation (JB) feature. Here we show the tasks where JB makes little difference on performance. The dotted lines indicate human baseline scores for each task.</p>
<h1>A. 6 Agent Performance Curves</h1>
<p>In this session we show training and test curves for all models in all tasks. The dotted lines indicate human baseline scores for each task.</p>
<p>Arbitrary Visuomotor Mapping
<img alt="img-16.jpeg" src="img-16.jpeg" /></p>
<p>Continuous Recognition
<img alt="img-17.jpeg" src="img-17.jpeg" /></p>
<p>Change Detection
<img alt="img-18.jpeg" src="img-18.jpeg" /></p>
<p>What Then Where
<img alt="img-19.jpeg" src="img-19.jpeg" /></p>
<p>Spot Diff Passive
<img alt="img-20.jpeg" src="img-20.jpeg" /></p>
<p>Spot Diff Basic
<img alt="img-21.jpeg" src="img-21.jpeg" /></p>
<p>Spot Diff Multi-Object
<img alt="img-22.jpeg" src="img-22.jpeg" /></p>
<p>Spot Diff Motion
<img alt="img-23.jpeg" src="img-23.jpeg" /></p>
<p>Invisible Goal Empty Arena
<img alt="img-24.jpeg" src="img-24.jpeg" /></p>
<p>Invisible Goal With Buildings
<img alt="img-25.jpeg" src="img-25.jpeg" /></p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{2}$ Available at https://github.com/deepmind/dm_memorytasks.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>