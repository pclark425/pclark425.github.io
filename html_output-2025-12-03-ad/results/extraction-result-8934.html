<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-8934 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-8934</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-8934</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-157.html">extraction-schema-157</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing self-reflection or iterative answer improvement (e.g., generate-then-reflect, self-critique, reflexion), including descriptions of the methods, tasks, performance results, mechanisms, and any reported limitations or failure cases.</div>
                <p><strong>Paper ID:</strong> paper-b5bffe41155052a43010ec7197f832e81c546268</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/b5bffe41155052a43010ec7197f832e81c546268" target="_blank">Quiet-STaR: Language Models Can Teach Themselves to Think Before Speaking</a></p>
                <p><strong>Paper Venue:</strong> arXiv.org</p>
                <p><strong>Paper TL;DR:</strong> Quiet-STaR is presented, a generalization of STaR in which LMs learn to generate rationales at each token to explain future text, improving their predictions and improving the LM's ability to directly answer difficult questions.</p>
                <p><strong>Paper Abstract:</strong> When writing and talking, people sometimes pause to think. Although reasoning-focused works have often framed reasoning as a method of answering questions or completing agentic tasks, reasoning is implicit in almost all written text. For example, this applies to the steps not stated between the lines of a proof or to the theory of mind underlying a conversation. In the Self-Taught Reasoner (STaR, Zelikman et al. 2022), useful thinking is learned by inferring rationales from few-shot examples in question-answering and learning from those that lead to a correct answer. This is a highly constrained setting -- ideally, a language model could instead learn to infer unstated rationales in arbitrary text. We present Quiet-STaR, a generalization of STaR in which LMs learn to generate rationales at each token to explain future text, improving their predictions. We address key challenges, including 1) the computational cost of generating continuations, 2) the fact that the LM does not initially know how to generate or use internal thoughts, and 3) the need to predict beyond individual next tokens. To resolve these, we propose a tokenwise parallel sampling algorithm, using learnable tokens indicating a thought's start and end, and an extended teacher-forcing technique. Encouragingly, generated rationales disproportionately help model difficult-to-predict tokens and improve the LM's ability to directly answer difficult questions. In particular, after continued pretraining of an LM on a corpus of internet text with Quiet-STaR, we find zero-shot improvements on GSM8K (5.9%$\rightarrow$10.9%) and CommonsenseQA (36.3%$\rightarrow$47.2%) and observe a perplexity improvement of difficult tokens in natural text. Crucially, these improvements require no fine-tuning on these tasks. Quiet-STaR marks a step towards LMs that can learn to reason in a more general and scalable way.</p>
                <p><strong>Cost:</strong> 0.014</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e8934.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e8934.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing self-reflection or iterative answer improvement (e.g., generate-then-reflect, self-critique, reflexion), including descriptions of the methods, tasks, performance results, mechanisms, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Quiet-STaR</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Quiet Self-Taught Reasoner</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A method that trains a pretrained language model to generate internal, tokenwise rationales (thoughts) before producing each next token, and to reinforce rationales that improve the model's likelihood on future ground-truth tokens using a REINFORCE-style reward; uses parallel sampling, learned start/end thought meta-tokens, a mixing head to interpolate logits with/without thought, and a non-myopic teacher-forcing loss.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Mistral 7B</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>A 7-billion-parameter autoregressive transformer (base Mistral 7B) pretrained in the standard way and then continued pretraining / finetuned with Quiet-STaR on web-text corpora (OpenWebMath and C4). Training used 8x80GB H100s; optimization hyperparameters and batch sizes are listed in Appendix A of the paper.</td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_name</strong></td>
                            <td>Quiet-STaR (tokenwise internal rationales)</td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_description</strong></td>
                            <td>At training time, after each token position the model samples multiple candidate rationales (thought sequences) in parallel using a diagonal/blocked attention mask; each rationale is bracketed with learned <|startofthought|> and <|endofthought|> meta-token embeddings. From the hidden state after a thought, a mixing head predicts how much to mix the logits produced with the thought versus the base logits without the thought. The reward for each sampled rationale is the difference in log-probability (over n_true future tokens) of the ground-truth future text under the mixed prediction for that rationale minus the average across sampled rationales; REINFORCE (with negative rewards clipped/excluded for stability) is used to increase likelihood of helpful rationales. A non-myopic teacher-forcing loss (predicting multiple tokens ahead) is included to stabilize learning. Parallel generation and a diagonal attention mask allow sampling rationales from all token positions efficiently.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>GSM8K and CommonsenseQA (zero-shot direct-answer evaluation); also chain-of-thought augmentation (GSM8K cot-maj@8)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>GSM8K: grade-school math word-problem benchmark requiring multi-step reasoning; CommonsenseQA: multiple-choice commonsense question-answering benchmark. Chain-of-thought evaluation refers to zero-shot CoT prompting and majority-vote over sampled CoT chains.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_reflection</strong></td>
                            <td>OpenWebMath-trained Quiet-STaR: GSM8K zero-shot direct accuracy 10.9% (from 5.9% baseline); CommonsenseQA zero-shot direct accuracy 47.2% (from 36.3% baseline). C4-trained Quiet-STaR (16 thought tokens): GSM8K 8.1% (from 5.9%); CommonsenseQA 42.6% (from 36.3%). Chain-of-thought (zero-shot) majority-vote (8 samples) on a 128-item GSM8K sample: cot-maj@8 increased from 40.6% to 47.7% when using Quiet-STaR internal thoughts. The paper also reports perplexity improvements concentrated on difficult tokens in natural text (qualitative and distributional analyses).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_reflection</strong></td>
                            <td>Base Mistral 7B (no Quiet-STaR): GSM8K zero-shot direct accuracy 5.9%; CommonsenseQA zero-shot direct accuracy 36.3%. Chain-of-thought majority baseline (cot-maj@8) was 40.6% on the 128-item GSM8K sample.</td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_comparison</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_of_reflection</strong></td>
                            <td>Internal rationale generation as latent tokens (learned meta-tokens to start/end thoughts) inserted at each token position; parallel sampling via a diagonal/blocked attention mask to generate rationale candidates concurrently for many positions; mixing head (MLP) computes interpolation weight between base logits and post-rationale logits; reward = improvement in log-probability on multiple future tokens relative to mean across samples; REINFORCE applied to increase probability of useful rationales; non-myopic teacher-forcing (multiple tokens ahead) used to stabilize the learning signal.</td>
                        </tr>
                        <tr>
                            <td><strong>number_of_iterations</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_improvement</strong></td>
                            <td>Quantitative: zero-shot direct-answer accuracy improvements on two reasoning benchmarks (GSM8K and CommonsenseQA) without task-specific finetuning; improvements increase with the number of tokens used in internal thoughts; chain-of-thought sampling accuracy (majority-vote) also improved when internal rationales are available during CoT generation; distributional analyses show improvements disproportionately concentrated on 'difficult' tokens and tokens where recalling relevant domain information helps (e.g., theorem names or proof steps); ablations (Appendix D) show multiple sampled rationales per token outperforms single-sample baselines and that predicting multiple tokens ahead (non-myopic loss) gives further gains.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Reported limitations: substantial computational overhead due to generating many rationale tokens per input token; initial distribution shift when introducing thoughts can harm performance (mitigated by the mixing head); Quiet-STaR as implemented does not dynamically predict when to generate or end a rationale (no learned stopping criterion); only evaluated as continued pretraining on a 7B model (unknown behavior when training from scratch or at other model scales); authors note training instability concerns which motivated excluding negative REINFORCE rewards (introduces bias); not all tokens benefit—improvements concentrate on difficult tokens; downstream-task performance curves sometimes deteriorate over continued training (roles of thought tokens may change); faithfulness of textual rationales to internal model computation is unknown; potential for harmful or biased reasoning patterns learned from web text; compute-normalized comparisons are included but the method requires extra compute. No exhaustive failure case catalog, but these limitations are explicitly discussed.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_methods</strong></td>
                            <td>Relation to STaR: Quiet-STaR generalizes STaR from discrete QA datasets to learning rationales from general web text and from per-problem accept/reject to a tokenwise REINFORCE reward across future-token likelihoods. Compared to pause-token fine-tuning (Goyal et al., 2023), Quiet-STaR (multi-token rationales) produces larger gains; pause tokens gave only minor gains on CommonsenseQA and harmed GSM8K in that prior work. Chain-of-thought (Kojima et al., 2022) is complementary: Quiet-STaR trains silent internal rationales that can be used during explicit CoT generation and improved CoT majority-vote accuracy. The paper situates Quiet-STaR alongside related iterative or self-generated-reasoning approaches (STaR, VSTaR, TRICE, Reflexion, Self-refine) but differs by training on general text and optimizing tokenwise latent rationales rather than training/verifying on curated task traces.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_study_results</strong></td>
                            <td>Appendix D reports: sampling multiple rationales per token consistently outperforms a single-sample baseline (≈ +0.5% GSM8K, +3% CommonsenseQA). Varying the number of sampled thoughts (2,3,4) gave consistent but small additional gains; more than two thoughts improved only by ~0.1–0.3%. Predicting more than one token ahead (non-myopic loss) improved GSM8K by ~0.3% and CommonsenseQA by ~3.1%, but beyond two tokens-ahead did not further improve the 12-thought-token baseline; rationales appear qualitatively more coherent with added tokens-ahead. The paper also provides compute-normalized plots (Appendix C) to contextualize gains versus extra inference calls.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Quiet-STaR: Language Models Can Teach Themselves to Think Before Speaking', 'publication_date_yy_mm': '2024-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Star: Bootstrapping reasoning with reasoning <em>(Rating: 2)</em></li>
                <li>Think before you speak: Training language models with pause tokens <em>(Rating: 2)</em></li>
                <li>Large Language Models are Zero-Shot Reasoners <em>(Rating: 2)</em></li>
                <li>Reflexion: Language agents with verbal reinforcement learning <em>(Rating: 2)</em></li>
                <li>Self-refine: Iterative refinement with self. Feedback <em>(Rating: 2)</em></li>
                <li>TRICE: Training chain-of-thought via latent-variable inference <em>(Rating: 1)</em></li>
                <li>V-star: Training verifiers for self-taught reasoners <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-8934",
    "paper_id": "paper-b5bffe41155052a43010ec7197f832e81c546268",
    "extraction_schema_id": "extraction-schema-157",
    "extracted_data": [
        {
            "name_short": "Quiet-STaR",
            "name_full": "Quiet Self-Taught Reasoner",
            "brief_description": "A method that trains a pretrained language model to generate internal, tokenwise rationales (thoughts) before producing each next token, and to reinforce rationales that improve the model's likelihood on future ground-truth tokens using a REINFORCE-style reward; uses parallel sampling, learned start/end thought meta-tokens, a mixing head to interpolate logits with/without thought, and a non-myopic teacher-forcing loss.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "Mistral 7B",
            "model_description": "A 7-billion-parameter autoregressive transformer (base Mistral 7B) pretrained in the standard way and then continued pretraining / finetuned with Quiet-STaR on web-text corpora (OpenWebMath and C4). Training used 8x80GB H100s; optimization hyperparameters and batch sizes are listed in Appendix A of the paper.",
            "reflection_method_name": "Quiet-STaR (tokenwise internal rationales)",
            "reflection_method_description": "At training time, after each token position the model samples multiple candidate rationales (thought sequences) in parallel using a diagonal/blocked attention mask; each rationale is bracketed with learned &lt;|startofthought|&gt; and &lt;|endofthought|&gt; meta-token embeddings. From the hidden state after a thought, a mixing head predicts how much to mix the logits produced with the thought versus the base logits without the thought. The reward for each sampled rationale is the difference in log-probability (over n_true future tokens) of the ground-truth future text under the mixed prediction for that rationale minus the average across sampled rationales; REINFORCE (with negative rewards clipped/excluded for stability) is used to increase likelihood of helpful rationales. A non-myopic teacher-forcing loss (predicting multiple tokens ahead) is included to stabilize learning. Parallel generation and a diagonal attention mask allow sampling rationales from all token positions efficiently.",
            "task_name": "GSM8K and CommonsenseQA (zero-shot direct-answer evaluation); also chain-of-thought augmentation (GSM8K cot-maj@8)",
            "task_description": "GSM8K: grade-school math word-problem benchmark requiring multi-step reasoning; CommonsenseQA: multiple-choice commonsense question-answering benchmark. Chain-of-thought evaluation refers to zero-shot CoT prompting and majority-vote over sampled CoT chains.",
            "performance_with_reflection": "OpenWebMath-trained Quiet-STaR: GSM8K zero-shot direct accuracy 10.9% (from 5.9% baseline); CommonsenseQA zero-shot direct accuracy 47.2% (from 36.3% baseline). C4-trained Quiet-STaR (16 thought tokens): GSM8K 8.1% (from 5.9%); CommonsenseQA 42.6% (from 36.3%). Chain-of-thought (zero-shot) majority-vote (8 samples) on a 128-item GSM8K sample: cot-maj@8 increased from 40.6% to 47.7% when using Quiet-STaR internal thoughts. The paper also reports perplexity improvements concentrated on difficult tokens in natural text (qualitative and distributional analyses).",
            "performance_without_reflection": "Base Mistral 7B (no Quiet-STaR): GSM8K zero-shot direct accuracy 5.9%; CommonsenseQA zero-shot direct accuracy 36.3%. Chain-of-thought majority baseline (cot-maj@8) was 40.6% on the 128-item GSM8K sample.",
            "has_performance_comparison": true,
            "mechanism_of_reflection": "Internal rationale generation as latent tokens (learned meta-tokens to start/end thoughts) inserted at each token position; parallel sampling via a diagonal/blocked attention mask to generate rationale candidates concurrently for many positions; mixing head (MLP) computes interpolation weight between base logits and post-rationale logits; reward = improvement in log-probability on multiple future tokens relative to mean across samples; REINFORCE applied to increase probability of useful rationales; non-myopic teacher-forcing (multiple tokens ahead) used to stabilize the learning signal.",
            "number_of_iterations": null,
            "evidence_for_improvement": "Quantitative: zero-shot direct-answer accuracy improvements on two reasoning benchmarks (GSM8K and CommonsenseQA) without task-specific finetuning; improvements increase with the number of tokens used in internal thoughts; chain-of-thought sampling accuracy (majority-vote) also improved when internal rationales are available during CoT generation; distributional analyses show improvements disproportionately concentrated on 'difficult' tokens and tokens where recalling relevant domain information helps (e.g., theorem names or proof steps); ablations (Appendix D) show multiple sampled rationales per token outperforms single-sample baselines and that predicting multiple tokens ahead (non-myopic loss) gives further gains.",
            "limitations_or_failure_cases": "Reported limitations: substantial computational overhead due to generating many rationale tokens per input token; initial distribution shift when introducing thoughts can harm performance (mitigated by the mixing head); Quiet-STaR as implemented does not dynamically predict when to generate or end a rationale (no learned stopping criterion); only evaluated as continued pretraining on a 7B model (unknown behavior when training from scratch or at other model scales); authors note training instability concerns which motivated excluding negative REINFORCE rewards (introduces bias); not all tokens benefit—improvements concentrate on difficult tokens; downstream-task performance curves sometimes deteriorate over continued training (roles of thought tokens may change); faithfulness of textual rationales to internal model computation is unknown; potential for harmful or biased reasoning patterns learned from web text; compute-normalized comparisons are included but the method requires extra compute. No exhaustive failure case catalog, but these limitations are explicitly discussed.",
            "comparison_to_other_methods": "Relation to STaR: Quiet-STaR generalizes STaR from discrete QA datasets to learning rationales from general web text and from per-problem accept/reject to a tokenwise REINFORCE reward across future-token likelihoods. Compared to pause-token fine-tuning (Goyal et al., 2023), Quiet-STaR (multi-token rationales) produces larger gains; pause tokens gave only minor gains on CommonsenseQA and harmed GSM8K in that prior work. Chain-of-thought (Kojima et al., 2022) is complementary: Quiet-STaR trains silent internal rationales that can be used during explicit CoT generation and improved CoT majority-vote accuracy. The paper situates Quiet-STaR alongside related iterative or self-generated-reasoning approaches (STaR, VSTaR, TRICE, Reflexion, Self-refine) but differs by training on general text and optimizing tokenwise latent rationales rather than training/verifying on curated task traces.",
            "ablation_study_results": "Appendix D reports: sampling multiple rationales per token consistently outperforms a single-sample baseline (≈ +0.5% GSM8K, +3% CommonsenseQA). Varying the number of sampled thoughts (2,3,4) gave consistent but small additional gains; more than two thoughts improved only by ~0.1–0.3%. Predicting more than one token ahead (non-myopic loss) improved GSM8K by ~0.3% and CommonsenseQA by ~3.1%, but beyond two tokens-ahead did not further improve the 12-thought-token baseline; rationales appear qualitatively more coherent with added tokens-ahead. The paper also provides compute-normalized plots (Appendix C) to contextualize gains versus extra inference calls.",
            "uuid": "e8934.0",
            "source_info": {
                "paper_title": "Quiet-STaR: Language Models Can Teach Themselves to Think Before Speaking",
                "publication_date_yy_mm": "2024-03"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Star: Bootstrapping reasoning with reasoning",
            "rating": 2
        },
        {
            "paper_title": "Think before you speak: Training language models with pause tokens",
            "rating": 2
        },
        {
            "paper_title": "Large Language Models are Zero-Shot Reasoners",
            "rating": 2
        },
        {
            "paper_title": "Reflexion: Language agents with verbal reinforcement learning",
            "rating": 2
        },
        {
            "paper_title": "Self-refine: Iterative refinement with self. Feedback",
            "rating": 2
        },
        {
            "paper_title": "TRICE: Training chain-of-thought via latent-variable inference",
            "rating": 1
        },
        {
            "paper_title": "V-star: Training verifiers for self-taught reasoners",
            "rating": 1
        }
    ],
    "cost": 0.01425075,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Quiet-STaR: Language Models Can Teach Themselves to Think Before Speaking</h1>
<p>Eric Zelikman<br>Stanford University</p>
<p>Nick Haber<br>Stanford University</p>
<p>Yijia Shao<br>Stanford University<br>Yijia Shao<br>Stanford University<br>Varuna Jayasiri<br>Notbad AI Inc</p>
<p>Noah D. Goodman
Stanford University</p>
<h4>Abstract</h4>
<p>When writing and talking, people sometimes pause to think. Although reasoning-focused works have often framed reasoning as a method of answering questions or completing agentic tasks, reasoning is implicit in almost all written text. For example, this applies to the steps not stated between the lines of a proof or to the theory of mind underlying a conversation. In the Self-Taught Reasoner (STaR, Zelikman et al. 2022), useful thinking is learned by inferring rationales from few-shot examples in question-answering and learning from those that lead to a correct answer. This is a highly constrained setting - ideally, a language model could instead learn to infer unstated rationales in arbitrary text. We present Quiet-STaR, a generalization of STaR in which LMs learn to generate rationales at each token to explain future text, improving their predictions. We address key challenges, including 1) the computational cost of generating continuations, 2) the fact that the LM does not initially know how to generate or use internal thoughts, and 3) the need to predict beyond individual next tokens. To resolve these, we propose a tokenwise parallel sampling algorithm, using learnable tokens indicating a thought's start and end, and an extended teacher-forcing technique. Encouragingly, generated rationales disproportionately help model difficult-to-predict tokens and improve the LM's ability to directly answer difficult questions. In particular, after continued pretraining of an LM on a corpus of internet text with Quiet-STaR, we find zero-shot improvements on GSM8K ( $5.9 \% \rightarrow 10.9 \%$ ) and CommonsenseQA ( $36.3 \% \rightarrow 47.2 \%$ ) and observe a perplexity improvement of difficult tokens in natural text. Crucially, these improvements require no fine-tuning on these tasks. Quiet-STaR marks a step towards LMs that can learn to reason in a more general and scalable way.</p>
<p>"Life can only be understood backwards; but it must be lived forwards."
— Sren Kierkegaard</p>
<h2>1 Introduction</h2>
<p>Much of the meaning of text is hidden between the lines: without understanding why statements appear in a document, a reader has only a shallow understanding. Moreover, this has been repeatedly shown to be true for LMs as well, in the contexts of tasks ranging from commonsense reasoning to theorem proving to programming (Wei et al., 2022b; Nye et al., 2021; Zelikman et al., 2022; 2023a; Kojima et al., 2022). Reasoning about implications of text to predict later text has consistently been shown to improve LM performance on a variety of tasks, but methods for allowing LMs to learn from their reasoning (e.g., Zelikman et al. 2022) have focused on solving individual tasks or predefined sets of tasks (e.g., Wei et al. 2021b). These works rely on carefully curated datasets to provide either specific reasoning tasks or in some cases, the reasoning itself. We instead ask, if reasoning is implicit in all text, why shouldn't we leverage the task of language modeling to teach reasoning?</p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Quiet-STaR. We visualize the algorithm as applied during training to a single thought. We generate thoughts, in parallel, following all tokens in the text (think). The model produces a mixture of its next-token predictions with and without a thought (talk). We apply REINFORCE, as in STaR, to increase the likelihood of thoughts that help the model predict future text while discarding thoughts that make the future text less likely (learn).</p>
<p>In particular, the Self-Taught Reasoner (STaR, [Zelikman et al. 2022]) showed that LMs can bootstrap their reasoning ability on question-answering (QA) datasets by sampling rationales to attempt to answer questions, training on rationales if they led to a correct final answer, and then repeating this to iteratively solve more difficult problems. Yet, training from curated QA datasets limits the scale and generalizability of the rationales. QA datasets, especially high-quality ones, require thoughtful curation and will inherently only ever cover a subset of reasoning tasks. Thus, we extend STaR - instead of the LM learning to reason on particular tasks like mathematical QA, we train an LM to generate reasoning that helps it infer future text from a large internet text corpus. As a result, we allow the LM to learn from the diverse tasks present in language (Weber et al., 2021). This builds on an intuition essential to the current language modeling paradigm, namely, that "language models are unsupervised multitask learners" (Radford et al., 2019). Thus, as in STaR, we leverage the LM's pre-existing reasoning ability to generate rationales and train the LM on them with a REINFORCE-based reward (Williams, 1992). We refer to this technique as Quiet-STaR, as it can be understood as applying STaR "quietly", training the model to think before it speaks.
Broadly, Quiet-STaR proceeds by generating rationales after every token to explain future text (think), mixing the future-text predictions with and without rationales (talk), and then learning to generate better rationales using REINFORCE (learn). We apply Quiet-STaR to Mistral 7B (Jiang et al., 2023) using the web text datasets OpenWebMath (Paster et al., 2023) and Colossal Clean Crawled Corpus (C4, Raffel et al. 2020). We find that, even without dataset-specific fine-tuning, Quiet-STaR results in improvements to zero-shot directreasoning abilities on CommonsenseQA ( $36.3 \% \rightarrow 47.2 \%$ ) and GSM8K ( $5.9 \% \rightarrow 10.9 \%$ ), and that these improvements consistently increase with the number of tokens used in the LM's internal thoughts. Lastly, we qualitatively investigate patterns in the generated rationales.
In solving this task, we make the following contributions:</p>
<ol>
<li>We generalize STaR to learn reasoning from diverse unstructured text data. To our knowledge, this is the first work explicitly training LMs to reason generally from text, rather than on curated reasoning tasks or collections of reasoning tasks.</li>
<li>We propose and implement a parallel sampling algorithm that makes our training procedure scalable, generating rationales from all token positions in a given string.</li>
<li>We introduce custom meta-tokens at the start and end of each thought to allow the LM to learn that it should be generating a rationale and when it should make a prediction based on that rationale.</li>
<li>We apply a mixing head to retrospectively determine how much to incorporate the next-token prediction from a given thought into the current next-token prediction.</li>
<li>We show that a non-myopic loss, including multiple tokens ahead for language modeling, improves the effect of thinking.</li>
<li>On multiple tasks, we demonstrate that thinking allows the LM to predict difficult tokens better than one trained on the same web text, improving with longer thoughts.</li>
</ol>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: Generalization Results. We evaluate the extent to which the model trained with Quiet-STaR generalizes to directly answering problems that require reasoning. The left plot (a) shows the zero-shot accuracy on GSM8K, while the right plot (b) shows the zero-shot accuracy on CommonsenseQA, without any fine-tuning. In both plots, the x-axis represents training steps, and each line corresponds to a different number of thinking tokens used during Quiet-STaR training. The y-axis measures the zero-shot direct accuracy on the respective datasets. We also include an inference normalized version of this plot in Figure 6.</p>
<h1>2 Related Work</h1>
<h3>2.1 Reasoning in Language Models</h3>
<p>There have been many works on training and exploiting language models to solve difficult tasks by first training them to reason through them. For example, Rajani et al. (2019) demonstrated that a pre-trained language model fine-tuned to output on human reasoning traces before answering multiple-choice commonsense reasoning questions outperformed one trained directly on answers. Shwartz et al. (2020) demonstrated that language models, when provided with some scaffolding, can generate these helpful chain-of-thought solutions without additional supervision. Later, Nye et al. (2021) demonstrated that "scratchpads" required less scaffolding when the language models were more capable, a result later reinforced by Wei et al. (2022b), emphasizing informal tasks, and further strengthened by Kojima et al. (2022), demonstrating this behavior could be accomplished zero-shot. Most recently, Wang \&amp; Zhou (2024) showed further that for commonsense-question answering, one could force a language model to leverage chain-of-thought reasoning by preventing it from emitting any valid answer tokens unless it was confident. However, once again, these approaches only work for a question-answer dataset, and Wang \&amp; Zhou (2024) relies on heuristics to identify when the model has output answer tokens. Somewhat like TRICE (Phan et al., 2023), we use the relative improvements in the log-likelihood of the target text across rationales as an estimate of quality, but we simply subtract the mean reward and do not incorporate more complex control variates.</p>
<h3>2.2 Training Language Models to Reason</h3>
<p>One direction that researchers have used to train language models to reason or improve their reasoning is training the language model on mined reasoning traces or reasoning-like data (Rajani et al., 2019; Wei et al., 2021a; Lewkowycz et al., 2022; Chung et al., 2022; Gunasekar et al., 2023). Although this approach has been demonstrated to be effective, it comes with drawbacks. It requires either manual annotation, which is sensitive to the capability of the annotators and is off-policy for the language model (i.e., the distribution of reasoning is not text that the language model would otherwise likely have generated). This approach is also expensive, difficult to scale, and provides no clear path to solving problems harder than those that the annotators are capable of solving.
Another direction for teaching reasoning relies on a language model's own generated reasoning, which can be seen as building on a large body of literature on self-play (Silver et al., 2017; Anthony et al., 2017; Polu \&amp; Sutskever, 2020). These include methods such as the</p>
<div class="codehilite"><pre><span></span><code><span class="nx">Algorithm</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="w"> </span><span class="nx">Quiet</span><span class="w"> </span><span class="k">Self</span><span class="o">-</span><span class="nx">Taught</span><span class="w"> </span><span class="nx">Reasoner</span><span class="w"> </span><span class="p">(</span><span class="nx">Quiet</span><span class="o">-</span><span class="nx">STaR</span><span class="p">)</span>
<span class="nx">Input</span><span class="p">:</span><span class="w"> </span><span class="nx">Language</span><span class="w"> </span><span class="nx">model</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">theta_</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span><span class="err">\</span><span class="p">),</span><span class="w"> </span><span class="nx">training</span><span class="w"> </span><span class="nx">steps</span><span class="w"> </span><span class="nx">num_steps</span><span class="p">,</span><span class="w"> </span><span class="nx">sequence</span><span class="w"> </span><span class="nx">length</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="nx">l</span><span class="err">\</span><span class="p">),</span><span class="w"> </span><span class="nx">thought</span><span class="w"> </span><span class="nx">length</span>
<span class="w">    </span><span class="err">\</span><span class="p">(</span><span class="nx">t</span><span class="err">\</span><span class="p">),</span><span class="w"> </span><span class="nx">learning</span><span class="w"> </span><span class="nx">rate</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">alpha</span><span class="err">\</span><span class="p">),</span><span class="w"> </span><span class="nx">batch</span><span class="w"> </span><span class="nx">size</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="nx">b</span><span class="err">\</span><span class="p">),</span><span class="w"> </span><span class="nx">number</span><span class="w"> </span><span class="nx">of</span><span class="w"> </span><span class="nx">thoughts</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="nx">n_</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="nx">thoughts</span><span class="w"> </span><span class="p">}}</span><span class="err">\</span><span class="p">),</span><span class="w"> </span><span class="nx">number</span><span class="w"> </span><span class="nx">of</span><span class="w"> </span><span class="nx">ground</span>
<span class="w">    </span><span class="nx">truth</span><span class="w"> </span><span class="nx">tokens</span><span class="w"> </span><span class="nx">used</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">supervising</span><span class="w"> </span><span class="nx">each</span><span class="w"> </span><span class="nx">thought</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="nx">n_</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="kc">true</span><span class="w"> </span><span class="p">}}</span><span class="err">\</span><span class="p">)</span>
<span class="nx">Output</span><span class="p">:</span><span class="w"> </span><span class="nx">Language</span><span class="w"> </span><span class="nx">model</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">theta</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">that</span><span class="w"> </span><span class="nx">generates</span><span class="w"> </span><span class="nx">rationales</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">predict</span><span class="w"> </span><span class="nx">future</span><span class="w"> </span><span class="nx">text</span>
<span class="k">for</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="nx">i</span><span class="p">=</span><span class="mi">0</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">num_steps</span><span class="w"> </span><span class="nx">do</span>
<span class="w">    </span><span class="nx">Sample</span><span class="w"> </span><span class="nx">batch</span><span class="w"> </span><span class="nx">of</span><span class="w"> </span><span class="nx">sequences</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="nx">X</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">of</span><span class="w"> </span><span class="nx">length</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="nx">l</span><span class="err">\</span><span class="p">)</span>
<span class="w">    </span><span class="err">\</span><span class="p">(</span><span class="nx">h</span><span class="o">^</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="nx">init</span><span class="w"> </span><span class="p">}}</span><span class="w"> </span><span class="err">\</span><span class="nx">leftarrow</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">hidden_states</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">theta_</span><span class="p">{</span><span class="nx">i</span><span class="p">}(</span><span class="nx">X</span><span class="p">)</span><span class="err">\</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="nx">j</span><span class="p">=</span><span class="mi">1</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="nx">l</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nx">parallel</span><span class="w"> </span><span class="nx">using</span><span class="w"> </span><span class="nx">attention</span><span class="w"> </span><span class="nx">mask</span><span class="w"> </span><span class="nx">do</span>
<span class="w">        </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">log</span><span class="w"> </span><span class="nx">p_</span><span class="p">{</span><span class="nx">j</span><span class="p">:</span><span class="w"> </span><span class="nx">j</span><span class="o">+</span><span class="nx">n_</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="kc">true</span><span class="w"> </span><span class="p">}}}</span><span class="o">^</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="nx">init</span><span class="w"> </span><span class="p">}}</span><span class="w"> </span><span class="err">\</span><span class="nx">leftarrow</span><span class="w"> </span><span class="err">\</span><span class="nx">operatorname</span><span class="p">{</span><span class="nx">lm</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nx">cdot</span><span class="w"> </span><span class="err">\</span><span class="nx">operatorname</span><span class="p">{</span><span class="nx">head</span><span class="p">}</span><span class="nx">_</span><span class="p">{</span><span class="err">\</span><span class="nx">theta_</span><span class="p">{</span><span class="nx">i</span><span class="p">}}</span><span class="err">\</span><span class="nx">left</span><span class="p">(</span><span class="nx">h_</span><span class="p">{</span><span class="nx">j</span><span class="p">:</span><span class="w"> </span><span class="nx">j</span><span class="o">+</span><span class="nx">n_</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="kc">true</span><span class="w"> </span><span class="p">}}}</span><span class="o">^</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="nx">init</span><span class="w"> </span><span class="p">}}</span><span class="err">\</span><span class="nx">right</span><span class="p">)</span><span class="w"> </span><span class="err">\</span><span class="nx">quad</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="o">/</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">Predict</span><span class="w"> </span><span class="nx">next</span><span class="w"> </span><span class="nx">tokens</span>
<span class="w">        </span><span class="err">\</span><span class="p">(</span><span class="nx">T_</span><span class="p">{</span><span class="nx">j</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nx">leftarrow</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">generate_tokens</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">theta_</span><span class="p">{</span><span class="nx">i</span><span class="p">}</span><span class="err">\</span><span class="nx">left</span><span class="p">(</span><span class="err">\</span><span class="nx">left</span><span class="p">[</span><span class="nx">X_</span><span class="p">{:</span><span class="w"> </span><span class="nx">j</span><span class="p">}</span><span class="w"> </span><span class="p">;&lt;</span><span class="err">\</span><span class="nx">right</span><span class="p">.</span><span class="err">\</span><span class="nx">right</span><span class="p">.</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">start_thought</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">left</span><span class="p">.&gt;],</span><span class="w"> </span><span class="nx">t</span><span class="p">,</span><span class="w"> </span><span class="nx">n_</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="nx">thoughts</span><span class="w"> </span><span class="p">}}</span><span class="err">\</span><span class="nx">right</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="o">/</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">Generate</span><span class="w"> </span><span class="nx">thought</span>
<span class="w">        </span><span class="err">\</span><span class="p">(</span><span class="nx">T_</span><span class="p">{</span><span class="nx">j</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nx">leftarrow</span><span class="err">\</span><span class="nx">left</span><span class="p">[</span><span class="nx">T_</span><span class="p">{</span><span class="nx">j</span><span class="p">}</span><span class="w"> </span><span class="p">;&lt;</span><span class="err">\</span><span class="nx">right</span><span class="p">.</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">end_thought</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">left</span><span class="p">.&gt;</span><span class="err">\</span><span class="nx">right</span><span class="p">]</span><span class="err">\</span><span class="p">)</span>
<span class="w">        </span><span class="err">\</span><span class="p">(</span><span class="nx">h_</span><span class="p">{</span><span class="nx">j</span><span class="p">:</span><span class="w"> </span><span class="nx">j</span><span class="o">+</span><span class="nx">n_</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="kc">true</span><span class="w"> </span><span class="p">}}}</span><span class="o">^</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="nx">thought</span><span class="w"> </span><span class="p">}}</span><span class="w"> </span><span class="err">\</span><span class="nx">leftarrow</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">hidden_states</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">theta_</span><span class="p">{</span><span class="nx">i</span><span class="p">}</span><span class="err">\</span><span class="nx">left</span><span class="p">(</span><span class="err">\</span><span class="nx">left</span><span class="p">[</span><span class="nx">X_</span><span class="p">{:</span><span class="w"> </span><span class="nx">j</span><span class="p">}</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="nx">T_</span><span class="p">{</span><span class="nx">j</span><span class="p">}</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="nx">X_</span><span class="p">{</span><span class="nx">j</span><span class="p">:</span><span class="w"> </span><span class="nx">j</span><span class="o">+</span><span class="nx">n_</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="kc">true</span><span class="w"> </span><span class="p">}}</span><span class="o">-</span><span class="mi">1</span><span class="p">}</span><span class="err">\</span><span class="nx">right</span><span class="p">]</span><span class="err">\</span><span class="nx">right</span><span class="p">)</span><span class="err">\</span><span class="p">)</span>
<span class="w">        </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">log</span><span class="w"> </span><span class="nx">p_</span><span class="p">{</span><span class="nx">j</span><span class="p">:</span><span class="w"> </span><span class="nx">j</span><span class="o">+</span><span class="nx">n_</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="kc">true</span><span class="w"> </span><span class="p">}}}</span><span class="o">^</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="nx">thought</span><span class="w"> </span><span class="p">}}</span><span class="w"> </span><span class="err">\</span><span class="nx">leftarrow</span><span class="w"> </span><span class="err">\</span><span class="nx">operatorname</span><span class="p">{</span><span class="nx">lm</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nx">cdot</span><span class="w"> </span><span class="err">\</span><span class="nx">operatorname</span><span class="p">{</span><span class="nx">head</span><span class="p">}</span><span class="nx">_</span><span class="p">{</span><span class="err">\</span><span class="nx">theta_</span><span class="p">{</span><span class="nx">i</span><span class="p">}}</span><span class="err">\</span><span class="nx">left</span><span class="p">(</span><span class="nx">h_</span><span class="p">{</span><span class="nx">j</span><span class="p">:</span><span class="w"> </span><span class="nx">j</span><span class="o">+</span><span class="nx">n_</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="kc">true</span><span class="w"> </span><span class="p">}}}</span><span class="o">^</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="nx">thought</span><span class="w"> </span><span class="p">}}</span><span class="err">\</span><span class="nx">right</span><span class="p">)</span><span class="w"> </span><span class="err">\</span><span class="nx">quad</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="o">/</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">Predict</span><span class="w"> </span><span class="nx">next</span><span class="w"> </span><span class="nx">tokens</span><span class="w"> </span><span class="nx">w</span><span class="o">/</span><span class="w"> </span><span class="nx">thought</span>
<span class="w">        </span><span class="err">\</span><span class="p">(</span><span class="nx">w_</span><span class="p">{</span><span class="nx">j</span><span class="p">:</span><span class="w"> </span><span class="nx">j</span><span class="o">+</span><span class="nx">n_</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="kc">true</span><span class="w"> </span><span class="p">}}}</span><span class="w"> </span><span class="err">\</span><span class="nx">leftarrow</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">mixing_head</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">theta_</span><span class="p">{</span><span class="nx">i</span><span class="p">}</span><span class="err">\</span><span class="nx">left</span><span class="p">(</span><span class="nx">h_</span><span class="p">{</span><span class="nx">j</span><span class="p">:</span><span class="w"> </span><span class="nx">j</span><span class="o">+</span><span class="nx">n_</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="kc">true</span><span class="w"> </span><span class="p">}}}</span><span class="o">^</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="nx">thought</span><span class="w"> </span><span class="p">}},</span><span class="w"> </span><span class="nx">h_</span><span class="p">{</span><span class="nx">j</span><span class="p">:</span><span class="w"> </span><span class="nx">j</span><span class="o">+</span><span class="nx">n_</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="kc">true</span><span class="w"> </span><span class="p">}}}</span><span class="o">^</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="nx">init</span><span class="w"> </span><span class="p">}}</span><span class="err">\</span><span class="nx">right</span><span class="p">)</span><span class="err">\</span><span class="p">)</span>
<span class="w">        </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">log</span><span class="w"> </span><span class="nx">p_</span><span class="p">{</span><span class="nx">j</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="nx">talk</span><span class="w"> </span><span class="p">}}</span><span class="w"> </span><span class="err">\</span><span class="nx">leftarrow</span><span class="w"> </span><span class="nx">w_</span><span class="p">{</span><span class="nx">j</span><span class="p">:</span><span class="w"> </span><span class="nx">j</span><span class="o">+</span><span class="nx">n_</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="kc">true</span><span class="w"> </span><span class="p">}}}</span><span class="w"> </span><span class="err">\</span><span class="nx">cdot</span><span class="w"> </span><span class="err">\</span><span class="nx">log</span><span class="w"> </span><span class="nx">p_</span><span class="p">{</span><span class="nx">j</span><span class="p">:</span><span class="w"> </span><span class="nx">j</span><span class="o">+</span><span class="nx">n_</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="kc">true</span><span class="w"> </span><span class="p">}}}</span><span class="o">^</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="nx">init</span><span class="w"> </span><span class="p">}}</span><span class="o">+</span><span class="err">\</span><span class="nx">left</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="nx">w_</span><span class="p">{</span><span class="nx">j</span><span class="p">:</span><span class="w"> </span><span class="nx">j</span><span class="o">+</span><span class="nx">n_</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="kc">true</span><span class="w"> </span><span class="p">}}}</span><span class="err">\</span><span class="nx">right</span><span class="p">)</span><span class="w"> </span><span class="err">\</span><span class="nx">cdot</span><span class="w"> </span><span class="err">\</span><span class="nx">log</span><span class="w"> </span><span class="nx">p_</span><span class="p">{</span><span class="nx">j</span><span class="p">:</span><span class="w"> </span><span class="nx">j</span><span class="o">+</span><span class="nx">n_</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="kc">true</span><span class="w"> </span><span class="p">}}}</span><span class="o">^</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="nx">thought</span><span class="w"> </span><span class="p">}}</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="o">/</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">Mix</span><span class="w"> </span><span class="nx">logits</span>
<span class="w">        </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">mathcal</span><span class="p">{</span><span class="nx">L</span><span class="p">}</span><span class="nx">_</span><span class="p">{</span><span class="nx">j</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="err">\</span><span class="nx">mathrm</span><span class="p">{</span><span class="nx">NLL</span><span class="p">}}</span><span class="w"> </span><span class="err">\</span><span class="nx">leftarrow</span><span class="o">-</span><span class="err">\</span><span class="nx">log</span><span class="w"> </span><span class="nx">p_</span><span class="p">{</span><span class="nx">j</span><span class="p">:</span><span class="w"> </span><span class="nx">j</span><span class="o">+</span><span class="nx">n_</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="kc">true</span><span class="w"> </span><span class="p">}}}</span><span class="o">^</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="nx">talk</span><span class="w"> </span><span class="p">}}</span><span class="err">\</span><span class="nx">left</span><span class="p">(</span><span class="nx">X_</span><span class="p">{</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="w"> </span><span class="nx">j</span><span class="o">+</span><span class="nx">n_</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="kc">true</span><span class="w"> </span><span class="p">}}</span><span class="o">+</span><span class="mi">1</span><span class="p">}</span><span class="err">\</span><span class="nx">right</span><span class="p">)</span><span class="err">\</span><span class="p">)</span>
<span class="w">        </span><span class="err">\</span><span class="p">(</span><span class="nx">r_</span><span class="p">{</span><span class="nx">j</span><span class="p">}=</span><span class="err">\</span><span class="nx">log</span><span class="w"> </span><span class="nx">p_</span><span class="p">{</span><span class="nx">j</span><span class="p">:</span><span class="w"> </span><span class="nx">j</span><span class="o">+</span><span class="nx">n_</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="kc">true</span><span class="w"> </span><span class="p">}}}</span><span class="o">^</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="nx">talk</span><span class="w"> </span><span class="p">}}</span><span class="err">\</span><span class="nx">left</span><span class="p">(</span><span class="nx">X_</span><span class="p">{</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="w"> </span><span class="nx">j</span><span class="o">+</span><span class="nx">n_</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="kc">true</span><span class="w"> </span><span class="p">}}</span><span class="o">+</span><span class="mi">1</span><span class="p">}</span><span class="err">\</span><span class="nx">right</span><span class="p">)</span><span class="o">-</span><span class="err">\</span><span class="nx">log</span><span class="w"> </span><span class="err">\</span><span class="nx">bar</span><span class="p">{</span><span class="nx">p</span><span class="p">}</span><span class="nx">_</span><span class="p">{</span><span class="nx">j</span><span class="p">:</span><span class="w"> </span><span class="nx">j</span><span class="o">+</span><span class="nx">n_</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="kc">true</span><span class="w"> </span><span class="p">}}}</span><span class="o">^</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="nx">talk</span><span class="w"> </span><span class="p">}}</span><span class="err">\</span><span class="nx">left</span><span class="p">(</span><span class="nx">X_</span><span class="p">{</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="w"> </span><span class="nx">j</span><span class="o">+</span><span class="nx">n_</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="kc">true</span><span class="w"> </span><span class="p">}}</span><span class="o">+</span><span class="mi">1</span><span class="p">}</span><span class="err">\</span><span class="nx">right</span><span class="p">)</span><span class="err">\</span><span class="p">)</span>
<span class="w">        </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">nabla_</span><span class="p">{</span><span class="err">\</span><span class="nx">theta</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nx">mathcal</span><span class="p">{</span><span class="nx">L</span><span class="p">}</span><span class="nx">_</span><span class="p">{</span><span class="nx">j</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="nx">REINFORCE</span><span class="w"> </span><span class="p">}}</span><span class="w"> </span><span class="err">\</span><span class="nx">leftarrow</span><span class="o">-</span><span class="nx">r_</span><span class="p">{</span><span class="nx">j</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nx">mathbb</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span><span class="err">\</span><span class="nx">left</span><span class="p">[</span><span class="nx">r_</span><span class="p">{</span><span class="nx">j</span><span class="p">}&gt;</span><span class="mi">0</span><span class="err">\</span><span class="nx">right</span><span class="p">]</span><span class="w"> </span><span class="err">\</span><span class="nx">cdot</span><span class="w"> </span><span class="err">\</span><span class="nx">nabla_</span><span class="p">{</span><span class="err">\</span><span class="nx">theta</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nx">log</span><span class="w"> </span><span class="nx">p_</span><span class="p">{</span><span class="err">\</span><span class="nx">theta_</span><span class="p">{</span><span class="nx">i</span><span class="p">}}</span><span class="err">\</span><span class="nx">left</span><span class="p">(</span><span class="nx">T_</span><span class="p">{</span><span class="nx">j</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nx">mid</span><span class="err">\</span><span class="nx">left</span><span class="p">[</span><span class="nx">X_</span><span class="p">{:</span><span class="w"> </span><span class="nx">j</span><span class="p">}</span><span class="w"> </span><span class="p">;&lt;</span><span class="err">\</span><span class="nx">right</span><span class="p">.</span><span class="err">\</span><span class="nx">right</span><span class="p">.</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">start_thought</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">left</span><span class="p">.</span><span class="err">\</span><span class="nx">left</span><span class="p">.&gt;</span><span class="err">\</span><span class="nx">right</span><span class="p">]</span><span class="err">\</span><span class="nx">right</span><span class="p">)</span><span class="err">\</span><span class="p">)</span>
<span class="w">        </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">nabla_</span><span class="p">{</span><span class="err">\</span><span class="nx">theta</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nx">mathcal</span><span class="p">{</span><span class="nx">L</span><span class="p">}</span><span class="nx">_</span><span class="p">{</span><span class="nx">j</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nx">leftarrow</span><span class="w"> </span><span class="err">\</span><span class="nx">nabla_</span><span class="p">{</span><span class="err">\</span><span class="nx">theta</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nx">mathcal</span><span class="p">{</span><span class="nx">L</span><span class="p">}</span><span class="nx">_</span><span class="p">{</span><span class="nx">j</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="err">\</span><span class="nx">mathrm</span><span class="p">{</span><span class="nx">NLL</span><span class="p">}}</span><span class="o">+</span><span class="err">\</span><span class="nx">nabla_</span><span class="p">{</span><span class="err">\</span><span class="nx">theta</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nx">mathcal</span><span class="p">{</span><span class="nx">L</span><span class="p">}</span><span class="nx">_</span><span class="p">{</span><span class="nx">j</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="nx">REINFORCE</span><span class="w"> </span><span class="p">}}</span><span class="err">\</span><span class="p">)</span>
<span class="w">    </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">theta_</span><span class="p">{</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nx">leftarrow</span><span class="w"> </span><span class="err">\</span><span class="nx">theta_</span><span class="p">{</span><span class="nx">i</span><span class="p">}</span><span class="o">-</span><span class="err">\</span><span class="nx">alpha</span><span class="w"> </span><span class="err">\</span><span class="nx">sum_</span><span class="p">{</span><span class="nx">j</span><span class="p">=</span><span class="mi">1</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="nx">l</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nx">nabla_</span><span class="p">{</span><span class="err">\</span><span class="nx">theta</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nx">mathcal</span><span class="p">{</span><span class="nx">L</span><span class="p">}</span><span class="nx">_</span><span class="p">{</span><span class="nx">j</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nx">quad</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="o">/</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">Update</span><span class="w"> </span><span class="nx">model</span><span class="w"> </span><span class="nx">parameters</span>
<span class="k">return</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">theta_</span><span class="p">{</span><span class="err">\</span><span class="nx">text</span><span class="w"> </span><span class="p">{</span><span class="nx">num_steps</span><span class="w"> </span><span class="p">}}</span><span class="err">\</span><span class="p">)</span>
</code></pre></div>

<p>Self-Taught Reasoner (Zelikman et al., 2022), which demonstrated that a language model iteratively trained on its reasoning that led to correct answers could solve increasingly difficult problems. Later work aimed to leverage additional information or assumptions such as Huang et al. (2022) which demonstrated that the algorithm proposed in STaR could still work if one assumed that the majority-vote answer was correct (although this has a lower ultimate performance). Further work has generalized the results of Zelikman et al. (2022), such as Uesato et al. (2022) which demonstrated additional usefulness to "process-based" supervision where incorrect reasoning traces were filtered, recently VSTaR (Hosseini et al., 2024) that demonstrates that training a verifier to guide generation also improves performance, as well as TRICE (Hoffman et al., 2024) which maximizes the marginal likelihood of the correct answer given several reasoning traces per problem. Finally, related work has also explored learning intermediate reasoning in the constrained setting of making mathematical statements, where statements in the model's intermediate reasoning could be constrained to only be valid mathematical statements (Poesia et al., 2023). We include further discussion of related reasoning works in Appendix F.</p>
<h1>2.3 Meta-tokens</h1>
<p>Recently, a growing body of work has demonstrated the usefulness of custom tokens optimized to perform specific functions in the context of a neural network - for this reason, they have also been referred to as "function vectors." (Todd et al., 2023). One of the original instantiations of this was prompt-tuning (Lester et al., 2021) (and relatedly prefix-tuning (Li \&amp; Liang, 2021)), where the embeddings corresponding to the tokens of a prompt could be optimized to better accomplish a task. Others have applied meta-tokens to compress long prompts (Li et al., 2023; Jung \&amp; Kim, 2023) for efficiency. Most relevant to this work, Mu et al. (2024) optimized a token such that, when the tokens after it could not attend to the tokens before it (i.e., a context compression token), it would provide sufficient information to future tokens. Although we do not focus on compression, we share the problem of learning a</p>
<p>token that affects attention and controls complex downstream behavior. In one related work, Goyal et al. (2023) show that learning a single "pause" token (essentially representing each token as two tokens) improves LM performance. However, unlike the thought tokens in our work, this pause token does not initialize a thought - instead, it can be seen as acting as the entirety of the thought. We find that reasoning in language is significantly more helpful.</p>
<h1>3 Problem Statement</h1>
<p>In this work, we introduce an auxiliary 'rationale' variable between each pair of observed tokens of the sequence. We then aim to optimize a language model with parameters $\theta$ with the capacity to generate intermediate thoughts (or rationales) such that</p>
<p>$$
\theta^{*}=\arg \max <em x="x">{\theta} E</em>}\left[\log p_{\theta}\left(x_{i: n} \mid x_{0: i}, \text { rationale <em 0:="0:" i="i">{\theta}\left(x</em>\right)\right)\right]
$$</p>
<p>Note that, in principle, this provides no advantage over an optimal language model that already correctly models the language's distribution over strings. Yet, in practice, extensive prior work has shown that language models benefit from intermediate rationales on reasoning tasks (Nye et al., 2021; Zelikman et al., 2022; Wei et al., 2022b). Some work has aimed to explain the effects of chain-of-thought reasoning, namely attributing it to "locality of experience" (Prystawski et al., 2024). More broadly, reasoning allows a model to decompose a challenging computation into smaller steps. In effect, we train the model to learn which decomposition and planning steps are effective in predicting future text. Also note that we formulate the objective as accurately predicting the remaining sequence, rather than only the next token. Once again, for an optimal LM these would be equivalent. However we find that the non-myopic formulation leads to a more effective loss for learning rationales.</p>
<h2>4 Quiet-STaR</h2>
<h3>4.1 Overview</h3>
<p>Quiet-STaR operates with three main steps (Figure 1):</p>
<ol>
<li>Parallel rationale generation (think, Subsection 4.2): In parallel across $n$ tokens $x_{i}$ in an input sequence $x_{0: n}$, we generate $r$ rationales of length $t: c_{i}=\left(c_{i 1}, \ldots, c_{i t}\right)$, resulting in $n \times r$ rationale candidates. We insert learned $&lt;|$ startofthought $&gt;$ and $&lt;|$ endofthought $&gt;$ tokens to mark each rationale's start and end.</li>
<li>Mixing post-rationale and base predictions (talk, Subsection 4.3): From the hidden state output after each rationale, we train a "mixing head" - a shallow MLP producing a weight determining how much the post-rationale next-token predicted logits should be incorporated compared to the base language model predicted logits. This approach eases distribution shift early in finetuning, due to introducing rationales.</li>
<li>Optimizing rationale generation (learn, Subsection 4.4): We optimize the rationale generation parameters (start/end tokens and LM weights) to increase the likelihood of rationales that make future text more probable. We use REINFORCE to provide a learning signal to rationales based on their impact on future-token prediction. To reduce variance, we apply a teacher-forcing trick to include in the loss the likelihood of predicting not only the token after the thought but also later tokens.</li>
</ol>
<h3>4.2 Parallel Generation</h3>
<p>A key challenge in Quiet-STaR is efficiently generating rationales at each token position in the input sequence. Naively, this would require a separate forward pass for each token, which becomes computationally intractable for long sequences.</p>
<p>We allow for highly parallel generation by first observing that an inference pass of a language model produces a probability distribution over the next tokens for all input tokens. Naturally, this allows us to sample one next token from each token in the input. If one has generated a successor from each token, it is not possible to simply continue with the original sequence. For example, imagine predicting the next token after each token of " $&lt;$ bos $&gt;$ the cat sat" one might generate "yes orange saw down" - each successor by itself is a reasonable next token</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: Parallel Generation. By constructing an attention mask that allows all thought tokens to pay attention to themselves, all preceding thought tokens within the same thought, and the preceding text, we can generate continuations of all of the thoughts in parallel. Each inference call is used to generate one additional thought token for all text tokens.
to a prefix of the sequence, but the list of tokens is a set of "counterfactual" continuations of these prefixes. We can, however, leverage these continuations to generate hidden thoughts for each observed token.</p>
<p>To do this efficiently, we cache each forward pass and concatenate a diagonal attention mask to the previous attention mask: each generated token now attends to all of the tokens that were used to generate it, as well as to itself (but not to token on other "counterfactual" paths). Moreover, this parallelized next-sampling token procedure can be repeated arbitrarily many times (or at least, until one runs out of memory). We visualize this procedure in Figure 3 and highlight additional ways to make this algorithm faster in Appendix B.</p>
<h1>4.3 "Mixing" (Residual) Heads</h1>
<p>When starting with a pre-trained model, thoughts will initially be out of distribution, and hence harm language modeling performance. To smooth the transition to thinking, we introduce a learned interpolation between the LM predictions with and without thoughts. Given the end-of-thought token's hidden state and the hidden state of the original text token, the mixing head outputs a weight that determines the extent to which the postthought prediction logits will be used. We use a shallow multi-layer perceptron for this head, outputting a scalar for each token. We include implementation details in Appendix A.</p>
<h3>4.4 Optimizing Rationale Generation</h3>
<h3>4.4.1 Optimizing Start-of-Thought and End-of-Thought Tokens</h3>
<p>The $&lt;|$ startofthought $\mid&gt;$ and $&lt;|$ endofthought $\mid&gt;$ tokens serve as learned meta-tokens that control the model's rationale generation. Optimizing the representation of these tokens, especially the $&lt;|$ startofthought $\mid&gt;$ token, is crucial but challenging due to the discrete nature of the rationale tokens. We initialize the start and end token embeddings to the embedding corresponding to the em dash, "---", which often appears in text data to denote a pause or thought. This leverages the language model's preexisting knowledge. In addition, to allow these embeddings to be optimized more quickly, we apply a (hyperparameter) weight to the gradients of these embeddings during the update step. Intuitively, the start thought tokens can be understood as putting the model into a "thinking mode" and the end thought token can be understood as telling the model when it's done thinking.</p>
<h3>4.4.2 Non-myopic Scoring and Teacher-forcing</h3>
<p>Because we do not expect thoughts to be useful in predicting every token, we would prefer the model's reward to depend less on the exact next word in the text following the thought and more on the following semantic content. There are two primary challenges here. First, unlike in typical language modeling with transformers, only the thoughts corresponding to</p>
<p><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 4: Forward Pass and Teacher Forcing. We visualize a single forward pass of our algorithm. Solid lines denote language model computation, while dashed lines indicate tokens are inserted via teacher forcing, and the mixer represents the mixing head. In particular, we visualize predicting three tokens ahead. Thought generation is shown in more detail in Figure 1 and Figure 3.
a given next-token prediction receive a gradient from that prediction-a consequence of our parallel sampling strategy. We could address this by adding loss terms for future tokens by sampling the tokens before. However this would result in much higher entropy for language modeling in general and lower-quality generated text, because it would train the LM to partially disregard its preceding tokens. Instead, we use the parallel attention mask to compute the log probabilities of the true next tokens, applying teacher forcing by assuming the model selected the correct next ground-truth token (as implicit in normal language modeling with transformers). Note that the loss for each future token also depends on a mixing weight computed from the end thought token and the previous observed token. The number of future tokens included in the loss is a hyper-parameter. We apply the same teacher-forcing technique to insert the start and end tokens. We visualize this procedure in Figure 4.</p>
<h1>4.4.3 Objective</h1>
<p>We use REINFORCE to optimize the likelihoods of the rationales based on their usefullness: the log-likelihood of the $n_{\text {true }}$ true next tokens $X_{j+1: j+n_{\text {true }}+1}$ under the language model given previous observed tokens and a particular rationale ( $p_{j: j+n_{\text {true }}}^{\text {talk }}$ as shorthand for the mixed prediction probabilities after thinking, see Algorithm 1). To reduce variance, we generate multiple rationale continuations for each token in the input sequence (loosely inspired by TRICE, Phan et al. (2023)). We thus define the reward $r_{j}$ for each rationale $T_{j}$ as the difference between $p_{j: j+n_{\text {true }}}^{\text {talk }}$ and the average across rationales for that token $\left(\bar{p}<em _text="\text" _true="{true">{j: j+n</em>\right)$ :}}}^{\text {talk }</p>
<p>$$
r_{j}=\log p_{j: j+n_{\text {true }}}^{\text {talk }}\left(X_{j+1: j+n_{\text {true }}+1}\right)-\log \bar{p}<em _text="\text" _true="{true">{j: j+n</em>\right)
$$}}}^{\text {talk }}\left(X_{j+1: j+n_{\text {true }}+1</p>
<p>We then use this reward in a REINFORCE loss term to update the language model parameters $\theta$ to increase the likelihood of rationales that perform better than the average:</p>
<p>$$
\nabla_{\theta} \mathcal{L}<em j="j">{j}^{\text {REINFORCE }}=-r</em> \mid&gt;\right]\right)
$$} \cdot \nabla_{\theta} \log p_{\theta}\left(T_{j} \mid\left[X_{: j} ;&lt;\mid \text { startof thought </p>
<p>We found it useful to exclude the negative reward from the REINFORCE loss term, as it led to more stable training, though it may introduce some bias.
This loss term encourages the model to generate rationales that improve its predictions of future tokens compared to the average prediction across all generated rationales for that token. The gradients from this loss are used to update both the LM parameters and the start-of-thought and end-of-thought token embeddings, with a (hyperparameter) weight applied to the gradients of the start-of-thought and end-of-thought token embeddings to accelerate their optimization. By iteratively optimizing these parameters, Quiet-STaR trains the model to generate more useful rationales throughout training. Lastly, we also include a log-likelihood loss, $\mathcal{L}_{j}^{\text {NLL }}$, to ensure that the LM learns to optimize the talking heads and also receives a next-token prediction signal for the base LM head ${ }^{1}$.</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<h1>5 Experiments and Results</h1>
<p>Intuitively, not all tokens require equal amounts of thought. For example, consider the sentence "the person is run-": although there is inevitably some probability of the token being something other than "ing"2, as a standalone sentence without context, additional thinking is unlikely to improve a well-trained model's prediction. Indeed, we conjecture that for most chunks of most online text, additional thought has little to no impact. Indeed, early in our exploration we observed that Quiet-STaR does not benefit all tokens equally. Thus, we design our experiments to investigate whether our approach is useful in predicting tokens that do require thought. We evaluate 1) whether Quiet-STaR improves a language model's ability to directly predict answers in datasets that require reasoning; and, 2) the distribution of impacts resulting from thinking tokens. We conduct all of our experiments starting with the base version of Mistral 7B (Jiang et al., 2023).
We perform most of our experiments by training on OpenWebMath (Paster et al., 2023), a crawl that emphasizes more technical webpages. We selected OpenWebMath because we anticipated that it would have a higher density of tokens that benefit from reasoning, which our experiments support. We also evaluate Quiet-STaR on C4 (Raffel et al., 2020), a widely used LM pretraining corpus with more diverse text, and again show significant albeit smaller benefits.</p>
<h3>5.1 Downstream Performance</h3>
<p>In this subsection, we evaluate the extent to which Quiet-STaR improves the zero-shot reasoning capabilities of the language model on CommonsenseQA (Talmor et al., 2018) and GSM8K (Cobbe et al., 2021). On CommonsenseQA, we find that Quiet-STaR improves performance by $10.9 \%$ compared to the base language model. As shown in Figure 2, this improvement consistently increases with the number of tokens used in the model's rationales, indicating that more thorough reasoning through the thought tokens is translating to better direct question-answering performance. Similarly, on GSM8K, Quiet-STaR results in a $5.0 \%$ boost over the base model, and once again, performance scales with the length of the rationales generated during Quiet-STaR training. For reference, in Figure 2, we include a baseline corresponding to training the same model on the same dataset without thought tokens. We observe that in multiple curves, performance appears to eventually deteriorate - we anticipate that this is because we are not training on these downstream tasks, so the roles of the thought tokens may change over time. We also find a benefit of our non-myopic objective, which we discuss in Appendix D.
We find that training with Quiet-STaR on C4 (Raffel et al., 2020) also improves performance on GSM8K ( $5.9 \% \rightarrow 8.1 \%$ ) and CommonsenseQA ( $36.3 \% \rightarrow 42.6 \%$ ) but by a smaller margin. Specifically, for our C4 evaluation, we train Mistral 7B with 16 thought tokens and 4 true tokens ahead and otherwise the same setup.
We can compare these improvements to those offered by pause tokens (Goyal et al., 2023), which can be seen as a constrained version of Quiet-STaR where each token is represented by two tokens and the second "pause" token acts as the entirety of the thought. In particular, our setup is most comparable to their pause token fine-tuning, as we also finetune a pretrained model. Their results indicate that pause token fine-tuning also provides minor gains over the base model on CommonsenseQA, they observed an improvement from $26.9 \%$ to $28.8 \%$; on GSM8K, Goyal et al. (2023) found that pause token fine-tuning harms performance. Moreover, on both tasks (and the majority of their evaluated tasks), they observed that additional thought tokens harmed performance. Moreover, they discuss the "lukewarm effect of pause-finetuning a standard-pretrained model" (Goyal et al., 2023). This suggests that allowing the model to generate multi-token rationales leads to more effective reasoning compared to the single-token "pauses". Note however, that unlike Goyal et al. (2023), we do not fine-tune on the downstream tasks.
Overall, these downstream results validate that training a language model to predict the subtext between the lines of general text data can substantially improve its reasoning</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 5: Zero-shot performance on Quiet-STaR applied to chain-of-thought on GSM8K. We visualize how using a Quiet-STaR trained Mistral model can improve chain-of-thought performance. We use an 8-thought-token-trained model and use its internal thoughts to improve the tokens in a zero-shot chain-of-thought (Kojima et al., 2022)
capabilities, even on datasets it was not explicitly trained on. The fact that longer rationales consistently lead to better outcomes, and that Quiet-STaR outperforms the constrained pause token approach, supports the notion that Quiet-STaR is successfully teaching the model to leverage its own generated thoughts to reason more thoroughly about the input.</p>
<h1>5.2 Improvement Distribution</h1>
<p>As visualized in Appendix Figure 7, we find that on average there is little improvement in the LM's ability to predict arbitrary tokens. But, when we visualize the distribution of relative improvements, there is a disproportionate improvement on more difficult tokens. This reflects the idea that some text tokens are substantially harder and benefit more from careful thought.</p>
<p>In Appendix Figure 8, we aim to provide some insight into the kinds of tokens where the improvements occur. Namely, while thinking appears to help for many tokens in the example, inspection suggests it disproportionately help to predict tokens where recalling relevant information is useful, such as the name of an applicable theorem or the start of the next step in a proof. Notably, this would align well with the framing proposed by Prystawski et al. (2024).</p>
<h3>5.3 Quiet-STaR and Chain-of-Thought</h3>
<p>While there are natural parallels between chain-of-thought prompting and our approach, they are orthogonal and complementary. In zero-shot chain-of-thought, a user actively prompts the model to think 'out loud', otherwise using its ordinary production distribution (Kojima et al., 2022); Quiet-STaR instead allows a model to think quietly at every token, with a distribution trained to be useful. We investigate using silent, Quiet-STaR, rationales while generating explicit CoT reasoning. Because our goal is generalist reasoning that requires no task-specific input at all, we used a zero-shot prompt ("Let's think step by step.") without in-context examples. Our experiments indicate that internal rationales allow the model to generate more structured and coherent chains of thought, shown in Appendix E and visualized in Figure 5. The majority vote accuracy over 8 samples (cot-maj@8) increases from $40.6 \%$ to $47.7 \%$ with Quiet-STaR, as evaluated on a sample of 128 GSM8K test items. Note that each chain-of-thought solution is sampled with temperature 0.7 .</p>
<h3>5.4 Examples</h3>
<p>While there is no explicit regularization in Quiet-STaR for thoughts to be humaninterpretable, they are generated from the same transformer trained to model language, hence likely to be at least partially understandable. We discuss why this design choice benefits the training stability in Appendix 1. For reference, we include examples of thoughts generated that were helpful to the model in predicting future tokens in OpenWebMath. First, in one case, recalling that one should start with magnesium to produce magnesium nitride allows it to better predict that the first step of the procedure involves heating magnesium.</p>
<p>'<s> # Magnesium reacts with nitrogen to form magnesium nitride. The chemical formula for this reaction is $\mathrm{Mg}+\mathrm{N} _2-&gt;\mathrm{MgN} _\mathrm{2}$. What is the product, or what are the products, of this reaction? \n\nJan 12, 2016\n\nThe formula for magnesium nitride is $\$ \mathrm{M}{\mathrm{g}}_{3}{\mathrm{N}}_{2} \$ . \backslash \mathrm{n} \backslash \mathrm{n} # # # #$ Explanation: \n\nAs do many active metals, magnesium nitride can be&lt;|startofthought|&gt; 1 --, so the equation of the reaction that forms magnesium nitride is $\backslash n \backslash n \$ M g+N _2 \backslash \backslash$ to &lt;|endofthought|&gt; formed by heating the metal (fier'</p>
<p>In some cases, the most useful thoughts appear to be near-continuations that correspond more closely to the target text, e.g.,
An integer $\$ n \$$ is odd if $\$ n=2 k+1 \$$ for some integer $\$ k \$ . \backslash n \backslash n$ To prove that $\$ A=$ B\$, we must show that \$A \subseteq B\$ and \$B \subseteq A\$. The first of these tends to&lt;|startthought|&gt; in some sense - to be the more difficult&lt;| endthought|&gt; trickiest for students</p>
<p>Lastly, we include an example from answering CommonsenseQA. Notably, this thought occurs while reading the question and hence was not used to predict the final answer.
'<s> Q: Talking to the same person about the same thing over and over again is &lt;|startofthought|&gt;\n\n(a) a one-to-one correlation\n\n(b) a one-to&lt;| endofthought|&gt; something someone can what?'</p>
<h1>6 Limitations</h1>
<p>This work proposes a new framework for learning to reason, and in doing so explores solutions to a variety of meta-learning challenges. However, to solve these challenges, certain simplifications were necessary. For example, it would be valuable to understand whether these techniques work when a model is trained from scratch. We have also only applied Quiet-STaR to a 7 billion parameter model, albeit a powerful one. The same techniques applied to a better model would likely yield disproportionately better results, as has often been observed for gains from reasoning (Wei et al., 2022a).
Quiet-STaR results in a substantial overhead, generating many tokens before generating every additional token. (See Appendix C for compute adjusted performance results.) However, this can also be seen as an advantage: typically, a language model can generate the next token based on the current context, and while there are techniques to improve sampling quality, there is no general way to leverage additional compute to enhance next-token prediction. In the current implementation we do not support dynamically predicting when to generate, or end, a rationale. However, this would be a natural extension. For instance, if the mixing head was a prediction from the base language model, before any thought, rather than after the thought, one could apply a threshold to prevent generating thoughts that would not be incorporated. We expect that this is a more difficult task, as predicting the usefulness of a thought is simpler when one has already generated the thought.</p>
<h2>7 Conclusion</h2>
<p>Quiet-STaR represents a step towards language models that can learn to reason in a general and scalable way. By training on the rich spectrum of reasoning tasks implicit in diverse web text, rather than narrowly specializing for particular datasets, Quiet-STaR points the way to more robust and adaptable language models. Our results demonstrate the promise of this approach, with Quiet-STaR improving downstream reasoning performance while generating qualitatively meaningful rationales. We believe this also opens many potential future directions - for example, one may aim to ensemble thoughts in order to further improve the predictions for future tokens. Moreover, if the language model can predict when thought will be useful, for example by putting the mixing head before the prediction, then the predicted mixing weight could be used to dynamically allocate compute during generation. Future work can build on these insights to further close the gap between language model and human-like reasoning capabilities.</p>
<h1>Ethics Statement</h1>
<p>This work raises some important ethical questions, many of which also apply to STaR. For example, it is impossible to know that the reasoning expressed by the model in language accurately represents the internal processing of the model (i.e., faithfulness). In addition, regardless of faithfulness, there are no safeguards against harmful or biased reasoning patterns if the model finds them useful. Relatedly, we note that CommonsenseQA is known to have many biased questions and low-quality answers (Geva et al., 2019), but we use it in line with prior work (Zelikman et al., 2022; Goyal et al., 2023). Thus, aside from improving language modeling, it is unclear in what capacity the rationales themselves should be used.</p>
<h2>Acknowledgements</h2>
<p>We particularly thank Xindi Wu, Michael Li, and Qian Huang for their helpful and detailed comments, as well as Xuechen Li, Jan-Philipp Fränken, Yuhuai Wu, Gabriel Poesia, Winnie Xu, Omar Shaikh, Fan-Yun Sun, Joy He-Yueya, Omar Khattab, and William Yin for useful discussions. In addition, we would like to acknowledge that this work was supported by NSF Grant #2302701.</p>
<h2>References</h2>
<p>Thomas Anthony, Zheng Tian, and David Barber. Thinking fast and slow with deep learning and tree search. Advances in neural information processing systems, 30, 2017.</p>
<p>Baian Chen, Chang Shu, Ehsan Shareghi, Nigel Collier, Karthik Narasimhan, and Shunyu Yao. Fireact: Toward language agent fine-tuning. arXiv preprint arXiv:2310.05915, 2023.</p>
<p>Hyung Won Chung, Le Hou, Shayne Longpre, Barret Zoph, Yi Tay, William Fedus, Yunxuan Li, Xuezhi Wang, Mostafa Dehghani, Siddhartha Brahma, et al. Scaling instructionfinetuned language models. arXiv preprint arXiv:2210.11416, 2022.
"Karl Cobbe, Vineet Kosaraju, Mohammad Bavarian, Mark Chen, Heewoo Jun, Lukasz Kaiser, Matthias Plappert, Jerry Tworek, Jacob Hilton, Reiichiro Nakano, Christopher Hesse, and John Schulman. Training Verifiers to Solve Math Word Problems. arXiv, 2021. _eprint: 2110.14168.</p>
<p>Kanishk Gandhi, Dorsa Sadigh, and Noah D Goodman. Strategic reasoning with language models. arXiv preprint arXiv:2305.19165, 2023.</p>
<p>Mor Geva, Yoav Goldberg, and Jonathan Berant. Are we modeling the task or the annotator? an investigation of annotator bias in natural language understanding datasets. arXiv preprint arXiv:1908.07898, 2019.</p>
<p>Sachin Goyal, Ziwei Ji, Ankit Singh Rawat, Aditya Krishna Menon, Sanjiv Kumar, and Vaishnavh Nagarajan. Think before you speak: Training language models with pause tokens. arXiv preprint arXiv:2310.02226, 2023.</p>
<p>Caglar Gulcehre, Tom Le Paine, Srivatsan Srinivasan, Ksenia Konyushkova, Lotte Weerts, Abhishek Sharma, Aditya Siddhant, Alex Ahern, Miaosen Wang, Chenjie Gu, et al. Reinforced self-training (rest) for language modeling. arXiv preprint arXiv:2308.08998, 2023.</p>
<p>Suriya Gunasekar, Yi Zhang, Jyoti Aneja, Caio César Teodoro Mendes, Allie Del Giorno, Sivakanth Gopi, Mojan Javaheripi, Piero Kauffmann, Gustavo de Rosa, Olli Saarikivi, et al. Textbooks are all you need. arXiv preprint arXiv:2306.11644, 2023.</p>
<p>Patrick Haluptzok, Matthew Bowers, and Adam Tauman Kalai. Language models can teach themselves to program better. In The Eleventh International Conference on Learning Representations, 2023. URL https://openreview.net/forum?id=SaRj2ka1XZ3.</p>
<p>John Hewitt, John Thickstun, Christopher D Manning, and Percy Liang. Backpack language models. arXiv preprint arXiv:2305.16765, 2023.</p>
<p>Namgyu Ho, Laura Schmid, and Se-Young Yun. Large language models are reasoning teachers. arXiv preprint arXiv:2212.10071, 2022.</p>
<p>Matthew Douglas Hoffman, Du Phan, David Dohan, Sholto Douglas, Tuan Anh Le, Aaron Parisi, Pavel Sountsov, Charles Sutton, Sharad Vikram, and Rif A Saurous. Training chain-of-thought via latent-variable inference. Advances in Neural Information Processing Systems, 36, 2024.</p>
<p>Arian Hosseini, Xingdi Yuan, Nikolay Malkin, Aaron Courville, Alessandro Sordoni, and Rishabh Agarwal. V-star: Training verifiers for self-taught reasoners. arXiv preprint arXiv:2402.06457, 2024.</p>
<p>Cheng-Yu Hsieh, Chun-Liang Li, Chih-Kuan Yeh, Hootan Nakhost, Yasuhisa Fujii, Alexander Ratner, Ranjay Krishna, Chen-Yu Lee, and Tomas Pfister. Distilling step-by-step! outperforming larger language models with less training data and smaller model sizes. arXiv preprint arXiv:2305.02301, 2023.</p>
<p>Jiaxin Huang, Shixiang Shane Gu, Le Hou, Yuexin Wu, Xuezhi Wang, Hongkun Yu, and Jiawei Han. Large language models can self-improve. arXiv preprint arXiv:2210.11610, 2022.</p>
<p>Eric Jang, Shixiang Gu, and Ben Poole. Categorical reparameterization with gumbel-softmax. arXiv preprint arXiv:1611.01144, 2016.</p>
<p>Albert Q Jiang, Alexandre Sablayrolles, Arthur Mensch, Chris Bamford, Devendra Singh Chaplot, Diego de las Casas, Florian Bressand, Gianna Lengyel, Guillaume Lample, Lucile Saulnier, et al. Mistral 7b. arXiv preprint arXiv:2310.06825, 2023.</p>
<p>Hoyoun Jung and Kyung-Joong Kim. Discrete prompt compression with reinforcement learning. arXiv preprint arXiv:2308.08758, 2023.</p>
<p>Omar Khattab, Keshav Santhanam, Xiang Lisa Li, David Hall, Percy Liang, Christopher Potts, and Matei Zaharia. Demonstrate-search-predict: Composing retrieval and language models for knowledge-intensive nlp. arXiv preprint arXiv:2212.14024, 2022.</p>
<p>Omar Khattab, Arnav Singhvi, Paridhi Maheshwari, Zhiyuan Zhang, Keshav Santhanam, Sri Vardhamanan, Saiful Haq, Ashutosh Sharma, Thomas T Joshi, Hanna Moazam, et al. Dspy: Compiling declarative language model calls into self-improving pipelines. arXiv preprint arXiv:2310.03714, 2023.</p>
<p>Takeshi Kojima, Shixiang Shane Gu, Machel Reid, Yutaka Matsuo, and Yusuke Iwasawa. Large Language Models are Zero-Shot Reasoners, 2022. URL https://arxiv.org/abs/ 2205.11916.</p>
<p>Andrew K Lampinen, Ishita Dasgupta, Stephanie CY Chan, Kory Matthewson, Michael Henry Tessler, Antonia Creswell, James L McClelland, Jane X Wang, and Felix Hill. Can language models learn from explanations in context? arXiv preprint arXiv:2204.02329, 2022.</p>
<p>Jack Lanchantin, Shubham Toshniwal, Jason Weston, Sainbayar Sukhbaatar, et al. Learning to reason and memorize with self-notes. Advances in Neural Information Processing Systems, 36, 2024.</p>
<p>Brian Lester, Rami Al-Rfou, and Noah Constant. The power of scale for parameter-efficient prompt tuning. arXiv preprint arXiv:2104.08691, 2021.</p>
<p>Aitor Lewkowycz, Anders Andreassen, David Dohan, Ethan Dyer, Henryk Michalewski, Vinay Ramasesh, Ambrose Slone, Cem Anil, Imanol Schlag, Theo Gutman-Solo, et al. Solving quantitative reasoning problems with language models. Advances in Neural Information Processing Systems, 35:3843-3857, 2022.</p>
<p>Michael Y Li, Emily B Fox, and Noah D Goodman. Automated statistical model discovery with language models. arXiv preprint arXiv:2402.17879, 2024.
Shiyang Li, Jianshu Chen, Yelong Shen, Zhiyu Chen, Xinlu Zhang, Zekun Li, Hong Wang, Jing Qian, Baolin Peng, Yi Mao, et al. Explanations from large language models make small reasoners better. arXiv preprint arXiv:2210.06726, 2022.</p>
<p>Xiang Lisa Li and Percy Liang. Prefix-tuning: Optimizing continuous prompts for generation. arXiv preprint arXiv:2101.00190, 2021.</p>
<p>Yucheng Li, Bo Dong, Chenghua Lin, and Frank Guerin. Compressing context to enhance inference efficiency of large language models. arXiv preprint arXiv:2310.06201, 2023.</p>
<p>Jiacheng Liu, Ramakanth Pasunuru, Hannaneh Hajishirzi, Yejin Choi, and Asli Celikyilmaz. Crystal: Introspective reasoners reinforced with self-feedback. arXiv preprint arXiv:2310.04921, 2023.</p>
<p>Haipeng Luo, Qingfeng Sun, Can Xu, Pu Zhao, Jianguang Lou, Chongyang Tao, Xiubo Geng, Qingwei Lin, Shifeng Chen, and Dongmei Zhang. Wizardmath: Empowering mathematical reasoning for large language models via reinforced evol-instruct. arXiv preprint arXiv:2308.09583, 2023.</p>
<p>Aman Madaan, Niket Tandon, Prakhar Gupta, Skyler Hallinan, Luyu Gao, Sarah Wiegreffe, Uri Alon, Nouha Dziri, Shrimai Prabhumoye, Yiming Yang, et al. Self-refine: Iterative refinement with self. Feedback, 2023.</p>
<p>Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Alex Graves, Ioannis Antonoglou, Daan Wierstra, and Martin Riedmiller. Playing atari with deep reinforcement learning. arXiv preprint arXiv:1312.5602, 2013.</p>
<p>Volodymyr Mnih, Adria Puigdomenech Badia, Mehdi Mirza, Alex Graves, Timothy Lillicrap, Tim Harley, David Silver, and Koray Kavukcuoglu. Asynchronous methods for deep reinforcement learning. In International conference on machine learning, pp. 1928-1937. PMLR, 2016.</p>
<p>Jesse Mu, Xiang Li, and Noah Goodman. Learning to compress prompts with gist tokens. Advances in Neural Information Processing Systems, 36, 2024.</p>
<p>Maxwell Nye, Anders Johan Andreassen, Guy Gur-Ari, Henryk Michalewski, Jacob Austin, David Bieber, David Dohan, Aitor Lewkowycz, Maarten Bosma, David Luan, et al. Show your work: Scratchpads for intermediate computation with language models. arXiv preprint arXiv:2112.00114, 2021.</p>
<p>Alexander Pan, Erik Jones, Meena Jagadeesan, and Jacob Steinhardt. Feedback loops with language models drive in-context reward hacking. arXiv preprint arXiv:2402.06627, 2024.</p>
<p>Keiran Paster, Marco Dos Santos, Zhangir Azerbayev, and Jimmy Ba. Openwebmath: An open dataset of high-quality mathematical web text. arXiv preprint arXiv:2310.06786, 2023.</p>
<p>Du Phan, Matthew Douglas Hoffman, Sholto Douglas, Tuan Anh Le, Aaron T Parisi, Pavel Sountsov, Charles Sutton, Sharad Vikram, Rif A Saurous, et al. Training chain-of-thought via latent-variable inference. In Thirty-seventh Conference on Neural Information Processing Systems, 2023.</p>
<p>Gabriel Poesia, Kanishk Gandhi, Eric Zelikman, and Noah D Goodman. Certified reasoning with language models. arXiv preprint arXiv:2306.04031, 2023.</p>
<p>Stanislas Polu and Ilya Sutskever. Generative Language Modeling for Automated Theorem Proving. CoRR, abs/2009.03393, 2020. URL https://arxiv.org/abs/2009.03393. .eprint: 2009.03393.</p>
<p>Ben Prystawski, Michael Li, and Noah Goodman. Why think step by step? reasoning emerges from the locality of experience. Advances in Neural Information Processing Systems, 36, 2024 .</p>
<p>Shuofei Qiao, Ningyu Zhang, Runnan Fang, Yujie Luo, Wangchunshu Zhou, Yuchen Eleanor Jiang, Chengfei Lv, and Huajun Chen. Autoact: Automatic agent learning from scratch via self-planning. arXiv preprint arXiv:2401.05268, 2024.</p>
<p>Linlu Qiu, Liwei Jiang, Ximing Lu, Melanie Sclar, Valentina Pyatkin, Chandra Bhagavatula, Bailin Wang, Yoon Kim, Yejin Choi, Nouha Dziri, et al. Phenomenal yet puzzling: Testing inductive reasoning capabilities of language models with hypothesis refinement. arXiv preprint arXiv:2310.08559, 2023.</p>
<p>Alec Radford, Jeffrey Wu, Rewon Child, David Luan, Dario Amodei, Ilya Sutskever, et al. Language models are unsupervised multitask learners. OpenAI blog, 1(8):9, 2019.</p>
<p>Colin Raffel, Noam Shazeer, Adam Roberts, Katherine Lee, Sharan Narang, Michael Matena, Yanqi Zhou, Wei Li, and Peter J Liu. Exploring the limits of transfer learning with a unified text-to-text transformer. Journal of machine learning research, 21(140):1-67, 2020.</p>
<p>Nazneen Fatema Rajani, Bryan McCann, Caiming Xiong, and Richard Socher. Explain yourself! leveraging language models for commonsense reasoning. In Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics, pp. 4932-4942, 2019.</p>
<p>Timo Schick, Jane Dwivedi-Yu, Roberto Dessì, Roberta Raileanu, Maria Lomeli, Eric Hambro, Luke Zettlemoyer, Nicola Cancedda, and Thomas Scialom. Toolformer: Language models can teach themselves to use tools. Advances in Neural Information Processing Systems, 36, 2024.</p>
<p>John Schulman, Filip Wolski, Prafulla Dhariwal, Alec Radford, and Oleg Klimov. Proximal policy optimization algorithms. arXiv preprint arXiv:1707.06347, 2017.</p>
<p>Tal Schuster, Ashwin Kalyan, Alex Polozov, and Adam Tauman Kalai. Programming Puzzles. In Thirty-fifth Conference on Neural Information Processing Systems, 2021. URL https://openreview.net/forum?id=fe_hCc4R8rg.</p>
<p>Noah Shinn, Federico Cassano, Beck Labash, Ashwin Gopinath, Karthik Narasimhan, and Shunyu Yao. Reflexion: Language agents with verbal reinforcement learning. arXiv preprint arXiv:2303.11366, 2023.</p>
<p>Vered Shwartz, Peter West, Ronan Le Bras, Chandra Bhagavatula, and Yejin Choi. Unsupervised commonsense question answering with self-talk. In Proceedings of the 2020 Conference on Empirical Methods in Natural Language Processing (EMNLP), pp. 4615-4629, 2020.</p>
<p>David Silver, Thomas Hubert, Julian Schrittwieser, Ioannis Antonoglou, Matthew Lai, Arthur Guez, Marc Lanctot, Laurent Sifre, Dharshan Kumaran, Thore Graepel, et al. Mastering chess and shogi by self-play with a general reinforcement learning algorithm. arXiv preprint arXiv:1712.01815, 2017.</p>
<p>Alon Talmor, Jonathan Herzig, Nicholas Lourie, and Jonathan Berant. Commonsenseqa: A question answering challenge targeting commonsense knowledge. arXiv preprint arXiv:1811.00937, 2018.</p>
<p>Eric Todd, Millicent L Li, Arnab Sen Sharma, Aaron Mueller, Byron C Wallace, and David Bau. Function vectors in large language models. arXiv preprint arXiv:2310.15213, 2023.</p>
<p>Jonathan Uesato, Nate Kushman, Ramana Kumar, Francis Song, Noah Siegel, Lisa Wang, Antonia Creswell, Geoffrey Irving, and Irina Higgins. Solving math word problems with process-and outcome-based feedback. Neural Information Processing Systems (NeurIPS 2022) Workshop on MATH-AI, 2022.</p>
<p>Ruocheng Wang, Eric Zelikman, Gabriel Poesia, Yewen Pu, Nick Haber, and Noah D Goodman. Hypothesis search: Inductive reasoning with language models. arXiv preprint arXiv:2309.05660, 2023.</p>
<p>Xuezhi Wang and Denny Zhou. Chain-of-thought reasoning without prompting. arXiv preprint arXiv:2402.10200, 2024.</p>
<p>Lucas Weber, Jaap Jumelet, Elia Bruni, and Dieuwke Hupkes. Language modelling as a multi-task problem. arXiv preprint arXiv:2101.11287, 2021.</p>
<p>Jason Wei, Maarten Bosma, Vincent Zhao, Kelvin Guu, Adams Wei Yu, Brian Lester, Nan Du, Andrew M Dai, and Quoc V Le. Finetuned language models are zero-shot learners. In International Conference on Learning Representations, 2021a.</p>
<p>Jason Wei, Maarten Bosma, Vincent Y Zhao, Kelvin Guu, Adams Wei Yu, Brian Lester, Nan Du, Andrew M Dai, and Quoc V Le. Finetuned language models are zero-shot learners. arXiv preprint arXiv:2109.01652, 2021b.</p>
<p>Jason Wei, Yi Tay, Rishi Bommasani, Colin Raffel, Barret Zoph, Sebastian Borgeaud, Dani Yogatama, Maarten Bosma, Denny Zhou, Donald Metzler, Ed H. Chi, Tatsunori Hashimoto, Oriol Vinyals, Percy Liang, Jeff Dean, and William Fedus. Emergent Abilities of Large Language Models, October 2022a. URL http://arxiv.org/abs/2206.07682. arXiv:2206.07682 [cs].</p>
<p>Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Brian Ichter, Fei Xia, Ed Chi, Quoc Le, and Denny Zhou. Chain of Thought Prompting Elicits Reasoning in Large Language Models, 2022b. URL https://arxiv.org/abs/2201.11903.</p>
<p>Ronald J Williams. Simple statistical gradient-following algorithms for connectionist reinforcement learning. Machine learning, 8:229-256, 1992.</p>
<p>Shunyu Yao, Jeffrey Zhao, Dian Yu, Nan Du, Izhak Shafran, Karthik Narasimhan, and Yuan Cao. React: Synergizing reasoning and acting in language models. International Conference on Learning Representations (ICLR 2023), 2022.</p>
<p>Eric Zelikman, Yuhuai Wu, Jesse Mu, and Noah Goodman. Star: Bootstrapping reasoning with reasoning. Advances in Neural Information Processing Systems, 35:15476-15488, 2022.</p>
<p>Eric Zelikman, Qian Huang, Gabriel Poesia, Noah D. Goodman, and Nick Haber. Parsel: Algorithmic reasoning with language models by composing decompositions, 2023a.</p>
<p>Eric Zelikman, Eliana Lorch, Lester Mackey, and Adam Tauman Kalai. Self-taught optimizer (stop): Recursively self-improving code generation. arXiv preprint arXiv:2310.02304, 2023b.</p>
<p>Hugh Zhang and David C Parkes. Chain-of-thought reasoning is a policy improvement operator. arXiv preprint arXiv:2309.08589, 2023.</p>
<p>Tianjun Zhang, Aman Madaan, Luyu Gao, Steven Zheng, Swaroop Mishra, Yiming Yang, Niket Tandon, and Uri Alon. In-context principle learning from mistakes. arXiv preprint arXiv:2402.05403, 2024.</p>
<p>Zhuosheng Zhang, Aston Zhang, Mu Li, and Alex Smola. Automatic chain of thought prompting in large language models. arXiv preprint arXiv:2210.03493, 2022.</p>
<p>Wenting Zhao, Justin T Chiu, Claire Cardie, and Alexander M Rush. Hop, union, generate: Explainable multi-hop reasoning without rationale supervision. arXiv preprint arXiv:2305.14237, 2023.</p>
<p>Hattie Zhou, Azade Nova, Hugo Larochelle, Aaron Courville, Behnam Neyshabur, and Hanie Sedghi. Teaching algorithmic reasoning via in-context learning. arXiv preprint arXiv:2211.09066, 2022.</p>
<p>Zhaocheng Zhu, Yuan Xue, Xinyun Chen, Denny Zhou, Jian Tang, Dale Schuurmans, and Hanjun Dai. Large language models can learn rules. arXiv preprint arXiv:2310.07064, 2023.</p>
<h1>Appendix</h1>
<h2>A Hyperparameter Choices</h2>
<p>Optimization and Evaluation For optimization, we use the AdamW optimizer with a warmup of 20 steps, a learning rate of $1 e-6$, a weight decay of 0.001 , and a batch size of 8 (along with any necessary gradient accumulation to keep this fixed across runs). Moreover, our &lt;|startof thought|&gt; and &lt;| endof thought|&gt; embedding gradient weight is $1 e 2$ and our policy weight is $1 e 6$. We sample with temperature $T=1$ during training and use greedy decoding for the thoughts during evaluation. We treat our samples as importance samples by computing the REINFORCE loss at temperature $T=3$. Because we do not prompt the model with any examples, we directly compute the probability of the correct answer, conditioned on generating an answer - for example, for multiple choice questions between $A \cdots E$, we compute the accuracy over the logits for tokens corresponding to $A \cdots E$. Lastly, for our training, we select a random span of 256 tokens from each sample (or pad if there are fewer than 256 tokens).</p>
<p>Mixing Head For our mixing head, we use a three-layer MLP with ReLU activation, taking in a vector of two times the size of the hidden state of the language model (as we concatenate the two predictions to determine their weights), and outputting a scalar. This scalar is them used to weight the logits from the LM head with and without thinking to make a prediction from a given token.</p>
<p>Computation We train all of our models on a single node of eight 80GB H100s.</p>
<h2>B Faster Parallel Sampling</h2>
<p>In this section, we highlight some simple ways to further accelerate the parallel generation algorithm. For example, note that one can reduce the attention's memory cost by computing the diagonal attention simply as elementwise (rather than pairwise) dot-products. That is, given two input embedding sequences of shapes $(b, t, l, d)$ and $(b, 1, l, d)$ where $t$ is the number of timesteps ahead, $b$ is batch size, $l$ is sequence length, and $d$ is embedding dimension, we do not need to compute their pairwise attention of shape $(b, t, l, l)$, we only need to compute the attention for the paired elements along the diagonal of shape $(b, t, l)$. Additionally, to avoid generating continuations for all of the tokens (for example, if one wanted to apply a value function to determine where thoughts would be most useful), one can index into this generated attention mask. Notably, however, this also requires manipulation of the other inputs during the forward pass such as the positional embeddings.</p>
<h2>C Compute-Adjusted Plots</h2>
<p>We also visualize Figure 2 where we normalize by the number of thought and talk tokens used for training.</p>
<h2>D Measuring the Impact of Multiple Thoughts Per Sequence and Multiple Tokens Ahead</h2>
<p>We perform a simple ablation on our 12-thought-token-4-ahead baseline, namely asking whether sampling multiple thoughts per sequence is necessary. We find that although simply computing the reward as the difference between the losses with and without thought proves to be a strong baseline, using multiple thoughts consistently outperformed it (by roughly $0.5 \%$ on GSM8K generalization and 3\% on CommonsenseQA generalization). However, the exact number of thoughts had little impact: varying between 2, 3, and 4 thoughts per sequence appeared to result in a consistent improvement with additional</p>
<p><img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>Figure 6: Compute-Normalized Generalization Results. We visualize the performance curves normalized by the number of inference calls used.
thoughts, but additional thoughts per sequence beyond two improved performance by only $0.1-0.3 \%$ on both GSM8K and CommonsenseQA. Similarly, we found that predicting more than one token ahead helped by $0.3 \%$ on GSM8K and $3.1 \%$ on CommonsenseQA, but with 12-thought-tokens, we did not find that additional tokens ahead, beyond two, improved performance. However, qualitatively, we found that the rationales appeared more coherent with additional tokens-ahead of supervision. This suggests a need for more specific evaluations of generation quality in future work.</p>
<h1>E Rationale-Augmented Rationales</h1>
<p>Because the language model can insert thoughts anywhere, we perform a preliminary study where we investigate the reasoning generated by the language model when it has access to internal rationales while it generates external rationales (i.e. chains-of-thought) to solve a problem. Because these chains of thought are themselves generated by chains of thought, one might refer to this as a net-of-thought (or NoT). We compare five solutions from the model to a fixed random question in GSM8K, looking at outputs of the base Mistral 7B, the outputs of Mistral fine-tuned for the same number of steps on OpenWebMath (Paster et al., 2023), and the rationales of our best Quiet-STaR model. We sample from all of them directly, at temperature $t=1$.</p>
<h2>E. 1 Base Mistral 7B</h2>
<p>First Response:
A: Let's think step by step. How many fresh eggs remains after the three her eat for breakfast and four goes into the muffin mix for her friends. We can calculate it by 16-3-4. The amount equals 9 fresh eggs. So, the dollars it makes daily equals what multiplied by $\$ 2.12 \times 2$. The answer is $\$ 24$.</p>
<p>Second Response:
Q: Janet's ducks lay 16 eggs per day. She eats three for breakfast every morning and bakes muffins for her friends every day with four. She sells the remainder at the farmers' market daily for $\$ 2$ per fresh duck egg. How much in dollars does she make every day at the farmers' market?
A: Let's think step by step. She eats 3 daily for breakfast. She bakes 4 daily into muffins for her friends. That leaves 9. She sells 9 for $\backslash(2 \backslash)$, so $\backslash(9 \backslash t i m e s ~ 2=\backslash \$ 18$ ). So Janet makes $\$ 18$ selling duck eggs each day.</p>
<ol>
<li>Janet sells an average of 12 fresh duck eggs daily on the farmers' market. If she sells them for $\$ 2$ per egg how much does she make per week, assuming she sells at the farmers' market most every day?A: If Janet sells on average 12 fresh duck eggs daily on the farmers' market. This is equal to (12\times 7), so 12 ( \backslash) times) 7 ={84}. The total amount she would then make would be (84\times 2) dollars, or 168 per week. So Janet makes $\$ 168$ selling duck eggs per week.</li>
</ol>
<h1>Third Response:</h1>
<p>Q: Janet's ducks lay 16 eggs per day. She eats three for breakfast every morning and bakes muffins for her friends every day with four. She sells the remainder at the farmers' market daily for $\$ 2$ per fresh duck egg. How much in dollars does she make every day at the farmers' market?
A: Let's think step by step.
How many eggs does she have left every day?
This is important because it will help us find how many eggs she sells each day.
What can we do to answer the question?
If we write the relationship between how many duck eggs Janet has left, how many she eats, and how many she bakes for the muffins, then we can see how many eggs she has left to sell at the farmers' market.</p>
<p>Let's write an equation to solve our dilemma.
Subtract an equation for eggs eaten and an equation for eggs baked to find the eggs remaining. Let's see what we can find.</p>
<p>We can see that Janet has 6 eggs leftover each day. \$6\times$12\$ per day. Therefore Janet receives an additional $\$ 12$ per day for her eggs at the farmer's market.
Remember, this is just for one day, so now she makes $\$ 12$ per day in additional income, because she sells her eggs at the farmer's market each day.
#### Answer
$\$ 12$</p>
<h2>Fourth Response:</h2>
<p>Q: Janet's ducks lay 16 eggs per day. She eats three for breakfast every morning and bakes muffins for her friends every day with four. She sells the remainder at the farmers' market daily for $\$ 2$ per fresh duck egg. How much in dollars does she make every day at the farmers' market?
A: Let's think step by step. First, you want to find out the number of eggs a total that Janet collects each day. Take this many dollars a three and subtract from the money she gets per egg, which is $\$ 2$. The answer to that question is $\$ 5$.</p>
<h2>Fifth Response</h2>
<p>Q: Janet's ducks lay 16 eggs per day. She eats three for breakfast every morning and bakes muffins for her friends every day with four. She sells the remainder at the farmers' market daily for $\$ 2$ per fresh duck egg. How much in dollars does she make every day at the farmers' market?
A: Let's think step by step.
For the first step, let's think of the day as a whole, using some variables to keep track of the numbers of eggs. Let $\$ n \$=$ the number of eggs that Janet's ducks lay per day. Then the number of eggs that she eats per day will be $\$(3) \$=$.
Next, she makes $\$ m \$=$ muffins. For each muffin, she uses $\$ 4 \$=$ eggs, so we can take from the eggs Janet's ducks lay to represent the number she uses: $\$ 4{m} \$=$. Now, to get her back to our starting number of eggs, we need to add these eggs back on, giving us . The eggs Janet sells each day brings her $\$ 2 \$ \$(n) \$=\$. This brings us to our next step.
Now we will break down all the eggs from our starting number, $\$ n \$=$, into the pieces that we set up previously. For the beginning number, we have: This brings us back to our starting number, and we can simplify this expression.</p>
<p>Moving from the top line to the second line, we multiply the numbers within each parenthetical group. Moving from the second line to the third line, we add the products together to find the total. Finally, we can distribute and determine the final product: $\$=360 . \$$
So the total number of eggs that Janet's ducks lay per day is $\$ 360 . \$$ Since Janet sells each egg she has for $\$ 2, \$$ her total earnings at the farmers' market is: $\$ \backslash$ boxed $(\$ \$$ 720).\$$</p>
<h1>E. 2 OpenWebMath-Trained Mistral 7B</h1>
<h2>First Response:</h2>
<p><s> Q: Janet's ducks lay 16 eggs per day. She eats three for breakfast every morning and bakes muffins for her friends every day with four. She sells the remainder at the farmers' market daily for $\$ 2$ per fresh duck egg. How much
in dollars does she make every day at the farmers' market?
A: Let's think step by step. How much does she make every day? Well per the question, that is $\$ 2$ per a duck egg. Now, how many duck eggs per day does she sell? Well, that's 16 minus the eggs she eats minus the eggs she uses to ma
ke muffins.
She eats 3 eggs every morning, so $\$ 16-3=13 \$$.
She makes 4 muffins, which uses 4 eggs. $\$ 16-3-4=5 \$$.
Therefore, the number of duck eggs she is selling is $\$ 5 \$$.
Clearly, 1 duck egg costs $\$ 2$. Therefore, the total amount she makes selling the eggs is $\$ 10 \$ \$ 2 \$$. Now, this can be written as a fraction as, "ten two-dollars," so $\$ 102$ bucks. $\$$</p>
<p>Converting to a fraction, or "a tenth of ten," so $\$ 102$ - bucks\$ = \$1\$ \$10 - bucks\$
[reveal-answer q="fs-id1165135856725"]Show Solution[/reveal-answer]
[hidden-answer a="fs-id1165135856725"]</p>
<h2>Second Response:</h2>
<p><s> Q: Janet s ducks lay 16 eggs per day. She eats three for breakfast every morning and bakes muffins for her friends every day with four. She sells the remainder at the farmers' market daily for $\$ 2$ per fresh duck egg. How much in dollars does she make every day at the farmers' market?
A: Let's think step by step. On what basis can we answer the question affer considering the question? What do we know given and how can we use what we're given to arrive at an answer. 3 is given, 4 is given, 16 is given, does anyone have any thoughts?
A: Well 16 minus 3 minus 4 equals 9 , and then I subtract 1 from 9 and that is 4 extra so five more eggs.
M: And we know that 2 times 5 is how much?
A: Ten
M: Yes.
A: If she eats 3 duck eggs for breakfast, in the morning equals (3 \backslash$ times $2=6 \backslash$ ). If she eat 4 duck eggs baking muffin for her friends equals (4 \backslash$ times $2=8 \backslash), so total of money and that she got is $\$ 6$ plus $\$ 8$ which equals 14 . The weight gain is 5 because it is 5 is that what you put up there so 5 times 2 ducks and subtract that from that from 16 and you got 7 no what did we write down? Are you able to figure out now what the question is, and what is what the question really is. You got 14 the weight loss you, you subtracted that from 16 which equals 2, $\$ 14$ minus 2 , remainder is what?
A: 12 .
M: The question is what is Janet s ducks lay 16 eggs, she eats 12 for sale. You subtract 3 plus 4 minus 5 so 5 when you eat the muffin equals 5 , times two, the 12 , minus the money so 5 times $2, \$-12 \$$. So (2 \backslash$ times $9=18 \backslash) minus $\$ 10$, so 4 more eggs... Still times $\$ 2$, total comes to to $\$ 20$.
A: I understand there is the ones day one 3 plus 4 eats who makes and so on and so on.
M: But maybe in order to answer it correctly you have to look a little close. Typically in the procedures you have that they give you first, I can tell you how here we go.</p>
<p>M: Now if you increase the 16, now you have that you would need to determine 16 minus 3 minus 4 and that adds up to the remainder, which is 9 . Then subtract 1 and but you have 5 . The next answer then, which you do is now 5 times 2 , which is 10 .
M: Which is $\$ 10$, and then 14 , which is is the remainder
M: Is $\$ 6$ and $\$ 8$ and that is a total of $\$ 14$, and now that you subtract 2 , and that means that you now have 16 minus 5 , which is 11 .
M: The next thing is to the yield for the second situation you have got 16 minus 3 plus 4 and that comes to 9 . This is very easy to do instantaneously even the first part, $16,3,4$ and 9 , and you happen to know what lives, and you just count and you have five and five then go ahead. 5 times 2 comes to 10 , so $\$ 10$ then so actually you have just added 4.5 , now your total is 16 plus $\$ 2$. But now to this is $\$ 10$ plus $\$ 2$ is $\$ 12$, so how much you sell from 16 and then minus 12 comes to 4 .
M: So what is the remainder of 16 minus 3 plus 4 minus 5 ? Matters you see three is missing. Four you have. Five eggs. So 5 times 2 , so $\$ 10$ remains at $\$ 10$, so reduce, so what happens now to what happened was added with subtracted the next the question is 16 minuses 3 plus 4 , and presumably you've done this before, if not then you add up 16 minus 3 plus 4 gives us 9 and what is the remainder after 5? So what is 5 times 2 ? So $10.2,3$, plus $2 \times 5$, and so your answer so far is 16 minus 3 plus 4 , and give us the basket minus 2 remains 9 and now you have to determine now what is the total for the second part? You have</p>
<h1>Third Response:</h1>
<p><s> Q: Janet s ducks lay 16 eggs per day. She eats three for breakfast every morning and bakes muffins for her friends every day with four. She sells the remainder at the farmers' market daily for $\$ 2$ per fresh duck egg. How much in dollars does she make every day at the farmers' market?
A: Let's think step by step. The "how much in dollars" part means that one egg is worth one dollar. So, twelve ducks lay 16 eggs, which means that Janet nets $\$ 20$ from selling them. $\$ 16$ muffins will give us 4 eggs, which nets us $\$ 8$. So, we paid $\$ 108$ for our ingredients to make 16 muffins. Hence, we lost 96 dollars. Hello, heroine, we have to do better than that! Look into averages. Let's say that we pay 5 dollars for one egg. Now, $\$ 12$ is our product and $\$ 5$ is our investment. Our net wealth will be $\$ 12-5 \times 12=24$ dollars. Is that correct?</p>
<h2>Fourth Response:</h2>
<p><s> Q: Janet s ducks lay 16 eggs per day. She eats three for breakfast every morning and bakes muffins for her friends every day with four. She sells the remainder at the farmers' market daily for $\$ 2$ per fresh duck egg. How much in dollars does she make every day at the farmers' market?
A: Let's think step by step. First, Jane's ducks lay 16 eggs perday. So there are 16 eggs Monday, 16 Tuesday, 16 Wednesday, 16 Thursday, 16 Friday, and so on. Second, Janet eats 3 of the 16 eggs that the ducklay ap day for breakfast. She only eats the duck eggs, not her baked goods (muffins) or other food. Therefore, she eats 3 Monday, 3 Tuesday, 3 Wednesday, 3 Thursday, and so on. Third, she only bakes the first 4 non-eaten eggs into muffins. Therefore\$ she sells the remaining 12 noneaten eggs Monday, 12 Tuesday, 12 Wednesday, 12 Thursday, and so on. Fourth, Janet sells duck eggs Monday, Tuesday, Wednesday, Thursday, Friday at the 2 each. Third, she eats 3 Monday, 3 Tuesday, 3 Wednesday, 3 Thursday, Friday at the farmers' market. Lastly, she makes 12 Monday, 12 Tuesday, 12 Wednesday, 12 Thursday, and so on in dollars every day at the farmers' market. The worksheet below summarizes these steps. The number formed by the intersection of corresponding row and column terms will be the correct answer. The product of the $(3, J)$ term and the $(J, 8)$ term is 1,150 . So, Janet makes $\$ 1,150$ per day!
(Note: Step 3 and Step 8 are repeating, but the $(3,7)$ term in Step 8 is not the same as the $(3,7)$ term in Step 3. )</p>
<h2>Fifth Response</h2>
<p><s> Q: Janet s ducks lay 16 eggs per day. She eats three for breakfast every morning and bakes muffins for her friends every day with four. She sells the remainder at</p>
<p>the farmers' market daily for $\$ 2$ per fresh duck egg. How much in dollars does she make every day at the farmers' market?
A: Let's think step by step.
What do we know?</p>
<ul>
<li>Janet's ducks lay 16 eggs per day.</li>
<li>She eats three for breakfast every morning and bakes muffins for her friends every day with four.</li>
</ul>
<p>From these two facts, we can conclude at least that Janet needs at least seven eggs for consumption per day.
And what do we need to find exactly?</p>
<ul>
<li>We need to find how much in dollars Janet makes every day at the farmers' market.</li>
</ul>
<p>Let's write an equation and solve it to find the answer. We know:
$-\backslash(16-3-4=9 \backslash)$
So our daily profit is 9 times $\$ 2$, or $\backslash(9 \backslash t i m e s \backslash \$ 2=\backslash \$ 18 \backslash)$
Hence her profits at market on a given day are $\backslash(\$ 18 \backslash)$.
Answer: $\backslash(\$ 18 \backslash)$.</p>
<h1>E. 3 Quiet-STaR-Trained Mistral 7B</h1>
<h2>First Response:</h2>
<p><s> Q: Janet's ducks lay 16 eggs per day. She eats three for breakfast every morning and bakes muffins for her friends every day with four. She sells the remainder at the farmers' market daily for $\$ 2$ per fresh duck egg. How much
in dollars does she make every day at the farmers' market?
A: Let's think step by step.
The ducks lay 16 eggs per day.
This is the total number of eggs.
3 of the eggs are eaten for breakfast.
This is the number of eggs that are eaten for breakfast.
4 of the eggs are used to make muffins.
This is the number of eggs that are used to make muffins.
$16-3-4=9$
9 is the number of eggs that are sold at the farmers' market.
9 of the eggs are sold at the farmers' market.
$\$ 2$
The price of each egg is $\$ 2$.
\$2 \times $9=18 \$$
18 is the total price of the eggs.
The total price of the eggs is $\$ 18$.</p>
<h2>Second Response:</h2>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{2}$ For example, in this very text, the token following "run" is "-"&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>