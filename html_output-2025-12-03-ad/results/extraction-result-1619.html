<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-1619 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-1619</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-1619</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-31.html">extraction-schema-31</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <p><strong>Paper ID:</strong> paper-220253536</p>
                <p><strong>Paper Title:</strong> Code Building Genetic Programming</p>
                <p><strong>Paper Abstract:</strong> In recent years the field of genetic programming has made significant advances towards automatic programming. Research and development of contemporary program synthesis methods, such as PushGP and Grammar Guided Genetic Programming, can produce programs that solve problems typically assigned in introductory academic settings. These problems focus on a narrow, predetermined set of simple data structures, basic control flow patterns, and primitive, non-overlapping data types (without, for example, inheritance or composite types). Few, if any, genetic programming methods for program synthesis have convincingly demonstrated the capability of synthesizing programs that use arbitrary data types, data structures, and specifications that are drawn from existing codebases. In this paper, we introduce Code Building Genetic Programming (CBGP) as a framework within which this can be done, by leveraging programming language features such as reflection and first-class specifications. CBGP produces a computational graph that can be executed or translated into source code of a host language. To demonstrate the novel capabilities of CBGP, we present results on new benchmarks that use non-primitive, polymorphic data types as well as some standard program synthesis benchmarks.</p>
                <p><strong>Cost:</strong> 0.015</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e1619.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e1619.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>CBGP</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Code Building Genetic Programming</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A program-synthesis genetic programming system that evolves linear genomes which are compiled into typed, reified program DAGs that can be transpiled into human-readable host-language source code, with native support for polymorphic types, higher-order functions, and integration with preexisting code via reflection.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Code Building Genetic Programming (CBGP)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>CBGP represents candidate programs as linear genomes (a derivative of the Plushy/Plushi representation) which are compiled via a Push-inspired stack process into type-safe directed acyclic computational graphs (program DAGs). Expressions wrap host-language functions, methods, constructors, constants and inputs and carry rich type specifications; reification rules refine expression specifications once child nodes are assigned. Evolution proceeds as a standard generational evolutionary algorithm over linear genomes; genomes are translated to Push-like code and then compiled into executable DAGs for evaluation. CBGP emphasizes executability (type-safe compilation), use of polymorphic and preexisting code, and transcribability to host-language source.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs / source code (expressions wrapping host-language functions, methods, constructors; program DAGs compiled to host-language code)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Not specified in the paper; the authors state the linear (Plushy-derived) genome allows a wide range of variation operators (including standard linear-genome crossover) but do not describe a concrete crossover mechanism or parameters.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Not specified in the paper; the authors state CBGP borrows variation operators from contemporary methods and that the linear genome permits many operators. Genome simplification is used post-evolution; the paper cites related work on uniform mutation by addition and deletion but does not describe a specific mutation operator used in these experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Primary executability metrics: (1) whether the Push->DAG compilation produced a valid program DAG of the requested return type (compilation success/failure), and (2) benchmark solution rate (number of successful evolutionary runs producing a correct program divided by total runs). Runtime exceptions during DAG evaluation are caught and produce penalty errors per training case.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>Reported benchmark solution rates on the novel benchmarks: Days Between 31/31 (100%), Filter Bounds 31/31 (100%), Prefix Paths 30/31 (96.8%). CBGP is reported to have significantly higher solution rates than PushGP on several General Program Synthesis Benchmark Suite problems (Negative To Zero, Median, Smallest, Vector Average) and significantly worse on two (Compare String Lengths, Replace Space With Newline); exact numeric solution rates for the latter comparisons are presented in Figure 7 of the paper but not all raw numbers are listed in-text.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>program synthesis / code generation (inductive program synthesis benchmarks and novel polymorphic-code benchmarks)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>PushGP; Grammar-Guided Genetic Programming (G3P)</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>CBGP's typed DAG compilation increases executability (type-safe programs, fewer runtime evaluation costs), enabling higher solution rates on several benchmarks relative to PushGP and parity or superiority over G3P on many tested problems. The paper does not analyze or report how specific crossover or mutation operators influenced novelty, diversity, or executability; instead it emphasizes representational advantages (polymorphism, expression reification, integration with host-language code) and faster evaluation due to compiled DAGs. Genome simplification post-evolution can improve generalization but the paper does not quantify mutation/crossover impacts on novelty/diversity.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Code Building Genetic Programming', 'publication_date_yy_mm': '2020-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1619.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e1619.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>PushGP</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Push Genetic Programming (PushGP)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A genetic programming framework that evolves programs in the stack-based Push language where programs are nested sequences of instructions and literals executed by a Push interpreter; Push code is interpreted per training case and uses stacks for different data types.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>PushGP</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>PushGP evolves programs written in the Push language, which is Turing-complete and stack-based; literals push values onto type-specific stacks and instructions pop required arguments and push results. PushGP programs are represented as nested token sequences interpreted by a Push virtual machine. The paper describes PushGP as a contemporary baseline and highlights limitations relative to CBGP (e.g., limited support for arbitrary/polymorphic data types without custom instructions, difficulty reifying into host-language source).</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs (Push language code sequences)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Not detailed in this paper; PushGP commonly uses linear/genetic operators in prior literature, but the CBGP paper does not specify the crossover mechanism used in PushGP baseline experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Not detailed in this paper; CBGP cites PushGP as an existing method but does not describe PushGP mutation specifics.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>PushGP execution model: programs are interpreted per training case by the Push interpreter; executability is implicit (successful interpreter runs) and runtime behavior is used to compute fitness over training cases. The CBGP paper contrasts this with CBGP's compiled-DAG evaluation which requires only one compilation and is faster to evaluate across many cases.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>Qualitative comparison: CBGP achieves significantly higher solution rates than PushGP on several benchmark problems and worse on others; the paper reports statistical significance for some comparisons but does not supply full numeric breakdowns for all problems in-text.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>program synthesis (baseline compared to CBGP on General Program Synthesis Benchmark Suite problems)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>CBGP (this paper compares solution rates against PushGP)</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>PushGP is a useful baseline but lacks CBGP's automatic support for polymorphic host-language types and tight reification to host-language source; per-case interpretation makes evaluation costlier. The paper does not examine how PushGP's crossover/mutation influence novelty or executability in these experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Code Building Genetic Programming', 'publication_date_yy_mm': '2020-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1619.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e1619.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>G3P</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Grammar-Guided Genetic Programming (G3P)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A genetic programming approach that uses context-free grammars (BNF) to constrain program generation, often via grammatical evolution mapping integer sequences to grammar productions, producing typesafe host-language source code.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Grammar-Guided Genetic Programming (G3P)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>G3P uses one or more context-free grammars to define the syntactic space of candidate programs; grammatical evolution or related mapping methods produce programs by selecting grammar productions. G3P can produce typesafe source in a host language, but extending the system to support new data types or polymorphism is laborious because grammars must be manually created or extended.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs / source code (grammar-constrained host-language programs)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Not specified in this paper; G3P implementations often apply crossover at the genotype (integer vector) or derivation-tree level, but the CBGP paper does not detail these operators.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Not specified in this paper; G3P mutation mechanisms vary by implementation and are not described here.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>G3P produces typesafe host-language source via grammars, and executability is measured by whether generated code compiles/runs and its fitness on training/test cases; CBGP reports comparisons in solution rates but does not give G3P operator-level data.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>CBGP was not significantly worse than G3P on any tested problems and found significantly more solutions on several problems (Negative To Zero, Median, Number IO, Smallest, Vector Average) according to the paper's statistical tests; exact numeric values for G3P per-problem solution rates are in the paper's Figure 7.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>program synthesis (compared against CBGP on standard benchmarks)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>CBGP (paper compares CBGP performance to G3P)</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>G3P produces typesafe source and is a reasonable baseline; CBGP matches or outperforms G3P on several problems while offering additional capabilities (polymorphism, integration with host code). The paper does not analyze the role of G3P crossover/mutation in producing novelty/diversity.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Code Building Genetic Programming', 'publication_date_yy_mm': '2020-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1619.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e1619.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Plushy genome</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Plushy / Plushi linear genome representation</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A flat linear genome format (Plushy) used in PushGP systems in which a sequence of tokens and structure tokens (OPEN/CLOSE) encodes programs; CBGP uses a derivative of this representation to permit flexible variation operators and translation to Push code and program DAGs.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Plushi: an embeddable, language agnostic, push interpreter.</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Plushy (linear) genome representation / Plushi interpreter</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>The Plushy genome is a linear encoding consisting of expressions interleaved with structure tokens (OPEN/CLOSE) that can be translated into nested Push-like code; CBGP uses a derivative of Plushy so that linear genomes can be translated into Push and then compiled into typed program DAGs. The linear encoding is chosen to support a wide variety of variation operators while avoiding direct graph/tree bloat.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs (linear token sequences that compile to program DAGs)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Not explicitly described in CBGP paper; the linear Plushy-style genome enables typical linear crossover operators (e.g., one-point, two-point, homologous crossover) but the paper does not commit to a concrete operator or implementation details.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Not explicitly described in CBGP paper; linear genomes typically allow insertion/deletion/substitution mutations; the paper references prior work on uniform mutation by addition and deletion but does not specify which mutations were used in the experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Plushy genomes are translated to Push-like representations and then compiled to typed DAGs; executability is ensured (or penalized) by the compilation process which can fail if type/spec constraints are not met.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>CBGP reports that the Plushy-derivative linear genome plus compilation avoids bloat and produces type-safe DAGs that are faster to evaluate than repeated Push interpreter runs; no numeric runtime microbenchmarks for genome formats are provided.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>representation layer for program synthesis GP</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>used as internal genome format; compared conceptually against direct tree/graph encodings in discussion</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Linear Plushy-derived genomes enable flexible variation operators and help avoid graph/tree bloat; CBGP leverages this to apply standard generational EA machinery, but the paper does not detail which specific crossover or mutation operators were applied nor how they affected solution novelty or diversity.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Code Building Genetic Programming', 'publication_date_yy_mm': '2020-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1619.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e1619.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Generational EA</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Typical generational evolutionary algorithm (as used in CBGP)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A standard generational evolutionary algorithm maintaining a population of linear genomes, using error functions for fitness, parent selection, variation to create offspring, and replacement across generations; CBGP follows this overall pattern for program synthesis.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Typical generational evolutionary algorithm (population, selection, variation, generational replacement)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>CBGP implements a standard generational EA: maintain a population of individuals represented by linear genomes, evaluate individuals via compiled program DAGs on training cases to compute error/fitness (penalizing compilation failures and runtime exceptions), select parents according to a selection strategy, apply variation (crossover/mutation or other operators) to produce offspring, and iterate for generations. Genome simplification is applied to solutions post-evolution.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs (linear genomes encoding program fragments translated to DAGs)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Not specified in this paper; the generational EA framework is present but concrete crossover operator(s) used in CBGP runs are not detailed.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Not specified in this paper; mutation is implied as part of variation but details are not given (paper cites related literature on mutation-by-addition/deletion).</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Fitness is based on training-case errors computed from program DAG execution; compilation success is a prerequisite for non-penalized evaluation. Post-evolution simplification is used as a heuristic to improve generalization.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>CBGP runs using the generational EA produced high solution rates on the novel benchmarks (100%,100%,96.8%) and competitive results on standard benchmarks compared to PushGP and G3P; the paper does not attribute effects specifically to crossover versus mutation within the generational EA.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>evolutionary search for program synthesis</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>standard GP literature (PushGP, G3P) serve as contextual baselines</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>The paper uses a standard generational EA applied to a novel representation (linear genomes compiled to typed DAGs) and finds that representation and compilation contribute strongly to executability and evaluation efficiency; the paper does not provide operator-level analysis showing how specific crossover/mutation choices affect novelty/diversity/executability.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Code Building Genetic Programming', 'publication_date_yy_mm': '2020-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Plushi: an embeddable, language agnostic, push interpreter. <em>(Rating: 2)</em></li>
                <li>The Push3 execution stack and the evolution of control <em>(Rating: 2)</em></li>
                <li>Program Synthesis Using Uniform Mutation by Addition and Deletion <em>(Rating: 2)</em></li>
                <li>Linear Genomes for Structured Programs <em>(Rating: 2)</em></li>
                <li>A field guide to genetic programming <em>(Rating: 1)</em></li>
                <li>General Program Synthesis Benchmark Suite <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-1619",
    "paper_id": "paper-220253536",
    "extraction_schema_id": "extraction-schema-31",
    "extracted_data": [
        {
            "name_short": "CBGP",
            "name_full": "Code Building Genetic Programming",
            "brief_description": "A program-synthesis genetic programming system that evolves linear genomes which are compiled into typed, reified program DAGs that can be transpiled into human-readable host-language source code, with native support for polymorphic types, higher-order functions, and integration with preexisting code via reflection.",
            "citation_title": "here",
            "mention_or_use": "use",
            "system_name": "Code Building Genetic Programming (CBGP)",
            "system_description": "CBGP represents candidate programs as linear genomes (a derivative of the Plushy/Plushi representation) which are compiled via a Push-inspired stack process into type-safe directed acyclic computational graphs (program DAGs). Expressions wrap host-language functions, methods, constructors, constants and inputs and carry rich type specifications; reification rules refine expression specifications once child nodes are assigned. Evolution proceeds as a standard generational evolutionary algorithm over linear genomes; genomes are translated to Push-like code and then compiled into executable DAGs for evaluation. CBGP emphasizes executability (type-safe compilation), use of polymorphic and preexisting code, and transcribability to host-language source.",
            "input_type": "programs / source code (expressions wrapping host-language functions, methods, constructors; program DAGs compiled to host-language code)",
            "crossover_operation": "Not specified in the paper; the authors state the linear (Plushy-derived) genome allows a wide range of variation operators (including standard linear-genome crossover) but do not describe a concrete crossover mechanism or parameters.",
            "mutation_operation": "Not specified in the paper; the authors state CBGP borrows variation operators from contemporary methods and that the linear genome permits many operators. Genome simplification is used post-evolution; the paper cites related work on uniform mutation by addition and deletion but does not describe a specific mutation operator used in these experiments.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Primary executability metrics: (1) whether the Push-&gt;DAG compilation produced a valid program DAG of the requested return type (compilation success/failure), and (2) benchmark solution rate (number of successful evolutionary runs producing a correct program divided by total runs). Runtime exceptions during DAG evaluation are caught and produce penalty errors per training case.",
            "executability_results": "Reported benchmark solution rates on the novel benchmarks: Days Between 31/31 (100%), Filter Bounds 31/31 (100%), Prefix Paths 30/31 (96.8%). CBGP is reported to have significantly higher solution rates than PushGP on several General Program Synthesis Benchmark Suite problems (Negative To Zero, Median, Smallest, Vector Average) and significantly worse on two (Compare String Lengths, Replace Space With Newline); exact numeric solution rates for the latter comparisons are presented in Figure 7 of the paper but not all raw numbers are listed in-text.",
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "program synthesis / code generation (inductive program synthesis benchmarks and novel polymorphic-code benchmarks)",
            "comparison_baseline": "PushGP; Grammar-Guided Genetic Programming (G3P)",
            "key_findings": "CBGP's typed DAG compilation increases executability (type-safe programs, fewer runtime evaluation costs), enabling higher solution rates on several benchmarks relative to PushGP and parity or superiority over G3P on many tested problems. The paper does not analyze or report how specific crossover or mutation operators influenced novelty, diversity, or executability; instead it emphasizes representational advantages (polymorphism, expression reification, integration with host-language code) and faster evaluation due to compiled DAGs. Genome simplification post-evolution can improve generalization but the paper does not quantify mutation/crossover impacts on novelty/diversity.",
            "uuid": "e1619.0",
            "source_info": {
                "paper_title": "Code Building Genetic Programming",
                "publication_date_yy_mm": "2020-08"
            }
        },
        {
            "name_short": "PushGP",
            "name_full": "Push Genetic Programming (PushGP)",
            "brief_description": "A genetic programming framework that evolves programs in the stack-based Push language where programs are nested sequences of instructions and literals executed by a Push interpreter; Push code is interpreted per training case and uses stacks for different data types.",
            "citation_title": "",
            "mention_or_use": "use",
            "system_name": "PushGP",
            "system_description": "PushGP evolves programs written in the Push language, which is Turing-complete and stack-based; literals push values onto type-specific stacks and instructions pop required arguments and push results. PushGP programs are represented as nested token sequences interpreted by a Push virtual machine. The paper describes PushGP as a contemporary baseline and highlights limitations relative to CBGP (e.g., limited support for arbitrary/polymorphic data types without custom instructions, difficulty reifying into host-language source).",
            "input_type": "programs (Push language code sequences)",
            "crossover_operation": "Not detailed in this paper; PushGP commonly uses linear/genetic operators in prior literature, but the CBGP paper does not specify the crossover mechanism used in PushGP baseline experiments.",
            "mutation_operation": "Not detailed in this paper; CBGP cites PushGP as an existing method but does not describe PushGP mutation specifics.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "PushGP execution model: programs are interpreted per training case by the Push interpreter; executability is implicit (successful interpreter runs) and runtime behavior is used to compute fitness over training cases. The CBGP paper contrasts this with CBGP's compiled-DAG evaluation which requires only one compilation and is faster to evaluate across many cases.",
            "executability_results": "Qualitative comparison: CBGP achieves significantly higher solution rates than PushGP on several benchmark problems and worse on others; the paper reports statistical significance for some comparisons but does not supply full numeric breakdowns for all problems in-text.",
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "program synthesis (baseline compared to CBGP on General Program Synthesis Benchmark Suite problems)",
            "comparison_baseline": "CBGP (this paper compares solution rates against PushGP)",
            "key_findings": "PushGP is a useful baseline but lacks CBGP's automatic support for polymorphic host-language types and tight reification to host-language source; per-case interpretation makes evaluation costlier. The paper does not examine how PushGP's crossover/mutation influence novelty or executability in these experiments.",
            "uuid": "e1619.1",
            "source_info": {
                "paper_title": "Code Building Genetic Programming",
                "publication_date_yy_mm": "2020-08"
            }
        },
        {
            "name_short": "G3P",
            "name_full": "Grammar-Guided Genetic Programming (G3P)",
            "brief_description": "A genetic programming approach that uses context-free grammars (BNF) to constrain program generation, often via grammatical evolution mapping integer sequences to grammar productions, producing typesafe host-language source code.",
            "citation_title": "",
            "mention_or_use": "use",
            "system_name": "Grammar-Guided Genetic Programming (G3P)",
            "system_description": "G3P uses one or more context-free grammars to define the syntactic space of candidate programs; grammatical evolution or related mapping methods produce programs by selecting grammar productions. G3P can produce typesafe source in a host language, but extending the system to support new data types or polymorphism is laborious because grammars must be manually created or extended.",
            "input_type": "programs / source code (grammar-constrained host-language programs)",
            "crossover_operation": "Not specified in this paper; G3P implementations often apply crossover at the genotype (integer vector) or derivation-tree level, but the CBGP paper does not detail these operators.",
            "mutation_operation": "Not specified in this paper; G3P mutation mechanisms vary by implementation and are not described here.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "G3P produces typesafe host-language source via grammars, and executability is measured by whether generated code compiles/runs and its fitness on training/test cases; CBGP reports comparisons in solution rates but does not give G3P operator-level data.",
            "executability_results": "CBGP was not significantly worse than G3P on any tested problems and found significantly more solutions on several problems (Negative To Zero, Median, Number IO, Smallest, Vector Average) according to the paper's statistical tests; exact numeric values for G3P per-problem solution rates are in the paper's Figure 7.",
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "program synthesis (compared against CBGP on standard benchmarks)",
            "comparison_baseline": "CBGP (paper compares CBGP performance to G3P)",
            "key_findings": "G3P produces typesafe source and is a reasonable baseline; CBGP matches or outperforms G3P on several problems while offering additional capabilities (polymorphism, integration with host code). The paper does not analyze the role of G3P crossover/mutation in producing novelty/diversity.",
            "uuid": "e1619.2",
            "source_info": {
                "paper_title": "Code Building Genetic Programming",
                "publication_date_yy_mm": "2020-08"
            }
        },
        {
            "name_short": "Plushy genome",
            "name_full": "Plushy / Plushi linear genome representation",
            "brief_description": "A flat linear genome format (Plushy) used in PushGP systems in which a sequence of tokens and structure tokens (OPEN/CLOSE) encodes programs; CBGP uses a derivative of this representation to permit flexible variation operators and translation to Push code and program DAGs.",
            "citation_title": "Plushi: an embeddable, language agnostic, push interpreter.",
            "mention_or_use": "use",
            "system_name": "Plushy (linear) genome representation / Plushi interpreter",
            "system_description": "The Plushy genome is a linear encoding consisting of expressions interleaved with structure tokens (OPEN/CLOSE) that can be translated into nested Push-like code; CBGP uses a derivative of Plushy so that linear genomes can be translated into Push and then compiled into typed program DAGs. The linear encoding is chosen to support a wide variety of variation operators while avoiding direct graph/tree bloat.",
            "input_type": "programs (linear token sequences that compile to program DAGs)",
            "crossover_operation": "Not explicitly described in CBGP paper; the linear Plushy-style genome enables typical linear crossover operators (e.g., one-point, two-point, homologous crossover) but the paper does not commit to a concrete operator or implementation details.",
            "mutation_operation": "Not explicitly described in CBGP paper; linear genomes typically allow insertion/deletion/substitution mutations; the paper references prior work on uniform mutation by addition and deletion but does not specify which mutations were used in the experiments.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Plushy genomes are translated to Push-like representations and then compiled to typed DAGs; executability is ensured (or penalized) by the compilation process which can fail if type/spec constraints are not met.",
            "executability_results": "CBGP reports that the Plushy-derivative linear genome plus compilation avoids bloat and produces type-safe DAGs that are faster to evaluate than repeated Push interpreter runs; no numeric runtime microbenchmarks for genome formats are provided.",
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "representation layer for program synthesis GP",
            "comparison_baseline": "used as internal genome format; compared conceptually against direct tree/graph encodings in discussion",
            "key_findings": "Linear Plushy-derived genomes enable flexible variation operators and help avoid graph/tree bloat; CBGP leverages this to apply standard generational EA machinery, but the paper does not detail which specific crossover or mutation operators were applied nor how they affected solution novelty or diversity.",
            "uuid": "e1619.3",
            "source_info": {
                "paper_title": "Code Building Genetic Programming",
                "publication_date_yy_mm": "2020-08"
            }
        },
        {
            "name_short": "Generational EA",
            "name_full": "Typical generational evolutionary algorithm (as used in CBGP)",
            "brief_description": "A standard generational evolutionary algorithm maintaining a population of linear genomes, using error functions for fitness, parent selection, variation to create offspring, and replacement across generations; CBGP follows this overall pattern for program synthesis.",
            "citation_title": "",
            "mention_or_use": "use",
            "system_name": "Typical generational evolutionary algorithm (population, selection, variation, generational replacement)",
            "system_description": "CBGP implements a standard generational EA: maintain a population of individuals represented by linear genomes, evaluate individuals via compiled program DAGs on training cases to compute error/fitness (penalizing compilation failures and runtime exceptions), select parents according to a selection strategy, apply variation (crossover/mutation or other operators) to produce offspring, and iterate for generations. Genome simplification is applied to solutions post-evolution.",
            "input_type": "programs (linear genomes encoding program fragments translated to DAGs)",
            "crossover_operation": "Not specified in this paper; the generational EA framework is present but concrete crossover operator(s) used in CBGP runs are not detailed.",
            "mutation_operation": "Not specified in this paper; mutation is implied as part of variation but details are not given (paper cites related literature on mutation-by-addition/deletion).",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Fitness is based on training-case errors computed from program DAG execution; compilation success is a prerequisite for non-penalized evaluation. Post-evolution simplification is used as a heuristic to improve generalization.",
            "executability_results": "CBGP runs using the generational EA produced high solution rates on the novel benchmarks (100%,100%,96.8%) and competitive results on standard benchmarks compared to PushGP and G3P; the paper does not attribute effects specifically to crossover versus mutation within the generational EA.",
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "evolutionary search for program synthesis",
            "comparison_baseline": "standard GP literature (PushGP, G3P) serve as contextual baselines",
            "key_findings": "The paper uses a standard generational EA applied to a novel representation (linear genomes compiled to typed DAGs) and finds that representation and compilation contribute strongly to executability and evaluation efficiency; the paper does not provide operator-level analysis showing how specific crossover/mutation choices affect novelty/diversity/executability.",
            "uuid": "e1619.4",
            "source_info": {
                "paper_title": "Code Building Genetic Programming",
                "publication_date_yy_mm": "2020-08"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Plushi: an embeddable, language agnostic, push interpreter.",
            "rating": 2,
            "sanitized_title": "plushi_an_embeddable_language_agnostic_push_interpreter"
        },
        {
            "paper_title": "The Push3 execution stack and the evolution of control",
            "rating": 2,
            "sanitized_title": "the_push3_execution_stack_and_the_evolution_of_control"
        },
        {
            "paper_title": "Program Synthesis Using Uniform Mutation by Addition and Deletion",
            "rating": 2,
            "sanitized_title": "program_synthesis_using_uniform_mutation_by_addition_and_deletion"
        },
        {
            "paper_title": "Linear Genomes for Structured Programs",
            "rating": 2,
            "sanitized_title": "linear_genomes_for_structured_programs"
        },
        {
            "paper_title": "A field guide to genetic programming",
            "rating": 1,
            "sanitized_title": "a_field_guide_to_genetic_programming"
        },
        {
            "paper_title": "General Program Synthesis Benchmark Suite",
            "rating": 1,
            "sanitized_title": "general_program_synthesis_benchmark_suite"
        }
    ],
    "cost": 0.014967749999999998,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>Code Building Genetic Programming</p>
<p>Edward Pantridge 
Swoop Cambridge
MassachusettsUSA</p>
<p>Lee Spector lspector@hampshire.edu 
Amherst College
Hampshire College
UMass Amherst Amherst
MassachusettsUSA</p>
<p>Code Building Genetic Programming
10.1145/3377930.3390239</p>
<p>has been gaining attention in recent years is "general program synthesis," which specifically aims to produce programs that use similar constructs (data types, control flows, data structures) as human programmers. The goal of this research area is to eventually discover a process of automatic programming that is comparable to human skill [12].</p>
<p>Real world applications of a sufficiently sophisticated automatic programming system would have dramatic impact on software development. Organizations could potentially deploy automated systems that attempt to fix bugs or reduce the resource utilization of their software. In addition, there may be a class of problems for which the solution is difficult for humans to produce, but is easy for program synthesis methods to discover.</p>
<p>An ideal program synthesis framework must be capable of producing programs that utilize arbitrary data types, including types with arbitrary relationships, such as inheritance. The computations performed by this system must support generic manipulation of polymorphic types.</p>
<p>Humans rely on decomposition, abstraction, and re-use to create complex software applications. An ideal program synthesis framework must be able to utilize preexisting abstractions (human written and/or previously synthesized) in the programs it produces. Furthermore, the framework should not require additional configuration or modification to use problem-specific abstractions.</p>
<p>The output of an ideal program synthesis framework would be the same as the output of a human programmer. Typically this is source code that can be executed in any environment that supports the programming language.</p>
<p>No known program synthesis methodology is capable of achieving the goals stated above. This paper presents Code Building Genetic Programming (CBGP), a general program synthesis system with comparable problem solving performance to PushGP and G3P 1 . CBGP also provides additional capabilities that are not present in other program synthesis systems. These include: use of generic functions, support for polymorphic types, automatic integration with existing codebases, and transcription of programs into human-readable source code of the host language.</p>
<p>The rest of this paper is structured as follows. First, we discuss related work that informed our research. Second, we describe CBGP's program representation and the architecture of the search process. We then provide details on the benchmark problems used to evaluate CBGP and present early comparisons against other methods. We conclude with discussion of the implications of this work and suggestions for future research.</p>
<p>RELATED WORK</p>
<p>Inductive program synthesis is a research topic that spans multiple fields of study. Evolutionary computation has produced multiple genetic programming frameworks designed to synthesize general programs. Some of the state-of-the-art program synthesis methods include PushGP and Grammar Guided Genetic Programming (G3P).</p>
<p>PushGP evolves programs in a Turing complete language, called Push. The Push language uses a stack-based execution model [17]. Push programs are nested sequences of instructions and literals. Literals are values that get directly pushed onto a particular stack based on their data type. Instructions are functions that pop values off the stacks, transform them, and push the result back onto the appropriate stack. Programs are run through an interpreter and the final state of the stacks is considered the output of the program. Push code can be pushed onto a dedicated stack that can be used by instructions to implement control flow patterns like iteration and conditionals.</p>
<p>It is not possible for PushGP to evolve programs that use arbitrary data types without the definition of additional instructions. This means a custom PushGP system would need to be built to take advantage of preexisting problem-specific abstractions. Furthermore, it is not clear how to build a PushGP system capable of using overlapping types. If C sub is a concrete subclass with a concrete super-class, C super , which stack should an instruction that requires an input of type C super pop from to find its arguments? To our knowledge, no PushGP implementation has ever developed a successful strategy for dealing with this situation or any other form of polymorphism.</p>
<p>PushGP programs are nested sequences of tokens that can be processed by a Push interpreter. Thus, the programs are only as portable as the PushGP implementations that produces them. Reimplementation of Push programs into source code of a host-language is difficult because the stack-based execution does not map cleanly into common programming paradigms.</p>
<p>Grammar Guided Genetic Programming (G3P) is a more recently introduced method of inductive program synthesis that features a set of context-free Backus-Naur Form grammars [2]. G3P uses one grammar per supported data type to achieve coverage over general programs. Using these grammars, a grammatical evolution (GE) framework can map variable length sequences of integers into programs [16].</p>
<p>The G3P methodology has the advantage of producing typesafe source code in the host-language. The code produced can contain variable assignments, control flow, and iteration. It has been previously discussed that extension of G3P systems to support additional data types is laborious. It requires the manual creation and integration of additional grammars [2]. It has also been shown that the performance of G3P is sensitive to the exact implementation of the grammars [3]. Similar to PushGP, we do not know of any prior work that attempts to extend G3P to support polymorphism.</p>
<p>Other program synthesis methods that are not variants of genetic programming exist, such as: Excel Flash Fill [5], MagicHaskeller [11], TerpreT [4], and DeepCoder [1]. Although all of these systems are successful in their target problem domains, they are incapable of attempting the standard program synthesis benchmark problems Figure 1: Some example program DAGS. "DAG 1" shows a program that will return the first 3 elements of a list of strings. The list of strings is provided to the DAG as an input value named MyList. Definitions for the expressions in "DAG 1" can be found in Figure 2. "DAG 2" is an example of the use of higher order functions described in Section 3.2.</p>
<p>due to a lack of support for crucial data types and control structures [13].</p>
<p>Code Building Genetic Programming aims to be a program synthesis methodology with comparable search performance to PushGP and G3P, while adding some additional capabilities that bring the field significantly closer to feasible real-world applications.</p>
<p>STRUCTURE OF CBGP PROGRAMS</p>
<p>Programs produced by Code Building Genetic Programming are computational graphs. Each inner node of a graph is a function and each leaf node is either a constant value or a reference to one of the program's inputs. We use the general term "expression" as the name for a node in a computational graph. The computational graphs are directed and acyclic (DAG). A program produced by CBGP will be a DAG of expressions, called a "program DAG. "</p>
<p>Expressions</p>
<p>Expressions are containers that encapsulate a particular computation or value. In addition, expressions hold an associated specification of the computation they encapsulate. For this work, the specifications are annotations denoting relevant data types associated with the expression.</p>
<p>The prototype implementation of CBGP discussed in this paper uses a finite set of expression types. These include: Constants, Inputs, Functions, Methods, Constructors, and Higher Order Functions. DAG 1 shown in Figure 1 shows an example program DAG that represents a program that returns the first 3 elements of a list, or the entire list if it contains 3 or fewer elements. Descriptions of each expression in the DAG are found in Figure 2.</p>
<p>Note that the MyList expression is specified to return a list of strings which is a sub-type of list. The Length expression is specified to take a generic list as an argument, but the MyList expression is a valid child expression because all values of MyList are guaranteed to be instances of the expected argument type. Program DAGs are type-safe because the return type of all child  expressions are sub-types (or the same type) as the corresponding argument types of their parent expression.</p>
<p>Constants and Inputs are leaf nodes that don't require any arguments. Constants always return the same value and Inputs return the value of a specific input to the program DAG. Both expression types have a specification that is the data type of the value of the node. If the data type is a collection type, union type, or some other polymorphic type, the specification will be a decompose-able representation of the type and its parts. For example, a key-value map type annotation can be decomposed into the data type of the keys and values respectively. In Figure 1 the "MyList" expression is an Input and the "3" expression is a Constant.</p>
<p>Some expression nodes of a program DAG represent a functionlike computation that accepts arguments and returns a value. These expressions wrap an underlying function in the host-language. Method and Constructor expressions wrap parts of a pre-existing class definition. All function-like expressions have the same structure in their specification consisting of of a mapping from argument names to types and an additional type corresponding to the return value. In Figure 1 "Length, " "Min, " "Take, " and "Add" are all functionlike expressions.</p>
<p>It is possible for Function and Constructor expressions to be leaf nodes of a program DAG if they have an arity of zero. Method expressions cannot be leaf nodes because they are treated as functions which have an implicit argument that is the class instance object.</p>
<p>Higher Order and Anonymous Functions</p>
<p>Contemporary program synthesis frameworks, such as PushGP and G3P, have demonstrated the capability to produce programs that utilize iteration and control flow. It is challenging to express generic forms of iteration, such as a while-loop, in an acyclic computational graph. In contrast, higher order functions are beginning to see more widespread use in the computational graphs used by big-data processing frameworks like Spark [18]. CBGP draws inspiration from these modern DAG representations and uses higher order functions in program DAGs to manipulate data structures. Figure 1 depicts a program DAG that utilizes the map higher order function. The first argument to the map expression must be an expression that returns a collection. The second argument is an expression that represents an anonymous function to apply to each element of the collection.</p>
<p>As shown in DAG 2 of Figure 1, one of the expressions contained in the anonymous function sub-DAG is a special kind of Input expression, called a "local input. " These expressions can only exist in a program DAG as part of an anonymous function. Each call to the anonymous function within an execution of the DAG will use the collection element as the value for the local input. It is possible for multiple local input expressions to appear in a single anonymous function sub-DAG, and anonymous function DAGs may contain higher order function expressions with their nested anonymous function DAGs.</p>
<p>When the map Higher Order Function expression is evaluated as part of a program DAG, the following process is followed:</p>
<p>(1) An empty sequential buffer is initialized. The current implementation of CBGP also supports a filter Higher Order Function expression which follows a similar process. The anonymous function for the filter expression must return a Boolean value. Additional Higher Order Function expressions, such as reducing and partitioning, are possible but have not been implemented yet in any CBGP system.</p>
<p>AUTOMATIC EXPRESSION CREATION</p>
<p>It is becoming increasingly popular for programming languages to be accompanied by rich, first-class, data oriented, specification tooling. These tools enable static and run-time validations of code behavior. One example of this tooling is the typing module introduced into the standard library of the Python programming language as of version 3.5. This library adds type hint annotations to function definitions, which complement the primarily object oriented programming language [19]. The Clojure Spec library is an example of an exceptionally expressive specification framework that goes beyond type checking [10]. It has seen rapid adoption after its emergence into Clojure's functional programming ecosystem. These new technologies allow for systems to reason about programs, and their behavior, as first-class objects which is profoundly useful for program synthesis systems.</p>
<p>The prototype implementation of Code Building Genetic Programming uses Python's type annotations as specifications to the values and functions encapsulated in expressions. Importantly, for polymorphic types the annotations can go beyond the generic datatype. For example, a list of strings might be annotated as list or as List [str]. The List[str] annotation can be decomposed as a collection type (List) and an element type (str). The typing system also supports the comparison of types at run-time. For example, list is a sub-type of Sequence by inheritance and int is a sub-type of Union[int, float] by composition.</p>
<p>Furthermore, language features such as reflection can be used to automatically discover the available functions, types, and values defined in the environment as well as their associated specifications. This allows CBGP to be injected into an arbitrary run-time environment, with existing code and external dependencies, and create a set of expressions from the discover-able classes, functions, and variables. The only assumption made by CBGP is that there is an available specification for everything it finds. The implication of this is that CBGP can synthesize programs which utilize human written code, previously synthesized code, and external libraries without any additional modification or configuration.</p>
<p>As a consequence, in real world applications the performance of CBGP can be improved by a human developer creating additional abstraction for the CBGP system to use. This kind of cooperation between a human programmer and a program synthesis framework is infeasible under any other known method because incorporation of new human written abstractions require modification or laborious configuration of the program synthesis method.</p>
<p>COMPOSITION AND REIFICATION OF PROGRAMS</p>
<p>Once a set of expressions has been defined within the context of a Code Building Genetic Programming application, program DAGs can be produced via the composition of expressions. An expression becomes a program DAG once it is assigned child nodes that satisfy all of the arguments required by the specification. Each child node must also be a valid program DAG. Constant, Input, and zero-arity Function expressions are always valid program DAGs.</p>
<p>Expression Reification</p>
<p>Although a Function expression has a specification for the arguments and return value, it is often possible to produce a more exact specification of the expression once the precise specification of one or more of its child expressions is known. For example, the Take expression described in Figure 2 is initially specified to return a List. However, it is known at development time that the Take method will return a list with the same element type as the list the method was called on. If a MyList expression from Figure 2 is the child of a Take expression, the correct specification of the return type for the Take expression should be a List[str].</p>
<p>We name this process of updating the specification of an expression instance "expression reification" because it concretizes attributes of the specification that become implicit given the additional information provided by the specification of the child nodes. Figure 3 shows an example of different ways an arithmetic addition expression might be reified in a program DAG.</p>
<p>Reification is implemented in CBGP as a set of zero or more "reification rules" that are assigned to each expression based on its logical behavior. Figure 4 describes the reification rule types that are used in the CBGP implementation created for this research. Most function-like expressions either do not require reification, or require the exact reification described in one of the common rules. In other words, reification rules can be heavily reused throughout an application.</p>
<p>The Push Compilation Process</p>
<p>Code Building Genetic Programming evolves a collection of expressions than can be "compiled" into a program DAG using a stack-based process inspired by the PushGP execution model [17]. PushGP uses this stack-based model to run the evolved programs, while CBGP uses this process to construct the program DAGs.</p>
<p>This compilation process translates a nested, sequential, collection of expressions into a type-safe, reified, program DAG that satisfies the overall specification of the program being evolved. This ensures that the program produced can be evaluated and is unlikely to produce run-time errors.</p>
<p>The input to the DAG compilation process is a nested, sequential, structure of expressions and a specification of the return value for the desired program. Much like PushGP, the nested sequence of expressions is loaded onto the exec stack of a Push interpreter to be processed one element at a time. Unlike PushGP, the Push interpreter used by CBGP only contains 2 additional stacks: one for DAGs and one for anonymous function definitions.</p>
<p>While the exec stack is not empty, the top element is popped and processed depending on its type. Constant and Input instructions are pushed to the DAG stack. Function, Method, and Constructor expressions undergo the following process:</p>
<p>(1) For each argument in the expression's specification:</p>
<p>(a) The DAG stack is traversed. (b) If the next DAG returns a sub-type of the expected argument's type, the DAG is a viable child to the expression and is removed from the DAG stack. (c) The expression's specification is updated with its reification rules (if any). (d) Step 1 is repeated until all arguments are satisfied by a child expression, or an argument is found that can't be satisfied by any DAG on the stack.  Expression returns the argument type that is highest in a hierarchy. +, -, * If the top element of the exec stack is a list, it is pushed onto the anonymous function stack. It cannot be compiled into a program DAG because the required argument and return specifications are not known until the anonymous function is used by a specific higher order function.</p>
<p>When a Higher Order Function expression is processed, it undergoes the following process:</p>
<p>(1) The DAG stack will be traversed to find a child expression that returns a collection type. (2) If no collection type expression is found, the higher order function expression is discarded and the stacks are unchanged. Steps 3 through 5 are skipped. (3) The anonymous function stack is traversed. For each list on the stack: (a) A new Push compilation process is made to compile the list into a DAG. This compilation process uses local input expressions as references to an element of the collection. (b) If the nested compilation process produces a program DAG that returns the correct type 2 , the DAG is assigned as the anonymous function body. (4) If no viable anonymous functions are found on the anonymous function stack, the higher order function expression is discarded and any changes to stacks are reverted. (5) If the higher order function expression has both of the required child nodes, it becomes a valid DAG and is pushed to the DAG stack.</p>
<p>If a local input expression is processed outside of the compilation of an anonymous function, it is ignored and has no effect on the stacks.</p>
<p>Once the exec stack is empty, the DAG stack will hold zero or more program DAGs. To find the single DAG that will be considered the program DAG, elements are popped from the DAG stack until a DAG is found whose return type is the same type (or a sub-type) of the return value for the desired program.</p>
<p>It is possible that this compilation does not produce a program DAG that satisfies the specification of the program being evolved. This situation must be handled in the error functions that are used to guide evolution toward a solution.</p>
<p>GENETIC PROGRAMMING</p>
<p>The novel capabilities of CBGP come from its expressive program DAG representation and unique process for safely building the DAGs as described in Section 5.2. The implementation of CBGP used for this research borrows all other aspects of the evolutionary computation from existing contemporary methods. The evolutionary population holds individuals defined by a linear genome. Error functions are used to assign errors to individuals. A parent selection strategy is used to pick individuals for variation. In summary, CBGP implements a typical generational evolutionary algorithm [15].</p>
<p>After evolution has found a solution individual, commonly used genome simplification methods are used to simplify individuals without sacrificing performance. Often the simplified genomes produce program DAGs with improved generalization performance [6].</p>
<p>Genome Representation</p>
<p>Individuals in CBGP use a derivative of the Plushy genome representation found in multiple PushGP systems [14]. The genome is a flat sequence of expressions and structure tokens. The two kinds of structure tokens are OPEN tokens and CLOSE tokens. The Plushy genomes can be translated into a Push representation that can be compiled into a program DAG via the process outlined in Section 5.2.</p>
<p>This linear structure allows for the use of a wide range of variation operators, and has been shown to yield better search results [7,9]. Also, the layers of indirection when translating Plushy genomes into Push code and compiling Push code into program DAGs ensure that type-safe computational graphs can be evolved without suffering from the bloat that accompanies using graph (or tree) structures directly.</p>
<p>Evaluation of Program DAGs</p>
<p>Once an individual's genome has been translated into Push code and compiled into a program DAG, it can be evaluated by an error function. The general structure of a typical error function is to evaluate the program on set of training cases containing inputoutput pairs. If the Push compilation process did not produce a program DAG that returns the required type for the given problem, the individual is assigned penalty errors for every training case. It is also possible for a program DAG to raise exceptions during run-time because not all expressions are defined for every value of their argument types. For example, a function with an integer argument might only return when given a natural integer and raise an exception when given a negative integer. If this happens during program DAG evaluation, the exception is caught and a penalty error is assigned for the training case.</p>
<p>One advantage CBGP has over PushGP is that the program DAGs only need to be compiled once and then the individual can be evaluated on all training cases. PushGP requires a separate execution of the stack-based interpreter for every training case. The computation graph representation of the programs produced during CBGP are much faster to compute than the stack-based execution in PushGP. Given that evaluation is the most expensive step of the evolutionary cycle, CBGP has the potential to dramatically reduce the cost of evolution for program synthesis tasks.</p>
<p>PRODUCING SOURCE CODE</p>
<p>One appealing aspect of G3P systems is their ability to produce source code that is potentially readable by humans and is portable between codebases. This capability implies there is a possibility that a sufficiently capable GP system could eventually be used in cooperation with human developers to contribute to the same codebase.</p>
<p>The program DAGs synthesized by Code Building Genetic Programming are roughly analogous to abstract syntax trees. Using knowledge of the host-language's syntax, it is possible to produce source code from a program DAG. This process makes the output of CBGP human interpret-able and portable, similar to G3P.</p>
<p>As mentioned previously, program DAGs evolved by CBGP contain expressions that wrap existing functions and methods. Thus, the source code representation of a program DAG includes calls to these functions and methods. This further motivates the potential cooperation between human programmers and a program synthesis framework as mentioned in Section 4.</p>
<p>BENCHMARKS</p>
<p>For every benchmark problem, the CBGP system was configured to use the following evolutionary settings. With the exception of the relatively low number of runs per problem, these settings are comparable to those used by other GP frameworks in previous publications. We leave the study and calibration of these settings for CBGP as future work.</p>
<p>We tested a prototype implementation of CBGP on two small sets of benchmark problems. The first is a novel set of benchmarks which are designed to demonstrate CBGP's ability to handle polymorphic types and integrate with existing codebases. The second is a sample of problems taken from the "General Program Synthesis Benchmark Suite" which has become a standard benchmark set for program synthesis GP systems since its introduction in 2015 [8].</p>
<p>The novel benchmarks presented in this section are similar to typical utility functions that might be implemented in real world applications as part of a larger system. The "General Program Synthesis Benchmark Suite" problems are derivatives of introductory academic assignments [8]. In the following subsections we will describe the novel benchmarks created for CBGP.</p>
<p>Days Between</p>
<p>The "Days Between" problem is designed to demonstrate CBGP's ability to work with pre-defined types and classes. The problem prompt is as follows:</p>
<p>Given two DateTime objects, return the absolute number of days between them.</p>
<p>The API of DateTime class and the related TimeDelta class can be found in Figure 5. If should also be noted that DateTime and TimeDelta objects can be compared with comparison functions (ie. &lt;, , &gt;, , ==) and shifted with arithmetic functions (ie. add, sub).</p>
<p>To our knowledge, no program synthesis GP methods have shown a capability to work with date and time data types, without explicit configuration and extension.</p>
<p>Filter Bounds</p>
<p>The "Filter Bounds" problem shows CBGP's ability to produce functions that work with different instances of a polymorphic type. The "Filter Bounds" problem also requires use of higher order functions. The problem prompt is as follows:</p>
<p>Given a list of elements that are all of the same comparable type, T , and two instance of type T representing a lower and upper bound, filter the list to the elements that fall between two bounds (inclusively). For example, if given the list [6,5,4,3,2,1], the lower bound 3, and the upper bound 5 the result should be [5,4,3]. Also, given the list ["a","b","c"], the lower bound "x", and the upper bound "zzz" the result should be an empty list.</p>
<p>The datasets of training and test cases use a variety of comparable types for T . The evolved solution is expected to work generically for all lists of comparable elements.</p>
<p>Prefix Paths</p>
<p>The "Prefix Paths" problem is designed with similar goals to the "Days Between" problem, except with the added complexity of requiring the use of a higher order function. The problem prompt is as follows:</p>
<p>Given a Path object representing a root directory and a list of file names (as strings), return a list of Path objects that join the root path and each filename. The resulting list of Path objects should be in the same order as the given filenames. For example, given a root of Path("/tmp") and a list of files ["log.txt", "data.csv"], the result should be [Path("/tmp/log.txt"), Path("/tmp/data.csv")]. The API for the 'Path' class used in this benchmark can be found in Figure 5. The solution program should work with absolute and relative root paths.</p>
<p>RESULTS</p>
<p>We present solution rates of a Code Building Genetic Programming system on the three novel benchmarks in the following These benchmark problems are not complex and these high solution rates don't necessarily indicate a strong overall search performance of CBGP. Instead, these problems are meant to demonstrate particular novel capabilities of CBGP described in Section 8. To highlight the successful demonstration of these capabilities, Figure 6 contains generated Python code which was produced using a solution DAG from one evolutionary run and simple string formatting rules that transcribe a program DAG into valid source code. We see usages of functions, methods, constants, constructors, and higher order functions in the generated source code.</p>
<p>We also tested CBGP on seven problems from the "General Program Synthesis Benchmark Suite" in order to compare performance between CBGP and other contemporary program synthesis methods. Figure 7 shows the solution rates between CBGP, PushGP, and G3P.</p>
<p>The solution rates for CBGP are significantly higher (with a P-value of 0.05) than PushGP for Negative To Zero, Median, Smallest, and Vector Average. CBGP performs significantly worse than PushGP on Compare String Lengths and Replace Space With Newline.</p>
<p>Code Building GP is not significantly worse that G3P on any of the problems we experimented with and finds significantly more solutions for Negative To Zero, Median, Number IO, Smallest, and Vector Average.</p>
<p>It should be noted that differences in supported functions/instructions make comparison between CBGP, PushGP, and G3P problematic. The CBGP implementation created for this research uses a subset of Python's built-in functions and types to create expressions, in line with the design goals of the system 3 . PushGP and G3P use manually curated instruction sets and grammars that are designed not to "cheat" at solving the benchmarks with instructions that are too close to a solution. This practice is useful when comparing methods, but is unrepresentative of real-world applications, for which any augmentation or restriction of the instruction set would be acceptable if it produces results that meet a current need.</p>
<p>In most cases, the improved performance of CBGP can easily be explained by the differences in supported functions. For example, Python has a built-in sum function that will sum a list of numbers. This function is made available to CBGP but neither PushGP, nor G3P, choose to support an equivalent operation. This gives CBGP a significant advantage on the "Vector Average" problem.</p>
<p>Another crucial difference between PushGP, G3P, and CBGP is configuration of which operations to use for a particular problem. Both PushGP and G3P select a subset of supported operations and data types to include before an evolutionary run. This configuration varies for each benchmark problem. The CBGP experiments presented in this paper use the entire set of core functions and classes that were defined and annotated to be identical to the built in capabilities of the Python language. This puts CBGP at a disadvantage because its search space has not been narrowed to the relevant operatoins.</p>
<p>We suggest that future research should test CBGP more rigorously, including some experimentation with a set of expressions that matches what is available in PushGP and G3P for each problem.</p>
<p>DISCUSSION AND FUTURE WORK</p>
<p>The theoretical capabilities of Code Building Genetic Programming promise a wider range of potential applications than any other program synthesis GP system. The initial indication from our empirical results show that CBGP can demonstrate these applications, at least for simple problems. To our knowledge, CBGP is the first inductive programming method, genetic programming or otherwise, to demonstrate the ability to synthesize programs that utilize arbitrary preexisting data types and an ability to handle polymorphism.</p>
<p>Furthermore, the ability for CBGP to gather its own set of supported expressions by leveraging technologies like reflection greatly reduces the requirements on external configuration. This makes CBGP a much simpler program synthesis framework, potentially suitable for real world applications by non-expert practitioners.</p>
<p>With regard to problem solving capabilities, our initial crude results indicate that CBGP is comparable or superior on some problems, while severely lacking on others. More rigorous experiments on a wider set of benchmarks is required to understand the general advantages and disadvantages between CBGP and its contemporaries. This research is ongoing.</p>
<p>The following subsections will discuss areas of future research which would improve the overall quality of a Code Building Genetic Programming system.</p>
<p>Post-processing of Program DAGs</p>
<p>Computational graphs, like the ones constructed by CBGP, are common representations of executable procedures. One advantage to using computational graphs is the ability to canonicalize and optimize the graphs for improved performance. def replace_space_with_newline(input1): return sub(len(input1), print_tap(input1.replace(" ", "\n", -87)).count("\n")) def negative_to_zero(input1): return map(lambda _0: max(bool2int(not(float2bool(0.5724738469524758))), _0), input1) Figure 6: A small sample of solution code snippets produced by CBGP on the benchmark problems described in Section 8. The functions that are not built-in Python functions (ie. bool2int, print_tap) are simple wrapper functions that add the necessary annotations. Notice that CBGP generated the name "_0" for the arguments to lambda functions. Big data frameworks, like Spark, utilize lazy evaluation of execution plans consisting of map-reduce operations to allow for query optimization [20]. The optimizer mutates the DAG into a more efficient computation that has the same behavior. This optimization can also be used to canonicalize an execution plan so that caching strategies can detect if a equivalent computation has already been performed.</p>
<p>Code Building GP could eventually utilize similar optimization algorithms to produce programs that are more resource efficient and easier to convert into source code. The code in Figure 6 has multiple instances of unnecessary function calls. The presented solution to the "Negative to Zero" problem has an 4 node sub-DAG that will always return a zero. Genome simplification was unable to address these issues, but it is likely that a more sophisticated canonicalization process would.</p>
<p>More Expressive Specifications</p>
<p>The prototype CBGP implementation uses data type based specifications. Types are a relatively weak form of specification because some functions are not defined across the entire argument space. As specification tooling matures, it will be beneficial to implement CBGP such that it utilizes more information than data types. This will allow evolution to avoid most, if not all, run-time errors in its program DAGs which will reduce the use of penalty errors and smooth out the search space.</p>
<p>CONCLUSION</p>
<p>In this paper, we present Code Building Genetic Programming and show early demonstrations of its unique capabilities. The benchmarks clearly demonstrate the use of preexisting functions and classes in evolved program DAGs, as well as the transcription of DAGs into valid, type-safe, Python code. This would not be possible without the introduction of expression reification and the stack-based compilation process.</p>
<p>Although our comparison to other program synthesis frameworks is flawed, the problem solving ability of CBGP is promising. Regardless, we recognize the value of first-class specifications and tools like reflection in making program synthesis methods more adaptive to a given use case. We hope these lessons will help propel the field beyond the academic benchmarks towards real-world applications.</p>
<p>Finally, we direct future research towards rigorous evaluation of CBGP, DAG canonicalizatoin, richer specification, and attempted collaborations between a CBGP system and a human programmer on a complex, real-world application.</p>
<p>Figure 2 :
2The definitions of the expressions found in "DAG 1" ofFigure 1. The "Arguments" and "Return" attributes of a an expression make up their specification. Method expressions treat the class instance object as an implicit argument.</p>
<p>( 2 )
2The child expression corresponding to the sequential collection is evaluated.(3) For each element of the resulting collection: (a) The anonymous function child expression is called with the element passed as the value for the local input. Input values of the overall program DAG are also passed to the anonymous function. (b) The resulting value is appended to the buffer. (4) The buffer is returned as the output of the map expression.</p>
<p>Figure 3 :
3Box 1 diagrams an "Add" expression with its default specification and no arguments. Boxes 2 and 3 show two different possible reifications for the "Add" expression depending on the exact type of the arguments.</p>
<p>( 2 )
2If the set of child DAGs is incomplete: (a) The expression is discarded. (b) All stacks are reverted to their original states. (c) Step 3 is skipped. (3) If all arguments are satisfied by a child node,</p>
<p>Figure 4 :
4The set of reification rules used to in the prototype implementation of CBGP presented in this paper.(a) The children are assigned to the expression, creating a valid DAG. (b) The new DAG is pushed to the DAG stack.</p>
<p>Figure 5 :
5APIs of the classes defined for the benchmark problems. These classes are annotated versions of existing classes provided by the Python standard library. This collection of classes are meant to demonstrate CBGP's ability to interface with pre-existing codebases.</p>
<p>Figure 7 :
7Solution rates between CBGP, PushGP, and G3P on a subset of the General Program Synthesis Benchmark Suite.</p>
<p>Args To Element Expression argument must be the element type of the collection argument. index_of, find, is_in Args To Same Expression arguments must have the same type.Reification Rule 
Description 
Examples 
Pass Though 
Expression returns the same type as a particular argument. 
abs, reverse, filter 
Return Element 
Expression returns the element type of a collection argument. 
first, last, nth, max, min 
concat, &lt;, &gt; 
List Of 
Expression returns a list with an element type of another argument. 
list 
Max Type </p>
<p>table.Problem 
Solutions Rate 
Days Between 31/31 
100% 
Filter Bounds 31/31 
100% 
Prefix Paths 
30/31 
96.8% </p>
<p>def days_between(dt1, dt2): return abs(sub(dt1, dt2).days()) def prefix_files(root, filenames): return map(lambda _0: root.join(Path(_0)), filenames) def filter_bounds(lst, lower, upper): return filter(lambda _0: lt(lt(_0, lower), le(_0, upper)), lst)
An open source implementation of our prototype can be found at https://github.com/erp12/CodeBuildingGeneticProgramming-ProtoType
For example, Filter expressions must find a predicate anonymous function that returns a Boolean
A listing of python functions used in our CBGP prototype can be found in the source code files at https://github.com/erp12/CodeBuildingGeneticProgramming-ProtoType/tree/master/push4/library
ACKNOWLEDGMENTSWe thank Bill Tozier, Nicholas McPhee, and the members of the Hampshire College Institute for Computational Intelligence for discussions that advanced this work. This material is based upon work supported by the National Science Foundation under Grant No. 1617087. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the authors and do not necessarily reflect the views of the National Science Foundation.
DeepCoder: Learning to Write Programs. Matej Balog, Alexander L Gaunt, Marc Brockschmidt, Sebastian Nowozin, Daniel Tarlow, arXiv:1611.01989Matej Balog, Alexander L. Gaunt, Marc Brockschmidt, Sebastian Nowozin, and Daniel Tarlow. 2016. DeepCoder: Learning to Write Programs. CoRR abs/1611.01989 (2016). arXiv:1611.01989 http://arxiv.org/abs/1611.01989</p>
<p>A Grammar Design Pattern for Arbitrary Program Synthesis Problems in Genetic Programming. In Genetic Programming. Stefan Forstenlechner, David Fagan, Miguel Nicolau, Michael O&apos; Neill, Springer International PublishingChamStefan Forstenlechner, David Fagan, Miguel Nicolau, and Michael O'Neill. 2017. A Grammar Design Pattern for Arbitrary Program Synthesis Problems in Genetic Programming. In Genetic Programming. Springer International Publishing, Cham, 262-277.</p>
<p>Extending Program Synthesis Grammars for Grammar-Guided Genetic Programming. In Parallel Problem Solving from Nature -PPSN XV. Stefan Forstenlechner, David Fagan, Miguel Nicolau, Michael O&apos; Neill, Springer International PublishingChamStefan Forstenlechner, David Fagan, Miguel Nicolau, and Michael O'Neill. 2018. Extending Program Synthesis Grammars for Grammar-Guided Genetic Program- ming. In Parallel Problem Solving from Nature -PPSN XV. Springer International Publishing, Cham, 197-208.</p>
<p>TerpreT: A Probabilistic Programming Language for Program Induction. Alexander L Gaunt, Marc Brockschmidt, Rishabh Singh, Nate Kushman, Pushmeet Kohli, Jonathan Taylor, Daniel Tarlow, arXiv:1608.04428Alexander L. Gaunt, Marc Brockschmidt, Rishabh Singh, Nate Kushman, Push- meet Kohli, Jonathan Taylor, and Daniel Tarlow. 2016. TerpreT: A Probabilistic Programming Language for Program Induction. CoRR abs/1608.04428 (2016). arXiv:1608.04428 http://arxiv.org/abs/1608.04428</p>
<p>Automating String Processing in Spreadsheets using Input-Output Examples. Sumit Gulwani, PoPL'11. Austin, Texas, USA; austin, texas, usaSumit Gulwani. 2011. Automating String Processing in Spread- sheets using Input-Output Examples. In PoPL'11, January 26-28, 2011, Austin, Texas, USA (popl'11, january 26-28, 2011, austin, texas, usa ed.). https://www.microsoft.com/en-us/research/publication/ automating-string-processing-spreadsheets-using-input-output-examples/</p>
<p>Improving Generalization of Evolved Programs through Automatic Simplification. Thomas Helmuth, Nicholas Freitag Mcphee, Edward Pantridge, Lee Spector, 10.1145/3071178.3071330Proceedings of the Genetic and Evolutionary Computation Conference (GECCO '17). the Genetic and Evolutionary Computation Conference (GECCO '17)New York, NY, USAAssociation for Computing MachineryThomas Helmuth, Nicholas Freitag McPhee, Edward Pantridge, and Lee Spec- tor. 2017. Improving Generalization of Evolved Programs through Automatic Simplification. In Proceedings of the Genetic and Evolutionary Computation Con- ference (GECCO '17). Association for Computing Machinery, New York, NY, USA, 937-944. https://doi.org/10.1145/3071178.3071330</p>
<p>Program Synthesis Using Uniform Mutation by Addition and Deletion. Thomas Helmuth, Nicholas Freitag Mcphee, Lee Spector, 10.1145/3205455.3205603Proceedings of the Genetic and Evolutionary Computation Conference (GECCO '18). the Genetic and Evolutionary Computation Conference (GECCO '18)New York, NY, USAACMThomas Helmuth, Nicholas Freitag McPhee, and Lee Spector. 2018. Program Synthesis Using Uniform Mutation by Addition and Deletion. In Proceedings of the Genetic and Evolutionary Computation Conference (GECCO '18). ACM, New York, NY, USA, 1127-1134. https://doi.org/10.1145/3205455.3205603</p>
<p>General Program Synthesis Benchmark Suite. Thomas Helmuth, Lee Spector, 10.1145/2739480.2754769Proceedings of the 2015 Annual Conference on Genetic and Evolutionary Computation (GECCO '15). the 2015 Annual Conference on Genetic and Evolutionary Computation (GECCO '15)New York, NY, USAAssociation for Computing MachineryThomas Helmuth and Lee Spector. 2015. General Program Synthesis Benchmark Suite. In Proceedings of the 2015 Annual Conference on Genetic and Evolutionary Computation (GECCO '15). Association for Computing Machinery, New York, NY, USA, 1039-1046. https://doi.org/10.1145/2739480.2754769</p>
<p>Linear Genomes for Structured Programs. Thomas Helmuth, Lee Spector, Nicholas Freitag Mcphee, Saul Shanabrook, Genetic Programming Theory and Practice XIV. SpringerThomas Helmuth, Lee Spector, Nicholas Freitag McPhee, and Saul Shanabrook. 2017. Linear Genomes for Structured Programs. In Genetic Programming Theory and Practice XIV. Springer.</p>
<p>clojure.spec -Rationale and Overview. Rich Hickey. 2016.Rich Hickey. 2016. clojure.spec -Rationale and Overview. (May 2016). https: //clojure.org/about/spec</p>
<p>Efficient Exhaustive Generation of Functional Programs Using Monte-Carlo Search with Iterative Deepening. Susumu Katayama, PRICAI 2008: Trends in Artificial Intelligence. Berlin Heidelberg; Berlin, HeidelbergSpringerSusumu Katayama. 2008. Efficient Exhaustive Generation of Functional Programs Using Monte-Carlo Search with Iterative Deepening. In PRICAI 2008: Trends in Artificial Intelligence. Springer Berlin Heidelberg, Berlin, Heidelberg, 199-210.</p>
<p>Automatic programming: The open issue?. O&apos; Michael, Lee Neill, Spector, 10.1007/s10710-019-09364-2Genetic Programming and Evolvable Machines. Michael O'Neill and Lee Spector. 2019. Automatic programming: The open issue? Genetic Programming and Evolvable Machines (2019). https://doi.org/10.1007/ s10710-019-09364-2</p>
<p>On the Difficulty of Benchmarking Inductive Program Synthesis Methods. Edward Pantridge, Thomas Helmuth, Nicholas Freitag Mcphee, Lee Spector, 10.1145/3067695.3082533Proceedings of the Genetic and Evolutionary Computation Conference Companion (GECCO '17). the Genetic and Evolutionary Computation Conference Companion (GECCO '17)New York, NY, USAAssociation for Computing MachineryEdward Pantridge, Thomas Helmuth, Nicholas Freitag McPhee, and Lee Spector. 2017. On the Difficulty of Benchmarking Inductive Program Synthesis Methods. In Proceedings of the Genetic and Evolutionary Computation Conference Compan- ion (GECCO '17). Association for Computing Machinery, New York, NY, USA, 1589-1596. https://doi.org/10.1145/3067695.3082533</p>
<p>Plushi: an embeddable, language agnostic, push interpreter. R Edward, Lee Pantridge, Spector, 10.1145/3205651.3208296Proceedings of the Genetic and Evolutionary Computation Conference Companion. the Genetic and Evolutionary Computation Conference CompanionKyoto, JapanACMEdward R. Pantridge and Lee Spector. 2018. Plushi: an embeddable, language agnostic, push interpreter. In Proceedings of the Genetic and Evolutionary Compu- tation Conference Companion, GECCO 2018, Kyoto, Japan, July 15-19, 2018. ACM, 1379-1385. https://doi.org/10.1145/3205651.3208296</p>
<p>A field guide to genetic programming. Riccardo Poli, William B Langdon, Nicholas Freitag Mcphee, J. R. KozaRiccardo Poli, William B. Langdon, and Nicholas Freitag McPhee. 2008. A field guide to genetic programming. Published via http://lulu.com and freely avail- able at http://www.gp-field-guide.org.uk. (With contributions by J. R. Koza).</p>
<p>Grammatical evolution: Evolving programs for an arbitrary language. Conor Ryan, Michael O Collins, Neill, Genetic Programming. Berlin Heidelberg; Berlin, HeidelbergSpringerConor Ryan, JJ Collins, and Michael O. Neill. 1998. Grammatical evolution: Evolving programs for an arbitrary language. In Genetic Programming. Springer Berlin Heidelberg, Berlin, Heidelberg, 83-96.</p>
<p>The Push3 execution stack and the evolution of control. Lee Spector, Jon Klein, Maarten Keijzer, 10.1145/1068009.1068292Lee Spector, Jon Klein, and Maarten Keijzer. 2005. The Push3 execution stack and the evolution of control. 1689-1696. https://doi.org/10.1145/1068009.1068292</p>
<p>Introducing New Built-in and Higher-Order Functions for Complex Data Types in Apache. Takuya Ueshin, Herman Van Hovell, Spark 2.4.Takuya Ueshin and Herman Van Hovell. 2018. Introducing New Built-in and Higher-Order Functions for Complex Data Types in Apache Spark 2.4. (Nov 2018).</p>
<p>PEP 484 -Type Hints. Guido Van Rossum, Jukka Lehtosalo, Lukasz Langa, Guido Van Rossum, Jukka Lehtosalo, and Lukasz Langa. 2014. PEP 484 -Type Hints. (Sep 2014). https://www.python.org/dev/peps/pep-0484/</p>
<p>Resilient distributed datasets: A fault-tolerant abstraction for in-memory cluster computing. Matei Zaharia, Mosharaf Chowdhury, Tathagata Das, Ankur Dave, Justin Ma, Murphy Mccauly, J Michael, Scott Franklin, Ion Shenker, Stoica, Presented as part of the 9th {USENIX} Symposium on Networked Systems Design and Implementation. Matei Zaharia, Mosharaf Chowdhury, Tathagata Das, Ankur Dave, Justin Ma, Murphy McCauly, Michael J Franklin, Scott Shenker, and Ion Stoica. 2012. Re- silient distributed datasets: A fault-tolerant abstraction for in-memory cluster computing. In Presented as part of the 9th {USENIX} Symposium on Networked Systems Design and Implementation ({NSDI} 12). 15-28.</p>            </div>
        </div>

    </div>
</body>
</html>