<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-6578 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-6578</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-6578</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-127.html">extraction-schema-127</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents that employ a memory mechanism to solve tasks, including details of the memory type, how it is accessed or updated, the tasks/benchmarks evaluated, performance with and without the memory, and any reported trade‑offs or limitations.</div>
                <p><strong>Paper ID:</strong> paper-80196cdfcd0c6ce2953bf65a7f019971e2026386</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/80196cdfcd0c6ce2953bf65a7f019971e2026386" target="_blank">IMPALA: Scalable Distributed Deep-RL with Importance Weighted Actor-Learner Architectures</a></p>
                <p><strong>Paper Venue:</strong> International Conference on Machine Learning</p>
                <p><strong>Paper TL;DR:</strong> A new distributed agent IMPALA (Importance Weighted Actor-Learner Architecture) is developed that not only uses resources more efficiently in single-machine training but also scales to thousands of machines without sacrificing data efficiency or resource utilisation.</p>
                <p><strong>Paper Abstract:</strong> In this work we aim to solve a large collection of tasks using a single reinforcement learning agent with a single set of parameters. A key challenge is to handle the increased amount of data and extended training time. We have developed a new distributed agent IMPALA (Importance Weighted Actor-Learner Architecture) that not only uses resources more efficiently in single-machine training but also scales to thousands of machines without sacrificing data efficiency or resource utilisation. We achieve stable learning at high throughput by combining decoupled acting and learning with a novel off-policy correction method called V-trace. We demonstrate the effectiveness of IMPALA for multi-task reinforcement learning on DMLab-30 (a set of 30 tasks from the DeepMind Lab environment (Beattie et al., 2016)) and Atari-57 (all available Atari games in Arcade Learning Environment (Bellemare et al., 2013a)). Our results show that IMPALA is able to achieve better performance than previous agents with less data, and crucially exhibits positive transfer between tasks as a result of its multi-task approach.</p>
                <p><strong>Cost:</strong> 0.013</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e6578.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e6578.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents that employ a memory mechanism to solve tasks, including details of the memory type, how it is accessed or updated, the tasks/benchmarks evaluated, performance with and without the memory, and any reported trade‑offs or limitations.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>IMPALA-LSTM</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>IMPALA agent (LSTM-based recurrent memory)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>The IMPALA reinforcement-learning agent architecture augmented with an LSTM recurrent module (and text embeddings for language-channel tasks) that provides an internal sequential memory (hidden/cell states) used to process language observations and maintain temporal context across steps; actors send initial LSTM state with trajectories to the learner.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>IMPALA (with LSTM)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>A distributed actor-learner RL agent (IMPALA) whose policy/value networks include an LSTM when used on tasks with a language channel; the LSTM receives text embeddings and visual inputs and maintains hidden/cell state across timesteps; actors include the initial LSTM state in trajectories sent to the learner so the learner can compute multi-step updates.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>≈1.2M (shallow) or ≈1.6M (deep) parameters (model architectures reported in paper)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>internal recurrent memory (LSTM hidden & cell state)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>LSTM hidden and cell state vectors; internal text embeddings are fed as inputs to the LSTM</td>
                        </tr>
                        <tr>
                            <td><strong>memory_access_mechanism</strong></td>
                            <td>recurrence (LSTM): sequential read/write via recurrent update at each time step; actors transmit the initial LSTM state along with trajectories to the learner so the learner can unroll and compute gradient updates over time</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>DMLab-30 language tasks (e.g., language_select-described_object, language_select_located_object, language_execute_random_task, language_answer_quantitative_question)</td>
                        </tr>
                        <tr>
                            <td><strong>task_category</strong></td>
                            <td>language-conditioned instruction following / grounded language tasks (within a 3D RL environment)</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>Per-table B.1 raw episode returns on DMLab-30 language tasks under IMPALA (agent using LSTM + text embeddings): language_select-described_object = 593.1 (raw score); language_select_located_object = 301.7; language_execute_random_task = 66.8; language_answer_quantitative_question = 264.0. Overall mean capped human-normalised score (DMLab-30, IMPALA, multi-task, deep, PBT) = 49.4% (mean capped human-normalised). (Metrics reported as raw episode returns per task and as capped human-normalised aggregate in paper.)</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_comparative_results</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td>Raw episode return per task (reported in Table B.1) and mean capped human-normalised percentage (aggregate DMLab-30 metric)</td>
                        </tr>
                        <tr>
                            <td><strong>tradeoffs_reported</strong></td>
                            <td>The paper does not report an explicit ablation comparing LSTM vs non-LSTM on the language tasks. It notes LSTM-based agents allow sequential processing of text inputs and that learner-side optimisations exploit LSTM structure (folding time into batch dimension) for computational efficiency; no explicit latency, memory-footprint, or stability trade-offs specific to the LSTM memory are reported in the paper.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>No task-level failure modes or direct negative-impact ablations of the LSTM memory are reported; the paper does not provide direct comparisons (with-memory vs without-memory) for the language tasks, so limitations specific to the memory mechanism are not experimentally characterised here.</td>
                        </tr>
                        <tr>
                            <td><strong>citation</strong></td>
                            <td>Lasse Espeholt, Hubert Soyer, Remi Munos, Karen Simonyan, Volodymyr Mnih, Tom Ward, Yotam Doron, Vlad Firoiu, Tim Harley, Iain Dunning, Shane Legg, Koray Kavukcuoglu. IMPALA: Scalable Distributed Deep-RL with Importance Weighted Actor-Learner Architectures. (DeepMind technical paper; authors and title as provided in the text.)</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'IMPALA: Scalable Distributed Deep-RL with Importance Weighted Actor-Learner Architectures', 'publication_date_yy_mm': '2018-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Grounded language learning in a simulated 3D world <em>(Rating: 2)</em></li>
                <li>Reinforcement learning with unsupervised auxiliary tasks <em>(Rating: 2)</em></li>
                <li>Asynchronous methods for deep reinforcement learning <em>(Rating: 2)</em></li>
                <li>Long short-term memory <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-6578",
    "paper_id": "paper-80196cdfcd0c6ce2953bf65a7f019971e2026386",
    "extraction_schema_id": "extraction-schema-127",
    "extracted_data": [
        {
            "name_short": "IMPALA-LSTM",
            "name_full": "IMPALA agent (LSTM-based recurrent memory)",
            "brief_description": "The IMPALA reinforcement-learning agent architecture augmented with an LSTM recurrent module (and text embeddings for language-channel tasks) that provides an internal sequential memory (hidden/cell states) used to process language observations and maintain temporal context across steps; actors send initial LSTM state with trajectories to the learner.",
            "citation_title": "here",
            "mention_or_use": "use",
            "agent_name": "IMPALA (with LSTM)",
            "agent_description": "A distributed actor-learner RL agent (IMPALA) whose policy/value networks include an LSTM when used on tasks with a language channel; the LSTM receives text embeddings and visual inputs and maintains hidden/cell state across timesteps; actors include the initial LSTM state in trajectories sent to the learner so the learner can compute multi-step updates.",
            "model_size": "≈1.2M (shallow) or ≈1.6M (deep) parameters (model architectures reported in paper)",
            "memory_used": true,
            "memory_type": "internal recurrent memory (LSTM hidden & cell state)",
            "memory_representation": "LSTM hidden and cell state vectors; internal text embeddings are fed as inputs to the LSTM",
            "memory_access_mechanism": "recurrence (LSTM): sequential read/write via recurrent update at each time step; actors transmit the initial LSTM state along with trajectories to the learner so the learner can unroll and compute gradient updates over time",
            "task_name": "DMLab-30 language tasks (e.g., language_select-described_object, language_select_located_object, language_execute_random_task, language_answer_quantitative_question)",
            "task_category": "language-conditioned instruction following / grounded language tasks (within a 3D RL environment)",
            "performance_with_memory": "Per-table B.1 raw episode returns on DMLab-30 language tasks under IMPALA (agent using LSTM + text embeddings): language_select-described_object = 593.1 (raw score); language_select_located_object = 301.7; language_execute_random_task = 66.8; language_answer_quantitative_question = 264.0. Overall mean capped human-normalised score (DMLab-30, IMPALA, multi-task, deep, PBT) = 49.4% (mean capped human-normalised). (Metrics reported as raw episode returns per task and as capped human-normalised aggregate in paper.)",
            "performance_without_memory": null,
            "has_comparative_results": false,
            "performance_metric": "Raw episode return per task (reported in Table B.1) and mean capped human-normalised percentage (aggregate DMLab-30 metric)",
            "tradeoffs_reported": "The paper does not report an explicit ablation comparing LSTM vs non-LSTM on the language tasks. It notes LSTM-based agents allow sequential processing of text inputs and that learner-side optimisations exploit LSTM structure (folding time into batch dimension) for computational efficiency; no explicit latency, memory-footprint, or stability trade-offs specific to the LSTM memory are reported in the paper.",
            "limitations_or_failure_cases": "No task-level failure modes or direct negative-impact ablations of the LSTM memory are reported; the paper does not provide direct comparisons (with-memory vs without-memory) for the language tasks, so limitations specific to the memory mechanism are not experimentally characterised here.",
            "citation": "Lasse Espeholt, Hubert Soyer, Remi Munos, Karen Simonyan, Volodymyr Mnih, Tom Ward, Yotam Doron, Vlad Firoiu, Tim Harley, Iain Dunning, Shane Legg, Koray Kavukcuoglu. IMPALA: Scalable Distributed Deep-RL with Importance Weighted Actor-Learner Architectures. (DeepMind technical paper; authors and title as provided in the text.)",
            "uuid": "e6578.0",
            "source_info": {
                "paper_title": "IMPALA: Scalable Distributed Deep-RL with Importance Weighted Actor-Learner Architectures",
                "publication_date_yy_mm": "2018-02"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Grounded language learning in a simulated 3D world",
            "rating": 2
        },
        {
            "paper_title": "Reinforcement learning with unsupervised auxiliary tasks",
            "rating": 2
        },
        {
            "paper_title": "Asynchronous methods for deep reinforcement learning",
            "rating": 2
        },
        {
            "paper_title": "Long short-term memory",
            "rating": 1
        }
    ],
    "cost": 0.012685499999999999,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>IMPALA: Scalable Distributed Deep-RL with Importance Weighted Actor-Learner Architectures</h1>
<p>Lasse Espeholt ${ }^{<em> 1}$ Hubert Soyer ${ }^{</em> 1}$ Remi Munos ${ }^{* 1}$ Karen Simonyan ${ }^{1}$ Volodymyr Mnih ${ }^{1}$ Tom Ward ${ }^{1}$<br>Yotam Doron ${ }^{1}$ Vlad Firoiu ${ }^{1}$ Tim Harley ${ }^{1}$ Iain Dunning ${ }^{1}$ Shane Legg ${ }^{1}$ Koray Kavukcuoglu ${ }^{1}$</p>
<h4>Abstract</h4>
<p>In this work we aim to solve a large collection of tasks using a single reinforcement learning agent with a single set of parameters. A key challenge is to handle the increased amount of data and extended training time. We have developed a new distributed agent IMPALA (Importance Weighted Actor-Learner Architecture) that not only uses resources more efficiently in singlemachine training but also scales to thousands of machines without sacrificing data efficiency or resource utilisation. We achieve stable learning at high throughput by combining decoupled acting and learning with a novel off-policy correction method called V-trace. We demonstrate the effectiveness of IMPALA for multi-task reinforcement learning on DMLab-30 (a set of 30 tasks from the DeepMind Lab environment (Beattie et al., 2016)) and Atari-57 (all available Atari games in Arcade Learning Environment (Bellemare et al., 2013a)). Our results show that IMPALA is able to achieve better performance than previous agents with less data, and crucially exhibits positive transfer between tasks as a result of its multi-task approach. The source code is publicly available at github.com/deepmind/scalable_agent.</p>
<h2>1. Introduction</h2>
<p>Deep reinforcement learning methods have recently mastered a wide variety of domains through trial and error learning (Mnih et al., 2015; Silver et al., 2017; 2016; Zoph et al., 2017; Lillicrap et al., 2015; Barth-Maron et al., 2018). While the improvements on tasks like the game of Go (Silver et al., 2017) and Atari games (Horgan et al., 2018) have been dramatic, the progress has been primarily in single task performance, where an agent is trained on each task</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup>separately. We are interested in developing new methods capable of mastering a diverse set of tasks simultaneously as well as environments suitable for evaluating such methods.</p>
<p>One of the main challenges in training a single agent on many tasks at once is scalability. Since the current state-of-the-art methods like A3C (Mnih et al., 2016) or UNREAL (Jaderberg et al., 2017b) can require as much as a billion frames and multiple days to master a single domain, training them on tens of domains at once is too slow to be practical.</p>
<p>We propose the Importance Weighted Actor-Learner Architecture (IMPALA) shown in Figure 1. IMPALA is capable of scaling to thousands of machines without sacrificing training stability or data efficiency. Unlike the popular A3C-based agents, in which workers communicate gradients with respect to the parameters of the policy to a central parameter server, IMPALA actors communicate trajectories of experience (sequences of states, actions, and rewards) to a centralised learner. Since the learner in IMPALA has access to full trajectories of experience we use a GPU to perform updates on mini-batches of trajectories while aggressively parallelising all time independent operations. This type of decoupled architecture can achieve very high throughput. However, because the policy used to generate a trajectory can lag behind the policy on the learner by several updates at the time of gradient calculation, learning becomes off-policy. Therefore, we introduce the $V$-trace off-policy actor-critic algorithm to correct for this harmful discrepancy.</p>
<p>With the scalable architecture and V-trace combined, IMPALA achieves exceptionally high data throughput rates of 250,000 frames per second, making it over 30 times faster than single-machine A3C. Crucially, IMPALA is also more data efficient than A3C based agents and more robust to hyperparameter values and network architectures, allowing it to make better use of deeper neural networks. We demonstrate the effectiveness of IMPALA by training a single agent on multi-task problems using DMLab-30, a new challenge set which consists of 30 diverse cognitive tasks in the 3D DeepMind Lab (Beattie et al., 2016) environment and by training a single agent on all games in the Atari-57 set of tasks.</p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1. Left: Single Learner. Each actor generates trajectories and sends them via a queue to the learner. Before starting the next trajectory, actor retrieves the latest policy parameters from learner. Right: Multiple Synchronous Learners. Policy parameters are distributed across multiple learners that work synchronously.</p>
<h2>2. Related Work</h2>
<p>The earliest attempts to scale up deep reinforcement learning relied on distributed asynchronous SGD (Dean et al., 2012) with multiple workers. Examples include distributed A3C (Mnih et al., 2016) and Gorila (Nair et al., 2015), a distributed version of Deep Q-Networks (Mnih et al., 2015). Recent alternatives to asynchronous SGD for RL include using evolutionary processes (Salimans et al., 2017), distributed BA3C (Adamski et al., 2018) and Ape-X (Horgan et al., 2018) which has a distributed replay but a synchronous learner.</p>
<p>There have also been multiple efforts that scale up reinforcement learning by utilising GPUs. One of the simplest of such methods is batched A2C (Clemente et al., 2017). At every step, batched A2C produces a batch of actions and applies them to a batch of environments. Therefore, the slowest environment in each batch determines the time it takes to perform the entire batch step (see Figure 2a and 2b). In other words, high variance in environment speed can severely limit performance. Batched A2C works particularly well on Atari environments, because rendering and game logic are computationally very cheap in comparison to the expensive tensor operations performed by reinforcement learning agents. However, more visually or physically complex environments can be slower to simulate and can have high variance in the time required for each step. Environments may also have variable length (sub)episodes causing a slowdown when initialising an episode.</p>
<p>The most similar architecture to IMPALA is GA3C (Babaeizadeh et al., 2016), which also uses asynchronous data collection to more effectively utilise GPUs. It decouples the acting/forward pass from the gradient calculation/backward pass by using dynamic batching. The actor/learner asynchrony in GA3C leads to instabilities during learning, which (Babaeizadeh et al., 2016) only partially mitigates by adding a small constant to action probabilities</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2. Timeline for one unroll with 4 steps using different architectures. Strategies shown in (a) and (b) can lead to low GPU utilisation due to rendering time variance within a batch. In (a), the actors are synchronised after every step. In (b) after every $n$ steps. IMPALA (c) decouples acting from learning.</p>
<p>During the estimation of the policy gradient. In contrast, IMPALA uses the more principled V-trace algorithm.</p>
<p>Related previous work on off-policy RL include (Precup et al., 2000; 2001; Wawrzynski, 2009; Geist &amp; Scherrer, 2014; O’Donoghue et al., 2017) and (Harutyunyan et al., 2016). The closest work to ours is the Retrace algorithm (Munos et al., 2016) which introduced an off-policy correction for multi-step RL, and has been used in several agent architectures (Wang et al., 2017; Gruslys et al., 2018). Retrace requires learning state-action-value functions $Q$ in order to make the off-policy correction. However, many actor-critic methods such as A3C learn a state-value function $V$ instead of a state-action-value function $Q$. V-trace is based on the state-value function.</p>
<h2>3. IMPALA</h2>
<p>IMPALA (Figure 1) uses an actor-critic setup to learn a policy $\pi$ and a baseline function $V^{\pi}$. The process of generating experiences is decoupled from learning the parameters of $\pi$ and $V^{\pi}$. The architecture consists of a set of actors, repeatedly generating trajectories of experience, and one or more learners that use the experiences sent from actors to learn $\pi$ off-policy.</p>
<p>At the beginning of each trajectory, an actor updates its own local policy $\mu$ to the latest learner policy $\pi$ and runs it for $n$ steps in its environment. After $n$ steps, the actor sends the trajectory of states, actions and rewards $x_{1},a_{1},r_{1}, \ldots, x_{n}, a_{n},r_{n}$ together with the corresponding policy distributions $\mu\left(a_{t} \mid x_{t}\right)$ and initial LSTM state to the learner through a queue. The learner then continuously updates its policy $\pi$ on batches of trajectories, each collected from many actors. This simple architecture enables the learner(s) to be accelerated using GPUs and actors to be easily distributed across many machines. However, the learner policy $\pi$ is potentially several updates ahead of the actor's policy $\mu$ at the time of update, therefore there is a policy-lag between the actors and learner(s). V-trace cor-</p>
<p>rects for this lag to achieve extremely high data throughput while maintaining data efficiency. Using an actor-learner architecture, provides fault tolerance like distributed A3C but often has lower communication overhead since the actors send observations rather than parameters/gradients.</p>
<p>With the introduction of very deep model architectures, the speed of a single GPU is often the limiting factor during training. IMPALA can be used with distributed set of learners to train large neural networks efficiently as shown in Figure 1. Parameters are distributed across the learners and actors retrieve the parameters from all the learners in parallel while only sending observations to a single learner. IMPALA use synchronised parameter update which is vital to maintain data efficiency when scaling to many machines (Chen et al., 2016).</p>
<h3>3.1. Efficiency Optimisations</h3>
<p>GPUs and many-core CPUs benefit greatly from running few large, parallelisable operations instead of many small operations. Since the learner in IMPALA performs updates on entire batches of trajectories, it is able to parallelise more of its computations than an online agent like A3C. As an example, a typical deep RL agent features a convolutional network followed by a Long Short-Term Memory (LSTM) (Hochreiter \&amp; Schmidhuber, 1997) and a fully connected output layer after the LSTM. An IMPALA learner applies the convolutional network to all inputs in parallel by folding the time dimension into the batch dimension. Similarly, it also applies the output layer to all time steps in parallel once all LSTM states are computed. This optimisation increases the effective batch size to thousands. LSTM-based agents also obtain significant speedups on the learner by exploiting the network structure dependencies and operation fusion (Appleyard et al., 2016).</p>
<p>Finally, we also make use of several off the shelf optimisations available in TensorFlow (Abadi et al., 2017) such as preparing the next batch of data for the learner while still performing computation, compiling parts of the computational graph with XLA (a TensorFlow Just-In-Time compiler) and optimising the data format to get the maximum performance from the cuDNN framework (Chetlur et al., 2014).</p>
<h2>4. V-trace</h2>
<p>Off-policy learning is important in the decoupled distributed actor-learner architecture because of the lag between when actions are generated by the actors and when the learner estimates the gradient. To this end, we introduce a novel offpolicy actor-critic algorithm for the learner, called V-trace.</p>
<p>First, let us introduce some notations. We consider the problem of discounted infinite-horizon RL in Markov Decision Processes (MDP), see (Puterman, 1994; Sutton \&amp;</p>
<p>Barto, 1998) where the goal is to find a policy $\pi$ that maximises the expected sum of future discounted rewards: $V^{\pi}(x) \stackrel{\text { def }}{=} \mathbb{E}<em 0="0" _geq="\geq" t="t">{\pi}\left[\sum</em>\right)$ is the action generated by following some policy $\pi$.} \gamma^{t} r_{t}\right]$, where $\gamma \in[0,1)$ is the discount factor, $r_{t}=r\left(x_{t}, a_{t}\right)$ is the reward at time $t, x_{t}$ is the state at time $t$ (initialised in $x_{0}=x$ ) and $a_{t} \sim \pi\left(\cdot \mid x_{t</p>
<p>The goal of an off-policy RL algorithm is to use trajectories generated by some policy $\mu$, called the behaviour policy, to learn the value function $V^{\pi}$ of another policy $\pi$ (possibly different from $\mu$ ), called the target policy.</p>
<h3>4.1. V-trace target</h3>
<p>Consider a trajectory $\left(x_{t}, a_{t}, r_{t}\right)<em s="s">{t=s}^{t=s+n}$ generated by the actor following some policy $\mu$. We define the $n$-steps V-trace target for $V\left(x</em>$, as:}\right)$, our value approximation at state $x_{s</p>
<p>$$
v_{s} \stackrel{\text { def }}{=} V\left(x_{s}\right)+\sum_{t=s}^{s+n-1} \gamma^{t-s}\left(\prod_{i=s}^{t-1} c_{i}\right) \delta_{t} V
$$</p>
<p>where $\delta_{t} V \stackrel{\text { def }}{=} \rho_{t}\left(r_{t}+\gamma V\left(x_{t+1}\right)-V\left(x_{t}\right)\right)$ is a temporal difference for $V$, and $\rho_{t} \stackrel{\text { def }}{=} \min \left(\bar{\rho}, \frac{\pi\left(a_{i} \mid x_{i}\right)}{\rho\left(a_{i} \mid x_{i}\right)}\right)$ and $c_{i} \stackrel{\text { def }}{=}$ $\min \left(\bar{c}, \frac{\pi\left(a_{i} \mid x_{i}\right)}{\rho\left(a_{i} \mid x_{i}\right)}\right)$ are truncated importance sampling (IS) weights (we make use of the notation $\prod_{i=s}^{t-1} c_{i}=1$ for $s=t$ ). In addition we assume that the truncation levels are such that $\bar{\rho} \geq \bar{c}$.</p>
<p>Notice that in the on-policy case (when $\pi=\mu$ ), and assuming that $\bar{c} \geq 1$, then all $c_{i}=1$ and $\rho_{t}=1$, thus (1) rewrites</p>
<p>$$
\begin{aligned}
v_{s} &amp; =V\left(x_{s}\right)+\sum_{t=s}^{s+n-1} \gamma^{t-s}\left(r_{t}+\gamma V\left(x_{t+1}\right)-V\left(x_{t}\right)\right) \
&amp; =\sum_{t=s}^{s+n-1} \gamma^{t-s} r_{t}+\gamma^{n} V\left(x_{s+n}\right)
\end{aligned}
$$</p>
<p>which is the on-policy $n$-steps Bellman target. Thus in the on-policy case, V-trace reduces to the on-policy $n$-steps Bellman update. This property (which Retrace (Munos et al., 2016) does not have) allows one to use the same algorithm for off- and on-policy data.</p>
<p>Notice that the (truncated) IS weights $c_{i}$ and $\rho_{t}$ play different roles. The weight $\rho_{t}$ appears in the definition of the temporal difference $\delta_{t} V$ and defines the fixed point of this update rule. In a tabular case, where functions can be perfectly represented, the fixed point of this update (i.e., when $V\left(x_{s}\right)=v_{s}$ for all states), characterised by $\delta_{t} V$ being equal to zero in expectation (under $\mu$ ), is the value function $V^{\pi_{\bar{\rho}}}$ of some policy $\pi_{\bar{\rho}}$, defined by</p>
<p>$$
\pi_{\bar{\rho}}(a \mid x) \stackrel{\text { def }}{=} \frac{\min (\bar{\rho} \mu(a \mid x), \pi(a \mid x))}{\sum_{b \in A} \min (\bar{\rho} \mu(b \mid x), \pi(b \mid x))}
$$</p>
<p>(see the analysis in Appendix A ). So when $\bar{\rho}$ is infinite (i.e. no truncation of $\rho_{t}$ ), then this is the value function $V^{\pi}$ of the target policy. However if we choose a truncation</p>
<p>level $\bar{\rho}&lt;\infty$, our fixed point is the value function $V^{\pi_{\bar{\rho}}}$ of a policy $\pi_{\bar{\rho}}$ which is somewhere between $\mu$ and $\pi$. At the limit when $\bar{\rho}$ is close to zero, we obtain the value function of the behaviour policy $V^{\mu}$. In Appendix A we prove the contraction of a related V-trace operator and the convergence of the corresponding online V-trace algorithm.</p>
<p>The weights $c_{i}$ are similar to the "trace cutting" coefficients in Retrace. Their product $c_{s} \ldots c_{t-1}$ measures how much a temporal difference $\delta_{t} V$ observed at time $t$ impacts the update of the value function at a previous time $s$. The more dissimilar $\pi$ and $\mu$ are (the more off-policy we are), the larger the variance of this product. We use the truncation level $\bar{c}$ as a variance reduction technique. However notice that this truncation does not impact the solution to which we converge (which is characterised by $\bar{\rho}$ only).</p>
<p>Thus we see that the truncation levels $\bar{c}$ and $\bar{\rho}$ represent different features of the algorithm: $\bar{\rho}$ impacts the nature of the value function we converge to, whereas $\bar{c}$ impacts the speed at which we converge to this function.
Remark 1. V-trace targets can be computed recursively:</p>
<p>$$
v_{s}=V\left(x_{s}\right)+\delta_{s} V+\gamma c_{s}\left(v_{s+1}-V\left(x_{s+1}\right)\right)
$$</p>
<p>Remark 2. Like in Retrace $(\lambda)$, we can also consider an additional discounting parameter $\lambda \in[0,1]$ in the definition of V-trace by setting $c_{i}=\lambda \min \left(\bar{c}, \frac{\pi\left(a_{i} \mid x_{i}\right)}{\mu\left(a_{i} \mid x_{i}\right)}\right)$. In the onpolicy case, when $n=\infty$, V-trace then reduces to $T D(\lambda)$.</p>
<h3>4.2. Actor-Critic algorithm</h3>
<h2>POLICY GRADIENT</h2>
<p>In the on-policy case, the gradient of the value function $V^{\mu}\left(x_{0}\right)$ with respect to some parameter of the policy $\mu$ is</p>
<p>$$
\nabla V^{\mu}\left(x_{0}\right)=\mathbb{E}<em 0="0" _geq="\geq" s="s">{\mu}\left[\sum</em>\right)\right]
$$} \gamma^{s} \nabla \log \mu\left(a_{s} \mid x_{s}\right) Q^{\mu}\left(x_{s}, a_{s</p>
<p>where $Q^{\mu}\left(x_{s}, a_{s}\right) \stackrel{\text { def }}{=} \mathbb{E}<em _geq="\geq" s="s" t="t">{\mu}\left[\sum</em>} \gamma^{t-s} r_{t} \mid x_{s}, a_{s}\right]$ is the state-action value of policy $\mu$ at $\left(x_{s}, a_{s}\right)$. This is usually implemented by a stochastic gradient ascent that updates the policy parameters in the direction of $\mathbb{E<em s="s">{a</em>$ that are visited under some behaviour policy $\mu$.} \sim \mu\left(\cdot \mid x_{s}\right)}\left[\nabla \log \mu\left(a_{s} \mid x_{s}\right) q_{s} \mid x_{s}\right]$, where $q_{s}$ is an estimate of $Q^{\mu}\left(x_{s}, a_{s}\right)$, and averaged over the set of states $x_{s</p>
<p>Now in the off-policy setting that we consider, we can use an IS weight between the policy being evaluated $\pi_{\bar{\rho}}$ and the behaviour policy $\mu$, to update our policy parameter in the direction of</p>
<p>$$
\mathbb{E}<em s="s">{a</em>\right]
$$} \sim \mu\left(\cdot \mid x_{s}\right)}\left[\frac{\pi_{\bar{\rho}}\left(a_{s} \mid x_{s}\right)}{\mu\left(a_{s} \mid x_{s}\right)} \nabla \log \pi_{\bar{\rho}}\left(a_{s} \mid x_{s}\right) q_{s} \mid x_{s</p>
<p>where $q_{s} \stackrel{\text { def }}{=} r_{s}+\gamma v_{s+1}$ is an estimate of $Q^{\pi_{\bar{\rho}}}\left(x_{s}, a_{s}\right)$ built from the V-trace estimate $v_{s+1}$ at the next state $x_{s+1}$.</p>
<p>The reason why we use $q_{s}$ instead of $v_{s}$ as the target for our Q-value $Q^{\pi_{\bar{\rho}}}\left(x_{s}, a_{s}\right)$ is that, assuming our value estimate is correct at all states, i.e. $V=V^{\pi_{\bar{\rho}}}$, then we have $\mathbb{E}\left[q_{s} \mid x_{s}, a_{s}\right]=Q^{\pi_{\bar{\rho}}}\left(x_{s}, a_{s}\right)$ (whereas we do not have this property if we choose $q_{t}=v_{t}$ ). See Appendix A for analysis and Appendix E. 3 for a comparison of different ways to estimate $q_{s}$.</p>
<p>In order to reduce the variance of the policy gradient estimate (4), we usually subtract from $q_{s}$ a state-dependent baseline, such as the current value approximation $V\left(x_{s}\right)$.</p>
<p>Finally notice that (4) estimates the policy gradient for $\pi_{\bar{\rho}}$ which is the policy evaluated by the V-trace algorithm when using a truncation level $\bar{\rho}$. However assuming the bias $V^{\pi_{\bar{\rho}}}-V^{\pi}$ is small (e.g. if $\bar{\rho}$ is large enough) then we can expect $q_{s}$ to provide us with a good estimate of $Q^{\pi}\left(x_{s}, a_{s}\right)$. Taking into account these remarks, we derive the following canonical V-trace actor-critic algorithm.</p>
<h2>V-TRACE ACTOR-CRITIC ALGORITHM</h2>
<p>Consider a parametric representation $V_{\theta}$ of the value function and the current policy $\pi_{\omega}$. Trajectories have been generated by actors following some behaviour policy $\mu$. The V-trace targets $v_{s}$ are defined by (1). At training time $s$, the value parameters $\theta$ are updated by gradient descent on the $l 2$ loss to the target $v_{s}$, i.e., in the direction of</p>
<p>$$
\left(v_{s}-V_{\theta}\left(x_{s}\right)\right) \nabla_{\theta} V_{\theta}\left(x_{s}\right)
$$</p>
<p>and the policy parameters $\omega$ in the direction of the policy gradient:</p>
<p>$$
\rho_{s} \nabla_{\omega} \log \pi_{\omega}\left(a_{s} \mid x_{s}\right)\left(r_{s}+\gamma v_{s+1}-V_{\theta}\left(x_{s}\right)\right)
$$</p>
<p>In order to prevent premature convergence we may add an entropy bonus, like in A3C, along the direction</p>
<p>$$
-\nabla_{\omega} \sum_{a} \pi_{\omega}\left(a \mid x_{s}\right) \log \pi_{\omega}\left(a \mid x_{s}\right)
$$</p>
<p>The overall update is obtained by summing these three gradients rescaled by appropriate coefficients, which are hyperparameters of the algorithm.</p>
<h2>5. Experiments</h2>
<p>We investigate the performance of IMPALA under multiple settings. For data efficiency, computational performance and effectiveness of the off-policy correction we look at the learning behaviour of IMPALA agents trained on individual tasks. For multi-task learning we train agents-each with one set of weights for all tasks-on a newly introduced collection of 30 DeepMind Lab tasks and on all 57 games of the Atari Learning Environment (Bellemare et al., 2013a).</p>
<p>For all the experiments we have used two different model architectures: a shallow model similar to (Mnih et al., 2016)</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3. Model Architectures. Left: Small architecture, 2 convolutional layers and 1.2 million parameters. Right: Large architecture, 15 convolutional layers and 1.6 million parameters.</p>
<table>
<thead>
<tr>
<th>Architecture</th>
<th>CPUs</th>
<th>GPUs ${ }^{1}$</th>
<th>FPS ${ }^{2}$</th>
</tr>
</thead>
<tbody>
<tr>
<td>Single-Machine</td>
<td></td>
<td></td>
<td>Task 1 Task 2</td>
</tr>
<tr>
<td>A3C 32 workers</td>
<td>64</td>
<td>0</td>
<td>6.5 K 9 K</td>
</tr>
<tr>
<td>Batched A2C (sync step)</td>
<td>48</td>
<td>0</td>
<td>9 K 5 K</td>
</tr>
<tr>
<td>Batched A2C (sync step)</td>
<td>48</td>
<td>1</td>
<td>13 K 5.5 K</td>
</tr>
<tr>
<td>Batched A2C (sync traj.)</td>
<td>48</td>
<td>0</td>
<td>16 K 17.5 K</td>
</tr>
<tr>
<td>Batched A2C (dyn. batch)</td>
<td>48</td>
<td>1</td>
<td>16 K 13 K</td>
</tr>
<tr>
<td>IMPALA 48 actors</td>
<td>48</td>
<td>0</td>
<td>17 K 20.5 K</td>
</tr>
<tr>
<td>IMPALA (dyn. batch) 48 actors ${ }^{3}$</td>
<td>48</td>
<td>1</td>
<td>21 K 24 K</td>
</tr>
<tr>
<td>Distributed</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>A3C</td>
<td>200</td>
<td>0</td>
<td>46 K 50 K</td>
</tr>
<tr>
<td>IMPALA</td>
<td>150</td>
<td>1</td>
<td>80 K</td>
</tr>
<tr>
<td>IMPALA (optimised)</td>
<td>375</td>
<td>1</td>
<td>200 K</td>
</tr>
<tr>
<td>IMPALA (optimised) batch 128</td>
<td>500</td>
<td>1</td>
<td>250 K</td>
</tr>
</tbody>
</table>
<p>${ }^{1}$ Nvidia P100 ${ }^{2}$ In frames/sec ( 4 times the agent steps due to action repeat). ${ }^{3}$ Limited by amount of rendering possible on a single machine.</p>
<p>Table 1. Throughput on seekavoid_arena_01 (task 1) and rooms_keys_doors_puzzle (task 2) with the shallow model in Figure 3. The latter has variable length episodes and slow restarts. Batched A2C and IMPALA use batch size 32 if not otherwise mentioned.
with an LSTM before the policy and value (shown in Figure 3 (left)) and a deeper residual model (He et al., 2016) (shown in Figure 3 (right)). For tasks with a language channel we used an LSTM with text embeddings as input.</p>
<h3>5.1. Computational Performance</h3>
<p>High throughput, computational efficiency and scalability are among the main design goals of IMPALA. To demonstrate that IMPALA outperforms current algorithms in these metrics we compare A3C (Mnih et al., 2016), batched A2C variations and IMPALA variants with various optimisations. For single-machine experiments using GPUs, we use dynamic batching in the forward pass to avoid several batch size 1 forward passes. Our dynamic batching module is implemented by specialised TensorFlow operations but is
conceptually similar to the queues used in GA3C. Table 1 details the results for single-machine and multi-machine versions with the shallow model from Figure 3. In the singlemachine case, IMPALA achieves the highest performance on both tasks, ahead of all batched A2C variants and ahead of A3C. However, the distributed, multi-machine setup is where IMPALA can really demonstrate its scalability. With the optimisations from Section 3.1 to speed up the GPUbased learner, the IMPALA agent achieves a throughput rate of 250,000 frames $/ \mathrm{sec}$ or 21 billion frames/day. Note, to reduce the number of actors needed per learner, one can use auxiliary losses, data from experience replay or other expensive learner-only computation.</p>
<h3>5.2. Single-Task Training</h3>
<p>To investigate IMPALA's learning dynamics, we employ the single-task scenario where we train agents individually on 5 different DeepMind Lab tasks. The task set consists of a planning task, two maze navigation tasks, a laser tag task with scripted bots and a simple fruit collection task.</p>
<p>We perform hyperparameter sweeps over the weighting of entropy regularisation, the learning rate and the RMSProp epsilon. For each experiment we use an identical set of 24 pre-sampled hyperparameter combinations from the ranges in Appendix D.1 . The other hyperparameters were fixed to values specified in Appendix D. 3 .</p>
<h3>5.2.1. CONVERGENCE AND STABILITY</h3>
<p>Figure 4 shows a comparison between IMPALA, A3C and batched A2C with the shallow model in Figure 3. In all of the 5 tasks, either batched A2C or IMPALA reach the best final average return and in all tasks but seekavoid_arena_01 they are ahead of A3C throughout the entire course of training. IMPALA outperforms the synchronous batched A2C on 2 out of 5 tasks while achieving much higher throughput (see Table 1). We hypothesise that this behaviour could stem from the V-trace off-policy correction acting similarly to generalised advantage estimation (Schulman et al., 2016) and asynchronous data collection yielding more diverse batches of experience.</p>
<p>In addition to reaching better final performance, IMPALA is also more robust to the choice of hyperparameters than A3C. Figure 4 compares the final performance of the aforementioned methods across different hyperparameter combinations, sorted by average final return from high to low. Note that IMPALA achieves higher scores over a larger number of combinations than A3C.</p>
<h3>5.2.2. V-Trace Analysis</h3>
<p>To analyse V-trace we investigate four different algorithms:</p>
<ol>
<li>No-correction - No off-policy correction.</li>
</ol>
<p><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 4. Top Row: Single task training on 5 DeepMind Lab tasks. Each curve is the mean of the best 3 runs based on final return. IMPALA achieves better performance than A3C. Bottom Row: Stability across hyperparameter combinations sorted by the final performance across different hyperparameter combinations. IMPALA is consistently more stable than A3C.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: center;">Task 1</th>
<th style="text-align: center;">Task 2</th>
<th style="text-align: center;">Task 3</th>
<th style="text-align: center;">Task 4</th>
<th style="text-align: center;">Task 5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Without Replay</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">V-trace</td>
<td style="text-align: center;">46.8</td>
<td style="text-align: center;">32.9</td>
<td style="text-align: center;">$\mathbf{3 1 . 3}$</td>
<td style="text-align: center;">$\mathbf{2 2 9 . 2}$</td>
<td style="text-align: center;">$\mathbf{4 3 . 8}$</td>
</tr>
<tr>
<td style="text-align: left;">1-Step</td>
<td style="text-align: center;">$\mathbf{5 1 . 8}$</td>
<td style="text-align: center;">$\mathbf{3 5 . 9}$</td>
<td style="text-align: center;">25.4</td>
<td style="text-align: center;">215.8</td>
<td style="text-align: center;">43.7</td>
</tr>
<tr>
<td style="text-align: left;">$\varepsilon$-correction</td>
<td style="text-align: center;">44.2</td>
<td style="text-align: center;">27.3</td>
<td style="text-align: center;">4.3</td>
<td style="text-align: center;">107.7</td>
<td style="text-align: center;">41.5</td>
</tr>
<tr>
<td style="text-align: left;">No-correction</td>
<td style="text-align: center;">40.3</td>
<td style="text-align: center;">29.1</td>
<td style="text-align: center;">5.0</td>
<td style="text-align: center;">94.9</td>
<td style="text-align: center;">16.1</td>
</tr>
<tr>
<td style="text-align: left;">With Replay</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">V-trace</td>
<td style="text-align: center;">47.1</td>
<td style="text-align: center;">$\mathbf{3 5 . 8}$</td>
<td style="text-align: center;">$\mathbf{3 4 . 5}$</td>
<td style="text-align: center;">$\mathbf{2 5 0 . 8}$</td>
<td style="text-align: center;">$\mathbf{4 6 . 9}$</td>
</tr>
<tr>
<td style="text-align: left;">1-Step</td>
<td style="text-align: center;">$\mathbf{5 4 . 7}$</td>
<td style="text-align: center;">34.4</td>
<td style="text-align: center;">26.4</td>
<td style="text-align: center;">204.8</td>
<td style="text-align: center;">41.6</td>
</tr>
<tr>
<td style="text-align: left;">$\varepsilon$-correction</td>
<td style="text-align: center;">30.4</td>
<td style="text-align: center;">30.2</td>
<td style="text-align: center;">3.9</td>
<td style="text-align: center;">101.5</td>
<td style="text-align: center;">37.6</td>
</tr>
<tr>
<td style="text-align: left;">No-correction</td>
<td style="text-align: center;">35.0</td>
<td style="text-align: center;">21.1</td>
<td style="text-align: center;">2.8</td>
<td style="text-align: center;">85.0</td>
<td style="text-align: center;">11.2</td>
</tr>
</tbody>
</table>
<p>Table 2. Average final return over 3 best hyperparameters for different off-policy correction methods on 5 DeepMind Lab tasks. When the lag in policy is negligible both V-trace and 1-step importance sampling perform similarly well and better than $\varepsilon$-correction/No-correction. However, when the lag increases due to use of experience replay, V-trace performs better than all other methods in 4 out 5 tasks.
2. $\varepsilon$-correction - Add a small value $(\varepsilon=1 e-6)$ during gradient calculation to prevent $\log \pi(a)$ from becoming very small and leading to numerical instabilities, similar to <em>Babaeizadeh et al. (2016)</em>.
3. 1-step importance sampling - No off-policy correction when optimising $V(x)$. For the policy gradient, multiply the advantage at each time step by the corresponding importance weight. This variant is similar to V-trace without "traces" and is included to investigate the importance of "traces" in V-trace.
4. V-trace as described in Section 4.</p>
<p>For V-trace and 1-step importance sampling we clip each importance weight $\rho_{t}$ and $c_{t}$ at 1 (i.e. $\bar{c}=\bar{\rho}=1$ ). This reduces the variance of the gradient estimate but introduces a bias. Out of $\bar{\rho} \in[1,10,100]$ we found that $\bar{\rho}=1$ worked best.</p>
<p>We evaluate all algorithms on the set of 5 DeepMind Lab tasks from the previous section. We also add an experience replay buffer on the learner to increase the off-policy gap between $\pi$ and $\mu$. In the experience replay experiments we draw $50 \%$ of the items in each batch uniformly at random from the replay buffer. Table 2 shows the final performance for each algorithm with and without replay respectively. In the no replay setting, V-trace performs best on 3 out of 5 tasks, followed by 1-step importance sampling, $\varepsilon$-correction and No-correction. Although 1-step importance sampling performs similarly to V-trace in the no-replay setting, the gap widens on 4 out 5 tasks when using experience replay. This suggests that the cruder 1-step importance sampling approximation becomes insufficient as the target and behaviour policies deviate from each other more strongly. Also note that V-trace is the only variant that consistently benefits from adding experience replay. $\varepsilon$-correction improves significantly over No-correction on two tasks but lies far behind the importance-sampling based methods, particularly in the more off-policy setting with experience replay. Figure E. 1 shows results of a more detailed analysis. Figure E. 2 shows that the importance-sampling based methods also perform better across all hyperparameters and are typically more robust.</p>
<h3>5.3. Multi-Task Training</h3>
<p>IMPALA's high data throughput and data efficiency allow us to train not only on one task but on multiple tasks in parallel with only a minimal change to the training setup. Instead of running the same task on all actors, we allocate a fixed number of actors to each task in the multi-task suite. Note, the model does not know which task it is being trained or evaluated on.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: center;">Test score</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">A3C, deep</td>
<td style="text-align: center;">$23.8 \%$</td>
</tr>
<tr>
<td style="text-align: left;">IMPALA, shallow</td>
<td style="text-align: center;">$37.1 \%$</td>
</tr>
<tr>
<td style="text-align: left;">IMPALA-Experts, deep</td>
<td style="text-align: center;">$44.5 \%$</td>
</tr>
<tr>
<td style="text-align: left;">IMPALA, deep</td>
<td style="text-align: center;">$46.5 \%$</td>
</tr>
<tr>
<td style="text-align: left;">IMPALA, deep, PBT</td>
<td style="text-align: center;">$\mathbf{4 9 . 4 \%}$</td>
</tr>
<tr>
<td style="text-align: left;">IMPALA, deep, PBT, 8 learners</td>
<td style="text-align: center;">$49.1 \%$</td>
</tr>
</tbody>
</table>
<p>Table 3. Mean capped human normalised scores on DMLab-30. All models were evaluated on the test tasks with 500 episodes per task. The table shows the best score for each architecture.</p>
<h3>5.3.1. DMLAB-30</h3>
<p>To test IMPALA's performance in a multi-task setting we use DMLab-30, a set of 30 diverse tasks built on DeepMind Lab. Among the many task types in the suite are visually complex environments with natural-looking terrain, instruction-based tasks with grounded language (Hermann et al., 2017), navigation tasks, cognitive (Leibo et al., 2018) and first-person tagging tasks featuring scripted bots as opponents. A detailed description of DMLab-30 and the tasks are available at github.com/deepmind/lab and deepmind.com/dm-lab-30.</p>
<p>We compare multiple variants of IMPALA with a distributed A3C implementation. Except for agents using populationbased training (PBT) (Jaderberg et al., 2017a), all agents are trained with hyperparameter sweeps across the same range given in Appendix D.1. We report mean capped human normalised score where the score for each task is capped at $100 \%$ (see Appendix B ). Using mean capped human normalised score emphasises the need to solve multiple tasks instead of focusing on becoming super human on a single task. For PBT we use the mean capped human normalised score as fitness function and tune entropy cost, learning rate and RMSProp $\varepsilon$. See Appendix F for the specifics of the PBT setup.</p>
<p>In particular, we compare the following agent variants. $A 3 C$, deep, a distributed implementation with 210 workers (7 per task) featuring the deep residual network architecture (Figure 3 (Right)). IMPALA, shallow with 210 actors and IMPALA, deep with 150 actors both with a single learner. IMPALA, deep, PBT, the same as IMPALA, deep, but additionally using the PBT (Jaderberg et al., 2017a) for hyperparameter optimisation. Finally IMPALA, deep, PBT, 8 learners, which utilises 8 learner GPUs to maximise learning speed. We also train IMPALA agents in an expert setting, IMPALA-Experts, deep, where a separate agent is trained per task. In this case we did not optimise hyperparameters for each task separately but instead across all tasks on which the 30 expert agents were trained.</p>
<p>Table 3 and Figure 5 show all variants of IMPALA performing much better than the deep distributed A3C. Moreover, the deep variant of IMPALA performs better than the shal-
low network version not only in terms of final performance but throughout the entire training. Note in Table 3 that IMPALA, deep, PBT, 8 learners, although providing much higher throughput, reaches the same final performance as the 1 GPU IMPALA, deep, PBT in the same number of steps. Of particular importance is the gap between the IMPALAExperts which were trained on each task individually and IMPALA, deep, PBT which was trained on all tasks at once. As Figure 5 shows, the multi-task version is outperforms IMPALA-Experts throughout training and the breakdown into individual scores in Appendix B shows positive transfer on tasks such as language tasks and laser tag tasks.</p>
<p>Comparing A3C to IMPALA with respect to wall clock time (Figure 6) further highlights the scalability gap between the two approaches. IMPALA with 1 learner takes only around 10 hours to reach the same performance that A3C approaches after 7.5 days. Using 8 learner GPUs instead of 1 further speeds up training of the deep model by a factor of 7 to 210 K frames $/ \mathrm{sec}$, up from 30 K frames $/ \mathrm{sec}$.</p>
<h3>5.3.2. ATARI</h3>
<p>The Atari Learning Environment (ALE) (Bellemare et al., 2013b) has been the testing ground of most recent deep reinforcement agents. Its 57 tasks pose challenging reinforcement learning problems including exploration, planning, reactive play and complex visual input. Most games feature very different visuals and game mechanics which makes this domain particularly challenging for multi-task learning.</p>
<p>We train IMPALA and A3C agents on each game individually and compare their performance using the deep network (without the LSTM) introduced in Section 5. We also provide results using a shallow network that is equivalent to the feed forward network used in (Mnih et al., 2016) which features three convolutional layers. The network is provided with a short term history by stacking the 4 most recent observations at each step. For details on pre-processing and hyperparameter setup please refer to Appendix G .</p>
<p>In addition to individual per-game experts, trained for 200 million frames with a fixed set of hyperparameters, we train an IMPALA Atari- 57 agent-one agent, one set of weightson all 57 Atari games at once for 200 million frames per game or a total of 11.4 billion frames. For the Atari- 57 agent, we use population based training with a population size of 24 to adapt entropy regularisation, learning rate, RMSProp $\varepsilon$ and the global gradient norm clipping threshold throughout training.</p>
<p>We compare all algorithms in terms of median human normalised score across all 57 Atari games. Evaluation follows a standard protocol, each game-score is the mean over 200 evaluation episodes, each episode was started with a random</p>
<p>Figure 5. Performance of best agent in each sweep/population during training on the DMLab-30 task-set wrt. data consumed across all environments. IMPALA with multi-task training is not only faster, it also converges at higher accuracy with better data efficiency across all 30 tasks. The x-axis is data consumed by one agent out of a hyperparameter sweep/PBT population of 24 agents, total data consumed across the whole population/sweep can be obtained by multiplying with the population/sweep size.
<img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 6. Performance on DMLab-30 wrt. wall-clock time. All models used the deep architecture (Figure 3). The high throughput of IMPALA results in orders of magnitude faster learning.
number of no-op actions (uniformly chosen from $[1,30]$ ) to combat the determinism of the ALE environment.</p>
<p>As table 4 shows, IMPALA experts provide both better final performance and data efficiency than their A3C counterparts in the deep and the shallow configuration. As in our DeepMind Lab experiments, the deep residual network leads to higher scores than the shallow network, irrespective of the reinforcement learning algorithm used. Note that the shallow IMPALA experiment completes training over 200 million frames in less than one hour.</p>
<p>We want to particularly emphasise that IMPALA, deep, multitask, a single agent trained on all 57 ALE games at once, reaches $59.7 \%$ median human normalised score. Despite</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Human Normalised Return</th>
<th style="text-align: right;">Median</th>
<th style="text-align: right;">Mean</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">A3C, shallow, experts</td>
<td style="text-align: right;">$54.9 \%$</td>
<td style="text-align: right;">$285.9 \%$</td>
</tr>
<tr>
<td style="text-align: left;">A3C, deep, experts</td>
<td style="text-align: right;">$117.9 \%$</td>
<td style="text-align: right;">$503.6 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Reactor, experts</td>
<td style="text-align: right;">$187 \%$</td>
<td style="text-align: right;">N/A</td>
</tr>
<tr>
<td style="text-align: left;">IMPALA, shallow, experts</td>
<td style="text-align: right;">$93.2 \%$</td>
<td style="text-align: right;">$466.4 \%$</td>
</tr>
<tr>
<td style="text-align: left;">IMPALA, deep, experts</td>
<td style="text-align: right;">$191.8 \%$</td>
<td style="text-align: right;">$957.6 \%$</td>
</tr>
<tr>
<td style="text-align: left;">IMPALA, deep, multi-task</td>
<td style="text-align: right;">$59.7 \%$</td>
<td style="text-align: right;">$176.9 \%$</td>
</tr>
</tbody>
</table>
<p>Table 4. Human normalised scores on Atari-57. Up to 30 no-ops at the beginning of each episode. For a level-by-level comparison to ACKTR (Wu et al., 2017) and Reactor see Appendix C.1 .
the high diversity in visual appearance and game mechanics within the ALE suite, IMPALA multi-task still manages to stay competitive to $A 3 C$, shallow, experts, commonly used as a baseline in related work. ALE is typically considered a hard multi-task environment, often accompanied by negative transfer between tasks (Rusu et al., 2016). To our knowledge, IMPALA is the first agent to be trained in a multi-task setting on all 57 games of ALE that is competitive with a standard expert baseline.</p>
<h2>6. Conclusion</h2>
<p>We have introduced a new highly scalable distributed agent, IMPALA, and a new off-policy learning algorithm, V-trace. With its simple but scalable distributed architecture, IMPALA can make efficient use of available compute at small and large scale. This directly translates to very quick turnaround for investigating new ideas and opens up unexplored opportunities.</p>
<p>V-trace is a general off-policy learning algorithm that is more stable and robust compared to other off-policy correction methods for actor critic agents. We have demonstrated that IMPALA achieves better performance compared to A3C variants in terms of data efficiency, stability and final performance. We have further evaluated IMPALA on the new DMLab-30 set and the Atari-57 set. To the best of our knowledge, IMPALA is the first Deep-RL agent that has been successfully tested in such large-scale multi-task settings and it has shown superior performance compared to A3C based agents ( $49.4 \%$ vs. $23.8 \%$ human normalised score on DMLab-30). Most importantly, our experiments on DMLab-30 show that, in the multi-task setting, positive transfer between individual tasks lead IMPALA to achieve better performance compared to the expert training setting. We believe that IMPALA provides a simple yet scalable and robust framework for building better Deep-RL agents and has the potential to enable research on new challenges.</p>
<h2>Acknowledgements</h2>
<p>We would like to thank Denis Teplyashin, Ricardo Barreira, Manuel Sanchez for their work improving the performance on DMLab-30 environments and Matteo Hessel, Jony Hudson, Igor Babuschkin, Max Jaderberg, Ivo Danihelka, Jacob Menick and David Silver for their comments and insightful discussions.</p>
<h2>References</h2>
<p>Abadi, M., Isard, M., and Murray, D. G. A computational model for tensorflow: An introduction. In Proceedings of the 1st ACM SIGPLAN International Workshop on Machine Learning and Programming Languages, MAPL 2017, 2017. ISBN 978-1-4503-5071-6.</p>
<p>Adamski, I., Adamski, R., Grel, T., Jedrych, A., Kaczmarek, K., and Michalewski, H. Distributed deep reinforcement learning: Learn how to play atari games in 21 minutes. CoRR, abs/1801.02852, 2018.</p>
<p>Appleyard, J., Kociský, T., and Blunsom, P. Optimizing performance of recurrent neural networks on gpus. CoRR, abs/1604.01946, 2016.</p>
<p>Babaeizadeh, M., Frosio, I., Tyree, S., Clemons, J., and Kautz, J. GA3C: GPU-based A3C for deep reinforcement learning. NIPS Workshop, 2016.</p>
<p>Barth-Maron, G., Hoffman, M. W., Budden, D., Dabney, W., Horgan, D., Tirumala, D., Muldal, A., Heess, N., and Lillicrap, T. Distributional policy gradients. ICLR, 2018.</p>
<p>Beattie, C., Leibo, J. Z., Teplyashin, D., Ward, T., Wainwright, M., Kuttler, H., Lefrancq, A., Green, S., Valdes, V., Sadik, A., Schrittwieser, J., Anderson, K., York, S., Cant, M., Cain, A., Bolton, A., Gaffney, S., King, H., Hassabis, D., Legg, S., and Petersen, S. Deepmind lab. CoRR, abs/1612.03801, 2016.</p>
<p>Bellemare, M. G., Naddaf, Y., Veness, J., and Bowling, M. The Arcade Learning Environment: An evaluation platform for general agents. Journal of Artificial Intelligence Research, 47:253-279, June 2013a.</p>
<p>Bellemare, M. G., Naddaf, Y., Veness, J., and Bowling, M. The arcade learning environment: An evaluation platform for general agents. J. Artif. Intell. Res.(JAIR), 47:253-279, 2013b.</p>
<p>Chen, J., Monga, R., Bengio, S., and Józefowicz, R. Revisiting distributed synchronous SGD. CoRR, abs/1604.00981, 2016.</p>
<p>Chetlur, S., Woolley, C., Vandermersch, P., Cohen, J., Tran, J., Catanzaro, B., and Shelhamer, E. cudnn: Efficient primitives for deep learning. CoRR, abs/1410.0759, 2014.</p>
<p>Clemente, A. V., Martínez, H. N. C., and Chandra, A. Efficient parallel methods for deep reinforcement learning. CoRR, abs/1705.04862, 2017.</p>
<p>Dean, J., Corrado, G., Monga, R., Chen, K., Devin, M., Mao, M., Ranzato, M., Senior, A., Tucker, P., Yang, K., Le, Q. V., and Ng, A. Y. Large scale distributed deep networks. In Advances in Neural Information Processing Systems 25, pp. 1223-1231, 2012.</p>
<p>Geist, M. and Scherrer, B. Off-policy learning with eligibility traces: A survey. The Journal of Machine Learning Research, 15(1):289-333, 2014.</p>
<p>Gruslys, A., Dabney, W., Azar, M. G., Piot, B., Bellemare, M. G., and Munos, R. The Reactor: A fast and sample-efficient actor-critic agent for reinforcement learning. ICLR, 2018.</p>
<p>Harutyunyan, A., Bellemare, M. G., Stepleton, T., and Munos, R. Q( $\lambda$ ) with Off-Policy Corrections, pp. 305320. Springer International Publishing, Cham, 2016.</p>
<p>He, K., Zhang, X., Ren, S., and Sun, J. Identity mappings in deep residual networks. In European Conference on Computer Vision, pp. 630-645. Springer, 2016.</p>
<p>Hermann, K. M., Hill, F., Green, S., Wang, F., Faulkner, R., Soyer, H., Szepesvari, D., Czarnecki, W., Jaderberg, M., Teplyashin, D., et al. Grounded language learning in a simulated 3d world. arXiv preprint arXiv:1706.06551, 2017.</p>
<p>Hochreiter, S. and Schmidhuber, J. Long short-term memory. Neural computation, 9(8):1735-1780, 1997.</p>
<p>Horgan, D., Quan, J., Budden, D., Barth-Maron, G., Hessel, M., van Hasselt, H., and Silver, D. Distributed prioritized experience replay. ICLR, 2018.</p>
<p>Jaderberg, M., Dalibard, V., Osindero, S., Czarnecki, W. M., Donahue, J., Razavi, A., Vinyals, O., Green, T., Dunning, I., Simonyan, K., Fernando, C., and Kavukcuoglu, K. Population based training of neural networks. CoRR, abs/1711.09846, 2017a.</p>
<p>Jaderberg, M., Mnih, V., Czarnecki, W. M., Schaul, T., Leibo, J. Z., Silver, D., and Kavukcuoglu, K. Reinforcement learning with unsupervised auxiliary tasks. ICLR, 2017b.</p>
<p>Leibo, J. Z., d’Autume, C. d. M., Zoran, D., Amos, D., Beattie, C., Anderson, K., Castañeda, A. G., Sanchez, M., Green, S., Gruslys, A., et al. Psychlab: A psychology laboratory for deep reinforcement learning agents. arXiv preprint arXiv:1801.08116, 2018.</p>
<p>Lillicrap, T. P., Hunt, J. J., Pritzel, A., Heess, N., Erez, T., Tassa, Y., Silver, D., and Wierstra, D. Continuous control with deep reinforcement learning. arXiv preprint arXiv:1509.02971, 2015.</p>
<p>Mnih, V., Kavukcuoglu, K., Silver, D., Rusu, A. A., Veness, J., Bellemare, M. G., Graves, A., Riedmiller, M., Fidjeland, A. K., Ostrovski, G., et al. Human-level control through deep reinforcement learning. Nature, 518(7540): 529-533, 2015.</p>
<p>Mnih, V., Badia, A. P., Mirza, M., Graves, A., Lillicrap, T. P., Harley, T., Silver, D., and Kavukcuoglu, K. Asynchronous methods for deep reinforcement learning. ICML, 2016.</p>
<p>Munos, R., Stepleton, T., Harutyunyan, A., and Bellemare, M. Safe and efficient off-policy reinforcement learning. In Advances in Neural Information Processing Systems, pp. 1046-1054, 2016.</p>
<p>Nair, A., Srinivasan, P., Blackwell, S., Alcicek, C., Fearon, R., Maria, A. D., Panneershelvam, V., Suleyman, M., Beattie, C., Petersen, S., Legg, S., Mnih, V., Kavukcuoglu, K., and Silver, D. Massively parallel methods for deep reinforcement learning. CoRR, abs/1507.04296, 2015.</p>
<p>O’Donoghue, B., Munos, R., Kavukcuoglu, K., and Mnih, V. Combining policy gradient and Q-learning. In $I C L R$, 2017.</p>
<p>Precup, D., Sutton, R. S., and Singh, S. Eligibility traces for off-policy policy evaluation. In Proceedings of the Seventeenth International Conference on Machine Learning, 2000.</p>
<p>Precup, D., Sutton, R. S., and Dasgupta, S. Off-policy temporal-difference learning with function approximation. In Proceedings of the 18th International Conference on Machine Laerning, pp. 417-424, 2001.</p>
<p>Puterman, M. L. Markov Decision Processes: Discrete Stochastic Dynamic Programming. John Wiley \&amp; Sons, Inc., New York, NY, USA, 1st edition, 1994. ISBN 0471619779 .</p>
<p>Rusu, A. A., Rabinowitz, N. C., Desjardins, G., Soyer, H., Kirkpatrick, J., Kavukcuoglu, K., Pascanu, R., and Hadsell, R. Progressive neural networks. arXiv preprint arXiv:1606.04671, 2016.</p>
<p>Salimans, T., Ho, J., Chen, X., and Sutskever, I. Evolution strategies as a scalable alternative to reinforcement learning. arXiv preprint arXiv:1703.03864, 2017.</p>
<p>Schulman, J., Moritz, P., Levine, S., Jordan, M., and Abbeel, P. High-dimensional continuous control using generalized advantage estimation. In $I C L R, 2016$.</p>
<p>Silver, D., Huang, A., Maddison, C. J., Guez, A., Sifre, L., van den Driessche, G., Schrittwieser, J., Antonoglou, I., Panneershelvam, V., Lanctot, M., Dieleman, S., Grewe, D., Nham, J., Kalchbrenner, N., Sutskever, I., Lillicrap, T., Leach, M., Kavukcuoglu, K., Graepel, T., and Hassabis, D. Mastering the game of go with deep neural networks and tree search. Nature, 529:484-503, 2016.</p>
<p>Silver, D., Schrittwieser, J., Simonyan, K., Antonoglou, I., Huang, A., Guez, A., Hubert, T., Baker, L., Lai, M., Bolton, A., Chen, Y., Lillicrap, T., Hui, F., Sifre, L., Driessche, G. v. d., Graepel, T., and Hassabis, D. Mastering the game of go without human knowledge. Nature, 550(7676):354-359, 10 2017. ISSN 0028-0836. doi: 10.1038/nature24270.</p>
<p>Sutton, R. and Barto, A. Reinforcement learning: An introduction, volume 116. Cambridge Univ Press, 1998.</p>
<p>Wang, Z., Bapst, V., Heess, N., Mnih, V., Munos, R., Kavukcuoglu, K., and de Freitas, N. Sample efficient actor-critic with experience replay. In $I C L R, 2017$.</p>
<p>Wawrzynski, P. Real-time reinforcement learning by sequential actor-critics and experience replay. Neural Networks, 22(10):1484-1497, 2009.</p>
<p>Wu, Y., Mansimov, E., Liao, S., Grosse, R. B., and Ba, J. Scalable trust-region method for deep reinforcement learning using kronecker-factored approximation. CoRR, abs/1708.05144, 2017.</p>
<p>Zoph, B., Vasudevan, V., Shlens, J., and Le, Q. V. Learning transferable architectures for scalable image recognition. arXiv preprint arXiv:1707.07012, 2017.</p>
<h1>Supplementary Material</h1>
<h2>A. Analysis of V-trace</h2>
<h2>A.1. V-trace operator</h2>
<p>Define the V-trace operator $\mathcal{R}$ :</p>
<p>$$
\mathcal{R} V(x) \stackrel{\text { def }}{=} V(x)+\mathbb{E}<em 0="0" _geq="\geq" t="t">{\mu}\left[\sum</em>=x, \mu\right]
$$} \gamma^{t}\left(c_{0} \ldots c_{t-1}\right) \rho_{t}\left(r_{t}+\gamma V\left(x_{t+1}\right)-V\left(x_{t}\right)\right) \mid x_{0</p>
<p>where the expectation $\mathbb{E}<em t="t">{\mu}$ is with respect to the policy $\mu$ which has generated the trajectory $\left(x</em>\right)<em 0="0">{t \geq 0}$, i.e., $x</em>\right)$. Here we consider the infinite-horizon operator but very similar results hold for the $n$-step truncated operator.
Theorem 1. Let $\rho_{t}=\min \left(\bar{\rho}, \frac{\pi\left(a_{t} \mid x_{t}\right)}{\mu\left(a_{t} \mid x_{t}\right)}\right)$ and $c_{t}=\min \left(\bar{c}, \frac{\pi\left(a_{t} \mid x_{t}\right)}{\mu\left(a_{t} \mid x_{t}\right)}\right)$ be truncated importance sampling weights, with $\bar{\rho} \geq \bar{c}$. Assume that there exists $\beta \in(0,1]$ such that $\mathbb{E}}=x$, $x_{t+1} \sim p\left(\cdot \mid x_{t}, a_{t}\right), a_{t} \sim \mu\left(\cdot \mid x_{t<em 0="0">{\mu} \rho</em>$ defined by} \geq \beta$. Then the operator $\mathcal{R}$ defined by (5) has a unique fixed point $V^{\pi_{\bar{\rho}}}$, which is the value function of the policy $\pi_{\bar{\rho}</p>
<p>$$
\pi_{\bar{\rho}}(a \mid x) \stackrel{\text { def }}{=} \frac{\min (\bar{\rho} \mu(a \mid x), \pi(a \mid x))}{\sum_{b \in A} \min (\bar{\rho} \mu(b \mid x), \pi(b \mid x))}
$$</p>
<p>Furthermore, $\mathcal{R}$ is a $\eta$-contraction mapping in sup-norm, with</p>
<p>$$
\eta \stackrel{\text { def }}{=} \gamma^{-1}-\left(\gamma^{-1}-1\right) \mathbb{E}<em 0="0" _geq="\geq" t="t">{\mu}\left[\sum</em>\right] \leq 1-(1-\gamma) \beta&lt;1
$$} \gamma^{t}\left(\prod_{i=0}^{t-2} c_{i}\right) \rho_{t-1</p>
<p>Remark 3. The truncation levels $\bar{c}$ and $\bar{\rho}$ play different roles in this operator:</p>
<ul>
<li>$\bar{\rho}$ impacts the fixed-point of the operator, thus the policy $\pi_{\bar{\rho}}$ which is evaluated. For $\bar{\rho}=\infty$ (untruncated $\rho_{t}$ ) we get the value function of the target policy $V^{\pi}$, whereas for finite $\bar{\rho}$, we evaluate a policy which is in between $\mu$ and $\pi$ (and when $\rho$ is close to 0 , then we evaluate $V^{\mu}$ ). So the larger $\bar{\rho}$ the smaller the bias in off-policy learning. The variance naturally grows with $\bar{\rho}$. However notice that we do not take the product of those $\rho_{t}$ coefficients (in contrast to the $c_{s}$ coefficients) so the variance does not explode with the time horizon.</li>
<li>$\bar{c}$ impacts the contraction modulus $\eta$ of $\mathcal{R}$ (thus the speed at which an online-algorithm like V-trace will converge to its fixed point $V^{\pi_{\bar{\rho}}}$ ). In terms of variance reduction, here is it really important to truncate the importance sampling ratios in $c_{t}$ because we take the product of those. Fortunately, our result says that for any level of truncation $\bar{c}$, the fixed point (the value function $V^{\pi_{\bar{\rho}}}$ we converge to) is the same: it does not depend on $\bar{c}$ but on $\bar{\rho}$ only.</li>
</ul>
<p>Proof. First notice that we can rewrite $\mathcal{R}$ as</p>
<p>$$
\mathcal{R} V(x)=\left(1-\mathbb{E}<em 0="0">{\mu} \rho</em>}\right) V(x)+\mathbb{E<em 0="0" _geq="\geq" t="t">{\mu}\left[\sum</em>\right)\right)\right]
$$} \gamma^{t}\left(\prod_{s=0}^{t-1} c_{s}\right)\left(\rho_{t} r_{t}+\gamma\left[\rho_{t}-c_{t} \rho_{t+1}\right] V\left(x_{t+1</p>
<p>Thus</p>
<p>$$
\begin{aligned}
\mathcal{R} V_{1}(x)-\mathcal{R} V_{2}(x) &amp; =\left(1-\mathbb{E}<em 0="0">{\mu} \rho</em>}\right)\left[V_{1}(x)-V_{2}(x)\right]+\mathbb{E<em 0="0" _geq="\geq" t="t">{\mu}\left[\sum</em>\right)\right]\right] \
&amp; =\mathbb{E}} \gamma^{t+1}\left(\prod_{s=0}^{t-1} c_{s}\right)\left[\rho_{t}-c_{t} \rho_{t+1}\right]\left[V_{1}\left(x_{t+1}\right)-V_{2}\left(x_{t+1<em 0="0" _geq="\geq" t="t">{\mu}\left[\sum</em>} \gamma^{t}\left(\prod_{s=0}^{t-2} c_{s}\right) \underbrace{\left[\rho_{t-1}-c_{t-1} \rho_{t}\right]<em t="t">{\alpha</em>\right)\right]\right]
\end{aligned}
$$}}\left[V_{1}\left(x_{t}\right)-V_{2}\left(x_{t</p>
<p>with the notation that $c_{-1}=\rho_{-1}=1$ and $\prod_{s=0}^{t-2} c_{s}=1$ for $t=0$ and 1 . Now the coefficients $\left(\alpha_{t}\right)_{t \geq 0}$ are non-negative in expectation. Indeed, since $\bar{\rho} \geq \bar{c}$, we have</p>
<p>$$
\mathbb{E}<em t="t">{\mu} \alpha</em>}=\mathbb{E}\left[\rho_{t-1}-c_{t-1} \rho_{t}\right] \geq \mathbb{E<em t-1="t-1">{\mu}\left[c</em>\right)\right] \geq 0
$$}\left(1-\rho_{t</p>
<p>since $\mathbb{E}<em t="t">{\mu} \rho</em>} \leq \mathbb{E<em t="t">{\mu}\left[\frac{\pi\left(a</em>$ at other states, weighted by non-negative coefficients whose sum is} \mid x_{t}\right)}{\mu\left(a_{t} \mid x_{t}\right)}\right]=1$. Thus $V_{1}(x)-V_{2}(x)$ is a linear combination of the values $V_{1}-V_{2</p>
<p>$$
\begin{aligned}
&amp; \sum_{t \geq 0} \gamma^{t} \mathbb{E}<em s="0">{\mu}\left[\left(\prod</em>\right|\right] \
= &amp; \sum_{t \geq 0} \gamma^{t} \mathbb{E}}^{t-2} c_{s}\right)\left|\rho_{t-1}-c_{t-1} \rho_{t<em s="0">{\mu}\left[\left(\prod</em>}^{t-2} c_{s}\right) \rho_{t-1}\right]-\sum_{t \geq 0} \gamma^{t} \mathbb{E<em s="0">{\mu}\left[\left(\prod</em>\right] \
= &amp; \sum_{t \geq 0} \gamma^{t} \mathbb{E}}^{t-1} c_{s}\right) \rho_{t<em s="0">{\mu}\left[\left(\prod</em>}^{t-2} c_{s}\right) \rho_{t-1}\right]-\gamma^{-1}\left(\sum_{t \geq 0} \gamma^{t} \mathbb{E<em s="0">{\mu}\left[\left(\prod</em>\right]-1\right) \
= &amp; \gamma^{-1}-\left(\gamma^{-1}-1\right) \underbrace{\sum_{t \geq 0} \gamma^{t} \mathbb{E}}^{t-2} c_{s}\right) \rho_{t-1<em s="0">{\mu}\left[\left(\prod</em>}^{t-2} c_{s}\right) \rho_{t-1}\right]<em _mu="\mu">{\geq 1+\gamma \mathbb{E}</em> \
\leq &amp; 1-(1-\gamma) \mathbb{E}} \rho_{0}<em 0="0">{\mu} \rho</em> \
\leq &amp; 1-(1-\gamma) \beta \
&lt; &amp; 1
\end{aligned}
$$</p>
<p>We deduce that $\left|\mathcal{R} V_{1}(x)-\mathcal{R} V_{2}(x)\right| \leq \eta\left|V_{1}-V_{2}\right|<em 0="0" _geq="\geq" t="t">{\infty}$, with $\eta=\gamma^{-1}-\left(\gamma^{-1}-1\right) \sum</em>} \gamma^{t} \mathbb{E<em s="0">{\mu}\left[\left(\prod</em>$. We have:}^{t-2} c_{s}\right) \rho_{t-1}\right] \leq$ $1-(1-\gamma) \beta&lt;1$, so $\mathcal{R}$ is a contraction mapping. Thus $\mathcal{R}$ possesses a unique fixed point. Let us now prove that this fixed point is $V^{\pi_{\bar{\rho}}</p>
<p>$$
\begin{aligned}
&amp; \mathbb{E}<em t="t">{\mu}\left[\rho</em>\right] \
= &amp; \sum_{a} \mu\left(a \mid x_{t}\right) \min \left(\bar{\rho}, \frac{\pi\left(a \mid x_{t}\right)}{\mu\left(a \mid x_{t}\right)}\right)\left[r\left(x_{t}, a\right)+\gamma \sum_{y} p\left(y \mid x_{t}, a\right) V^{\pi_{\bar{\rho}}}(y)-V^{\pi_{\bar{\rho}}}\left(x_{t}\right)\right] \
= &amp; \underbrace{\sum_{a} \pi_{\bar{\rho}}\left(a \mid x_{t}\right)\left[r\left(x_{t}, a\right)+\gamma \sum_{y} p\left(y \mid x_{t}, a\right) V^{\pi_{\bar{\rho}}}(y)-V^{\pi_{\bar{\rho}}}\left(x_{t}\right)\right]}}\left(r_{t}+\gamma V^{\pi_{\bar{\rho}}}\left(x_{t+1}\right)-V^{\pi_{\bar{\rho}}}\left(x_{t}\right)\right) \mid x_{t<em b="b">{=0} \sum</em>\right)\right) \
= &amp; 0
\end{aligned}
$$} \min \left(\bar{\rho} \mu\left(b \mid x_{t}\right), \pi\left(b \mid x_{t</p>
<p>since this is the Bellman equation for $V^{\pi_{\bar{\rho}}}$. We deduce that $\mathcal{R} V^{\pi_{\bar{\rho}}}=V^{\pi_{\bar{\rho}}}$, thus $V^{\pi_{\bar{\rho}}}$ is the unique fixed point of $\mathcal{R}$.</p>
<h1>A.2. Online learning</h1>
<p>Theorem 2. Assume a tabular representation, i.e. the state and action spaces are finite. Consider a set of trajectories, with the $k^{t h}$ trajectory $x_{0}, a_{0}, r_{0}, x_{1}, a_{1}, r_{1}, \ldots$ generated by following $\mu: a_{t} \sim \mu\left(\cdot \mid x_{t}\right)$. For each state $x_{s}$ along this trajectory, update</p>
<p>$$
V_{k+1}\left(x_{s}\right)=V_{k}\left(x_{s}\right)+\alpha_{k}\left(x_{s}\right) \sum_{t \geq s} \gamma^{t-s}\left(c_{s} \ldots c_{t-1}\right) \rho_{t}\left(r_{t}+\gamma V_{k}\left(x_{t+1}\right)-V_{k}\left(x_{t}\right)\right)
$$</p>
<p>with $c_{i}=\min \left(\bar{c}, \frac{\pi\left(a_{i} \mid x_{i}\right)}{\mu\left(a_{i} \mid x_{i}\right)}\right), \rho_{i}=\min \left(\bar{\rho}, \frac{\pi\left(a_{i} \mid x_{i}\right)}{\mu\left(a_{i} \mid x_{i}\right)}\right), \bar{\rho} \geq \bar{c}$. Assume that (1) all states are visited infinitely often, and (2) the stepsizes obey the usual Robbins-Munro conditions: for each state $x, \sum_{k} \alpha_{k}(x)=\infty, \sum_{k} \alpha_{k}^{2}(x)&lt;\infty$. Then $V_{k} \rightarrow V^{\pi_{\bar{\rho}}}$ almost surely.</p>
<p>The proof is a straightforward application of the convergence result for stochastic approximation algorithms to the fixed point of a contraction operator, see e.g. Dayan \&amp; Sejnowski (1994); Bertsekas \&amp; Tsitsiklis (1996); Kushner \&amp; Yin (2003).</p>
<h1>A.3. On the choice of $q_{s}$ in policy gradient</h1>
<p>The policy gradient update rule (4) makes use of the coefficient $q_{s}=r_{s}+\gamma v_{s+1}$ as an estimate of $Q^{\pi_{\rho}}\left(x_{s}, a_{s}\right)$ built from the V-trace estimate $v_{s+1}$ at the next state $x_{s+1}$. The reason why we use $q_{s}$ instead of $v_{s}$ as target for our Q-value $Q^{\pi_{\rho}}\left(x_{s}, a_{s}\right)$ is to make sure our estimate of the Q-value is as unbiased as possible, and the first requirement is that it is entirely unbiased in the case of perfect representation of the V-values. Indeed, assuming our value function is correctly estimated at all states, i.e. $V=V^{\pi_{\rho}}$, then we have $\mathbb{E}\left[q_{s} \mid x_{s}, a_{s}\right]=Q^{\pi_{\rho}}\left(x_{s}, a_{s}\right)$ (whereas we do not have this property for $v_{t}$ ). Indeed,</p>
<p>$$
\begin{aligned}
\mathbb{E}\left[q_{s} \mid x_{s}, a_{s}\right] &amp; =r_{s}+\gamma \mathbb{E}\left[V^{\pi_{\rho}}\left(x_{s+1}\right)+\delta_{s+1} V^{\pi_{\rho}}+\gamma c_{s+1} \delta_{s+2} V^{\pi_{\rho}}+\ldots\right] \
&amp; =r_{s}+\gamma \mathbb{E}\left[V^{\pi_{\rho}}\left(x_{s+1}\right)\right] \
&amp; =Q^{\pi_{\rho}}\left(x_{s}, a_{s}\right)
\end{aligned}
$$</p>
<p>whereas</p>
<p>$$
\begin{aligned}
\mathbb{E}\left[v_{s} \mid x_{s}, a_{s}\right] &amp; =V^{\pi_{\rho}}\left(x_{s}\right)+\rho_{s}\left(r_{s}+\gamma \mathbb{E}\left[V^{\pi_{\rho}}\left(x_{s+1}\right)\right]-V^{\pi_{\rho}}\left(x_{s}\right)\right)+\gamma c_{s} \delta_{s+1} V^{\pi_{\rho}}+\ldots \
&amp; =V^{\pi_{\rho}}\left(x_{s}\right)+\rho_{s}\left(r_{s}+\gamma \mathbb{E}\left[V^{\pi_{\rho}}\left(x_{s+1}\right)\right]-V^{\pi_{\rho}}\left(x_{s}\right)\right) \
&amp; =V^{\pi_{\rho}}\left(x_{s}\right)\left(1-\rho_{s}\right)+\rho_{s} Q^{\pi_{\rho}}\left(x_{s}, a_{s}\right)
\end{aligned}
$$</p>
<p>which is different from $Q^{\pi_{\rho}}\left(x_{s}, a_{s}\right)$ when $V^{\pi_{\rho}}\left(x_{s}\right) \neq Q^{\pi_{\rho}}\left(x_{s}, a_{s}\right)$.</p>
<h1>B. Reference Scores</h1>
<table>
<thead>
<tr>
<th style="text-align: left;">Task $t$</th>
<th style="text-align: right;">Human $h$</th>
<th style="text-align: right;">Random $r$</th>
<th style="text-align: right;">Experts</th>
<th style="text-align: right;">IMPALA</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">rooms_collect_good_objects_test</td>
<td style="text-align: right;">10.0</td>
<td style="text-align: right;">0.1</td>
<td style="text-align: right;">9.0</td>
<td style="text-align: right;">5.8</td>
</tr>
<tr>
<td style="text-align: left;">rooms_exploit_deferred_effects_test</td>
<td style="text-align: right;">85.7</td>
<td style="text-align: right;">8.5</td>
<td style="text-align: right;">15.6</td>
<td style="text-align: right;">11.0</td>
</tr>
<tr>
<td style="text-align: left;">rooms_select_nonmatching_object</td>
<td style="text-align: right;">65.9</td>
<td style="text-align: right;">0.3</td>
<td style="text-align: right;">7.3</td>
<td style="text-align: right;">26.1</td>
</tr>
<tr>
<td style="text-align: left;">rooms_watermaze</td>
<td style="text-align: right;">54.0</td>
<td style="text-align: right;">4.1</td>
<td style="text-align: right;">26.9</td>
<td style="text-align: right;">31.1</td>
</tr>
<tr>
<td style="text-align: left;">rooms_keys_doors_puzzle</td>
<td style="text-align: right;">53.8</td>
<td style="text-align: right;">4.1</td>
<td style="text-align: right;">28.0</td>
<td style="text-align: right;">24.3</td>
</tr>
<tr>
<td style="text-align: left;">language_select-described_object</td>
<td style="text-align: right;">389.5</td>
<td style="text-align: right;">-0.1</td>
<td style="text-align: right;">324.6</td>
<td style="text-align: right;">593.1</td>
</tr>
<tr>
<td style="text-align: left;">language_select_located_object</td>
<td style="text-align: right;">280.7</td>
<td style="text-align: right;">1.9</td>
<td style="text-align: right;">189.0</td>
<td style="text-align: right;">301.7</td>
</tr>
<tr>
<td style="text-align: left;">language_execute_random_task</td>
<td style="text-align: right;">254.1</td>
<td style="text-align: right;">-5.9</td>
<td style="text-align: right;">-49.9</td>
<td style="text-align: right;">66.8</td>
</tr>
<tr>
<td style="text-align: left;">language_answer_quantitative_question</td>
<td style="text-align: right;">184.5</td>
<td style="text-align: right;">-0.3</td>
<td style="text-align: right;">219.4</td>
<td style="text-align: right;">264.0</td>
</tr>
<tr>
<td style="text-align: left;">lasertag_one_opponent_large</td>
<td style="text-align: right;">12.7</td>
<td style="text-align: right;">-0.2</td>
<td style="text-align: right;">-0.2</td>
<td style="text-align: right;">0.3</td>
</tr>
<tr>
<td style="text-align: left;">lasertag_three_opponents_large</td>
<td style="text-align: right;">18.6</td>
<td style="text-align: right;">-0.2</td>
<td style="text-align: right;">-0.1</td>
<td style="text-align: right;">4.1</td>
</tr>
<tr>
<td style="text-align: left;">lasertag_one_opponent_small</td>
<td style="text-align: right;">18.6</td>
<td style="text-align: right;">-0.1</td>
<td style="text-align: right;">-0.1</td>
<td style="text-align: right;">2.5</td>
</tr>
<tr>
<td style="text-align: left;">lasertag_three_opponents_small</td>
<td style="text-align: right;">31.5</td>
<td style="text-align: right;">-0.1</td>
<td style="text-align: right;">19.1</td>
<td style="text-align: right;">11.3</td>
</tr>
<tr>
<td style="text-align: left;">natlab_fixed_large_map</td>
<td style="text-align: right;">36.9</td>
<td style="text-align: right;">2.2</td>
<td style="text-align: right;">34.7</td>
<td style="text-align: right;">12.2</td>
</tr>
<tr>
<td style="text-align: left;">natlab_varying_map_regrowth</td>
<td style="text-align: right;">24.4</td>
<td style="text-align: right;">3.0</td>
<td style="text-align: right;">20.7</td>
<td style="text-align: right;">15.9</td>
</tr>
<tr>
<td style="text-align: left;">natlab_varying_map_randomized</td>
<td style="text-align: right;">42.4</td>
<td style="text-align: right;">7.3</td>
<td style="text-align: right;">36.1</td>
<td style="text-align: right;">29.0</td>
</tr>
<tr>
<td style="text-align: left;">skymaze_lirreversible_path_hard</td>
<td style="text-align: right;">100.0</td>
<td style="text-align: right;">0.1</td>
<td style="text-align: right;">13.6</td>
<td style="text-align: right;">30.0</td>
</tr>
<tr>
<td style="text-align: left;">skymaze_lirreversible_path_varied</td>
<td style="text-align: right;">100.0</td>
<td style="text-align: right;">14.4</td>
<td style="text-align: right;">45.1</td>
<td style="text-align: right;">53.6</td>
</tr>
<tr>
<td style="text-align: left;">pyschlab_arbitrary_visuomotor_mapping</td>
<td style="text-align: right;">58.8</td>
<td style="text-align: right;">0.2</td>
<td style="text-align: right;">16.4</td>
<td style="text-align: right;">14.3</td>
</tr>
<tr>
<td style="text-align: left;">pyschlab_continuous_recognition</td>
<td style="text-align: right;">58.3</td>
<td style="text-align: right;">0.2</td>
<td style="text-align: right;">29.9</td>
<td style="text-align: right;">29.9</td>
</tr>
<tr>
<td style="text-align: left;">pyschlab_sequential_comparison</td>
<td style="text-align: right;">39.5</td>
<td style="text-align: right;">0.1</td>
<td style="text-align: right;">0.0</td>
<td style="text-align: right;">0.0</td>
</tr>
<tr>
<td style="text-align: left;">pyschlab_visual_search</td>
<td style="text-align: right;">78.5</td>
<td style="text-align: right;">0.1</td>
<td style="text-align: right;">0.0</td>
<td style="text-align: right;">0.0</td>
</tr>
<tr>
<td style="text-align: left;">explore_object_locations_small</td>
<td style="text-align: right;">74.5</td>
<td style="text-align: right;">3.6</td>
<td style="text-align: right;">57.8</td>
<td style="text-align: right;">62.6</td>
</tr>
<tr>
<td style="text-align: left;">explore_object_locations_large</td>
<td style="text-align: right;">65.7</td>
<td style="text-align: right;">4.7</td>
<td style="text-align: right;">37.0</td>
<td style="text-align: right;">51.1</td>
</tr>
<tr>
<td style="text-align: left;">explore_obstructed_goals_small</td>
<td style="text-align: right;">206.0</td>
<td style="text-align: right;">6.8</td>
<td style="text-align: right;">135.2</td>
<td style="text-align: right;">188.8</td>
</tr>
<tr>
<td style="text-align: left;">explore_obstructed_goals_large</td>
<td style="text-align: right;">119.5</td>
<td style="text-align: right;">2.6</td>
<td style="text-align: right;">39.5</td>
<td style="text-align: right;">71.0</td>
</tr>
<tr>
<td style="text-align: left;">explore_goal_locations_small</td>
<td style="text-align: right;">267.5</td>
<td style="text-align: right;">7.7</td>
<td style="text-align: right;">209.4</td>
<td style="text-align: right;">252.5</td>
</tr>
<tr>
<td style="text-align: left;">explore_goal_locations_large</td>
<td style="text-align: right;">194.5</td>
<td style="text-align: right;">3.1</td>
<td style="text-align: right;">83.1</td>
<td style="text-align: right;">125.3</td>
</tr>
<tr>
<td style="text-align: left;">explore_object_rewards_few</td>
<td style="text-align: right;">77.7</td>
<td style="text-align: right;">2.1</td>
<td style="text-align: right;">39.8</td>
<td style="text-align: right;">43.2</td>
</tr>
<tr>
<td style="text-align: left;">explore_object_rewards_many</td>
<td style="text-align: right;">106.7</td>
<td style="text-align: right;">2.4</td>
<td style="text-align: right;">58.7</td>
<td style="text-align: right;">62.6</td>
</tr>
<tr>
<td style="text-align: left;">Mean Capped Normalised Score: $\left(\sum_{t} \min \left[1,\left(s_{t}-r_{t}\right) /\left(h_{t}-r_{t}\right)\right]\right) / N$</td>
<td style="text-align: right;">$100 \%$</td>
<td style="text-align: right;">$0 \%$</td>
<td style="text-align: right;">$44.5 \%$</td>
<td style="text-align: right;">$49.4 \%$</td>
</tr>
</tbody>
</table>
<p>Table B.1. DMLab-30 test scores.</p>
<h1>B.1. Final training scores on DMLab-30</h1>
<p><img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>Figure B.1. Human normalised scores across all DMLab-30 tasks.</p>
<h1>C. Atari Scores</h1>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">ACKTR</th>
<th style="text-align: center;">The Reactor</th>
<th style="text-align: center;">IMPALA (deep, multi-task)</th>
<th style="text-align: center;">IMPALA (shallow)</th>
<th style="text-align: center;">IMPALA (deep)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">alien</td>
<td style="text-align: center;">3197.10</td>
<td style="text-align: center;">6482.10</td>
<td style="text-align: center;">2344.60</td>
<td style="text-align: center;">1536.05</td>
<td style="text-align: center;">15962.10</td>
</tr>
<tr>
<td style="text-align: center;">amidar</td>
<td style="text-align: center;">1059.40</td>
<td style="text-align: center;">833</td>
<td style="text-align: center;">136.82</td>
<td style="text-align: center;">497.62</td>
<td style="text-align: center;">1554.79</td>
</tr>
<tr>
<td style="text-align: center;">assault</td>
<td style="text-align: center;">10777.70</td>
<td style="text-align: center;">11013.50</td>
<td style="text-align: center;">2116.32</td>
<td style="text-align: center;">12086.86</td>
<td style="text-align: center;">19148.47</td>
</tr>
<tr>
<td style="text-align: center;">asterix</td>
<td style="text-align: center;">31583.00</td>
<td style="text-align: center;">36238.50</td>
<td style="text-align: center;">2609.00</td>
<td style="text-align: center;">29692.50</td>
<td style="text-align: center;">300732.00</td>
</tr>
<tr>
<td style="text-align: center;">asteroids</td>
<td style="text-align: center;">34171.60</td>
<td style="text-align: center;">2780.40</td>
<td style="text-align: center;">2011.05</td>
<td style="text-align: center;">3508.10</td>
<td style="text-align: center;">108590.05</td>
</tr>
<tr>
<td style="text-align: center;">atlantis</td>
<td style="text-align: center;">3433182.00</td>
<td style="text-align: center;">308258</td>
<td style="text-align: center;">460430.50</td>
<td style="text-align: center;">773355.50</td>
<td style="text-align: center;">849967.50</td>
</tr>
<tr>
<td style="text-align: center;">bank.heist</td>
<td style="text-align: center;">1289.70</td>
<td style="text-align: center;">988.70</td>
<td style="text-align: center;">55.15</td>
<td style="text-align: center;">1200.35</td>
<td style="text-align: center;">1223.15</td>
</tr>
<tr>
<td style="text-align: center;">battle.zone</td>
<td style="text-align: center;">8910.00</td>
<td style="text-align: center;">61220</td>
<td style="text-align: center;">7705.00</td>
<td style="text-align: center;">13015.00</td>
<td style="text-align: center;">20885.00</td>
</tr>
<tr>
<td style="text-align: center;">beam_rider</td>
<td style="text-align: center;">13581.40</td>
<td style="text-align: center;">8566.50</td>
<td style="text-align: center;">698.36</td>
<td style="text-align: center;">8219.92</td>
<td style="text-align: center;">32463.47</td>
</tr>
<tr>
<td style="text-align: center;">berzerk</td>
<td style="text-align: center;">927.20</td>
<td style="text-align: center;">1641.40</td>
<td style="text-align: center;">647.80</td>
<td style="text-align: center;">888.30</td>
<td style="text-align: center;">1852.70</td>
</tr>
<tr>
<td style="text-align: center;">bowling</td>
<td style="text-align: center;">24.30</td>
<td style="text-align: center;">75.40</td>
<td style="text-align: center;">31.06</td>
<td style="text-align: center;">35.73</td>
<td style="text-align: center;">59.92</td>
</tr>
<tr>
<td style="text-align: center;">boxing</td>
<td style="text-align: center;">1.45</td>
<td style="text-align: center;">99.40</td>
<td style="text-align: center;">96.63</td>
<td style="text-align: center;">96.30</td>
<td style="text-align: center;">99.96</td>
</tr>
<tr>
<td style="text-align: center;">breakout</td>
<td style="text-align: center;">735.70</td>
<td style="text-align: center;">518.40</td>
<td style="text-align: center;">35.67</td>
<td style="text-align: center;">640.43</td>
<td style="text-align: center;">787.34</td>
</tr>
<tr>
<td style="text-align: center;">centipede</td>
<td style="text-align: center;">7125.28</td>
<td style="text-align: center;">3402.80</td>
<td style="text-align: center;">4916.84</td>
<td style="text-align: center;">5528.13</td>
<td style="text-align: center;">11049.75</td>
</tr>
<tr>
<td style="text-align: center;">chopper_command</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">37568</td>
<td style="text-align: center;">5036.00</td>
<td style="text-align: center;">5012.00</td>
<td style="text-align: center;">28255.00</td>
</tr>
<tr>
<td style="text-align: center;">crazy_climber</td>
<td style="text-align: center;">150444.00</td>
<td style="text-align: center;">194347</td>
<td style="text-align: center;">115384.00</td>
<td style="text-align: center;">136211.50</td>
<td style="text-align: center;">136950.00</td>
</tr>
<tr>
<td style="text-align: center;">defender</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">113128</td>
<td style="text-align: center;">16667.50</td>
<td style="text-align: center;">58718.25</td>
<td style="text-align: center;">185203.00</td>
</tr>
<tr>
<td style="text-align: center;">demon_attack</td>
<td style="text-align: center;">274176.70</td>
<td style="text-align: center;">100189</td>
<td style="text-align: center;">10095.20</td>
<td style="text-align: center;">107264.73</td>
<td style="text-align: center;">132826.98</td>
</tr>
<tr>
<td style="text-align: center;">double_dunk</td>
<td style="text-align: center;">$-0.54$</td>
<td style="text-align: center;">11.40</td>
<td style="text-align: center;">$-1.92$</td>
<td style="text-align: center;">$-0.35$</td>
<td style="text-align: center;">$-0.33$</td>
</tr>
<tr>
<td style="text-align: center;">enduro</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">2230.10</td>
<td style="text-align: center;">971.28</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">0.00</td>
</tr>
<tr>
<td style="text-align: center;">fishing_derby</td>
<td style="text-align: center;">33.73</td>
<td style="text-align: center;">23.20</td>
<td style="text-align: center;">35.27</td>
<td style="text-align: center;">32.08</td>
<td style="text-align: center;">44.85</td>
</tr>
<tr>
<td style="text-align: center;">freeway</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">31.40</td>
<td style="text-align: center;">21.41</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">0.00</td>
</tr>
<tr>
<td style="text-align: center;">frostbite</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">8042.10</td>
<td style="text-align: center;">2744.15</td>
<td style="text-align: center;">269.65</td>
<td style="text-align: center;">317.75</td>
</tr>
<tr>
<td style="text-align: center;">gopher</td>
<td style="text-align: center;">47730.80</td>
<td style="text-align: center;">69135.10</td>
<td style="text-align: center;">913.50</td>
<td style="text-align: center;">1002.40</td>
<td style="text-align: center;">66782.30</td>
</tr>
<tr>
<td style="text-align: center;">gravitar</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">1073.80</td>
<td style="text-align: center;">282.50</td>
<td style="text-align: center;">211.50</td>
<td style="text-align: center;">359.50</td>
</tr>
<tr>
<td style="text-align: center;">hero</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">35542.20</td>
<td style="text-align: center;">18818.90</td>
<td style="text-align: center;">33853.15</td>
<td style="text-align: center;">33730.55</td>
</tr>
<tr>
<td style="text-align: center;">ice_hockey</td>
<td style="text-align: center;">$-4.20$</td>
<td style="text-align: center;">3.40</td>
<td style="text-align: center;">$-13.55$</td>
<td style="text-align: center;">$-5.25$</td>
<td style="text-align: center;">3.48</td>
</tr>
<tr>
<td style="text-align: center;">jamesbond</td>
<td style="text-align: center;">490.00</td>
<td style="text-align: center;">7869.20</td>
<td style="text-align: center;">284.00</td>
<td style="text-align: center;">440.00</td>
<td style="text-align: center;">601.50</td>
</tr>
<tr>
<td style="text-align: center;">kangaroo</td>
<td style="text-align: center;">3150.00</td>
<td style="text-align: center;">10484.50</td>
<td style="text-align: center;">8240.50</td>
<td style="text-align: center;">47.00</td>
<td style="text-align: center;">1632.00</td>
</tr>
<tr>
<td style="text-align: center;">krull</td>
<td style="text-align: center;">9686.90</td>
<td style="text-align: center;">9930.80</td>
<td style="text-align: center;">10807.80</td>
<td style="text-align: center;">9247.60</td>
<td style="text-align: center;">8147.40</td>
</tr>
<tr>
<td style="text-align: center;">kung_fu_master</td>
<td style="text-align: center;">34954.00</td>
<td style="text-align: center;">59799.50</td>
<td style="text-align: center;">41905.00</td>
<td style="text-align: center;">42259.00</td>
<td style="text-align: center;">43375.50</td>
</tr>
<tr>
<td style="text-align: center;">montezuma_revenge</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">2643.50</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">0.00</td>
</tr>
<tr>
<td style="text-align: center;">ms_pacman</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">2724.30</td>
<td style="text-align: center;">3415.05</td>
<td style="text-align: center;">6501.71</td>
<td style="text-align: center;">7342.32</td>
</tr>
<tr>
<td style="text-align: center;">name_this_game</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">9907.20</td>
<td style="text-align: center;">5719.30</td>
<td style="text-align: center;">6049.55</td>
<td style="text-align: center;">21537.20</td>
</tr>
<tr>
<td style="text-align: center;">phoenix</td>
<td style="text-align: center;">133433.70</td>
<td style="text-align: center;">40092.20</td>
<td style="text-align: center;">7486.50</td>
<td style="text-align: center;">33068.15</td>
<td style="text-align: center;">210996.45</td>
</tr>
<tr>
<td style="text-align: center;">pitfall</td>
<td style="text-align: center;">$-1.10$</td>
<td style="text-align: center;">$-3.50$</td>
<td style="text-align: center;">$-1.22$</td>
<td style="text-align: center;">$-11.14$</td>
<td style="text-align: center;">$-1.66$</td>
</tr>
<tr>
<td style="text-align: center;">pong</td>
<td style="text-align: center;">20.90</td>
<td style="text-align: center;">20.70</td>
<td style="text-align: center;">8.58</td>
<td style="text-align: center;">20.40</td>
<td style="text-align: center;">20.98</td>
</tr>
<tr>
<td style="text-align: center;">private_eye</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">15177.10</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">92.42</td>
<td style="text-align: center;">98.50</td>
</tr>
<tr>
<td style="text-align: center;">qbert</td>
<td style="text-align: center;">23151.50</td>
<td style="text-align: center;">22956.50</td>
<td style="text-align: center;">10717.38</td>
<td style="text-align: center;">18901.25</td>
<td style="text-align: center;">351200.12</td>
</tr>
<tr>
<td style="text-align: center;">riverraid</td>
<td style="text-align: center;">17762.80</td>
<td style="text-align: center;">16608.30</td>
<td style="text-align: center;">2850.15</td>
<td style="text-align: center;">17401.90</td>
<td style="text-align: center;">29608.05</td>
</tr>
<tr>
<td style="text-align: center;">road_runner</td>
<td style="text-align: center;">53446.00</td>
<td style="text-align: center;">71168</td>
<td style="text-align: center;">24435.50</td>
<td style="text-align: center;">37505.00</td>
<td style="text-align: center;">57121.00</td>
</tr>
<tr>
<td style="text-align: center;">robotank</td>
<td style="text-align: center;">16.50</td>
<td style="text-align: center;">68.50</td>
<td style="text-align: center;">9.94</td>
<td style="text-align: center;">2.30</td>
<td style="text-align: center;">12.96</td>
</tr>
<tr>
<td style="text-align: center;">seaquest</td>
<td style="text-align: center;">1776.00</td>
<td style="text-align: center;">8425.80</td>
<td style="text-align: center;">844.60</td>
<td style="text-align: center;">1716.90</td>
<td style="text-align: center;">1753.20</td>
</tr>
<tr>
<td style="text-align: center;">skiing</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">$-10753.40$</td>
<td style="text-align: center;">$-8988.00$</td>
<td style="text-align: center;">$-29975.00$</td>
<td style="text-align: center;">$-10180.38$</td>
</tr>
<tr>
<td style="text-align: center;">solaris</td>
<td style="text-align: center;">2368.60</td>
<td style="text-align: center;">2760</td>
<td style="text-align: center;">1160.40</td>
<td style="text-align: center;">2368.40</td>
<td style="text-align: center;">2365.00</td>
</tr>
<tr>
<td style="text-align: center;">space_invaders</td>
<td style="text-align: center;">19723.00</td>
<td style="text-align: center;">2448.60</td>
<td style="text-align: center;">199.65</td>
<td style="text-align: center;">1726.28</td>
<td style="text-align: center;">43595.78</td>
</tr>
<tr>
<td style="text-align: center;">star_gunner</td>
<td style="text-align: center;">82920.00</td>
<td style="text-align: center;">70038</td>
<td style="text-align: center;">1855.50</td>
<td style="text-align: center;">69139.00</td>
<td style="text-align: center;">200625.00</td>
</tr>
<tr>
<td style="text-align: center;">surround</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">6.70</td>
<td style="text-align: center;">$-8.51$</td>
<td style="text-align: center;">$-8.13$</td>
<td style="text-align: center;">7.56</td>
</tr>
<tr>
<td style="text-align: center;">tennis</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">23.30</td>
<td style="text-align: center;">$-8.12$</td>
<td style="text-align: center;">$-1.89$</td>
<td style="text-align: center;">0.55</td>
</tr>
<tr>
<td style="text-align: center;">time_pilot</td>
<td style="text-align: center;">22286.00</td>
<td style="text-align: center;">19401</td>
<td style="text-align: center;">3747.50</td>
<td style="text-align: center;">6617.50</td>
<td style="text-align: center;">48481.50</td>
</tr>
<tr>
<td style="text-align: center;">tutankham</td>
<td style="text-align: center;">314.30</td>
<td style="text-align: center;">272.60</td>
<td style="text-align: center;">105.22</td>
<td style="text-align: center;">267.82</td>
<td style="text-align: center;">292.11</td>
</tr>
<tr>
<td style="text-align: center;">up_n_down</td>
<td style="text-align: center;">436665.80</td>
<td style="text-align: center;">64354.20</td>
<td style="text-align: center;">82155.30</td>
<td style="text-align: center;">273058.10</td>
<td style="text-align: center;">332546.75</td>
</tr>
<tr>
<td style="text-align: center;">venture</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">1597.50</td>
<td style="text-align: center;">1.00</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">0.00</td>
</tr>
<tr>
<td style="text-align: center;">video_pinball</td>
<td style="text-align: center;">100496.60</td>
<td style="text-align: center;">469366</td>
<td style="text-align: center;">20125.14</td>
<td style="text-align: center;">228642.52</td>
<td style="text-align: center;">572898.27</td>
</tr>
<tr>
<td style="text-align: center;">wizard_of_wor</td>
<td style="text-align: center;">702.00</td>
<td style="text-align: center;">13170.50</td>
<td style="text-align: center;">2106.00</td>
<td style="text-align: center;">4203.00</td>
<td style="text-align: center;">9157.50</td>
</tr>
<tr>
<td style="text-align: center;">yars_revenge</td>
<td style="text-align: center;">125169.00</td>
<td style="text-align: center;">102760</td>
<td style="text-align: center;">14739.41</td>
<td style="text-align: center;">80530.13</td>
<td style="text-align: center;">84231.14</td>
</tr>
<tr>
<td style="text-align: center;">zaxxon</td>
<td style="text-align: center;">17448.00</td>
<td style="text-align: center;">25215.50</td>
<td style="text-align: center;">6497.00</td>
<td style="text-align: center;">1148.50</td>
<td style="text-align: center;">32935.50</td>
</tr>
</tbody>
</table>
<p>Table C.1. Atari scores after 200M steps environment steps of training. Up to 30 no-ops at the beginning of each episode.</p>
<h1>D. Parameters</h1>
<p>In this section, the specific parameter settings that are used throughout our experiments are given in detail.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Hyperparameter</th>
<th style="text-align: left;">Range</th>
<th style="text-align: center;">Distribution</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Entropy regularisation</td>
<td style="text-align: left;">$[5 \mathrm{e}-5,1 \mathrm{e}-2]$</td>
<td style="text-align: center;">Log uniform</td>
</tr>
<tr>
<td style="text-align: left;">Learning rate</td>
<td style="text-align: left;">$[5 \mathrm{e}-6,5 \mathrm{e}-3]$</td>
<td style="text-align: center;">Log uniform</td>
</tr>
<tr>
<td style="text-align: left;">RMSProp epsilon $(\varepsilon)$ regularisation parameter</td>
<td style="text-align: left;">$[1 \mathrm{e}-1,1 \mathrm{e}-3,1 \mathrm{e}-5,1 \mathrm{e}-7]$</td>
<td style="text-align: center;">Categorical</td>
</tr>
</tbody>
</table>
<p>Table D.1. The ranges used in sampling hyperparameters across all experiments that used a sweep and for the initial hyperparameters for PBT. Sweep size and population size are 24. Note, the loss is summed across the batch and time dimensions.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Action</th>
<th style="text-align: left;">Native DeepMind Lab Action</th>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Forward</td>
<td style="text-align: left;">$0,0,0,1,0,0,0]$</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">Backward</td>
<td style="text-align: left;">$0,0,0,0,1,0,0,0]$</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">Strafe Left</td>
<td style="text-align: left;">$0,0,0,1,0,0,0,0]$</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">Strafe Right</td>
<td style="text-align: left;">$0,0,1,0,0,0,0]$</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">Look Left</td>
<td style="text-align: left;">$[-20,0,0,0,0,0,0]$</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">Look Right</td>
<td style="text-align: left;">$20,0,0,0,0,0,0]$</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">Forward + Look Left</td>
<td style="text-align: left;">$[-20,0,0,1,0,0,0]$</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">Forward + Look Right</td>
<td style="text-align: left;">$20,0,0,1,0,0,0]$</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">Fire</td>
<td style="text-align: left;">$0,0,0,0,1,0,0]$</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<p>Table D.2. Action set used in all tasks from the DeepMind Lab environment, including the DMLab-30 experiments.</p>
<h2>D.1. Fixed Model Hyperparameters</h2>
<p>In this section, we list all the hyperparameters that were kept fixed across all experiments in the paper which are mostly concerned with observations specifications and optimisation. We first show below the reward pre-processing function that is used across all experiments using DeepMind Lab, followed by all fixed numerical values.
<img alt="img-6.jpeg" src="img-6.jpeg" /></p>
<p>Figure D.1. Optimistic Asymmetric Clipping - $0.3 \cdot \min (\tanh ($ reward $), 0)+5.0 \cdot \max (\tanh ($ reward $), 0)$</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Parameter</th>
<th style="text-align: right;">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Image Width</td>
<td style="text-align: right;">96</td>
</tr>
<tr>
<td style="text-align: left;">Image Height</td>
<td style="text-align: right;">72</td>
</tr>
<tr>
<td style="text-align: left;">Action Repetitions</td>
<td style="text-align: right;">4</td>
</tr>
<tr>
<td style="text-align: left;">Unroll Length $(n)$</td>
<td style="text-align: right;">100</td>
</tr>
<tr>
<td style="text-align: left;">Reward Clipping</td>
<td style="text-align: right;">$[-1,1]$</td>
</tr>
<tr>
<td style="text-align: left;">- Single tasks</td>
<td style="text-align: right;">See Figure D.1</td>
</tr>
<tr>
<td style="text-align: left;">- DMLab-30, including experts</td>
<td style="text-align: right;">0.99</td>
</tr>
<tr>
<td style="text-align: left;">Discount $(\gamma)$</td>
<td style="text-align: right;">0.5</td>
</tr>
<tr>
<td style="text-align: left;">Baseline loss scaling</td>
<td style="text-align: right;">0.0</td>
</tr>
<tr>
<td style="text-align: left;">RMSProp momentum</td>
<td style="text-align: right;"></td>
</tr>
<tr>
<td style="text-align: left;">Experience Replay (in Section 5.2.2 )</td>
<td style="text-align: right;">10,000 trajectories</td>
</tr>
<tr>
<td style="text-align: left;">- Capacity</td>
<td style="text-align: right;">Uniform</td>
</tr>
<tr>
<td style="text-align: left;">- Sampling</td>
<td style="text-align: right;">First-in-first-out</td>
</tr>
<tr>
<td style="text-align: left;">- Removal</td>
<td style="text-align: right;"></td>
</tr>
</tbody>
</table>
<p>Table D.3. Fixed model hyperparameters across all DeepMind Lab experiments.</p>
<h1>E. V-trace Analysis</h1>
<h2>E.1. Controlled Updates</h2>
<p>Here we show how different algorithms (On-Policy, No-correction, $\varepsilon$-correction, V-trace) behave under varying levels of policy-lag between the actors and the learner.
<img alt="img-7.jpeg" src="img-7.jpeg" /></p>
<p>Figure E.1. As the policy-lag (the number of update steps the actor policy is behind learner policy) increases, learning with V-trace is more robust compared to $\varepsilon$-correction and pure on-policy learning.</p>
<p><img alt="img-8.jpeg" src="img-8.jpeg" /></p>
<p>Figure E.2. Stability across hyper parameter combinations for different off-policy correction variants using replay. V-trace is much more stable across a wide range of parameter combinations compared to $\varepsilon$-correction and pure on-policy learning.</p>
<h1>E.3. Estimating the State Action Value for Policy Gradient</h1>
<p>We investigated different ways of estimating the state action value function used to estimate advantages for the policy gradient calculation. The variant presented in the main section of the paper uses the V-trace corrected value function $v_{s+1}$ to estimate $q_{s}=r_{s}+\gamma v_{s+1}$. Another possibility is to use the actor-critic baseline $V\left(x_{s+1}\right)$ to estimate $q_{s}=r_{s}+\gamma V\left(x_{s+1}\right)$. Note that the latter variant does not use any information from the current policy rollout to estimate the policy gradient and relies on an accurate estimate of the value function. We found the latter variant to perform worse both when comparing the top 3 runs and an average over all runs of the hyperparameter sweep as can be see in figures E. 3 and E. 4.
<img alt="img-9.jpeg" src="img-9.jpeg" /></p>
<p>Figure E.3. Variants for estimation of state action value function - average over top 3 runs.
<img alt="img-10.jpeg" src="img-10.jpeg" /></p>
<p>Figure E.4. Variants for estimation of state action value function - average over all runs.</p>
<h2>F. Population Based Training</h2>
<p>For Population Based Training we used a "burn-in" period of 20 million frames where no evolution is done. This is to stabilise the process and to avoid very rapid initial adaptation which hinders diversity. After collecting 5,000 episode rewards in total, the mean capped human normalised score is calculated and a random instance in the population is selected. If the score of the selected instance is more than an absolute $5 \%$ higher, then the selected instance weights and parameters are copied.
No matter if a copy happened or not, each parameter (RMSProp epsilon, learning rate and entropy cost) is permuted with $33 \%$ probability by multiplying with either 1.2 or $1 / 1.2$. This is different from Jaderberg et al. (2017) in that our multiplication is unbiased where they use a multiplication of 1.2 or .8 . We found that diversity is increased when the parameters are permuted even if no copy happened.
We reconstruct the learning curves of the PBT runs in Figure 5 by backtracking through the ancestry of copied checkpoints for selected instances.</p>
<p><img alt="img-11.jpeg" src="img-11.jpeg" /></p>
<p>Figure F.1. Learning rate schedule that is discovered by the PBT Jaderberg et al. (2017) method compared against the linear annealing schedule of the best run from the parameter sweep (red line).</p>
<h1>G. Atari Experiments</h1>
<p>All agents trained on Atari are equipped only with a feed forward network and pre-process frames in the same way as described in Mnih et al. (2016). When training experts agents, we use the same hyperparameters for each game for both IMPALA and A3C. These hyperparameters are the result of tuning A3C with a shallow network on the following games: breakout, pong, space_invaders, seaquest, beam_rider, qbert. Following related work, experts use game-specific action sets.
The multi-task agent was equipped with a feed forward residual network (see Figure 3 ). The learning rate, entropy regularisation, RMSProp $\varepsilon$ and gradient clipping threshold were adapted through population based training. To be able to use the same policy layer on all Atari games in the multi-task setting we train the multi-task agent on the full Atari action set consisting of 18 actions.
Agents were trained using the following set of hyperparameters:</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{*}$ Equal contribution ${ }^{1}$ DeepMind Technologies, London, United Kingdom. Correspondence to: Lasse Espeholt $&lt;$ lespeholt@google.com&gt;.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>