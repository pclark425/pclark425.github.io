<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-1589 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-1589</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-1589</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-31.html">extraction-schema-31</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <p><strong>Paper ID:</strong> paper-14002628</p>
                <p><strong>Paper Title:</strong> <a href="https://arxiv.org/pdf/1309.5896v1.pdf" target="_blank">On the Success Rate of Crossover Operators for Genetic Programming with Offspring Selection</a></p>
                <p><strong>Paper Abstract:</strong> Genetic programming is a powerful heuristic search technique that is used for a number of real world applications to solve among others regression, classification, and time-series forecasting problems. A lot of progress towards a theoretic description of genetic programming in form of schema theorems has been made, but the internal dynamics and success factors of genetic programming are still not fully understood. In particular, the effects of different crossover operators in combination with offspring selection are largely unknown. This contribution sheds light on the ability of well-known GP crossover operators to create better offspring when applied to benchmark problems. We conclude that standard (sub-tree swapping) crossover is a good default choice in combination with offspring selection, and that GP with offspring selection and random selection of crossover operators can improve the performance of the algorithm in terms of best solution quality when no solution size constraints are applied.</p>
                <p><strong>Cost:</strong> 0.01</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e1589.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e1589.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>GP+OffspringSel</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Genetic Programming with Offspring Selection</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A tree-based genetic programming system that uses offspring selection (only offspring strictly better than their best parent are admitted) together with several crossover operators and a single-point mutation to evolve programs for regression, time-series prediction, and classification benchmarks.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Genetic Programming with Offspring Selection</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Population-based tree-structured GP (population size 1000) initialized by PTC2 (uniform tree sizes [3..50]), parent selection: fitness-proportional (50%) + random (50%), strict offspring selection (generate children until an offspring better than best parent is found), 1-elitism, mutation rate 15% (single-point: replace a node with a function or terminal with 50/50 chance). Goal is to evolve variable-length programs (symbolic expressions) minimizing MSE on training data.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Multiple tree-based crossover operators were used: standard subtree-swapping (select random subtree in each parent and exchange), one-point tree crossover (single crossover point respecting linearized representation/tree shape), uniform crossover (swap nodes between parents with independent probabilities), size-fair crossover (select crossover points to limit size increase and bias towards exchanging similarly-sized subtrees), homologous crossover (align crossover points by homologous positions in the trees), and a mixed variant that randomly picks one of the five operators per crossover event.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Single-point mutation applied to 15% of offspring: with 50% probability replace a function node by a randomly chosen function symbol, with 50% probability replace a terminal by a randomly chosen terminal (terminals include input variables and constants where applicable).</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Fitness measured as mean squared error (MSE) on the training dataset for each benchmark; additionally offspring selection pressure is tracked as a measure of how often recombination produces better (i.e., more executable/functional) offspring. Offspring selection pressure = (number of solution evaluations required to fill population) / (population size).</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>Qualitative: Standard (sub-tree) and mixed crossover achieved better best-solution MSEs on two of three benchmarks; no numeric novelty/functionality breakdown beyond MSE traces (figures) is provided. Max evaluations: Poly-10 1,000,000; Mackey-Glass 5,000,000; Wisconsin 2,000,000. Exact MSE time-series values not tabulated in text.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Average tree size (genotypic size) over population and offspring selection pressure as a proxy for evolvability/searchability; no explicit behavioral diversity metric reported.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td>Qualitative: Standard and mixed crossover caused exponential growth in average tree size; one-point, uniform, size-fair and homologous maintained low average tree size. Offspring selection pressure remained low for standard and mixed crossover (indicating crossover could still generate better children), whereas it rose for one-point and uniform crossover (indicating harder to produce better children). No numeric diversity statistics provided in the text.</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Described qualitatively: allowing growth in solution size (as seen with standard and mixed crossover) correlates with lower offspring selection pressure (i.e., easier to create better/executable offspring), implying larger/novel offspring are more likely to be improvements; when size constraints were applied in prior work offspring selection pressure rose, indicating a tradeoff between constraining novelty (size growth) and ability to produce functional improvements.</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Program synthesis via symbolic regression (Poly-10), time-series prediction (Mackey-Glass), and binary classification (Wisconsin breast cancer).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Compared crossover operators against each other (standard subtree-swapping, one-point, uniform, size-fair, homologous, and mixed/random selection of those). Also compared conceptually to prior runs with strict size constraints (reported elsewhere).</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Standard subtree-swapping crossover is a good default in combination with offspring selection; mixed (randomly choosing among operators) can outperform standard crossover on some problems when no size constraints are applied; one-point and uniform crossover perform poorly alone and tend to fix tree shape (leading to sudden convergence and increased offspring selection pressure); size-fair and homologous crossover keep tree sizes small but are less able to exploit size-growth-based improvements; offspring selection pressure serves as an informative proxy for the ease of generating improved offspring, and allowing size growth can reduce selection pressure (i.e., make producing better offspring easier).</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1589.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e1589.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Non-destructive crossover</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Non-destructive crossover (related concept)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A selection/replacement concept where a child is only accepted if it is better than the parent, i.e., the better of child and parent is preserved; mentioned as conceptually similar to offspring selection.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Non-destructive crossover (selection scheme)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>After producing offspring via crossover, compare child quality directly to parent(s); add the better of parent and child to next generation. Mentioned as related work and as conceptually similar to offspring selection.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Depends on underlying GP implementation; the paper does not define a specific crossover mechanism for this concept (it's a selection/replacement rule).</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Mentioned conceptually, no experiments in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Mentioned as similar to offspring selection; no empirical results in this paper.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1589.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e1589.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Soft brood selection</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Soft brood selection</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A selection method that generates n offspring from parents and chooses one via tournament among offspring (children do not compete with parents); mentioned as related to offspring selection.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Soft brood selection (selection scheme)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Generates multiple offspring from parents and selects one offspring by tournament selection to enter the next generation; children do not directly compete with parents under the classic definition.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Not specified in this paper; soft-brood is a selection wrapper around any recombination operator.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Mentioned conceptually, no experiments in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Mentioned for contextualizing offspring selection; no empirical data here.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1589.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e1589.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Hill-climbing crossover</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Hill-climbing crossover</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A recombination approach that repeatedly generates offspring from parents while improvements can be found and adds the best found offspring; mentioned as related work to offspring selection.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Hill-climbing crossover (recombination strategy)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Generate successive offspring from given parents and accept the best offspring found by this local search-like recombination procedure; the best result is added to the population.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Procedure involves repeated recombination attempts between the same parents until no better offspring is found or a limit is reached; specific operator details are not provided in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Mentioned conceptually, no experiments in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Cited as conceptually similar to offspring selection; no direct experiments here.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1589.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e1589.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Hereditary selection</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Hereditary selection</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A selection concept that biases parent selection towards solutions with few common ancestors, used in combination with offspring selection in prior work; mentioned in the paper as related work.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Hereditary selection (selection scheme)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Parent selection biased to prefer parents with fewer common ancestors, combined with offspring selection to possibly increase genetic diversity and reduce premature convergence (referenced from other works).</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Mentioned conceptually, no experiments in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Mentioned as a related selection concept that couples with offspring selection; not evaluated experimentally in this paper.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Offspring selection: A new self-adaptive selection scheme for genetic algorithms <em>(Rating: 2)</em></li>
                <li>Size fair and homologous tree genetic programming crossovers <em>(Rating: 2)</em></li>
                <li>On the search properties of different crossover operators in genetic programming <em>(Rating: 2)</em></li>
                <li>On crossover success rate in genetic programming with offspring selection <em>(Rating: 2)</em></li>
                <li>General schema theory for genetic programming with subtree-swapping crossover: part I <em>(Rating: 1)</em></li>
                <li>Hybridized crossover-based search techniques for program discovery <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-1589",
    "paper_id": "paper-14002628",
    "extraction_schema_id": "extraction-schema-31",
    "extracted_data": [
        {
            "name_short": "GP+OffspringSel",
            "name_full": "Genetic Programming with Offspring Selection",
            "brief_description": "A tree-based genetic programming system that uses offspring selection (only offspring strictly better than their best parent are admitted) together with several crossover operators and a single-point mutation to evolve programs for regression, time-series prediction, and classification benchmarks.",
            "citation_title": "here",
            "mention_or_use": "use",
            "system_name": "Genetic Programming with Offspring Selection",
            "system_description": "Population-based tree-structured GP (population size 1000) initialized by PTC2 (uniform tree sizes [3..50]), parent selection: fitness-proportional (50%) + random (50%), strict offspring selection (generate children until an offspring better than best parent is found), 1-elitism, mutation rate 15% (single-point: replace a node with a function or terminal with 50/50 chance). Goal is to evolve variable-length programs (symbolic expressions) minimizing MSE on training data.",
            "input_type": "programs",
            "crossover_operation": "Multiple tree-based crossover operators were used: standard subtree-swapping (select random subtree in each parent and exchange), one-point tree crossover (single crossover point respecting linearized representation/tree shape), uniform crossover (swap nodes between parents with independent probabilities), size-fair crossover (select crossover points to limit size increase and bias towards exchanging similarly-sized subtrees), homologous crossover (align crossover points by homologous positions in the trees), and a mixed variant that randomly picks one of the five operators per crossover event.",
            "mutation_operation": "Single-point mutation applied to 15% of offspring: with 50% probability replace a function node by a randomly chosen function symbol, with 50% probability replace a terminal by a randomly chosen terminal (terminals include input variables and constants where applicable).",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Fitness measured as mean squared error (MSE) on the training dataset for each benchmark; additionally offspring selection pressure is tracked as a measure of how often recombination produces better (i.e., more executable/functional) offspring. Offspring selection pressure = (number of solution evaluations required to fill population) / (population size).",
            "executability_results": "Qualitative: Standard (sub-tree) and mixed crossover achieved better best-solution MSEs on two of three benchmarks; no numeric novelty/functionality breakdown beyond MSE traces (figures) is provided. Max evaluations: Poly-10 1,000,000; Mackey-Glass 5,000,000; Wisconsin 2,000,000. Exact MSE time-series values not tabulated in text.",
            "diversity_metric": "Average tree size (genotypic size) over population and offspring selection pressure as a proxy for evolvability/searchability; no explicit behavioral diversity metric reported.",
            "diversity_results": "Qualitative: Standard and mixed crossover caused exponential growth in average tree size; one-point, uniform, size-fair and homologous maintained low average tree size. Offspring selection pressure remained low for standard and mixed crossover (indicating crossover could still generate better children), whereas it rose for one-point and uniform crossover (indicating harder to produce better children). No numeric diversity statistics provided in the text.",
            "novelty_executability_tradeoff": "Described qualitatively: allowing growth in solution size (as seen with standard and mixed crossover) correlates with lower offspring selection pressure (i.e., easier to create better/executable offspring), implying larger/novel offspring are more likely to be improvements; when size constraints were applied in prior work offspring selection pressure rose, indicating a tradeoff between constraining novelty (size growth) and ability to produce functional improvements.",
            "frontier_characterization": null,
            "benchmark_or_domain": "Program synthesis via symbolic regression (Poly-10), time-series prediction (Mackey-Glass), and binary classification (Wisconsin breast cancer).",
            "comparison_baseline": "Compared crossover operators against each other (standard subtree-swapping, one-point, uniform, size-fair, homologous, and mixed/random selection of those). Also compared conceptually to prior runs with strict size constraints (reported elsewhere).",
            "key_findings": "Standard subtree-swapping crossover is a good default in combination with offspring selection; mixed (randomly choosing among operators) can outperform standard crossover on some problems when no size constraints are applied; one-point and uniform crossover perform poorly alone and tend to fix tree shape (leading to sudden convergence and increased offspring selection pressure); size-fair and homologous crossover keep tree sizes small but are less able to exploit size-growth-based improvements; offspring selection pressure serves as an informative proxy for the ease of generating improved offspring, and allowing size growth can reduce selection pressure (i.e., make producing better offspring easier).",
            "uuid": "e1589.0"
        },
        {
            "name_short": "Non-destructive crossover",
            "name_full": "Non-destructive crossover (related concept)",
            "brief_description": "A selection/replacement concept where a child is only accepted if it is better than the parent, i.e., the better of child and parent is preserved; mentioned as conceptually similar to offspring selection.",
            "citation_title": "",
            "mention_or_use": "mention",
            "system_name": "Non-destructive crossover (selection scheme)",
            "system_description": "After producing offspring via crossover, compare child quality directly to parent(s); add the better of parent and child to next generation. Mentioned as related work and as conceptually similar to offspring selection.",
            "input_type": "programs",
            "crossover_operation": "Depends on underlying GP implementation; the paper does not define a specific crossover mechanism for this concept (it's a selection/replacement rule).",
            "mutation_operation": null,
            "uses_literature": null,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Mentioned conceptually, no experiments in this paper.",
            "comparison_baseline": "",
            "key_findings": "Mentioned as similar to offspring selection; no empirical results in this paper.",
            "uuid": "e1589.1"
        },
        {
            "name_short": "Soft brood selection",
            "name_full": "Soft brood selection",
            "brief_description": "A selection method that generates n offspring from parents and chooses one via tournament among offspring (children do not compete with parents); mentioned as related to offspring selection.",
            "citation_title": "",
            "mention_or_use": "mention",
            "system_name": "Soft brood selection (selection scheme)",
            "system_description": "Generates multiple offspring from parents and selects one offspring by tournament selection to enter the next generation; children do not directly compete with parents under the classic definition.",
            "input_type": "programs",
            "crossover_operation": "Not specified in this paper; soft-brood is a selection wrapper around any recombination operator.",
            "mutation_operation": null,
            "uses_literature": null,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Mentioned conceptually, no experiments in this paper.",
            "comparison_baseline": "",
            "key_findings": "Mentioned for contextualizing offspring selection; no empirical data here.",
            "uuid": "e1589.2"
        },
        {
            "name_short": "Hill-climbing crossover",
            "name_full": "Hill-climbing crossover",
            "brief_description": "A recombination approach that repeatedly generates offspring from parents while improvements can be found and adds the best found offspring; mentioned as related work to offspring selection.",
            "citation_title": "",
            "mention_or_use": "mention",
            "system_name": "Hill-climbing crossover (recombination strategy)",
            "system_description": "Generate successive offspring from given parents and accept the best offspring found by this local search-like recombination procedure; the best result is added to the population.",
            "input_type": "programs",
            "crossover_operation": "Procedure involves repeated recombination attempts between the same parents until no better offspring is found or a limit is reached; specific operator details are not provided in this paper.",
            "mutation_operation": null,
            "uses_literature": null,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Mentioned conceptually, no experiments in this paper.",
            "comparison_baseline": "",
            "key_findings": "Cited as conceptually similar to offspring selection; no direct experiments here.",
            "uuid": "e1589.3"
        },
        {
            "name_short": "Hereditary selection",
            "name_full": "Hereditary selection",
            "brief_description": "A selection concept that biases parent selection towards solutions with few common ancestors, used in combination with offspring selection in prior work; mentioned in the paper as related work.",
            "citation_title": "",
            "mention_or_use": "mention",
            "system_name": "Hereditary selection (selection scheme)",
            "system_description": "Parent selection biased to prefer parents with fewer common ancestors, combined with offspring selection to possibly increase genetic diversity and reduce premature convergence (referenced from other works).",
            "input_type": "programs",
            "crossover_operation": null,
            "mutation_operation": null,
            "uses_literature": null,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Mentioned conceptually, no experiments in this paper.",
            "comparison_baseline": "",
            "key_findings": "Mentioned as a related selection concept that couples with offspring selection; not evaluated experimentally in this paper.",
            "uuid": "e1589.4"
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Offspring selection: A new self-adaptive selection scheme for genetic algorithms",
            "rating": 2,
            "sanitized_title": "offspring_selection_a_new_selfadaptive_selection_scheme_for_genetic_algorithms"
        },
        {
            "paper_title": "Size fair and homologous tree genetic programming crossovers",
            "rating": 2,
            "sanitized_title": "size_fair_and_homologous_tree_genetic_programming_crossovers"
        },
        {
            "paper_title": "On the search properties of different crossover operators in genetic programming",
            "rating": 2,
            "sanitized_title": "on_the_search_properties_of_different_crossover_operators_in_genetic_programming"
        },
        {
            "paper_title": "On crossover success rate in genetic programming with offspring selection",
            "rating": 2,
            "sanitized_title": "on_crossover_success_rate_in_genetic_programming_with_offspring_selection"
        },
        {
            "paper_title": "General schema theory for genetic programming with subtree-swapping crossover: part I",
            "rating": 1,
            "sanitized_title": "general_schema_theory_for_genetic_programming_with_subtreeswapping_crossover_part_i"
        },
        {
            "paper_title": "Hybridized crossover-based search techniques for program discovery",
            "rating": 1,
            "sanitized_title": "hybridized_crossoverbased_search_techniques_for_program_discovery"
        }
    ],
    "cost": 0.01013425,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>On the Success Rate of Crossover Operators for Genetic Programming with Offspring Selection
23 Sep 2013</p>
<p>Gabriel Kronberger 
Heuristic and Evolutionary Algorithms Laboratory School of Informatics, Communications and Media -Hagenberg Upper
University of Applied Sciences
Softwarepark 11A-4232HagenbergAustria, Austria</p>
<p>Stephan Winkler swinkler@heuristiclab.com 
Heuristic and Evolutionary Algorithms Laboratory School of Informatics, Communications and Media -Hagenberg Upper
University of Applied Sciences
Softwarepark 11A-4232HagenbergAustria, Austria</p>
<p>Michael Affenzeller 
Heuristic and Evolutionary Algorithms Laboratory School of Informatics, Communications and Media -Hagenberg Upper
University of Applied Sciences
Softwarepark 11A-4232HagenbergAustria, Austria</p>
<p>Andreas Beham abeham@heuristiclab.com 
Heuristic and Evolutionary Algorithms Laboratory School of Informatics, Communications and Media -Hagenberg Upper
University of Applied Sciences
Softwarepark 11A-4232HagenbergAustria, Austria</p>
<p>Stefan Wagner swagner@heuristiclab.com 
Heuristic and Evolutionary Algorithms Laboratory School of Informatics, Communications and Media -Hagenberg Upper
University of Applied Sciences
Softwarepark 11A-4232HagenbergAustria, Austria</p>
<p>On the Success Rate of Crossover Operators for Genetic Programming with Offspring Selection
23 Sep 201310.1007/978-3-642-04772-5_102
Genetic programming is a powerful heuristic search technique that is used for a number of real world applications to solve amongst others regression, classification, and time-series forecasting problems. A lot of progress towards a theoretic description of genetic programming in form of schema theorems has been made, but the internal dynamics and success factors of genetic programming are still not fully understood. In particular, the effects of different crossover operators in combination with offspring selection are largely unknown. This contribution sheds light on the ability of well-known GP crossover operators to create better offspring when applied to benchmark problems. We conclude that standard (sub-tree swapping) crossover is a good default choice in combination with offspring selection, and that GP with offspring selection and random selection of crossover operators can improve the performance of the algorithm in terms of best solution quality when no solution size constraints are applied.</p>
<p>Genetic Programming</p>
<p>Genetic programming (GP) is a generalization of genetic algorithms first studied at length by John Koza [5]. Whereas the goal of genetic algorithms is to find a fixed length vector of symbols that encodes a solution to the problem, the goal of genetic programming is to find a variable-length program that solves the original problem when executed. Common practice is to use a tree-based representation of computer programs similar to so called symbolic expressions of functional programming languages such as LISP.</p>
<p>Genetic programming is a powerful heuristic search method that has been used successfully to solve real world problems from various application domains, including classification, regression, and forecasting of time-series [9,16].</p>
<p>Offspring selection [1] is a generic selection concept for evolutionary algorithms that aims to reduce the effect of premature convergence often observed</p>
<p>The final publication is available at http://link.springer.com/chapter/10.1007/978-3-642-04772-5_102 with traditional selection operators by preservation of important alleles [2]. The main difference to the usual definition of evolutionary algorithms is that after parent selection, recombination and optional mutation, offspring selection filters the newly generated solutions. Only solutions that have a better quality than their best parent are added to the next generation of the population. In this aspect offspring selection is similar to non-destructive crossover [21], soft brood selection [3], and hill-climbing crossover [13]. Non-destructive crossover compares the quality of one child to the quality of the parent and adds the better one to the next generation, whereas offspring selection generates new children until a successful offspring is found. Soft brood selection generates n offspring and uses tournament selection to determine the individual that is added to the next generation, but in comparison to offspring selection the children do not compete against the parents. Hill-climbing crossover generates new offspring from the parents as long as better solutions can be found. The best solution found by this hill-climbing scheme is added to the next generation. The recently described hereditary selection concept [11,12] also uses a similar offspring selection scheme in combination with parent selection that is biased to select solutions with few common ancestors.</p>
<p>Motivation</p>
<p>Since the very first experiments with genetic programming a lot of effort has been put into the definition of a theoretic foundation for GP in order to gain a better understanding of its internal dynamics. A lot of progress [9,17,18,20] towards the definition of schema theorems for variable length genetic programming and sub-tree swapping crossover, as well as homologous crossover operators [19] has been made. Still, an overall understanding of the internal dynamics and the success factors of genetic programming is still missing. The effects of mixed or variable arity function sets or different mutation operators in combination with more advanced selection schemes are still not fully understood. In particular, the effects of different crossover operators on the tree size and solution quality in combination with offspring selection are largely unknown.</p>
<p>In this research we aim to shed light on the effects of GP crossover operators regarding their ability to create improved solutions in the context of offspring selection. We apply GP with offspring selection to three benchmark problems: symbolic regression (Poly-10), time series prediction (Mackey-Glass) and classification (Wisconsin diagnostic breast cancer). The same set of experiments was also executed for the 4-bit even parity problem, but because of space constraints the results of those experiments are not reported in this paper.</p>
<p>Recently we have analyzed the success rate of GP crossover operators with offspring selection with strict solution size constraints [6]. In the paper at hand we report results of similar experiments with the same set of crossover operators and benchmark problems, but without strict solution size constraints.</p>
<p>The crossover operators used in the experiments are: standard (sub-tree swapping) [5] [20], one-point [9], uniform [15], size-fair, homologous, and size-fair [7]. Additionally, the same experiments were also executed with a crossover variant that chooses one of the five crossover operators randomly for each crossover event [6]. Except for the crossover operator, the problem specific evaluation operator, and the function set all other parameters of the algorithm were the same for all experiments. The random initial population was generated with probabilistic tree creation (PTC2) [10] and uniform distribution of tree sizes in the interval [3; 50]. A single-point mutation operator was used to manipulate 15% of the solution candidates by exchanging either a function symbol (50%) or a terminal symbol (50%). See Table 1 for a summary of all GP parameters.</p>
<p>To analyze the results, the quality of the best solution, average tree size in the whole population as well as offspring selection pressure were logged at each generation step together with the number of solutions that have been evaluated so far. Each run was stopped as soon as the maximal offspring selection pressure or the maximal number of solution evaluations was reached.</p>
<p>Offspring selection pressure of a population is defined as the ratio of the number of solution evaluations that were necessary to fill the population to the population size [1]. High offspring selection pressure means that the chance that crossover generates better children is very small, whereas low offspring selection pressure means that the crossover operator can easily generate better children.</p>
<p>Symbolic Regression -Poly-10</p>
<p>The Poly-10 symbolic regression benchmark problem uses ten input variables x 1 , . . . , x 10 . The function for the target variable y is defined as y = x 1 x 2 +x 3 x 4 + x 5 x 6 + x 1 x 7 x 9 + x 3 x 6 x 10 [8,14]. For our experiments 100 training samples were generated randomly by sampling the values for the input variables uniformly in the range [1, 1[. The usual function set of +,-,*, % (protected division) and the terminal set of x 1 . . . , x 10 without constants was used. The mean squared errors function (MSE) over all 100 training samples was used as fitness function.</p>
<p>Time Series Prediction -Mackey-Glass</p>
<p>The Mackey-Glass ( = 17) 1 chaotic time series is an artificial benchmark data set sometimes used as a representative time series for medical or financial data sets [8]. We used the first 928 samples as training set, the terminal set for the prediction of x(t) consisted of past observations x 128 , x 64 , x 32 , x 16 , x 8 , x 4 , x 2 , x 1 and integer constants in the interval [1; 127]. The function set and the fitness function (MSE) were the same as in the experiments for Poly-10.</p>
<p>Classification -Wisconsin Diagnostic Breast Cancer</p>
<p>The Wisconsin diagnostic breast cancer data set from the UCI Machine Learning Repository [4] is a well known data set for binary classification. Only a part (400 samples) of the whole data set was used and the values of the target variable were transformed to values 2 and 4. Before each genetic programming run the whole data set was shuffled, thus the training set was different for each run.</p>
<p>Again the mean squared errors function for the whole training set was used as fitness function. In contrast to the previous experiments a rather large function set was used that included functions with different arities and types (see Table 1). The terminal set consisted of all ten input variables and real-valued constants in the interval [20; 20].  Figure 1 shows the quality progress (MSE, note log scale), average tree size, and offspring selection pressure for each of the six crossover operators over time (number of evaluated solutions). The first row shows the best solution quality, the second row shows average tree size over the whole population and the third row shows offspring selection pressure.</p>
<p>Results</p>
<p>Size-fair, homologous, and mixed crossover are the most successful operators, whereas onepoint and uniform crossover show rather bad performance. The average tree size grows exponentially in the experiments with standard and mixed crossover, whereas with onepoint, uniform, size-fair and homologous crossover the average tree size stays at a low level. The most interesting result is that offspring selection pressure stays at a low level over the whole run when standard or mixed crossover are used. Offspring selection pressure rises gradually over the whole run when standard crossover is used with size constraints [6]. The different behavior when no size constraints are applied indicates that larger offspring solutions are more likely to be better than their parent solutions than offspring solutions of equal or smaller size. The offspring selection pressure charts for onepoint, uniform, size-fair and homologous crossover show the usual effect, namely that it becomes increasingly harder for crossover to produce successful children.   Figure 2 shows the results for the Mackey-Glass problem. Standard crossover and mixed crossover show good performance in terms of solution quality and the expected exponential growth of solution size. Size-fair crossover had similar behavior as homologous crossover. Onepoint and uniform crossover are the least effective operators. The offspring selection pressure charts show that with onepoint and uniform crossover the offspring selection pressure rises quickly. The runs with standard crossover and mixed crossover again have low offspring selection pressure over the whole run. Figure 3 shows the results for the Wisconsin classification problem. Mixed crossover performs better than standard crossover for this problem. Onepoint, uniform, size-fair, and homologous crossover reached similar solution quality, except for one outlier with homologous crossover. The offspring selection pressure curves of onepoint and uniform crossover show that offspring selection pressure remains at a low level until a point of convergence is reached where the offspring selection pressure rapidly increases to the upper limit. The explanation for this is that onepoint and uniform crossover cause convergence to a fixed tree shape. When all solutions have the same tree shape it becomes very hard to find better solutions. Only the runs with size-fair crossover show the usual pattern of gradually increasing offspring selection pressure. An interesting result is that offspring selection pressure also remains low for homologous crossover even though it doesn't show the exponential growth in solution size as standard and mixed crossover. The flat offspring selection pressure curve could be caused by either the extended function set or the structure of the data set. Further investigations are necessary to fully explain this observation.</p>
<p>Conclusion</p>
<p>Based on the results for the benchmark problems it can be concluded that standard (sub-tree swapping) crossover is a good default choice. The results also show that onepoint and uniform crossover operators do not perform very well on their own. They also have the tendency to quickly freeze the tree shape, and should be combined with mutation operators which manipulate tree shape.</p>
<p>The aim of the experiments with the mixed-crossover variant was to find out if a combination of all five crossover operators in one GP run has a beneficial effect either in terms of achievable solution quality or efficiency. For two of the three benchmark problems the runs with mixed crossover found better solutions than runs with standard crossover. This result is in contrast to the results of experiments with strict size constraints where runs with mixed crossover did not find better solutions than runs with standard crossover [6]. </p>
<p>Acknowledgment</p>
<p>This work mainly reflects research work done within the Josef Ressel-center for heuristic optimization "Heureka!"at the Upper Austria University of Applied Sciences, Campus Hagenberg. The center "Heureka!" is supported by the Austrian Research Promotion Agency (FFG) on behalf of the Austrian Federal Ministry of Economy, Family and Youth (BMWFJ). G.K. thanks the participants of Eu-roGP 2009 for the insightful comments and discussions.</p>
<p>Fig. 1 .
1Best solution quality (MSE, note log scale), average tree size, and offspring selection pressure for 20 runs with each crossover operator for the Poly-10 problem.</p>
<p>Fig. 2 .
2Best solution quality (MSE, note log scale), average tree size, and offspring selection pressure (note different scale) for 20 runs with each crossover operator for the Mackey-Glass problem.</p>
<p>Fig. 3 .
3Best solution quality (MSE, note log scale), average tree size, and offspring selection pressure for 20 runs with each crossover operator for the Wisconsin classification problem.</p>
<p>Table 1. General parameters for all experiments and specific parameters for each benchmark problem.General parameters Population size 1000 
for all experiments Initialization 
PTC2 (uniform [3..50]) 
Parent selection fitness-proportional (50%), random (50%) 
strict offspring selection, 1-elitism 
Mutation rate 
15% single point (50% functions, 50% terminals) 
constraints 
unlimited tree size and depth 
Poly-10 
Function set 
ADD, SUB, MUL, DIV (protected) 
Terminal set 
x1 . . . x10 
Fitness function Mean squared errors 
Max. evaluations 1.000.000 
Mackey-Glass 
Function set 
ADD, SUB, MUL, DIV (protected) 
Terminal set 
x128, x64, . . . , x2, x1, constants: 1..127 
Fitness function Mean squared errors 
Max. evaluations 5.000.000 
Wisconsin 
Function set 
ADD, MUL, SUB, DIV (protected), 
LOG, EXP, SIGNUM, SIN, COS, TAN, 
IF-THEN-ELSE, LESS-THAN, GREATER-THAN, 
EQUAL, NOT, AND, OR, XOR 
Terminal set 
x1, . . . , x10, constants: [20..20] 
Fitness function Mean squared errors 
Max. evaluations 2.000.000 </p>
<p>Data set available from: http://neural.cs.nthu.edu.tw/jang/benchmark/</p>
<p>Offspring selection: A new self-adaptive selection scheme for genetic algorithms. Michael Affenzeller, Stefan Wagner, Adaptive and Natural Computing Algorithms. SpringerMichael Affenzeller and Stefan Wagner. Offspring selection: A new self-adaptive selection scheme for genetic algorithms. In Adaptive and Natural Computing Algo- rithms, Springer Computer Series, pages 218-221. Springer, 2005.</p>
<p>Effective allele preservation by offspring selection: An empirical study for the TSP. Michael Affenzeller, Stephan M Winkler, Stefan Wagner, International Journal of Simulation and Process Modelling. Accepted to appearMichael Affenzeller, Stephan M. Winkler, and Stefan Wagner. Effective allele preservation by offspring selection: An empirical study for the TSP. International Journal of Simulation and Process Modelling, 2009. Accepted to appear.</p>
<p>The evolution of evolvability in genetic programming. Lee Altenberg, Advances in Genetic Programming. Kenneth E. Kinnear, Jr.MIT PressLee Altenberg. The evolution of evolvability in genetic programming. In Kenneth E. Kinnear, Jr., editor, Advances in Genetic Programming, chapter 3, pages 47-74. MIT Press, 1994.</p>
<p>UCI machine learning repository. Arthur Asuncion, David J Newman, Arthur Asuncion and David J. Newman. UCI machine learning repository, 2007.</p>
<p>Genetic Programming. John R Koza, MIT PressJohn R. Koza. Genetic Programming. MIT Press, 1992.</p>
<p>On crossover success rate in genetic programming with offspring selection. Gabriel Kronberger, Stephan Winkler, Michael Affenzeller, Stefan Wagner, Genetic Programming. Leonardo Vanneschi, Steven Gustafson, Alberto Moraglio, Ivanoe De Falco, and Marc EbnerSpringerGabriel Kronberger, Stephan Winkler, Michael Affenzeller, and Stefan Wagner. On crossover success rate in genetic programming with offspring selection. In Leonardo Vanneschi, Steven Gustafson, Alberto Moraglio, Ivanoe De Falco, and Marc Ebner, editors, Genetic Programming, pages 232-243. Springer, 2009.</p>
<p>Size fair and homologous tree genetic programming crossovers. William B Langdon, Genetic Programming and Evolvable Machines. 11/2William B. Langdon. Size fair and homologous tree genetic programming crossovers. Genetic Programming and Evolvable Machines, 1(1/2):95-119, April 2000.</p>
<p>Repeated patterns in genetic programming. Natural Computing. B William, Wolfgang Langdon, Banzhaf, 26Published onlineWilliam B. Langdon and Wolfgang Banzhaf. Repeated patterns in genetic pro- gramming. Natural Computing, 2008. Published online: 26 May 2007.</p>
<p>Foundations of Genetic Programming. B William, Riccardo Langdon, Poli, SpringerWilliam B. Langdon and Riccardo Poli. Foundations of Genetic Programming. Springer, March 2002.</p>
<p>Two fast tree-creation algorithms for genetic programming. Sean Luke, IEEE Trans. Evolutionary Computation. 43Sean Luke. Two fast tree-creation algorithms for genetic programming. IEEE Trans. Evolutionary Computation, 4(3):274-283, 2000.</p>
<p>Exploiting the path of least resistance in evolution. Gearoid Murphy, Conor Ryan, GECCO '08: Proceedings of the 10th annual conference on Genetic and evolutionary computation. Atlanta, GA, USAACMGearoid Murphy and Conor Ryan. Exploiting the path of least resistance in evo- lution. In GECCO '08: Proceedings of the 10th annual conference on Genetic and evolutionary computation, pages 1251-1258, Atlanta, GA, USA, 12-16 July 2008. ACM.</p>
<p>A simple powerful constraint for genetic programming. Gearoid Murphy, Conor Ryan, Proceedings of the 11th European Conference on Genetic Programming. the 11th European Conference on Genetic ProgrammingNaplesSpringer4971EuroGPGearoid Murphy and Conor Ryan. A simple powerful constraint for genetic pro- gramming. In Proceedings of the 11th European Conference on Genetic Program- ming, EuroGP 2008, volume 4971 of Lecture Notes in Computer Science, pages 146-157, Naples, 26-28 March 2008. Springer.</p>
<p>Hybridized crossover-based search techniques for program discovery. Una-May O&apos; Reilly, Franz Oppacher, Proceedings of the 1995 World Conference on Evolutionary Computation. the 1995 World Conference on Evolutionary ComputationPerth, AustraliaIEEE Press2Una-May O'Reilly and Franz Oppacher. Hybridized crossover-based search tech- niques for program discovery. In Proceedings of the 1995 World Conference on Evolutionary Computation, volume 2, pages 573-578, Perth, Australia, 29 Novem- ber -1 December 1995. IEEE Press.</p>
<p>A simple but theoretically-motivated method to control bloat in genetic programming. Riccardo Poli, Genetic Programming, Proceedings of EuroGP'2003. EssexSpringer-VerlagRiccardo Poli. A simple but theoretically-motivated method to control bloat in genetic programming. In Genetic Programming, Proceedings of EuroGP'2003, vol- ume 2610 of LNCS, pages 204-217, Essex, 14-16 April 2003. Springer-Verlag.</p>
<p>On the search properties of different crossover operators in genetic programming. Riccardo Poli, William B Langdon, Proceedings of the Third Annual Conference. the Third Annual ConferenceMadison, Wisconsin, USAMorgan KaufmannUniversity of WisconsinGenetic ProgrammingRiccardo Poli and William B. Langdon. On the search properties of different crossover operators in genetic programming. In Genetic Programming 1998: Pro- ceedings of the Third Annual Conference, pages 293-301, University of Wisconsin, Madison, Wisconsin, USA, 22-25 July 1998. Morgan Kaufmann.</p>
<p>A Field Guide to Genetic Programming. Riccardo Poli, William B Langdon, Nicholas F Mcphee, Lulu.com. Riccardo Poli, William B. Langdon, and Nicholas F. McPhee. A Field Guide to Genetic Programming. Lulu.com, 2008.</p>
<p>General schema theory for genetic programming with subtree-swapping crossover: part I. Riccardo Poli, Nicholas F Mcphee, Evol. Comput. 111Riccardo Poli and Nicholas F. McPhee. General schema theory for genetic pro- gramming with subtree-swapping crossover: part I. Evol. Comput., 11(1):53-66, 2003.</p>
<p>General schema theory for genetic programming with subtree-swapping crossover: part II. Riccardo Poli, Nicholas F Mcphee, Evol. Comput. 112Riccardo Poli and Nicholas F. McPhee. General schema theory for genetic pro- gramming with subtree-swapping crossover: part II. Evol. Comput., 11(2):169-206, 2003.</p>
<p>Exact schema theory and markov chain models for genetic programming and variable-length genetic algorithms with homologous crossover. Genetic Programming and Evolvable Machines. Riccardo Poli, Nicholas F Mcphee, Jonathan E Rowe, 5Riccardo Poli, Nicholas F. McPhee, and Jonathan E. Rowe. Exact schema the- ory and markov chain models for genetic programming and variable-length genetic algorithms with homologous crossover. Genetic Programming and Evolvable Ma- chines, 5(1):31-70, March 2004.</p>
<p>Allele diffusion in linear genetic programming and variable-length genetic algorithms with subtree crossover. Riccardo Poli, Jonathan E Rowe, Christopher R Stephens, Alden H Wright, Genetic Programming, Proceedings of the 5th European Conference. James A. Foster, Evelyne Lutton, Julian Miller, Conor Ryan, and Andrea G. B. TettamanziKinsale, IrelandSpringer-Verlag2278LNCSRiccardo Poli, Jonathan E. Rowe, Christopher R. Stephens, and Alden H. Wright. Allele diffusion in linear genetic programming and variable-length genetic algo- rithms with subtree crossover. In James A. Foster, Evelyne Lutton, Julian Miller, Conor Ryan, and Andrea G. B. Tettamanzi, editors, Genetic Programming, Pro- ceedings of the 5th European Conference, EuroGP 2002, volume 2278 of LNCS, pages 212-227, Kinsale, Ireland, 3-5 April 2002. Springer-Verlag.</p>
<p>Code size and depth flows in genetic programming. Terence Soule, James A Foster ; John, R Koza, Kalyanmoy Deb, Marco Dorigo, David B Fogel, Max Garzon, Hitoshi Iba, Rick L Riolo, Genetic Programming 1997: Proceedings of the Second Annual Conference. Stanford University, CA, USAMorgan KaufmannTerence Soule and James A. Foster. Code size and depth flows in genetic pro- gramming. In John R. Koza, Kalyanmoy Deb, Marco Dorigo, David B. Fogel, Max Garzon, Hitoshi Iba, and Rick L. Riolo, editors, Genetic Programming 1997: Proceedings of the Second Annual Conference, pages 313-320, Stanford University, CA, USA, 13-16 July 1997. Morgan Kaufmann.</p>            </div>
        </div>

    </div>
</body>
</html>