<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-5051 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-5051</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-5051</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-106.html">extraction-schema-106</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models (LLMs or neural language models) being used to solve puzzle games that require spatial knowledge (such as Sudoku or other spatial reasoning tasks). Include details about the models, the puzzles, the mechanisms or strategies used, performance metrics, evidence of spatial reasoning, limitations, and comparisons.</div>
                <p><strong>Paper ID:</strong> paper-50f76736c3090c6effac25400e5e40cc0b7b5ad9</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/50f76736c3090c6effac25400e5e40cc0b7b5ad9" target="_blank">The Neuro-Symbolic Concept Learner: Interpreting Scenes, Words, and Sentences From Natural Supervision</a></p>
                <p><strong>Paper Venue:</strong> International Conference on Learning Representations</p>
                <p><strong>Paper TL;DR:</strong> The Neuro-Symbolic Concept Learner (NS-CL), a model that learns visual concepts, words, and semantic parsing of sentences without explicit supervision on any of them; instead, the model learns by simply looking at images and reading paired questions and answers.</p>
                <p><strong>Paper Abstract:</strong> We propose the Neuro-Symbolic Concept Learner (NS-CL), a model that learns visual concepts, words, and semantic parsing of sentences without explicit supervision on any of them; instead, our model learns by simply looking at images and reading paired questions and answers. Our model builds an object-based scene representation and translates sentences into executable, symbolic programs. To bridge the learning of two modules, we use a neuro-symbolic reasoning module that executes these programs on the latent scene representation. Analogical to human concept learning, the perception module learns visual concepts based on the language description of the object being referred to. Meanwhile, the learned visual concepts facilitate learning new words and parsing new sentences. We use curriculum learning to guide the searching over the large compositional space of images and language. Extensive experiments demonstrate the accuracy and efficiency of our model on learning visual concepts, word representations, and semantic parsing of sentences. Further, our method allows easy generalization to new object attributes, compositions, language concepts, scenes and questions, and even new program domains. It also empowers applications including visual question answering and bidirectional image-text retrieval.</p>
                <p><strong>Cost:</strong> 0.012</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e5051.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e5051.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models (LLMs or neural language models) being used to solve puzzle games that require spatial knowledge (such as Sudoku or other spatial reasoning tasks). Include details about the models, the puzzles, the mechanisms or strategies used, performance metrics, evidence of spatial reasoning, limitations, and comparisons.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>NS-CL (semantic parser)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Neuro-Symbolic Concept Learner — semantic parsing component</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A neural sequence-to-tree semantic parser (encoder-decoder with bidirectional GRU encoder and recursive GRU/FFN decoders) that maps natural-language questions into executable DSL programs which are then symbolically executed on object-level scene representations to solve spatial reasoning VQA tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>NS-CL semantic parser (bi-GRU sequence-to-tree)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Encoder-decoder semantic parser: a bidirectional GRU encoder (two-layer bidirectional GRU) produces a question embedding; an operation decoder (OpDecoder, feed-forward) predicts DSL operators; a concept decoder attends over extracted concept-word embeddings to pick concept parameters; output encoders (GRU cells) recursively produce sub-states to generate a sequence-to-tree hierarchical program. Trained jointly with the perception module using REINFORCE and off-policy program search; curriculum learning is applied. No parameter counts are reported in the paper.</td>
                        </tr>
                        <tr>
                            <td><strong>puzzle_name</strong></td>
                            <td>CLEVR visual question answering (spatial reasoning benchmark)</td>
                        </tr>
                        <tr>
                            <td><strong>puzzle_description</strong></td>
                            <td>Synthetic visual question-answering tasks (CLEVR) with rendered 3D objects where questions require spatial reasoning (relations such as left/right/front/behind), attribute queries (color, shape, size, material), counting, comparisons and compositional queries of varying program depth.</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_or_strategy</strong></td>
                            <td>Translate natural-language question into an explicit program in a CLEVR DSL (operators include Scene, Filter, Relate, AERelate, Query, Count, Exist, Comparison ops etc.), then execute the program deterministically on an object-based scene representation. Execution is quasi-symbolic: object sets are represented as soft attention masks (probabilities), concept classification uses attribute-specific neural operators with learned concept embeddings, and relational classifiers produce pairwise RelClassify matrices; training uses REINFORCE to update the parser and differentiable execution to update perception, with off-policy exhaustive search for low-variance supervision and a curriculum learning schedule.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_of_spatial_reasoning</strong></td>
                            <td>Explicit DSL operators for spatial relations (Relate, AERelate) and relational concept classifiers (RelClassify matrices) are implemented and used in execution traces; the model learns relational concepts (e.g., Left) and uses them in multi-hop programs; semantic parser recovers underlying programs with >99.9% accuracy (so program traces explicitly encode spatial reasoning); experiments include CLEVR relational queries, CLEVR-CoGenT compositional tests, combinatorial generalization to larger scenes and deeper programs, and transfer to a Minecraft dataset with object facing directions, demonstrating use of spatial relations.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>On CLEVR validation: overall QA accuracy 98.9% (Table 4). Visual concept (attribute) classification ≈99% (near-perfect; Table 2). Semantic parser program recovery: >99.9% QA accuracy when checking recovered programs. Data-efficiency (Table 3): NS-CL achieves 99.2% with full data and 98.9% when trained with 10% of training images. On CLEVR-CoGenT split tests, accuracy ≈98.8–98.9% across splits. On incremental new-color fine-tuning (100 images) achieved 93.9% on target split. Exact numeric metrics quoted from the paper's tables.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Relational/spatial-concept learning is weaker than object-attribute learning because CLEVR has relatively few direct spatial-relation queries; spatial relation concepts are learned indirectly. The approach assumes a domain-specific language (DSL) and requires concept-word extraction rules (hand-coded for CLEVR), relies on object proposals (Mask R-CNN) and pretrained perception (ResNet-34/ImageNet), and needs curriculum learning for stable training. Authors report spurious/ambiguous programs (programs that are different but equivalent or scene-specific spurious programs) and use sampling/importance weighting and stop-grad heuristics to mitigate them. The model is not evaluated on unconstrained natural-language dialog-like puzzles or puzzle games such as Sudoku, and the authors note extensions to 3D scenes and action semantics are future work.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Compared against several state-of-the-art VQA/reasoning models: TbD (Mascharka et al., 2018) reported 99.1% overall (but requires program annotations for parser training in TbD's best setups), MAC (Hudson & Manning, 2018) reported 98.9%, FiLM (Perez et al., 2018) 97.6%, IEP (Johnson et al., 2017b) 96.9% (table values from paper). NS-CL matches or exceeds many baselines while using zero program annotations; NS-VQA (Yi et al., 2018) achieves slightly better numbers but requires annotated visual attributes and program traces during training. NS-CL is notably more data-efficient: with just 10% of training images NS-CL achieves ~98.9% while many baselines drop substantially (e.g., MAC drops to 67.3% in the paper's 10% data comparison for a particular variant).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'The Neuro-Symbolic Concept Learner: Interpreting Scenes, Words, and Sentences From Natural Supervision', 'publication_date_yy_mm': '2019-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>CLEVR: A diagnostic dataset for compositional language and elementary visual reasoning <em>(Rating: 2)</em></li>
                <li>Inferring and executing programs for visual reasoning <em>(Rating: 2)</em></li>
                <li>Compositional attention networks for machine reasoning <em>(Rating: 2)</em></li>
                <li>Film: Visual reasoning with a general conditioning layer <em>(Rating: 2)</em></li>
                <li>Transparency by design: Closing the gap between performance and interpretability in visual reasoning <em>(Rating: 2)</em></li>
                <li>Neural-Symbolic VQA: Disentangling reasoning from vision and language understanding <em>(Rating: 2)</em></li>
                <li>A simple neural network module for relational reasoning <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-5051",
    "paper_id": "paper-50f76736c3090c6effac25400e5e40cc0b7b5ad9",
    "extraction_schema_id": "extraction-schema-106",
    "extracted_data": [
        {
            "name_short": "NS-CL (semantic parser)",
            "name_full": "Neuro-Symbolic Concept Learner — semantic parsing component",
            "brief_description": "A neural sequence-to-tree semantic parser (encoder-decoder with bidirectional GRU encoder and recursive GRU/FFN decoders) that maps natural-language questions into executable DSL programs which are then symbolically executed on object-level scene representations to solve spatial reasoning VQA tasks.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "NS-CL semantic parser (bi-GRU sequence-to-tree)",
            "model_description": "Encoder-decoder semantic parser: a bidirectional GRU encoder (two-layer bidirectional GRU) produces a question embedding; an operation decoder (OpDecoder, feed-forward) predicts DSL operators; a concept decoder attends over extracted concept-word embeddings to pick concept parameters; output encoders (GRU cells) recursively produce sub-states to generate a sequence-to-tree hierarchical program. Trained jointly with the perception module using REINFORCE and off-policy program search; curriculum learning is applied. No parameter counts are reported in the paper.",
            "puzzle_name": "CLEVR visual question answering (spatial reasoning benchmark)",
            "puzzle_description": "Synthetic visual question-answering tasks (CLEVR) with rendered 3D objects where questions require spatial reasoning (relations such as left/right/front/behind), attribute queries (color, shape, size, material), counting, comparisons and compositional queries of varying program depth.",
            "mechanism_or_strategy": "Translate natural-language question into an explicit program in a CLEVR DSL (operators include Scene, Filter, Relate, AERelate, Query, Count, Exist, Comparison ops etc.), then execute the program deterministically on an object-based scene representation. Execution is quasi-symbolic: object sets are represented as soft attention masks (probabilities), concept classification uses attribute-specific neural operators with learned concept embeddings, and relational classifiers produce pairwise RelClassify matrices; training uses REINFORCE to update the parser and differentiable execution to update perception, with off-policy exhaustive search for low-variance supervision and a curriculum learning schedule.",
            "evidence_of_spatial_reasoning": "Explicit DSL operators for spatial relations (Relate, AERelate) and relational concept classifiers (RelClassify matrices) are implemented and used in execution traces; the model learns relational concepts (e.g., Left) and uses them in multi-hop programs; semantic parser recovers underlying programs with &gt;99.9% accuracy (so program traces explicitly encode spatial reasoning); experiments include CLEVR relational queries, CLEVR-CoGenT compositional tests, combinatorial generalization to larger scenes and deeper programs, and transfer to a Minecraft dataset with object facing directions, demonstrating use of spatial relations.",
            "performance_metrics": "On CLEVR validation: overall QA accuracy 98.9% (Table 4). Visual concept (attribute) classification ≈99% (near-perfect; Table 2). Semantic parser program recovery: &gt;99.9% QA accuracy when checking recovered programs. Data-efficiency (Table 3): NS-CL achieves 99.2% with full data and 98.9% when trained with 10% of training images. On CLEVR-CoGenT split tests, accuracy ≈98.8–98.9% across splits. On incremental new-color fine-tuning (100 images) achieved 93.9% on target split. Exact numeric metrics quoted from the paper's tables.",
            "limitations_or_failure_cases": "Relational/spatial-concept learning is weaker than object-attribute learning because CLEVR has relatively few direct spatial-relation queries; spatial relation concepts are learned indirectly. The approach assumes a domain-specific language (DSL) and requires concept-word extraction rules (hand-coded for CLEVR), relies on object proposals (Mask R-CNN) and pretrained perception (ResNet-34/ImageNet), and needs curriculum learning for stable training. Authors report spurious/ambiguous programs (programs that are different but equivalent or scene-specific spurious programs) and use sampling/importance weighting and stop-grad heuristics to mitigate them. The model is not evaluated on unconstrained natural-language dialog-like puzzles or puzzle games such as Sudoku, and the authors note extensions to 3D scenes and action semantics are future work.",
            "comparison_baseline": "Compared against several state-of-the-art VQA/reasoning models: TbD (Mascharka et al., 2018) reported 99.1% overall (but requires program annotations for parser training in TbD's best setups), MAC (Hudson & Manning, 2018) reported 98.9%, FiLM (Perez et al., 2018) 97.6%, IEP (Johnson et al., 2017b) 96.9% (table values from paper). NS-CL matches or exceeds many baselines while using zero program annotations; NS-VQA (Yi et al., 2018) achieves slightly better numbers but requires annotated visual attributes and program traces during training. NS-CL is notably more data-efficient: with just 10% of training images NS-CL achieves ~98.9% while many baselines drop substantially (e.g., MAC drops to 67.3% in the paper's 10% data comparison for a particular variant).",
            "uuid": "e5051.0",
            "source_info": {
                "paper_title": "The Neuro-Symbolic Concept Learner: Interpreting Scenes, Words, and Sentences From Natural Supervision",
                "publication_date_yy_mm": "2019-04"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "CLEVR: A diagnostic dataset for compositional language and elementary visual reasoning",
            "rating": 2
        },
        {
            "paper_title": "Inferring and executing programs for visual reasoning",
            "rating": 2
        },
        {
            "paper_title": "Compositional attention networks for machine reasoning",
            "rating": 2
        },
        {
            "paper_title": "Film: Visual reasoning with a general conditioning layer",
            "rating": 2
        },
        {
            "paper_title": "Transparency by design: Closing the gap between performance and interpretability in visual reasoning",
            "rating": 2
        },
        {
            "paper_title": "Neural-Symbolic VQA: Disentangling reasoning from vision and language understanding",
            "rating": 2
        },
        {
            "paper_title": "A simple neural network module for relational reasoning",
            "rating": 1
        }
    ],
    "cost": 0.011932,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>The Neuro-Symbolic Concept Learner: Interpreting Scenes, Words, and Sentences FROM NATURAL SUPERVISION</h1>
<p>Jiayuan Mao<br>MIT CSAIL and IIIS, Tsinghua University<br>mjy14@mails.tsinghua.edu.cn</p>
<p>Pushmeet Kohli
Deepmind
pushmeet@google.com</p>
<p>Joshua B. Tenenbaum
MIT BCS, CBMM, CSAIL
jbt@mit.edu</p>
<h2>Chuang Gan <br> MIT-IBM Watson AI Lab <br> ganchuang@csail.mit.edu</h2>
<p>Jiajun Wu
MIT CSAIL
jiajunwu@mit.edu</p>
<h2>ABSTRACT</h2>
<p>We propose the Neuro-Symbolic Concept Learner (NS-CL), a model that learns visual concepts, words, and semantic parsing of sentences without explicit supervision on any of them; instead, our model learns by simply looking at images and reading paired questions and answers. Our model builds an object-based scene representation and translates sentences into executable, symbolic programs. To bridge the learning of two modules, we use a neuro-symbolic reasoning module that executes these programs on the latent scene representation. Analogical to human concept learning, the perception module learns visual concepts based on the language description of the object being referred to. Meanwhile, the learned visual concepts facilitate learning new words and parsing new sentences. We use curriculum learning to guide the searching over the large compositional space of images and language. Extensive experiments demonstrate the accuracy and efficiency of our model on learning visual concepts, word representations, and semantic parsing of sentences. Further, our method allows easy generalization to new object attributes, compositions, language concepts, scenes and questions, and even new program domains. It also empowers applications including visual question answering and bidirectional image-text retrieval.</p>
<h2>1 INTRODUCTION</h2>
<p>Humans are capable of learning visual concepts by jointly understanding vision and language (Fazly et al., 2010; Chrupała et al., 2015; Gauthier et al., 2018). Consider the example shown in Figure 1-I. Imagine that someone with no prior knowledge of colors is presented with the images of the red and green cubes, paired with the questions and answers. They can easily identify the difference in objects' visual appearance (in this case, color), and align it to the corresponding words in the questions and answers (Red and Green). Other object attributes (e.g., shape) can be learned in a similar fashion. Starting from there, humans are able to inductively learn the correspondence between visual concepts and word semantics (e.g., spatial relations and referential expressions, Figure 1-II), and unravel compositional logic from complex questions assisted by the learned visual concepts (Figure 1-III, also see Abend et al. (2017)).</p>
<p>Motivated by this, we propose the neuro-symbolic concept learner (NS-CL), which jointly learns visual perception, words, and semantic language parsing from images and question-answer pairs. NS-CL has three modules: a neural-based perception module that extracts object-level representations from the scene, a visually-grounded semantic parser for translating questions into executable programs, and a symbolic program executor that reads out the perceptual representation of objects, classifies their attributes/relations, and executes the program to obtain an answer.</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Humans learn visual concepts, words, and semantic parsing jointly and incrementally. I. Learning visual concepts (red $v s$. green) starts from looking at simple scenes, reading simple questions, and reasoning over contrastive examples (Fazly et al., 2010). II. Afterwards, we can interpret referential expressions based on the learned object-based concepts, and learn relational concepts (e.g., on the right of, the same material as). III Finally, we can interpret complex questions from visual cues by exploiting the compositional structure.</p>
<p>NS-CL learns from natural supervision (i.e., images and QA pairs), requiring no annotations on images or semantic programs for sentences. Instead, analogical to human concept learning, it learns via curriculum learning. NS-CL starts by learning representations/concepts of individual objects from short questions (e.g., What's the color of the cylinder?) on simple scenes ( $\leq 3$ objects). By doing so, it learns object-based concepts such as colors and shapes. NS-CL then learns relational concepts by leveraging these object-based concepts to interpret object referrals (e.g., Is there a box right of a cylinder?). The model iteratively adapts to more complex scenes and highly compositional questions.</p>
<p>NS-CL's modularized design enables interpretable, robust, and accurate visual reasoning: it achieves state-of-the-art performance on the CLEVR dataset (Johnson et al., 2017a). More importantly, it naturally learns disentangled visual and language concepts, enabling combinatorial generalization w.r.t. both visual scenes and semantic programs. In particular, we demonstrate four forms of generalization. First, NS-CL generalizes to scenes with more objects and longer semantic programs than those in the training set. Second, it generalizes to new visual attribute compositions, as demonstrated on the CLEVR-CoGenT (Johnson et al., 2017a) dataset. Third, it enables fast adaptation to novel visual concepts, such as learning a new color. Finally, the learned visual concepts transfer to new tasks, such as image-caption retrieval, without any extra fine-tuning.</p>
<h1>2 Related Work</h1>
<p>Our model is related to research on joint learning of vision and natural language. In particular, there are many papers that learn visual concepts from descriptive languages, such as image-captioning or visually-grounded question-answer pairs (Kiros et al., 2014; Shi et al., 2018; Mao et al., 2016; Vendrov et al., 2016; Ganju et al., 2017), dense language descriptions for scenes (Johnson et al., 2016), video-captioning (Donahue et al., 2015) and video-text alignment (Zhu et al., 2015).</p>
<p>Visual question answering (VQA) stands out as it requires understanding both visual content and language. The state-of-the-art approaches usually use neural attentions (Malinowski \&amp; Fritz, 2014; Chen et al., 2015; Yang et al., 2016; Xu \&amp; Saenko, 2016). Beyond question answering, Johnson et al. (2017a) proposed the CLEVR (VQA) dataset to diagnose reasoning models. CLEVR contains synthetic visual scenes and questions generated from latent programs. Table 1 compares our model with state-of-the-art visual reasoning models (Andreas et al., 2016; Suarez et al., 2018; Santoro et al., 2017) along four directions: visual features, semantics, inference, and the requirement of extra labels.</p>
<p>For visual representations, Johnson et al. (2017b) encoded visual scenes into a convolutional feature map for program operators. Mascharka et al. (2018); Hudson \&amp; Manning (2018) used attention as intermediate representations for transparent program execution. Recently, Yi et al. (2018) explored an interpretable, object-based visual representation for visual reasoning. It performs well, but requires fully-annotated scenes during training. Our model also adopts an object-based visual representation, but the representation is learned only based on natural supervision (questions and answers).</p>
<p>Anderson et al. (2018) also proposed to represent the image as a collection of convolutional object features and gained substantial improvements on VQA. Their model encodes questions with neural</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Models</th>
<th style="text-align: center;">Visual Features</th>
<th style="text-align: center;">Semantics</th>
<th style="text-align: center;">Extra Labels</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Inference</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"># Prog.</td>
<td style="text-align: center;">Attr.</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">FiLM (Perez et al., 2018)</td>
<td style="text-align: center;">Convolutional</td>
<td style="text-align: center;">Implicit</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">Feature Manipulation</td>
</tr>
<tr>
<td style="text-align: center;">IEP (Johnson et al., 2017b)</td>
<td style="text-align: center;">Convolutional</td>
<td style="text-align: center;">Explicit</td>
<td style="text-align: center;">700 K</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">Feature Manipulation</td>
</tr>
<tr>
<td style="text-align: center;">MAC (Hudson \&amp; Manning, 2018)</td>
<td style="text-align: center;">Attentional</td>
<td style="text-align: center;">Implicit</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">Feature Manipulation</td>
</tr>
<tr>
<td style="text-align: center;">Stack-NMN (Hu et al., 2018)</td>
<td style="text-align: center;">Attentional</td>
<td style="text-align: center;">Implicit</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">Attention Manipulation</td>
</tr>
<tr>
<td style="text-align: center;">TbD (Mascharka et al., 2018)</td>
<td style="text-align: center;">Attentional</td>
<td style="text-align: center;">Explicit</td>
<td style="text-align: center;">700 K</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">Attention Manipulation</td>
</tr>
<tr>
<td style="text-align: center;">NS-VQA (Yi et al., 2018)</td>
<td style="text-align: center;">Object-Based</td>
<td style="text-align: center;">Explicit</td>
<td style="text-align: center;">0.2 K</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Symbolic Execution</td>
</tr>
<tr>
<td style="text-align: center;">NS-CL</td>
<td style="text-align: center;">Object-Based</td>
<td style="text-align: center;">Explicit</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">Symbolic Execution</td>
</tr>
</tbody>
</table>
<p>Table 1: Comparison with other frameworks on the CLEVR VQA dataset, w.r.t. visual features, implicit or explicit semantics and supervisions.
<img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: We propose to use neural symbolic reasoning as a bridge to jointly learn visual concepts, words, and semantic parsing of sentences.
networks and answers the questions by question-conditioned attention over the object features. In contrast, NS-CL parses question inputs into programs and executes them on object features to get the answer. This makes the reasoning process interpretable and supports combinatorial generalization over quantities (e.g., counting objects). Our model also learns general visual concepts and their association with symbolic representations of language. These learned concepts can then be explicitly interpreted and deployed in other vision-language applications such as image caption retrieval.</p>
<p>There are two types of approaches in semantic sentence parsing for visual reasoning: implicit programs as conditioned neural operations (e.g., conditioned convolution and dual attention) (Perez et al., 2018; Hudson \&amp; Manning, 2018) and explicit programs as sequences of symbolic tokens (Andreas et al., 2016; Johnson et al., 2017b; Mascharka et al., 2018). As a representative, Andreas et al. (2016) build modular and structured neural architectures based on programs for answering questions. Explicit programs gain better interpretability, but usually require extra supervision such as groundtruth program annotations for training. This restricts their application. We propose to use visual grounding as distant supervision to parse questions in natural languages into explicit programs, with zero program annotations. Given the semantic parsing of questions into programs, Yi et al. (2018) proposed a purely symbolic executor for the inference of the answer in the logic space. Compared with theirs, we propose a quasi-symbolic executor for VQA.</p>
<p>Our work is also related to learning interpretable and disentangled representations for visual scenes using neural networks. Kulkarni et al. (2015) proposed convolutional inverse graphics networks for learning and inferring pose of faces, while Yang et al. (2015) learned disentangled representation of pose of chairs from images. Wu et al. (2017) proposed the neural scene de-rendering framework as an inverse process of any rendering process. Siddharth et al. (2017); Higgins et al. (2018) learned disentangled representations using deep generative models. In contrast, we propose an alternative representation learning approach through joint reasoning with language.</p>
<h1>3 NEURO-SYMBOLIC CONCEPT LEARNER</h1>
<p>We present our neuro-symbolic concept learner, which uses a symbolic reasoning process to bridge the learning of visual concepts, words, and semantic parsing of sentences without explicit annotations</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: We treat attributes such as Shape and Color as neural operators. The operators map object representations into a visual-semantic space. We use similarity-based metric to classify objects.
for any of them. We first use a visual perception module to construct an object-based representation for a scene, and run a semantic parsing module to translate a question into an executable program. We then apply a quasi-symbolic program executor to infer the answer based on the scene representation. We use paired images, questions, and answers to jointly train the visual and language modules.</p>
<p>Shown in Figure 2, given an input image, the visual perception module detects objects in the scene and extracts a deep, latent representation for each of them. The semantic parsing module translates an input question in natural language into an executable program given a domain specific language (DSL). The generated programs have a hierarchical structure of symbolic, functional modules, each fulfilling a specific operation over the scene representation. The explicit program semantics enjoys compositionality, interpretability, and generalizability.</p>
<p>The program executor executes the program upon the derived scene representation and answers the question. Our program executor works in a symbolic and deterministic manner. This feature ensures a transparent execution trace of the program. Our program executor has a fully differentiable design w.r.t. the visual representations and the concept representations, which supports gradient-based optimization during training.</p>
<h1>3.1 MODEL DETAILS</h1>
<p>Visual perception. Shown in Figure 2, given the input image, we use a pretrained Mask R-CNN (He et al., 2017) to generate object proposals for all objects. The bounding box for each single object paired with the original image is then sent to a ResNet-34 (He et al., 2015) to extract the region-based (by RoI Align) and image-based features respectively. We concatenate them to represent each object. Here, the inclusion of the representation of the full scene adds the contextual information, which is essential for the inference of relative attributes such as size or spatial position.</p>
<p>Concept quantization. Visual reasoning requires determining an object's attributes (e.g., its color or shape). We assume each visual attribute (e.g., shape) contains a set of visual concept (e.g., Cube). In NS-CL, visual attributes are implemented as neural operators, mapping the object representation into an attribute-specific embedding space. Figure 3 shows an inference an object's shape. Visual concepts that belong to the shape attribute, including Cube, Sphere and Cylinder, are represented as vectors in the shape embedding space. These concept vectors are also learned along the process. We measure the cosine distances $\langle\cdot, \cdot\rangle$ between these vectors to determine the shape of the object. Specifically, we compute the probability that an object $o_{i}$ is a cube by $\sigma{\langle\operatorname{ShapeOf}\left(o_{i}\right), v^{\text {Cube }}\rangle-\gamma} / \tau$, where ShapeOf $(\cdot)$ denotes the neural operator, $v^{\text {Cube }}$ the concept embedding of Cube and $\sigma$ the Sigmoid function. $\gamma$ and $\tau$ are scalar constants for scaling and shifting the values of similarities. We classify relational concepts (e.g., Left) between a pair of objects similarly, except that we concatenate the visual representations for both objects to form the representation of their relation.</p>
<p>DSL and semantic parsing. The semantic parsing module translates a natural language question into an executable program with a hierarchy of primitive operations, represented in a domain-specific language (DSL) designed for VQA. The DSL covers a set of fundamental operations for visual reasoning, such as filtering out objects with certain concepts or query the attribute of an object. The operations share the same input and output interface, and thus can be compositionally combined to form programs of any complexity. We include a complete specification of the DSL used by our framework in the Appendix A.</p>
<p><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 4: A. Demonstration of the curriculum learning of visual concepts, words, and semantic parsing of sentences by watching images and reading paired questions and answers. Scenes and questions of different complexities are illustrated to the learner in an incremental manner. B. Illustration of our neuro-symbolic inference model for VQA. The perception module begins with parsing visual scenes into object-based deep representations, while the semantic parser parse sentences into executable programs. A symbolic execution process bridges two modules.</p>
<p>Our semantic parser generates the hierarchies of latent programs in a sequence to tree manner (Dong \&amp; Lapata, 2016). We use a bidirectional GRU (Cho et al., 2014) to encode an input question, which outputs a fixed-length embedding of the question. A decoder based on GRU cells is applied to the embedding, and recovers the hierarchy of operations as the latent program. Some operations takes concepts their parameters, such as Filter( Red ) and Query( Shape ). These concepts are chosen from all concepts appeared in the input question. Figure 4(B) shows an example, while more details can be found in Appendix B.</p>
<p>Quasi-symbolic program execution. Given the latent program recovered from the question in natural language, a symbolic program executor executes the program and derives the answer based on the object-based visual representation. Our program executor is a collection of deterministic functional modules designed to realize all logic operations specified in the DSL. Figure 4(B) shows an illustrative execution trace of a program.</p>
<p>To make the execution differentiable w.r.t. visual representations, we represent the intermediate results in a probabilistic manner: a set of objects is represented by a vector, as the attention mask over all objects in the scene. Each element, Mask, $\in[0,1]$ denotes the probability that the $i$-th object of the scene belongs to the set. For example, shown in Figure 4(B), the first Filter operation outputs a mask of length 4 (there are in total 4 objects in the scene), with each element representing the probability that the corresponding object is selected out (i.e., the probability that each object is a green cube). The output "mask" on the objects will be fed into the next module (Relate in this case) as input and the execution of programs continues. The last module outputs the final answer to the question. We refer interested readers to Appendix C for the implementation of all operators.</p>
<h1>3.2 TRAINING PARADIGM</h1>
<p>Optimization objective. The optimization objective of NS-CL is composed of two parts: concept learning and language understanding. Our goal is to find the optimal parameters $\Theta_{v}$ of the visual</p>
<p>perception module Perception (including the ResNet-34 for extracting object features, attribute operators. and concept embeddings) and $\Theta_{s}$ of the semantic parsing module SemanticParse, to maximize the likelihood of answering the question $Q$ correctly:</p>
<p>$$
\Theta_{v}, \Theta_{s} \leftarrow \arg \max <em v="v">{\Theta</em>}, \Theta_{s}} \mathbb{E<em v="v">{P}\left[\operatorname{Pr}\left[A=\operatorname{Executor}\left(\operatorname{Perception}\left(S ; \Theta</em>\right), P\right)\right]\right]
$$</p>
<p>where $P$ denotes the program, $A$ the answer, $S$ the scene, and Executor the quasi-symbolic executor. The expectation is taken over $P \sim \operatorname{SemanticParse}\left(Q ; \Theta_{s}\right)$.
Recall the program executor is fully differentiable w.r.t. the visual representation. We compute the gradient w.r.t. $\Theta_{v}$ as $\nabla_{\Theta_{v}} \mathbb{E}<em _mathrm_KL="\mathrm{KL">{P}\left[D</em>}}\left(\operatorname{Executor}\left(\operatorname{Perception}\left(S ; \Theta_{v}\right), P\right) | A\right)\right]$. We use REINFORCE (Williams, 1992) to optimize the semantic parser $\Theta_{s}: \nabla_{\Theta_{s}}=\mathbb{E<em s="s">{P}[r \cdot \log \operatorname{Pr}[P=$ $\left.\operatorname{SemanticParse}\left(Q ; \Theta</em>\right)\right]\right]$, where the reward $r=1$ if the answer is correct and 0 otherwise. We also use off-policy search to reduce the variance of REINFORCE, the detail of which can be found in Appendix D.</p>
<p>Curriculum visual concept learning. Motivated by human concept learning as in Figure 1, we employ a curriculum learning approach to help joint optimization. We heuristically split the training samples into four stages (Figure 4(A)): first, learning object-level visual concepts; second, learning relational questions; third, learning more complex questions with perception modules fixed; fourth, joint fine-tuning of all modules. We found that this is essential to the learning of our neuro-symbolic concept learner. We include more technical details in Appendix E.</p>
<h1>4 EXPERIMENTS</h1>
<p>We demonstrate the following advantages of our NS-CL. First, it learns visual concepts with remarkable accuracy; second, it allows data-efficient visual reasoning on the CLEVR dataset (Johnson et al., 2017a); third, it generalizes well to new attributes, visual composition, and language domains.
We train NS-CL on 5K images ( $&lt;10 \%$ of CLEVR's 70K training images). We generate 20 questions for each image for the entire curriculum learning process. The Mask R-CNN module is pretrained on 4 K generated CLEVR images with bounding box annotations, following Yi et al. (2018).</p>
<h3>4.1 VISUAL CONCEPT LEARNING</h3>
<p>Classification-based concept evaluation. Our model treats attributes as neural operators that map latent object representations into an attribute-specific embedding space (Figure 3). We evaluate the concept quantization of objects in the CLEVR validation split. Our model can achieve near perfect classification accuracy ( $\sim 99 \%$ ) for all object properties, suggesting it effectively learns generic concept representations. The result for spatial relations is relatively lower, because CLEVR does not have direct queries on the spatial relation between objects. Thus, spatial relation concepts can only be learned indirectly.</p>
<p>Count-based concept evaluation. The SOTA methods do not provide interpretable representation on individual objects (Johnson et al., 2017a; Hudson \&amp; Manning, 2018; Mascharka et al., 2018) . To evaluate the visual concepts learned by such models, we generate a synthetic question set. The diagnostic question set contains simple questions as the following form: "How many red objects are there?". We evaluate the performance on all concepts appeared in the CLEVR dataset.</p>
<p>Table 2 summarizes the results compared with strong baselines, including methods based on convolutional features (Johnson et al., 2017b) and those based on neural attentions (Mascharka et al., 2018; Hudson \&amp; Manning, 2018). Our approach outperforms IEP by a significant margin (8\%) and attention-based baselines by $&gt;2 \%$, suggesting object-based visual representations and symbolic reasoning helps to interpret visual concepts.</p>
<h3>4.2 DATA-EFFICIENT AND INTERPRETABLE VISUAL REASONING</h3>
<p>NS-CL jointly learns visual concepts, words and semantic parsing by watching images and reading paired questions and answers. It can be directly applied to VQA.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: center;">Visual</th>
<th style="text-align: center;">Mean</th>
<th style="text-align: center;">Color</th>
<th style="text-align: center;">Mat.</th>
<th style="text-align: center;">Shape</th>
<th style="text-align: center;">Size</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">IEP</td>
<td style="text-align: center;">Conv.</td>
<td style="text-align: center;">90.6</td>
<td style="text-align: center;">91.0</td>
<td style="text-align: center;">90.0</td>
<td style="text-align: center;">89.9</td>
<td style="text-align: center;">90.6</td>
</tr>
<tr>
<td style="text-align: left;">MAC</td>
<td style="text-align: center;">Attn.</td>
<td style="text-align: center;">95.9</td>
<td style="text-align: center;">98.0</td>
<td style="text-align: center;">91.4</td>
<td style="text-align: center;">94.4</td>
<td style="text-align: center;">94.2</td>
</tr>
<tr>
<td style="text-align: left;">TbD (hres.)</td>
<td style="text-align: center;">Attn.</td>
<td style="text-align: center;">96.5</td>
<td style="text-align: center;">96.6</td>
<td style="text-align: center;">92.2</td>
<td style="text-align: center;">95.4</td>
<td style="text-align: center;">92.6</td>
</tr>
<tr>
<td style="text-align: left;">NS-CL</td>
<td style="text-align: center;">Obj.</td>
<td style="text-align: center;">$\mathbf{9 8 . 7}$</td>
<td style="text-align: center;">$\mathbf{9 9 . 0}$</td>
<td style="text-align: center;">$\mathbf{9 8 . 7}$</td>
<td style="text-align: center;">$\mathbf{9 8 . 1}$</td>
<td style="text-align: center;">$\mathbf{9 9 . 1}$</td>
</tr>
</tbody>
</table>
<p>Table 2: We also evaluate the learned visual concepts using a diagnostic question set containing simple questions such as "How many red objects are there?". NS-CL outperforms both convolutional and attentional baselines. The suggested object-based visual representation and symbolic reasoning approach perceives better interpretation of visual concepts.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: left;">Visual</th>
<th style="text-align: center;">Accuracy <br> (100\% Data)</th>
<th style="text-align: center;">Accuracy <br> (10\% Data)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">TbD</td>
<td style="text-align: left;">Attn.</td>
<td style="text-align: center;">99.1</td>
<td style="text-align: center;">54.2</td>
</tr>
<tr>
<td style="text-align: left;">TbD-Object</td>
<td style="text-align: left;">Obj.</td>
<td style="text-align: center;">84.1</td>
<td style="text-align: center;">52.6</td>
</tr>
<tr>
<td style="text-align: left;">TbD-Mask</td>
<td style="text-align: left;">Attn.</td>
<td style="text-align: center;">99.0</td>
<td style="text-align: center;">55.0</td>
</tr>
<tr>
<td style="text-align: left;">MAC</td>
<td style="text-align: left;">Attn.</td>
<td style="text-align: center;">98.9</td>
<td style="text-align: center;">67.3</td>
</tr>
<tr>
<td style="text-align: left;">MAC-Object</td>
<td style="text-align: left;">Obj.</td>
<td style="text-align: center;">79.5</td>
<td style="text-align: center;">51.2</td>
</tr>
<tr>
<td style="text-align: left;">MAC-Mask</td>
<td style="text-align: left;">Attn.</td>
<td style="text-align: center;">98.7</td>
<td style="text-align: center;">68.4</td>
</tr>
<tr>
<td style="text-align: left;">NS-CL</td>
<td style="text-align: left;">Obj.</td>
<td style="text-align: center;">$\mathbf{9 9 . 2}$</td>
<td style="text-align: center;">$\mathbf{9 8 . 9}$</td>
</tr>
</tbody>
</table>
<p>Table 3: We compare different variants of baselines for a systematic study on visual features and data efficiency. Using only $10 \%$ of the training images, our model is able to achieve a comparable results with the baselines trained on the full dataset. See the text for details.</p>
<p>Table 4 summarizes results on the CLEVR validation split. Our model achieves the state-of-theart performance among all baselines using zero program annotations, including MAC (Hudson \&amp; Manning, 2018) and FiLM (Perez et al., 2018). Our model achieves comparable performance with the strong baseline TbD-Nets (Mascharka et al., 2018), whose semantic parser is trained using 700K programs in CLEVR (ours need 0). The recent NS-VQA model from Yi et al. (2018) achieves better performance on CLEVR; however, their system requires annotated visual attributes and program traces during training, while our NS-CL needs no extra labels.</p>
<p>Here, the visual perception module is pre-trained on ImageNet (Deng et al., 2009). Without pretraining, the concept learning accuracies drop by $0.2 \%$ on average and the QA accuracy drops by $0.5 \%$. Meanwhile, NS-CL recovers the underlying programs of questions accurately ( $&gt;99.9 \%$ accuracy). NS-CL can also detect ambiguous or invalid programs and indicate exceptions. Please see Appendix F for more details. NS-CL can also be applied to other visual reasoning testbeds. Please refer to Appendix G. 1 for our results on the Minecraft dataset (Yi et al., 2018).</p>
<p>For a systematic study on visual features and data efficiency, we implement two variants of the baseline models: TbD-Object and MAC-Object. Inspired by (Anderson et al., 2018), instead of the input image, TbD-Object and MAC-Object take a stack of object features as input. TbD-Mask and MAC-Mask integrate the masks of objects by using them to guide the attention over the images.</p>
<p>Table 3 summarizes the results. Our model outperforms all baselines on data efficiency. This comes from the full disentanglement of visual concept learning and symbolic reasoning: how to execute program instructions based on the learned concepts is programmed. TbD-Object and MAC-Object demonstrate inferior results in our experiments. We attribute this to the design of model architectures and have a detailed analysis in Appendix F.3. Although TbD-Mask and MAC-Mask do not perform better than the originals, we find that using masks to guide attentions speeds up the training.</p>
<p>Besides achieving a competitive performance on the visual reasoning testbeds, by leveraging both object-based representation and symbolic reasoning, out model learns fully interpretable visual concepts: see Appendix H for qualitative results on various datasets.</p>
<h1>4.3 GENERALIZATION TO NEW ATTRIBUTES AND COMPOSITIONS</h1>
<p>Generalizing to new visual compositions. The CLEVR-CoGenT dataset is designed to evaluate models' ability to generalize to new visual compositions. It has two splits: Split A only contains gray, blue, brown and yellow cubes, but red, green, purple, and cyan cylinders; split B imposes the opposite color constraints on cubes and cylinders. If we directly learn visual concepts on split A , it overfits to classify shapes based on the color, leading to a poor generalization to split B.
Our solution is based on the idea of seeing attributes as operators. Specifically, we jointly train the concept embeddings (e.g., Red, Cube, etc.) as well as the semantic parser on split A, keeping pretrained, frozen attribute operators. As we learn distinct representation spaces for different attributes, our model achieves an accuracy of $98.8 \%$ on split A and $98.9 \%$ on split B.</p>
<table>
<thead>
<tr>
<th>Model</th>
<th>Prog.</th>
<th>Overall</th>
<th>Count</th>
<th>Cmp.</th>
<th>Exist</th>
<th>Query</th>
<th>Cmp.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Anno.</td>
<td></td>
<td></td>
<td>Num.</td>
<td></td>
<td>Attr.</td>
<td>Attr.</td>
</tr>
<tr>
<td>Human</td>
<td>N/A</td>
<td>92.6</td>
<td>86.7</td>
<td>86.4</td>
<td>96.6</td>
<td>95.0</td>
<td>96.0</td>
</tr>
<tr>
<td>NMN</td>
<td>700K</td>
<td>72.1</td>
<td>52.5</td>
<td>72.7</td>
<td>79.3</td>
<td>79.0</td>
<td>78.0</td>
</tr>
<tr>
<td>N2NMN</td>
<td>700K</td>
<td>88.8</td>
<td>68.5</td>
<td>84.9</td>
<td>85.7</td>
<td>90.0</td>
<td>88.8</td>
</tr>
<tr>
<td>IEP</td>
<td>700K</td>
<td>96.9</td>
<td>92.7</td>
<td>98.7</td>
<td>97.1</td>
<td>98.1</td>
<td>98.9</td>
</tr>
<tr>
<td>DDRprog</td>
<td>700K</td>
<td>98.3</td>
<td>96.5</td>
<td>98.4</td>
<td>98.8</td>
<td>99.1</td>
<td>99.0</td>
</tr>
<tr>
<td>TbD</td>
<td>700K</td>
<td>99.1</td>
<td>97.6</td>
<td>99.4</td>
<td>99.2</td>
<td>99.5</td>
<td>99.6</td>
</tr>
<tr>
<td>RN</td>
<td>0</td>
<td>95.5</td>
<td>90.1</td>
<td>93.6</td>
<td>97.8</td>
<td>97.1</td>
<td>97.9</td>
</tr>
<tr>
<td>FiLM</td>
<td>0</td>
<td>97.6</td>
<td>94.5</td>
<td>93.8</td>
<td>99.2</td>
<td>99.2</td>
<td>99.0</td>
</tr>
<tr>
<td>MAC</td>
<td>0</td>
<td>98.9</td>
<td>97.2</td>
<td>99.4</td>
<td>99.5</td>
<td>99.3</td>
<td>99.5</td>
</tr>
<tr>
<td>NS-CL</td>
<td>0</td>
<td>98.9</td>
<td>98.2</td>
<td>99.0</td>
<td>98.8</td>
<td>99.3</td>
<td>99.1</td>
</tr>
</tbody>
</table>
<p>Table 4: Our model outperforms all baselines using no program annotations. It achieves comparable results with models trained by full program annotations such as TbD.</p>
<table>
<thead>
<tr>
<th>Model</th>
<th>Test</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Split A</td>
<td>Split B</td>
<td>Split C</td>
<td>Split D</td>
<td></td>
</tr>
<tr>
<td>MAC</td>
<td>97.3</td>
<td>N/A</td>
<td>92.9</td>
<td>N/A</td>
<td></td>
</tr>
<tr>
<td>IEP</td>
<td>96.1</td>
<td>92.1</td>
<td>91.5</td>
<td>90.9</td>
<td></td>
</tr>
<tr>
<td>TbD</td>
<td>98.8</td>
<td>94.5</td>
<td>94.3</td>
<td>91.9</td>
<td></td>
</tr>
<tr>
<td>NS-CL</td>
<td>98.9</td>
<td>98.9</td>
<td>98.7</td>
<td>98.8</td>
<td></td>
</tr>
</tbody>
</table>
<p>Figure 5: We test the combinatorial generalization w.r.t. the number of objects in scenes and the complexity of questions (i.e. the depth of the program trees). We makes four split of the data containing various complexities of scenes and questions. Our object-based visual representation and explicit program semantics enjoys the best (and almost-perfect) combinatorial generalization compared with strong baselines.
<img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 6: Samples collected from four splits in Section 4.3 for illustration. Models are trained on split A but evaluated on all splits for testing the combinatorial generalization.</p>
<p>Generalizing to new visual concepts. We expect the process of concept learning can take place in an incremental manner: having learned 7 different colors, humans can learn the 8 -th color incrementally and efficiently. To this end, we build a synthetic split of the CLEVR dataset to replicate the setting of incremental concept learning. Split A contains only images without any purple objects, while split B contains images with at least one purple object. We train all the models on split A first, and finetune them on 100 images from split B. We report the final QA performance on split B's validation set. All models use a pre-trained semantic parser on the full CLEVR dataset.</p>
<p>Our model performs a $93.9 \%$ accuracy on the QA test in Split B, outperforming the convolutional baseline IEP (Johnson et al., 2017b) and the attentional baseline TbD (Mascharka et al., 2018) by $4.6 \%$ and $6.1 \%$ respectively. The acquisition of Color operator brings more efficient learning of new visual concepts.</p>
<h1>4.4 COMBINATORIAL GENERALIZATION TO NEW SCENES AND QUESTIONS</h1>
<p>Having learned visual concepts on small-scale scenes (containing only few objects) and simple questions (only single-hop questions), we humans can easily generalize the knowledge to larger-scale scenes and to answer complex questions. To evaluate this, we split the CLEVR dataset into four parts: Split A contains only scenes with less than 6 objects, and questions whose latent programs having a depth less than 5; Split B contains scenes with less than 6 objects, but arbitrary questions; Split C contains arbitrary scenes, but restricts the program depth being less than 5; Split D contains arbitrary scenes and questions. Figure 6 shows some illustrative samples.</p>
<p>As VQA baselines are unable to count a set of objects of arbitrary size, for a fair comparison, all programs containing the "count" operation over $&gt;6$ objects are removed from the set. For</p>
<p><img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>Caption: There is a big yellow cylinder in front of a gray object.
(a) An illustrative pair of image and caption in our synthetic dataset.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: center;">Retrieval Accuracy</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">IEP</td>
<td style="text-align: center;">95.5</td>
</tr>
<tr>
<td style="text-align: left;">TbD</td>
<td style="text-align: center;">$\mathbf{9 7 . 0}$</td>
</tr>
<tr>
<td style="text-align: left;">NS-CL</td>
<td style="text-align: center;">96.9</td>
</tr>
</tbody>
</table>
<p>(b) Image-caption retrieval accuracy on a subset of data. Our model archives comparable results with VQA baselines.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: center;">Retrieval Accuracy</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">CNN-LSTM</td>
<td style="text-align: center;">68.9</td>
</tr>
<tr>
<td style="text-align: left;">NS-CL</td>
<td style="text-align: center;">$\mathbf{9 7 . 0}$</td>
</tr>
</tbody>
</table>
<p>(c) Image-caption retrieval accuracy on the full dataset. Our model outperforms baselines and requires no extra training or fine-tuning of the visual perception module.</p>
<p>Table 5: We introduce a new simple DSL for image-caption retrieval to evaluate how well the learned visual concepts transfer. Due to the difference between VQA and caption retrieval, VQA baselines are only able to infer the result on a partial set of data. The learned object-based visual concepts can be directly transferred into the new domain for free.
methods using explicit program semantics, the semantic parser is pre-trained on the full dataset and fixed. Methods with implicit program semantics (Hudson \&amp; Manning, 2018) learn an entangled representation for perception and reasoning, and cannot trivially generalize to more complex programs. We only use the training data from the Split A and then quantify the generalization ability on other three splits. Shown in Table 5, our NS-CL leads to almost-perfect generalization to larger scenes and more complex questions, outperforming all baselines by at least $4 \%$ in QA accuracy.</p>
<h1>4.5 EXTENDING TO OTHER PROGRAM DOMAIN</h1>
<p>The learned visual concepts can also be used in other domains such as image retrieval. With the visual scenes fixed, the learned visual concepts can be directly transferred into the new domain. We only need to learn the semantic parsing of natural language into the new DSL.</p>
<p>We build a synthetic dataset for image retrieval and adopt a DSL from scene graph-based image retrieval (Johnson et al., 2015). The dataset contains only simple captions: "There is an $&lt;$ object A $&gt;$ $&lt;$ relation $&gt;&lt;$ object B $&gt;$." (e.g., There is a box right of a cylinder). The semantic parser learns to extract corresponding visual concepts (e.g., box, right, and cylinder) from the sentence. The program can then be executed on the visual representation to determine if the visual scene contains such relational triples.</p>
<p>For simplicity, we treat retrieval as classifying whether a relational triple exists in the image. This functionality cannot be directly implemented on the CLEVR VQA program domain, because questions such as "Is there a box right of a cylinder" can be ambiguous if there exist multiple cylinders in the scene. Due to the entanglement of the visual representation with the specific DSL, baselines trained on CLEVR QA can not be directly applied to this task. For a fair comparison with them, we show the result in Table 5b on a subset of the generated image-caption pairs where the underlying programs have no ambiguity regarding the reference of object B. A separate semantic parser is trained for the VQA baselines, which translates captions into a CLEVR QA-compatible program (e.g., Exist (Filter(Box, Relate(Right, Filter(Cylinder))).</p>
<p>Table 5c compares our NS-CL against typical image-text retrieval baselines on the full image-caption dataset. Without any annotations of the sentence semantics, our model learns to parse the captions into the programs in the new DSL. It outperforms the CNN-LSTM baseline by $30 \%$.</p>
<h3>4.6 EXTENDING TO NATURAL IMAGES AND LANGUAGE</h3>
<p>We further conduct experiments on MS-COCO (Lin et al., 2014) images. Results are presented on the VQS dataset (Gan et al., 2017). VQS contains a subset of images and questions from the original VQA 1.0 dataset (Antol et al., 2015). All questions in the VQS dataset can be visually grounded: each question is associated with multiple image regions, annotated by humans as essential for answering the question. Figure 7 illustrates an execution trace of NS-CL on VQS.</p>
<p>We use a syntactic dependency parser to extract programs and concepts from language (Andreas et al., 2016; Schuster et al., 2015). The object proposals and features are extracted from models pre-trained on the MS-COCO dataset and the ImageNet dataset, respectively. Illustrated in Figure 7, our model</p>
<p><img alt="img-6.jpeg" src="img-6.jpeg" /></p>
<p>Figure 7: Left: An example image-question pair from the VQS dataset and the corresponding execution trace of NS-CL. Right: Results on the VQS test set. Our model achieves a comparable results with the baselines.
<img alt="img-7.jpeg" src="img-7.jpeg" /></p>
<p>Figure 8: Concepts learned from VQS, including object categories, attributes, and relations.
shows competitive performance on QA accuracy, comparable with the MLP baseline (Jabri et al., 2016) and the MAC network (Hudson \&amp; Manning, 2018). Additional illustrative execution traces of NS-CL are in Appendix H. Beyond answering questions, NS-CL effectively learns visual concepts from data. Figure 8 shows examples of the learned visual concepts, including object categories, attributes, and relations. Experiment setup and implementation details are in Appendix G.2.</p>
<p>In this paper, we focus on a neuro-symbolic framework that learns visual concepts about object properties and relations. Indeed, visual question answering requires AI systems to reason about more general concepts such as events or activities (Levin, 1993). We leave the extension of NS-CL along this direction and its application to general VQA datasets (Antol et al., 2015) as future work.</p>
<h1>5 Discussion and Future Work</h1>
<p>We presented a method that jointly learns visual concepts, words, and semantic parsing of sentences from natural supervision. The proposed framework, NS-CL, learns by looking at images and reading paired questions and answers, without any explicit supervision such as class labels for objects. Our model learns visual concepts with remarkable accuracy. Based upon the learned concepts, our model achieves good results on question answering, and more importantly, generalizes well to new visual compositions, new visual concepts, and new domain specific languages.
The design of NS-CL suggests multiple research directions. First, constructing 3D object-based representations for realistic scenes needs further exploration (Anderson et al., 2018; Baradel et al., 2018). Second, our model assumes a domain-specific language for describing formal semantics. The integration of formal semantics into the processing of complex natural language would be meaningful future work (Artzi \&amp; Zettlemoyer, 2013; Oh et al., 2017). We hope our paper could motivate future research in visual concept learning, language learning, and compositionality.</p>
<p>Our framework can also be extended to other domains such as video understanding and robotic manipulation. Here, we would need to discover semantic representations for actions and interactions (e.g., push) beyond static spatial relations. Along this direction, researchers have studied building symbolic representations for skills (Konidaris et al., 2018) and learning instruction semantics from interaction (Oh et al., 2017) in constrained setups. Applying neuro-symbolic learning frameworks for concepts and skills would be meaningful future work toward robotic learning in complex interactive environments.</p>
<p>Acknowledgements. We thank Kexin Yi, Haoyue Shi, and Jon Gauthier for helpful discussions and suggestions. This work was supported in part by the Center for Brains, Minds and Machines (NSF STC award CCF-1231216), ONR MURI N00014-16-1-2007, MIT-IBM Watson AI Lab, and Facebook.</p>
<h1>REFERENCES</h1>
<p>Omri Abend, Tom Kwiatkowski, Nathaniel J Smith, Sharon Goldwater, and Mark Steedman. Bootstrapping language acquisition. Cognition, 2017.</p>
<p>Peter Anderson, Xiaodong He, Chris Buehler, Damien Teney, Mark Johnson, Stephen Gould, and Lei Zhang. Bottom-up and top-down attention for image captioning and visual question answering. In CVPR, 2018.</p>
<p>Jacob Andreas, Marcus Rohrbach, Trevor Darrell, and Dan Klein. Learning to compose neural networks for question answering. In NAACL-HLT, 2016.</p>
<p>Stanislaw Antol, Aishwarya Agrawal, Jiasen Lu, Margaret Mitchell, Dhruv Batra, C Lawrence Zitnick, and Devi Parikh. VQA: Visual question answering. In ICCV, 2015.</p>
<p>Yoav Artzi and Luke Zettlemoyer. Weakly supervised learning of semantic parsers for mapping instructions to actions. TACL, 2013.</p>
<p>Fabien Baradel, Natalia Neverova, Christian Wolf, Julien Mille, and Greg Mori. Object level visual reasoning in videos. In ECCV, 2018.</p>
<p>Kan Chen, Jiang Wang, Liang-Chieh Chen, Haoyuan Gao, Wei Xu, and Ram Nevatia. Abc-cnn: An attention based convolutional neural network for visual question answering. arXiv:1511.05960, 2015.</p>
<p>Kyunghyun Cho, Bart Van Merriënboer, Caglar Gulcehre, Dzmitry Bahdanau, Fethi Bougares, Holger Schwenk, and Yoshua Bengio. Learning phrase representations using rnn encoder-decoder for statistical machine translation. In EMNLP, 2014.</p>
<p>Grzegorz Chrupała, Akos Kádár, and Afra Alishahi. Learning language through pictures. In ACL, 2015.</p>
<p>Jia Deng, Wei Dong, Richard Socher, Li-Jia Li, Kai Li, and Li Fei-Fei. Imagenet: A large-scale hierarchical image database. In CVPR, 2009.</p>
<p>Jeffrey Donahue, Lisa Anne Hendricks, Sergio Guadarrama, Marcus Rohrbach, Subhashini Venugopalan, Kate Saenko, and Trevor Darrell. Long-term recurrent convolutional networks for visual recognition and description. In CVPR, 2015.</p>
<p>Li Dong and Mirella Lapata. Language to logical form with neural attention. In ACL, 2016.
Afsaneh Fazly, Afra Alishahi, and Suzanne Stevenson. A probabilistic computational model of cross-situational word learning. Cognit. Sci., 2010.</p>
<p>Chuang Gan, Yandong Li, Haoxiang Li, Chen Sun, and Boqing Gong. VQS: Linking segmentations to questions and answers for supervised attention in vqa and question-focused semantic segmentation. In ICCV, 2017.</p>
<p>Siddha Ganju, Olga Russakovsky, and Abhinav Gupta. What's in a question: Using visual questions as a form of supervision. In CVPR, 2017.</p>
<p>Jon Gauthier, Roger Levy, and Joshua B Tenenbaum. Word learning and the acquisition of syntacticsemantic overhypotheses. In $\operatorname{CogSci}, 2018$.</p>
<p>Jonas Gehring, Michael Auli, David Grangier, Denis Yarats, and Yann N Dauphin. Convolutional sequence to sequence learning. In ICML, 2017.</p>
<p>Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition. In CVPR, 2015.</p>
<p>Kaiming He, Georgia Gkioxari, Piotr Dollár, and Ross Girshick. Mask R-CNN. In ICCV, 2017.
Irina Higgins, Nicolas Sonnerat, Loic Matthey, Arka Pal, Christopher P Burgess, Matthew Botvinick, Demis Hassabis, and Alexander Lerchner. Scan: learning abstract hierarchical compositional visual concepts. In $I C L R, 2018$.</p>
<p>Ronghang Hu, Jacob Andreas, Trevor Darrell, and Kate Saenko. Explainable neural computation via stack neural module networks. In ECCV, 2018.</p>
<p>Drew A Hudson and Christopher D Manning. Compositional attention networks for machine reasoning. In $I C L R, 2018$.</p>
<p>Allan Jabri, Armand Joulin, and Laurens van der Maaten. Revisiting visual question answering baselines. In ECCV, 2016.</p>
<p>Justin Johnson, Ranjay Krishna, Michael Stark, Li-Jia Li, David Shamma, Michael Bernstein, and Li Fei-Fei. Image retrieval using scene graphs. In CVPR, 2015.</p>
<p>Justin Johnson, Andrej Karpathy, and Li Fei-Fei. DenseCap: Fully convolutional localization networks for dense captioning. In CVPR, 2016.</p>
<p>Justin Johnson, Bharath Hariharan, Laurens van der Maaten, Li Fei-Fei, C Lawrence Zitnick, and Ross Girshick. CLEVR: A diagnostic dataset for compositional language and elementary visual reasoning. In CVPR, 2017a.</p>
<p>Justin Johnson, Bharath Hariharan, Laurens van der Maaten, Judy Hoffman, Li Fei-Fei, C Lawrence Zitnick, and Ross Girshick. Inferring and executing programs for visual reasoning. In ICCV, 2017b.</p>
<p>Ryan Kiros, Ruslan Salakhutdinov, and Richard S Zemel. Unifying visual-semantic embeddings with multimodal neural language models. arXiv:1411.2539, 2014.</p>
<p>George Konidaris, Leslie Pack Kaelbling, and Tomas Lozano-Perez. From skills to symbols: Learning symbolic representations for abstract high-level planning. JAIR, 2018.</p>
<p>Tejas D Kulkarni, William F Whitney, Pushmeet Kohli, and Josh Tenenbaum. Deep convolutional inverse graphics network. In NeurIPS, 2015.</p>
<p>Beth Levin. English verb classes and alternations, volume 1. University of Chicago Press, 1993.
Tsung-Yi Lin, Michael Maire, Serge Belongie, James Hays, Pietro Perona, Deva Ramanan, Piotr Dollár, and C Lawrence Zitnick. Microsoft coco: Common objects in context. In ECCV, 2014.</p>
<p>M Malinowski and M Fritz. A multi-world approach to question answering about real-world scenes based on uncertain input. In NeurIPS, 2014.</p>
<p>Junhua Mao, Jiajing Xu, Kevin Jing, and Alan L Yuille. Training and evaluating multimodal word embeddings with large-scale web annotated images. In NeurIPS, 2016.</p>
<p>David Mascharka, Philip Tran, Ryan Soklaski, and Arjun Majumdar. Transparency by design: Closing the gap between performance and interpretability in visual reasoning. In CVPR, 2018.</p>
<p>Junhyuk Oh, Satinder Singh, Honglak Lee, and Pushmeet Kohli. Zero-shot task generalization with multi-task deep reinforcement learning. In ICML, 2017.</p>
<p>Jeffrey Pennington, Richard Socher, and Christopher Manning. Glove: Global vectors for word representation. In EMNLP, 2014.</p>
<p>Ethan Perez, Florian Strub, Harm De Vries, Vincent Dumoulin, and Aaron Courville. Film: Visual reasoning with a general conditioning layer. In AAAI, 2018.</p>
<p>Adam Santoro, David Raposo, David GT Barrett, Mateusz Malinowski, Razvan Pascanu, Peter Battaglia, and Timothy Lillicrap. A simple neural network module for relational reasoning. In NeurIPS, 2017.</p>
<p>Sebastian Schuster, Ranjay Krishna, Angel Chang, Li Fei-Fei, and Christopher D Manning. Generating semantically precise scene graphs from textual descriptions for improved image retrieval. In EMNLP Workshop, 2015.</p>
<p>Haoyue Shi, Jiayuan Mao, Tete Xiao, Yuning Jiang, and Jian Sun. Learning visually-grounded semantics from contrastive adversarial samples. In COLING, 2018.</p>
<p>N Siddharth, T. B. Paige, J.W. Meent, A. Desmaison, N. Goodman, P. Kohli, F. Wood, and P. Torr. Learning disentangled representations with semi-supervised deep generative models. In NeurIPS, 2017.</p>
<p>Joseph Suarez, Justin Johnson, and Fei-Fei Li. DDRprog: A clevr differentiable dynamic reasoning programmer. arXiv:1803.11361, 2018.</p>
<p>Richard S Sutton, David A McAllester, Satinder P Singh, and Yishay Mansour. Policy gradient methods for reinforcement learning with function approximation. In NeurIPS, 2000.</p>
<p>Ivan Vendrov, Ryan Kiros, Sanja Fidler, and Raquel Urtasun. Order-embeddings of images and language. In $I C L R, 2016$.</p>
<p>Ronald J Williams. Simple statistical gradient-following algorithms for connectionist reinforcement learning. $M L J, 8(3-4): 229-256,1992$.</p>
<p>Jiajun Wu, Joshua B Tenenbaum, and Pushmeet Kohli. Neural scene de-rendering. In CVPR, 2017.
Huijuan Xu and Kate Saenko. Ask, attend and answer: Exploring question-guided spatial attention for visual question answering. In ECCV, 2016.</p>
<p>Jimei Yang, Scott E Reed, Ming-Hsuan Yang, and Honglak Lee. Weakly-supervised disentangling with recurrent transformations for 3d view synthesis. In NeurIPS, 2015.</p>
<p>Zichao Yang, Xiaodong He, Jianfeng Gao, Li Deng, and Alex Smola. Stacked attention networks for image question answering. In CVPR, 2016.</p>
<p>Kexin Yi, Jiajun Wu, Chuang Gan, Antonio Torralba, Pushmeet Kohli, and Joshua B Tenenbaum. Neural-Symbolic VQA: Disentangling reasoning from vision and language understanding. In NeurIPS, 2018.</p>
<p>Yukun Zhu, Ryan Kiros, Rich Zemel, Ruslan Salakhutdinov, Raquel Urtasun, Antonio Torralba, and Sanja Fidler. Aligning books and movies: Towards story-like visual explanations by watching movies and reading books. In CVPR, 2015.</p>
<h1>A CLEVR DOMAIN-SPECIFIC LANGUAGE AND IMPLEMENTATIONS</h1>
<p>We first introduce the domain-specific language (DSL) designed for the CLEVR VQA dataset (Johnson et al., 2017a). Table 6 shows the available operations in the DSL, while Table 7 explains the type system.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Operation</th>
<th style="text-align: center;">Signature</th>
<th style="text-align: center;">Semantics</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Scene</td>
<td style="text-align: center;">() $\longrightarrow$ ObjectSet</td>
<td style="text-align: center;">Return all objects in the scene.</td>
</tr>
<tr>
<td style="text-align: center;">Filter</td>
<td style="text-align: center;">(ObjectSet, ObjConcept) $\longrightarrow$ ObjectSet</td>
<td style="text-align: center;">Filter out a set of objects having the object-level concept (e.g., red) from the input object set.</td>
</tr>
<tr>
<td style="text-align: center;">Relate</td>
<td style="text-align: center;">(Object, RelConcept) $\longrightarrow$ ObjectSet</td>
<td style="text-align: center;">Filter out a set of objects that have the relational concept (e.g., left) with the input object.</td>
</tr>
<tr>
<td style="text-align: center;">AERelate</td>
<td style="text-align: center;">(Object, Attribute) $\longrightarrow$ ObjectSet</td>
<td style="text-align: center;">(Attribute-Equality Relate) Filter out a set of objects that have the same attribute value (e.g., same color) as the input object.</td>
</tr>
<tr>
<td style="text-align: center;">Intersection</td>
<td style="text-align: center;">(ObjectSet, ObjectSet) $\longrightarrow$ ObjectSet</td>
<td style="text-align: center;">Return the intersection of two object sets.</td>
</tr>
<tr>
<td style="text-align: center;">Union</td>
<td style="text-align: center;">(ObjectSet, ObjectSet) $\longrightarrow$ ObjectSet</td>
<td style="text-align: center;">Return the union of two object sets.</td>
</tr>
<tr>
<td style="text-align: center;">Query</td>
<td style="text-align: center;">(Object, Attribute) $\longrightarrow$ ObjConcept</td>
<td style="text-align: center;">Query the attribute (e.g., color) of the input object.</td>
</tr>
<tr>
<td style="text-align: center;">AEQuery</td>
<td style="text-align: center;">(Object, Object, Attribute) $\longrightarrow$ Bool</td>
<td style="text-align: center;">(Attribute-Equality Query) Query if two input objects have the same attribute value (e.g., same color).</td>
</tr>
<tr>
<td style="text-align: center;">Exist</td>
<td style="text-align: center;">(ObjectSet) $\longrightarrow$ Bool</td>
<td style="text-align: center;">Query if the set is empty.</td>
</tr>
<tr>
<td style="text-align: center;">Count</td>
<td style="text-align: center;">(ObjectSet) $\longrightarrow$ Integer</td>
<td style="text-align: center;">Query the number of objects in the input set.</td>
</tr>
<tr>
<td style="text-align: center;">CLessThan</td>
<td style="text-align: center;">(ObjectSet, ObjectSet) $\longrightarrow$ Bool</td>
<td style="text-align: center;">(Counting LessThan) Query if the number of objects in the first input set is less than the one of the second set.</td>
</tr>
<tr>
<td style="text-align: center;">CGreaterThan</td>
<td style="text-align: center;">(ObjectSet, ObjectSet) $\longrightarrow$ Bool</td>
<td style="text-align: center;">(Counting GreaterThan) Query if the number of objects in the first input set is greater than the one of the second set.</td>
</tr>
<tr>
<td style="text-align: center;">CEqual</td>
<td style="text-align: center;">(ObjectSet, ObjectSet) $\longrightarrow$ Bool</td>
<td style="text-align: center;">(Counting Equal) Query if the number of objects in the first input set is the same as the one of the second set.</td>
</tr>
</tbody>
</table>
<p>Table 6: All operations in the domain-specific language for CLEVR VQA.</p>
<p>We note that some function takes Object as its input instead of ObjectSet. These functions require the uniqueness of the referral object. For example, to answer the question "What's the color of the red object?", there should be one and only one red object in the scene. During the program execution, the input object set will be implicitly cast to the single object (if the set is non-empty and there is only one object in the set). Such casting is named Unique in related works (Johnson et al., 2017b).</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Example</th>
<th style="text-align: left;">Semantics</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">ObjConcept</td>
<td style="text-align: left;">Red, Cube, etc.</td>
<td style="text-align: left;">Object-level concepts.</td>
</tr>
<tr>
<td style="text-align: left;">Attribute</td>
<td style="text-align: left;">Color, Shape, etc.</td>
<td style="text-align: left;">Object-level attributes.</td>
</tr>
<tr>
<td style="text-align: left;">RelConcept</td>
<td style="text-align: left;">Left, Front, etc.</td>
<td style="text-align: left;">Relational concepts.</td>
</tr>
<tr>
<td style="text-align: left;">Object</td>
<td style="text-align: left;">$\bullet$</td>
<td style="text-align: left;">A single object in the scene.</td>
</tr>
<tr>
<td style="text-align: left;">ObjectSet</td>
<td style="text-align: left;">${\bullet, \bullet}$</td>
<td style="text-align: left;">A set of objects in the scene.</td>
</tr>
<tr>
<td style="text-align: left;">Integer</td>
<td style="text-align: left;">$0,1,2, \cdots$</td>
<td style="text-align: left;">A single integer.</td>
</tr>
<tr>
<td style="text-align: left;">Bool</td>
<td style="text-align: left;">True, False</td>
<td style="text-align: left;">A single boolean value.</td>
</tr>
</tbody>
</table>
<p>Table 7: The type system of the domain-specific language for CLEVR VQA.</p>
<h1>B SEMANTIC PARSING</h1>
<p>As shown in Appendix A, a program can be viewed as a hierarchy of operations which take concepts as their parameters. Thus, NS-CL generates the hierarchies of latent programs in a sequence to tree manner (Dong \&amp; Lapata, 2016). The semantic parser adopts an encoder-decoder architecture, which contains four neural modules: (1) a bidirectional GRU encoder IEncoder (Cho et al., 2014) to encode an input question into a fixed-length embedding, (2) an operation decoder OpDecoder that determines the operation tokens, such as Filter, in the program based on the sentence embedding, (3) a concept decoder ConceptDecoder that selects concepts appeared in the input question as the parameters for certain operations (e.g., Filter takes an object-level concept parameter while Query takes an attribute), and (4) a set of output encoders ${\mathrm{OEncoder}_{i}}$ which encode the decoded operations by OpDecoder and output the latent embedding for decoding the next operation. The operation decoder, the concept decoder, and the output encoders work jointly and recursively to generate the hierarchical program layout. Algorithm 1 illustrates the algorithmic outline of the semantic parser.</p>
<div class="codehilite"><pre><span></span><code><span class="n">Algorithm</span><span class="w"> </span><span class="mi">1</span><span class="err">:</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">String</span><span class="o">-</span><span class="k">to</span><span class="o">-</span><span class="n">Tree</span><span class="w"> </span><span class="n">Semantic</span><span class="w"> </span><span class="n">Parser</span><span class="p">.</span>
<span class="k">Function</span><span class="w"> </span><span class="nf">parse</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nf">left</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="err">\</span><span class="nf">left</span><span class="err">\{</span><span class="n">c_</span><span class="err">{</span><span class="n">i</span><span class="err">}\</span><span class="nf">right</span><span class="err">\}\</span><span class="nf">right</span><span class="p">)</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="err">:</span>
<span class="w">    </span><span class="n">program</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">leftarrow</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="n">EmptyProgram</span><span class="p">(</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">program</span><span class="p">.</span><span class="n">op</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">leftarrow</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="n">OpDecoder</span><span class="w"> </span><span class="err">\</span><span class="p">((</span><span class="n">f</span><span class="p">)</span><span class="err">\</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">program</span><span class="p">.</span><span class="n">op</span><span class="w"> </span><span class="n">requires</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">concept</span><span class="w"> </span><span class="k">parameter</span><span class="w"> </span><span class="k">then</span>
<span class="w">        </span><span class="n">program</span><span class="p">.</span><span class="n">concept</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">leftarrow</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="n">ConceptDecoder</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nf">left</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="err">\</span><span class="nf">left</span><span class="err">\{</span><span class="n">c_</span><span class="err">{</span><span class="n">i</span><span class="err">}\</span><span class="nf">right</span><span class="err">\}\</span><span class="nf">right</span><span class="p">)</span><span class="err">\</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="n">cdots</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">non</span><span class="o">-</span><span class="n">concept</span><span class="w"> </span><span class="n">inputs</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">program</span><span class="p">.</span><span class="n">op</span><span class="w"> </span><span class="n">do</span>
<span class="w">        </span><span class="n">program</span><span class="p">.</span><span class="k">input</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="err">\</span><span class="n">leftarrow</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nf">parse</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">OEncoder</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">_</span><span class="err">{</span><span class="n">i</span><span class="err">}</span><span class="p">(</span><span class="n">f</span><span class="err">\</span><span class="p">),</span><span class="w"> </span><span class="n">program</span><span class="p">.</span><span class="n">op</span><span class="w"> </span><span class="err">\</span><span class="p">(),</span><span class="err">\</span><span class="nf">left</span><span class="err">\{</span><span class="n">c_</span><span class="err">{</span><span class="n">i</span><span class="err">}\</span><span class="nf">right</span><span class="err">\}\</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">program</span>
</code></pre></div>

<p>The function parse takes two inputs: the current decoding state $f$ and all concepts appeared in the question, as a set $\left{c_{i}\right}$. The parsing procedure begins with encoding the input question by IEncoder as $f_{0}$, extracting the concept set $\left{c_{i}\right}$ from the input question, and invoking parse $\left(f_{0},\left{c_{i}\right}\right)$.
The concept set $\left{c_{i}\right}$ is extracted using hand-coded rules. We assume that each concept (including object-level concepts, relational concepts, and attributes) is associated with a single word in the question. For example, the word "red" is associated with the object-level concept Red, while the word "shape" is associated with the attribute Shape. Informally, we call these words concept words. For a given question $Q$, the corresponding concept set $\left{c_{i}\right}$ is composed of all occurrences of the concept words in $Q$. The set of concept words is known for the CLEVR dataset. For natural language questions, one could run POS tagging to find all concept words (Andreas et al., 2016; Schuster et al., 2015). We leave the automatic discovery of concept words as a future work (Gauthier et al., 2018). We use the word embedding of the concept words as the representation for the concepts $\left{c_{i}\right}$. Note that, these "concept embeddings" are only for the program parsing. The visual module has separate concept embeddings for aligning object features with concepts in the visual-semantic space.</p>
<p>We now delve into the main function $\operatorname{parse}\left(f,\left{c_{i}\right}\right)$ : we first decode the root operation $o p$ of the hierarchy by $\operatorname{OpDecoder}(f)$. If $o p$ requires a concept parameter (an object-level concept, a relational concept, or an attribute), ConceptDecoder will be invoked to choose a concept from all concepts $\left{c_{i}\right}$. Assuming $o p$ takes two non-concept inputs (e.g., the operation Intersection takes two object sets as its input), there will be two branches for this root node. Thus, two output encoders OEncoder ${ }<em 1="1">{0}$ and OEncoder ${ }</em>$ to generate the two branches respectively. In the DSL, the number of non-concept inputs for any operation is at most 2.}$ will be applied to transform the current state $f$ into two sub-states $f_{1}$ and $f_{2}$. parse will be recursively invoked based on $f_{1}$ and $f_{2</p>
<p>In our implementation, the input encoder IEncoder first maps each word in the question into an embedding space. The word embeddings are composed of two parts: a randomly initialized word embedding of dimension 256 and a positional embedding of dimension 128 (Gehring et al., 2017). For a concept word, its word embedding only depends on which type it belongs to (i.e. object-level, relational or attribute). Thus, after being trained on a fixed dataset, the semantic parser can parse questions with novel (unseen) concept words. The sequence of word embeddings is then encoded by a two-layer GRU with a hidden dimension of $256 * 2$ (bidirectional). The function parse starts from the last hidden state of the GRU, and works recursively to generate the hierarchical program layout. Both OpDecoder and ConceptDecoder are feed-forward networks. ConceptDecoder performs attentions over the representations of all concepts $\left{c_{i}\right}$ to select the concepts. Output encoders OEncoder ${ }<em 1="1">{0}$ and OEncoder ${ }</em>$ are implemented as GRU cells.</p>
<p>Another pre-processing of the sentence is to group consecutive object-level concept words into a group and treat them together as a single concept, inspired by the notion of "noun phrases" in natural languages. The computational intuition behind this grouping is that, the latent programs of CLEVR questions usually contain multiple consecutive Filter tokens. During the program parsing and execution, we aim to fuse all such Filters into a single Filter operation that takes multiple concepts as its parameter.</p>
<p>A Running Example As a running example, consider again the question "What is the color of the cube right of the red matte object?". We first process the sentence (by rules) as: "What is the $&lt;$ Attribute 1 (color) $&gt;$ of the $&lt;$ (ObjConcept 1 (cube) $&gt;&lt;$ RelConcept 1 (right) $&gt;$ of the $&lt;$ ObjConcept 2 (red matte object) $&gt;$ ?". The expected parsing result of this sentence is:</p>
<div class="codehilite"><pre><span></span><code>Query(&lt;Attribute 1&gt;,
    Filter(&lt;ObjConcept 1&gt;,
        Relate(&lt;RelConcept 1&gt;,
            Filter(&lt;ObjConcept 2&gt;, Scene)
        )
    )
).
</code></pre></div>

<p>The semantic parser encode the word embeddings with IEncoder. The last hidden state of the GRU will be used as $f_{0}$. The word embeddings of the concept words form the set $\left{c_{i}\right}=$ {Attribute 1, ObjConcept 1, RelConcept 1, ObjConcept 2}. The function parse is then invoked recursively to generate the hierarchical program layout. Table 8 illustrates the decoding process step-by-step.</p>
<h1>C Program Execution</h1>
<p>In this section, we present the implementation of all operations listed in Table 6. We start from the implementation of Object-typed and ObjectSet-typed variables. Next, we discuss how to classify objects by object-level concepts or relational concept, followed by the implementation details of all operations.</p>
<p>Object-typed and ObjectSet-typed variables. We consider a scene with $n$ objects. An Objecttyped variable can be represented as a vector Object of length $n$, where $\operatorname{Object}<em i="i">{i} \in[0,1]$ and $\sum</em>} \operatorname{Object<em i="i">{i}=1$. Object $</em>}$ can be interpreted as the probability that the $i$-th object of the scene is being referred to. Similarly, an ObjectSet-typed variable can be represented as a vector ObjectSet of length $n$, where ObjectSet ${ <em i="i">{i} \in[0,1]$. ObjectSet ${ }</em>$ can be interpreted as the probability that the $i$-the object is in the set. To cast an ObjectSet-typed variable ObjectSet as an Object-typed variable</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Step</th>
<th style="text-align: center;">Inputs</th>
<th style="text-align: center;">Outputs</th>
<th style="text-align: center;">Recursive Invocation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">$f_{0}$</td>
<td style="text-align: center;">$\begin{aligned} &amp; \text { OpDecoder }\left(f_{0}\right) \rightarrow \text { Query; } \ &amp; \text { ConceptDecoder }\left(f_{0}\right) \rightarrow&lt;\text { Attribute } 1&gt;; \ &amp; \text { OEncoder }<em 0="0">{0}\left(f</em>$}, \text { Query }\right) \rightarrow f_{1} \end{aligned</td>
<td style="text-align: center;">$\operatorname{parse}\left(f_{1}\right)$</td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;">$f_{1}$</td>
<td style="text-align: center;">$\begin{aligned} &amp; \text { OpDecoder }\left(f_{1}\right) \rightarrow \text { Filter; } \ &amp; \text { ConceptDecoder }\left(f_{1}\right) \rightarrow&lt;\text { ObjConcept } 1&gt;; \ &amp; \text { OEncoder }<em 1="1">{0}\left(f</em>$}, \text { Filter }\right) \rightarrow f_{2} \end{aligned</td>
<td style="text-align: center;">$\operatorname{parse}\left(f_{2}\right)$</td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: center;">$f_{2}$</td>
<td style="text-align: center;">$\begin{aligned} &amp; \text { OpDecoder }\left(f_{2}\right) \rightarrow \text { Relate; } \ &amp; \text { ConceptDecoder }\left(f_{2}\right) \rightarrow&lt;\text { RelConcept } 1&gt;; \ &amp; \text { OEncoder }<em 2="2">{0}\left(f</em>$}, \text { Relate }\right) \rightarrow f_{3} \end{aligned</td>
<td style="text-align: center;">$\operatorname{parse}\left(f_{3}\right)$</td>
</tr>
<tr>
<td style="text-align: center;">4</td>
<td style="text-align: center;">$f_{3}$</td>
<td style="text-align: center;">$\begin{aligned} &amp; \text { OpDecoder }\left(f_{3}\right) \rightarrow \text { Filter; } \ &amp; \text { ConceptDecoder }\left(f_{3}\right) \rightarrow&lt;\text { ObjConcept } 2&gt;; \ &amp; \text { OEncoder }<em 3="3">{0}\left(f</em>$}, \text { Filter }\right) \rightarrow f_{4} \end{aligned</td>
<td style="text-align: center;">$\operatorname{parse}\left(f_{4}\right)$</td>
</tr>
<tr>
<td style="text-align: center;">5</td>
<td style="text-align: center;">$f_{4}$</td>
<td style="text-align: center;">OpDecoder $\left(f_{3}\right) \rightarrow$ Scene;</td>
<td style="text-align: center;">(End of branch.)</td>
</tr>
</tbody>
</table>
<p>Table 8: A step-by-step running example of the recursive parsing procedure. The parameter $\left{c_{i}\right}$ is omitted for better visualization.</p>
<p>Object (i.e., the Unique operation), we compute: Object $=\operatorname{softmax}\left(\sigma^{-1}(\right.$ ObjectSet $\left.)\right)$, where $\sigma^{-1}(x)=\log (x /(1-x))$ is the logit function.</p>
<p>Concept quantization. Denote $o_{i}$ as the visual representation of the $i$-th object, $O C$ the set of all object-level concepts, and $A$ the set of all object-level attributes. Each object-level concept $o c$ (e.g., Red) is associated with a vector embedding $v^{o c}$ and a L1-normalized vector $b^{o c}$ of length $|A| . b^{o c}$ represents which attribute does this object-level concept belong to (e.g., the concept Red belongs to the attribute Color). All attributes $a \in A$ are implemented as neural operators, denoted as $u^{a}$ (e.g., $u^{\text {Color }}$ ). To classify the objects as being Red or not, we compute:</p>
<p>$$
\operatorname{Pr}[\text { object } i \text { is Red }]=\sigma\left(\sum_{a \in A}\left(b_{i j}^{\text {Red }} \cdot \frac{\left\langle u^{a}\left(o_{i}\right), v_{\text {Red }}\right\rangle-\gamma}{\tau}\right)\right)
$$</p>
<p>where $\sigma$ denotes the Sigmoid function, $\langle\cdot, \cdot\rangle$ the cosine distance between two vectors. $\gamma$ and $\tau$ are scalar constants for scaling and shifting the values of similarities. By applying this classifier on all objects we will obtain a vector of length $n$, denoted as $\operatorname{ObjClassify}($ Red $)$. Similarly, such classification can be done for relational concepts such as Left. This will result in an $n \times n$ matrix RelClassify (Left), where RelClassify (Left) $)_{j, i}$ is the probability that the object $i$ is left of the object $j$.</p>
<p>To classify whether two objects have the same attribute (e.g., have the same Color), we compute:</p>
<p>$$
\operatorname{Pr}[\text { object } i \text { has the same Color as object } j]=\sigma\left(\frac{\left\langle u^{\text {Color }}\left(o_{i}\right), u^{\text {Color }}\left(o_{j}\right)\right\rangle-\gamma}{\tau}\right)
$$</p>
<p>We can obtain a matrix AEClassify (Color) by applying this classifier on all pairs of objects, where AEClassifier $(\mathrm{Color})_{j, i}$ is the probability that the object $i$ and $j$ have the same Color.</p>
<p>Quasi-symbolic program execution. Finally, Table 9 summarizes the implementation of all operators. In practice, all probabilities are stored in the log space for better numeric stability.</p>
<h1>D OPTIMIZATION OF THE SEMANTIC PARSER</h1>
<p>To tackle the optimization in a non-smooth program space, we apply an off-policy program search process (Sutton et al., 2000) to facilitate the learning of the semantic parser. Denote $\mathbb{P}(s)$ as the set of all valid programs in the CLEVR DSL for the input question $s$. We want to compute the gradient w.r.t. $\Theta_{s}$, the parameters of the semantic parser:</p>
<p>$$
\nabla_{\Theta_{s}}=\nabla_{\Theta_{s}} \mathbb{E}_{P}[r \cdot \log \operatorname{Pr}[P]]
$$</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Signature</th>
<th style="text-align: center;">Implementation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Scene() $\rightarrow$ out: ObjectSet</td>
<td style="text-align: center;">out $_{i}:=1$</td>
</tr>
<tr>
<td style="text-align: center;">Filter(in: ObjectSet, oc: ObjConcept) $\rightarrow$ out: ObjectSet</td>
<td style="text-align: center;">$o u t_{i}:=\min \left(i n_{i}, \operatorname{ObjClassify}(o c)_{i}\right)$</td>
</tr>
<tr>
<td style="text-align: center;">Relate(in: Object, $r c$ : RelConcept) $\rightarrow$ out: ObjectSet</td>
<td style="text-align: center;">$o u t_{i}:=\sum_{j}\left(i n_{j} \cdot \operatorname{RelClassify}(r c)_{j, i}\right)$ )</td>
</tr>
<tr>
<td style="text-align: center;">AERelate(in: Object, $a$ : Attribute) $\rightarrow$ out: ObjectSet</td>
<td style="text-align: center;">$o u t_{i}:=\sum_{j}\left(i n_{j} \cdot \operatorname{AEClassify}(a)_{j, i}\right)$ )</td>
</tr>
<tr>
<td style="text-align: center;">Intersection $\left(i n^{(1)}\right.$ : ObjectSet, in ${ }^{(2)}$ : ObjectSet) $\rightarrow$ out: ObjectSet</td>
<td style="text-align: center;">$o u t_{i}:=\min \left(i n_{i}^{(1)}, i n_{i}^{(2)}\right)$</td>
</tr>
<tr>
<td style="text-align: center;">Union $\left(i n^{(1)}\right.$ : ObjectSet, in ${ }^{(2)}$ : ObjectSet) $\rightarrow$ out: ObjectSet</td>
<td style="text-align: center;">$o u t_{i}:=\max \left(i n_{i}^{(1)}, i n_{i}^{(2)}\right)$</td>
</tr>
<tr>
<td style="text-align: center;">Query(in: Object, $a$ : Attribute) $\rightarrow$ out: ObjConcept</td>
<td style="text-align: center;">$\operatorname{Pr}[o u t=o c]:=\sum_{i} i n_{i} \cdot \frac{\text { ObjClassify }(o c)<em a="a">{i} \cdot b</em>\right)}^{o c}}{\sum_{o c^{\prime}} \text { ObjClassify }\left(o c^{\prime<em a="a">{i} \cdot b</em>$}^{o c^{\prime}}</td>
</tr>
<tr>
<td style="text-align: center;">AEQuery $\left(i n^{(1)}\right.$ : Object, in ${ }^{(2)}$ : Object, $a$ : Attribute) $\rightarrow b$ : Bool</td>
<td style="text-align: center;">$b:=\sum_{i} \sum_{j}\left(i n_{i}^{(1)} \cdot i n_{j}^{(2)} \cdot \operatorname{AEClassify}(a)_{j, i}\right)$ )</td>
</tr>
<tr>
<td style="text-align: center;">Exist(in: ObjectSet) $\rightarrow b$ : Bool</td>
<td style="text-align: center;">$b:=\max <em i="i">{i} i n</em>$</td>
</tr>
<tr>
<td style="text-align: center;">Count(in: ObjectSet) $\rightarrow i$ : Integer</td>
<td style="text-align: center;">$i:=\sum_{i} i n_{i}$</td>
</tr>
<tr>
<td style="text-align: center;">$\operatorname{CLessThan}\left(i n^{(1)}\right.$ : ObjectSet, in ${ }^{(2)}$ : ObjectSet) $\rightarrow b$ : Bool</td>
<td style="text-align: center;">$b:=\sigma\left(\left(\sum_{i} i n_{i}^{(2)}-\sum_{i} i n_{i}^{(1)}-1+\gamma_{c}\right) / \tau_{c}\right)$</td>
</tr>
<tr>
<td style="text-align: center;">CGreaterThan $\left(i n^{(1)}\right.$ : ObjectSet, in ${ }^{(2)}$ : ObjectSet) $\rightarrow b$ : Bool</td>
<td style="text-align: center;">$b:=\sigma\left(\left(\sum_{i} i n_{i}^{(1)}-\sum_{i} i n_{i}^{(2)}-1+\gamma_{c}\right) / \tau_{c}\right)$</td>
</tr>
<tr>
<td style="text-align: center;">CEqual $\left(i n^{(1)}\right.$ : ObjectSet, in ${ }^{(2)}$ : ObjectSet) $\rightarrow b$ : Bool</td>
<td style="text-align: center;">$b:=\sigma\left(\left(-</td>
</tr>
</tbody>
</table>
<p>Table 9: All operations in the domain-specific language for CLEVR VQA. $\gamma_{c}=0.5$ and $\tau_{c}=0.25$ are constants for scaling and shift the probability. During inference, one can quantify all operations as Yi et al. (2018).
where $P \sim$ SemanticParse $\left(s ; \Theta_{s}\right)$. In REINFORCE, we approximate this gradient via Monte Carlo sampling.</p>
<p>An alternative solution is to exactly compute the gradient. Note that in the definition of the reward $r$, only the set of programs $\mathbb{Q}(s)$ leading to the correct answer will contribute to the gradient term. With the perception module fixed, the set $\mathbb{Q}$ can be efficiently determined by an off-policy exhaustive search of all possible programs $\mathbb{P}(s)$. In the third stage of the curriculum learning, we search for the set $\mathbb{Q}$ offline based on the quantified results of concept classification and compute the exact gradient $\nabla \Theta_{s}$. An intuitive explanation of the off-policy search is that, we enumerate all possible programs, execute them on the visual representation, and find the ones leading to the correct answer. We use $\mathbb{Q}(s)$ as the "groundtruth" program annotation for the question, to supervise the learning, instead of running the Monte Carlo sampling-based REINFORCE.</p>
<p>Spurious program suppression. However, directly using $\mathbb{Q}(s)$ as the supervision by computing $\ell=\sum_{p \in \mathbb{Q}(S)}-\log \operatorname{Pr}(p)$ can be problematic, due to the spuriousness or the ambiguity of the programs. This comes from two aspects:</p>
<p>1) intrinsic ambiguity: two programs are different but equivalent. For example</p>
<p>P1: AEQuery(Color,Filter(Cube), Filter(Sphere)) and
P2: Exist(Filter(Sphere,AERelate(Color, Filter(Cube))))
are equivalent.
2) extrinsic spuriousness: one of the program is incorrect, but also leads to the correct answer in a</p>
<p>specific scene. For example,</p>
<p>$$
\begin{aligned}
&amp; \text { P1: Filter(Red, Relate(Left, Filter(Sphere))) and } \
&amp; \text { P2: Filter(Red, Relate(Left, Filter(Cube))) }
\end{aligned}
$$</p>
<p>may refer to the same red object in a specific scene. Motivated by the REINFORCE process, to suppress such spurious programs, we use the loss function:</p>
<p>$$
\ell=\sum_{p \in \mathbb{Q}} \operatorname{stop} \cdot \operatorname{gradient}(\operatorname{Pr}[p]) \cdot(-\log \operatorname{Pr}[p])
$$</p>
<p>The corresponding gradient $\nabla_{\Theta_{s}}$ is,</p>
<p>$$
\nabla_{\Theta_{s}}=\sum_{p \in \mathbb{Q}} \operatorname{Pr}[p] \cdot \nabla_{\Theta_{s}}(r \cdot \log \operatorname{Pr}[P])=\nabla_{\Theta_{s}}\left(\sum_{p \in \mathbb{Q}} r \cdot \operatorname{Pr}[p]\right)
$$</p>
<p>The key observation is that, given a sufficiently large set of scenes, a program can be identified as spurious if there exists at least one scene where the program leads to a wrong answer. As the training goes, spurious programs will get less update due to the sampling importance term $\operatorname{Pr}[p]$ which weights the likelihood maximization term.</p>
<h1>E Curriculum Learning Setup</h1>
<p>During the whole training process, we gradually add more visual concepts and more complex question examples into the model. Summarized in Figure 4(A), in general, the whole training process is split into 3 stages. First, we only use questions from lesson 1 to let the model learn object-level visual concepts. Second, we train the model to parse simple questions and to learn relational concepts. In this step, we freeze the neural operators and concept embeddings of object-level concepts. Third, the model gets trained on the full question set (lesson 3), learning to understand questions of different complexities and various format. For the first several iterations in this step, we freeze the parameters in the perception modules. In addition, during the training of all stages, we gradually increase the number of objects in the scene: from 3 to 10 .</p>
<p>We select questions for each lesson in the curriculum learning by their depth of the latent program layout. For eaxmple, the program "Query(Shape, Filter(Red, Scene))" has the depth of 3, while the program "Query(Shape, Filter(Cube, Relate(Left, Filter(Red, Scene))))" has the depth of 5 . Since we have fused consecutive Filter operations into a single one, the maximum depth of all programs is 9 on the CLEVR dataset. We now present the detailed split of our curriculum learning lessons:</p>
<p>For lesson 1, we use only programs of depth 3. It contains three types of questions: querying an attribute of the object, querying the existence of a certain type of objects, count a certain type of objects, and querying if two objects have the same attribute (e.g., of the same color). These questions are almost about fundamental object-based visual concepts. For each image, we generate 5 questions of lesson 1 .</p>
<p>For lesson 2, we use programs of depth less than 5, containing a number of questions regarding relations, such as querying the attribute of an object that is left of another object. We found that in the original CLEVR dataset, all Relate operations are followed by a Filter operation. This setup degenerates the performance of the learning of relational concepts such as Left. Thus, we add a new question template into the original template set: Count(Relate( $\cdot$, Filter ( $\cdot$, Scene) )) (e.g., "What's the number of objects that are left of the cube?"). For each image, we generate 5 questions of lesson 2 .</p>
<p>For lesson 3, we use the full CLEVR question set.
Curriculum learning is crucial for the learning of our neuro-symbolic concept learner. We found that by removing the curriculum setup w.r.t. the number of object in the scenes, the visual perception module will get stuck at an accuracy that is similar to a random-guess model, even if we only use stage-1 questions. If we remove the curriculum setup w.r.t. the complexity of the programs, the joint training of the visual perception module and the semantic parser can not converge.</p>
<h1>F Ablation Study</h1>
<p>We conduct ablation studies on the accuracy of semantic parsing, the impacts of the ImageNet pretraining of visual perception modules, the data efficiency of our model, and the usage of object-based representations.</p>
<h2>F. 1 SEMANTIC PARSING ACCURACY.</h2>
<p>We evaluate how well our model recovers the underlying programs of questions. Due to the intrinsic equivalence of different programs, we evaluate the accuracy of programs by executing them on the ground-truth annotations of objects. Invalid or ambiguous programs are also considered as incorrect. Our semantic parser archives $&gt;99.9 \%$ QA accuracy on the validation split.</p>
<h2>F. 2 IMPACTS OF THE IMAGENET PRE-TRAINING.</h2>
<p>The only extra supervision of the visual perception module comes from the pre-training of the perception modules on ImageNet (Deng et al., 2009). To quantify the influence of this pre-training, we conduct ablation experiments where we randomly initialize the perception module following He et al. (2015). The classification accuracies of the learned concepts almost remain the same except for Shape. The classification accuracy of Shape drops from 98.7 to 97.5 on the validation set while the overall QA accuracy on the CLEVR dataset drops to 98.2 from 98.9. We speculate that large-scale image recognition dataset can provide prior knowledge of shape.</p>
<h2>F. 3 Data Efficiency and ObJeCt-based Representations</h2>
<p>In this section, we study whether and how the number of training samples and feature representations affect the overall performance of various models on the CLEVR dataset. Specifically, we compare the proposed NS-CL against two strong baselines: TbD (Mascharka et al., 2018) and MAC (Hudson \&amp; Manning, 2018).</p>
<p>Baselines. For comparison, we implement two variants of the baseline models: TbD-Object and MAC-Object. Inspired by Anderson et al. (2018), instead of using a 2D convolutional feature map, TbD-Object and MAC-Object take a stack of object features as inputs, whose shape is $k \times d_{o k j} . k$ is the number of objects in the scene, and $d_{o k j}$ is the feature dimension for a single object. In our experiments, we fix $k=12$ as a constant value. If there are fewer than 12 objects in the scene, we add "null" objects whose features are all-zero vectors.
We extract object features in the same way as NS-CL. Features are extracted from a pre-trained ResNet-34 network before the last residual block for a feature map with high resolution. For each object, its feature is composed of two parts: region-based (by RoI Align) and image-based features. We concatenate them to represent each object. As discussed, the inclusion of the representation of the full scene is essential for the inference of relative attributes such as size or spatial position on the CLEVR domain.</p>
<p>TbD and MAC networks are originally designed to use image-level attention for reasoning. Thus, we implement two more baselines: TbD-Mask and MAC-Mask. Specifically, we replace the original attention module on images with a mask-guided attention. Denotes the union of all object masks as $M$. Before the model applies the attention on the input image, we multiply the original attention map computed by the model with this mask $M$. The multiplication silences the attention on pixels that are not part of any objects.</p>
<p>Results. Table 3 summarizes the results. We found that TbD-Object and MAC-Object approach show inferior results compared with the original model. We attribute this to the design of the network architectures. Take the Relate operation (e.g., finds all objects left of a specific object $x$ ) as an example. TbD uses a stack of dilated convolutional layers to propagate the attention from object $x$ to others. In TbD-Object, we replace the stack of 2D convolutions by several 1D convolution layers, operating over the $k \times d_{o k j}$ object features. This ignores the equivalence of objects (the order of objects should not affect the results). In contrast, MAC networks always use the attention mechanism</p>
<p>to extract information from the image representation. This operation is invariant to the order of objects, but is not suitable for handling quantities (e.g., counting objects).</p>
<p>As for TbD-Mask and MAC-Mask, although the mask-guided attention does not improve the overall performance, we have observed noticeably faster convergence during model training. TbD-Mask and MAC-Mask leverage the prior knowledge of object masks to facilitate the attention. Such prior has also been verified to be effective in the original TbD model: TbD employs an attention regularization during training, which encourages the model to attend to smaller regions.</p>
<p>In general, NS-CL is more data-efficient than MAC networks and TbD. Recall that NS-CL answers questions by executing symbolic programs on the learned visual concepts. Only visual concepts (such as Red and Left) and the interpretation of questions (how to translate questions into executable programs) need to be learned from data. In contrast, both TbD and MAC networks need to additionally learn to execute (implicit or explicit) programs such as counting.</p>
<p>For the experiments on the full CLEVR training set, we split 3,500 images ( $5 \%$ of the training data) as the hold-out validation set to tune the hyperparameters and select the best model. We then apply this model to the CLEVR validation split and report the testing performance. Our model reaches an accuracy of $99.2 \%$ using the CLEVR training set.</p>
<h1>G Extending to Other Scene and Language Domains</h1>
<h2>G. 1 Minecraft Dataset</h2>
<p>We also extend the experiments to a new reasoning testbed: Minecraft worlds (Yi et al., 2018). The Minecraft reasoning dataset differs from CLEVR in both visual appearance and question types. Figure 9 gives an example instance from the dataset.
<img alt="img-8.jpeg" src="img-8.jpeg" /></p>
<p>Q: What direction is the closest creature facing?
A: Left.
P: Query(Direction, FilterMost(Closest,
Filter(Creature)
))</p>
<p>Figure 9: An example image and a related question-answering pair from the Minecraft dataset.</p>
<p>Setup. Following Yi et al. (2018), we generate 10,000 Minecraft scenes using the officially opensourced tools by Wu et al. (2017). Each image contains 3 to 6 objects. The objects are chosen from 12 categories, with 4 different facing directions (front, back, left and right). They stand on a 2D plane.</p>
<p>Besides different 3D visual appearance and image contexts, the Minecraft reasoning dataset introduces two new types of reasoning operations. We add them to our domain-specific language:</p>
<ol>
<li>FilterMost(ObjectSet, Concept) $\rightarrow$ ObjectSet: Given a set of objects, finds the "most" one. For example, FilterMost(Closest, set) locates the object in the input set that is cloest to the camera (e.g., what is the direction of the closest animal?)</li>
<li>BelongTo(Object, ObjectSet) $\rightarrow$ Bool: Query if the input object belongs to a set.</li>
</ol>
<p>Results. Table 10 summarizes the results and Figure 12 shows sample execution traces. We compare our method against the NS-VQA baseline (Yi et al., 2018), which uses strong supervision for both scene representation (e.g., object categories and positions) and program traces. In contrast, our method learns both by looking at images and reading question-answering pairs. NS-CL outperforms NS-VQA by $5 \%$ in overall accuracy. We attribute the inferior results of NS-VQA to its derendering module. Because objects in the Minecraft world usually occlude with each other, the detected object bounding boxes are inevitably noisy. During the training of the derendering module, each detected bounding box is matched with one of the ground-truth bounding boxes and uses its class and pose as supervision. Poorly localized bounding boxes lead to noisy labels and hurt the accuracy of the derendering module. This further influences the overall performance of NS-VQA.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>Project page: http://nscl.csail.mit.edu&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>