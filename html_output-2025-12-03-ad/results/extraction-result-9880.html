<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-9880 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-9880</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-9880</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-168.html">extraction-schema-168</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods, criteria, benchmarks, and results for evaluating LLM-generated scientific theories.</div>
                <p><strong>Paper ID:</strong> paper-1ccd031f28dccfb226f6c0c588c93a97a50bf95f</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/1ccd031f28dccfb226f6c0c588c93a97a50bf95f" target="_blank">Measuring Coding Challenge Competence With APPS</a></p>
                <p><strong>Paper Venue:</strong> NeurIPS Datasets and Benchmarks</p>
                <p><strong>Paper TL;DR:</strong> APPS, a benchmark for code generation, measures the ability of models to take an arbitrary natural language specification and generate satisfactory Python code and finds that the prevalence of syntax errors is decreasing exponentially as models improve.</p>
                <p><strong>Paper Abstract:</strong> While programming is one of the most broadly applicable skills in modern society, modern machine learning models still cannot code solutions to basic problems. Despite its importance, there has been surprisingly little work on evaluating code generation, and it can be difficult to accurately assess code generation performance rigorously. To meet this challenge, we introduce APPS, a benchmark for code generation. Unlike prior work in more restricted settings, our benchmark measures the ability of models to take an arbitrary natural language specification and generate satisfactory Python code. Similar to how companies assess candidate software developers, we then evaluate models by checking their generated code on test cases. Our benchmark includes 10,000 problems, which range from having simple one-line solutions to being substantial algorithmic challenges. We fine-tune large language models on both GitHub and our training set, and we find that the prevalence of syntax errors is decreasing exponentially as models improve. Recent models such as GPT-Neo can pass approximately 20% of the test cases of introductory problems, so we find that machine learning models are now beginning to learn how to code. As the social significance of automatic code generation increases over the coming years, our benchmark can provide an important measure for tracking advancements.</p>
                <p><strong>Cost:</strong> 0.016</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e9880.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e9880.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods, criteria, benchmarks, and results for evaluating LLM-generated scientific theories.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>APPS</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Automated Programming Progress Standard (APPS)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A large benchmark of 10,000 Python programming problems with 131,777 test cases and 232,421 human solutions, designed to evaluate LLMs' ability to generate correct programs from natural-language specifications by executing generated code on problem-specific test cases.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>llm_name</strong></td>
                            <td>GPT-2 (0.1B, 1.5B), GPT-Neo (2.7B), GPT-3 (davinci, 175B), OpenAI Codex (reported by Chen et al.)</td>
                        </tr>
                        <tr>
                            <td><strong>llm_description</strong></td>
                            <td>Various transformer autoregressive LLMs: GPT-2 variants (pretrained on natural language, some variants further pretrained on GitHub code), GPT-Neo 2.7B (pretrained on the Pile which includes GitHub), GPT-3 davinci/instruct (175B, few-shot API, not fine-tuned by authors), and Codex (12B, code-specialized reported in follow-up work).</td>
                        </tr>
                        <tr>
                            <td><strong>scientific_domain</strong></td>
                            <td>Computer science — program synthesis / automated code generation</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_method</strong></td>
                            <td>Automatic execution of generated Python programs on problem-specific test cases (merged judging framework adapted from competitive programming sites); detection of syntax/loading errors (pyext heuristic); aggregate metrics computed across the test set; top-k candidate selection (beam search) for multi-attempt evaluation.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_criteria</strong></td>
                            <td>Functional correctness on test cases (Test Case Average and Strict Accuracy), syntax error frequency, and auxiliary lexical metrics (BLEU/CodeBLEU) for analysis.</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_dataset</strong></td>
                            <td>APPS: 10,000 problems drawn from open coding sites (Codeforces, Kattis, AtCoder, etc.), curated and deduplicated; split into 5,000 train / 5,000 test; average problem length ~293.2 words; per-problem test cases (avg ~21.2), problems categorized into Introductory, Interview, and Competition difficulty levels.</td>
                        </tr>
                        <tr>
                            <td><strong>results_summary</strong></td>
                            <td>Fine-tuned code-capable models (GPT-Neo 2.7B and fine-tuned GPT-2 variants) achieved nonzero functional performance: e.g., GPT-Neo passes ~14.7% of test cases on introductory problems (top-1) and attains ~3.9% strict top-1 accuracy and ~5.5% top-5 strict accuracy on introductory problems; syntax error rates fall sharply with code pretraining/fine-tuning (GPT-3 ~59% syntax errors on introductory problems vs GPT-Neo ~3%). Few-shot GPT-3 (davinci) solved only 3/5,000 test-set problems under the evaluated prompts.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Potential false positives for problems with very few test cases (2–3); lexical metrics (BLEU) do not correlate with functional correctness and can be misleading; models can overfit formatting and produce syntactically malformed but semantically close code; pretraining data contamination must be controlled (authors decontaminated GitHub for GPT-2 experiments); resource costs for large-model inference/training.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_human_or_traditional</strong></td>
                            <td>Evaluation mirrors human grading in programming (running test cases) rather than lexical/translation metrics; benchmark explicitly separates model performance from human experts by requiring functional correctness rather than similarity to human solutions.</td>
                        </tr>
                        <tr>
                            <td><strong>recommendations_or_best_practices</strong></td>
                            <td>Use execution-based test-case evaluation as the gold standard for program synthesis; include many and diverse test cases probing corner cases; measure both test-case-average (partial correctness) and strict accuracy (full correctness); report syntax-error rates; evaluate top-k candidate generations (beam search or sampling) because selecting best-of-k substantially improves measured performance; control for data contamination during pretraining.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Measuring Coding Challenge Competence With APPS', 'publication_date_yy_mm': '2021-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e9880.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e9880.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods, criteria, benchmarks, and results for evaluating LLM-generated scientific theories.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Test Case Average</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Test Case Average (average fraction of test cases passed)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An aggregate metric computed as the mean, over problems, of the fraction of per-problem test cases that a generated program passes; captures partial correctness when solutions handle some but not all cases.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>llm_name</strong></td>
                            <td>GPT-2 (0.1B, 1.5B), GPT-Neo (2.7B), GPT-3 (davinci), Codex (reported)</td>
                        </tr>
                        <tr>
                            <td><strong>llm_description</strong></td>
                            <td>See APPS entry (various transformer LLMs; some fine-tuned on APPS and/or GitHub).</td>
                        </tr>
                        <tr>
                            <td><strong>scientific_domain</strong></td>
                            <td>Computer science — program synthesis / code generation</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_method</strong></td>
                            <td>For each problem p with C_p test cases, compute (1/C_p) sum_c indicator(eval(code_p, x_{p,c}) == y_{p,c}); average across all P problems.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_criteria</strong></td>
                            <td>Average fractional pass rate across test cases (a softer metric than strict all-cases correctness).</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_dataset</strong></td>
                            <td>APPS test set (5,000 problems; avg ~21.2 test cases per problem).</td>
                        </tr>
                        <tr>
                            <td><strong>results_summary</strong></td>
                            <td>Reported test-case-average values by model and difficulty (examples: GPT-Neo 2.7B: Introductory ~14.68% top-1, Interview ~9.85%, Competition ~6.54%, Average ~10.15%; fine-tuning and larger models increase test-case-average).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>May overestimate capability because partial solutions pass some cases but miss corner cases; sensitive to the quality and coverage of test-case bank; does not require full functional correctness.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_human_or_traditional</strong></td>
                            <td>Analogous to grading partial-credit in human evaluation — gives insight into incremental progress rather than binary success/failure.</td>
                        </tr>
                        <tr>
                            <td><strong>recommendations_or_best_practices</strong></td>
                            <td>Report alongside strict accuracy and provide many, high-coverage test cases designed to probe corner cases; interpret as intermediate evidence of capability rather than complete correctness.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Measuring Coding Challenge Competence With APPS', 'publication_date_yy_mm': '2021-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e9880.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e9880.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods, criteria, benchmarks, and results for evaluating LLM-generated scientific theories.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Strict Accuracy</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Strict Accuracy (all-test-case correctness)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>The proportion of problems for which the generated program passes every test case; a strict, binary correctness metric aligned with full functional correctness.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>llm_name</strong></td>
                            <td>GPT-2, GPT-Neo, GPT-3, Codex</td>
                        </tr>
                        <tr>
                            <td><strong>llm_description</strong></td>
                            <td>See APPS entry.</td>
                        </tr>
                        <tr>
                            <td><strong>scientific_domain</strong></td>
                            <td>Computer science — program synthesis / code generation</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_method</strong></td>
                            <td>For each problem, require that the generated code evaluates to correct outputs on all test cases; strict accuracy is (# problems passing all test-cases) / P.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_criteria</strong></td>
                            <td>Binary per-problem correctness (pass all cases).</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_dataset</strong></td>
                            <td>APPS (5,000 test problems, per-problem test-case suites).</td>
                        </tr>
                        <tr>
                            <td><strong>results_summary</strong></td>
                            <td>Strict accuracies are low for current models: examples from Table 2 — GPT-Neo 2.7B strict accuracy: Introductory 3.90% (top-1) and ~5.50% (top-5); other models lower. Strict accuracy highlights how few problems are fully solved.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Very stringent; may obscure incremental progress (models can pass many but not all edge cases); sensitive to the exhaustiveness of test cases.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_human_or_traditional</strong></td>
                            <td>Equivalent to requiring full correctness as in competitive programming scoring; more aligned with human expectations of a correct program.</td>
                        </tr>
                        <tr>
                            <td><strong>recommendations_or_best_practices</strong></td>
                            <td>Report both strict accuracy and test-case-average; use strict accuracy as the long-term target metric once models become sufficiently capable.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Measuring Coding Challenge Competence With APPS', 'publication_date_yy_mm': '2021-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e9880.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e9880.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods, criteria, benchmarks, and results for evaluating LLM-generated scientific theories.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>BLEU (for code)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>BLEU (Bilingual Evaluation Understudy) applied to generated code</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A lexical similarity metric (originally for MT) computed between generated and reference human solutions; in this paper, authors compute BLEU against each human solution and take the maximum BLEU per problem for analysis.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>llm_name</strong></td>
                            <td>GPT-2, GPT-Neo, GPT-3</td>
                        </tr>
                        <tr>
                            <td><strong>llm_description</strong></td>
                            <td>See APPS entry.</td>
                        </tr>
                        <tr>
                            <td><strong>scientific_domain</strong></td>
                            <td>Evaluation metrics for code generation / program synthesis</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_method</strong></td>
                            <td>Compute BLEU between generated solution and each human-written solution; record the highest BLEU per problem and aggregate.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_criteria</strong></td>
                            <td>Lexical/phrase n-gram overlap with reference solutions.</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_dataset</strong></td>
                            <td>APPS generated solutions vs ground-truth human solutions.</td>
                        </tr>
                        <tr>
                            <td><strong>results_summary</strong></td>
                            <td>BLEU can be misleading: BLEU scores sometimes increase with problem difficulty even though functional performance decreases; worse models can have similar or higher BLEU than better models (example: GPT-2 0.1B and GPT-Neo 2.7B BLEU comparisons).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>BLEU does not track program correctness and can be anticorrelated with functional metrics; code can be correct but lexically different from references (low BLEU), or lexically close but functionally incorrect (high BLEU).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_human_or_traditional</strong></td>
                            <td>Unlike execution-based evaluation (which directly measures functionality), BLEU measures surface similarity and is a poor proxy for human grading of functional correctness.</td>
                        </tr>
                        <tr>
                            <td><strong>recommendations_or_best_practices</strong></td>
                            <td>Do not rely on BLEU alone for code-generation evaluation; prefer execution-based test-case metrics (Test Case Average / Strict Accuracy) and, where appropriate, semantics-aware metrics (e.g., CodeBLEU) though authors caution careful validation.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Measuring Coding Challenge Competence With APPS', 'publication_date_yy_mm': '2021-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e9880.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e9880.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods, criteria, benchmarks, and results for evaluating LLM-generated scientific theories.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Syntax Error Rate (pyext heuristic)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Syntax Error Frequency measured via module-load heuristic (pyext)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A diagnostic metric measuring the proportion of generated programs that fail to be parsed/loaded (syntax or formatting errors) using the heuristic of whether pyext can load the generated code as a Python module.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>llm_name</strong></td>
                            <td>GPT-2 variants, GPT-Neo 2.7B, GPT-3 davinci</td>
                        </tr>
                        <tr>
                            <td><strong>llm_description</strong></td>
                            <td>See APPS entry.</td>
                        </tr>
                        <tr>
                            <td><strong>scientific_domain</strong></td>
                            <td>Program synthesis diagnostics / code quality</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_method</strong></td>
                            <td>Attempt to import/load generated code using pyext; if load fails (unbalanced brackets, missing colons, incorrect indentation), count as syntax error.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_criteria</strong></td>
                            <td>Fraction of generated programs that are un-runnable due to parsing/compilation errors.</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_dataset</strong></td>
                            <td>APPS generated solutions.</td>
                        </tr>
                        <tr>
                            <td><strong>results_summary</strong></td>
                            <td>Observed exponential decrease in syntax errors with code-focused pretraining and larger models: GPT-3 had ~59% syntax errors on introductory problems, while GPT-Neo 2.7B had ~3% syntax errors.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Heuristic may conflate some runtime import-time errors with syntax issues, but authors report it almost exclusively captures syntax errors; poor formatting can still cause false negatives in otherwise correct logic.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_human_or_traditional</strong></td>
                            <td>Human programmers rarely produce such a high rate of syntax-only failures once familiar with language; measuring syntax errors helps separate formatting/representation issues from algorithmic reasoning failures.</td>
                        </tr>
                        <tr>
                            <td><strong>recommendations_or_best_practices</strong></td>
                            <td>Report syntax-error rates; consider code-pretraining and fine-tuning on code to reduce syntax errors; repair models might be unnecessary as syntax errors are decreasing with model improvements.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Measuring Coding Challenge Competence With APPS', 'publication_date_yy_mm': '2021-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e9880.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e9880.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods, criteria, benchmarks, and results for evaluating LLM-generated scientific theories.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Top-k / Beam Evaluation</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Top-k candidate evaluation using beam search / sampling</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Evaluate multiple generated candidate solutions per problem (e.g., beam width 5) and report best-of-k performance (top-1 vs top-5), which captures gains obtainable by sampling multiple attempts.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>llm_name</strong></td>
                            <td>GPT-2 (all sizes), GPT-Neo 2.7B</td>
                        </tr>
                        <tr>
                            <td><strong>llm_description</strong></td>
                            <td>See APPS entry.</td>
                        </tr>
                        <tr>
                            <td><strong>scientific_domain</strong></td>
                            <td>Program synthesis evaluation / search-based evaluation</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_method</strong></td>
                            <td>Generate k candidate programs per problem using beam search (authors used beam size 5) and evaluate each on the test-case bank; report the best-performing candidate's metrics (test-case-average and strict accuracy) as top-k.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_criteria</strong></td>
                            <td>Best-of-k test-case pass rate and best-of-k strict accuracy.</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_dataset</strong></td>
                            <td>APPS; authors present Top-1 and Top-5 results and full top-5 tables.</td>
                        </tr>
                        <tr>
                            <td><strong>results_summary</strong></td>
                            <td>Top-5 selection markedly improves measured performance: e.g., GPT-Neo 2.7B top-1 test-case-average on introductory problems ~14.7% vs top-5 ~19.89%; strict top-1 accuracy ~3.9% vs top-5 strict accuracy ~5.5% (introductory).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Top-k evaluation reflects an ideal selector that can pick the best program; in practice, selecting among k candidates may require an external validation signal (which APPS provides via test cases).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_human_or_traditional</strong></td>
                            <td>Analogous to human submission of multiple attempts and selecting the working one; differs from single-shot evaluation.</td>
                        </tr>
                        <tr>
                            <td><strong>recommendations_or_best_practices</strong></td>
                            <td>Report both top-1 and top-k metrics; consider increasing k (e.g., Chen et al. report top-1000 experiments) to measure model diversity and potential with cheap validation.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Measuring Coding Challenge Competence With APPS', 'publication_date_yy_mm': '2021-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e9880.6">
                <h3 class="extraction-instance">Extracted Data Instance 6 (e9880.6)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods, criteria, benchmarks, and results for evaluating LLM-generated scientific theories.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>False Positive / Test-case-sparsity Analysis</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>False-positive rate analysis for problems with few test cases</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Empirical manual audit to quantify how few-test-case problems can yield false positives (passing test cases but not being fully correct), especially on problems with only 2–3 test cases.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>llm_name</strong></td>
                            <td>GPT-Neo 2.7B (audit subject)</td>
                        </tr>
                        <tr>
                            <td><strong>llm_description</strong></td>
                            <td>See APPS entry.</td>
                        </tr>
                        <tr>
                            <td><strong>scientific_domain</strong></td>
                            <td>Program synthesis evaluation / dataset QA</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_method</strong></td>
                            <td>Identify problems in test split with only 2 or 3 test cases that the model passed; manually inspect whether passing those test cases implies correct general behavior; compute false-positive rates.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_criteria</strong></td>
                            <td>Empirical fraction of 'passed' problems that are actually incorrect solutions (false positives) among problems with small test-case counts.</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_dataset</strong></td>
                            <td>APPS — focused on test-set problems with only 2 or 3 test cases (common for some Kattis-sourced problems).</td>
                        </tr>
                        <tr>
                            <td><strong>results_summary</strong></td>
                            <td>Manual check: out of 12 two-test-case problems that GPT-Neo passed, 8 were false positives; out of 6 three-test-case problems passed, 1 was a false positive. Authors compute false-positive rates approximately 0.9% for 2-test-case problems and 0.1% for 3-test-case problems relative to larger denominators, concluding noise is significantly less than many annotated datasets.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Small-test-case problems risk overestimating model competence; manual inspection required to identify false positives in small-sample scenarios.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_human_or_traditional</strong></td>
                            <td>Human graders often inspect edge cases or require proofs; automatic small-test-case evaluation is less robust but pragmatic.</td>
                        </tr>
                        <tr>
                            <td><strong>recommendations_or_best_practices</strong></td>
                            <td>Prefer many test cases per problem when feasible; manually audit small-test-case problems to estimate false-positive risk; report these false-positive estimates when publishing benchmark results.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Measuring Coding Challenge Competence With APPS', 'publication_date_yy_mm': '2021-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e9880.7">
                <h3 class="extraction-instance">Extracted Data Instance 7 (e9880.7)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods, criteria, benchmarks, and results for evaluating LLM-generated scientific theories.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Execution-based Evaluation Framework</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Execution-and-judging framework for arbitrary Python code (merged judge)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A standardized testing harness that executes arbitrary generated Python solutions (including imports) against per-problem test-case suites, merging diverse online judge behaviors and normalizing input formats; also includes dataset preprocessing and problem formatting parsers.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>llm_name</strong></td>
                            <td>Used to evaluate outputs from GPT-2, GPT-Neo, GPT-3 and reported Codex results</td>
                        </tr>
                        <tr>
                            <td><strong>llm_description</strong></td>
                            <td>See APPS entry.</td>
                        </tr>
                        <tr>
                            <td><strong>scientific_domain</strong></td>
                            <td>Program synthesis evaluation / automated testing infrastructure</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_method</strong></td>
                            <td>Run generated code as Python modules (when applicable) or scripts; compare program outputs to expected outputs for each test case; use heuristics (pyext import) to detect syntax errors; format problem text and starter code into consistent prompts for models.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_criteria</strong></td>
                            <td>Functional match per test case and module-load success for syntax checks.</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_dataset</strong></td>
                            <td>APPS test-case bank (131,777 test cases), starter-code-aware prompts (call-based and standard-input formats), custom HTML parsers for problem text, LaTeX handling.</td>
                        </tr>
                        <tr>
                            <td><strong>results_summary</strong></td>
                            <td>Framework enables automated large-scale evaluation across 5,000 test problems; authors used it to measure test-case-average, strict accuracy, syntax-error rates, and top-k performance for multiple LLMs.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Executing arbitrary code poses security concerns (authors merge judging functionality similar to contest sites); differences in allowed libraries and input conventions across sites must be normalized; runtime nondeterminism and environment dependencies can complicate evaluation.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_human_or_traditional</strong></td>
                            <td>More objective and scalable than manual human grading; closely mirrors online judge workflows used to evaluate human programmers.</td>
                        </tr>
                        <tr>
                            <td><strong>recommendations_or_best_practices</strong></td>
                            <td>Standardize problem formats and environment, sanitize and decontaminate pretraining corpora to avoid memorization artifacts, include explicit starter code handling in prompts, and provide a large suite of targeted test cases per problem.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Measuring Coding Challenge Competence With APPS', 'publication_date_yy_mm': '2021-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Evaluating large language models trained on code <em>(Rating: 2)</em></li>
                <li>CodeBLEU: a method for automatic evaluation of code synthesis <em>(Rating: 2)</em></li>
                <li>Graph-based, self-supervised program repair from diagnostic feedback <em>(Rating: 1)</em></li>
                <li>Language models are few-shot learners <em>(Rating: 1)</em></li>
                <li>Generative language modeling for automated theorem proving <em>(Rating: 1)</em></li>
                <li>CodeXGLUE: a machine learning benchmark dataset for code understanding and generation <em>(Rating: 2)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-9880",
    "paper_id": "paper-1ccd031f28dccfb226f6c0c588c93a97a50bf95f",
    "extraction_schema_id": "extraction-schema-168",
    "extracted_data": [
        {
            "name_short": "APPS",
            "name_full": "Automated Programming Progress Standard (APPS)",
            "brief_description": "A large benchmark of 10,000 Python programming problems with 131,777 test cases and 232,421 human solutions, designed to evaluate LLMs' ability to generate correct programs from natural-language specifications by executing generated code on problem-specific test cases.",
            "citation_title": "here",
            "mention_or_use": "use",
            "llm_name": "GPT-2 (0.1B, 1.5B), GPT-Neo (2.7B), GPT-3 (davinci, 175B), OpenAI Codex (reported by Chen et al.)",
            "llm_description": "Various transformer autoregressive LLMs: GPT-2 variants (pretrained on natural language, some variants further pretrained on GitHub code), GPT-Neo 2.7B (pretrained on the Pile which includes GitHub), GPT-3 davinci/instruct (175B, few-shot API, not fine-tuned by authors), and Codex (12B, code-specialized reported in follow-up work).",
            "scientific_domain": "Computer science — program synthesis / automated code generation",
            "evaluation_method": "Automatic execution of generated Python programs on problem-specific test cases (merged judging framework adapted from competitive programming sites); detection of syntax/loading errors (pyext heuristic); aggregate metrics computed across the test set; top-k candidate selection (beam search) for multi-attempt evaluation.",
            "evaluation_criteria": "Functional correctness on test cases (Test Case Average and Strict Accuracy), syntax error frequency, and auxiliary lexical metrics (BLEU/CodeBLEU) for analysis.",
            "benchmark_or_dataset": "APPS: 10,000 problems drawn from open coding sites (Codeforces, Kattis, AtCoder, etc.), curated and deduplicated; split into 5,000 train / 5,000 test; average problem length ~293.2 words; per-problem test cases (avg ~21.2), problems categorized into Introductory, Interview, and Competition difficulty levels.",
            "results_summary": "Fine-tuned code-capable models (GPT-Neo 2.7B and fine-tuned GPT-2 variants) achieved nonzero functional performance: e.g., GPT-Neo passes ~14.7% of test cases on introductory problems (top-1) and attains ~3.9% strict top-1 accuracy and ~5.5% top-5 strict accuracy on introductory problems; syntax error rates fall sharply with code pretraining/fine-tuning (GPT-3 ~59% syntax errors on introductory problems vs GPT-Neo ~3%). Few-shot GPT-3 (davinci) solved only 3/5,000 test-set problems under the evaluated prompts.",
            "limitations_or_challenges": "Potential false positives for problems with very few test cases (2–3); lexical metrics (BLEU) do not correlate with functional correctness and can be misleading; models can overfit formatting and produce syntactically malformed but semantically close code; pretraining data contamination must be controlled (authors decontaminated GitHub for GPT-2 experiments); resource costs for large-model inference/training.",
            "comparison_to_human_or_traditional": "Evaluation mirrors human grading in programming (running test cases) rather than lexical/translation metrics; benchmark explicitly separates model performance from human experts by requiring functional correctness rather than similarity to human solutions.",
            "recommendations_or_best_practices": "Use execution-based test-case evaluation as the gold standard for program synthesis; include many and diverse test cases probing corner cases; measure both test-case-average (partial correctness) and strict accuracy (full correctness); report syntax-error rates; evaluate top-k candidate generations (beam search or sampling) because selecting best-of-k substantially improves measured performance; control for data contamination during pretraining.",
            "uuid": "e9880.0",
            "source_info": {
                "paper_title": "Measuring Coding Challenge Competence With APPS",
                "publication_date_yy_mm": "2021-05"
            }
        },
        {
            "name_short": "Test Case Average",
            "name_full": "Test Case Average (average fraction of test cases passed)",
            "brief_description": "An aggregate metric computed as the mean, over problems, of the fraction of per-problem test cases that a generated program passes; captures partial correctness when solutions handle some but not all cases.",
            "citation_title": "here",
            "mention_or_use": "use",
            "llm_name": "GPT-2 (0.1B, 1.5B), GPT-Neo (2.7B), GPT-3 (davinci), Codex (reported)",
            "llm_description": "See APPS entry (various transformer LLMs; some fine-tuned on APPS and/or GitHub).",
            "scientific_domain": "Computer science — program synthesis / code generation",
            "evaluation_method": "For each problem p with C_p test cases, compute (1/C_p) sum_c indicator(eval(code_p, x_{p,c}) == y_{p,c}); average across all P problems.",
            "evaluation_criteria": "Average fractional pass rate across test cases (a softer metric than strict all-cases correctness).",
            "benchmark_or_dataset": "APPS test set (5,000 problems; avg ~21.2 test cases per problem).",
            "results_summary": "Reported test-case-average values by model and difficulty (examples: GPT-Neo 2.7B: Introductory ~14.68% top-1, Interview ~9.85%, Competition ~6.54%, Average ~10.15%; fine-tuning and larger models increase test-case-average).",
            "limitations_or_challenges": "May overestimate capability because partial solutions pass some cases but miss corner cases; sensitive to the quality and coverage of test-case bank; does not require full functional correctness.",
            "comparison_to_human_or_traditional": "Analogous to grading partial-credit in human evaluation — gives insight into incremental progress rather than binary success/failure.",
            "recommendations_or_best_practices": "Report alongside strict accuracy and provide many, high-coverage test cases designed to probe corner cases; interpret as intermediate evidence of capability rather than complete correctness.",
            "uuid": "e9880.1",
            "source_info": {
                "paper_title": "Measuring Coding Challenge Competence With APPS",
                "publication_date_yy_mm": "2021-05"
            }
        },
        {
            "name_short": "Strict Accuracy",
            "name_full": "Strict Accuracy (all-test-case correctness)",
            "brief_description": "The proportion of problems for which the generated program passes every test case; a strict, binary correctness metric aligned with full functional correctness.",
            "citation_title": "here",
            "mention_or_use": "use",
            "llm_name": "GPT-2, GPT-Neo, GPT-3, Codex",
            "llm_description": "See APPS entry.",
            "scientific_domain": "Computer science — program synthesis / code generation",
            "evaluation_method": "For each problem, require that the generated code evaluates to correct outputs on all test cases; strict accuracy is (# problems passing all test-cases) / P.",
            "evaluation_criteria": "Binary per-problem correctness (pass all cases).",
            "benchmark_or_dataset": "APPS (5,000 test problems, per-problem test-case suites).",
            "results_summary": "Strict accuracies are low for current models: examples from Table 2 — GPT-Neo 2.7B strict accuracy: Introductory 3.90% (top-1) and ~5.50% (top-5); other models lower. Strict accuracy highlights how few problems are fully solved.",
            "limitations_or_challenges": "Very stringent; may obscure incremental progress (models can pass many but not all edge cases); sensitive to the exhaustiveness of test cases.",
            "comparison_to_human_or_traditional": "Equivalent to requiring full correctness as in competitive programming scoring; more aligned with human expectations of a correct program.",
            "recommendations_or_best_practices": "Report both strict accuracy and test-case-average; use strict accuracy as the long-term target metric once models become sufficiently capable.",
            "uuid": "e9880.2",
            "source_info": {
                "paper_title": "Measuring Coding Challenge Competence With APPS",
                "publication_date_yy_mm": "2021-05"
            }
        },
        {
            "name_short": "BLEU (for code)",
            "name_full": "BLEU (Bilingual Evaluation Understudy) applied to generated code",
            "brief_description": "A lexical similarity metric (originally for MT) computed between generated and reference human solutions; in this paper, authors compute BLEU against each human solution and take the maximum BLEU per problem for analysis.",
            "citation_title": "here",
            "mention_or_use": "use",
            "llm_name": "GPT-2, GPT-Neo, GPT-3",
            "llm_description": "See APPS entry.",
            "scientific_domain": "Evaluation metrics for code generation / program synthesis",
            "evaluation_method": "Compute BLEU between generated solution and each human-written solution; record the highest BLEU per problem and aggregate.",
            "evaluation_criteria": "Lexical/phrase n-gram overlap with reference solutions.",
            "benchmark_or_dataset": "APPS generated solutions vs ground-truth human solutions.",
            "results_summary": "BLEU can be misleading: BLEU scores sometimes increase with problem difficulty even though functional performance decreases; worse models can have similar or higher BLEU than better models (example: GPT-2 0.1B and GPT-Neo 2.7B BLEU comparisons).",
            "limitations_or_challenges": "BLEU does not track program correctness and can be anticorrelated with functional metrics; code can be correct but lexically different from references (low BLEU), or lexically close but functionally incorrect (high BLEU).",
            "comparison_to_human_or_traditional": "Unlike execution-based evaluation (which directly measures functionality), BLEU measures surface similarity and is a poor proxy for human grading of functional correctness.",
            "recommendations_or_best_practices": "Do not rely on BLEU alone for code-generation evaluation; prefer execution-based test-case metrics (Test Case Average / Strict Accuracy) and, where appropriate, semantics-aware metrics (e.g., CodeBLEU) though authors caution careful validation.",
            "uuid": "e9880.3",
            "source_info": {
                "paper_title": "Measuring Coding Challenge Competence With APPS",
                "publication_date_yy_mm": "2021-05"
            }
        },
        {
            "name_short": "Syntax Error Rate (pyext heuristic)",
            "name_full": "Syntax Error Frequency measured via module-load heuristic (pyext)",
            "brief_description": "A diagnostic metric measuring the proportion of generated programs that fail to be parsed/loaded (syntax or formatting errors) using the heuristic of whether pyext can load the generated code as a Python module.",
            "citation_title": "here",
            "mention_or_use": "use",
            "llm_name": "GPT-2 variants, GPT-Neo 2.7B, GPT-3 davinci",
            "llm_description": "See APPS entry.",
            "scientific_domain": "Program synthesis diagnostics / code quality",
            "evaluation_method": "Attempt to import/load generated code using pyext; if load fails (unbalanced brackets, missing colons, incorrect indentation), count as syntax error.",
            "evaluation_criteria": "Fraction of generated programs that are un-runnable due to parsing/compilation errors.",
            "benchmark_or_dataset": "APPS generated solutions.",
            "results_summary": "Observed exponential decrease in syntax errors with code-focused pretraining and larger models: GPT-3 had ~59% syntax errors on introductory problems, while GPT-Neo 2.7B had ~3% syntax errors.",
            "limitations_or_challenges": "Heuristic may conflate some runtime import-time errors with syntax issues, but authors report it almost exclusively captures syntax errors; poor formatting can still cause false negatives in otherwise correct logic.",
            "comparison_to_human_or_traditional": "Human programmers rarely produce such a high rate of syntax-only failures once familiar with language; measuring syntax errors helps separate formatting/representation issues from algorithmic reasoning failures.",
            "recommendations_or_best_practices": "Report syntax-error rates; consider code-pretraining and fine-tuning on code to reduce syntax errors; repair models might be unnecessary as syntax errors are decreasing with model improvements.",
            "uuid": "e9880.4",
            "source_info": {
                "paper_title": "Measuring Coding Challenge Competence With APPS",
                "publication_date_yy_mm": "2021-05"
            }
        },
        {
            "name_short": "Top-k / Beam Evaluation",
            "name_full": "Top-k candidate evaluation using beam search / sampling",
            "brief_description": "Evaluate multiple generated candidate solutions per problem (e.g., beam width 5) and report best-of-k performance (top-1 vs top-5), which captures gains obtainable by sampling multiple attempts.",
            "citation_title": "here",
            "mention_or_use": "use",
            "llm_name": "GPT-2 (all sizes), GPT-Neo 2.7B",
            "llm_description": "See APPS entry.",
            "scientific_domain": "Program synthesis evaluation / search-based evaluation",
            "evaluation_method": "Generate k candidate programs per problem using beam search (authors used beam size 5) and evaluate each on the test-case bank; report the best-performing candidate's metrics (test-case-average and strict accuracy) as top-k.",
            "evaluation_criteria": "Best-of-k test-case pass rate and best-of-k strict accuracy.",
            "benchmark_or_dataset": "APPS; authors present Top-1 and Top-5 results and full top-5 tables.",
            "results_summary": "Top-5 selection markedly improves measured performance: e.g., GPT-Neo 2.7B top-1 test-case-average on introductory problems ~14.7% vs top-5 ~19.89%; strict top-1 accuracy ~3.9% vs top-5 strict accuracy ~5.5% (introductory).",
            "limitations_or_challenges": "Top-k evaluation reflects an ideal selector that can pick the best program; in practice, selecting among k candidates may require an external validation signal (which APPS provides via test cases).",
            "comparison_to_human_or_traditional": "Analogous to human submission of multiple attempts and selecting the working one; differs from single-shot evaluation.",
            "recommendations_or_best_practices": "Report both top-1 and top-k metrics; consider increasing k (e.g., Chen et al. report top-1000 experiments) to measure model diversity and potential with cheap validation.",
            "uuid": "e9880.5",
            "source_info": {
                "paper_title": "Measuring Coding Challenge Competence With APPS",
                "publication_date_yy_mm": "2021-05"
            }
        },
        {
            "name_short": "False Positive / Test-case-sparsity Analysis",
            "name_full": "False-positive rate analysis for problems with few test cases",
            "brief_description": "Empirical manual audit to quantify how few-test-case problems can yield false positives (passing test cases but not being fully correct), especially on problems with only 2–3 test cases.",
            "citation_title": "here",
            "mention_or_use": "use",
            "llm_name": "GPT-Neo 2.7B (audit subject)",
            "llm_description": "See APPS entry.",
            "scientific_domain": "Program synthesis evaluation / dataset QA",
            "evaluation_method": "Identify problems in test split with only 2 or 3 test cases that the model passed; manually inspect whether passing those test cases implies correct general behavior; compute false-positive rates.",
            "evaluation_criteria": "Empirical fraction of 'passed' problems that are actually incorrect solutions (false positives) among problems with small test-case counts.",
            "benchmark_or_dataset": "APPS — focused on test-set problems with only 2 or 3 test cases (common for some Kattis-sourced problems).",
            "results_summary": "Manual check: out of 12 two-test-case problems that GPT-Neo passed, 8 were false positives; out of 6 three-test-case problems passed, 1 was a false positive. Authors compute false-positive rates approximately 0.9% for 2-test-case problems and 0.1% for 3-test-case problems relative to larger denominators, concluding noise is significantly less than many annotated datasets.",
            "limitations_or_challenges": "Small-test-case problems risk overestimating model competence; manual inspection required to identify false positives in small-sample scenarios.",
            "comparison_to_human_or_traditional": "Human graders often inspect edge cases or require proofs; automatic small-test-case evaluation is less robust but pragmatic.",
            "recommendations_or_best_practices": "Prefer many test cases per problem when feasible; manually audit small-test-case problems to estimate false-positive risk; report these false-positive estimates when publishing benchmark results.",
            "uuid": "e9880.6",
            "source_info": {
                "paper_title": "Measuring Coding Challenge Competence With APPS",
                "publication_date_yy_mm": "2021-05"
            }
        },
        {
            "name_short": "Execution-based Evaluation Framework",
            "name_full": "Execution-and-judging framework for arbitrary Python code (merged judge)",
            "brief_description": "A standardized testing harness that executes arbitrary generated Python solutions (including imports) against per-problem test-case suites, merging diverse online judge behaviors and normalizing input formats; also includes dataset preprocessing and problem formatting parsers.",
            "citation_title": "here",
            "mention_or_use": "use",
            "llm_name": "Used to evaluate outputs from GPT-2, GPT-Neo, GPT-3 and reported Codex results",
            "llm_description": "See APPS entry.",
            "scientific_domain": "Program synthesis evaluation / automated testing infrastructure",
            "evaluation_method": "Run generated code as Python modules (when applicable) or scripts; compare program outputs to expected outputs for each test case; use heuristics (pyext import) to detect syntax errors; format problem text and starter code into consistent prompts for models.",
            "evaluation_criteria": "Functional match per test case and module-load success for syntax checks.",
            "benchmark_or_dataset": "APPS test-case bank (131,777 test cases), starter-code-aware prompts (call-based and standard-input formats), custom HTML parsers for problem text, LaTeX handling.",
            "results_summary": "Framework enables automated large-scale evaluation across 5,000 test problems; authors used it to measure test-case-average, strict accuracy, syntax-error rates, and top-k performance for multiple LLMs.",
            "limitations_or_challenges": "Executing arbitrary code poses security concerns (authors merge judging functionality similar to contest sites); differences in allowed libraries and input conventions across sites must be normalized; runtime nondeterminism and environment dependencies can complicate evaluation.",
            "comparison_to_human_or_traditional": "More objective and scalable than manual human grading; closely mirrors online judge workflows used to evaluate human programmers.",
            "recommendations_or_best_practices": "Standardize problem formats and environment, sanitize and decontaminate pretraining corpora to avoid memorization artifacts, include explicit starter code handling in prompts, and provide a large suite of targeted test cases per problem.",
            "uuid": "e9880.7",
            "source_info": {
                "paper_title": "Measuring Coding Challenge Competence With APPS",
                "publication_date_yy_mm": "2021-05"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Evaluating large language models trained on code",
            "rating": 2
        },
        {
            "paper_title": "CodeBLEU: a method for automatic evaluation of code synthesis",
            "rating": 2
        },
        {
            "paper_title": "Graph-based, self-supervised program repair from diagnostic feedback",
            "rating": 1
        },
        {
            "paper_title": "Language models are few-shot learners",
            "rating": 1
        },
        {
            "paper_title": "Generative language modeling for automated theorem proving",
            "rating": 1
        },
        {
            "paper_title": "CodeXGLUE: a machine learning benchmark dataset for code understanding and generation",
            "rating": 2
        }
    ],
    "cost": 0.016260499999999997,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Measuring Coding Challenge Competence With APPS</h1>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<h4>Abstract</h4>
<p>While programming is one of the most broadly applicable skills in modern society, it is unclear how well state-of-the-art machine learning models can write code. Despite its importance, there has been surprisingly little work on evaluating code generation, and it can be difficult to assess code generation performance in an accurate and rigorous manner. To meet this challenge, we introduce APPS, a benchmark for code generation. Unlike prior work in more restricted settings, our benchmark measures the ability of models to take an arbitrary natural language specification and generate satisfactory Python code. Similar to how companies assess candidate software developers, we evaluate models by checking their generated code on test cases. Our benchmark includes 10,000 problems, which range from having simple oneline solutions to being substantial algorithmic challenges. We fine-tune large language models on both GitHub and our training set, and we find that the prevalence of syntax errors is decreasing exponentially as models improve. Recent models such as GPT-Neo can pass approximately $20 \%$ of the test cases of introductory problems, so we find that machine learning models are now beginning to learn how to code. As the social significance of automatic code generation increases over the coming years, our benchmark can provide an objective measure for tracking advancements.</p>
<p>"Everybody should learn to program a computer, because it teaches you how to think." - Steve Jobs</p>
<h2>1 Introduction</h2>
<p>Computer programming can be found in nearly all parts of society. Spanning entertainment, healthcare, education, and more, programming is an extraordinarily general tool with applications that are vast in scope. As computers are becoming more ubiquitous in modern life, rising demand for highquality code draws an ever-greater number of aspiring programmers to the profession. After years of study to become proficient coders, human experts are are able to convert abstract specifications of diverse cognitive tasks into concrete programs.
In the past few years, large-scale language models have shown promise in generalizing to various cognitive tasks, including linguistic inference (Wang et al., 2019a), commonsense reasoning (Zellers et al., 2019; Huang et al., 2019; Bisk et al., 2019), logical deduction (Liu et al., 2020b), mathematics (Polu and Sutskever, 2020; Hendrycks et al., 2021c), and general understanding of multiple domains</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 1: An example problem from APPS (left) along with possible generated code (middle) and two example test cases we use to evaluate the generated code (right). Our evaluation framework has test cases and 10,000 code generation problems of varying difficulty levels.</p>
<p>of human knowledge (Hendrycks et al., 2021b). However, whether large-scale language models can reliably write code remains an open question.</p>
<p>Motivated by the potential of language models and the need for thorough code generation evaluation, we introduce APPS, a benchmark for code generation from natural language specifications. Unlike prior work on code generation with Transformer language models (Vaswani et al., 2017), which mostly focuses on code translation (Lachaux et al., 2020) and pseudocode-to-code (Kulal et al., 2019), we evaluate models on their ability to take specifications given in natural language and write code that meets these specifications. This setting mirrors how human coders are evaluated and is a more realistic and informative setting in which to benchmark models.</p>
<p>APPS provides a precise and comprehensive view of code generation. APPS evaluates models not only on their ability to code syntactically correct programs, but also on their ability to understand task descriptions and devise algorithms to solve these tasks. It contains 10,000 programming problems at various levels of difficulty, covering simple introductory problems, interview-level problems, and coding competition challenges. If a model were to perform well on APPS, this would indicate an ability to flexibly use data structures and programming techniques, as well as an ability to correctly interpret diverse task specifications, follow instructions, and understand human intent (Hendrycks et al., 2021a).</p>
<p>For most text generation tasks, high-quality evaluation requires human feedback, which can be time-consuming or carry pecuniary costs. As a result, automatic metrics such as BLEU (Papineni et al., 2002) are often used to compare methods, but these metrics do not necessarily track program correctness. Since the objective for code generation is to produce correct programs, we assess programs not with BLEU but with test cases and error catching. Evaluating code generation on APPS is facilitated by a large bank of over 130,000 test cases. The test cases are specifically chosen to probe correct functionality across the input space. By using test cases, we provide a gold-standard metric for code generation quality.</p>
<p>In our experiments, we find that models are now starting to exhibit nonzero accuracy and solve some coding problems. Additionally, as models improve, we observe that syntax errors are exponentially decreasing. We also find further evidence that BLEU is a problematic metric for code generation, sometimes being anticorrelated with gold-standard accuracy. We find that accuracy decreases with difficulty level and improves through fine-tuning and model size increases. The strongest model that we evaluate on introductory problems passes almost 20% of test cases given five attempts. These results position code generation as a challenging but now tractable testbed for large-scale language models.</p>
<p>Writing code to meet specifications in natural language is an economically valuable task with widespread social implications should it be solved, as it could eventually facilitate malicious code generation and one day result in job automation. As large-scale language models have the potential</p>
<table>
<thead>
<tr>
<th></th>
<th>PY150</th>
<th>CONCODE</th>
<th>SPoC</th>
<th>APPS</th>
</tr>
</thead>
<tbody>
<tr>
<td>Programming Language</td>
<td>Python</td>
<td>Java</td>
<td>C++</td>
<td>Python</td>
</tr>
<tr>
<td>Test Cases</td>
<td>$\times$</td>
<td>$\times$</td>
<td>$\checkmark$</td>
<td>$\checkmark$</td>
</tr>
<tr>
<td>Number of Programs</td>
<td>N/A</td>
<td>104,000</td>
<td>18,356</td>
<td>232,421</td>
</tr>
<tr>
<td>Lines per Program (Avg.)</td>
<td>1</td>
<td>26.3</td>
<td>14.7</td>
<td>18.0</td>
</tr>
<tr>
<td>Number of Exercises</td>
<td>3,000</td>
<td>104,000</td>
<td>677</td>
<td>10,000</td>
</tr>
<tr>
<td>Text Input</td>
<td>Python</td>
<td>Docstrings</td>
<td>Pseudocode</td>
<td>Problem Descriptions</td>
</tr>
</tbody>
</table>
<p>Table 1: A comparison of the APPS dataset to existing datasets for converting between text and code. APPS has over an order of magnitude more ground-truth solutions than these datasets, test cases, and natural language problem descriptions.
to make significant progress on code generation, it is essential that we begin to track advancements on this task. Our new benchmark facilitates measuring performance in an accurate and rigorous manner. Using APPS, we find that programming is very difficult for modern language models, though performance is improving. Thus, the APPS benchmark can provide foresight about the performance of future large-scale language models at the critical task of program synthesis from natural language. The dataset is available at https://github.com/hendrycks/apps.</p>
<h1>2 Related Work</h1>
<p>Program Synthesis. Program synthesis is the task of generating a computer program that satisfies given specifications. Deductive program synthesis uses formal logic specifications to define a search problem. Complex optimization techniques are used to generate programs satisfying these specifications (Alur et al., 2018). Because specifications must be converted into a formal language, these approaches can be rigid. Inductive synthesis from example input-output behavior can provide an alternative to formal specification (Cai et al., 2017; Gulwani et al., 2017), but it is often hard to full specify behavior with examples, as any machine learning practitioner is well-aware.
An alternative to formal or inductive specification is to specify program behavior in natural language, which prior work has considered in constrained settings. Raza et al. (2015) and Desai et al. (2016) generate short programs using ad-hoc programming languages to solve specifications such as "Any 2 letters followed by any combination of 6 whole numbers." Yu et al. (2018) introduce the Spider dataset for converting natural language queries into short SQL database commands. In contrast, we consider long natural language specifications and general-purpose programming languages.
Code Understanding Datasets. Language modeling is a compelling tool for code generation, and several works have achieved success generating code with language models in limited settings. Lachaux et al. (2020) use unsupervised machine translation techniques to translate functions across programming languages, attaining identical behavior after translation in many cases. Kulal et al. (2019) introduce SPoC, a method for converting pseudocode to code utilizing seq2seq machine translation with an additional search step. To train SPoC, they collect line-by-line descriptions of C++ programs using Amazon Mechanical Turk. Recently, Lu et al. (2021) introduce the CodeXGLUE benchmark which aggregates various previous benchmarks and use CodeBLEU (Ren et al., 2020) and CONCODE. Iyer et al. (2018) investigate generating Java code from docstrings and evaluate performance with BLEU. The docstrings are often incomplete specifications of what should be coded and only 14.7 words long on average, e.g. "Convert mixed case to underscores." By comparison, problem specifications in our new APPS benchmark are self-contained and have a much larger average length of 293.2 words. Unlike Iyer et al. (2018), APPS contains test cases for every exercise, enabling a high-quality evaluation of code correctness. Further comparisons are in the Appendix.
Evaluating Large-Scale Language Models. Modern large-scale language models have demonstrated impressive capabilities across a variety of text-based tasks. On the SuperGLUE benchmark (Wang et al., 2019b), some models now exceed human performance. On many commonsense reasoning benchmarks, performance is rising quickly (Zellers et al., 2019; Huang et al., 2019; Bisk et al., 2019). Even when language models are evaluated across diverse technical areas such as law and medicine, performance is surprisingly high and poised to improve as models are scaled up further (Hendrycks et al., 2021b). With rapid improvements across numerous datasets, finding resilient</p>
<p>benchmarks on which models significantly underperform humans is challenging. APPS represents an attempt to fill this gap and cleanly separate model performance from that of expert humans.</p>
<h1>3 The APPS Dataset</h1>
<p>The APPS dataset consists of problems collected from different open-access coding websites such as Codeforces, Kattis, and more. The APPS benchmark attempts to mirror how humans programmers are evaluated by posing coding problems in unrestricted natural language and using test cases to evaluate solution correctness. The problems range in difficulty from introductory to collegiate competition level and measure coding and problem-solving ability.
The Automated Programming Progress Standard, abbreviated APPS, consists of 10,000 coding problems in total, with 131,777 test cases for checking solutions and 232,421 ground-truth solutions written by humans. Problems can be complicated, as the average length of a problem is 293.2 words. The data are split evenly into training and test sets, with 5,000 problems each. In the test set, every problem has multiple test cases, and the average number of test cases is 21.2 . Each test case is specifically designed for the corresponding problem, enabling us to rigorously evaluate program functionality.
Dataset Construction. To create the APPS dataset, we manually curate problems from open-access sites where programmers share problems with each other, including Codewars, AtCoder, Kattis, and Codeforces. Problems are posed as natural language specifications of what should be coded, and they come in various formats. To improve quality and consistency, we wrote custom HTML parsers for each source of problems, which allows us to properly format LaTeX expressions, lists, and sections in the question text. Where necessary, we convert equation images to LaTeX using the MathPix API, and we remove problems that rely on image figures. We also perform deduplication using tf-idf features with SVD dimensionality reduction and cosine similarity. Several graduate and undergraduate student authors polished and refined this dataset over the course of six months, ensuring a high-quality set of problems.
Executing and evaluating arbitrary Python code is challenging. On the websites we source data from, human solutions are allowed to run arbitrary code, including import statements for common modules and libraries. To handle this, each website implements a custom judging system for solutions. We design a testing framework with this in mind, which merges the judging functionality of several websites. We also standardize the format of test cases. The end result is that solutions are allowed to execute arbitrary Python code, and the results are compared against test cases for a given problem.
Dataset Difficulty. Each of our problem sources uses a separate scale for measuring difficulty. We place problems from these different sources into three categories. For example, problems from Kattis with difficulty less than 3 are categorized as "introductory," problems with difficulty between 3 and 5 as "interview," and problems with difficulty greater than 5 as "competition."</p>
<ol>
<li>Introductory Level. These are problems that most programmers with 1-2 years of experience can answer without requiring complicated algorithms. Examples of such problems include counting the number of vowels in a string, or returning the running sum of a list of integers. There are 3,639 problems classified as introductory level and 1,000 in the test set.</li>
<li>Interview Level. These are problems that are more algorithmic and difficult in nature and would be at the level of questions asked in programming technical interviews. Examples of such problems might include those involving data structures such as trees or graphs, or problems that requiring nontrivial algorithms. There are 5,000 problems classified as interview level and 3,000 in the test set.</li>
<li>Competition Level. These are problems are the most challenging and are at the level of the most advanced high school and collegiate programming competitions, including USACO, IOI, and ACM. There are 1,361 competition level problems and 1,000 in the test set.</li>
</ol>
<p>Problem Formats. To accommodate a broad range of problem sources, problems in APPS come in two formats.</p>
<ul>
<li>Call-Based Format problems generally provide initial starter code, usually in the form of a function header, and ask for the solution to be provided as the function's return value.</li>
</ul>
<h1>Problem</h1>
<p>You are given a string $s=s_{1} s_{2} \ldots s_{n}$ of length $n$, which only contains digits $1,2, \ldots, 9$. A substring $s[l \ldots r]$ of $s$ is a string $s_{l} s_{l+1} s_{l+2} \ldots s_{r}$. A substring $s[l \ldots r]$ of $s$ is called even if the number represented by it is even. Find the number of even substrings of $s$. Note, that even if some substrings are equal as strings, but have different $l$ and $r$, they are counted as different substrings. The first line contains an integer $n(1 \leq n \leq 65000)$ - the length of the string $s$. The second line contains a string $s$ of length $n$. The string $s$ consists only of digits $1,2, \ldots, 9$. Print the number of even substrings of $s$.</p>
<h2>Model Output</h2>
<div class="codehilite"><pre><span></span><code><span class="nv">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">int</span><span class="ss">(</span><span class="nv">input</span><span class="ss">())</span>
<span class="nv">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">input</span><span class="ss">()</span>
<span class="nv">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="k">for</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">range</span><span class="ss">(</span><span class="nv">n</span><span class="ss">)</span>:
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nv">j</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">range</span><span class="ss">(</span><span class="nv">i</span>,<span class="w"> </span><span class="nv">n</span><span class="ss">)</span>:
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nv">int</span><span class="ss">(</span><span class="nv">s</span>[<span class="nv">i</span>:<span class="nv">j</span><span class="o">+</span><span class="mi">1</span>]<span class="ss">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span>:
<span class="w">            </span><span class="nv">ans</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span>
<span class="nv">print</span><span class="ss">(</span><span class="nv">ans</span><span class="ss">)</span>
</code></pre></div>

<p>Figure 2: Model-generated code from GPT-2 1.5B. 18/18 test cases pass for the problem. Note that models were given in problems exactly as they they are formatted here, which even meant parsing LaTeX. For brevity, we exclude formatting instructions from this depicted problem.</p>
<ul>
<li>Standard Input Format problems generally lack starter code. Instead, the model is only provided with the problem and must output its answers to the STDOUT stream, such as by using print statements.</li>
</ul>
<p>For the call-based format problems, we prompt models using the following inputs:</p>
<div class="codehilite"><pre><span></span><code>&quot;\nQUESTION:\n&quot; + q_str + &quot;\n&quot; + starter_code_str + &quot;\n&quot; + &quot;\nUse
Call-Based Format\n\nANSWER:\n&quot;
</code></pre></div>

<p>For the above prompt, the variable q_str represents the raw text of the problem statement. The variable starter_code_str represents the starter code given in the problem definition, or the empty string if no starter code was provided. For the standard input format problems, we prompt the model with the input string as before, but we replace "Call-Based Format" with "Standard Input Format." Note that if starter code is given, it is only part of the input. This means that to use the starter code, a model must learn to copy the starter code at the beginning of its outputted answer in order to get the question correct. We find that fine-tuned models are able to do this without difficulty.</p>
<p>Test Case Quality. In the APPS test split, the average number of test cases is 21.2 , but some problems only have two test cases. These problems mainly come from Kattis and were chosen for the test split due to limited numbers of competition problems. A potential concern is that these problems could result in false positives if models happen to guess both test cases correctly. This is very unlikely in problems with large output spaces, but some problems have small output spaces, such as {"YES", "NO"}. Although the model must narrow down these two options from the space of all possible strings, we find that this is not difficult for current models to accomplish, and this may cause false positives in our evaluation.
To quantify the impact of these problems, we took all 2- and 3-test-case problems that GPT-Neo 2.7B passed and manually checked for false positives. Out of 12 problems that the model got correct with 2 test cases, 8 were false positives. Out of 6 problems with 3 test cases, only 1 was a false positive. Since the test cases are from coding challenge websites with many users, we can assume that false negatives are absent. Thus, the false positive rate with 2 test cases is $8 /(890-4)=0.009&lt;1 \%$ and $1 /(765-5)=0.001&lt;1 \%$ with 3 test cases. The upshot is that the potential for noise is significantly less than that of most naturally annotated datasets.</p>
<h1>Problem</h1>
<p>You are given two integers $n$ and $m$. Calculate the number of pairs of arrays $(a, b)$ such that: the length of both arrays is equal to $m$; each element of each array is an integer between 1 and $n$ (inclusive); $a_{i} \leq b_{i}$ for any index $i$ from 1 to $m$; array $a$ is sorted in non-descending order; array $b$ is sorted in non-ascending order. As the result can be very large, you should print it modulo $10^{9}+7$. Input: The only line contains two integers $n$ and $m(1 \leq n \leq 1000,1 \leq m \leq 10)$. Output: Print one integer - the number of arrays $a$ and $b$ satisfying the conditions described above modulo $10^{9}+7$.</p>
<h2>Model Output</h2>
<div class="codehilite"><pre><span></span><code><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">map</span><span class="p">(</span><span class="nc">int</span><span class="p">,</span><span class="w"> </span><span class="k">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
<span class="k">mod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="o">**</span><span class="mi">9</span><span class="o">+</span><span class="mi">7</span>
<span class="n">fact</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">1, 1</span><span class="o">]</span>
<span class="n">factinv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">1, 1</span><span class="o">]</span>
<span class="n">inv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">0, 1</span><span class="o">]</span>
<span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="k">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="err">:</span>
<span class="w">    </span><span class="n">fact</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">fact</span><span class="o">[</span><span class="n">-1</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="k">mod</span><span class="p">)</span>
<span class="w">    </span><span class="n">inv</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="o">-</span><span class="n">inv</span><span class="o">[</span><span class="n">mod % i</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="k">mod</span><span class="o">//</span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="k">mod</span><span class="p">)</span>
<span class="w">    </span><span class="n">factinv</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">factinv</span><span class="o">[</span><span class="n">-1</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">inv</span><span class="o">[</span><span class="n">-1</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="k">mod</span><span class="p">)</span>
<span class="n">def</span><span class="w"> </span><span class="n">cmb</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="k">mod</span><span class="p">)</span><span class="err">:</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="err">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">fact</span><span class="o">[</span><span class="n">n</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">factinv</span><span class="o">[</span><span class="n">r</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">factinv</span><span class="o">[</span><span class="n">n-r</span><span class="o">]</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="k">mod</span>
<span class="k">print</span><span class="p">((</span><span class="n">cmb</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="k">mod</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cmb</span><span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">mod</span><span class="p">))</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="k">mod</span><span class="p">)</span>
</code></pre></div>

<p>Figure 3: An example from GPT-2 1.5B. Although the code generated passes 0 test cases, it looks plausible at first glance.</p>
<h2>4 Experiments</h2>
<h3>4.1 Experimental Setup</h3>
<p>Models. We use GPT-2 (Radford et al., 2019), GPT-3 (Brown et al., 2020), and GPT-Neo (Black et al., 2021) models. The GPT architecture is especially appropriate for text generation because it is autoregressive. However, GPT-2 was not pretrained on code, so we pretrain it on GitHub as described in the next paragraph. Anecdotal evidence indicates that GPT-3 can generate code. To determine the extent of its code generation ability, we use the 'davinci' (Instruct series) model, the largest publicly available model speculated to have 175 billion parameters. Finally, GPT-Neo has an architecture similar to GPT-3, and it was pretrained on the Pile (Gao et al., 2020) which includes GitHub. Unlike GPT-3, GPT-Neo's weights are publicly available, hence we are able to fine-tune it with APPS.</p>
<p>GPT-2 Pretraining. Since GPT-2 was trained on natural language and not code, we collected GitHub code to further pretrain GPT-2. GitHub repositories with fewer than one star were filtered out. While Neo's GitHub pretraining data did not undergo an APPS data decontamination process, our GPT-2 models are trained on decontaminated data. Specifically, all repositories matching certain keywords that would suggest overlap with common programming exercises were removed. We provide the list of keywords in the Supplementary Materials. We also discard any GitHub code that contains functions with the same signatures as functions in the starter code in many of our APPS problems. This leaves us with 30 GB of Python code. To improve the efficiency of pretraining, we process all Python code in the pretraining dataset by converting from spaces to tabs, which saves the character conversion when running model tokenizers.</p>
<p>Fine-tuning. During fine-tuning with APPS, the objective is to predict the entire code solution, given both the English text problem statement and the problem format (call-based format or standard input format). For problems with starter code, we exclude the starter code from the training loss.</p>
<table>
<thead>
<tr>
<th></th>
<th>Test Case Average</th>
<th></th>
<th></th>
<th></th>
<th>Strict Accuracy</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Model</td>
<td>Introductory</td>
<td>Interview</td>
<td>Competitive</td>
<td>Average</td>
<td>Introductory</td>
<td>Interview</td>
<td>Competition</td>
<td>Average</td>
</tr>
<tr>
<td>1-2 0.1B</td>
<td>5.64</td>
<td>6.93</td>
<td>4.37</td>
<td>6.16</td>
<td>1.00</td>
<td>0.33</td>
<td>0.00</td>
<td>0.40</td>
</tr>
<tr>
<td>GPT-2 1.5B</td>
<td>7.40</td>
<td>9.11</td>
<td>5.05</td>
<td>7.96</td>
<td>1.30</td>
<td>0.70</td>
<td>0.00</td>
<td>0.68</td>
</tr>
<tr>
<td>GPT-Neo 2.7B</td>
<td>14.68</td>
<td>9.85</td>
<td>6.54</td>
<td>10.15</td>
<td>3.90</td>
<td>0.57</td>
<td>0.00</td>
<td>1.12</td>
</tr>
<tr>
<td>GPT-3 175B</td>
<td>0.57</td>
<td>0.65</td>
<td>0.21</td>
<td>0.55</td>
<td>0.20</td>
<td>0.03</td>
<td>0.00</td>
<td>0.06</td>
</tr>
</tbody>
</table>
<p>Table 2: Average percentage of test cases passed and strict accuracy for each model and difficulty level. All values are percentages. Note ‘0.1B’ indicates the number of model parameters in billions. GPT-3 is a few-shot model and not fine-tuned, unlike the other models. GPT-Neo does best and attains approximately 4% strict accuracy on Introductory problems, and for these problems it passes approximately 15% of the test cases.</p>
<p>Across pretraining and fine-tuning, we use the AdamW optimizer <em>Loshchilov and Hutter (2019)</em>, a batch size of 256, and a weight decay of 0.05. We fine-tune for 10 epochs. We use DeepSpeed and its implementation of the ZeRO optimizer to reduce memory consumption while training large models <em>Rasley et al. (2020); Rajbhandari et al. (2020)</em>. Unless otherwise specified, we use the default HuggingFace generation parameters, except that we use beam search with a beam size of 5. Models are fine-tuned on 8 A100 GPUs.</p>
<h3>4.2 Metrics</h3>
<p>To obtain a comprehensive evaluation of code generation ability, we use the large bank of test cases and ground-truth solutions provided with APPS. Test cases allow for automatic evaluation, even though the the space of possible programs can be combinatorially large. Therefore, unlike many other text generation tasks, manual analysis is not necessary. We aggregate the generated code’s performance on test cases with two metrics, “test case average” and “strict accuracy.”</p>
<p>Test Case Average. We compute the average fraction of test cases passed. Concretely, let the number of problems in the test set be $P$. For a given problem $p$, let the code generated to solve problem $p$ be denoted $\langle\operatorname{code}<em p_c="p,c">{p}\rangle$, and set of test cases for problem $p$ be ${\langle x</em>\rangle}},y_{p,c<em p="p">{c=1}^{C</em>$. Then the test case average is}</p>
<p>$\frac{1}{P}\sum_{p=1}^{P}\frac{1}{C_{p}}\sum_{c=1}^{C_{p}}\mathbb{1}{\operatorname{eval}(\langle\operatorname{code}<em p_c="p,c">{p}\rangle,x</em>}.$})=y_{p,c</p>
<p>Oftentimes, solutions can successfully pass a subset of the test cases but not cover every corner case. This allows for less stringent model evaluation, as strict accuracy may currently obscure model improvements.</p>
<p>Strict Accuracy. Eventually, generated solutions should pass all test cases including corner cases. To compute the strict accuracy which requires programs pass every test case, we run the code generated by the model on every test case of every problem. Strict accuracy is then computed by taking the number of solutions passing every test case divided by the total number of exercises. Using the notation from before, we can write the strict accuracy as $\frac{1}{P}\sum_{p=1}^{P}\prod_{c=1}^{C_{p}}\mathbb{1}{\operatorname{eval}(\langle\operatorname{code}<em p_c="p,c">{p}\rangle,x</em>}$. Future research may only use strict accuracy when models become sufficiently capable.})=y_{p,c</p>
<h3>4.3 Model Performance Analysis</h3>
<p>Qualitative Output Analysis. Models can sometimes generate correct or superficially plausible code. Figure 2 shows code generated by GPT-2 1.5B that passes all test cases. When models do not pass the test cases, sometimes their generated code still appears plausible at first glance. For example, in Figure 3, we see that the 1.5B parameter model generates code that is related to the problem statement and makes a plausible attempt to solve it.</p>
<p>Test Case Evaluation. We show the main results in Table 2. We observe that models are able to generate code that passed some test cases, implying many generated programs are free of syntax errors and can successfully process inputs test cases to produce correct answers. Note that for Introductory questions, GPT-Neo passes approximately 15% of the test cases. We visualize Test Case Average</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 4: The average percentage of test cases passed increases with larger fine-tuned models.</p>
<p>Figure 5: Syntax errors decrease exponentially with fine-tuning and increased model sizes. GPT-Neo 2.7B has very few syntax errors.</p>
<p>Results in Figure 4. This demonstrates models are showing marked improvements on code generation and now starting to have traction on code generation.</p>
<p>Performance can be further improved by sampling multiple solutions and selecting the best. Here, we perform beam search with beam width 5 and evaluate its 5 beams, so that each model has five attempts to get a problem correct rather than one. With this setup, GPT-Neo's strict accuracy on Introductory problem then exceeds 5%, as shown in Table 3. Our results in the Supplementary Materials show that the top-5 test case average GPT-2 0.1B is 10.75 while the top-1 test case average of GPT-2 1.5B is 7.96. This highlights that simply sampling multiple candidate solutions is a powerful way to markedly improve performance.</p>
<p>Our results also provide us with information about the importance of model choice. Evidently existing few-shot GPT-3 models are not necessarily better at code generation than fine-tuned models that are smaller by two orders of magnitude. Additionally, performance improvement from GPT-2 1.5B to GPT-Neo 2.7B is larger than that from GPT-2 0.1B to GPT-2 1.5B. Potential causes of GPT-Neo's better performance are that GPT-Neo is trained on more code from GitHub, it has more parameters, or its architecture hyperparameters were chosen better. Memorization explaining all performance is an implausible explanation as performance tracks problem difficulty; were models just memorizing, we would expect uniform performance across difficulties. Since models still have large room for improvement, solving the APPS benchmark without unreasonable amounts of computational resources may require architectural or algorithmic improvements.</p>
<table>
<thead>
<tr>
<th>Top-1</th>
<th>Top-5</th>
</tr>
</thead>
<tbody>
<tr>
<td>Test Case Average</td>
<td>14.7%</td>
</tr>
<tr>
<td>Strict Accuracy</td>
<td>3.9%</td>
</tr>
</tbody>
</table>
<p>Table 3: GPT-Neo 2.7B performance on introductory problems using one generated program (Top-1) and the best of five generated programs (Top-5). Full results are in the Supplementary Materials.</p>
<p><strong>Syntax Errors.</strong> We now assess the frequency of syntax errors, errors that prevent the program from being interpreted including inconsistent spacing, unbalanced brackets, missing colons, and so on. Syntax errors are identified in our testing framework based on the heuristic of whether pyext is able to load the generated code as a Python module. For our purposes, this almost exclusively occurs for syntax errors. We visualize the prevalence of syntax errors in Figure 5. While approximately 59% of GPT-3's generated solutions for introductory problems have syntax errors, GPT-Neo syntax error frequency is approximately 3%. Note that recent work such as Yasunaga and Liang (2020) create a separate model to repair source code to fix compilation issues, but our results suggest that such efforts may be unnecessary in the future as syntax error frequency is sharply decreasing automatically.</p>
<p>BLEU. We find that assessing model performance with BLEU is a poor substitute for evaluating with test cases. To evaluate BLEU, we take the generated solution and compute its BLEU with each human-written solution for a given problem; we then record the highest BLEU score. Observe in Figure 6 that BLEU increases as problem sources become more difficult, even though models actually perform worse on harder problems. Moreover, worse models can have similar or higher BLEU scores. For example, GPT-2 0.1B has 26.8, 29.7, and 30.2 as BLEU scores for introductory, interview, and competition problems, respectively. Meanwhile GPT-Neo 2.7B has 27.1, 29.1, and 29.3 as its BLEU scores, respectively. Hence BLEU wrongly suggests GPT-Neo is a worse model.</p>
<p>Evaluating GPT-3. We evaluate GPT-3 175B on APPS in a few-shot setting. A separate prompt is used for standard input and call-based questions, and each prompt includes instruction text along with two example questions and solutions from the corresponding question type. We find that GPT-3 only solves 3 problems out of 5,000: two introductory problems and one interview problem. The two introductory problems are simple interpretation tasks, such as implementing a specified algebraic expression. The interview problem requires higher-level thinking that suggests nontrivial reasoning. However, it is possible that GPT-3 memorized the solution during pretraining, or that it took a lucky guess based on heuristics in the question. One potential factor in GPT-3’s poor performance is that it handles syntax poorly. Namely, we observed cases where improper formatting of otherwise functioning code causes a syntax error. For specific examples and more details, see the Supplementary Materials.</p>
<p>Evaluations on Larger Models. Since the public release of APPS, several others have trained even larger models on APPS than we evaluate here. OpenAI Codex is a 12B parameter Transformer language model pre-trained on large quantities of public code and comments. Chen et al. (2021) evaluate Codex on APPS under various configurations and achieve top-1 and top-5 accuracy on introductory problems of 4.14% and 9.65% respectively, close to double the top-5 accuracy of GPT-Neo 2.7B. Furthermore, by scaling up to a top-1000 evaluation they obtain 25% accuracy. This demonstrates that larger models trained specifically for code generation can improve APPS performance even further, but are still far from solving the task.</p>
<h2>5 Conclusion</h2>
<p>We introduced APPS, a benchmark of 10,000 Python programming problems. Unlike prior work that focused on pseudocode to code generation or translation between programming languages, our benchmark measures how well language models can generate python code given natural language specifications. By performing extensive quality assurance and including hundreds of thousands of test cases and ground-truth solutions across different difficulty levels, we created a comprehensive and rigorous testbed for evaluating models. We assessed state-of-the-art generative models on our benchmark and found that overall performance was low. However, the prevalence of syntax errors decreased exponentially as models improved, and recent models such as GPT-Neo solved over 5% of our introductory problems. As models become more competent at code generation, it is important to have a proxy for tracking this capability which could one day result in automation or malicious code generation. The APPS benchmark can provide an important measure for tracking upstream program synthesis advancements.</p>
<h1>References</h1>
<p>Miltiadis Allamanis and Charles Sutton. Mining source code repositories at massive scale using language modeling. In 2013 10th Working Conference on Mining Software Repositories (MSR), pages 207-216. IEEE, 2013.
Rajeev Alur, Dana Fisman, Saswat Padhi, Rishabh Singh, and Abhishek Udupa. Sygus-comp 2018: Results and analysis. SYNT, 2018.
Yonatan Bisk, Rowan Zellers, Ronan Le Bras, Jianfeng Gao, and Yejin Choi. Piqa: Reasoning about physical commonsense in natural language, 2019.
Sid Black, Leo Gao, Phil Wang, Connor Leahy, and Stella Biderman. GPT-Neo: Large Scale Autoregressive Language Modeling with Mesh-Tensorflow, March 2021. URL https://doi.org/ 10.5281/zenodo. 5297715 . If you use this software, please cite it using these metadata.
T. Brown, B. Mann, Nick Ryder, Melanie Subbiah, J. Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, Sandhini Agarwal, Ariel Herbert-Voss, G. Krüger, T. Henighan, R. Child, Aditya Ramesh, D. Ziegler, Jeffrey Wu, Clemens Winter, Christopher Hesse, Mark Chen, E. Sigler, Mateusz Litwin, Scott Gray, Benjamin Chess, J. Clark, Christopher Berner, Sam McCandlish, A. Radford, Ilya Sutskever, and Dario Amodei. Language models are few-shot learners. ArXiv, abs/2005.14165, 2020.
Jonathon Cai, Richard Shin, and D. Song. Making neural programming architectures generalize via recursion. 2017.
Mark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Ponde, Jared Kaplan, Harri Edwards, Yura Burda, Nicholas Joseph, Greg Brockman, et al. Evaluating large language models trained on code. arXiv preprint arXiv:2107.03374, 2021.
Aditya Desai, Sumit Gulwani, Vineet Hingorani, Nidhi Jain, Amey Karkare, Mark Marron, and Subhajit Roy. Program synthesis using natural language. In Proceedings of the 38th International Conference on Software Engineering, pages 345-356, 2016.
Leo Gao, Stella Biderman, Sid Black, Laurence Golding, Travis Hoppe, Charles Foster, Jason Phang, Horace He, Anish Thite, Noa Nabeshima, et al. The pile: An 800gb dataset of diverse text for language modeling. arXiv preprint arXiv:2101.00027, 2020.
Timnit Gebru, Jamie Morgenstern, Briana Vecchione, Jennifer Wortman Vaughan, Hanna Wallach, Hal Daumeé III, and Kate Crawford. Datasheets for datasets. arXiv preprint arXiv:1803.09010, 2018.</p>
<p>Sumit Gulwani, Oleksandr Polozov, and R. Singh. Program synthesis. Found. Trends Program. Lang., $4: 1-119,2017$.
Dan Hendrycks, Collin Burns, Steven Basart, Andrew Critch, Jerry Li, Dawn Song, and Jacob Steinhardt. Aligning AI with shared human values. Proceedings of the International Conference on Learning Representations (ICLR), 2021a.
Dan Hendrycks, Collin Burns, Steven Basart, Andy Zou, Mantas Mazeika, Dawn Song, and Jacob Steinhardt. Measuring massive multitask language understanding. Proceedings of the International Conference on Learning Representations (ICLR), 2021b.
Dan Hendrycks, Collin Burns, Saurav Kadavath, Akul Arora, Steven Basart, Eric Tang, Dawn Song, and Jacob Steinhardt. Measuring mathematical problem solving with the math dataset. arXiv preprint arXiv:2103.03874, 2021c.
Lifu Huang, Ronan Le Bras, Chandra Bhagavatula, and Yejin Choi. Cosmos qa: Machine reading comprehension with contextual commonsense reasoning, 2019.
Srinivasan Iyer, Ioannis Konstas, Alvin Cheung, and Luke Zettlemoyer. Mapping language to code in programmatic context. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, Brussels, Belgium, October-November 2018. Association for Computational Linguistics.
Sumith Kulal, Panupong Pasupat, Kartik Chandra, Mina Lee, Oded Padon, Alex Aiken, and Percy S Liang. Spoc: Search-based pseudocode to code. In Advances in Neural Information Processing Systems, volume 32, 2019.
Marie-Anne Lachaux, Baptiste Roziere, Lowik Chanussot, and Guillaume Lample. Unsupervised translation of programming languages. arXiv preprint arXiv:2006.03511, 2020.</p>
<p>W. Ling, P. Blunsom, Edward Grefenstette, K. Hermann, Tomás Kociský, Fumin Wang, and A. Senior. Latent predictor networks for code generation. ArXiv, abs/1603.06744, 2016.
Hui Liu, Mingzhu Shen, Jiaqi Zhu, Nan Niu, Ge Li, and Lu Zhang. Deep learning based program generation from requirements text: Are we there yet? IEEE Transactions on Software Engineering, 2020a.
J. Liu, Leyang Cui, Hanmeng Liu, Dandan Huang, Yile Wang, and Yue Zhang. LogiQA: A challenge dataset for machine reading comprehension with logical reasoning. In IJCAI, 2020b.
I. Loshchilov and F. Hutter. Decoupled weight decay regularization. In ICLR, 2019.</p>
<p>Shuai Lu, Daya Guo, Shuo Ren, Junjie Huang, Alexey Svyatkovskiy, A. Blanco, C. Clément, Dawn Drain, Daxin Jiang, Duyu Tang, Ge Li, L. Zhou, Linjun Shou, Long Zhou, Michele Tufano, Ming Gong, Ming Zhou, N. Duan, N. Sundaresan, Shao Kun Deng, Shengyu Fu, and Shujie Liu. Codexglue: A machine learning benchmark dataset for code understanding and generation. 2021.
Yusuke Oda, Hiroyuki Fudaba, Graham Neubig, Hideaki Hata, Sakriani Sakti, Tomoki Toda, and Satoshi Nakamura. Learning to generate pseudo-code from source code using statistical machine translation. In International Conference on Automated Software Engineering (ASE), 2015.
Kishore Papineni, Salim Roukos, Todd Ward, and Wei-Jing Zhu. Bleu: a method for automatic evaluation of machine translation. In Proceedings of the 40th annual meeting of the Association for Computational Linguistics, pages 311-318, 2002.
Stanislas Polu and Ilya Sutskever. Generative language modeling for automated theorem proving. ArXiv, abs/2009.03393, 2020.
Alec Radford, Jeffrey Wu, Rewon Child, David Luan, Dario Amodei, and Ilya Sutskever. Language models are unsupervised multitask learners. OpenAI blog, 1(8):9, 2019.
Samyam Rajbhandari, Jeff Rasley, Olatunji Ruwase, and Yuxiong He. Zero: Memory optimizations toward training trillion parameter models, 2020.
Jeff Rasley, Samyam Rajbhandari, Olatunji Ruwase, and Yuxiong He. Deepspeed: System optimizations enable training deep learning models with over 100 billion parameters. Proceedings of the 26th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, 2020.
Veselin Raychev, Pavol Bielik, and Martin T. Vechev. Probabilistic model for code with decision trees. Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications, 2016.
Mohammad Raza, Sumit Gulwani, and Natasa Milic-Frayling. Compositional program synthesis from natural language and examples. In IJCAI, 2015.
Shuo Ren, Daya Guo, Shuai Lu, L. Zhou, Shujie Liu, Duyu Tang, M. Zhou, A. Blanco, and S. Ma. Codebleu: a method for automatic evaluation of code synthesis. ArXiv, abs/2009.10297, 2020.
L. Tang and R. Mooney. Using multiple clause constructors in inductive logic programming for semantic parsing. In ECML, 2001.
Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, L. Kaiser, and Illia Polosukhin. Attention is all you need. ArXiv, abs/1706.03762, 2017.</p>
<p>Alex Wang, Yada Pruksachatkun, Nikita Nangia, Amanpreet Singh, Julian Michael, Felix Hill, Omer Levy, and Samuel Bowman. Superglue: A stickier benchmark for general-purpose language understanding systems. In NeurIPS, 2019a.
Alex Wang, Yada Pruksachatkun, Nikita Nangia, Amanpreet Singh, Julian Michael, Felix Hill, Omer Levy, and Samuel R. Bowman. Superglue: A stickier benchmark for general-purpose language understanding systems. In NeurIPS, 2019b.
Bailin Wang, Richard Shin, Xiaodong Liu, Oleksandr Polozov, and Matthew Richardson. Ratsql: Relation-aware schema encoding and linking for text-to-sql parsers. arXiv preprint arXiv:1911.04942, 2019c.
Michihiro Yasunaga and Percy Liang. Graph-based, self-supervised program repair from diagnostic feedback. ArXiv, abs/2005.10636, 2020.
Tao Yu, Rui Zhang, Kai Yang, Michihiro Yasunaga, Dongxu Wang, Zifan Li, James Ma, Irene Li, Qingning Yao, Shanelle Roman, et al. Spider: A large-scale human-labeled dataset for complex and cross-domain semantic parsing and text-to-sql task. arXiv preprint arXiv:1809.08887, 2018.</p>
<p>Maksym Zavershynskyi, A. Skidanov, and Illia Polosukhin. Naps: Natural program synthesis dataset. 2nd Workshop on Neural Abstract Machines and Program Induction, 2018.
J. Zelle and R. Mooney. Learning to parse database queries using inductive logic programming. In AAAI/IAAI, Vol. 2, 1996.
Rowan Zellers, Ari Holtzman, Yonatan Bisk, Ali Farhadi, and Yejin Choi. Hellaswag: Can a machine really finish your sentence?, 2019.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: center;">Hearthstone</th>
<th style="text-align: center;">Django</th>
<th style="text-align: center;">NAPS</th>
<th style="text-align: center;">APPS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Programming Language</td>
<td style="text-align: center;">Python</td>
<td style="text-align: center;">Python</td>
<td style="text-align: center;">UAST</td>
<td style="text-align: center;">Python</td>
</tr>
<tr>
<td style="text-align: left;">Test Cases</td>
<td style="text-align: center;">$\times$</td>
<td style="text-align: center;">$\times$</td>
<td style="text-align: center;">$\checkmark$</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: left;">Number of Programs</td>
<td style="text-align: center;">665</td>
<td style="text-align: center;">18,805</td>
<td style="text-align: center;">17,477</td>
<td style="text-align: center;">232,421</td>
</tr>
<tr>
<td style="text-align: left;">Lines per Program (Avg.)</td>
<td style="text-align: center;">7.7</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">21.7</td>
<td style="text-align: center;">18.0</td>
</tr>
<tr>
<td style="text-align: left;">Number of Exercises</td>
<td style="text-align: center;">665</td>
<td style="text-align: center;">18,805</td>
<td style="text-align: center;">2,231</td>
<td style="text-align: center;">10,000</td>
</tr>
<tr>
<td style="text-align: left;">Text Input</td>
<td style="text-align: center;">Card Text</td>
<td style="text-align: center;">Comment</td>
<td style="text-align: center;">Pseudocode</td>
<td style="text-align: center;">Problem Descriptions</td>
</tr>
</tbody>
</table>
<p>Table 4: Further comparisons of APPS with previous datasets.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Model</th>
<th style="text-align: center;">Top-5 Test Case Average</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Average</th>
<th style="text-align: center;">Top-5 Strict Accuracy</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Average</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Introductory</td>
<td style="text-align: center;">Interview</td>
<td style="text-align: center;">Competitive</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Introductory</td>
<td style="text-align: center;">Interview</td>
<td style="text-align: center;">Competition</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">GPT-2 0.1B</td>
<td style="text-align: center;">13.81</td>
<td style="text-align: center;">10.97</td>
<td style="text-align: center;">7.03</td>
<td style="text-align: center;">10.75</td>
<td style="text-align: center;">2.70</td>
<td style="text-align: center;">0.73</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">1.02</td>
</tr>
<tr>
<td style="text-align: center;">GPT-2 1.5B</td>
<td style="text-align: center;">16.86</td>
<td style="text-align: center;">13.84</td>
<td style="text-align: center;">9.01</td>
<td style="text-align: center;">13.48</td>
<td style="text-align: center;">3.60</td>
<td style="text-align: center;">1.03</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">1.34</td>
</tr>
<tr>
<td style="text-align: center;">GPT-Neo 2.7B</td>
<td style="text-align: center;">19.89</td>
<td style="text-align: center;">13.19</td>
<td style="text-align: center;">9.90</td>
<td style="text-align: center;">13.87</td>
<td style="text-align: center;">5.50</td>
<td style="text-align: center;">0.80</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">1.58</td>
</tr>
</tbody>
</table>
<p>Table 5: Top-5 performance of GPT-2 models and GPT-Neo. Taking the best of five candidate solutions markedly improves performance.</p>
<h1>A Auxiliary Dataset Information</h1>
<p>Legal Compliance. In APPS, we scrape question text, ground-truth solutions, and test cases from various coding challenge websites. These websites are AtCoder, CodeChef, Codeforces, Codewars, HackerRank, Kattis, and LeetCode. In all cases, we only scrape public-facing data. For instance, we avoid scraping data from paywalled portions of sites. In the case of Kattis, all problems we scrape are under the CC BY-SA 3.0 license (https://creativecommons.org/licenses/by-sa/3.0/). For other websites, some content may be copyrighted. In these cases, we abide by Fair Use §107: "the fair use of a copyrighted work, including such use by ... scholarship, or research, is not an infringement of copyright", where fair use is determined by "the purpose and character of the use, including whether such use is of a commercial nature or is for nonprofit educational purposes", "the amount and substantiality of the portion used in relation to the copyrighted work as a whole", and "the effect of the use upon the potential market for or value of the copyrighted work." The APPS dataset is noncommercial and is likely to have no effect on the value of the original problems. Moreover, for all problem sources, we only scrape a fraction of the available problems and ground-truth solutions.
Regarding international copyright laws, the websites that we scrape from are based in the United States, Japan, India, and Russia, all of which are contracting parties to the WIPO Copyright Treaty. In the United States, the WIPO Copyright Treaty is implemented by the Digital Millenium Copyright Act (DMCA). Since APPS was made in the United States, the DMCA is the relevant legislation that we must comply with. Notably, DMCA $\S 1201$ states, "No person shall circumvent a technological measure that effectively controls access to a work protected under this title." We do not circumvent access controls when creating APPS and hence abide by $\S 1201$. Fair Use extends to content protected by the DMCA, for which we refer readers to the previous paragraph.
Although GDPR only applies in the European Union, some of the ground-truth solutions in APPS may have been written by EU citizens. GDPR is chiefly concerned with the protection of personal data gathered by entities engaging in economic activity. The only personally linked information in APPS is the problem solutions written by individuals and published under aliases to public websites. In some cases, these solutions contain identifying information in comments, which we remove to preserve privacy. We comply with GDPR, because our processed solutions remove identifiers, and we are compliant because we collect the data for academic research purposes.</p>
<p>Author Statement and License. We bear all responsibility in case of violation of rights. The APPS data is licensed under CC BY-SA 3.0 in accordance with the Kattis problem licenses and the ShareAlike terms. Our code is open sourced under the MIT license.</p>
<h1>B Datasheets</h1>
<p>We follow the recommendations of Gebru et al. (2018) and provide a datasheet for the ETHICS dataset in this section.</p>
<h2>B. 1 Motivation</h2>
<p>For what purpose was the dataset created? Was there a specific task in mind? Was there a specific gap that needed to be filled? Please provide a description. The APPS dataset was created to track the progress of code generation models on the task of generating arbitrary Python code from complex natural language specifications, a challenging setting that had no rigorous benchmark before our work.</p>
<p>Who created the dataset (e.g., which team, research group) and on behalf of which entity (e.g., company, institution, organization)? Refer to the main document.</p>
<p>Who funded the creation of the dataset? If there is an associated grant, please provide the name of the grantor and the grant name and number. There is no associated grant.</p>
<p>Any other comments? No.</p>
<h2>B. 2 Composition</h2>
<p>What do the instances that comprise the dataset represent (e.g., documents, photos, people, countries)? Are there multiple types of instances (e.g., movies, users, and ratings; people and interactions between them; nodes and edges)? Please provide a description. The instances are coding challenge problems posed in natural language, each of which consists of question text, ground-truth solutions, and test cases. Please refer to the main document for more detail.</p>
<p>How many instances are there in total (of each type, if appropriate)? APPS contains 10,000 problems, 232,421 ground-truth solutions, and 131,777 test cases.</p>
<p>Does the dataset contain all possible instances or is it a sample (not necessarily random) of instances from a larger set? If the dataset is a sample, then what is the larger set? Is the sample representative of the larger set (e.g., geographic coverage)? If so, please describe how this representativeness was validated/verified. If it is not representative of the larger set, please describe why not (e.g., to cover a more diverse range of instances, because instances were withheld or unavailable). APPS contains a subset of all possible test cases for its problems. These test cases are written by problem designers to cover important functionality.</p>
<p>What data does each instance consist of? "Raw" data (e.g., unprocessed text or images) or features? In either case, please provide a description. Each instance consists of text and numerical data.</p>
<p>Is there a label or target associated with each instance? If so, please provide a description. Each instance is associated with test cases, which provide a ground-truth signal for functional correctness.</p>
<p>Is any information missing from individual instances? If so, please provide a description, explaining why this information is missing (e.g., because it was unavailable). This does not include intentionally removed information, but might include, e.g., redacted text. No.</p>
<p>Are relationships between individual instances made explicit (e.g., users' movie ratings, social network links)? If so, please describe how these relationships are made explicit. We remove duplicate or near-duplicate problems from APPS.</p>
<p>Are there recommended data splits (e.g., training, development/validation, testing)? If so, please provide a description of these splits, explaining the rationale behind them. We provide a training and test split. The splits were optimized for increasing the number of test cases in the test split while maintaining a fixed number of problems from each difficulty.</p>
<p>Are there any errors, sources of noise, or redundancies in the dataset? If so, please provide a description. See Section 3 in the main paper for a discussion of test case quality.</p>
<p>Is the dataset self-contained, or does it link to or otherwise rely on external resources (e.g., websites, tweets, other datasets)? The dataset is self-contained.</p>
<p>Does the dataset contain data that might be considered confidential (e.g., data that is protected by legal privilege or by doctor-patient confidentiality, data that includes the content of individuals' non-public communications)? If so, please provide a description. No.</p>
<p>Does the dataset contain data that, if viewed directly, might be offensive, insulting, threatening, or might otherwise cause anxiety? If so, please describe why. Unknown.</p>
<p>Does the dataset relate to people? If not, you may skip the remaining questions in this section. Yes.</p>
<p>Does the dataset identify any subpopulations (e.g., by age, gender)? If so, please describe how these subpopulations are identified and provide a description of their respective distributions within the dataset. No.</p>
<p>Is it possible to identify individuals (i.e., one or more natural persons), either directly or indirectly (i.e., in combination with other data) from the dataset? If so, please describe how No.</p>
<p>Does the dataset contain data that might be considered sensitive in any way (e.g., data that reveals racial or ethnic origins, sexual orientations, religious beliefs, political opinions or union memberships, or locations; financial or health data; biometric or genetic data; forms of government identification, such as social security numbers; criminal history)? If so, please provide a description. No.</p>
<p>Any other comments? No.</p>
<h1>B. 3 Collection Process</h1>
<p>How was the data associated with each instance acquired? Was the data directly observable (e.g., raw text, movie ratings), reported by subjects (e.g., survey responses), or indirectly inferred/derived from other data (e.g., part-of-speech tags, model-based guesses for age or language)? If data was reported by subjects or indirectly inferred/derived from other data, was the data validated/verified? If so, please describe how. All data was collected by scraping problems from coding challenge websites, such as Codewars, AtCoder and Kattis.</p>
<p>What mechanisms or procedures were used to collect the data (e.g., hardware apparatus or sensor, manual human curation, software program, software API)? How were these mechanisms or procedures validated? We used off-the-shelf and custom-built scrapers. We manually checked whether scraped data matched text on the websites.</p>
<p>If the dataset is a sample from a larger set, what was the sampling strategy (e.g., deterministic, probabilistic with specific sampling probabilities)? Some problems we scraped were left out of APPS for various reasons, e.g. they required images to solve, they lacked ground-truth solutions and test cases, or they were duplicate problems.</p>
<p>Who was involved in the data collection process (e.g., students, crowdworkers, contractors) and how were they compensated (e.g., how much were crowdworkers paid)? All data was collected by undergraduate and graduate student authors on the paper.</p>
<p>Over what timeframe was the data collected? Does this timeframe match the creation timeframe of the data associated with the instances (e.g., recent crawl of old news articles)? If not, please describe the timeframe in which the data associated with the instances was created. Data was collected from late 2020 to early 2021 and refined for six months.</p>
<p>Were any ethical review processes conducted (e.g., by an institutional review board)? If so, please provide a description of these review processes, including the outcomes, as well as a link or other access point to any supporting documentation No.</p>
<p>Does the dataset relate to people? If not, you may skip the remainder of the questions in this section. Yes.</p>
<p>Did you collect the data from the individuals in question directly, or obtain it via third parties or other sources (e.g., websites)? We scraped data via websites where individuals had publicly posted problem solutions.</p>
<p>Were the individuals in question notified about the data collection? If so, please describe (or show with screenshots or other information) how notice was provided, and provide a link or other access point to, or otherwise reproduce, the exact language of the notification itself. Users who posted on the Internet were not notified of our collection, because their examples were posted publicly.</p>
<p>Did the individuals in question consent to the collection and use of their data? If so, please describe (or show with screenshots or other information) how consent was requested and provided, and provide a link or other access point to, or otherwise reproduce, the exact language to which the individuals consented. N/A</p>
<p>If consent was obtained, were the consenting individuals provided with a mechanism to revoke their consent in the future or for certain uses? If so, please provide a description, as well as a link or other access point to the mechanism (if appropriate). N/A</p>
<p>Has an analysis of the potential impact of the dataset and its use on data subjects (e.g., a data protection impact analysis) been conducted? If so, please provide a description of this analysis, including the outcomes, as well as a link or other access point to any supporting documentation. No.</p>
<p>Any other comments? No.</p>
<h1>B. 4 Preprocessing/Cleaning/Labeling</h1>
<p>Was any preprocessing/cleaning/labeling of the data done (e.g., discretization or bucketing, tokenization, part-of-speech tagging, SIFT feature extraction, removal of instances, processing of missing values)? If so, please provide a description. If not, you may skip the remainder of the questions in this section. Yes, as described in Section 3 of the main paper.</p>
<p>Was the "raw" data saved in addition to the preprocessed/cleaned/labeled data (e.g., to support unanticipated future uses)? If so, please provide a link or other access point to the "raw" data. No.</p>
<p>Is the software used to preprocess/clean/label the instances available? If so, please provide a link or other access point. Not at this time.</p>
<p>Any other comments? No.</p>
<h2>B. 5 Uses</h2>
<p>Has the dataset been used for any tasks already? If so, please provide a description. Yes, see the main paper.</p>
<p>Is there a repository that links to any or all papers or systems that use the dataset? If so, please provide a link or other access point. No.</p>
<p>What (other) tasks could the dataset be used for? N/A
Is there anything about the composition of the dataset or the way it was collected and preprocessed/cleaned/labeled that might impact future uses? For example, is there anything that a future user might need to know to avoid uses that could result in unfair treatment of individuals or groups (e.g., stereotyping, quality of service issues) or other undesirable harms (e.g., financial harms, legal risks) If so, please provide a description. Is there anything a future user could do to mitigate these undesirable harms? We describe how our data collection is legally compliant in Appendix A.</p>
<p>Are there tasks for which the dataset should not be used? If so, please provide a description. N/A</p>
<p>Any other comments? No.</p>
<h1>B. 6 Distribution</h1>
<p>Will the dataset be distributed to third parties outside of the entity (e.g., company, institution, organization) on behalf of which the dataset was created? If so, please provide a description. Yes, the dataset will be publicly distributed.</p>
<p>How will the dataset will be distributed (e.g., tarball on website, API, GitHub)? Does the dataset have a digital object identifier (DOI)? The dataset is available at https://github.com/hendrycks/apps.</p>
<p>When will the dataset be distributed? The dataset is currently available.
Will the dataset be distributed under a copyright or other intellectual property (IP) license, and/or under applicable terms of use (ToU)? If so, please describe this license and/or ToU, and provide a link or other access point to, or otherwise reproduce, any relevant licensing terms or ToU, as well as any fees associated with these restrictions. The code for our experimental framework is distributed under an MIT license. Where applicable,</p>
<p>Have any third parties imposed IP-based or other restrictions on the data associated with the instances? If so, please describe these restrictions, and provide a link or other access point to, or otherwise reproduce, any relevant licensing terms, as well as any fees associated with these restrictions. In cases where websites that we scrape data from have copyright policies, we abide by Fair Use according to $\S 107$, and we comply with GDPR even though all our problem sources with ground-truth solutions are based in the US. See Appendix A for details.</p>
<p>Do any export controls or other regulatory restrictions apply to the dataset or to individual instances? If so, please describe these restrictions, and provide a link or other access point to, or otherwise reproduce, any supporting documentation. No.</p>
<p>Any other comments? No.</p>
<h2>B. 7 Maintenance</h2>
<p>Who is supporting/hosting/maintaining the dataset? Refer to the main document.
How can the owner/curator/manager of the dataset be contacted (e.g., email address)? Refer to the main document.</p>
<p>Is there an erratum? If so, please provide a link or other access point. Not at this time.</p>
<p>Will the dataset be updated (e.g., to correct labeling errors, add new instances, delete instances)? If so, please describe how often, by whom, and how updates will be communicated to users (e.g., mailing list, GitHub)? We plan to update the dataset with an additional JSON of test cases present in the question text for each problem. This will be available through GitHub.</p>
<p>If the dataset relates to people, are there applicable limits on the retention of the data associated with the instances (e.g., were individuals in question told that their data would be retained for a fixed period of time and then deleted)? If so, please describe these limits and explain how they will be enforced No.</p>
<p>Will older versions of the dataset continue to be supported/hosted/maintained? If so, please describe how. If not, please describe how its obsolescence will be communicated to users. N/A</p>
<p>If others want to extend/augment/build on/contribute to the dataset, is there a mechanism for them to do so? If so, please provide a description. Will these contributions be validated/verified? If so, please describe how. If not, why not? Is there a process for communicating/distributing these contributions to other users? If so, please provide a description. Our dataset could be extended with additional problems that follow the formatting of existing problems.</p>
<p>Any other comments? No.</p>
<h1>C Additional Dataset Information</h1>
<p>Expanded Dataset Comparisons. We compared to several datasets in the (Kulal et al., 2019; Yu et al., 2018; Raychev et al., 2016; Iyer et al., 2018; Lu et al., 2021) main paper. We continue the comparisons below. Ling et al. (2016) introduce datasets based on Hearthstone and Magic the Gathering card games for code generation. Oda et al. (2015) provide a language-to-code dataset using simple code comments. Zavershynskyi et al. (2018) introduce the NAPS dataset for converting pseudocode to code, obtained by crowdsourcing low-level descriptions of programming exercises, and apply machine translation techniques to the problem. Recent anecdotal posts on social media have demonstrated that modern Transformers can in some instances generate JSX code adhering to user requests, but our work provides precision to the discussion through quantitative evaluation. Allamanis and Sutton (2013) introduce the GitHub Java Corpus used for performing language modeling on Java code. Liu et al. (2020a) do a smaller-scale analysis of code generation but with their limited language-specific training data models "fail to pass even a single predefined test case" on their 300 test problems, while with our large training set and test set, trained models can pass tens of thousands of test cases. Zelle and Mooney (1996) and Tang and Mooney (2001) precedes Yu et al. (2018) by also facilitating the synthesis of database queries, though more recent program synthesis works such as Wang et al. (2019c) use Spider from Yu et al. (2018).
Table 4 compares APPS to Hearthstone (Ling et al., 2016), Django (Oda et al., 2015), and Zavershynskyi et al. (2018). 'Number of Programs' refers to the number of human-written programs or functions in the dataset, and 'Number of Exercises' refers to the number of tasks that the network must solve. These numbers can differ in datasets such as APPS with multiple human-written solutions per exercise.</p>
<p>Excluded Keywords. In creating the GitHub pretraining dataset, we exclude the following keywords to prevent overlap with coding challenge questions similar to those in APPS: 'atcoder', 'coderbyte', 'leetcode', 'codeforces', 'codewars', 'hackerrank', 'topcoder', 'codechef', 'checkio', 'HackerEarth', 'Programmr', 'Exercism', 'Codier', 'PyBites', 'Tynker', 'CodinGame', 'CodeCombat', 'usaco', 'IOI', 'UVA', 'ICFP', 'EPIJudge', 'SPOJ', 'UVaOJ', 'judge', 'interview', 'solution', 'coding', 'code', 'problem', 'exercise', 'challenge', 'algo', 'practice', 'competitive', 'program'.</p>
<h2>D Additional Results</h2>
<p>Top-5 Performance. Rather than allowing models to generate just one potential solution, we let models generate five and we choose the best performing solution. Full top-5 performance results are in Table 5.</p>
<h1>Problem</h1>
<p>Mahmoud and Ehab play a game called the even-odd game. Ehab chooses his favorite integer $n$ and then they take turns, starting from Mahmoud. In each player's turn, he has to choose an integer $a$ and subtract it from $n$ such that: $1 \leq a \leq n$. If it's Mahmoud's turn, $a$ has to be even, but if it's Ehab's turn, $a$ has to be odd.
If the current player can't choose any number satisfying the conditions, he loses. Can you determine the winner if they both play optimally?
—Input-
The only line contains an integer $n\left(1 \leq n \leq 10^{9}\right)$, the number at the beginning of the game.
—Output-
Output "Mahmoud" (without quotes) if Mahmoud wins and "Ehab" (without quotes) otherwise.</p>
<h2>Model Output</h2>
<div class="codehilite"><pre><span></span><code><span class="nv">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">int</span><span class="ss">(</span><span class="nv">input</span><span class="ss">())</span>
<span class="k">if</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span>:
<span class="w">    </span><span class="nv">print</span><span class="ss">(</span><span class="s1">&#39;Mahmoud&#39;</span><span class="ss">)</span>
<span class="k">else</span>:
<span class="w">    </span><span class="nv">print</span><span class="ss">(</span><span class="s1">&#39;Ehab&#39;</span><span class="ss">)</span>
</code></pre></div>

<p>Figure 7: The sole interview problem solved by GPT-3. Legitimately solving this problem requires nontrivial reasoning about the proposed game's branching possibilities.</p>
<div class="codehilite"><pre><span></span><code><span class="nv">a</span>,<span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">int</span><span class="ss">(</span><span class="nv">input</span><span class="ss">())</span>,<span class="w"> </span><span class="nv">int</span><span class="ss">(</span><span class="nv">input</span><span class="ss">())</span>
<span class="k">if</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">b</span>:
<span class="nv">print</span><span class="ss">(</span><span class="s1">&#39;&#39;</span>.<span class="nv">join</span><span class="ss">(</span><span class="nv">map</span><span class="ss">(</span><span class="nv">str</span>,<span class="w"> </span>[<span class="nv">a</span>,<span class="w"> </span><span class="nv">b</span>]<span class="ss">)))</span>
<span class="k">else</span>:
<span class="nv">print</span><span class="ss">(</span><span class="s1">&#39;&#39;</span>.<span class="nv">join</span><span class="ss">(</span><span class="nv">map</span><span class="ss">(</span><span class="nv">str</span>,<span class="w"> </span>[<span class="nv">a</span>,<span class="w"> </span><span class="nv">b</span>]<span class="ss">)))</span>
</code></pre></div>

<p>Figure 8: Oftentimes, GPT-3 generates outputs with incorrect syntax, such as the above code. Even though the code is reasonable, bad formatting of the if-else block causes a syntax error.</p>
<p>GPT-3. We evaluate GPT-3 175B on APPS in a few-shot setting. A separate prompt is used for standard input and call-based questions, and each prompt includes instruction text along with two example questions and solutions from the corresponding question type. The solutions we select for each prompt are the shortest solutions passing all test cases for the corresponding problems. In preliminary experiments, we found that the original GPT-3 175B did not perform well, and the instruct series was necessary for reasonable generations. Inference on the 5,000 problems in the APPS test set is possible for approximately $\$ 500$.
We find that GPT-3 only solves 3 problems out of 5,000: two introductory problems and one interview problem. The two introductory problems are simple interpretation tasks, such as implementing a specified algebraic expression. The interview problem requires higher-level thinking and is show in Figure 7. Legitimately solving this problem would suggest nontrivial reasoning. However, it is possible that GPT-3 memorized the solution during pretraining, or that it took a lucky guess based on heuristics in the question.
We also find that GPT-3 tends to handle syntax poorly. In Figure 8, we see a generation with improper formatting of an if-else block, which causes a syntax error. By contrast, GPT-2 0.1B has fewer syntax errors with three orders of magnitude fewer parameters, and GPT-Neo 2.7B has almost no syntax errors. These two models are fine-tuned on GitHub and the APPS training set.</p>
<p>More Generated Code Examples. Additional examples of generated code can be found in Figure 9, Figure 10, and Figure 11.</p>
<h1>Problem</h1>
<p>Given is a directed graph $G$ with $N$ vertices and $M$ edges. The vertices are numbered 1 to $N$, and the i-th edge is directed from Vertex A_i to Vertex B_i. It is guaranteed that the graph contains no self-loops or multiple edges. Determine whether there exists an induced subgraph (see Notes) of G such that the in-degree and out-degree of every vertex are both 1 . If the answer is yes, show one such subgraph. Here the null graph is not considered as a subgraph.</p>
<h2>Model Output</h2>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">setrecursionlimit</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="mi">7</span><span class="p">)</span>
<span class="nb">input</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span>
<span class="n">f_inf</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
<span class="n">mod</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">9</span> <span class="o">+</span> <span class="mi">7</span>
<span class="k">def</span><span class="w"> </span><span class="nf">resolve</span><span class="p">():</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
    <span class="n">edge</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
        <span class="n">edge</span><span class="p">[</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">edge</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dfs</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span><span class="p">]</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">seen</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                <span class="k">continue</span>
                <span class="n">seen</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">seen</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                        <span class="k">continue</span>
                        <span class="n">seen</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">seen</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">seen</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">res</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">resolve</span><span class="p">()</span>
</code></pre></div>

<p>Figure 9: An example generated by GPT-2 1.5B. The model can sometimes compose function calls.</p>
<h1>Problem</h1>
<p>Given is a tree G with N vertices. The vertices are numbered 1 through N , and the i-th edge connects Vertex a_i and Vertex b_i. Consider painting the edges in G with some number of colors. We want to paint them so that, for each vertex, the colors of the edges incident to that vertex are all different. Among the colorings satisfying the condition above, construct one that uses the minimum number of colors.</p>
<h2>Model Output</h2>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span><span class="p">,</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">Counter</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="kp">accumulate</span><span class="p">,</span> <span class="kp">product</span><span class="p">,</span> <span class="n">permutations</span><span class="p">,</span> <span class="n">combinations</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">operator</span><span class="w"> </span><span class="kn">import</span> <span class="n">itemgetter</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">bisect</span><span class="w"> </span><span class="kn">import</span> <span class="n">bisect_left</span><span class="p">,</span> <span class="n">bisect_right</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">heapq</span><span class="w"> </span><span class="kn">import</span> <span class="n">heappop</span><span class="p">,</span> <span class="n">heappush</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="kp">ceil</span><span class="p">,</span> <span class="kp">floor</span><span class="p">,</span> <span class="kp">sqrt</span><span class="p">,</span> <span class="n">gcd</span><span class="p">,</span> <span class="kp">inf</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>
<span class="n">INF</span> <span class="o">=</span> <span class="kp">inf</span>
<span class="n">MOD</span> <span class="o">=</span> <span class="mi">1000000007</span>
<span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
<span class="n">ab</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="kp">split</span><span class="p">()))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ab</span><span class="p">:</span>
    <span class="n">graph</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="kp">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">graph</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="kp">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">color</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">y</span><span class="p">]:</span>
            <span class="k">continue</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">color</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">stack</span><span class="o">.</span><span class="kp">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="n">ans</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="n">ans</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<p>Figure 10: An additional generated example. Here, the model output has many import statements.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>*Equal Contribution.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>