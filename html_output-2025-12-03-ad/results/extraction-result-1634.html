<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-1634 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-1634</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-1634</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-31.html">extraction-schema-31</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <p><strong>Paper ID:</strong> paper-53288676</p>
                <p><strong>Paper Title:</strong> Computational Complexity Analysis of Genetic Programming</p>
                <p><strong>Paper Abstract:</strong> Genetic Programming (GP) is an evolutionary computation technique to solve problems in an automated, domain-independent way. Rather than identifying the optimum of a function as in more traditional evolutionary optimization, the aim of GP is to evolve computer programs with a given functionality. A population of programs is evolved using variation operators inspired by Darwinian evolution (crossover and mutation) and natural selection principles to guide the search process towards better programs. While many GP applications have produced human competitive results, the theoretical understanding of what problem characteristics and algorithm properties allow GP to be effective is comparatively limited. Compared to traditional evolutionary algorithms for function optimization, GP applications are further complicated by two additional factors: the variable length representation of candidate programs, and the difficulty of evaluating their quality efficiently. Such difficulties considerably impact the runtime analysis of GP where space complexity also comes into play. As a result initial complexity analyses of GP focused on restricted settings such as evolving trees with given structures or estimating the quality of solutions using only a small polynomial number of input/output examples. However, the first runtime analyses concerning GP applications for evolving proper functions with defined input/output behavior have recently appeared. In this chapter, we present an overview of the state-of-the-art.</p>
                <p><strong>Cost:</strong> 0.022</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e1634.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e1634.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Koza-GP</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Standard tree-based Genetic Programming (Koza)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Classic tree-based GP that represents programs as syntax trees and evolves them via subtree crossover, subtree mutation and selection using fitness on input/output training cases; widely used as the canonical crossover+mutation GP paradigm.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Genetic programming -on the programming of computers by means of natural selection.</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Standard tree-based Genetic Programming (Koza-style)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Evolves variable-length program syntax trees using population-based selection. Variation operators include subtree crossover (exchange of randomly chosen subtrees between two parents) and subtree mutation (replace a randomly-chosen subtree by a randomly-generated subtree), together with selection driven by fitness computed on a training set of input/output cases. Often combined with bloat-control heuristics (depth/size limits, parsimony pressure).</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Subtree crossover: select a random node in parent A and a random node in parent B; swap the entire subtrees rooted at those nodes to create two offspring. Crossover can copy large syntactic structure from both parents and potentially violate depth/size constraints (may be rejected or repaired).</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Typical subtree mutation: select a random node in the tree and replace its subtree by a newly randomly-generated subtree; other variants include point/substitution mutations, insertions and deletions.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>program synthesis, symbolic regression, Boolean function evolution, engineering design (antennas, lenses), MAX problem</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>mutation-only GP variants ((1+1) GP, RLS-GP), HVL-Prime based mutation, multi-objective/parsimony approaches</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Paper cites that standard Koza-style GP uses crossover + mutation but theoretical runtime analyses are scarce because crossover complicates rigorous analysis; empirical/theoretical evidence (MAX problem) shows crossover can interact poorly with depth bounds (deception) making crossover-based GP hard on some problems; consequently much theoretical work uses mutation-only algorithms for tractability.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1634.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e1634.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>(1+1)-GP</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>(1+1) Genetic Programming / RLS-GP</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A single-individual GP (population size 1) analyzed extensively in the paper; it uses HVL-Prime mutation (k sub-operations per iteration) to modify program trees and does not use crossover, enabling rigorous runtime analyses.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Computational complexity analysis of simple genetic programming on two problems modeling isolated program semantics.</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>(1+1) GP / RLS-GP</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Population of one individual X; in each generation an offspring X' is created by applying k ≥ 1 HVL-Prime mutation sub-operations to X (k = 1 for RLS-GP, k = 1 + Poisson(1) for (1+1) GP). The offspring replaces the parent if it does not decrease fitness (non-strict) or only if strictly better (elitist variant). No crossover or population-based recombination is used.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs (syntax trees)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>HVL-Prime: choose uniformly among INS, DEL, SUB. INS: choose a node, pick f∈F and l∈L, replace node by f with children (original node, l) with random order. DEL: choose a leaf and replace its parent by the leaf's sibling. SUB: replace a chosen node by a randomly selected terminal if leaf or function if internal. Applied k times per generation to permit larger changes without intermediate fitness evaluations.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Program fitness measured as disagreement/error on a training set (either complete truth table or sampled subset); e.g., number of misclassified truth-table rows, numeric evaluation value for MAX.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>Problem-specific runtime / performance bounds reported: ORDER expected optimization time O(n T_max); with lexicographic parsimony Θ(T_init + n log n) to optima. MAJORITY expected time between Ω(T_init + n log n) and O(T_init log T_init + n log^3 n). AND (complete truth table) expected optimization Θ(n log n). XOR: exponential time; RLS-GP requires >2^{Ω(n/log n)} iterations w.h.p. MAX: RLS-GP finds optimum in expected O(n log n) iterations (n = max nodes).</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>theoretical GP benchmarks: ORDER, MAJORITY, SORTING, AND, XOR, MAX; evolves Boolean and arithmetic programs</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Standard crossover-based GP (Koza), SMO-GP (Pareto GP), mutation-only variants (RLS-GP vs (1+1) GP), parsimony-controlled variants</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Mutation-only (1+1)-GP and RLS-GP are amenable to rigorous runtime analysis and are efficient on several targets (AND, MAX, ORDER under size bounds) but fail or take exponential time on others (XOR). Bloat (uncontrolled growth) and acceptance of neutral moves significantly affect runtimes; analyses demonstrate benefits of parsimony pressure and Pareto approaches to control bloat.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1634.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e1634.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>HVL-Prime</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Hierarchical Variable-Length Prime mutation operator (HVL-Prime)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A mutation operator for binary GP trees that performs small, hierarchical edits (insertion, deletion, substitution) chosen uniformly to mimic bitwise mutation while respecting tree structure and variable length.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Computational complexity analysis of simple genetic programming on two problems modeling isolated program semantics.</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>HVL-Prime mutation operator</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Per-application: pick op∈{INS,DEL,SUB} uniformly. INS: pick node x, pick function f∈F and terminal l∈L, replace x by f and set children to x and l (random order). DEL: pick a leaf x, replace its parent with x's sibling. SUB: pick node x, replace it by a random terminal (if leaf) or random function (if internal). Designed to make minimal hierarchical edits and to be analyzable.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs (syntax trees)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>As described: single HVL-Prime application changes tree minimally; in (1+1) GP it can be applied k times per offspring to allow larger changes.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Used as the standard mutation in theoretical analyses across ORDER, MAJORITY, SORTING, AND, XOR, MAX</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Standard subtree mutation, more permissive mutation operators; also compared within k=1 vs k=1+Poisson(1) variants</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>HVL-Prime permits small localized edits that make mathematical analysis tractable; using multiple HVL-Prime sub-operations per generation simulates larger mutations; operator design (probabilities of INS/DEL/SUB) affects drift toward or away from bloat.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1634.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e1634.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>SMO-GP</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Simple Multi-objective Genetic Programming (SMO-GP) / Pareto parsimony pressure</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A multi-objective GP algorithm that treats fitness and program size as two objectives and maintains a population approximating the Pareto front, using HVL-Prime mutation to produce offspring while minimizing bloat via Pareto selection.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Computational complexity analysis of multi-objective genetic programming.</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>SMO-GP (Pareto parsimony pressure)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Maintains population P of non-dominated solutions (fitness vs size). Each iteration: select parent uniformly from P, apply HVL-Prime k times to produce offspring; if offspring not strictly dominated by any in P add it and remove any solutions it weakly dominates. Aims to compute/approximate the Pareto front to trade off complexity and fitness.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs (syntax trees)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>HVL-Prime applied k times per offspring (k = 1 or 1+Poisson(1)).</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Fitness measured as usual per problem (e.g., number of expressed literals, training-set error) and program size as second objective.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>Runtime bounds for computing Pareto front: ORDER expected optimization time O(n T_init + n^2 log n) (Theorem 5); WORDER/WMAJORITY bounds given (e.g., O(T_init^2 + n^2 T_init + n^3) for k=1). Population size P_max may be large (worst-case exponential).</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Pareto front diversity (multi-objective diversity across fitness vs size axis)</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td>Population upper-bounded by number of distinct fitness values (e.g., ≤ n+1 for MAJORITY); however P_max may be exponential in worst cases (WMAJORITY).</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Described qualitatively: Pareto approach explicitly trades smaller program size (parsimony) vs fitness; no explicit novelty-vs-executability quantitative curve provided.</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td>Paper analyzes Pareto front construction times and population sizes; characterizes time to obtain whole front with stated asymptotic bounds but no continuous novelty-executability curve.</td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>ORDER, WORDER, MAJORITY, WMAJORITY, SORTING</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>(1+1) GP, RLS-GP with/without lexicographic parsimony pressure, standard GP</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>SMO-GP with Pareto parsimony can avoid bloat and construct Pareto fronts efficiently in many settings (provable runtime bounds). However, worst-case population size can be large and some bounds depend on initial tree size or P_max; Pareto selection provides an effective mechanism for balancing solution complexity and fitness.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1634.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e1634.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Linear-GP (identification)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Linear Genetic Programming algorithm for the identification (PAC) problem</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A simplified GP-style evolutionary method that searches weight assignments of a fixed linear function by flipping single weights per mutation and evaluates candidates on sampled training sets within the PAC-learning framework.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>PAC learning and genetic programming.</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Linear GP (identification problem solver)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Algorithm maintains a candidate linear function f(x)=Σ w_i x_i with w_i∈{−1,1}. Each iteration mutates a single weight w_i and compares parent and offspring using error on a sampled multiset S of input vectors (sampled with replacement). Selection accepts lower sampled error. Goal: identify the sign pattern of weights of the target linear function in a PAC setting.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>program parameters (weights of a linear function), not full code</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Single-weight flip per iteration (change sign of one coefficient w_i).</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Sampled error e_S(f,f_OPT) = Σ_{x∈S} |f(x)-f_OPT(x)| used as fitness surrogate; generalization error (expected error on uniform random input) is target metric in PAC analysis.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>Theorem: with |S| ≥ c0 n log n (c0 large constant), expected generations until best-so-far has expected error ≤ δ is O(n log n + n^2/δ^2). If target has linear number of +1 and −1 weights, expected generations until correct solution O(n + n^2/δ^2); perfect learning (δ=1) gives O(n^2).</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>PAC learning / identification of linear pseudo-Boolean functions</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Other PAC-evolvability analyses and evolutionary algorithms in literature; not directly compared to crossover-based GP in this paper</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Linear GP with single-weight mutations can PAC-learn the sign pattern of target linear functions efficiently when sample size per generation is Ω(n log n); shows how sample size trades off statistical reliability and runtime (more samples => reliable selection, but higher per-iteration cost).</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1634.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e1634.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>GSGP</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Geometric Semantic Genetic Programming (GSGP)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A class of GP algorithms whose crossover and mutation are defined to operate on program semantics (output vectors) rather than syntax, yielding offspring with predictable semantic relationships to parents and enabling hill-climbing in semantic space.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Geometric semantic genetic programming.</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Geometric Semantic Genetic Programming (GSGP)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Represents program semantics as the full output vector over the truth table (2^n rows for Boolean functions). Semantic crossover (SGXB) and semantic mutation (SGMB) produce offspring whose semantics are convex/controlled combinations of parents: e.g., SGXB(T1,T2,TR) → (T1 ∧ TR) ∨ (T2 ∧ TR) (switching behavior according to randomly-generated TR); SGMB(T1) → with prob 0.5 T1 ∨ M or T1 ∧ M where M is a random minterm. Operators typically append syntax and then simplification is required. Variants (FBM, VBM, FABM, MSBM) modify how minterms are generated to control expressiveness.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs (Boolean expressions) with semantics as output vectors</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Semantic crossover SGXB: construct offspring that outputs parent T1 on inputs where random TR is true and outputs parent T2 where TR is false, implemented syntactically as (T1 ∧ TR) ∨ (T2 ∧ TR) in paper text (interpreted as switching function based on TR). This performs crossover in semantic/output-vector space.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Semantic mutation SGMB: pick random minterm M (conjunction of literals); with probability 0.5 produce T1 ∨ M, otherwise T1 ∧ M. Variants: FBM (Fixed Block Mutation) fix a small subset of v variables to define minterms; VBM (Varying Block Mutation) draw v variables each iteration; FABM partitions variables; MSBM samples variable-size incomplete minterms enabling full expressiveness.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Training-set fitness (number of matched rows / sampled-error); semantic operators guarantee a cone fitness landscape enabling hill-climbing toward zero training error. Theoretical results measure iterations to fit a polynomial-sized training set.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>Theorem 34 (FBM): For a training set T of n^c rows sampled uniformly, FBM with v > 2c log2(n) fits T w.h.p. and finds a fitting function in expected O(n^{2c} log n) iterations. Theorem 35 (MSBM): a DNF φ with α=poly(n) conjunctions each of ≤β=O(1) variables can be obtained by GSGP with MSBM in expected O(α n^{β+1} 2^{β}) iterations (polynomial).</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Paper notes semantic operators tend to perfectly fit training sets but may generalize poorly; tradeoff between expressiveness (ability to fit training set) and generalization is discussed qualitatively, not quantified as a novelty-executability numeric tradeoff.</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Boolean function learning, regression (basis functions), classification trees; fitting polynomial-sized training sets and specific DNF classes</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Standard syntax-based GP, mutation-only GP; different semantic mutation variants compared (FBM, VBM, FABM, MSBM) in expressiveness and runtime to fit training sets</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>GSGP semantic operators guarantee a cone-shaped fitness landscape enabling mutation-only hill-climbing to fit training sets; expressiveness of mutation (FBM vs VBM vs MSBM) matters: FBM can fit random polynomial training sets with high probability if block size v is large enough, VBM is more expressive but still may fail on crafted training sets, MSBM attains full expressiveness and can fit certain DNF classes in polynomial time. However, theoretical analysis of generalization (performance on unseen inputs) remains an open challenge; many semantic operators produce good training fit but poor generalization empirically.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Geometric semantic genetic programming. <em>(Rating: 2)</em></li>
                <li>Computational complexity analysis of simple genetic programming on two problems modeling isolated program semantics. <em>(Rating: 2)</em></li>
                <li>PAC learning and genetic programming. <em>(Rating: 2)</em></li>
                <li>Computational complexity analysis of multi-objective genetic programming. <em>(Rating: 2)</em></li>
                <li>Genetic programming -on the programming of computers by means of natural selection. <em>(Rating: 2)</em></li>
                <li>The max problem revisited: The importance of mutation in genetic programming. <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-1634",
    "paper_id": "paper-53288676",
    "extraction_schema_id": "extraction-schema-31",
    "extracted_data": [
        {
            "name_short": "Koza-GP",
            "name_full": "Standard tree-based Genetic Programming (Koza)",
            "brief_description": "Classic tree-based GP that represents programs as syntax trees and evolves them via subtree crossover, subtree mutation and selection using fitness on input/output training cases; widely used as the canonical crossover+mutation GP paradigm.",
            "citation_title": "Genetic programming -on the programming of computers by means of natural selection.",
            "mention_or_use": "mention",
            "system_name": "Standard tree-based Genetic Programming (Koza-style)",
            "system_description": "Evolves variable-length program syntax trees using population-based selection. Variation operators include subtree crossover (exchange of randomly chosen subtrees between two parents) and subtree mutation (replace a randomly-chosen subtree by a randomly-generated subtree), together with selection driven by fitness computed on a training set of input/output cases. Often combined with bloat-control heuristics (depth/size limits, parsimony pressure).",
            "input_type": "programs",
            "crossover_operation": "Subtree crossover: select a random node in parent A and a random node in parent B; swap the entire subtrees rooted at those nodes to create two offspring. Crossover can copy large syntactic structure from both parents and potentially violate depth/size constraints (may be rejected or repaired).",
            "mutation_operation": "Typical subtree mutation: select a random node in the tree and replace its subtree by a newly randomly-generated subtree; other variants include point/substitution mutations, insertions and deletions.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "program synthesis, symbolic regression, Boolean function evolution, engineering design (antennas, lenses), MAX problem",
            "comparison_baseline": "mutation-only GP variants ((1+1) GP, RLS-GP), HVL-Prime based mutation, multi-objective/parsimony approaches",
            "key_findings": "Paper cites that standard Koza-style GP uses crossover + mutation but theoretical runtime analyses are scarce because crossover complicates rigorous analysis; empirical/theoretical evidence (MAX problem) shows crossover can interact poorly with depth bounds (deception) making crossover-based GP hard on some problems; consequently much theoretical work uses mutation-only algorithms for tractability.",
            "uuid": "e1634.0"
        },
        {
            "name_short": "(1+1)-GP",
            "name_full": "(1+1) Genetic Programming / RLS-GP",
            "brief_description": "A single-individual GP (population size 1) analyzed extensively in the paper; it uses HVL-Prime mutation (k sub-operations per iteration) to modify program trees and does not use crossover, enabling rigorous runtime analyses.",
            "citation_title": "Computational complexity analysis of simple genetic programming on two problems modeling isolated program semantics.",
            "mention_or_use": "use",
            "system_name": "(1+1) GP / RLS-GP",
            "system_description": "Population of one individual X; in each generation an offspring X' is created by applying k ≥ 1 HVL-Prime mutation sub-operations to X (k = 1 for RLS-GP, k = 1 + Poisson(1) for (1+1) GP). The offspring replaces the parent if it does not decrease fitness (non-strict) or only if strictly better (elitist variant). No crossover or population-based recombination is used.",
            "input_type": "programs (syntax trees)",
            "crossover_operation": null,
            "mutation_operation": "HVL-Prime: choose uniformly among INS, DEL, SUB. INS: choose a node, pick f∈F and l∈L, replace node by f with children (original node, l) with random order. DEL: choose a leaf and replace its parent by the leaf's sibling. SUB: replace a chosen node by a randomly selected terminal if leaf or function if internal. Applied k times per generation to permit larger changes without intermediate fitness evaluations.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Program fitness measured as disagreement/error on a training set (either complete truth table or sampled subset); e.g., number of misclassified truth-table rows, numeric evaluation value for MAX.",
            "executability_results": "Problem-specific runtime / performance bounds reported: ORDER expected optimization time O(n T_max); with lexicographic parsimony Θ(T_init + n log n) to optima. MAJORITY expected time between Ω(T_init + n log n) and O(T_init log T_init + n log^3 n). AND (complete truth table) expected optimization Θ(n log n). XOR: exponential time; RLS-GP requires &gt;2^{Ω(n/log n)} iterations w.h.p. MAX: RLS-GP finds optimum in expected O(n log n) iterations (n = max nodes).",
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "theoretical GP benchmarks: ORDER, MAJORITY, SORTING, AND, XOR, MAX; evolves Boolean and arithmetic programs",
            "comparison_baseline": "Standard crossover-based GP (Koza), SMO-GP (Pareto GP), mutation-only variants (RLS-GP vs (1+1) GP), parsimony-controlled variants",
            "key_findings": "Mutation-only (1+1)-GP and RLS-GP are amenable to rigorous runtime analysis and are efficient on several targets (AND, MAX, ORDER under size bounds) but fail or take exponential time on others (XOR). Bloat (uncontrolled growth) and acceptance of neutral moves significantly affect runtimes; analyses demonstrate benefits of parsimony pressure and Pareto approaches to control bloat.",
            "uuid": "e1634.1"
        },
        {
            "name_short": "HVL-Prime",
            "name_full": "Hierarchical Variable-Length Prime mutation operator (HVL-Prime)",
            "brief_description": "A mutation operator for binary GP trees that performs small, hierarchical edits (insertion, deletion, substitution) chosen uniformly to mimic bitwise mutation while respecting tree structure and variable length.",
            "citation_title": "Computational complexity analysis of simple genetic programming on two problems modeling isolated program semantics.",
            "mention_or_use": "use",
            "system_name": "HVL-Prime mutation operator",
            "system_description": "Per-application: pick op∈{INS,DEL,SUB} uniformly. INS: pick node x, pick function f∈F and terminal l∈L, replace x by f and set children to x and l (random order). DEL: pick a leaf x, replace its parent with x's sibling. SUB: pick node x, replace it by a random terminal (if leaf) or random function (if internal). Designed to make minimal hierarchical edits and to be analyzable.",
            "input_type": "programs (syntax trees)",
            "crossover_operation": null,
            "mutation_operation": "As described: single HVL-Prime application changes tree minimally; in (1+1) GP it can be applied k times per offspring to allow larger changes.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Used as the standard mutation in theoretical analyses across ORDER, MAJORITY, SORTING, AND, XOR, MAX",
            "comparison_baseline": "Standard subtree mutation, more permissive mutation operators; also compared within k=1 vs k=1+Poisson(1) variants",
            "key_findings": "HVL-Prime permits small localized edits that make mathematical analysis tractable; using multiple HVL-Prime sub-operations per generation simulates larger mutations; operator design (probabilities of INS/DEL/SUB) affects drift toward or away from bloat.",
            "uuid": "e1634.2"
        },
        {
            "name_short": "SMO-GP",
            "name_full": "Simple Multi-objective Genetic Programming (SMO-GP) / Pareto parsimony pressure",
            "brief_description": "A multi-objective GP algorithm that treats fitness and program size as two objectives and maintains a population approximating the Pareto front, using HVL-Prime mutation to produce offspring while minimizing bloat via Pareto selection.",
            "citation_title": "Computational complexity analysis of multi-objective genetic programming.",
            "mention_or_use": "use",
            "system_name": "SMO-GP (Pareto parsimony pressure)",
            "system_description": "Maintains population P of non-dominated solutions (fitness vs size). Each iteration: select parent uniformly from P, apply HVL-Prime k times to produce offspring; if offspring not strictly dominated by any in P add it and remove any solutions it weakly dominates. Aims to compute/approximate the Pareto front to trade off complexity and fitness.",
            "input_type": "programs (syntax trees)",
            "crossover_operation": null,
            "mutation_operation": "HVL-Prime applied k times per offspring (k = 1 or 1+Poisson(1)).",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Fitness measured as usual per problem (e.g., number of expressed literals, training-set error) and program size as second objective.",
            "executability_results": "Runtime bounds for computing Pareto front: ORDER expected optimization time O(n T_init + n^2 log n) (Theorem 5); WORDER/WMAJORITY bounds given (e.g., O(T_init^2 + n^2 T_init + n^3) for k=1). Population size P_max may be large (worst-case exponential).",
            "diversity_metric": "Pareto front diversity (multi-objective diversity across fitness vs size axis)",
            "diversity_results": "Population upper-bounded by number of distinct fitness values (e.g., ≤ n+1 for MAJORITY); however P_max may be exponential in worst cases (WMAJORITY).",
            "novelty_executability_tradeoff": "Described qualitatively: Pareto approach explicitly trades smaller program size (parsimony) vs fitness; no explicit novelty-vs-executability quantitative curve provided.",
            "frontier_characterization": "Paper analyzes Pareto front construction times and population sizes; characterizes time to obtain whole front with stated asymptotic bounds but no continuous novelty-executability curve.",
            "benchmark_or_domain": "ORDER, WORDER, MAJORITY, WMAJORITY, SORTING",
            "comparison_baseline": "(1+1) GP, RLS-GP with/without lexicographic parsimony pressure, standard GP",
            "key_findings": "SMO-GP with Pareto parsimony can avoid bloat and construct Pareto fronts efficiently in many settings (provable runtime bounds). However, worst-case population size can be large and some bounds depend on initial tree size or P_max; Pareto selection provides an effective mechanism for balancing solution complexity and fitness.",
            "uuid": "e1634.3"
        },
        {
            "name_short": "Linear-GP (identification)",
            "name_full": "Linear Genetic Programming algorithm for the identification (PAC) problem",
            "brief_description": "A simplified GP-style evolutionary method that searches weight assignments of a fixed linear function by flipping single weights per mutation and evaluates candidates on sampled training sets within the PAC-learning framework.",
            "citation_title": "PAC learning and genetic programming.",
            "mention_or_use": "use",
            "system_name": "Linear GP (identification problem solver)",
            "system_description": "Algorithm maintains a candidate linear function f(x)=Σ w_i x_i with w_i∈{−1,1}. Each iteration mutates a single weight w_i and compares parent and offspring using error on a sampled multiset S of input vectors (sampled with replacement). Selection accepts lower sampled error. Goal: identify the sign pattern of weights of the target linear function in a PAC setting.",
            "input_type": "program parameters (weights of a linear function), not full code",
            "crossover_operation": null,
            "mutation_operation": "Single-weight flip per iteration (change sign of one coefficient w_i).",
            "uses_literature": false,
            "uses_code": false,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Sampled error e_S(f,f_OPT) = Σ_{x∈S} |f(x)-f_OPT(x)| used as fitness surrogate; generalization error (expected error on uniform random input) is target metric in PAC analysis.",
            "executability_results": "Theorem: with |S| ≥ c0 n log n (c0 large constant), expected generations until best-so-far has expected error ≤ δ is O(n log n + n^2/δ^2). If target has linear number of +1 and −1 weights, expected generations until correct solution O(n + n^2/δ^2); perfect learning (δ=1) gives O(n^2).",
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "PAC learning / identification of linear pseudo-Boolean functions",
            "comparison_baseline": "Other PAC-evolvability analyses and evolutionary algorithms in literature; not directly compared to crossover-based GP in this paper",
            "key_findings": "Linear GP with single-weight mutations can PAC-learn the sign pattern of target linear functions efficiently when sample size per generation is Ω(n log n); shows how sample size trades off statistical reliability and runtime (more samples =&gt; reliable selection, but higher per-iteration cost).",
            "uuid": "e1634.4"
        },
        {
            "name_short": "GSGP",
            "name_full": "Geometric Semantic Genetic Programming (GSGP)",
            "brief_description": "A class of GP algorithms whose crossover and mutation are defined to operate on program semantics (output vectors) rather than syntax, yielding offspring with predictable semantic relationships to parents and enabling hill-climbing in semantic space.",
            "citation_title": "Geometric semantic genetic programming.",
            "mention_or_use": "use",
            "system_name": "Geometric Semantic Genetic Programming (GSGP)",
            "system_description": "Represents program semantics as the full output vector over the truth table (2^n rows for Boolean functions). Semantic crossover (SGXB) and semantic mutation (SGMB) produce offspring whose semantics are convex/controlled combinations of parents: e.g., SGXB(T1,T2,TR) → (T1 ∧ TR) ∨ (T2 ∧ TR) (switching behavior according to randomly-generated TR); SGMB(T1) → with prob 0.5 T1 ∨ M or T1 ∧ M where M is a random minterm. Operators typically append syntax and then simplification is required. Variants (FBM, VBM, FABM, MSBM) modify how minterms are generated to control expressiveness.",
            "input_type": "programs (Boolean expressions) with semantics as output vectors",
            "crossover_operation": "Semantic crossover SGXB: construct offspring that outputs parent T1 on inputs where random TR is true and outputs parent T2 where TR is false, implemented syntactically as (T1 ∧ TR) ∨ (T2 ∧ TR) in paper text (interpreted as switching function based on TR). This performs crossover in semantic/output-vector space.",
            "mutation_operation": "Semantic mutation SGMB: pick random minterm M (conjunction of literals); with probability 0.5 produce T1 ∨ M, otherwise T1 ∧ M. Variants: FBM (Fixed Block Mutation) fix a small subset of v variables to define minterms; VBM (Varying Block Mutation) draw v variables each iteration; FABM partitions variables; MSBM samples variable-size incomplete minterms enabling full expressiveness.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Training-set fitness (number of matched rows / sampled-error); semantic operators guarantee a cone fitness landscape enabling hill-climbing toward zero training error. Theoretical results measure iterations to fit a polynomial-sized training set.",
            "executability_results": "Theorem 34 (FBM): For a training set T of n^c rows sampled uniformly, FBM with v &gt; 2c log2(n) fits T w.h.p. and finds a fitting function in expected O(n^{2c} log n) iterations. Theorem 35 (MSBM): a DNF φ with α=poly(n) conjunctions each of ≤β=O(1) variables can be obtained by GSGP with MSBM in expected O(α n^{β+1} 2^{β}) iterations (polynomial).",
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": "Paper notes semantic operators tend to perfectly fit training sets but may generalize poorly; tradeoff between expressiveness (ability to fit training set) and generalization is discussed qualitatively, not quantified as a novelty-executability numeric tradeoff.",
            "frontier_characterization": null,
            "benchmark_or_domain": "Boolean function learning, regression (basis functions), classification trees; fitting polynomial-sized training sets and specific DNF classes",
            "comparison_baseline": "Standard syntax-based GP, mutation-only GP; different semantic mutation variants compared (FBM, VBM, FABM, MSBM) in expressiveness and runtime to fit training sets",
            "key_findings": "GSGP semantic operators guarantee a cone-shaped fitness landscape enabling mutation-only hill-climbing to fit training sets; expressiveness of mutation (FBM vs VBM vs MSBM) matters: FBM can fit random polynomial training sets with high probability if block size v is large enough, VBM is more expressive but still may fail on crafted training sets, MSBM attains full expressiveness and can fit certain DNF classes in polynomial time. However, theoretical analysis of generalization (performance on unseen inputs) remains an open challenge; many semantic operators produce good training fit but poor generalization empirically.",
            "uuid": "e1634.5"
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Geometric semantic genetic programming.",
            "rating": 2,
            "sanitized_title": "geometric_semantic_genetic_programming"
        },
        {
            "paper_title": "Computational complexity analysis of simple genetic programming on two problems modeling isolated program semantics.",
            "rating": 2,
            "sanitized_title": "computational_complexity_analysis_of_simple_genetic_programming_on_two_problems_modeling_isolated_program_semantics"
        },
        {
            "paper_title": "PAC learning and genetic programming.",
            "rating": 2,
            "sanitized_title": "pac_learning_and_genetic_programming"
        },
        {
            "paper_title": "Computational complexity analysis of multi-objective genetic programming.",
            "rating": 2,
            "sanitized_title": "computational_complexity_analysis_of_multiobjective_genetic_programming"
        },
        {
            "paper_title": "Genetic programming -on the programming of computers by means of natural selection.",
            "rating": 2,
            "sanitized_title": "genetic_programming_on_the_programming_of_computers_by_means_of_natural_selection"
        },
        {
            "paper_title": "The max problem revisited: The importance of mutation in genetic programming.",
            "rating": 1,
            "sanitized_title": "the_max_problem_revisited_the_importance_of_mutation_in_genetic_programming"
        }
    ],
    "cost": 0.02196575,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>Computational Complexity Analysis of Genetic Programming
11 Nov 2018</p>
<p>Andrei Lissovoi 
Pietro S Oliveto 
Computational Complexity Analysis of Genetic Programming
11 Nov 2018Version: Submitted Version Article: Lissovoi, A. and Oliveto, P.S. (Submitted: 2018) Computational complexity analysis of genetic programming. arXiv. (Submitted)This is a repository copy of Computational complexity analysis of genetic programming. White Rose Research Online URL for this paper: Reuse Items deposited in White Rose Research Online are protected by copyright, with all rights reserved unless indicated otherwise. They may be downloaded and/or printed for private study, or other acts as permitted by national copyright laws. The publisher or other rights holders may allow further reproduction and re-use of the full text version. This is indicated by the licence information on the White Rose Research Online record for the item. Takedown If you consider content in White Rose Research Online to be in breach of UK law, please notify us by emailing eprints@whiterose.ac.uk including the URL of the record and the reason for the withdrawal request.
Genetic Programming (GP) is an evolutionary computation technique to solve problems in an automated, domain-independent way. Rather than identifying the optimum of a function as in more traditional evolutionary optimization, the aim of GP is to evolve computer programs with a given functionality. A population of programs is evolved using variation operators inspired by Darwinian evolution (crossover and mutation) and natural selection principles to guide the search process towards better programs. While many GP applications have produced human competitive results, the theoretical understanding of what problem characteristics and algorithm properties allow GP to be effective is comparatively limited. Compared to traditional evolutionary algorithms for function optimization, GP applications are further complicated by two additional factors: the variable length representation of candidate programs, and the difficulty of evaluating their quality efficiently. Such difficulties considerably impact the runtime analysis of GP where space complexity also comes into play. As a result initial complexity analyses of GP focused on restricted settings such as evolving trees with given structures or estimating the quality of solutions using only a small polynomial number of input/output examples. However, the first runtime analyses concerning GP applications for evolving proper functions with defined input/output behavior have recently appeared. In this chapter, we present an overview of the state-of-the-art.</p>
<p>Introduction</p>
<p>Genetic Programming (GP) is a class of evolutionary computation techniques to evolve computer programs originally introduced by Koza [16]. GP uses genetic algorithm mutation, crossover and selection operators adapted to work on populations of program structures. Program fitness is evaluated using a training set consisting of samples of program inputs and the corresponding correct outputs. The goal of a GP system is to construct a program which, as well as producing 1 the correct outputs on the inputs included in the training set, generalizes well to the other possible inputs.</p>
<p>In standard tree-based GP, as introduced by Koza, programs are expressed as syntax trees rather than lines of code, with variables and constants (collectively referred to as terminals) appearing as leaves in the tree, and functions (such as +, *, and cos) appearing as internal nodes. New programs are produced by mutation (applying changes to a copy of a parent solution) or crossover (replacing a subtree in one parent solution with a subtree from another parent). Several other variants of GP exist that use different representations than tree structures. Popular ones are Linear GP [1], cartesian GP [27], and Geometric Semantic GP (GSGP) [30]. Since most of the available complexity analysis results focus on tree based GP this is where we keep our focus in this chapter. Work on GSGP is an exception that we will also consider [32].</p>
<p>One of the main points regarding GP made by Koza is that a wide variety of different problems from many different fields can be recast as requiring the discovery of a computer program that produces some desired output when presented with particular inputs [16]. Ideally, this process of discovery could take place without requiring a human to explicitly make decisions about the size, shape, or structural complexity of the solutions in advance. As GP systems provide a way to search the space of computer programs for one which is well-adapted to solving (or approximating) the problem at hand, they are thus applicable to a wide variety of problems, including those in artificial intelligence, machine learning, adaptive systems, and automated learning. GP has produced human-competitive results or patentable solutions on a large number of diverse problems, including the design of quantum computing circuits [48], antennas [22], mechanical [20], and optical lens systems [18]. From these results, Koza observes that Genetic Programming may be especially productive in areas where little information about the size or shape of the ultimate solution is known, while large amounts of data and good simulators are available to measure performance of candidate solutions.</p>
<p>While there are many examples of successful applications of GP (see [17] for an overview), the understanding of how such systems work and on which problems they are successful is much more limited. Compared to traditional evolutionary algorithms for function optimization, GP applications are further complicated by two additional factors: the variable length representation of candidate programs, and the difficulty of evaluating their quality efficiently since it is prohibitive or even impossible to test programs on all possible inputs. Such difficulties, naturally, considerably impact the runtime analysis of GP where space complexity also comes into play. As a result, while nowadays the analysis of standard elitist [3] and non-elitist genetic algorithms [36,37,2] has finally become a reality, analyzing standard GP systems is far more prohibitive. Indeed, McDermott and O'Reilly [26] remark that "due to stochasticity, it is arguably impossible in most cases to make formal guarantees about the number of fitness evaluations needed for a GP algorithm to find an optimal solution." Similarly to how the analysis of simplified evolutionary algorithms (EAs) has gradually led to the achievement of the techniques that nowadays allow the analysis of standard EAs, Poli et al. suggested "computational complexity techniques being used to model simpler GP systems, perhaps GP systems based on mutation and stochastic hill-climbing" [45].</p>
<p>Following this guideline the first runtime analyses laying the groundwork for better understanding of GP considered simplified algorithms primarily based on mutation and hill-climbing (i.e., the (1 + 1) GP algorithm introduced in [7]). However, further simplifications compared to GP applications in practice were necessary to deal with the additional difficulties introduced by the variable-length of GP solutions, the stochastic fitness function evaluations when using dynamic training sets, and the neighborhood structure imposed by the GP mutation and crossover operations acting on syntax trees. Indeed Goldberg and O'Reilly observed that "the methodology of using deliberately designed problems, isolating specific properties, and pursuing, in detail, their relationships in simple GP is more than sound; it is the only practical means of systematically extending GP understanding and design" [11]. To this end, the first runtime analyses of GP considered the time required to evolve particular tree structures rather than proper computer programs. In particular, solution fitness was evaluated based on the tree structure rather than by executing the evolved syntax tree. Problems belonging to this category are ORDER, MAJORITY [7] and SORTING [52]. Already in such simplified settings the characteristic GP problem, bloat (i.e., the continuous growth of evolved solutions that is not accompanied by significant improvements in solution quality), may appear.</p>
<p>In GP applications the set of all possible inputs is generally either too large to evaluate the exact solution quality efficiently, or not much of it is known (i.e., only a limited amount of information about the correct input/output behavior is available). As a result the performance of the GP system is usually considered in the probably approximately correct (PAC) learning framework [50], to show that the solution produced by the GP system generalizes well to all inputs. Kötzing et al. isolate this issue when they present the first runtime analysis of a GP system in this framework [14]. They consider the problem of learning the weights assigned to n bits of a pseudo-Boolean function (i.e., the identification problem), proving that a simple GP system can discover the weights efficiently even by using a limited sample of the possible inputs to evaluate solution quality.</p>
<p>A more realistic problem where the program output, rather than structure, is used as the basis for determining solution quality is the MAX problem [15], originally introduced in [10]. The problem is that of evolving a program which, given some mathematical operators and constants (the problem admits no variable inputs) outputs the maximum possible value subject to a constraint on program size.</p>
<p>Recently, time and space complexity of the (1 + 1) GP has been analyzed for evolving Boolean functions of arity n [25,21]. Solution quality was evaluated by comparing the output of the evolved programs to the target function on the entire truth table for the target function, or on a polynomially sized training set. The analyses show that while conjunctions of n variables can be evolved efficiently (either exactly, using the complete truth table as the training set, or in the PAC learning framework when using smaller training sets), parity functions Algorithm 1: The (1+1) GP. 1 Initialize a tree X; 2 for t ← 1, 2, . . . do 3 X ′ ← X; 4 k ← 1 + Poisson(1); 5 for i ← 1, . . . , k do 6 X ′ ← HVL-Prime(X ′ );
7 if f (X ′ ) ≤ f (X) then 8 X ← X ′ ;
of n variables cannot. These results represent the first rigorous complexity analysis of a tree-based GP system for evolving functions with actual input/output behavior.</p>
<p>We will also consider the theoretical work on GSGP, where the variation operators used by the GP system are designed to modify program semantics rather than program syntax.</p>
<p>This chapter presents an overview of the state-of-the-art. It is structured as follows. In Section 2, we introduce the (1 + 1) GP, the GP system used for most available complexity analysis results. In Section 3, we consider results where the GP system is tasked with evolving tree structures with specific properties (the ORDER, MAJORITY, and SORTING problems). In Section 4, we present results where GP systems evolve programs with limited functionality: the MAX problem in Subsection 4.1 and the identification problem considered in Subsection 4.2. Section 5 presents results for GP evolving Boolean functions of arity n. Section 6 presents a brief overview of the complexity analysis results available for Geometric Semantic Genetic Programming algorithms. Finally, Section 7 presents a summary of the complexity results and discusses the open directions for future work.</p>
<p>Preliminaries</p>
<p>In this chapter, we will primarily consider the behavior of the simple (1+1) GP algorithm (Algorithm 1), which represents programs using syntax trees and uses the HVL-Prime operator (Algorithm 2) to perform mutations. The algorithm maintains a population of one individual (initialized either as an empty tree, or a randomly-generated tree of a particular size), and at each generation chooses between the parent and a single offspring generated by HVL-Prime mutation. This simple algorithm was already considered in early comparative work between standard tree-based GP and iterated hill-climbing versions of GP [40,39,41].</p>
<p>The HVL-Prime mutation operator, introduced in [7] and shown as Algorithm 2 here, is an updated version of the HVL (Hierarchical Variable Length) mutation operator [39]. It is specialized to deal with binary trees and is designed Algorithm 2: The HVL-Prime mutation operator.</p>
<p>Data: A binary syntax tree X. 1 Choose op ∈ {INS, DEL, SUB} uniformly at random; 2 if X is an empty tree then 3 Choose a literal l ∈ L uniformly at random; 4 Set l to be the root of X;
5 else if op = INS then 6
Choose a node x ∈ X uniformly at random; 7 Choose f ∈ F, l ∈ L uniformly at random;
8 Replace x in X with f ; 9
Set the children of f to be x and l, order chosen uniformly at random;
10 else if op = DEL then 11
Choose a leaf node x ∈ X uniformly at random; 12 Replace x's parent in X with x's sibling in X;
13 else if op = SUB then 14
Choose a node x ∈ X uniformly at random; 15 Choose a replacement l ∈ L, or f ∈ F uniformly at random; 16 Replace x in X with l if x was a leaf node, or f if x was an interior node;</p>
<p>to perform similarly to bitwise mutation in evolutionary algorithms. The original motivation to use the HVL-Prime operator was that of making the smallest alterations possible to GP trees while respecting the key properties of the GP tree search space: variable length and hierarchical structure. A single application of HVL-Prime selects uniformly at random one of three sub-operations -insertion, substitution, and deletion -to be applied at a location in the solution tree chosen uniformly at random, selecting additional functions or terminals from the sets F and L of all available functions and terminals as required. The sub-operations are illustrated in Figure 1: substitution can replace any node of the tree with another node chosen uniformly at random from the set of terminals or the set of functions (if the replaced node was a terminal or a function respectively), insertion inserts a new leaf and function node at a random location in the tree, and deletion can remove a random leaf (replacing its parent with its sibling).</p>
<p>We note that for problems with trivial function or terminal sets (i.e., those that contain only one element), the substitution operator is typically restricted to only select among those nodes which can be replaced with something other than their current content, avoiding the situation where the only option is to substitute a function or terminal node with a copy of itself. This restriction does not typically affect asymptotic complexity analysis results, as the only effect of allowing such substitutions is that approximately 1/6 of the HVL-Prime applications will not alter the current solution.</p>
<p>In this chapter, we refer to Algorithm 1, with k = 1 + Poisson(1), as the (1 + 1) GP, differentiating it from the simpler local search variant which always uses k = 1, which we call RLS-GP 1 .
5 AND x 2 OR x 2 x 3 SUB ⇐ AND x 1 OR x 2 x 3 INS ⇒ AND OR x 3 x 1 OR x 2 x 3 ⇓ DEL OR x 2 x 3
(1 + 1) GP algorithms do not use crossover or populations. Instead, larger changes to the current solution can be performed by multiple applications of the HVL-Prime operator without evaluating the fitness of the intermediate trees produced within an iteration. Since each application of HVL-Prime selects a location in the tree it will modify independently, it is possible for this procedure to mutate the parent tree in several places, rather than only modifying a single subtree (which would be the case for the standard GP's subtree mutation operator, which replaces a random subtree of the parent program with a randomly-generated subtree [44]).</p>
<p>Bloat Control Mechanisms</p>
<p>Algorithm 1 depicts the non-strictly elitist variant of (1 + 1) GP, which accepts offspring as long as they do not decrease the fitness of the current solution. We use (1 + 1) GP * (and equivalently RLS-GP * ) to refer to the strictly elitist variant of the algorithm, which only accepts offspring which have strictly better fitness when compared to the current solution.</p>
<p>The difference between the elitist and non-elitist variants is often significant in how the algorithms cope with bloat problems. The (1 + 1) GP algorithms operate with a variable-length representation of their current solution: as mutations are applied, the number of nodes in the tree may increase or decrease. Poli et al. define bloat as program growth without (significant) return in terms of fitness [44]. Bloat can reduce the effectiveness of GP, as larger programs are potentially more expensive to evaluate, can be hard to interpret, and may reduce the effectiveness of the GP operators in exploring the solution space. For example, if a large portion of the current solution is non-executable (perhaps inside an if statement with a trivially false condition), mutations applied in-side this portion of the program would not alter its behavior, and hence are not helpful in attempting to improve the program.</p>
<p>Common techniques used to control the impact of bloat include modifying the genetic operators to produce smaller trees and considering additional non-fitness related factors when determining whether an offspring should be accepted into the population. The latter can include imposing direct limits on the size of the accepted solutions (by imposing either a maximum tree depth or a maximum tree size limit), rejecting neutral solutions, or a parsimony pressure approach [44], which prefers smaller solutions when the fitness of two solutions is equal.</p>
<p>Two bloat control approaches that frequently appear in theoretical analyses of GP algorithms are lexicographic parsimony pressure and Pareto parsimony pressure [23]. The former mechanism breaks ties between equal-fitness individuals (e.g. in line 7 of Algorithm 1) by preferring solutions of smaller size, whereas the latter treats fitness and solution size as equal objectives in a multiobjective approach to optimization, suggesting that the GP system maintains a population of individuals which do not Pareto-dominate each other.</p>
<p>Evaluating Solution Quality</p>
<p>In the GP problems analyzed in this chapter, the correct behavior of the target program is known for all possible inputs. Additionally, in most of the problems, the GP systems considered are able to evaluate program quality on all possible inputs efficiently. Both of these assumptions simplify the analysis, but may not be practical in the real world applications of GP: the correct output of the target function might only be known on a limited number of the possible inputs, and/or it might not be practical to evaluate the candidate solutions on all of the known inputs. Nevertheless, considering the performance of GP in this setting represents an important first step: systems which are unable to evolve the a program with the desired behavior using a fitness function which considers all possible inputs are unlikely to fare better when using a limited approximation. Additionally, fully deterministic outcomes for solution fitness comparisons simplify the analysis of the GP systems, allowing their behavior to be described in greater detail.</p>
<p>When the exact fitness is not available, performance of GP is analyzed in the PAC-learning framework [50]. This considers the expected performance of the GP-evolved program on inputs it may not have encountered during the optimization process. In this framework, GP evaluates solution fitness by sampling input/output examples from a training set during the optimization process, while the goal is to produce a program with a low generalization error, i.e., with a good probability of producing correct output on any randomly sampled solution, including ones that have not been sampled during its construction. The number of samples used to compare the quality of solutions is an important parameter in this setting, potentially trading evaluation accuracy for time efficiency.</p>
<p>While the GP algorithm may evaluate solution fitness by relying on a static training set of polynomial size, for instance chosen at random from the set of all known inputs/outputs at the start of the optimization process, Poli et al. note that in some circumstances doing so "may encourage the population to evolve into a cul-de-sac where it is dominated by offspring of a single initial program which did well on some fraction of the training cases, but was unable to fit the others" [44,Chapter 10]. To counteract this, GP systems can also, when the amount of training set data available is sufficient, opt to compare program quality on samples chosen from the available data for each comparison [9]. The complexity of these subset selection algorithms varies from simply selecting inputs/outputs at random (in the case of Random Subset Selection), to attempting to identify useful inputs/outputs based on the current or previous GP runs (Dynamic or Historical Subset Selection respectively), to hierarchical combinations of these approaches [4].</p>
<p>Evolving Tree Structures</p>
<p>In this section, we review the computational complexity results concerning the analysis of GP systems for the evolution of trees with specified properties, rather than the result of running the evolved program on any particular input. The specific property that the evolved tree should satisfy depends on the problem class. The possibility of calculating the fitness of candidate solution trees without explicitly executing the program was regarded as a considerable advantage since more realistic problems were deemed to be far too difficult for initial computational complexity analyses. The earliest analysis for the evolution of tree structures considered two separable problems called ORDER and MAJORITY. The problems, originally introduced by Goldberg and O'Reilly [11], were considered as "two much simplified, but still insightful, problems that exhibit a few simple aspects of program structure" [7]. They were minimally sufficient to capture relevant GP properties such as the existence of multiple optimal solutions. Specifically, ORDER and MAJORITY where respectively introduced as abstracted simplifications of the eliminative expression that takes place in the conditional statements (where the presence or absence of some element may eliminate others from evaluation, e.g. by making it impossible for program execution to reach the body of an if statement with an always false condition) and the accumulative expression present in many GP applications such as symbolic regression (where the GP system is able to accumulate information about the correct solution from the aggregate response of a large number of variables). In particular, the ORDER problem was meant to reflect conditional programs by making it impossible to express certain variables by inserting them at certain tree locations (representing portions of the program which might not ever be executed), while MAJORITY requires the identification of the correct set of solution components out of all possible sets. For both problems the fitness of a candidate solution is determined by an in-order traversal of its syntax tree.</p>
<p>Another problem considered in the literature where the fitness of solutions 8 depends on tree structure rather than program execution is SORTING. In the following three subsections, we review the state of the art concerning these problems.</p>
<p>The ORDER Problem</p>
<p>The ORDER problem, as originally introduced by Goldberg and O'Reilly [11], is defined as follows.
Problem 1 (ORDER). F := {J}, L := {x 1 , x 1 , . . . , x n , x n }.
The fitness of a tree X is the number of literals x i for which the positive literal x i appears before the negative literal x i in the in-order parse of X.</p>
<p>In this problem, J (for "join") is the only available function, and the fitness of a tree is determined by an in-order parse of its leaf nodes; this reduces the importance of the tree structure in the analysis, making the representation somewhat similar to a variable-length list. For example, a tree X with in-order parse (x 1 , x 4 , x 2 , x 1 , x 3 , x 6 ) has fitness f (X) = 3 because x 1 , x 2 , x 3 appear before their negations. Obviously the optimal solution is any tree that contains all the positive literals and each negative literal x i that appears in the tree is preceded by the corresponding positive literal x i , and thus has a fitness of n.</p>
<p>ORDER was introduced as a simple problem that reflects the typical eliminative expressions that take place in conditional statements and other logical elements of computer programs, where the presence of an element determines the execution of a program branch rather than another. The overall idea is that, in ORDER, the conditional execution path is determined by inspecting whether a literal or its complement appear first in the in-order leaf parse. The task of the GP algorithm is to identify and appropriately position the conditional functions to achieve the correct behavior.</p>
<p>Durrett et al. proved that the (1+1) GP can optimize ORDER in expected time O(nT max ) where T max represents the maximum size the evolved tree reaches throughout the optimization process. The exact result is stated in the following theorem.</p>
<p>Theorem 2 ([7]). The expected optimization time of the strictly and non-strictly elitist cases of the RLS-GP and (1 + 1) GP algorithms on ORDER is O(n T max ) in the worst case, where n is the number of variables x i and T max denotes the maximal tree size at any stage during the execution of the algorithm.</p>
<p>The proof idea uses standard fitness-based partition arguments. Given that at most k variables are expressed correctly (i.e., the positive literal appears before any instances of the corresponding negative literal in the in-order parse of the GP tree), a lower bound of p k = Ω((n − k) 2 /(n max(T, n))) may be achieved on the probability of expressing an additional literal by an insertion operation given that the GP tree contains exactly T leaves. Then by standard waiting time arguments the expected number of iterations to improve the solution is 1/p k , and the expected time until all literals are expressed is obtained by summing the n times.</p>
<p>The runtime bound stated in Theorem 2 depends on the tree size T max . If, as it often happens in GP applications, a bound on the maximum size of the tree is imposed, then this bound is also a bound on T max . However, if no restriction on the maximum tree size is imposed, then bounding the maximum size of the tree is challenging. Nevertheless, if strict selection and local mutations are used, then it can be shown that the tree does not grow too much from its initialized size. The following corollary of Theorem 2, which states this result precisely, is slightly more general than the one presented in [7].
Corollary 3. The expected optimization time of the RLS-GP * on ORDER is O(n 2 + n T init ) if the tree is initialized with T init terminals.
Proof. RLS-GP * will only accept mutations which improve the fitness of the current solution, and as there are only n + 1 possible fitness values, at most n mutations can be accepted by the GP before the optimum is found.</p>
<p>A single application of HVL-Prime cannot increase the size of the tree by more than one leaf. Thus, T max ≤ T init + n, and applying Theorem 2 yields the desired runtime bound.</p>
<p>It is still an open problem to bound T max for the (1 + 1) GP, or even for RLS-GP where non-strict selection is used. It has been conjectured [7] that the same bound as in Corollary 3 should also hold for the (1 + 1) GP * . In general, they note that the acceptance of neutral moves on ORDER causes a "feedback loop that stimulates the growth of the tree", as there is a slight bias towards accepting insertions rather than deletions on the problem, and larger trees create more opportunities for neutral insertions to take place.</p>
<p>A subsequent experimental analysis performed by Urli et al. led the authors to conjecture an O(T init +n log n) upper bound on the runtime [49], which would imply, if correct, that the bound given in Corollary 3 is not tight.</p>
<p>As shown in the following subsection, by using bloat control mechanisms, more precise results have been achieved by exploiting the more explicit control of the tree size.</p>
<p>Bloat Control</p>
<p>The performance of the (1 + 1) GP with lexicographic parsimony pressure on ORDER has been considered by Nguyen et al. [35] and Doerr et al. [5]. This mechanism controls bloat by preferring trees of smaller size when breaking ties amongst solutions of equal fitness.</p>
<p>The Negative Drift Theorem was used by Nguyen et al. to show that as long as the initial tree is not too large (T init &lt; 19n), it does not grow significantly in less than exponential time (i.e., T max &lt; 20n with high probability). With this bound on T max , it is then proven that the optimum is found in O(n 2 log n) iterations with high probability, showing that the solution can be improved up to n times via a cycle of shrinking it down to minimal size (containing no redundant copies of any variable) and then expressing a new variable (pessimistically assuming that this insertion also creates a large amount of redundant terminals in the tree, requiring another round of shrinking to occur prior to the next insertion). Experimental results led to the conjecture of an O(T init + n log n) bound [49].</p>
<p>A more precise analysis proves the bound and its tightness, as given in the following theorem [5].</p>
<p>Theorem 4 ([5]</p>
<p>). The (1 + 1) GP with lexicographic parsimony pressure on ORDER takes Θ(T init + n log n) iterations in expectation to construct the minimal optimal solution.</p>
<p>The lower bound of the theorem is proven by using standard coupon collector and additive drift arguments. For the upper bound, the variable drift theorem [46] is applied using a potential function that takes into account both the number of expressed literals and the size of the tree.</p>
<p>Neumann considered the Pareto parsimony pressure approach to bloat control by introducing a multi-objective GP algorithm (SMO-GP), and using both the solution fitness and size as objectives [34]. This approach was motivated by noting that GP practitioners can, when presented with a variety of solutions, gain insight into how solution complexity trades off against quality.</p>
<p>The SMO-GP algorithm maintains a population of solutions P representing the current-best approximation of the Pareto front. Similarly to the (1 + 1) GP, the algorithm produces a single offspring individual by applying the HVL-Prime operator k times to a parent individual chosen uniformly at random from P in each iteration. If the offspring is not strictly dominated by any solution already in P , it is added to the population, while any solutions in P it weakly dominates are removed. Thus, the size of the population P can vary throughout the run. The theoretical analysis considers the number of iterations required to compute a population containing the entire Pareto front.</p>
<p>Theorem 5 ([34]</p>
<p>). The expected optimization time of the SMO-GP, using either k = 1 or k = 1 + Poisson(1), on ORDER is O(n T init + n 2 log n).</p>
<p>The result is proven by showing that it is possible for the GP algorithms to construct the empty tree in expected O(nT init ) iterations. Once a minimal solution with k expressed variables exists in the population, the minimal solution with k + 1 expressed variables can be constructed from it with probability at least 1 3e 1 n+1 n−k 2n in each iteration, and hence an upper bound on the expected runtime may be achieved by using the fitness-based partition method.</p>
<p>Experiments have led to the unproven conjecture that the bound of Theorem 5 is tight [49].</p>
<p>Generalizations: Weighted ORDER</p>
<p>Neumann introduced the WORDER problem, a weighted variant of ORDER, where each pair of variables x i , x i has a corresponding weight w i and the fitness of a solution is the sum of the weights of all expressed variables [34]. The idea behind the problem was to mimic the generalization of the complexity analysis of evolutionary algorithms from OneMax to the class of linear pseudo-Boolean functions [6,38]. As RLS-GP is unable to produce offspring that differ by more than two expressed variables, its expected optimization time on WORDER is equal to its expected optimization time on ORDER, leading to an equivalent of Theorem 4 for the RLS-GP with lexicographic parsimony pressure. A bound on the runtime of the (1 + 1) GP is given in the following theorem.
Theorem 6 ([35]). The expected optimization time of the (1 + 1) GP on WORDER is O(n T max (log n + log w max )).
The theorem is proven by applying the Multiplicative Drift Theorem, showing that, in expectation, the weight of the unexpressed variables decreases by a constant factor in each iteration. The dependence on T max is explained by noting that a beneficial mutation requires the insertion of a variable at the beginning of the in-order walk of the tree; unfortunately, T max can potentially grow to be arbitrarily large.</p>
<p>As for the standard ORDER problems, using the Pareto parsimony pressure approach, results not depending on the maximum tree size may be achieved. Yet, in the multi-objective setting, a special case is considered where the algorithm is initialized with a non-redundant solution (i.e., a solution where no single leaf can be removed without adversely affecting solution fitness). By limiting k = 1 (i.e., the RLS variant), the algorithm will not accept redundant solutions throughout the optimization process. The following theorem was proven following the approach of Theorem 5. Both the requirement that the initial tree should be non-redundant, and the restriction to the single-operation local search variant of SMO-GP were removed by Nguyen et al. [35].</p>
<p>Theorem 8 ( [35]). Let T init be the size of the initial solution, and P max be the maximum size of the SMO-GP population at any point during the optimization process. Then, expected optimization time of SMO-GP on WORDER is O(T init 2 + n 2 T init + n 3 ) when k = 1, and O(P max (T init + n 2 )) when k = 1 + Poisson(1).</p>
<p>Unfortunately, even though the size of the Pareto front is linear, P max is not a parameter that can be controlled by the user: in the worst case, the population might consist of an individual for every possible fitness value, and on some WORDER instances, this can range up to 2 n . Experiments have led to the conjecture that both T max and P max grow linearly during the optimization process. However, no rigorous proofs are available [35].</p>
<p>The MAJORITY Problem</p>
<p>The MAJORITY problem, as originally introduced by Goldberg and O'Reilly [11], is defined as follows.
Problem 9 (MAJORITY). F := {J}, L := {x 1 , x 1 , . . . , x n , x n }.
The fitness of a tree X is the number of literals x i for which the positive literal x i appears in X at least once, and at least as many times as the corresponding negative literal x i .</p>
<p>In this problem, J (for "join") is the only available function, and the fitness of a tree is determined by an in-order parse of its leaf nodes; this reduces the importance of the tree structure in the analysis, making the representation somewhat similar to a variable-length list. For example, a tree with an in-order parse of (x 1 , x 1 , x 2 , x 3 , x 3 , x 3 ) would have a fitness of 2, as only the x 1 and x 2 literals are expressed (while x 3 outnumbers x 3 in the tree, and is therefore suppressed). Any optimal solution, expressing all n positive literals, has a fitness of n.</p>
<p>The fitness of solutions on MAJORITY is based on the quantity of x i and x i literals in the tree, with only the literal in greater quantity (majority) being expressed and potentially contributing to the fitness value. This serves to model problems where solution fitness can be accumulated through additions of more nodes to the tree, regardless of their exact positions.</p>
<p>In contrast to ORDER, where there is always a position in the tree where an unexpressed x i literal can be inserted to express x i and improve the fitness of a solution, on MAJORITY there exist trees where no single insertion of an unexpressed x i will lead to x i being expressed and thus improving fitness, even though all x i literals can contribute to expressing x i in aggregate regardless of their position. Thus, GP variants which do not accept neutral moves were found to perform quite badly, with RLS-GP * shown to be capable of getting stuck in easily-constructed local optima, and (1 + 1) GP * having an exponential expected optimization time to recover from a worst-case initialization [7]. On the other hand, GP variants using non-strict selection may be efficient. in the worst case, where D := max(0, max i (c(x i ) − c(x i ))), and c(x) is the number of times the literal x appears in the initial tree.</p>
<p>If initialized with a random tree containing 2n terminals selected uniformly at random from L, the expected optimization time of the RLS-GP on MAJORITY is O(n 2 T max log log n).</p>
<p>The presented bounds depend on D, the maximum deficit between the number of positive literals and negative literals of any variable in the tree (thus, a tree with a single copy of x 1 and two copies of x 1 would have a deficit of D = 1). The worst case result, assuming a deficit of D literals for all n variables, follows from a generalized variant of the coupon collector problem [33], requiring the collection of D copies of each coupon. For the uniform initialization with T init = 2n, a bound on D = O(log n/ log log n) is derived using the balls-into-bins model [28]. It is then proven that a variable which initially has a deficit of D becomes expressed after an expected O(DT max ) mutations involving that variable (which occur with probability Θ(1/n)) by showing that the GP system essentially performs a random walk that is at least fair with respect to decreasing the deficit.</p>
<p>For the (1 + 1) GP, only a hypothetical worst-case analysis for the elitist variant is presented in [7], noting that if the last unexpressed variable has k more negative literals than positive literals in the tree, the final mutation will require at least Ω(n k/2 ) time, and thus unless k can be shown to be constant, the expected runtime remains super-polynomial. However, no bounds on the probability that a super-constant k would actually occur were given.</p>
<p>The problem, including the dependence on T max was recently solved, proving the following upper and lower bounds on the expected optimization time [5].</p>
<p>Theorem 11 ([5]). When initialized with a tree containing T init terminals, the expected optimization time of the RLS-GP and (1 + 1) GP algorithms on MAJORITY is at least Ω(T init + n log n) and at most O(T init log T init + n log 3 n).</p>
<p>The lower bound is proved by an application of the multiplicative drift theorem with bounded step size, while the upper bound relies on showing that if T init ≥ n log 2 n, the tree will grow by at most a constant factor in O(T init log T init ) generations before the optimal solution is constructed. As a result, the bloat cannot be too excessive throughout the optimization process, implying that the final tree may be at most larger by a multiplicative polylogarithmic factor than the optimal solution size.</p>
<p>From the analysis, an interesting alternative to bloat control emerges. By changing the HVL mutation probabilities such that deletions are more likely than insertions, a drift towards smaller solutions would be observed, leading to smaller trees, and hence faster optimization. Such a suggestion was originally given by Durrett et al., albeit for the ORDER problem [7]. Concerning MAJORITY, theoretical evidence in support of this has emerged, though no formal proof is available [5].</p>
<p>Bloat Control</p>
<p>Applying lexicographic parsimony pressure mitigates the analysis problems in the GP systems for MAJORITY. With this bloat control mechanism, mutations which solely remove negated terminals are always accepted, as they reduce the size of the tree. Accepting such mutations eventually leads GP to a solution where fitness can be improved by inserting a positive literal, allowing the optimum to be reached efficiently.</p>
<p>Theorem 12 ([34]). The expected optimization time of the RLS-GP with lexicographic parsimony pressure on MAJORITY, when initialized with a tree containing T init literals, is O(T init + n log n).</p>
<p>The result is proven by reasoning that it takes O(T init ) iterations to remove the T init negated terminals provided by a worst-case initialization, and O(n log n) iterations to express all n variables by an application of the coupon collector argument.</p>
<p>A tight bound for the (1 + 1) GP, showing that the larger Poisson mutations do not affect the asymptotic run time, has recently been proved [5], confirming a previous conjecture [49]. Theorem 13 ([5]). The expected optimization time of the (1 + 1) GP with lexicographic parsimony pressure on MAJORITY, when initialized with a tree containing T init literals, is Θ(T init + n log n).</p>
<p>The lower bound of the theorem is proven by using standard coupon collector and additive drift arguments. For the upper bound, the variable drift theorem [46] is applied using a potential function that takes into account both the number of expressed literals and the size of the tree. Intuitively, the size of the tree is only allowed to increase if the MAJORITY fitness is also increased, which can only occur a limited number of times, and the magnitude of the increase is unlikely to be overly large due to the Poisson distribution used to determine k.</p>
<p>It is still an open problem to prove whether lexicographic parsimony pressure asymptotically improves the runtime of the (1 + 1) GP or whether the upper bound given in Theorem 11 is not tight (Urli et al. conjecture an upper bound of O(T init + n log n) without bloat control based on experimental data [49]).</p>
<p>Applying Pareto parsimony pressure and treating the size of the tree as an additional objective in the multi-objective SMO-GP algorithm allows the GP system to compute the Pareto front of solutions in terms of fitness/complexity.  (1)) on MAJORITY, initialized with a single tree containing T init terminals, is O(nT init + n 2 log n).</p>
<p>The SMO-GP population will contain at most n + 1 individuals, as there are only n + 1 distinct fitness values on MAJORITY. Similar to the situation for lexicographic parsimony pressure, SMO-GP is able to construct an initial solution on the Pareto front by repeatedly removing any duplicate or negated terminals from the initial solution. Once a solution on the Pareto front exists, the entire front can be constructed by repeatedly selecting a solution at the edge of the front and expressing an additional variable or deleting an expressed variable.</p>
<p>Generalizations: Weighted MAJORITY</p>
<p>Neumann [34] introduced the WMAJORITY problem, a weighted variant of MAJORITY, where each pair of variables x i , x i has a corresponding weight w i and the fitness of a solution is the sum of the weights of all expressed variables. The idea was again to mimic the generalization of the complexity analysis of evolutionary algorithms from OneMax to the class of linear pseudo-Boolean functions [6,38]. Results about GP systems without bloat control for WMAJORITY are unknown, though Urli et al. conjecture an O(T init + n log n) upper bound on the runtime of RLS-GP and (1 + 1) GP based on experimental results [49].</p>
<p>Concerning lexicographic parsimony pressure, as RLS-GP is unable to produce offspring that differ by more than two expressed variables, its expected optimization time on WMAJORITY is equal to its expected optimization time on MAJORITY, leading to an equivalent of Theorem 12 (i.e., an O(T init + n log n) runtime bound).</p>
<p>Concerning Pareto parsimony pressure, bounds on the WMAJORITY problem for both the single-operation and multi-operation variants of the SMO-GP were proven, using the size of the tree as an additional objective to minimize [35]. Theorem 15 ([35]). Let T init be the size of the initial solution, and P max be the maximum size of the SMO-GP population at any point during the optimization process. The expected optimization time of SMO-GP on WMAJORITY is O(T init 2 + n 2 T init + n 3 ) when k = 1, and O(P max (T init + n 2 )) when k = 1 + Poisson(1).</p>
<p>Unfortunately, P max is not a parameter that can be controlled by the user: in the worst case, the population might consist of an individual for every possible fitness value, which for WMAJORITY can be exponential with respect to n. Experiments have led to the conjecture that P max grows linearly with the problem size n [35].</p>
<p>The SORTING Problem</p>
<p>The SORTING problem is the first classical combinatorial optimization problem for which computational complexity results have been obtained for discrete evolutionary algorithms. For the application of evolutionary algorithms Scharnow et al. defined SORTING as the problem of maximizing different measures of sortedness of a permutation of a totally ordered set of elements [47].</p>
<p>The problem was considered in a GP setting by Wagner et al., aiming to investigate the differences between different bloat control mechanisms for genetic programming [52,53]. For the GP variant, the measures of sortedness have been adapted to deal with incomplete permutations of the literal set. RUN(π) Number of maximal sorted blocks (minimize to sort), plus the number of missing elements n − |π|, with RUN(π) = n + 1 if |π| = 0 LAS(π) Length of longest ascending sequence (maximize to sort) EXC(π) Smallest number of exchanges needed to sort the sequence (minimize to sort), plus 1 + n − |π| if |π| &lt; n.</p>
<p>In this problem, J (for "join") is the only available function, and the fitness of a tree is determined by an in-order parse of its leaf nodes drawn from a totally-ordered set of terminals L; this reduces the importance of the tree structure in the analysis, making the representation somewhat similar to a variablelength list. Thus, for n = 5, the fitness of a tree with an in-order parse of (1, 2, 1, 4, 5, 4, 3), and hence π = (1, 2, 4, 5, 3) is: INV(π) = 3, HAM(π) = 2, RUN(π) = 2, LAS(π) = 4, and EXC(π) = 2. The fitness value of optimal trees for the INV, HAM, and LAS measures is n, while for the RUN and EXC measures it is 0.</p>
<p>Unlike the ORDER and MAJORITY problems considered in the previous sections, the SORTING problem is not separable, meaning that it cannot be split into subproblems that could be solved independently. The dependencies between the sub-problems can thus significantly impact the overall time needed to solve the optimization problem, and the variable-length representation of solutions can create local optima from which it is difficult for the GP systems to escape. Wagner et al. additionally remark that the task of evolving a solution is more difficult for the considered RLS-GP and (1 + 1) GP systems than for the permutation-based EA, which in expectation requires O(n 2 log n) iterations for the INV, HAM, LAS or EXC sortedness measures, and exponential time when using the RUN sortedness measure [47]. The positive statement is proven by applying the artificial fitness level method, observing that there are n · (n − 1)/2 + 1 possible fitness values, and with probability Ω(1/(nT max )) a mutation inserts a literal which corrects at least one unsorted pair without introducing any additional unsorted pairs.</p>
<p>For the HAM, RUN, LAS, and EXC measures, trees which require large mutations to improve fitness exist, which causes the expected optimization time to be infinite for the RLS-GP * , and e Ω(n) for the (1 + 1) GP * . In general, the problematic solutions contain a large number of copies of a single literal in an incorrect location, and a large sorted sequence, requiring either all the incorrectly placed copies to be removed simultaneously, or the sorted sequence to be moved in a single mutation.</p>
<p>Bloat Control</p>
<p>When bloat control mechanisms are applied, the GP systems may reduce the size of the redundant components of the solution even if mutations which make progress in this direction do not alter the solution's sortedness measure.  [53].</p>
<p>No Bloat Control
Parsimony Pressure F(X) RLS-GP * (1 + 1) GP * RLS-GP SMO-GP INV O(n 3 T max ) [2] O(n 3 T max ) [2] O(T init + n 5 ) [2] O(n 2 T init + n 5 ) [2] LAS ∞ [2] Ω n e n [2] O(T init + n 2 log n) † [2] O(nT init + n 3 log n) [2] HAM ∞ [2] Ω n e n [2] ∞ [1] O(nT init + n 4 ) [1] EXC ∞ [2] Ω n e n [2] ∞ [1] O(n 2 T init + n 3 log n) [1] RUN ∞ [2] Ω n e n [2] ∞ [1] O(n 2 T init + n 3 log n) [1]
The impact of applying lexicographic parsimony pressure for the (1 + 1) GP family of algorithms, and of Pareto parsimony pressure for the SMO-GP algorithms has been considered [52,53]. We summarize the results in Table 1.</p>
<p>In general, the positive results are proven by showing that there exists a sequence of fitness-improving mutations leading the GP system to the global optimum (in the case of (1 + 1) GP algorithms), or, for the SMO-GP, to a solution on the Pareto front, from which other Pareto front solutions can be constructed efficiently.</p>
<p>The majority of the negative results rely on showing the existence of local optima for the sortedness measure, which limits the availability of results for the non-strictly elitist algorithms, and especially for (1 + 1) GP, which is capable of performing larger mutations.</p>
<p>Interestingly, the results in Table 1 suggest that the variable-length representation can cause difficulties for the RLS-GP even when parsimony pressure is applied for some simple measures of sortedness, while even a simple multiobjective algorithm is able to find the entire Pareto front of the problem efficiently when using any of the five considered measures.</p>
<p>Experimental results presented suggest that the (1 + 1) GP algorithm is efficient (i.e. able to find the optimum in polynomial time) using all of the considered sortedness measures except RUN, both with and without bloat control mechanisms: concerning the average case complexity, an O(n 2 log n) bound is conjectured for INV and LAS measures, and an O(n 4 ) bound is conjectured for the EXC and HAM measures [53]. Providing a rigorous theoretical analysis of the GP systems' behavior remains an open question.</p>
<p>Evolving Programs of Fixed Size</p>
<p>In this section, we consider two more advanced applications compared to those of the previous section. For both problems, the fitness of an evolved program is computed by evaluating its output. While more realistic, the problems are still different from proper GP applications. In the first problem, MAX, the program to be evolved has no input variables, and thus the GP system has to construct a program which always outputs the same constant value, subject to constraints on problem size and available operators. Concerning the second problem, an identification one, the structure of the optimal solution is fixed (i.e., no tree structure has to be evolved), and the considered GP system is not allowed to deviate from it, but must instead learn the exact weights of a predefined linear function while evaluating program quality by comparing the program output to the target function on only a limited amount of the possible function inputs.</p>
<p>The MAX Problem</p>
<p>The MAX problem was originally introduced by Gathercole and Ross as a means of analyzing the limitations of crossover when applied to trees of fixed size [10]. The fitness of the program depends on the evaluation of the arithmetic expression represented by the tree. However, the problem contains no variable inputs, and thus the goal of the GP algorithms is simply to construct a tree that evaluates to the maximum possible value subject to the restrictions on the size of the tree, and the available functions and terminals. The fitness of a tree X is the value produced by evaluating the arithmetic expression represented by the tree if the tree is of depth at most D, and 0 if the tree is of larger depth.</p>
<p>The optimal solution to MAX is a complete binary tree of depth D, with t at all the leaves, with the lowest ⌊1/2 + 1/t⌋ levels of interior (i.e., non-leaf) nodes containing + and the remaining interior nodes containing ×. It has been noted that lower values of t &lt; 1 make the problem more difficult for crossover-based GP systems [10].</p>
<p>The behavior of GP systems on the MAX problem was previously studied experimentally, with Langdon and Poli observing that MAX is hard for GP systems utilizing crossover due to the interaction of deception with the depth bound on the tree making it difficult to evolve solutions, with the GP systems essentially being forced to perform randomized hill climbing in the later stages of the optimization process, and hence requiring exponential time with respect to the maximum allowed depth of the trees [19].</p>
<p>A theoretical analysis of the (1 + 1) GP on the MAX problem was presented by Kötzing et al., showing that the runtime of the mutation-only algorithm was polynomial with respect to n = 2 D+1 − 1, the maximum allowed number of nodes in the tree.</p>
<p>Theorem 19 ([15]</p>
<p>). The RLS-GP algorithm finds the optimal solution on the MAX problem for any choice of t &gt; 0, in expected O(n log n) iterations, where n is the maximum allowed number of nodes in a tree subject to the depth limit D.</p>
<p>The theorem is proven by showing that the GP algorithm can first construct a complete binary tree with depth D in a way that prevents any node from being deleted, and then use the substitution sub-operation of HVL-Prime to correct internal nodes.</p>
<p>Concerning the (1 + 1) GP, a weaker bound on the expected runtime was proven.</p>
<p>Theorem 20 ( [15]). The expected time for the (1 + 1) GP to find the optimal solution for the MAX problem with t = 1 is O(n 2 ).</p>
<p>The theorem is proved using fitness-based partitions, exploiting the existence of at least one leaf in a tree of size n which could be selected by insertion to grow the tree. Experimental results suggesting that the true runtime of the (1 + 1) GP on MAX is also O(n log n) were also presented, and the authors note that a more precise potential function based on the contents of the tree would be required to show this upper bound using drift analysis.</p>
<p>Additionally, a modification of the insertion operation in HVL-Prime to grow the tree in a more balanced fashion was considered: rather than selecting a location to insert a new leaf node at uniformly at random from the entire tree, selection would pick a leaf at depth d with probability 2 −d to replace with a new function node, using the original leaf and an inserted terminal as its leaves. As well as balancing the growth of the tree between different branches, this reduces the probability that mutation attempts insertion operations which would be blocked by the tree depth limit. With this modified insertion operator, an O(n log n) bound on the expected runtime of the (1 + 1) GP on MAX with F = {+} was proved [15].</p>
<p>Closing the gap between the O(n 2 ) upper bound for the (1 + 1) GP on MAX with F = {+, ×} and an Ω(n log n) lower bound given by a coupon collector argument remains an open problem. Furthermore, theoretical time complexity analyses of the performance of crossover-based GP systems, for which the MAX problem was originally introduced, are still unavailable.</p>
<p>The Identification Problem and PAC Learning</p>
<p>The identification problem was introduced by Kötzing et al. [14], to evaluate the learning capabilities of a simple evolutionary algorithm (EA with a local mutation operator) in the setting of the approximately correct (PAC) learning framework [50]. The idea is that while some problems cannot always be solved exactly (as there might be no known polynomial-time algorithms producing an exact solution, as, e.g., for NP-hard problems), a good approximation, i.e. one that is correct on a random input with high probability, may be a satisfactory solution. A large class of functions has been shown to be PAC learnable by designing appropriate evolutionary algorithms [51,8]. Compared to these works, Kötzing et al. consider a simplified setting [14]. Unlike the previously considered problems, the structure of the desired solution is known in advance by the algorithm, which is tasked with identifying the target function from a known class of linear functions; more precisely, the identification problem is that of learning a linear function f OP T defined over bit strings x ∈ {0, 1} n ,
f OP T (x) = n i=1 w i x i , where w i ∈ {−1, 1}.
The goal of the considered EA (called the Linear GP algorithm) is to identify whether each weight w i is positive or negative. The algorithm changes a single weight w i in each iteration, and determines whether the mutated offspring has better fitness than its parent using a multi-set S constructed independently in each iteration by selecting the desired number of points uniformly at random (with replacement) from {0, 1} n , and computing an error of each solution f as
e S : e S (f, f OP T ) = x∈S |f (x) − f OP T (x)|
preferring solutions with lower error. Thus, the focus of the analysis is to measure the ability of the GP system to extract information from a limited view of the true fitness function: if S is too small, the sampled error function may be an unreliable indication of the true quality of the solution. On the other hand, larger S require more computational effort for each fitness evaluation, which could result in worse performance with respect to the overall CPU time spent.</p>
<p>The following theorem shows that the Linear GP algorithm is able to learn f OP T efficiently if the number of inputs sampled in each iteration is sufficiently large.</p>
<p>Theorem 21 ([14]). If |S| ≥ c 0 n log n, c 0 a large enough constant, the expected number of generations until the best-so-far function found by Linear GP has an expected error ≤ δ is O(n log n + n 2 /δ 2 ).</p>
<p>If f OP T also has a linear number of both 1 and −1 weights, the expected number of generations until such a solution is found is O(n + n 2 /δ 2 ).</p>
<p>In this setting, e S ≤ 1 implies that an optimal solution has been found, and thus the theorem additionally provides an O(n 2 ) bound on the expected number of generations required to learn the f OP T perfectly (by setting δ = 1). The theorem is proven by showing that in O(n log n) generations, the numbers c 1 and c −1 of incorrect weights in f set to 1 and −1 respectively becomes balanced (such that there is at most one more incorrect weight of one kind versus the other) with high probability, and remains balanced throughout the rest of the process. When c 1 = c −1 , mutations increasing either value are rejected with high probability, while mutations reducing either value are accepted with high probability (but can be undone by the GP system until a wrong weight of the opposite kind is corrected). Thus, c 1 and c −1 can be reduced permanently by performing the two reductions in sequence (which occurs with probability at least (i/n) 2 if initially c 1 = c −1 = i), and by a coupon collector-like argument, the number of incorrect weights is reduced to an acceptable level in expectation after O(n 2 /δ 2 ) generations.</p>
<p>Extending the analysis results to broader function classes and algorithms, e.g. considering functions with more than two options for each coefficient, or a (1 + 1) GP-like mutation operator capable of performing more than one change in each iteration, remains an open direction for further research. The PAC-learning framework will also be used to analyze the performance of the (1 + 1) GP family of algorithms on Boolean functions in the next section.</p>
<p>Evolving Proper Programs: Boolean Functions</p>
<p>The problems of evolving Boolean functions of arity n, such as conjunctions (AND) or parity (XOR), have long been used as benchmarks in the field of GP [16,19], and are well-understood in the PAC-learning framework [51] conjunctions are evolvable efficiently, while parity problems are not. Unlike the problems considered in the previous sections, Boolean functions have a clear input/output behavior, allowing a natural definition of a fitness function related to program inputs and outputs, and can naturally support larger function and terminal sets.</p>
<p>A complexity analysis of the (1+1) GP algorithms on the AND and XOR problems has recently been presented [25]. Common to both problems, the GP algorithms are initialized with an empty tree, as larger trees are helpful for the easiest case of the AND problem.</p>
<p>For these problems, the fitness of the evolved solutions is evaluated by comparing their output to that of the target function on either the entire truth table, or a polynomial training subset. If an incomplete training set is used, the GP system may either choose it once at the beginning of the run (the static incomplete training set case as considered in [25]), or choose a fresh subset dynamically in every iteration (as in [21]). Both approaches may be valid in different practical settings: if the complete truth table is known but is prohibitively large, it may be sampled to produce an estimated fitness of a solution, while if only a limited number of input/output examples are available, some may need to be held back to validate the quality of the solution on inputs that it has not been trained on.</p>
<p>Evolving Conjunctions</p>
<p>The AND problem, in its simplest form, tasks the GP with evolving a conjunction of all n available input variables. The fitness of a tree X using a training set T selected from the rows of the complete truth table C is the number of training set rows on which the value produced by evaluating the Boolean expression represented by the tree differs from the output of the conjunction of all n inputs. This fitness value should be minimized; the optimal solution has a fitness of 0.</p>
<p>For example, when the complete truth table is used as the training set T , the fitness of a tree containing only a single x 1 leaf on the AND problem with n = 3 is 3, while the fitness of the optimum is 0 (as the fitness function represents the error of the solution on the training set). In general, a conjunction of a distinct variables has a fitness of 2 n−a − 1 on the complete training set. This fitness function is unimodal, making the AND problem somewhat similar to the OneMax benchmark problem for evolutionary algorithms: the GP system simply has to collect all n distinct variables in its solution, with the fitness of the current solution improving with each distinct variable added.</p>
<p>Complete Training Sets</p>
<p>Mambrini and Oliveto show that the RLS-GP and RLS-GP * algorithms can efficiently construct the optimal solution on the AND problem when using the complete truth table to evaluate solution fitness [25].</p>
<p>Theorem 23 ([25]</p>
<p>). The expected optimization time of RLS-GP and RLS-GP * on the AND problem using the complete training set is Θ(n log n). The solution produced by RLS-GP * contains exactly n terminals.</p>
<p>The proof applies a coupon collector argument, showing that with probability (n − i)/(3n), a new variable is added to the solution, and that no mutations decreasing the number of distinct variables are ever accepted. As all interior nodes are forced to be conjunctions, collecting all n variables in the tree produces an optimal solution.</p>
<p>The following theorem presents a fixed budget analysis of the RLS-GP and RLS-GP * algorithms, providing a relationship between the expected number of distinct variables in the solution and the time the algorithms are allowed to run.</p>
<p>Theorem 24 ([21]).</p>
<p>Let v(x) denote the number of distinct variables in solution x, and x * b (x b respectively) be the solution produced by the RLS-GP * (RLS-GP) algorithm given a budget of b iterations on the AND problem using the complete training set when initialized with an empty tree. Then,
E(v(x * b )) = n − n(1 − 1/(3n)) b , n − n(1 − 1/(3n)) b ≤ E(v(x b )) ≤ n − n(1 − 2/(3n)) b .
The theorem is proven by following the techniques used to analyze Randomized Local Search on the OneMax problem in [13]. The exact expectation is known for RLS-GP * , which never accepts solutions that do not improve fitness, and hence can never have a substitution sub-operation increase the number of distinct variables in the solution. The upper and lower bounds on E(v(x b )) for the RLS-GP stem from trivial bounds on the probability of a substitution sub-operation of HVL-Prime increasing the number of distinct variables in the solution. We note that although the f (x) = 2 n−v(x) −1 relationship between the solution fitness (f (x)) and the number of distinct variables it contains (v(x)) is known, it is not possible to apply linearity of expectation to transform a bound on E(v(x b )) into a bound on E(f (x b )) (as could be done for OneMax).</p>
<p>The runtime analysis results have been extended to cover the (1 + 1) GP algorithms, and show that the expected number of terminals in the constructed solution is Θ(n).</p>
<p>Theorem 25 ([21]</p>
<p>). The expected optimization time of the (1 + 1) GP and the (1 + 1) GP * on the AND problem using the complete training set is Θ(n log n). In expectation, the solution produced by the algorithms contains Θ(n) terminals.</p>
<p>On the AND problem, there are many possible trees which encode the desired behavior (as repeating a variable multiple times in the conjunction does not negatively affect the behavior of the program) and it is therefore possible that a "correct" program could contain much more than the n required leaf nodes. The space complexity result in Theorem 25 shows that the considered GP systems construct a tree that in expectation contains just O(n) leaf nodes. It is proven by showing that the number of terminals containing variables present in the solution multiple times does not grow fast enough to affect the asymptotic size bound in the O(n log n) iterations required to collect all n required variables with high probability.</p>
<p>Incomplete Training Sets</p>
<p>Obviously, the complete truth table for the AND problem contains N = 2 n rows in total. Hence, in practice it is not possible to evaluate the exact fitness of a candidate solution.</p>
<p>If the training set was restricted to be polynomial in size, and were to be chosen uniformly at random from the complete truth table, then with high probability, a solution representing a conjunction of a logarithmic number of distinct variables will be correct on all of the inputs included in the training set, causing the optimization process to end prior to finding a solution that is correct on all possible inputs [25]. The following result holds in both when the training set is sampled once and for all at the beginning of the run (i.e., a static training set), and when at each generation a new training set is sampled (i.e., a dynamic training set). This result is proven by observing that rows selected uniformly at random from the truth table are unlikely to assign more than Y = n/2 + ǫn input variables to true, and hence can be satisfied by inserting any one of a linear number of variables into the solution; after log n/Y (2s) successful insertions, the probability that some row of the s-row training set is still not satisfied is at most n/2, and hence in expectation the process satisfies all rows after 2k = O(log n) distinct variables are successfully inserted into the tree.</p>
<p>Theorem 26 also yields a lower bound on the generalization error of the solution: if it contains at most O(log n) variables, the probability that its output is wrong on a truth table row sampled uniformly at random is 2 −O(log n) = n −O(1) , i.e., requiring in expectation a polynomial number of samples taken uniformly at random from C before a divergence from the target function is discovered.</p>
<p>Theorem 26 has been extended to cover the (1 + 1) GP and (1 + 1) GP * algorithms, using the Multiplicative Drift Theorem to provide a runtime bound on the expected time to fit the static polynomial-sized training set [21]. Additionally, a similar bound holds if instead of a static training set, each iteration samples s independent rows of the complete truth table to compare the fitness of two solutions (using a dynamic training set).</p>
<p>Theorem 27 ([21]</p>
<p>). Let s = n 2c+ǫ rows from the complete truth table of the AND problem be sampled with replacement and uniformly at random in each iteration (where c &gt; 0 and ǫ &gt; 0 are any constants). Then, RLS-GP, RLS-GP * , (1 + 1) GP, (1 + 1) GP * , will construct a solution with a generalization error of at most n −c in expected O(log n) iterations. In expected O(log 2 n) iterations, the non-strictly elitist algorithms will construct a solution with a sampled error of 0.</p>
<p>Here, the training set size s is chosen to be sufficiently large to ensure that solutions with a generalization error greater than n −c are wrong on at least one training set row with high probability, preventing the GP system from terminating with a bad solution early, while the O(log 2 n) runtime bound stems from a random walk argument pessimistically considering the probabilities of accepting solutions increasing or decreasing the number of distinct variables in the tree being equal.</p>
<p>Extended Function and Terminal Sets</p>
<p>While the AND problem uses minimal function and terminal sets necessary to represent the optimal solution, both sets can be enlarged to represent a lack of knowledge regarding which components are actually necessary in order to solve a problem. These extensions lead to considerably more realistic applications of GP.</p>
<p>The AND n,m problem is a variant of the AND problem in which the target function is a conjunction of m &lt; n distinct variables from the terminal set L. This is similar to the setting considered by [51], and has been analyzed for the RLS-GP algorithms in [21], where the RLS-GP and RLS-GP * (while disallowing the HVL-Prime substitution sub-operation) algorithms are able to construct the optimum solution on the AND n,m problem in an expected O(n log n) iterations, while the canonical RLS-GP * will with high probability fail to find the optimum.</p>
<p>Theorem 28 ([21]). The RLS-GP algorithm, and the RLS-GP * algorithm (without the substitution HVL-Prime operation) find the optimum on the AND n,m problem in expected O(n log n) iterations when using the complete training set.</p>
<p>The RLS-GP * algorithm (with the substitution operation) will with high probability fail to find the optimum on the AND n,m problem when m = cn for any constant 0 &lt; c &lt; 1 when using the complete training set.</p>
<p>The analysis relies on showing that initially, inserting both variables that are present in the target function ("correct" variables), and those that are not ("incorrect" variables), is beneficial for the fitness value of the candidate solution, while removing incorrect variables only becomes beneficial after all correct variables are present in the current solution. With local search mutation and the substitution sub-operation of HVL-Prime, it is possible for the RLS-GP * to accept a solution which substitutes the last copy of some incorrect variable with another copy of a still-present incorrect variable in the solution. If this occurs, RLS-GP * will not be able to reach the global optimum, as no single application of HVL-Prime is capable of removing a leaf node containing an incorrect variable present multiple times in the current solution while improving fitness.</p>
<p>It is conjectured that a similar bound holds for the runtime of the (1 + 1) GP and (1 + 1) GP * algorithms, which are able to introduce and remove duplicate terminals in the solution using larger mutation operations.</p>
<p>The function set could also be enlarged by introducing additional Boolean operators, such as OR or NOT, aiming to provide the GP with the expressive power necessary to represent any Boolean function. Mambrini and Oliveto have shown that if the unary NOT operation is introduced (by extending the set of literals with negated versions of each variable, avoiding the need to modify the HVL-Prime mutation operator to deal with non-binary functions), the RLS-GP algorithms are no longer able to efficiently construct the optimum solution on the AND problem using the complete training set [25]; this was extended by Lissovoi and Oliveto to cover the (1 + 1) GP algorithms [21]. Theorem 29 ([25,21]). The RLS-GP, RLS-GP * , (1 + 1) GP and (1 + 1) GP * algorithms on the AND problem with L = {x 1 , . . . , x n , x 1 , . . . , x n } do not construct an optimal solution in polynomial time with overwhelming probability when using the complete training set.</p>
<p>This result follows from the observation that a solution containing a conjunction of both a variable x i and its negation x i always evaluates to false, and hence has a nearly-optimal fitness value of 1 (i.e., it is wrong on just one of 2 n possible inputs). Such a pair of literals is shown to be present in the current solution with overwhelming probability once it contains n/2 distinct literals. For the strictly elitist GP algorithms, reaching the global optimum would then require a large simultaneous mutation with an exponential waiting time, while the non-strictly elitist GPs need to essentially perform a random walk in 2n dimensions and reach a particular point while receiving little guidance from the fitness function.</p>
<p>Additionally, even if the GP systems could be prevented from accepting any solution containing a contradiction (for instance, by weighing the all-true variable assignment much higher than any other input), the RLS-GP and (1 + 1) GP algorithms still require exponential time to find the global optimum, as all nonoptimal solutions containing all n variables (in either the positive or negated form) share the same fitness value (2 n − 2, being wrong on the all-true input, and the single assignment satisfying the solution but not the target function), and it the closer the GP system is to having all n positive literals, the more likely mutation is to produce an offspring which replaces a positive literal with a negative one.</p>
<p>From a problem hardness perspective, it was shown that there exist small training sets of O(n) rows which allow the RLS-GP and (1 + 1) GP algorithms to find exact solutions (with a generalization error of 0) to the AND, the AND n,m , and the AND (with NOT) problems efficiently. In general, identifying such training sets may be non-trivial. In the case of the NOT-extended AND problem, a variant of the (1 + 1) GP which maintains and randomly selects from a population of µ individuals subject to a diversity mechanism prohibiting multiple solutions with identical outputs on the training set was proven to find an optimal solution in O(µn log n) iterations on an n + 1 row training set (consisting of all the inputs in M and an input where all the n variables are set to true) [21].</p>
<p>Evolving Parity</p>
<p>The XOR problem is that of evolving an exclusive disjunction of all n input variables. The fitness of a tree X using a training set T selected from the rows of the complete truth table C is the number of training set rows on which the value produced by evaluating the Boolean expression represented by the tree differs from the output of the exclusive disjunction of all n inputs.</p>
<p>When using the complete truth table as the training set, the fitness of any non-optimal solution is 2 n−1 , while the fitness of the optimal solution is 0. Thus, using the complete training set on XOR is similar to the Needle benchmark problem; Langdon and Poli note that "the fitness landscape is like a needle-ina-haystack, so any adaptive search approach will have difficulties" [19], and the problem is known not to be evolvable in the PAC-learning framework [51].</p>
<p>Predictably, the RLS-GP and (1 + 1) GP algorithms are not able to optimize XOR efficiently. Strictly elitist variants of GP algorithms will not move from their initial solution unless the optimum is constructed directly, which is typically not possible for the RLS-GP * , and occurs in expected exponential time for the (1 + 1) GP * , which needs to essentially construct the complete function in one mutation consisting of at least n HVL-Prime sub-operations. When using the complete training set, the expected optimization time for the RLS-GP is exponential, as the algorithms accepts any and all mutations, while reaching the optimal solution requires all n variables to appear an odd number of times in the solution [25].</p>
<p>Theorem 32 (Theorem 4, [25]). The RLS-GP using F = {XOR} and L = {x 1 , . . . , x n } to evolve XOR n using the complete truth table as training set requires more than 2 Ω(n/log n) iterations with probability p &gt; 1 − 2 −Ω(n/log n) to reach the optimum.</p>
<p>The theorem is proven by an application of the simplified negative drift theorem, showing that when the number of variables that appear in the current solution an odd number of times is large, there is a strong negative drift toward reducing this number, and the optimum requires all n distinct variables to appear an odd number of times in the solution. The negative drift stems primarily from the HVL-Prime insertion operator: if a large number of variables is represented an odd number of times, it is more likely to insert one of these variables when choosing a terminal uniformly at random.</p>
<p>While sampling solution fitness using a polynomial number of complete training set rows is also possible on XOR, the outcome is generally underwhelming: if only a logarithmically small number of training set rows are sampled in each iteration, the algorithm will in expected polynomial time terminate with a nonoptimal solution that fit the sampled training set, while using training sets of super-logarithmic size will lead to super-polynomial optimization time. Thus, in any polynomial amount of time, the expected generalization ability of the considered GP systems on XOR is 1/2, i.e., requiring in expectation a constant number of samples taken uniformly at random from C before a divergence from the target function is discovered.</p>
<p>There is also a straightforward extension of Theorem 32 to dynamic training sets of polynomial size, as such sampling provides no consistent indication of fitness.</p>
<p>Corollary 33. The RLS-GP and (1 + 1) GP algorithms sampling s ∈ ω(log n) rows of the complete truth table in each iteration on XOR n with F = {XOR} and L = {x 1 , . . . , x n } with high probability do not reach the optimum in polynomial time.</p>
<p>Proof. The RLS-GP and (1 + 1) GP algorithms will accept any non-optimal offspring of a non-optimal parent with probability at least 1/2, as both the offspring and the parent are wrong on 2 n−1 inputs, and there are exactly as many rows on which the offspring is correct while the parent is wrong as the converse, and the offspring is accepted in cases of tied fitness.</p>
<p>With s ∈ ω(log n) rows sampled uniformly at random in each iteration, the probability that a non-optimal solution is correct on all sampled rows is 2 −ω(log n) = n −ω(1) , and by a straightforward union bound, the GP algorithms do not terminate within polynomial time unless the optimal solution is found.</p>
<p>With the exception of any iterations in which the offspring individual is rejected, the algorithms behave identically to the RLS-GP and (1 + 1) GP algorithms using the complete truth table to evaluate solution fitness (i.e., accepting offspring regardless of the effects of mutation), and thus cannot achieve better performance than these algorithms in terms of the number of iterations performed.</p>
<p>Theorem 32 only provides a runtime bound for the RLS-GP. A similar result for the (1 + 1) GP can be obtained by observing that (1 + 1) GP performs in expectation two HVL-Prime sub-operations in each iteration, and hence even if the algorithm terminated immediately upon constructing the optimal solution (even if this occurred in the middle of a mutation), it would in expectation be only a constant factor faster than RLS-GP in terms of the number of iterations required to find the optimum.</p>
<p>Other GP Algorithms</p>
<p>The previous sections covered the available theoretical results for standard treebased GP systems, which constitute the majority of GP theoretical complexity analysis results. In this section, we present a slightly different approach to GP system design, which aims to evolve programs semantically rather than syntactically.</p>
<p>Geometric Semantic Genetic Programming</p>
<p>Standard tree-based GP evolves programs by applying mutation and crossover to their syntax. Programs that are considerably different syntactically may produce identical output while introducing minimal syntactic mutations may completely change the output of a program. Moraglio et al. [30] introduced Geometric Semantic GP (GSGP) with the aim of focusing GP search on program behavior. In particular, GSGP mutation and crossover operators modify programs in a way that allows the GP system to search through the semantic neighborhood (which consists of programs with similar behavior) rather than their syntactic neighborhood (which consists of programs with similar syntax).</p>
<p>GSGP generally uses a natural program representation for the domain at hand (e.g., representing programs using Boolean expressions when a Boolean expression is to be evolved), and uses specialized semantic mutation and crossover operators to produce offspring programs with behavior similar to that of their parents. These operators generally reproduce the parent programs in their entirety, adding to them to modify their behavior in a limited fashion. For example, the GSGP mutation operator might produce an offspring which contains an exact copy of its parent and a random element which overrides some portions of the parent's behavior, while the GSGP crossover operator could construct an offspring containing exact copies of both parents and a random element which switches between the two behaviors depending on the inputs. As both operators increase the size of the programs by adding additional syntax to the parent programs to encode the chosen random components (and the crossover includes exact copies of both parents), the programs produced by these operators need to be simplified in order for the algorithm to remain tractable. For some domains, like Boolean functions, quick function-preserving simplifiers exist, while computer algebra systems and static analysis can be used to simplify more complex expressions and programs [30].</p>
<p>Initial experimental results suggest that GSGP consistently finds solutions that fit the training sets used for a wide array of simple Boolean benchmark functions, regression problems for polynomials of degree up to 10, and various classification problems, outperforming standard tree-based GP with the same evaluation budget [30]. Semantic geometric crossover and mutation operators have been designed for many problem domains, including regression problems [31]), learning classification trees [24], and Boolean functions [32]. In these papers, theoretical guarantees are derived regarding the number of generations it takes GSGP to construct a solution fitting the training set (or achieving an ǫ-small training set error in the case of regression problems). In this section, we explore the theoretical results focusing on the latter setting: applying geometric semantic search to evolving Boolean functions.</p>
<p>In the case of Boolean functions, the program semantics can be represented by the 2 n -row output vector, corresponding to the program output on all rows of the complete n-variable truth table. In this setting, the semantic crossover operator SGXB, acting on two parents T 1 and T 2 , produces an offspring solution
(T 1 ∧ T R ) ∨ (T 2 ∧ T R ),
where T R is a randomly-generated Boolean function. This offspring outputs the solution produced by T 1 if T R evaluates to true, and the solution produced by T 2 if T R evaluates to false, effectively performing crossover on the 2 n -row output vectors of the two parent solutions. The semantic mutation operator SGMB, acting on a single parent T 1 , produces the offspring T 1 ∨M with probability 0.5, and T ∧ M with probability 0.5, where M is a random minterm (a conjunction where each variable appears either in positive or negated form) of all input variables. This effectively copies the output vector of T 1 , setting the rows on which M evaluates to true to either true or false.</p>
<p>These operators allow GSGP to always observe a cone fitness landscape on any Boolean function, i.e., the mutation operator is always able to improve the behavior of the parent program. This allows mutation-only GSGP to hill-climb its way to the optimal program for any function in this domain. However, as the output vector contains 2 n rows, hill-climbing by applying SGMB, which only affects one row per iteration, would take O(2 n log(2 n )) = O(n2 n ) iterations (by the coupon collector argument, or similarly to Randomized Local Search on a 2 n -bit OneMax function).</p>
<p>For GSGP on any Boolean function, a polynomially-sized training set can be viewed as a OneMax problem on a 2 n -bit string where only a polynomial number of bits are non-neutral (i.e., contribute to the solution's fitness). In that setting, the runtime can be improved by allowing mutations to flip more than one bit of the output vector per iteration (e.g. such that in expectation one non-neutral bit is affected per iteration). This setting is explored in [32], with various approaches to the design of mutation operators, establishing a hierarchy of operator expressiveness (based on how much of the search space they enable the GP system to explore), and considering the probability of fitting a training set of polynomial size. Their results show that while the Varying Block Mutation (VBM) operator, which in each iteration draws an incomplete minterm of v &lt; n variables chosen uniformly at random in each iteration (where v is a parameter), is more expressive than Fixed Block Mutation (FBM), which picks the v variables once during the run, or Fixed Alternative Block Mutation (FABM), which partitions the variables into v sets, and forms the minterm by picking a variable from each set uniformly at random in each iteration, there nevertheless exist training sets which GSGP using VBM cannot fit in any amount of time. Conversely, they also prove that the less-expressive FBM operator can with high probability fit a training set of polynomial size sampled uniformly at random from the complete truth table of any Boolean function.</p>
<p>Theorem 34 ([32]). Let a training set T consist of n c rows, with c a positive constant, sampled uniformly at random from any problem P . Then, GSGP using the Fixed Block Mutation (FBM) operator with v &gt; 2c log 2 (n) is able to fit T with probability at least 1 − 1 2 n −ǫ (for any ǫ &gt; 0); conditioning on this, a function fitting the training set is found in an expected O(n 2c log n) iterations.</p>
<p>This result is proven by observing that FBM's initial choice of v variables (to use as the basis for the minterms) partitions the 2 n row output vector of P into 2 v blocks of equal size, each corresponding to a particular minterm of the v variables. Choosing v &gt; 2c log 2 n partitions the output vector into more than 2 2c log 2 n = n 2c blocks, ensuring that with high probability all n c training set rows (chosen uniformly at random from the complete truth table) are in different blocks, and thus the training set can be satisfied by collecting the exact minterms corresponding to the blocks which contain the training set rows. When this condition holds, the expected runtime is obtained by a Coupon Collector argument.</p>
<p>Of course, if FBM chooses the v variables poorly with respect to the training set T (meaning that at least two training set rows demanding different output are contained in the same block), GSGP will not be able to fit the training set. More expressive operators such as FABM or VBM can minimize this probability at the cost of a mild runtime penalty by allowing the mutation operator to be more flexible when choosing which variables to use as the basis for the minterm (e.g. increasing the runtime by a factor of n/v, but improving the success probability from p to 1 − (1 − p) n/v where v is number classes in the partition created by FABM).</p>
<p>There are also modifications of the GSGP mutation operators that are able to cover the entire search space of programs, eliminating the possibility of failure. There exist classes of Boolean functions on which such operators are effective, allowing the GSGP to fit any training set in expected polynomial time, as shown in the following theorem. The MSBM mutation operator is a modification of the VBM variant of the SGMB operator. It samples an integer v between 0 and n, selects v variables from the set of n input variables, and then generates uniformly at random an incomplete minterm M of these variables. This modified mutation operator essentially allows each clause of the target function to be "fixed" in the current solution in expected polynomial number of iterations.</p>
<p>At present, there is no theoretical analysis of how the functions produced by GSGP generalize to unseen inputs. The issue has been considered experimentally [43,42,29], with results suggesting that while the initially proposed geometric semantic crossover and mutation operators often achieve poor generalization despite good training set performance, other variants of the semantic operators and algorithm components may be able to achieve better generalization performance.</p>
<p>Conclusion</p>
<p>We have presented an overview of the available results in the computational complexity analysis of GP algorithms. The results follow the blueprint suggested by Poli et al., starting with the analysis of simple GP systems based on mutation and stochastic-hill climbing on simple problems [45]. The complexity of the problems has slowly increased, from the analysis focusing on the main characteristic difficulties of GP (i.e., variable solution length, and solution quality evaluations) to more recent results considering the evolution of functions with true input/output behavior and using realistically constrained fitness functions. The approach of gradually expanding the complexity of analyzed systems was also endorsed by Goldberg and O'Reilly, who stated that the "methodology of using deliberately designed problems, isolating specific properties, and pursuing, in detail, their relationships in simple GP is more than sound; it is the only practical means of systematically extending GP understanding and design" [11].</p>
<p>The GP systems considered for theoretical analysis have remained relatively simple: applying HVL-prime mutation and limited, if any, populations with no crossover are a common setting. In many cases, the analysis for the positive runtime results is only made tractable because "the fitness structure of the model problems is simple, and the algorithms use only a simple hierarchical variable length mutation operator" [7]. In particular, variable length representations and bloat often complicate the analysis of GP systems, and require "rather deep insights into the optimization process and the growth of the GP-trees" [5].</p>
<p>For GP systems utilizing geometric semantic mutation and crossover operators, analyses of the time required to produce a solution fitting the training set are available for wider classes of functions, and frequently do not require insight into the structure of the considered function. However, theoretical analyses of how well the GSGP solutions generalize -how well they perform on inputs not included in the training set -remain a challenge.</p>
<p>While the presented results represent first steps in rigorously analyzing the behavior of GP systems, bridging the gap to the GP systems used in practice requires analyzing more complex GP algorithms on more realistic problems. Thus, extending the presented results to broader classes of problems (for instance, those allowing more flexibility in program behavior), to other problem classes on which GP experimentally performs well (such as symbolic regression), and to more realistic GP algorithms (introducing populations and crossover) are the main directions for further research.</p>
<p>Figure 1 :
1HVL-Prime sub-operations: substitution, insertion, and deletion.</p>
<p>Theorem 7 (
7[34]). Starting with an initial solution containing no redundant terminals, the expected optimization time of SMO-GP with k = 1 on WORDER is O(n 3 ).</p>
<p>Theorem 10 ([7]). Let T max denote the maximal tree size at any stage during the execution of the algorithm. Then, the expected optimization time of the RLS-GP on MAJORITY is O(n log n + DT max n log log n)</p>
<p>Theorem 14 ([34]). The expected optimization time of SMO-GP (with either k = 1 and k = 1 + Poisson</p>
<p>Problem 16 (
16SORTING). F := {J}, L := {1, 2, . . . , n}. The fitness of a tree X is computed by deriving a sequence π of symbols based on their first appearance in the in-order parse of X, and considering one of the five measures of sortedness of this sequence: INV(π) Number of pairs of adjacent elements in the correct order (maximize to sort), with INV(π) = 0.5 if |π| = 1. HAM(π) Number of elements in correct position (maximize to sort).</p>
<p>Theorem 17 ([53]). The expected optimization time for the RLS-GP * and (1 + 1) GP * algorithms on SORTING using INV as the sortedness measure is O(n 3 T max ), where n is the number of elements to be sorted, and T max is the maximum size of the tree during the run of the algorithm.For the HAM, RUN, LAS and EXC measures, there exist initial solutions with O(n) terminals such that the expected optimization time of RLS-GP * is infinite, and the expected optimization time of (1 + 1) GP * is e Ω(n) .</p>
<p>Problem 18 (
18MAX). F := {+, ×}, L := {t}, t &gt; 0 a positive constant, and maximum tree depth D.</p>
<p>Problem 22 (
22AND). F := {AND}, L := {x 1 , . . . , x n }.</p>
<p>Theorem 26 ([25,21]). Let s = poly(n) be the size of a training set chosen from the truth table uniformly at random with replacement. Then, both the RLS-GP and the RLS-GP * will fit the training set on the AND problem in expected time O(log s) = O(log n); with the solution containing at most O(log n) variables.</p>
<p>Theorem 30 ([21]). Let M be an n-row training set, where row i sets x i to false and all x j (where j = i) to true and M ′ be a 2n + 1-row training set containing all the rows of M and n + 1 copies of the row setting all inputs to true. The RLS-GP and (1 + 1) GP algorithms using the training sets M (M ′ respectively) are able to find the exact solution of AND n and AND n,m with F = {AN D}, L = {x 1 , . . . , x n } (AND n with F = {AN D} and L = {x 1 , . . . , x n , x 1 , . . . , x n }) in expected O(n log n) fitness evaluations (or O(n 2 log n) training set row evaluations).</p>
<p>Problem 31 (
31XOR). F := {XOR}, L := {x 1 , . . . , x n }.</p>
<p>Theorem 35 ([32]). Let φ be a disjunctive normal form (DNF) formula with α = poly(n) conjunctions, every conjunction containing at most β = O(1) variables. Then φ can be obtained by GSGP with Multiple Size Block Mutation (MSBM) in expected O(αn β+1 2 β ) iterations, i.e., polynomial time.</p>
<p>Table 1 :
1Known expected runtimes for GP algorithms on SORTING using var-
ious sortedness measures and bloat control mechanisms.  †: also holds with 
probability 1 − o(1) for the (1 + 1) GP. [1]: shown in [52], [2]: shown in 
In previous work, the name (1 + 1) GP was used for both algorithms, relying either on explicitly specifying k or using a suffix like (1 + 1) GP-multi and (1 + 1) GP-single to distinguish between the two variants. Our notation matches the conventions of runtime analysis of evolutionary algorithms[38,12].
Acknowledgements Financial support by the Engineering and Physical Sciences Research Council (EPSRC Grant No. EP/M004252/1) is gratefully acknowledged.
Linear Genetic Programming. No. XVI in Genetic and Evolutionary Computation. M Brameier, W Banzhaf, SpringerBrameier, M., Banzhaf, W.: Linear Genetic Programming. No. XVI in Genetic and Evolutionary Computation. Springer (2007)</p>
<p>Level-based analysis of genetic algorithms and other search processes. D Corus, D C Dang, A V Eremeev, P K Lehre, 10.1109/TEVC.2017.2753538IEEE Transactions on Evolutionary Computation. 99Corus, D., Dang, D.C., Eremeev, A.V., Lehre, P.K.: Level-based analysis of genetic algorithms and other search processes. IEEE Transactions on Evolutionary Computation (99), 1-1 (2017). DOI 10.1109/TEVC.2017. 2753538</p>
<p>Standard steady state genetic algorithms can hillclimb faster than mutation-only evolutionary algorithms. D Corus, P S Oliveto, DOI10.1109/TEVC.2017.2745715IEEE Transactions on Evolutionary Computation. 99Corus, D., Oliveto, P.S.: Standard steady state genetic algorithms can hill- climb faster than mutation-only evolutionary algorithms. IEEE Transac- tions on Evolutionary Computation (99), 1-1 (2017). DOI 10.1109/TEVC. 2017.2745715</p>
<p>Scaling genetic programming to large datasets using hierarchical dynamic subset selection. R Curry, P Lichodzijewski, M I Heywood, IEEE Trans. Systems, Man, and Cybernetics. 374Part BCurry, R., Lichodzijewski, P., Heywood, M.I.: Scaling genetic programming to large datasets using hierarchical dynamic subset selection. IEEE Trans. Systems, Man, and Cybernetics, Part B 37(4), 1065-1073 (2007)</p>
<p>Bounding bloat in genetic programming. B Doerr, T Kötzing, J A G Lagodzinski, J Lengler, Proceedings of the Genetic and Evolutionary Computation Conference. the Genetic and Evolutionary Computation ConferenceDoerr, B., Kötzing, T., Lagodzinski, J.A.G., Lengler, J.: Bounding bloat in genetic programming. In: Proceedings of the Genetic and Evolutionary Computation Conference (GECCO 2017), pp. 921-928 (2017)</p>
<p>On the analysis of the (1+1) evolutionary algorithm. S Droste, T Jansen, I Wegener, Theoretical Computer Science. 2761-2Droste, S., Jansen, T., Wegener, I.: On the analysis of the (1+1) evolu- tionary algorithm. Theoretical Computer Science 276(1-2), 51-81 (2002)</p>
<p>Computational complexity analysis of simple genetic programming on two problems modeling isolated program semantics. G Durrett, F Neumann, U O&apos;reilly, Proceedings of the 11th International Workshop on Foundations of Genetic Algorithms (FOGA 2011). the 11th International Workshop on Foundations of Genetic Algorithms (FOGA 2011)Durrett, G., Neumann, F., O'Reilly, U.: Computational complexity anal- ysis of simple genetic programming on two problems modeling isolated program semantics. In: Proceedings of the 11th International Workshop on Foundations of Genetic Algorithms (FOGA 2011), pp. 69-80 (2011)</p>
<p>A complete characterization of statistical query learning with applications to evolvability. V Feldman, Journal of Computer and System Sciences. 785Feldman, V.: A complete characterization of statistical query learning with applications to evolvability. Journal of Computer and System Sciences 78(5), 1444-1459 (2012)</p>
<p>Dynamic training subset selection for supervised learning in genetic programming. C Gathercole, P Ross, Proceedings of the 3rd International Conference on Parallel Problem Solving from Nature. the 3rd International Conference on Parallel Problem Solving from NaturePPSNGathercole, C., Ross, P.: Dynamic training subset selection for supervised learning in genetic programming. In: Proceedings of the 3rd International Conference on Parallel Problem Solving from Nature (PPSN 1994), pp. 312-321 (1994)</p>
<p>An adverse interaction between crossover and restricted tree depth in genetic programming. C Gathercole, P Ross, Proceedings of the 1st Annual Conference on Genetic Programming. the 1st Annual Conference on Genetic ProgrammingCambridge, MA, USAMIT PressGathercole, C., Ross, P.: An adverse interaction between crossover and re- stricted tree depth in genetic programming. In: Proceedings of the 1st Annual Conference on Genetic Programming, pp. 291-296. MIT Press, Cambridge, MA, USA (1996)</p>
<p>Where does the good stuff go, and why? how contextual semantics influences program structure in simple genetic programming. D E Goldberg, U O&apos;reilly, Genetic Programming, First European Workshop, Eu-roGP'98. Paris, FranceGoldberg, D.E., O'Reilly, U.: Where does the good stuff go, and why? how contextual semantics influences program structure in simple genetic programming. In: Genetic Programming, First European Workshop, Eu- roGP'98, Paris, France, April 14-15, 1998, Proceedings, pp. 16-36 (1998)</p>
<p>Analyzing Evolutionary Algorithms -The Computer Science Perspective. T Jansen, Natural Computing Series. SpringerJansen, T.: Analyzing Evolutionary Algorithms -The Computer Science Perspective. Natural Computing Series. Springer (2013)</p>
<p>Performance analysis of randomised search heuristics operating with a fixed budget. T Jansen, C Zarges, Theoretical Computer Science. 545Jansen, T., Zarges, C.: Performance analysis of randomised search heuris- tics operating with a fixed budget. Theoretical Computer Science 545, 39-58 (2014)</p>
<p>PAC learning and genetic programming. T Kötzing, F Neumann, R Spöhel, Proceedings of the Genetic and Evolutionary Computation Conference. the Genetic and Evolutionary Computation ConferenceKötzing, T., Neumann, F., Spöhel, R.: PAC learning and genetic pro- gramming. In: Proceedings of the Genetic and Evolutionary Computation Conference (GECCO 2011), pp. 2091-2096 (2011)</p>
<p>The max problem revisited: The importance of mutation in genetic programming. T Kötzing, A M Sutton, F Neumann, U O&apos;reilly, Theoretical Computer Science. 545Kötzing, T., Sutton, A.M., Neumann, F., O'Reilly, U.: The max problem revisited: The importance of mutation in genetic programming. Theoretical Computer Science 545, 94-107 (2014)</p>
<p>Genetic programming -on the programming of computers by means of natural selection. Complex adaptive systems. J R Koza, MIT PressKoza, J.R.: Genetic programming -on the programming of computers by means of natural selection. Complex adaptive systems. MIT Press (1992)</p>
<p>Human-competitive results produced by genetic programming. J R Koza, Genetic Programming and Evolvable Machines. 113-4Koza, J.R.: Human-competitive results produced by genetic programming. Genetic Programming and Evolvable Machines 11(3-4), 251-284 (2010)</p>
<p>Automated ab initio synthesis of complete designs of four patented optical lens systems by means of genetic programming. J R Koza, S H Al-Sakran, L W Jones, Artificial Intelligence for Engineering Design. 223Analysis and ManufacturingKoza, J.R., Al-Sakran, S.H., Jones, L.W.: Automated ab initio synthesis of complete designs of four patented optical lens systems by means of genetic programming. Artificial Intelligence for Engineering Design, Analysis and Manufacturing 22(3), 249-273 (2008)</p>
<p>Foundations of genetic programming. W B Langdon, R Poli, SpringerLangdon, W.B., Poli, R.: Foundations of genetic programming. Springer (2002)</p>
<p>Evolutionary synthesis of kinematic mechanisms. H Lipson, Artificial Intelligence for Engineering Design. 223Analysis and ManufacturingLipson, H.: Evolutionary synthesis of kinematic mechanisms. Artificial Intelligence for Engineering Design, Analysis and Manufacturing 22(3), 195-205 (2008)</p>
<p>On the time and space complexity of genetic programming for evolving boolean conjunctions. A Lissovoi, P S Oliveto, To appear in the proceedings of the Thirty-Second AAAI Conference on Artificial Intelligence (AAAI-18). Lissovoi, A., Oliveto, P.S.: On the time and space complexity of genetic programming for evolving boolean conjunctions (2018). To appear in the proceedings of the Thirty-Second AAAI Conference on Artificial Intelli- gence (AAAI-18).</p>
<p>Human-competitive evolved antennas. J D Lohn, G Hornby, D S Linden, Artificial Intelligence for Engineering Design. 223Analysis and ManufacturingLohn, J.D., Hornby, G., Linden, D.S.: Human-competitive evolved anten- nas. Artificial Intelligence for Engineering Design, Analysis and Manufac- turing 22(3), 235-247 (2008)</p>
<p>Lexicographic parsimony pressure. S Luke, L Panait, Proceedings of the Genetic and Evolutionary Computation Conference. the Genetic and Evolutionary Computation ConferenceLuke, S., Panait, L.: Lexicographic parsimony pressure. In: Proceedings of the Genetic and Evolutionary Computation Conference (GECCO 2002), pp. 829-836 (2002)</p>
<p>Theory-laden design of mutation-based geometric semantic genetic programming for learning classification trees. A Mambrini, L Manzoni, A Moraglio, Proceedings of the Congress on Evolutionary Computation (CEC 2013). the Congress on Evolutionary Computation (CEC 2013)Mambrini, A., Manzoni, L., Moraglio, A.: Theory-laden design of mutation-based geometric semantic genetic programming for learning clas- sification trees. In: Proceedings of the Congress on Evolutionary Compu- tation (CEC 2013), pp. 416-423 (2013)</p>
<p>On the analysis of simple genetic programming for evolving boolean functions. A Mambrini, P S Oliveto, Genetic Programming -19th. Mambrini, A., Oliveto, P.S.: On the analysis of simple genetic program- ming for evolving boolean functions. In: Genetic Programming -19th</p>
<p>European Conference. Porto, PortugalEuroGPEuropean Conference, EuroGP 2016, Porto, Portugal, March 30 -April 1, 2016, Proceedings, pp. 99-114 (2016)</p>
<p>Genetic programming. J Mcdermott, U O&apos;reilly, SpringerMcDermott, J., O'Reilly, U.: Genetic programming. In: Springer Hand- book of Computational Intelligence, pp. 845-869. Springer (2015)</p>
<p>J F Miller, Cartesian Genetic Programming. SpringerMiller, J.F. (ed.): Cartesian Genetic Programming. Natural Computing Series. Springer (2011)</p>
<p>Probability and computing -randomized algorithms and probabilistic analysis. M Mitzenmacher, E Upfal, Cambridge University PressMitzenmacher, M., Upfal, E.: Probability and computing -randomized algorithms and probabilistic analysis. Cambridge University Press (2005)</p>
<p>Geometric semantic genetic programming for recursive boolean programs. A Moraglio, K Krawiec, Proceedings of the Genetic and Evolutionary Computation Conference. the Genetic and Evolutionary Computation ConferenceMoraglio, A., Krawiec, K.: Geometric semantic genetic programming for recursive boolean programs. In: Proceedings of the Genetic and Evolution- ary Computation Conference (GECCO 2017), pp. 993-1000 (2017)</p>
<p>Geometric semantic genetic programming. A Moraglio, K Krawiec, C G Johnson, Proceedings of the 12th International Conference on Parallel Problem Solving from Nature (PPSN 2012). the 12th International Conference on Parallel Problem Solving from Nature (PPSN 2012)Moraglio, A., Krawiec, K., Johnson, C.G.: Geometric semantic genetic programming. In: Proceedings of the 12th International Conference on Parallel Problem Solving from Nature (PPSN 2012), pp. 21-31 (2012)</p>
<p>Runtime analysis of mutation-based geometric semantic genetic programming for basis functions regression. A Moraglio, A Mambrini, Proceedings of the Genetic and Evolutionary Computation Conference (GECCO 2013). the Genetic and Evolutionary Computation Conference (GECCO 2013)Moraglio, A., Mambrini, A.: Runtime analysis of mutation-based geometric semantic genetic programming for basis functions regression. In: Proceed- ings of the Genetic and Evolutionary Computation Conference (GECCO 2013), pp. 989-996 (2013)</p>
<p>Runtime analysis of mutationbased geometric semantic genetic programming on boolean functions. A Moraglio, A Mambrini, L Manzoni, Proceedings of the 12th International Workshop on Foundations of Genetic Algorithms (FOGA 2013). the 12th International Workshop on Foundations of Genetic Algorithms (FOGA 2013)Moraglio, A., Mambrini, A., Manzoni, L.: Runtime analysis of mutation- based geometric semantic genetic programming on boolean functions. In: Proceedings of the 12th International Workshop on Foundations of Genetic Algorithms (FOGA 2013), pp. 119-132 (2013)</p>
<p>Some new aspects of the coupon collector's problem. A N Myers, H S Wilf, SIAM Journal on Discrete Mathematics. 171Myers, A.N., Wilf, H.S.: Some new aspects of the coupon collector's prob- lem. SIAM Journal on Discrete Mathematics 17(1), 1-17 (2003)</p>
<p>Computational complexity analysis of multi-objective genetic programming. F Neumann, Proceedings of the Genetic and Evolutionary Computation Conference (GECCO 2012). the Genetic and Evolutionary Computation Conference (GECCO 2012)Neumann, F.: Computational complexity analysis of multi-objective ge- netic programming. In: Proceedings of the Genetic and Evolutionary Com- putation Conference (GECCO 2012), pp. 799-806 (2012)</p>
<p>Single-and multi-objective genetic programming: new bounds for weighted order and majority. A Nguyen, T Urli, M Wagner, Proceedings of the 12th International Workshop on Foundations of Genetic Algorithms (FOGA 2013). the 12th International Workshop on Foundations of Genetic Algorithms (FOGA 2013)Nguyen, A., Urli, T., Wagner, M.: Single-and multi-objective genetic pro- gramming: new bounds for weighted order and majority. In: Proceedings of the 12th International Workshop on Foundations of Genetic Algorithms (FOGA 2013), pp. 161-172 (2013)</p>
<p>On the runtime analysis of the simple genetic algorithm. P S Oliveto, C Witt, Theoretical Computer Science. 545Oliveto, P.S., Witt, C.: On the runtime analysis of the simple genetic algorithm. Theoretical Computer Science 545, 2-19 (2014)</p>
<p>Improved time complexity analysis of the simple genetic algorithm. P S Oliveto, C Witt, Theoretical Computer Science. 605Oliveto, P.S., Witt, C.: Improved time complexity analysis of the simple genetic algorithm. Theoretical Computer Science 605, 21-41 (2015)</p>
<p>Runtime analysis of evolutionary algorithms for discrete optimization. P S Oliveto, X Yao, Theory of Randomized Search Heuristics: Foundations and Recent Developments. A. Auger, B. DoerrWorld ScientificOliveto, P.S., Yao, X.: Runtime analysis of evolutionary algorithms for discrete optimization. In: A. Auger, B. Doerr (eds.) Theory of Randomized Search Heuristics: Foundations and Recent Developments, chap. 2, pp. 21- 52. World Scientific (2011)</p>
<p>Program search with a hierarchical variable lenght representation: Genetic programming, simulated annealing and hill climbing. U O&apos;reilly, F Oppacher, Proceedings of the 3rd International Conference on Parallel Problem Solving from Nature. the 3rd International Conference on Parallel Problem Solving from NaturePPSN 1994)O'Reilly, U., Oppacher, F.: Program search with a hierarchical variable lenght representation: Genetic programming, simulated annealing and hill climbing. In: Proceedings of the 3rd International Conference on Parallel Problem Solving from Nature (PPSN 1994), pp. 397-406 (1994)</p>
<p>An analysis of genetic programming. U M O&apos;reilly, Ottawa, Ontario, CanadaCarleton University, Ottawa-Carleton Institute for Computer SciencePh.D. thesisO'Reilly, U.M.: An analysis of genetic programming. Ph.D. thesis, Car- leton University, Ottawa-Carleton Institute for Computer Science, Ottawa, Ontario, Canada (1995)</p>
<p>A comparative analysis of genetic programming. U M O&apos;reilly, F Oppacher, Advances in Genetic Programming. P.J. Angeline, K.E. Kinnear, Jr.Cambridge, MA, USAMIT Press2O'Reilly, U.M., Oppacher, F.: A comparative analysis of genetic program- ming. In: P.J. Angeline, K.E. Kinnear, Jr. (eds.) Advances in Genetic Programming 2, chap. 2, pp. 23-44. MIT Press, Cambridge, MA, USA (1996)</p>
<p>Competent geometric semantic genetic programming for symbolic regression and boolean function synthesis. T P Pawlak, K Krawiec, Evolutionary Computation (Early Access). Pawlak, T.P., Krawiec, K.: Competent geometric semantic genetic pro- gramming for symbolic regression and boolean function synthesis. Evolu- tionary Computation (Early Access), 1-36 (2017)</p>
<p>Review and comparative analysis of geometric semantic crossovers. T P Pawlak, B Wieloch, K Krawiec, Genetic Programming and Evolvable Machines. 163Pawlak, T.P., Wieloch, B., Krawiec, K.: Review and comparative analysis of geometric semantic crossovers. Genetic Programming and Evolvable Machines 16(3), 351-386 (2015)</p>
<p>A Field Guide to Genetic Programming. R Poli, W B Langdon, N F Mcphee, Poli, R., Langdon, W.B., McPhee, N.F.: A Field Guide to Genetic Pro- gramming. http://lulu.com (2008)</p>
<p>Theoretical results in genetic programming: the next ten years?. R Poli, L Vanneschi, W B Langdon, N F Mcphee, Genetic Programming and Evolvable Machines. 113-4Poli, R., Vanneschi, L., Langdon, W.B., McPhee, N.F.: Theoretical results in genetic programming: the next ten years? Genetic Programming and Evolvable Machines 11(3-4), 285-320 (2010)</p>
<p>The choice of the offspring population size in the (1, λ) EA. J E Rowe, D Sudholt, Proceedings of the Genetic and Evolutionary Computation Conference (GECCO 2012). the Genetic and Evolutionary Computation Conference (GECCO 2012)Rowe, J.E., Sudholt, D.: The choice of the offspring population size in the (1, λ) EA. In: Proceedings of the Genetic and Evolutionary Computation Conference (GECCO 2012), pp. 1349-1356 (2012)</p>
<p>The analysis of evolutionary algorithms on sorting and shortest paths problems. J Scharnow, K Tinnefeld, I Wegener, Journal of Mathematical Modelling and Algorithms. 34Scharnow, J., Tinnefeld, K., Wegener, I.: The analysis of evolutionary al- gorithms on sorting and shortest paths problems. Journal of Mathematical Modelling and Algorithms 3(4), 349-366 (2004)</p>
<p>Automatic Quantum Computer Programming: A Genetic Programming Approach. L Spector, 10.1007/978-0-387-36791-0Genetic Programming. 7Kluwer Academic PublishersSpector, L.: Automatic Quantum Computer Programming: A Genetic Programming Approach, Genetic Programming, vol. 7. Kluwer Aca- demic Publishers, Boston/Dordrecht/New York/London (2004). DOI doi:10.1007/978-0-387-36791-0</p>
<p>Experimental supplements to the computational complexity analysis of genetic programming for problems modelling isolated program semantics. T Urli, M Wagner, F Neumann, Proceedings of the 12th International Conference on Parallel Problem Solving from Nature. the 12th International Conference on Parallel Problem Solving from NaturePPSN 2012Urli, T., Wagner, M., Neumann, F.: Experimental supplements to the computational complexity analysis of genetic programming for problems modelling isolated program semantics. In: Proceedings of the 12th In- ternational Conference on Parallel Problem Solving from Nature (PPSN 2012), pp. 102-112 (2012)</p>
<p>A theory of the learnable. L G Valiant, Communications of the ACM. 2711Valiant, L.G.: A theory of the learnable. Communications of the ACM 27(11), 1134-1142 (1984)</p>
<p>. L G Valiant, Evolvability. Journal of the ACM. 561Valiant, L.G.: Evolvability. Journal of the ACM 56(1), 3:1-3:21 (2009)</p>
<p>Parsimony pressure versus multi-objective optimization for variable length representations. M Wagner, F Neumann, Proceedings of the 12th International Conference on Parallel Problem Solving from Nature. the 12th International Conference on Parallel Problem Solving from NaturePPSN 2012Wagner, M., Neumann, F.: Parsimony pressure versus multi-objective op- timization for variable length representations. In: Proceedings of the 12th International Conference on Parallel Problem Solving from Nature (PPSN 2012), pp. 133-142 (2012)</p>
<p>On the performance of different genetic programming approaches for the SORTING problem. M Wagner, F Neumann, T Urli, Evolutionary Computation. 234Wagner, M., Neumann, F., Urli, T.: On the performance of different ge- netic programming approaches for the SORTING problem. Evolutionary Computation 23(4), 583-609 (2015)</p>            </div>
        </div>

    </div>
</body>
</html>