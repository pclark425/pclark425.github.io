<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-1612 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-1612</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-1612</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-31.html">extraction-schema-31</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <p><strong>Paper ID:</strong> paper-12457018</p>
                <p><strong>Paper Title:</strong> <a href="https://arxiv.org/pdf/1508.00468v1.pdf" target="_blank">Evolutionary Algorithms: Concepts, Designs, and Applications in Bioinformatics: Evolutionary Algorithms for Bioinformatics</a></p>
                <p><strong>Paper Abstract:</strong> Since genetic algorithm was proposed by John Holland (Holland J. H., 1975) in the early 1970s, the study of evolutionary algorithm has emerged as a popular research field (Civicioglu&Besdok, 2013). Researchers from various scientific and engineering disciplines have been digging into this field, exploring the unique power of evolutionary algorithms (Hadka&Reed, 2013). Many applications have been successfully proposed in the past twenty years. For example, mechanical design (Lampinen&Zelinka, 1999), electromagnetic optimization (Rahmat-Samii&Michielssen, 1999), environmental protection (Bertini, Felice, Moretti,&Pizzuti, 2010), finance (Larkin&Ryan, 2010), musical orchestration (Esling, Carpentier,&Agon, 2010), pipe routing (Furuholmen, Glette, Hovin,&Torresen, 2010), and nuclear reactor core design (Sacco, Henderson, Rios-Coelho, Ali,&Pereira, 2009). In particular, its function optimization capability was highlighted (Goldberg&Richardson, 1987) because of its high adaptability to different function landscapes, to which we cannot apply traditional optimization techniques (Wong, Leung,&Wong, 2009). Here we review the applications of evolutionary algorithms in bioinformatics.</p>
                <p><strong>Cost:</strong> 0.016</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e1612.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e1612.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>GP (tree-based)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Genetic Programming (tree-based representation)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A class of evolutionary algorithms that represent candidate solutions as tree-structured programs or expressions and apply crossover (subtree exchange, module crossover, etc.) and mutation (point, hoist, subtree replacement, etc.) to evolve functional programs or expressions.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Genetic Programming --An Introduction; On the Automatic Evolution of Computer Programs and its Applications.</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Genetic Programming (tree-based)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Represents solutions as trees (programs, boolean expressions, mathematical expressions). Evolution proceeds by selecting parents by fitness and applying genetic operators tailored to trees: crossover typically swaps subtrees between two parents (or within one parent), and mutation replaces or perturbs subtrees or node values. Often combined with selection pressures (fitness-proportional, tournament, rank) and bloat-control mechanisms (parsimony pressure, explicit penalties). Used here to evolve boolean-expression trees of k-mers for TF/TFBS modeling and more generally to evolve programs.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs / expressions / tree-structured programs (e.g. boolean expression trees, mathematical expressions)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Tree-aware crossover: typical operation is subtree-exchange crossover (select a subtree in each parent tree and swap them). Variants listed include self-crossover (swap subtrees within a single individual), module crossover (exchange higher-level modules), SCPC/WCPC (swap subtrees when coordinates match exactly or approximately).</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Tree-aware mutation variants: point mutation (change a node's value/operator/terminal), subtree mutation (replace a selected subtree with a newly generated subtree), hoist mutation (promote a subtree to become the whole individual), expansion/collapse mutations (replace subtree with terminal or vice versa), permutation of argument order, gene (subtree) duplication.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>program synthesis / symbolic modeling / motif-expression learning (e.g. TF/TFBS boolean expression trees)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Not evaluated quantitatively in this chapter; GP is discussed relative to canonical GA and other evolutionary methods; references to empirical comparisons (e.g. Luke & Spector 1998, White & Poulding 2009) are provided.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>The chapter reviews GP as the canonical way to evolve programs/expressions and lists many crossover and mutation operators; it notes an ongoing debate about the relative utility of crossover vs mutation (problem-dependent) and the bloat/intron phenomenon which can protect modules but also cause undesired code growth. Both crossover and mutation are recommended as a compromise in practice.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Evolutionary Algorithms: Concepts, Designs, and Applications in Bioinformatics: Evolutionary Algorithms for Bioinformatics', 'publication_date_yy_mm': '2015-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1612.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e1612.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>GP Operators (Table)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Genetic Programming crossover and mutation operators (table in chapter)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A catalog of common GP crossover and mutation operators (subtree exchange, self-crossover, module crossover, SCPC/WCPC; point mutation, permutation, hoist, expansion/collapse, subtree mutation, gene duplication) presented in the chapter.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Catalog of GP crossover and mutation operators</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>A compiled list of typical GP operators used when evolving trees/programs: crossover operators that recombine tree-structured parents (subtree exchange and variants) and mutation operators that perturb or replace parts of trees (point changes, subtree replacements, hoist, duplication, etc.). The table summarizes operators used in GP literature (cites Banzhaf et al. and others).</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>tree-structured programs / expressions / boolean-expression trees</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Enumerated: Subtree Exchange Crossover (swap subtrees between individuals), Self Crossover (swap within an individual), Module Crossover (exchange identified modules), SCPC (swap if coordinates match exactly), WCPC (swap if coordinates match approximately).</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Enumerated: Point Mutation (change node value), Permutation (change argument order), Hoist Mutation (use a subtree as new root), Expansion Mutation (replace a terminal with a subtree), Collapse Subtree Mutation (replace subtree with terminal), Subtree Mutation (replace subtree), Gene Duplication (duplicate a subtree).</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>genetic programming / program evolution / symbolic regression / motif-expression learning</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>The chapter explicitly lists and classifies GP crossover and mutation operators and emphasizes that operator choice is representation-dependent; it highlights the ongoing debate about the roles of crossover and mutation and the importance of bloat control (parsimony pressure or penalties).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Evolutionary Algorithms: Concepts, Designs, and Applications in Bioinformatics: Evolutionary Algorithms for Bioinformatics', 'publication_date_yy_mm': '2015-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1612.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e1612.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Wong2011 GP-kmer</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Evolutionary algorithm evolving boolean-expression trees of k-mers (Wong et al., 2011)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An evolutionary method that evolves pairs of boolean-expression trees over k-mers to represent generalized TF (amino-acid k-mer) and TFBS (DNA k-mer) binding patterns; uses genetic programming-style operators (crossover and mutation) to search the space of interpretable pattern expressions.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Generalizing and learning protein-DNA binding sequence representations by an evolutionary algorithm</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Evolutionary learning of boolean-expression k-mer trees</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Evolves paired trees (one for TF k-mers, one for TFBS k-mers) where each tree is a boolean expression combining k-mer terminals; parent selection and survival selection follow standard evolutionary approaches; both crossover (subtree exchange and GP-style recombination) and mutation operators (point changes, subtree replacement, hoist, duplication, etc.) are used to generate new candidate expression-pairs which are evaluated for their ability to capture TF-TFBS associations.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>textual sequence motifs (amino-acid k-mers and DNA k-mers) represented as boolean-expression trees</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>GP-style subtree crossover between paired boolean-expression trees (swap subtrees between two parent trees); the chapter notes that both crossover and mutation were adopted in the referenced method but does not fully enumerate the exact crossover parameterization used in that specific study.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>GP-style mutations including point mutation (change an operator or k-mer terminal), subtree mutation (replace a subtree with a new subtree), hoist/expansion/collapse variants as per GP practice; the chapter states both crossover and mutation were used as a compromise given debates in the literature.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>bioinformatics — discovery of TF (protein) and TFBS (DNA) binding sequence patterns (interpretable boolean expressions of k-mers)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Compared conceptually to association-rule mining (Apriori) and other motif-discovery/statistical methods; chapter does not report quantitative baselines for this GP approach in this excerpt.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>The chapter reports that Wong et al. (2011) used GP to generalize TF-TFBS pairs into interpretable boolean-expression representations; both crossover and mutation were included because literature shows their relative importance is problem-dependent. The chapter emphasizes interpretability of resulting expressions and cites cross-validation/verification against PDB/homology modeling in related work, but provides no numerical metrics here for novelty, diversity, or executability.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Evolutionary Algorithms: Concepts, Designs, and Applications in Bioinformatics: Evolutionary Algorithms for Bioinformatics', 'publication_date_yy_mm': '2015-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1612.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e1612.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Evolved buffer-overflow attacks (GP)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Evolving buffer overflow attack codes using genetic programming (case example)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An instance from literature where GP was used to evolve buffer-overflow exploit code; the evolved programs exploited GP bloat/introns to hide malicious payloads from intrusion detectors (qualitative demonstration).</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>On evolving buffer overflow attacks using genetic programming</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>GP-evolved buffer-overflow attack generation</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Genetic programming was used to evolve executable attack code (buffer overflow exploits). Tree-based genetic operators (subtree crossover, subtree mutation, duplication) cause structural variability; bloat/intron phenomena were exploited to conceal malicious sequences from detectors while preserving exploit functionality.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>executable code / exploit payloads (program code)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Standard GP subtree-exchange crossover applied to program trees, producing recombined code variants that may preserve functionality while altering structure to avoid detection.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Subtree mutation and point mutations that alter instructions/operators/terminals within program trees; gene duplication and hoist mutations used to create introns/bloat to obfuscate functional code segments.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Qualitative functional success measured by whether evolved exploit executes and evades detectors (reported in cited literature but not quantified in this chapter).</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Discussed qualitatively: presence of introns/bloat can both protect functional modules (increasing survivability/executability under crossover) and introduce unnecessary growth (reducing parsimony); used adversarially to hide exploits from detectors.</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>security / exploit generation / adversarial code evolution</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>The chapter cites this work as an example where GP-evolved code exploited the bloat/intron phenomenon to hide functional payloads from intrusion detection; this illustrates that GP can evolve executable code and that structural growth (bloat) has functional consequences for executability and detectability, but the chapter does not provide quantitative metrics from that study.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Evolutionary Algorithms: Concepts, Designs, and Applications in Bioinformatics: Evolutionary Algorithms for Bioinformatics', 'publication_date_yy_mm': '2015-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Genetic Programming --An Introduction; On the Automatic Evolution of Computer Programs and its Applications. <em>(Rating: 2)</em></li>
                <li>On evolving buffer overflow attacks using genetic programming <em>(Rating: 2)</em></li>
                <li>A Revised Comparison of Crossover and Mutation in Genetic Programming <em>(Rating: 2)</em></li>
                <li>A Rigorous Evaluation of Crossover and Mutation in Genetic Programming <em>(Rating: 2)</em></li>
                <li>Generalizing and learning protein-DNA binding sequence representations by an evolutionary algorithm <em>(Rating: 2)</em></li>
                <li>Genetic algorithms with sharing for multimodal function optimization <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-1612",
    "paper_id": "paper-12457018",
    "extraction_schema_id": "extraction-schema-31",
    "extracted_data": [
        {
            "name_short": "GP (tree-based)",
            "name_full": "Genetic Programming (tree-based representation)",
            "brief_description": "A class of evolutionary algorithms that represent candidate solutions as tree-structured programs or expressions and apply crossover (subtree exchange, module crossover, etc.) and mutation (point, hoist, subtree replacement, etc.) to evolve functional programs or expressions.",
            "citation_title": "Genetic Programming --An Introduction; On the Automatic Evolution of Computer Programs and its Applications.",
            "mention_or_use": "mention",
            "system_name": "Genetic Programming (tree-based)",
            "system_description": "Represents solutions as trees (programs, boolean expressions, mathematical expressions). Evolution proceeds by selecting parents by fitness and applying genetic operators tailored to trees: crossover typically swaps subtrees between two parents (or within one parent), and mutation replaces or perturbs subtrees or node values. Often combined with selection pressures (fitness-proportional, tournament, rank) and bloat-control mechanisms (parsimony pressure, explicit penalties). Used here to evolve boolean-expression trees of k-mers for TF/TFBS modeling and more generally to evolve programs.",
            "input_type": "programs / expressions / tree-structured programs (e.g. boolean expression trees, mathematical expressions)",
            "crossover_operation": "Tree-aware crossover: typical operation is subtree-exchange crossover (select a subtree in each parent tree and swap them). Variants listed include self-crossover (swap subtrees within a single individual), module crossover (exchange higher-level modules), SCPC/WCPC (swap subtrees when coordinates match exactly or approximately).",
            "mutation_operation": "Tree-aware mutation variants: point mutation (change a node's value/operator/terminal), subtree mutation (replace a selected subtree with a newly generated subtree), hoist mutation (promote a subtree to become the whole individual), expansion/collapse mutations (replace subtree with terminal or vice versa), permutation of argument order, gene (subtree) duplication.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "program synthesis / symbolic modeling / motif-expression learning (e.g. TF/TFBS boolean expression trees)",
            "comparison_baseline": "Not evaluated quantitatively in this chapter; GP is discussed relative to canonical GA and other evolutionary methods; references to empirical comparisons (e.g. Luke & Spector 1998, White & Poulding 2009) are provided.",
            "key_findings": "The chapter reviews GP as the canonical way to evolve programs/expressions and lists many crossover and mutation operators; it notes an ongoing debate about the relative utility of crossover vs mutation (problem-dependent) and the bloat/intron phenomenon which can protect modules but also cause undesired code growth. Both crossover and mutation are recommended as a compromise in practice.",
            "uuid": "e1612.0",
            "source_info": {
                "paper_title": "Evolutionary Algorithms: Concepts, Designs, and Applications in Bioinformatics: Evolutionary Algorithms for Bioinformatics",
                "publication_date_yy_mm": "2015-08"
            }
        },
        {
            "name_short": "GP Operators (Table)",
            "name_full": "Genetic Programming crossover and mutation operators (table in chapter)",
            "brief_description": "A catalog of common GP crossover and mutation operators (subtree exchange, self-crossover, module crossover, SCPC/WCPC; point mutation, permutation, hoist, expansion/collapse, subtree mutation, gene duplication) presented in the chapter.",
            "citation_title": "here",
            "mention_or_use": "mention",
            "system_name": "Catalog of GP crossover and mutation operators",
            "system_description": "A compiled list of typical GP operators used when evolving trees/programs: crossover operators that recombine tree-structured parents (subtree exchange and variants) and mutation operators that perturb or replace parts of trees (point changes, subtree replacements, hoist, duplication, etc.). The table summarizes operators used in GP literature (cites Banzhaf et al. and others).",
            "input_type": "tree-structured programs / expressions / boolean-expression trees",
            "crossover_operation": "Enumerated: Subtree Exchange Crossover (swap subtrees between individuals), Self Crossover (swap within an individual), Module Crossover (exchange identified modules), SCPC (swap if coordinates match exactly), WCPC (swap if coordinates match approximately).",
            "mutation_operation": "Enumerated: Point Mutation (change node value), Permutation (change argument order), Hoist Mutation (use a subtree as new root), Expansion Mutation (replace a terminal with a subtree), Collapse Subtree Mutation (replace subtree with terminal), Subtree Mutation (replace subtree), Gene Duplication (duplicate a subtree).",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "genetic programming / program evolution / symbolic regression / motif-expression learning",
            "comparison_baseline": null,
            "key_findings": "The chapter explicitly lists and classifies GP crossover and mutation operators and emphasizes that operator choice is representation-dependent; it highlights the ongoing debate about the roles of crossover and mutation and the importance of bloat control (parsimony pressure or penalties).",
            "uuid": "e1612.1",
            "source_info": {
                "paper_title": "Evolutionary Algorithms: Concepts, Designs, and Applications in Bioinformatics: Evolutionary Algorithms for Bioinformatics",
                "publication_date_yy_mm": "2015-08"
            }
        },
        {
            "name_short": "Wong2011 GP-kmer",
            "name_full": "Evolutionary algorithm evolving boolean-expression trees of k-mers (Wong et al., 2011)",
            "brief_description": "An evolutionary method that evolves pairs of boolean-expression trees over k-mers to represent generalized TF (amino-acid k-mer) and TFBS (DNA k-mer) binding patterns; uses genetic programming-style operators (crossover and mutation) to search the space of interpretable pattern expressions.",
            "citation_title": "Generalizing and learning protein-DNA binding sequence representations by an evolutionary algorithm",
            "mention_or_use": "mention",
            "system_name": "Evolutionary learning of boolean-expression k-mer trees",
            "system_description": "Evolves paired trees (one for TF k-mers, one for TFBS k-mers) where each tree is a boolean expression combining k-mer terminals; parent selection and survival selection follow standard evolutionary approaches; both crossover (subtree exchange and GP-style recombination) and mutation operators (point changes, subtree replacement, hoist, duplication, etc.) are used to generate new candidate expression-pairs which are evaluated for their ability to capture TF-TFBS associations.",
            "input_type": "textual sequence motifs (amino-acid k-mers and DNA k-mers) represented as boolean-expression trees",
            "crossover_operation": "GP-style subtree crossover between paired boolean-expression trees (swap subtrees between two parent trees); the chapter notes that both crossover and mutation were adopted in the referenced method but does not fully enumerate the exact crossover parameterization used in that specific study.",
            "mutation_operation": "GP-style mutations including point mutation (change an operator or k-mer terminal), subtree mutation (replace a subtree with a new subtree), hoist/expansion/collapse variants as per GP practice; the chapter states both crossover and mutation were used as a compromise given debates in the literature.",
            "uses_literature": false,
            "uses_code": false,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "bioinformatics — discovery of TF (protein) and TFBS (DNA) binding sequence patterns (interpretable boolean expressions of k-mers)",
            "comparison_baseline": "Compared conceptually to association-rule mining (Apriori) and other motif-discovery/statistical methods; chapter does not report quantitative baselines for this GP approach in this excerpt.",
            "key_findings": "The chapter reports that Wong et al. (2011) used GP to generalize TF-TFBS pairs into interpretable boolean-expression representations; both crossover and mutation were included because literature shows their relative importance is problem-dependent. The chapter emphasizes interpretability of resulting expressions and cites cross-validation/verification against PDB/homology modeling in related work, but provides no numerical metrics here for novelty, diversity, or executability.",
            "uuid": "e1612.2",
            "source_info": {
                "paper_title": "Evolutionary Algorithms: Concepts, Designs, and Applications in Bioinformatics: Evolutionary Algorithms for Bioinformatics",
                "publication_date_yy_mm": "2015-08"
            }
        },
        {
            "name_short": "Evolved buffer-overflow attacks (GP)",
            "name_full": "Evolving buffer overflow attack codes using genetic programming (case example)",
            "brief_description": "An instance from literature where GP was used to evolve buffer-overflow exploit code; the evolved programs exploited GP bloat/introns to hide malicious payloads from intrusion detectors (qualitative demonstration).",
            "citation_title": "On evolving buffer overflow attacks using genetic programming",
            "mention_or_use": "mention",
            "system_name": "GP-evolved buffer-overflow attack generation",
            "system_description": "Genetic programming was used to evolve executable attack code (buffer overflow exploits). Tree-based genetic operators (subtree crossover, subtree mutation, duplication) cause structural variability; bloat/intron phenomena were exploited to conceal malicious sequences from detectors while preserving exploit functionality.",
            "input_type": "executable code / exploit payloads (program code)",
            "crossover_operation": "Standard GP subtree-exchange crossover applied to program trees, producing recombined code variants that may preserve functionality while altering structure to avoid detection.",
            "mutation_operation": "Subtree mutation and point mutations that alter instructions/operators/terminals within program trees; gene duplication and hoist mutations used to create introns/bloat to obfuscate functional code segments.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Qualitative functional success measured by whether evolved exploit executes and evades detectors (reported in cited literature but not quantified in this chapter).",
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": "Discussed qualitatively: presence of introns/bloat can both protect functional modules (increasing survivability/executability under crossover) and introduce unnecessary growth (reducing parsimony); used adversarially to hide exploits from detectors.",
            "frontier_characterization": null,
            "benchmark_or_domain": "security / exploit generation / adversarial code evolution",
            "comparison_baseline": null,
            "key_findings": "The chapter cites this work as an example where GP-evolved code exploited the bloat/intron phenomenon to hide functional payloads from intrusion detection; this illustrates that GP can evolve executable code and that structural growth (bloat) has functional consequences for executability and detectability, but the chapter does not provide quantitative metrics from that study.",
            "uuid": "e1612.3",
            "source_info": {
                "paper_title": "Evolutionary Algorithms: Concepts, Designs, and Applications in Bioinformatics: Evolutionary Algorithms for Bioinformatics",
                "publication_date_yy_mm": "2015-08"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Genetic Programming --An Introduction; On the Automatic Evolution of Computer Programs and its Applications.",
            "rating": 2,
            "sanitized_title": "genetic_programming_an_introduction_on_the_automatic_evolution_of_computer_programs_and_its_applications"
        },
        {
            "paper_title": "On evolving buffer overflow attacks using genetic programming",
            "rating": 2,
            "sanitized_title": "on_evolving_buffer_overflow_attacks_using_genetic_programming"
        },
        {
            "paper_title": "A Revised Comparison of Crossover and Mutation in Genetic Programming",
            "rating": 2,
            "sanitized_title": "a_revised_comparison_of_crossover_and_mutation_in_genetic_programming"
        },
        {
            "paper_title": "A Rigorous Evaluation of Crossover and Mutation in Genetic Programming",
            "rating": 2,
            "sanitized_title": "a_rigorous_evaluation_of_crossover_and_mutation_in_genetic_programming"
        },
        {
            "paper_title": "Generalizing and learning protein-DNA binding sequence representations by an evolutionary algorithm",
            "rating": 2,
            "sanitized_title": "generalizing_and_learning_proteindna_binding_sequence_representations_by_an_evolutionary_algorithm"
        },
        {
            "paper_title": "Genetic algorithms with sharing for multimodal function optimization",
            "rating": 1,
            "sanitized_title": "genetic_algorithms_with_sharing_for_multimodal_function_optimization"
        }
    ],
    "cost": 0.015717000000000002,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>Evolutionary Algorithms: Evolutionary Algorithms: Evolutionary Algorithms: Evolutionary Algorithms: Concepts, Concepts, Concepts, Concepts, Designs, Designs, Designs, Designs, and Applications in and Applications in and Applications in and Applications in</p>
<p>Ka-Chun Wong 
Bioinformatics Bioinformatics Bioinformatics Bioinformatics Evolutionary Algorithms for Bioinformatics Evolutionary Algorithms for Bioinformatics Evolutionary Algorithms for Bioinformatics Evolutionary Algorithms for Bioinformatics</p>
<p>Department of Computer Science
University of Toronto
OntarioCanada INTRODUCTION</p>
<p>Evolutionary Algorithms: Evolutionary Algorithms: Evolutionary Algorithms: Evolutionary Algorithms: Concepts, Concepts, Concepts, Concepts, Designs, Designs, Designs, Designs, and Applications in and Applications in and Applications in and Applications in
BE8A7ADF1846928FEE7600FCB6692F8D
Since genetic algorithm was proposed by John Holland(Holland J. H., 1975)in the early 1970s, the study of evolutionary algorithm has emerged as a popular research field(Civicioglu &amp; Besdok, 2013).Researchers from various scientific and engineering disciplines have been digging into this field, exploring the unique power of evolutionary algorithms(Hadka &amp; Reed, 2013).Many applications have been successfully proposed in the past twenty years.</p>
<p>BACKGROUND</p>
<p>Evolutionary algorithms draw inspiration from nature.An evolutionary algorithm starts with a randomly initialized population.The population then evolves across several generations.In each generation, fit individuals are selected to become parent individuals.They cross-over with each other to generate new individuals, which are subsequently called offspring individuals.Randomly selected offspring individuals then undergo certain mutations.After that, the algorithm selects the optimal individuals for survival to the next generation according to the survival selection scheme designed in advance.For instance, if the algorithm is overlapping (De Jong, 2006), then both parent and offspring populations will participate in the survival selection.Otherwise, only the offspring population will participate in the survival selection.The selected individuals then survive to the next generation.Such a procedure is repeated again and again until a certain termination condition is met (Wong, Leung, &amp; Wong, 2010).Figure 1 outlines a typical evolutionary algorithm</p>
<p>Figure 1. Major components of a typical evolutionary algorithm</p>
<p>In this book chapter, we follow the unified approach proposed by De Jong (De Jong, 2006).The design of evolutionary algorithm can be divided into several components: representation, parent selection, crossover operators, mutation operators, survival selection, and termination condition.Details can be found in the following sections.</p>
<p>• Representation: It involves genotype representation and genotype-phenotype mapping.(De Jong, 2006).For instance, we may represent an integer (phenotype) as a binary array (genotype): '19' as '10011' and '106' as '1101010'.If we mutate the first bit, then we will get '3' (00011) and '42' (0101010).For those examples, even we have mutated one bit in the genotype, the phenotype may vary very much.Thus we can see that there are a lot of considerations in the mapping.</p>
<p>• Parent Selection: It aims at selecting good parent individuals for crossovers, where the goodness of a parent individual is quantified by its fitness.Thus most parent selection schemes focus on giving more opportunities to the fitter parent individuals than the other individuals and vice versa such that "good" offspring individuals are likely to be generated.</p>
<p>• Crossover Operators: It resembles the reproduction mechanism in nature.Thus they, with mutation operators, are collectively called reproductive operators.In general, a crossover operator combines two individuals to form a new individual.It tries to split an individual into parts and then assemble those parts into a new individual.</p>
<p>• Mutation Operators: It simulates the mutation mechanism in which some parts of a genome undergoes random changes in nature.Thus, as a typical modeling practice, a mutation operator changes parts of the genome of an individual.On the other hand, mutations can be thought as an exploration mechanism to balance the exploitation power of crossover operators.</p>
<p>• Survival Selection: It aims at selecting a subset of good individuals from a set of individuals, where the goodness of individual is proportional to its fitness in most cases.Thus survival selection mechanism is somehow similar to parent selection mechanism.In a typical framework like 'EC4' (De Jong, 2006), most parent selection mechanisms can be re-applied in survival selection.</p>
<p>• Termination Condition: It refers to the condition at which an evolutionary algorithm should end.</p>
<p>EVOLUTIONARY ALGORITHMS: CONCEPTS AND DESIGNS Representation</p>
<p>Representation involves genotype representation and genotype-phenotype mapping.In general, designers try to keep genotype representation as compact as possible while keeping it as close to the corresponding phenotype representations as possible such that measurement metrics, say distance, in the genotype space can be mapped to those in phenotype space without the loss of semantic information.In general, there are many types of representations that an evolutionary algorithm can adopt.For example, fixed-length linear structures, variable-length linear structures, and tree structures…… Figure 2 depicts three examples.Figure 2a is a vector of integers.We can observe that its genotype is a binary array with length equal to 10.To map it into the phenotype space, the first 5 binary digits (10011) are mapped to the first element (19) of the vector whereas the remaining 5 binary digits (11110) are mapped to the second element (30) of the vector.Figure 2b is the relative encoding representation of a protein on the HP lattice model (Krasnogor, Hart, Smith, &amp; Pelta, 1999).Its genotype is an array of moves and its length is set to the amino acid sequence length of the protein.The array of moves encodes the relative positions of amino acids from their predecessor amino acids.Thus we need to follow the move sequence to compute the 3D structure of the protein (phenotype) for further evaluations.Figure 2c is the tree representation of a mathematical expression.Obviously, such tree structure is a variable length structure, which has the flexibility in design.If the expression is short, it can be shrunk during the evolution.If the expression is long, it can also be expanded during the evolution.Thus we can observe that the structure has an advantage over the previous representations.Nevertheless, there is no free lunch.It imposes several implementation difficulties to translate it into phenotypes.</p>
<p>Parent Selection</p>
<p>Parent selection aims at selecting "good" parent individuals for crossover, where the goodness of a parent individual is positively proportional to its fitness for most cases.Thus most parent selection schemes focus on giving more opportunities to the fitter parent individuals than the other individuals and vice versa.The typical methods are listed as follows:</p>
<p>• Fitness Proportional Selection: The scheme is sometimes called roulette wheel selection.In the scheme, the fitness values of all individuals are summed.Once summed, the fitness of each individual is divided by the sum.The ratio then becomes the probability for each individual to be selected.</p>
<p>• Rank Proportional Selection: Individuals with high ranks are given more chances to be selected.Unlike fitness proportional scheme, the rank proportional scheme does not depend on the actual fitness values of the individuals.It is a double-edged sword.On the positive side, it can help us prevent the domination of very high fitness values.On the negative side, it imposes additional computational costs for ranking.</p>
<p>• Uniform Deterministic Selection: The scheme is the simplest among the other schemes.All individuals are selected, resulting in uniform selection.</p>
<p>• Uniform Stochastic Selection: The scheme is the probabilistic version of uniform deterministic selection.All individuals are given equal chances (equal probabilities) to be selected.</p>
<p>• Binary Tournament: Actually, there are other tournament selection schemes proposed in the past literature.In this book chapter, the most basic one, binary tournament, is selected and described.In each binary tournament, two individuals are randomly selected and competed with each other by fitness.The winner is then selected.Such a procedure is repeated until all vacancies are filled.</p>
<p>• Truncation: The top individuals are selected deterministically when there is a vacancy for selection.In other words, the bottom individuals are never selected.For example, if there are 100 individuals and 50 slots are available, then the top 50 fittest individuals will be selected.</p>
<p>Crossover Operators</p>
<p>Crossover operators resemble the reproduction mechanism in nature.Thus they, with mutation operators, are collectively called reproductive operators.In general, a crossover operator combines two individuals to form a new individual.It tries to partition an individual into parts and then assemble the parts of two individuals into a new individual.The partitioning is not a trivial task.It depends on the representation adopted.Thus it is not hard to imagine that crossover operators are representation-dependent.Nevertheless, without loss of generality, a list of classic crossover operators is listed as follows:</p>
<p>• One Point Crossover: One point crossover is a commonly used crossover operator because of its simplicity.Given two individuals, it randomly chooses a cut point in their genomes.Then it swaps the parts after (or before) the cut point between the two genomes.</p>
<p>• Two Points Crossover: Two points crossover is another commonly used crossover operator because people argue that one point crossover has a positional bias toward the terminal positions.</p>
<p>For instance, when making a one point crossover, the rightmost (or leftmost) part is always swapped.Thus people propose two point crossovers to avoid the positional bias.</p>
<p>• Uniform Crossover: Uniform crossover is a general one.Each gene is given an equal probability to be swapped.</p>
<p>• Blend Crossover: Blend crossover is commonly used in real number optimization.Instead of swapping genes, it tries to blend two genes together by arithmetic averaging to obtain the intermediate values.For instance, if we are going to make a crossover between two vectors [1 2 3] and [4 5 6], then the blended vector will be [2.5 3.5 4.5].Weights can be applied here.</p>
<p>Mutation Operators</p>
<p>Mutation operators resemble the mutation mechanism in which some parts of genome undergo random changes in nature.Thus, as a typical modeling, a mutation operator changes parts of the genome of an individual probabilistically.Similar to crossover operators, mutation operators are representationdependent.Nevertheless, without loss of generality, a list of commonly used mutation operators is shown below:</p>
<p>• Bitflip Mutation: It is commonly used in binary genomes.Specified by a pre-defined probability, each bit in a binary genome is probabilistically inverted.</p>
<p>• Random Mutation: Random mutation is generalized from bitflip mutation.It can be applied in many genomes.Specified by a pre-defined probability, each part in a genome is probabilistically changed to a random value within domain bounds.</p>
<p>• Delta Mutation: Delta mutation is commonly used in real number genomes.Specified by a predefined probability, each real number in a real number genome is probabilistically incremented/decremented by a certain step size (called delta), where the step size is pre-specified.Nonetheless, it is straightforward to make the step size adaptive, similar to the trial vector generations in differential evolution (Storn &amp; Price, 1997).</p>
<p>• Gaussian Mutation: Gaussian mutation is also commonly used in real number genomes.Similar to delta mutation, each real number in a real number genome is probabilistically increased / decreased by a step size.The difference is that the step size is a Gaussian random number.(De Jong, 2006).</p>
<p>Survival Selection</p>
<p>Survival selection aims at selecting a subset of good individuals from a population, where the goodness of individual is proportional to its fitness for most cases.Thus survival selection mechanism is somehow similar to parent selection mechanism.In a typical framework like EC4 (De Jong, 2006), most parent selection mechanisms can be re-applied in survival selection.For example, the fitness proportional selection can be applied as survival selection.</p>
<p>Termination Condition</p>
<p>Termination condition refers to the condition at which an evolutionary algorithm should end.For historical reasons, the number of generations is often adopted as the termination measurement: an evolutionary algorithm terminates when a certain number of generations has been reached (e.g.1000 generations).Nonetheless, it has been pointed out that fitness function evaluations are computationally expensive in certain domains.Thus the number of fitness function evaluations is also adopted in some problems.If computing resources are limited, CPU time is also adopted.Nonetheless, convergence is not guaranteed.Thus people have calculated the fitness improvement of each generation as another condition for termination.</p>
<p>Examples</p>
<p>Genetic Algorithm: Genetic algorithm is the most classic evolutionary algorithm.It draws inspiration from the Darwin's Evolution Theory.The difference between genetic algorithm and evolutionary algorithm becomes blurred nowadays.The words 'genetic algorithm' and 'evolutionary algorithm' are sometimes interchanged in use.To clearly explain the working mechanism of a genetic algorithm, we chose the canonical genetic algorithm (Whitley, 1994) as a representative example.</p>
<p>In the canonical genetic algorithm, each individual has a fixed-length binary array as its genotype.Then the fitness of each individual is divided by the average fitness to calculate the normalized probability to be selected.The algorithm then adopts them to select parents for one point crossover to produce offspring individuals, which subsequently undergo mutations.The offspring individuals become the population in the next generation and so forth.</p>
<p>Genetic Programming: Genetic programming is indeed a special type of genetic algorithm.The difference lies in their representations.Genetic programming adopts trees as genotypes to represent programs or expressions.(Figure 2 depicts an example).The typical selection schemes of evolutionary algorithms can still be used as parent selection and survival selection in genetic programming.The distinct features of genetic programming are their crossover and mutation operators.For instance, swapping sub-trees between two trees and random generation of sub-trees.A list of common crossover and mutation operators for genetic programming is tabulated in Table 1.</p>
<p>Table 1.A list of crossover and mutation operators for genetic programming (Banzhaf, Nordin, Keller, &amp; Francone, 1998)  &amp; Price, 1997).It demonstrated great potential for real function optimization in the subsequent contests (Price, 1997).Without loss of generality, a typical strategy of differential evolution (DE/rand/1) (Feoktistov, 2006) is shown in Figure 3.
Description</p>
<p>Figure 3. Outline of differential evolution (DE/rand/1)</p>
<p>For each individual in a generation, the algorithm randomly selects three individuals to form a trial vector.</p>
<p>One individual forms a base vector, whereas the value difference between the other two individuals forms a difference vector.The sum of those two vectors forms a trial vector, which recombines with the individual to form an offspring.Replacing the typical crossover and mutation operation by this trial vector generation, manual parameter tuning of crossover and mutation is no longer needed.It can provide differential evolution a self-organizing ability and high adaptability for choosing suitable step sizes which demonstrated its potential for continuous optimization in the past contests.A self-organizing ability is granted for moving toward the optima.A high adaptability is achieved for optimizing different landscapes (Feoktistov, 2006).With such self-adaptability, differential evolution is considered as one of the most powerful evolutionary algorithms for real function optimization.For example, mechanical engineering design (Lampinen &amp; Zelinka, 1999) and nuclear reactor core design (Sacco, Henderson, Rios-Coelho, Ali, &amp; Pereira, 2009).</p>
<p>Evolution Strategy: Evolution Strategy was proposed in 1968 (Beyer &amp; Schwefel, 2002).It is even older than genetic algorithm.Schwefel and Klockgether originally used evolution strategy as a heuristic to perform several experimental optimizations in air flow.They found that evolution strategy was better than other discrete gradient-oriented strategy, which raised people's interests in evolution strategy.Comparing to the previous evolutionary algorithms, evolution strategy draws less inspiration from nature.Instead, it was artificially created as a numerical tool for optimization.Thus the structure of evolution strategy is quite different from the other evolutionary algorithms.For example, evolution strategy scholars call the mutation step size and probability as endogenous parameters encoded in the genome of an individual.Thus, besides the gene values, a genome is also composed of the parameter settings which control the convergence progress of the whole algorithm.The notation of evolution strategy is quite interesting.( µ / ρ + , λ ) -ES denotes an evolution strategy where µ denotes parent population size; ρ denotes breeding size;</p>
<p>( µ / ρ + λ ) -ES denotes the algorithm is overlapping; ( µ / ρ , λ ) denotes the algorithm is not overlapping; λ denotes the offspring population size.</p>
<p>Swarm Intelligence: Ant Colony Optimization (Dorigo &amp; Gambardella, 1997), Particle Swarm Optimization (Poli, Kennedy, &amp; Blackwell, 2007), and Bee Colony Optimization (Karaboga, Akay, &amp; Ozturk, 2007)……etc are collectively known as Swarm Intelligence.Swarm intelligence is a special class of evolutionary algorithm.It does not involve any selection (i.e.birth and death).Instead, it maintains a fixed-size population of individuals for search across generations.After each generation, the individuals report their findings which are recorded and used to adjust the search strategy in the next generation.Some of the algorithms were originally designed for shortest path finding.Nevertheless, people have further generalized them for other applications.For instance, Bi-Criterion Opitmization (Iredi, Merkle, &amp; Middendorf, 2000), Load Balancing in Telecommunication Network (Schoonderwoerd, Bruten, Holland, &amp; Rothkrantz, 1996), Protein Folding Problem (Shmygelska &amp;Hoos, 2005), andPower System (del Valle, Venayagamoorthy, Mohagheghi, Hernandez, &amp;Harley, 2008).</p>
<p>Multimodel Optimization: Real world problems always have different multiple solutions.For instance, optical engineers need to tune the recording parameters to get as many optimal solutions as possible for multiple trials in the varied-line-spacing holographic grating design problem because the design constraints are too difficult to be expressed and solved in mathematical forms.Unfortunately, most traditional optimization techniques focus on solving for a single optimal solution.They need to be applied several times; yet all solutions are not guaranteed to be found.Thus the multimodal optimization problem was proposed.In that problem, we are interested in not only a single optimal point, but also the others.</p>
<p>Given an objective function, an algorithm is expected to find all optimal points in a single run.With strong parallel search capability, evolutionary algorithms are shown to be particularly effective in solving this type of problem.Although the objective is clear, it is not easy to be satisfied in practice because some problems may have too many optima to be located.Nonetheless, it is still of great interest to researchers how these problems are going to be solved because the algorithms for multimodal optimization usually not only locate multiple optima in a single run, but also preserve their population diversity throughout a run, resulting in their global optimization ability on multimodal functions.The work by De Jong (De Jong, 2006) is one of the first known attempts to solve the multimodal optimization problem by an evolutionary algorithm.He introduced the crowding technique to increase the chance of locating multiple optima.In the crowding technique, an offspring replaces the parent which is most similar to the offspring itself.Such a strategy can preserve the diversity and maintain different niches in a run.Twelve years later, Goldberg and Richardson (Goldberg &amp; Richardson, 1987) 2009).EASE is built on the Species Conserving Genetic Algorithm (SCGA), and the design is improved in several ways.In particular, it not only identifies species seeds, but also exploits the species seeds to create multiple mutated copies in order to further converge to the respective optimum for each species.Evolutionary Algorithm with Speciesspecific Explosion (EASE) is an evolutionary algorithm which identifies and exploits species seeds to locate global and local optima.There are two stages in the algorithm: Exploration Stage and Speciesspecific Stage.The exploration stage targets for roughly locating all global and local optima.It not only undergoes normal genetic operations: selection and crossover, but also involves the addition of randomly generated individuals for preserving the diversity.On the other hand, the species-specific stage targets for gently locating the optimum for each species.Species-specific genetic operations are applied.Only the individuals within the same species are allowed to perform selection and crossover to each other.No inter-species selection and crossover are allowed.Such a strategy is to provide more chances for each species to converge to its respective optimum, with the trade-off that diversity is no longer preserved.To have a better global picture for locating optima, EASE starts with the exploration stage.It will switch to the species-specific stage only after the stage switching condition is satisfied.No matter in which stage, a local operation called Species-specific Explosion is always executed so as to help species to climb and converge to its corresponding optimum.Briefly, in SCGA, Li et al. proposed conserving one individual for each species.However, just one individual for each species is not enough for the algorithm to wellconserve and nurture the species.In a run of SCGA, it is often the case that the algorithm does conserve species with low fitness values, but they are present in a small proportion.Once they form new offspring, their offspring are often removed quickly in subsequent generations due to their low fitness values.Thus most individuals are always of the species with high fitness values.In atypical run of SCGA, we can observe that the individuals gradually converge to the three optima fitness-proportionally.Though different species are preserved with an individual as the species seed, it cannot converge to some of the low-fitness local optima.Merely SCGA itself actually cannot provide enough indiscriminate condition for species to nurture, evolve, and converge to its respective optimum in each run.Hence EASE incorporates a local operation called Species-specific Explosion to nurture species and remedy their convergences.Species-specific explosion is the local operation in which we create multiple copies for each species seed and mutate them.In summary, EASE is divided into two stages: Exploration Stage and Species-specific Stage.EASE starts with the exploration stage.Once the stage switching condition is satisfied, it will be changed to species-specific stage.Throughout the two stages, a local operation: Species-specific Explosion is applied so as to help each species to converge to its respective optimum.</p>
<p>Though different methods were proposed in the past, they were all based on the same fundamental idea: it is to strike an optimal balance between convergence and population diversity in order to locate optima.</p>
<p>Others: Other evolutionary computation methods have been proposed; for instance, Cuckoo-search (Civicioglu &amp; Besdok, 2013)</p>
<p>APPLICATIONS TO BIOINFORMATICS An Overview of Bioinformatics</p>
<p>Since the 1990s, the whole genomes of a large number of species have been sequenced by their corresponding genome sequencing projects.In 1995, the first free-living organism Haemophilus influenzae was sequenced by the Institute for Genomic Research (Fleischmann, et al., 1995).In 1996, the first eukaryotic genome (Saccharomyces cerevisiase) was completely sequenced (Goffeau, et al., 1996).</p>
<p>In 2000, the first plant genome Arabidopsis thaliana, was also sequenced by Arabidopsis Genome Initiative (Initiative, 2000).In 2004, the Human Genome Project (HGP) announced its completion (Consortium I. H., 2004).Following the HGP, the Encyclopedia of DNA Elements (ENCODE) project was started, revealing massive functional putative elements on the human genome in 2011 (Consortium E. , 2012).The drastically decreasing cost of sequencing also enables the 1000 Genomes Project to be carried out, resulting in an integrated map of genetic variation from 1,092 human genomes published in 2012 (Abecasis, Auton, Brooks, DePristo, &amp; Durbin, 2012).Nonetheless, the massive genomic data generated by those projects impose an unforeseen challenge for large-scale data analysis at the scale of gigabytes or even terabytes (Wong, Peng, Li, &amp; Chan, 2014).</p>
<p>In particular, computational methods are essential in analyzing the massive genomic data (Wong, Li, Peng, &amp; Zhang, 2015).They are collectively known as bioinformatics or computational biology.For instance, motif discovery (GuhaThakurta, 2006) helps us distinguish real signal subsequence patterns from background sequences.Multiple sequence alignment (Altschul, Gish, Miller, Myers, &amp; Lipman, 1990) can be used to analyze the similarities between multiple sequences.Protein structure prediction (McGuffin, Bryson, &amp; Jones, 2000) can be applied to predict the 3D tertiary structure from an amino acid sequence.Gene network inference (D'Haeseleer, Liang, &amp; Somogyi, 2000) are the statistical methods to infer gene networks from correlated data (e.g.microarray data).Promoter prediction (Abeel, Van de Peer, &amp; Saeys, 2009) help us annotate the promoter regions on a genome.Phylogenetic tree inference (Ronquist &amp; Huelsenbeck, 2003) can be applied to study the hierarchical evolution relationship between different species.Drug scheduling (Liang, Leung, &amp; Mok, 2008) can help solve the clinical scheduling problems in an effective manner.Although the precisions of those computational methods are usually lower than the existing biotechnology, they can still serve as useful preprocessing tools to significantly narrow search spaces (Wong &amp; Zhang, 2014).Thus prioritized candidates can be selected for further validation by wetlab experiments, saving manual time and funding (Wong, Chan, Peng, Li, &amp; Zhang, 2013).</p>
<p>Evolutionary Algorithms for Protein Structure Prediction</p>
<p>A polypeptide is a chain of amino acid residues.Once folded into its native state, it is called protein.</p>
<p>Proteins play vital roles in living organisms.They perform different tasks to maintain a body's life.For instance, material transportations across cells and catalyzing metabolic reactions and body defenses against viruses.Nevertheless, functions of proteins substantially depend on their structural features.In other words, researchers need to know a protein's native structure before its function can be completely deduced.It gives rises to the protein structure prediction problem.</p>
<p>The protein structure prediction problem is often referred as the ``holy grail'' of biology.In particular, Anfinsen's dogma (Anfinsen, 1973) and Levinthal's paradox (Levinthal, 1968) are the central rules in this problem.Anfinsen's dogma postulates that a protein's native structure (tertiary structure) only depends on its amino acid residue sequence (primary structure).On the other hand, Levinthal's paradox postulates that it is too time-consuming for a protein to randomly sample all the feasible confirmation regions for its native structure.On the other hand, the proteins in nature can still spontaneously fold into its native structures in about several milliseconds.</p>
<p>Based on the above ideas, researchers have explored the problem throughout several years.In particular, the protein structural design and sequence degeneracy have been studied by Li et.al. (Li, Helling, Tang, &amp; Wingreen, 1996).The computational complexity has also been examined (Aluru, 2005).</p>
<p>Numerous prediction approaches have been proposed.In general, they can be classified into two categories, depending on whether any prior knowledge other than sequence data has been incorporated (Baker &amp; Sali, 2001).This book chapter focuses on de novo (or ab initio) protein structure prediction on 3D Hydrophobic-Polar (HP) lattice model using evolutionary algorithms (Krasnogor, Hart, Smith, &amp; Pelta, 1999).In other words, only sequence data is considered.</p>
<p>Different protein structure models have been proposed in the past (Silverio, 2008).Their differences mainly lie in their resolution levels and search space freedom.At the highest resolution level, all the atoms and bond angles can be simulated using molecular dynamics.Nevertheless, there is no free lunch.The simulation is hard to be completed by the current computational power.On the other hand, a study indicated that protein folding mechanisms might be simpler than previously thought (Baker, 2000).Thus this book chapter focuses on HP lattice model to capture the physical principles of protein folding process (Duan &amp; Kollman, 2001).</p>
<p>In this problem, it assumes that the main driving forces are the interactions among the hydrophobic amino acid residues.The twenty amino acids are experimentally classified as either hydrophobic (H) or polar (P).</p>
<p>An amino acid sequence is thus represented as a string {H,P} + .Each residue is represented as a nonoverlapping bead in a cubic lattice L. Each peptide bond in the main chain is represented as a connecting line.A protein is thus represented as a non-overlapping chain in L.</p>
<p>Based on the above model, the objective of the protein structure prediction problem is to find the conformation with the minimal energy for each protein.Mathematically, it is to minimize the following function (Li, Helling, Tang, &amp; Wingreen, 1996):
‫ܪ‬ = ‫ݎ(ܧ‬ ାଵழ , ‫ݎ‬ ) ‫ݎ(∆‬ , ‫ݎ‬ )
where ‫ݎ‬ and ‫ݎ‬ are amino acid residues at sequence position $i$ and $j$.The constraint $i+1&lt;j$ is to ensure that ‫ݎ‬ and ‫ݎ‬ are not next to each other on their sequence and they are examined together once only.∆൫‫ݎ‬ , ‫ݎ‬ ൯ = 1 when ‫ݎ‬ and ‫ݎ‬ are adjacent in L; Otherwise ∆൫‫ݎ‬ , ‫ݎ‬ ൯ = 0.As stated in the previous section, each residue is represented as either H or P. Thus ‫ߪ(ܧ‬ , ߪ ) could be ‫,ܪ(ܧ‬ ‫,)ܪ‬ ‫,ܪ(ܧ‬ ܲ), ‫,ܲ(ܧ‬ ‫,)ܪ‬ or ‫,ܲ(ܧ‬ ܲ).For their values, three schemes have been proposed.The most widely used scheme is ‫,ܪ(ܧ‬ ‫)ܪ‬ = −1, ‫,ܪ(ܧ‬ ܲ) = 0, ‫,ܲ(ܧ‬ ‫)ܪ‬ = 0, and ‫,ܲ(ܧ‬ ܲ) = 0.The second scheme ‫,ܪ(ܧ‬ ‫)ܪ‬ = −2.3,‫,ܪ(ܧ‬ ܲ) = −1, ‫,ܲ(ܧ‬ ‫)ܪ‬ = −1, and ‫,ܲ(ܧ‬ ܲ) = 0 was proposed.The last scheme ‫,ܪ(ܧ‬ ‫)ܪ‬ = −2, ‫,ܪ(ܧ‬ ܲ) = 1, ‫,ܲ(ܧ‬ ‫)ܪ‬ = 1, and ‫,ܲ(ܧ‬ ܲ) = 1 is called functional model protein (or ``shifted'' HP model) (Cutello, Nicosia, Pavone, &amp; Timmis, 2007).As mentioned in (Silverio, 2008), the results are insensitive to the value of E(H,H} as long as the physical constraints (Li, Helling, Tang, &amp; Wingreen, 1996) are satisfied.Thus we have chosen the first scheme in this book chapter.</p>
<p>For the representation of an amino acid residue sequence, there are two conditions to be satisfied: (Krasnogor, Hart, Smith, &amp; Pelta, 1999) (1) Sequence connectivity (2) Self-avoidance.Among the proposed representations (Cutello, Nicosia, Pavone, &amp; Timmis, 2007), Internal Coordinate should be a favorable choice since it can handle the first condition implicitly.Internal coordinate is a representation system which residue positions depend on their sequence-predecessor residues.There are two types of internal coordinate representation: Absolute Encoding and Relative Encoding.Absolute encoding represents each residue position as the absolute direction from the previous residue.A sequence is represented as {U,D,L,R,F,B} n-1 (Up, Down, Left, Right, Forward, Backward) (Unger &amp; Moult, 1993).</p>
<p>On the other hand, relative encoding represents those as relatively directional changes based on the directions of the two predecessor residues.Backward direction is omitted for one-step self-avoiding.Thus a sequence is represented as {F,R,L,U,D} n-2 (Patton, Punch III, &amp; Goodman, 1995).Except the forward move, a cyclic conformation is formed if a move is repeated four times.Krasnogor et al. (Krasnogor, Hart, Smith, &amp; Pelta, 1999) have examined both representations on square lattices.Their results showed that relative encoding had better performance than absolute encoding on square lattices.</p>
<p>Although the 3D HP model seems relatively simple among other models, it has been proved that the protein structure prediction problem on the model is NP-Complete (Berger &amp; Leighton, 1998).Thus researchers propose heuristics as compromising solutions.In particular, the seminal work by Unger et al. (Unger &amp; Moult, 1993) experimentally showed that genetic algorithm approaches were better than Monte Carlos simulations.Thus researchers tried genetic algorithm as one of the heuristics to solve the problem.Nevertheless, the genetic algorithm approach by Unger et al. (Unger &amp; Moult, 1993) was actually hybridized with Monte Carlo moves.Hence Patton et al. (Patton, Punch III, &amp; Goodman, 1995) further generalized it into a standard genetic algorithm approach, which search space included infeasible regions penalized by a penalty function.Furthermore, they proposed ``relative encoding'' so that one-step selfavoiding constraints could be implicitly incorporated in the genome representation.Few years later, Krasnogor et al. (Krasnogor, Hart, Smith, &amp; Pelta, 1999) published a work discussing the basic algorithmic factors affecting the problem.Since then, researchers explored different ways to tackle the problem.For instance, Krasnogor et al. further applied a multimeme algorithm, which adaptively chose multiple local searchers to reach optimal structures (Krasnogor, Blackburnem, Hirst, &amp; Burke, 2002).Cox et al. (Cox, Mortimer-Jones, Taylor, &amp; Johnston, 2004) and Hoque et al. (Hoque, Chetty, &amp; Dooley, 2006) utilized heavy machinery of specific genetic operators and techniques.Ant colony algorithm (Shmygelska &amp; Hoos, 2005), differential evolution (Bitello &amp; Lopes, 2006), immune algorithm (Cutello, Nicosia, Pavone, &amp; Timmis, 2007) and estimation of distribution algorithm (Santana, Larranaga, &amp; Lozano, 2008) were also customized and reported in literatures.In particular, diversity preserving techniques were often incorporated in them.For instance, Duplicate Predator (Cox, Mortimer-Jones, Taylor, &amp; Johnston, 2004), Aging Operator (Cutello, Nicosia, Pavone, &amp; Timmis, 2007), and additional renormalization of the pheromone (Shmygelska &amp; Hoos, 2005).They can be deemed as the signs of the multimodality in the problem.However, the necessity of multimodal optimization techniques has not been emphasized.</p>
<p>For the protein structure prediction problem, it is generally believed that the native state of protein should be at the conformation with the lowest energy.Thus previous works mainly focus on the minimal energy they could achieve: the minimal energy ever found and the average and standard deviation of the minimal energy across several runs.Nevertheless, Jahn et al. (Jahn &amp; Radford, 2008) has shown that the native state is not necessarily a single global optimum.It may also be a local optimum in Fig. 1 of (Jahn &amp; Radford, 2008).For the HP lattice model, Unger et al. (Unger &amp; Moult, 1993) have observed that there can be multiple conformations for each energy value.A recent fitness landscape study also indicated that HP landscapes were highly multimodal (Flores &amp; Smith, 2003).Thus Wong et al. have proposed multimodal optimization techniques for the protein structure prediction problem (Wong, Leung, &amp; Wong, 2010).</p>
<p>The most widely used distance measure should be the root mean square deviation (RMSD) (Holm &amp; Sander, 1993).RMSD calculates the average absolute distances between two superimposed conformations' points.Nevertheless, if two conformations differ by only one point direction in relative encoding, their RMSD cannot reflect such small change.For instance, some conformations of the benchmark UM20 (Cotta, 2003) are visualized in Figure 4.</p>
<p>Figure 4. The left most confirmation depicts an optimal conformation (LDLDFLUFDDFRFRDDFD) on the benchmark UM20. The other two confirmations (LDLDFLUFDDFRFFDDFD and LDLDDLLRLLDRFRDDFD) depict two candidate conformations after mutations. Red beads denote hydrophobic residues (H) while blue beads denote polar residues (P).</p>
<p>To be mutated to the optimal conformation, Example A is only needed to change its move between a1 and a2 to R whereas example b is needed to change nearly all of its moves between b1 and b8.However, the RMSD of Example A with the optimal conformation (5 diagonal point changes a2 to a6) is larger than that of example B (4 diagonal point changes b2,b3,b5,b6).RMSD cannot capture the move information in relative encoding.Furthermore, if RMSD is applied, it will be quite computationally intensive.To calculate the RMSD between two conformations, the corresponding relative encoding genomes are converted to absolute 3D coordinates.Once converted, one of them is then translated and rotated to be optimally superimposed on the other.RMSD is then calculated which involves multiplications and square root calculations.In contrast, Hamming distance calculates the move differences between two relative encoding genomes.It is relatively computational tractable.Thus Hamming distance is usually adopted in this problem.</p>
<p>Basically there are two approaches for handling infeasible conformations: (1) Delete infeasible conformations (2) Tolerate infeasible conformations by adjusting their energy values by a penalty score (either constant or adaptive).Both approaches were thought beneficial in different view angles (Flores &amp; Smith, 2003).For the first approach, it is conjectured that search space can be narrowed if infeasible conformations are deleted.For the second approach, it is conjectured that the paths to optimal conformations are shorter if infeasible conformations exist.Nevertheless, the study in (Flores &amp; Smith, 2003) had a detailed analysis supporting the first approach.</p>
<p>Evolutionary Algorithms for Protein-DNA Pattern Discovery</p>
<p>Protein-DNA interactions are essential in genetic activities such as transcription, packaging, rearrangement, and replication (Luscombe &amp; Thornton, 2002).Understanding them forms the basis for further deciphering biological systems.In particular, the protein-DNA interactions between Transcription Factors (TFs) and Transcription Factor Binding Sites (TFBSs) play a central role in gene transcription.</p>
<p>TFs bind in a sequence-specific manner to TFBSs to regulate gene transcription (Luscombe, Austin, Berman, &amp; Thornton, 2000).</p>
<p>Nevertheless, it is expensive and laborious to experimentally identify the TF-TFBS binding sequence pairs, for example, using DNA footprinting (Galas &amp; Schmitz, 1987) or gel electrophoresis (Garner &amp; Revzin, 1981).The technology of Chromatin immunoprecipitation (ChIP) (Smith, Sumazin, Das, &amp; Zhang, 2005) measures the binding of a particular TF to DNA of co-regulated genes on a genome-wide scale in vivo, but at low resolution.Further processing is needed to extract precise TFBSs (Liu, Brutlag, &amp; Liu, 2002).To share the precious sequence data, researchers have built databases.In particular, TRANSFAC (Matys V. , et al., 2006) is one of the largest and most representative databases for regulatory elements including TFs, TFBSs, nucleotide distribution matrices of the TFBSs, and regulated genes.The data are expertly annotated and manually corrected from peer-reviewed publications and experimentally verified studies.Other annotation databases of TF families and binding domains are also available (e.g.PROSITE (Hulo, et al., 2008), Pfam (Bateman, et al., 2004)).</p>
<p>On the other hand, high-quality TF-TFBS binding structures can provide valuable insights into putative principles of binding.However, it is difficult and time consuming to extract those high-resolution 3D TF-TFBS complex structures with X-ray crystallography (Smyth &amp; Martin, 2000) or Nuclear Magnetic Resonance (NMR) spectroscopic analysis (Mohan &amp; Hosur, 2009).To share the precious structural data, researchers have also built databases.In particular, the Protein Data Bank (PDB) (Berman, et al., 2000) serves as a representative repository of such experimentally extracted protein-DNA (in particular TF-TFBS) complexes with high resolution at atomic levels.However, the available 3D structures are far from complete.As a result, there is strong motivation to have automatic methods, particularly, computational approaches based on existing abundant data, to provide testable candidates of TF-TFBS binding sequence pairs with high confidence to guide and accelerate the wet-lab experiments.</p>
<p>Most of the previous computational attempts related to TF-TFBS interactions are devoted to discover either the motifs of TF domains or those of TFBSs separately.The TF domains and TFBSs sequences are somewhat conserved due to their functional similarity and importance.By exploiting the conservation, computational methods called motif discovery have been proposed to save the expensive and laborious laboratory experiments (MacIsaac &amp; Fraenkel, 2006).The methods usually make use of comprehensive statistical and scoring models to extract the domain information from the background sequences (Jensen S. T., Liu, Zhou, &amp; Liu, 2004).In addition, data mining methods have been proposed to find the sequence pairs.For instance, support vector machines (SVM) (Ofran, Mysore, &amp; Rost, 2007) and regressions (Zhou &amp; Liu, 2008).Distinct from motif discovery, they utilize the biochemical information in sequence data (e.g.base compositions, structures, thermodynamic properties (Ahmad, Keskin, Sarai, &amp; Nussinov, 2008)) to perform prediction.Nevertheless, most of their results are not concrete sequences (the most explicit and interpretable format).</p>
<p>Thus Leung et al. have proposed a framework based on association rule mining with Apriori algorithm (Agrawal, Imielinski, &amp; Swami, 1993) to discover associated TF-TFBS binding sequence patterns in the most explicit and interpretable form from TRANSFAC (Leung, et al., 2010).With downward closure property, the algorithm guarantees the exact and optimal performance to generate all frequent TFBS kmer TF k-mer pairs from TRANSFAC where a k-mer is a string with length equal to k.The approach relies merely on sequence information without any prior knowledge in TF binding domains or protein-DNA 3D structure data.From comprehensive evaluations, statistics of the discovered patterns are shown to reflect meaningful binding characteristics.According to independent literature, PDB data and homology modeling, a good number of TF-TFBS binding patterns discovered have been verified by experiments and annotations.They exhibit atomic-level interactions between the respective TF binding domains and specific nucleotides of the TFBS from experimentally determined protein-DNA 3D structures.</p>
<p>Although the above, the sequence pairs discovered are in one-to-one mappings (Leung, et al., 2010).One TF amino acid sequence is coupled with one TFBS DNA sequence.In the biological world, a TF may bind to a promoter using several contact surface subsequences.Some surfaces of the TF may also be interacting surfaces to recruit another TF as a performing complex (White R. J., 2001).For instance, McGuire et al found that there were two conserved parts for the ArcA-P recognition motif in E.coli (McGuire, De Wulf, Church, &amp; Lin, 1999).Kato et al. proposed a novel method to identify combinatorial regulation of transcription factors and binding motifs using chromatin immunoprecipitation (ChIP) data with microarray expression data (Kato, Hata, Banerjee, Futcher, &amp; Zhang, 2004).A case study in the evolution of combinatorial gene regulation in Fungi has also been carried out (Tuch, Galgoczy, Hernday, Li, &amp; Johnson, 2008).Biochemists have used biochemical experiment methods to observe many evidences.For instance, SOX proteins perform their function in a complex interplay with other transcription factors in a manner highly dependent on cell type and promoter context.In particular, multiple TFBSs are found within the enhancer of the FGF4 gene during early embryonic expression.One is a recognition element for POU proteins; the other is a binding site for SOX proteins.The POU and SOX protein partnership is crucial to determine cell fate.Scientists have also used 3D structural determination methods to observe such combinatorial behavior.Some examples can be found in (Kato, Hata, Banerjee, Futcher, &amp; Zhang, 2004).Many experimental evidences can also be found in TransCompel (Matys V. , et al., 2006) which is a comprehensive database on the composite interactions between TFs binding to their TFBSs.Multiple TF amino acid sequences may be coupled with multiple TFBS DNA sequence, instead of just one-to-one mapping.Considering the huge search space, Wong et al. have further proposed an evolutionary algorithm to learn generalized representations from the original pairs (Wong, Peng, Wong, &amp; Leung, 2011).In particular, the original pairs are evolved to pairs of boolean expressions (trees) of k-mers An example is shown in Figure 5. Evolving trees (e.g.boolean expressions of k-mers) by evolutionary algorithms are well studied in the genetic programming field.Many design issues have been reviewed in section 2 of (Banzhaf, Nordin, Keller, &amp; Francone, 1998).In particular, researchers are especially concerned about the roles of crossovers and mutations.Some of them argue that crossovers are not beneficial to the evolution, whereas the others hold the opposite view (Spears &amp; Anand, 1991).Some of them also argue that mutations are not needed, whereas the others hold the opposite view (Poli, Langdon, &amp; Mcphee, A Field Guide to Genetic Programming, 2008).Even extensive experiments on comparing crossovers and mutations on a series of well known problems have been conducted (Luke &amp; Spector, 1998).The results can only reflect that it is problem-dependent (White &amp; Poulding, 2009).The debate is still continuing.Thus, as a compromising solution, both crossover and mutation operators are adopted in (Wong, Peng, Wong, &amp; Leung, 2011).Another important topic in genetic programming is to control the <code>bloat'' property.During a typical run of genetic programming, it is often found that some unnecessary components (called</code>introns'') are formed.It is intuitive for us to think that they are not necessary, and thus not good.Soule et al. (Terence, Foster, &amp; Dickinson, 1996) suggested a fitness function which penalizes trees with many introns.Rosca also suggested parsimony pressure on selecting trees was beneficial to grow toward the optimal structures (Rosca, 1997).Some researchers also suggest that the presence of the introns can confuse crossover operators, protecting good modules/components as discussed in Chapter 7 of (Banzhaf, Nordin, Keller, &amp; Francone, 1998).For instance, some of them made use of the bloat property to evolve buffer overflow attack codes which can successfully hide themselves from intrusion detectors (Kayacik, Heywood, &amp; Zincir-Heywood, 2006).Indeed, the bloat property is a double-edged sword.</p>
<p>CONCLUSION</p>
<p>Evolutionary algorithms build a bridge between computer science and nature (Kari &amp; Rozenberg, 2008).Instead of artificial creation, evolutionary algorithm emphasizes on learning from nature.Nature rules are applied or modeled to build novel computational techniques, which can be well adapted and integrated into different contexts.For instance, inspired from the Darwin's evolutionary theory, John Holland has proposed genetic algorithm which simulates the evolutionary process for natural selection.It has been proved successful in different applications widely.Indeed, the design of evolutionary algorithms draws inspiration from nature.They resemble the natural mechanism and are affiliated to nature.It is not surprising for us to expect that they should be among the best methods in bioinformatics to decipher nature in the future.</p>
<p>Besides, we suspect that most of the evolutionary algorithms applied to bioinformatics are always stuck in local optima.People are either not aware of the issue, or too lazy to study and handle it as long as the local optima found are good enough in practice.Thus we can foresee, if we further apply some evolutionary algorithms for multimodal optimization to the bioinformatics problems, promising results will be probably obtained.</p>
<p>Notably, Wong et al. have proposed robust and competitive methods for multimodel optimization (Wong, Wu, Mok, Peng, &amp; Zhang, 2012).In those methods, to explore the locality principle in evolutionary computation, crowding differential evolution (CrowdingDE) is incorporated with locality for multimodal optimization.Instead of generating trial vectors randomly, the first method proposed takes advantage of spatial locality to generate trial vectors.Temporal locality is also adopted to help generate offspring in the second method proposed.Temporal and spatial localities are then applied together in the third method proposed.</p>
<p>Here, we briefly describe those methods one by one.If diversity maintenance techniques are not applied, most evolutionary algorithms will prematurely converge and get stuck in a local optimum.To cope with the problem, the algorithms are usually equipped with their own local operations for diversity maintenance.In CorwdingDE, the local operation is the crowding technique, in which each offspring can only replace the individual which is most similar to itself.Looking at this technique more deeply, a restriction is proposed in the individual replacement method so that a individual gets replaced only when another individual is generated and evaluated fitter than the former within the same niche.The algorithm is forced to passively wait for the trial vector generations for feasible replacements.Unfortunately, the trial vector generations of CrowdingDE are random, as stated before.Thus the fundamental computer science concept, spatial locality, is applied to the trial vector generations in order to increase the chance of successful replacements in this work.</p>
<p>Close individuals tend to have similar characteristics.In a run of evolutionary algorithm, the population is usually divided into different niches.Within each niche, the individuals exhibit similar positions and stepsizes for improvement.After several generations, the differences between niches may be large.It will be a disaster if a single evolutionary strategy is applied to all of them regardless of their niches.Interestingly, it is a double-edged sword.Such a property also gives us spatial locality: the crossovers between close individuals can have higher chance to generate better offspring in their niche, comparing with the crossovers between distinct individuals.Thus the individuals which are closer to the parent than the others in the same generation should be given more chance of trial vector generations within a population.We should be aware that such a evolutionary policy may not be applicable for the problem domains other than multimodal optimization because the selected individuals may be similar to each other.Such a similarity may generally reduce the step size.To bring such a neighborhood idea into trial vector generations, spatial locality is proposed as a measure for selecting individuals to form trial vectors.The distances between the parent and all candidate individuals are computed and transformed into proportions which form a roulette-wheel.Within the roulette-wheel, a larger portion is given to the candidate individual which is closer to the parent than the others in the same generation.It follows that closer individuals are given higher chance of trial vector generations and vice versa.</p>
<p>By doing so, each trial vector generation becomes a local operation tailor-made for the parent individual.Crowding Differential Evolution (CrowdingDE) is reformulated as a hybrid algorithm which takes advantage of spatial locality.Thus we call the proposed algorithm as Crowding Differential Evolution using Spatial Locality (CrowdingDE-SL).</p>
<p>Besides spatial locality, temporal locality is also an intrinsic feature we can make use of.For instance, the most typical application is the use of cache in a computer system.If some data is accessed at a given time, then it is very likely that these data will be referenced again.Thus it is useful to store these data into high speed caches.Based on the same idea, such a temporal locality concept can also be incorporated into CrowdingDE.If an individual is replaced by another fitter individual under the crowding selection, then the vector difference between them is a improvement step within their niche.If the step is reused in a correct situation, it can contribute to improvements within their niche again.Thus it is advantageous for an algorithm to save and reuse these vectors for improvement.Nevertheless, as several generations pass by, a vast amount of these vectors are accumulated.It is impossible to store them all.As an intuitive solution, these vectors should be summarized on the fly.To do that, there are lots of existing techniques available.Considering the heavily iterative property of evolutionary algorithms, computational efficiency needs be taken into account seriously.Thus a simple summation technique with a discount factor is proposed.</p>
<p>In that technique, each individual is allocated with an array called delta which is of the same size as the genome.The main use of the array is to store the temporal locality history.Whenever an offspring generated is fitter than its nearest neighbor, the method records and stores their vector difference, plus the array delta of the nearest neighbor (with a discount factor), into the array delta of the offspring.After that, one more offspring is generated by summing the genome of the offspring and the array delta of the offspring together.If the new offspring is fitter than the original offspring, then the new offspring replaces the nearest neighbor.Otherwise, the original offspring replaces the nearest neighbor.Combined with this local operation, Crowding Differential Evolution (CrowdingDE) is reformulated as a hybrid algorithm which takes advantage of temporal locality.Thus we call it Crowding Differential Evolution using Temporal Locality (CrowdingDE-TL).</p>
<p>Having incorporated spatial and temporal locality into CrowdingDE separately, it is intuitive for us to apply them together since they belong to different modules: spatial locality takes effect in trial vector generations, whereas temporal locality takes effect in the selection stage after trial vector generations.Thus CrowdingDE can be combined with both spatial and temporal locality together, which is subsequently called Crowding Differential Evolution using Spatial and Temporal Locality (CrowdingDE-STL).</p>
<p>Numerical experiments are conducted to compare the proposed methods with the state-of-the-art methods on benchmark functions extensively.Experimental analysis is undertaken to observe the effect of locality and the synergy between temporal locality and spatial locality.Further experiments are also conducted on two application problems.One is the varied-line-spacing holographic grating design problem, while the other is the protein structure prediction problem.The numerical results demonstrate the effectiveness of those methods (Wong, Wu, Mok, Peng, &amp; Zhang, 2012).</p>
<p>Figure 2 .
2
Figure 2. Some representations of evolutionary algorithms: (a) Integer representation (b) Protein structure representation on a lattice model (c) Tree representation for a mathematical expression</p>
<p>Crossover • Subtree Exchange Crossover: exchange subtrees between individuals • Self Crossover: exchange subtrees within an individual • Module Crossover: exchange modules between individuals • SCPC: exchange subtrees if coordinates match exactly • WCPC: exchange subtrees if coordinates match approximately Mutation • Point Mutation: change the value of a node • Permutation: change the argument order of a node • Hoist: use a subtree to become a new individual • Expansion Mutation: exchange a subtree against a terminal node • Collapse Subtree Mutation: exchange a terminal node against a subtree • Subtree Mutation: replace a subtree by another subtree • Gene Duplication: replace a subtree by a terminal Differential Evolution: Differential Evolution was first proposed by Price and Storn in the 1990s (Storn</p>
<p>Figure 5 .
5
Figure 5. Exemplary pair of boolean expressions (trees) of k-mers.The left tree is on the TF side with amino acid k-mers while the right tree is on the TFBS side with DNA k-mers.</p>
<p>proposed a fitness-sharing niching technique as a diversity preserving strategy to solve the multimodal optimization problem.They proposed a shared fitness function, instead of an absolute fitness function, to evaluate the fitness of a individual in order to favor the growth of the individuals which are distinct from the others.With this technique, a population can be prevented from the domination of a particular type of individuals.Species conserving genetic algorithm (SCGA) (Wong, Leung, &amp; Wong, An evolutionary algorithm with species-specific explosion for multimodal optimization, 2009) is another technique for evolving parallel subpopulations.Before crossovers in each generation, the algorithm selects a set of species seeds which can bypass the subsequent procedures to the next generation.Since then, many researchers have been exploring different ways to deal with the problem.Notably, SCGA was claimed that the technique was considered as an effective and efficient method for inducing niching behavior into GAs.However, in our experiments, we find that the performance of the technique still has space for improvement.It always suffers from genetic</p>
<p>drifts though each species is conserved with one individual.The results of the comparison test conducted bySingh et al. (Singh &amp; Deb, 2006) also reveals that the species conserving technique performs the worst among the algorithms tested.As a result, Wong et al. have proposed a novel algorithm to remedy the species conserving technique.The novel algorithm is called Evolutionary Algorithm with Species-specific Explosion (EASE) for multimodal optimization (Wong, Leung, &amp; Wong, An evolutionary algorithm with species-specific explosion for multimodal optimization,</p>
<p>(Shah-Hosseini, 2009)er, Buldyrev, Murphy, Prince, &amp; Stanley, 1996)tanley, 1996), Bacterial Colony Optimization(Niu &amp; Wang, 2012), and Intelligent Water Drops algorithm(Shah-Hosseini, 2009).</p>
<p>An integrated map of genetic variation from 1,092 human genomes. G R Abecasis, A Auton, L D Brooks, M A Depristo, R M Durbin, Nature. 49174222012</p>
<p>Toward a gold standard for promoter prediction evaluation. T Abeel, Y Van De Peer, Y Saeys, Bioinformatics. 25122009</p>
<p>Mining association rules between sets of items in large databases. R Agrawal, T Imielinski, A Swami, SIGMOD '93: Proceedings of the 1993 ACM SIGMOD international conference on Management of data. 1993</p>
<p>Protein-DNA interactions: structural, thermodynamic and clustering patterns of conserved residues in DNA-binding proteins. S Ahmad, O Keskin, A Sarai, R Nussinov, Nucleic Acids Res. 362008</p>
<p>Basic local alignment search tool. S F Altschul, W Gish, W Miller, E W Myers, D J Lipman, Journal of molecular biology. 21531990</p>
<p>Handbook of Computational Molecular Biology (Chapman \&amp; All/Crc Computer and Information Science Series). S Aluru, 2005Chapman \&amp; Hall/CRC</p>
<p>Principles that Govern the Folding of Protein Chains. C B Anfinsen, Science. 18140961973</p>
<p>A surprising simplicity to protein folding. D Baker, Nature. 67822000</p>
<p>Protein Structure Prediction and Structural Genomics. D Baker, A Sali, Science. 29455402001</p>
<p>Genetic Programming --An Introduction; On the Automatic Evolution of Computer Programs and its Applications. W Banzhaf, P Nordin, R E Keller, F D Francone, 1998Morgan KaufmannSan Francisco, CA, USA</p>
<p>The Pfam protein families database. A Bateman, L Coin, R Durbin, R D Finn, V Hollich, S Grifrths-Jones, Nucleic Acids Res. 322004</p>
<p>Protein folding in the hydrophobic-hydrophilic (HP) is NPcomplete. B Berger, T Leighton, RECOMB '98: Proceedings of the second annual international conference on Computational molecular biology. New York, NY, USAACM1998</p>
<p>The Protein Data Bank. H M Berman, J Westbrook, Z Feng, G Gilliland, T N Bhat, H Weissig, Nucl. Acids Res. 2812000</p>
<p>Start-Up Optimisation of a Combined Cycle Power Plant with Multiobjective Evolutionary Algorithms. I Bertini, M De, F Moretti, S Pizzuti, EvoApplications. 22010</p>
<p>Evolution strategies -A comprehensive introduction. H Beyer, H Schwefel, Natural Computing. 112002</p>
<p>A Differential Evolution Approach for Protein Folding. R Bitello, H S Lopes, CIBCB '06. 2006 IEEE Symposium on. Toronto, Ont2006. 2006</p>
<p>A conceptual comparison of the Cuckoo-search, particle swarm optimization, differential evolution and artificial bee colony algorithms. P Civicioglu, E Besdok, Artificial Intelligence Review. 3942013</p>
<p>An integrated encyclopedia of DNA elements in the human genome. E Consortium, Nature. 48974142012</p>
<p>Finishing the euchromatic sequence of the human genome. I H Consortium, Nature. 43170112004</p>
<p>Protein Structure Prediction Using Evolutionary Algorithms Hybridized with Backtracking. C Cotta, IWANN '03: Proceedings of the 7th International Work-Conference on Artificial and Natural Neural Networks. Berlin, HeidelbergSpringer-Verlag2003</p>
<p>Development and optimisation of a novel genetic algorithm for studying model protein folding. G A Cox, T V Mortimer-Jones, R P Taylor, R L Johnston, Theoretical Chemistry Accounts: Theory, Computation, and Modeling. 2004112</p>
<p>An Immune Algorithm for Protein Structure Prediction on Lattice Models. V Cutello, G Nicosia, M Pavone, J Timmis, {IEEE} Transactions on Evolutionary Computation. 1112007</p>
<p>Particle Swarm Optimization: Basic Concepts, Variants and Applications in Power Systems. De Jong, K A Del Venayagamoorthy, G K Mohagheghi, S Hernandez, J C Harley, R G , Evolutionary Computation. 1222006. 2008MIT PressIEEE Transactions on</p>
<p>Genetic network inference: from coexpression clustering to reverse engineering. P D'haeseleer, S Liang, R Somogyi, Bioinformatics. 82000</p>
<p>Ant colony system: a cooperative learning approach to the traveling salesman problem. M Dorigo, L M Gambardella, Y Duan, P A Kollman, Evolutionary Computation. 111997. 2001IBM Syst. J.</p>
<p>Dynamic Musical Orchestration Using Genetic Algorithms and a Spectro-Temporal Description of Musical Instruments. P Esling, G Carpentier, C Agon, 2010EvoApplications</p>
<p>Differential Evolution. V Feoktistov, Search of Solutions. Secaucus, NJ, USASpringer-Verlag New York, Inc2006</p>
<p>{{W}hole-genome random sequencing and assembly of {H}aemophilus influenzae {R}d}. R D Fleischmann, M D Adams, O White, R A Clayton, E F Kirkness, A R Kerlavage, Science. 2691995</p>
<p>Study of fitness landscapes for the HP model of protein structure prediction. S D Flores, J Smith, {CEC} '03. The 2003 Congress on. 2003. 20034</p>
<p>Evolutionary Approaches to the Three-dimensional Multi-pipe Routing Problem: A Comparative Study Using Direct Encodings. M Furuholmen, K Glette, M Hovin, J Torresen, 2010EvoCOP</p>
<p>DNAse footprinting: a simple method for the detection of protein-{DNA} binding specificity. D J Galas, A Schmitz, Nucleic Acids Res. 591987</p>
<p>A gel electrophoresis method for quantifying the binding of proteins to specific {DNA} regions: application to components of the Escherichia coli lactose operon regulatory system. M M Garner, A Revzin, Nucleic Acids Res. 9131981</p>
<p>{{L}ife with 6000 genes}. A Goffeau, B Barrell, H Bussey, R Davis, B Dujon, H Feldmann, Science. 2741996</p>
<p>Computational identification of transcriptional regulatory elements in DNA sequence. D E Goldberg, J Richardson, Proceedings of the Second International Conference on Genetic algorithms and their application. the Second International Conference on Genetic algorithms and their applicationHillsdale, NJ, USAL. Erlbaum Associates Inc. GuhaThakurta, D1987. 200634Genetic algorithms with sharing for multimodal function optimization</p>
<p>Borg: An Auto-Adaptive Many-Objective Evolutionary Computing Framework. D Hadka, P Reed, Evolutionary Computation. 2122013</p>
<p>Adaptation in natural and artificial systems. J H Holland, 1975University of Michigan PressAnn Arbor</p>
<p>Protein structure comparison by alignment of distance matrices. L Holm, C Sander, J. Mol. Biol. 2331993</p>
<p>A Guided Genetic Algorithm for Protein Folding Prediction Using 3D Hydrophobic-Hydrophilic Model. T Hoque, M Chetty, L S Dooley, Evolutionary Computation. 2006. 2006. 2006IEEE Congress on</p>
<p>The 20 years of PROSITE. N Hulo, A Bairoch, V Bulliard, L Cerutti, B A Cuche, E De Castro, Nucl. Acids Res. 36suppl_12008</p>
<p>Analysis of the genome sequence of the flowering plant Arabidopsis thaliana. A G Initiative, Nature. 4082000</p>
<p>Bi-Criterion Optimization with Multi Colony Ant Algorithms. S Iredi, D Merkle, M Middendorf, Proceedings of the First International Conference on Evolutionary Multi-Criterion Optimization (EMO 2001), no. 1993 in LNCS. the First International Conference on Evolutionary Multi-Criterion Optimization (EMO 2001), no. 1993 in LNCSSpringer2000</p>
<p>Folding versus aggregation: polypeptide conformations on competing pathways. T R Jahn, S E Radford, Arch. Biochem. Biophys. 4692008</p>
<p>Computational discovery of gene regulatory binding motifs: a Bayesian perspective. S T Jensen, X S Liu, Q Zhou, J S Liu, Statistical Science. 1912004</p>
<p>Artificial Bee Colony (ABC) Optimization Algorithm for Training Feed-Forward Neural Networks. D Karaboga, B Akay, C Ozturk, MDAI. 4617V. Torra, Y. Narukawa, &amp; Y. Yoshida2007Springer</p>
<p>The many facets of natural computing. L Kari, G Rozenberg, Commun. ACM. 102008</p>
<p>Identifying combinatorial regulation of transcription factors and binding motifs. M Kato, N Hata, N Banerjee, B Futcher, M Q Zhang, Genome Biol. 5R562004</p>
<p>On evolving buffer overflow attacks using genetic programming. H Kayacik, M Heywood, N Zincir-Heywood, Proceedings of the 8th annual conference on Genetic and evolutionary computation. the 8th annual conference on Genetic and evolutionary computationNew YorkACM2006</p>
<p>Protein Structure Prediction With Evolutionary Algorithms. N Krasnogor, B Blackburnem, J Hirst, E Burke, N Krasnogor, W Hart, J Smith, D Pelta, 7th International Conference Parallel Problem Solving from Nature. 2439. Granada, Spain; BerlinMorgan Kaufmann2002. 1999Multimeme Algorithms for Protein Structure Prediction</p>
<p>Mechanical engineering design optimization by differential evolution. New ideas in optimization. J Lampinen, I Zelinka, 1999</p>
<p>Modesty Is the Best Policy: Automatic Discovery of Viable Forecasting Goals in Financial Data. F Larkin, C Ryan, EvoApplications. 22010</p>
<p>Discovering protein-DNA binding sequence patterns using association rule mining. K S Leung, K C Wong, T M Chan, M H Wong, K H Lee, C K Lau, Nucleic Acids Res. 38192010</p>
<p>Are there pathways for protein folding?. C Levinthal, J. Chem. Phys. 651968</p>
<p>Emergence of Preferred Structures in a Simple Model of Protein Folding. H Li, R Helling, C Tang, N Wingreen, Science. 27352751996</p>
<p>Evolutionary drug scheduling models with different toxicity metabolism in cancer chemotherapy. Y Liang, K S Leung, T S Mok, Appl. Soft Comput. 812008</p>
<p>An algorithm for finding protein--{DNA} binding sites with applications to chromatinimmunoprecipitation microarray experiments. X S Liu, D L Brutlag, J S Liu, Nat. Biotechnol. 202002</p>
<p>A Revised Comparison of Crossover and Mutation in Genetic Programming. S Luke, L Spector, Proceedings of the Third Annual Genetic Programming Conference (GP98). the Third Annual Genetic Programming Conference (GP98)Morgan Kaufmann1998</p>
<p>Protein-DNA interactions: amino acid conservation and the effects of mutations on binding specificity. N M Luscombe, J M Thornton, J Mol Biol. 32052002</p>
<p>An overview of the structures of protein-DNA complexes. N M Luscombe, S E Austin, H M Berman, J M Thornton, Genome Biol. 11S0012000</p>
<p>Practical strategies for discovering regulatory DNA sequence motifs. K D Macisaac, E Fraenkel, PLoS Comput Biol. 24e362006</p>
<p>TRANSFAC and its module TRANSCompel: transcriptional gene regulation in eukaryotes. V Matys, O V Kel-Margoulis, E Fricke, I Liebich, S Land, A Barre-Dirrie, Nucleic Acids Research. 342006</p>
<p>The PSIPRED protein structure prediction server. L J Mcguffin, K Bryson, D T Jones, Bioinformatics. 1642000</p>
<p>A weight matrix for binding recognition by the redox-response regulator ArcA-P of Escherichia coli. A M Mcguire, P De Wulf, G M Church, E C Lin, Mol. Microbiol. 321999</p>
<p>Structure-function-folding relationships and native energy landscape of dynein light chain protein: nuclear magnetic resonance insights. P M Mohan, R V Hosur, Bacterial Colony Optimization. Discrete Dynamics in Nature and Society. B Niu, H Wang, 2009. 201234698057</p>
<p>Prediction of DNA-binding residues from sequence. Y Ofran, V Mysore, B Rost, Bioinformatics. 23132007</p>
<p>A Standard GA Approach to Native Protein Conformation Prediction. A L Patton, Iii Punch, W F Goodman, E D , Proceedings of the 6th International Conference on Genetic Algorithms. R Poli, J Kennedy, T , the 6th International Conference on Genetic AlgorithmsSan Francisco, CA, USAMorgan Kaufmann Publishers Inc1995. 20071Particle swarm optimization</p>
<p>A Field Guide to Genetic Programming. R Poli, W B Langdon, N F Mcphee, 2008Lulu Enterprises, UK Ltd</p>
<p>Differential evolution vs. the functions of the 2nd ICEO. K V Price, IEEE International Conference on. I N Indianapolis, Usa Rahmat-Samii, Y Michielssen, E , New York, NY, USAJohn Wiley \&amp; Sons, Inc1997. 1997. 1999Electromagnetic Optimization by Genetic Algorithms</p>
<p>MrBayes 3: Bayesian phylogenetic inference under mixed models. F Ronquist, J P Huelsenbeck, Bioinformatics. 19122003</p>
<p>Analysis of Complexity Drift in Genetic Programming. J P Rosca, Proceedings of the Second Annual Conference. the Second Annual ConferenceMorgan Kaufmann1997. 1997</p>
<p>Protein Folding in Simplified Models With Estimation of Distribution Algorithms. W F Sacco, N Henderson, A C Rios-Coelho, M M Ali, C M Pereira, R Santana, P Larranaga, J A Lozano, {IEEE} Transactions on Evolutionary Computation. 1242009. June. 2008Annals of Nuclear Energy</p>
<p>Ant-based load balancing in telecommunications networks. R Schoonderwoerd, J L Bruten, O E Holland, L J Rothkrantz, Adapt. Behav. 521996</p>
<p>The intelligent water drops algorithm: a nature-inspired swarm-based optimization algorithm. H Shah-Hosseini, International Journal of Bio-Inspired Computation. 12009</p>
<p>An ant colony optimisation algorithm for the 2D and 3D hydrophobic polar protein folding problem. A Shmygelska, H Hoos, BMC Bioinformatics. 61302005</p>
<p>Evolutionary Algorithms for the Protein Folding Problem: A Review and Current Trends. H Silverio, Computational Intelligence in Biomedicine and Bioinformatics. 2008</p>
<p>Mining ChIP-chip data for transcription factor and cofactor binding sites. A D Smith, P Sumazin, D Das, M Q Zhang, Bioinformatics. 2005Suppl 1 (20</p>
<p>M S Smyth, J H Martin, W M Spears, V Anand, A Study of Crossover Operators in Genetic Programming. ISMIS '91: Proceedings of the 6th International Symposium on Methodologies for Intelligent Systems. London, UKSpringer-Verlag2000. 199153X ray crystallography. Molecular pathology : MP</p>
<p>Differential Evolution -A Simple and Efficient Heuristic for global Optimization over Continuous Spaces. R Storn, K Price, Journal of Global Optimization. 1141997</p>
<p>The evolution of combinatorial gene regulation in fungi. S Terence, J A Foster, J Dickinson, B B Tuch, D J Galgoczy, A D Hernday, H Li, A D Johnson, Proceedings of the 1st annual conference on genetic programming. the 1st annual conference on genetic programmingCambridge, MAMIT Press1996. 20086e38Code growth in genetic programming</p>
<p>Genetic Algorithm for 3D Protein Folding Simulations. R Unger, J Moult, Proceedings of the 5th International Conference on Genetic Algorithms. the 5th International Conference on Genetic AlgorithmsSan Francisco, CA, USAMorgan Kaufmann Publishers Inc1993</p>
<p>Levy flight search patterns of wandering albatrosses. G M Vuswabatgab, V Afanasyer, S V Buldyrev, E J Murphy, P A Prince, H E Stanley, Nature. 3811996</p>
<p>A Rigorous Evaluation of Crossover and Mutation in Genetic Programming. D R White, S Poulding, 09: Proceedings of the 12th European Conference on Genetic Programming. Berlin, HeidelbergSpringer-Verlag2009</p>
<p>R J White, Gene Transcription: Mechanisms and Control. Wiley-Blackwell2001</p>
<p>A genetic algorithm tutorial. D Whitley, Statistics and Computing. 421994</p>
<p>SNPdryad: predicting deleterious non-synonymous human SNPs using only orthologous protein sequences. K C Wong, Z Zhang, Bioinformatics. 3082014</p>
<p>DNA motif elucidation using belief propagation. K C Wong, T M Chan, C Peng, Y Li, Z Zhang, Nucleic Acids Res. 4116e1532013</p>
<p>An evolutionary algorithm with speciesspecific explosion for multimodal optimization. K C Wong, K S Leung, M H Wong, GECCO '09: Proceedings of the 11th Annual conference on Genetic and evolutionary computation. New York, NY, USAACM2009</p>
<p>Effect of Spatial Locality on An Evolutionary Algorithm for Multimodal Optimization. K C Wong, K S Leung, M H Wong, Part I. LNCS. Springer-Verlag2010. 20106024</p>
<p>Protein Structure Prediction on a Lattice Model via Multimodal Optimization Techniques. K C Wong, K S Leung, M H Wong, Proceedings of the 12th annual conference on Genetic and evolutionary computation. the 12th annual conference on Genetic and evolutionary computationPortlandACM2010</p>
<p>SignalSpider: probabilistic pattern discovery on multiple normalized ChIP-Seq signal profiles. K C Wong, Y Li, C Peng, Z Zhang, Bioinformatics. 3112015</p>
<p>Herd Clustering: a synergistic data clustering approach using collective intelligence. K C Wong, C Peng, Y Li, T M Chan, Applied Soft Computing. 232014</p>
<p>Generalizing and learning protein-DNA binding sequence representations by an evolutionary algorithm. K C Wong, C Peng, M H Wong, K S Leung, Soft Comput. 1582011</p>
<p>Extracting sequence features to predict protein-DNA interactions: a comparative study. Q Zhou, J S Liu, Nucl. Acids Res. 36122008</p>            </div>
        </div>

    </div>
</body>
</html>