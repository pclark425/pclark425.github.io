<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-8947 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-8947</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-8947</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-157.html">extraction-schema-157</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing self-reflection or iterative answer improvement (e.g., generate-then-reflect, self-critique, reflexion), including descriptions of the methods, tasks, performance results, mechanisms, and any reported limitations or failure cases.</div>
                <p><strong>Paper ID:</strong> paper-7c1707db9aafd209aa93db3251e7ebd593d55876</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/7c1707db9aafd209aa93db3251e7ebd593d55876" target="_blank">SelfCheckGPT: Zero-Resource Black-Box Hallucination Detection for Generative Large Language Models</a></p>
                <p><strong>Paper Venue:</strong> Conference on Empirical Methods in Natural Language Processing</p>
                <p><strong>Paper TL;DR:</strong> This work proposes "SelfCheckGPT", a simple sampling-based approach that can be used to fact-check the responses of black-box models in a zero-resource fashion, i.e. without an external database, and demonstrates that it can detect non-factual and factual sentences and rank passages in terms of factuality.</p>
                <p><strong>Paper Abstract:</strong> Generative Large Language Models (LLMs) such as GPT-3 are capable of generating highly fluent responses to a wide variety of user prompts. However, LLMs are known to hallucinate facts and make non-factual statements which can undermine trust in their output. Existing fact-checking approaches either require access to the output probability distribution (which may not be available for systems such as ChatGPT) or external databases that are interfaced via separate, often complex, modules. In this work, we propose"SelfCheckGPT", a simple sampling-based approach that can be used to fact-check the responses of black-box models in a zero-resource fashion, i.e. without an external database. SelfCheckGPT leverages the simple idea that if an LLM has knowledge of a given concept, sampled responses are likely to be similar and contain consistent facts. However, for hallucinated facts, stochastically sampled responses are likely to diverge and contradict one another. We investigate this approach by using GPT-3 to generate passages about individuals from the WikiBio dataset, and manually annotate the factuality of the generated passages. We demonstrate that SelfCheckGPT can: i) detect non-factual and factual sentences; and ii) rank passages in terms of factuality. We compare our approach to several baselines and show that our approach has considerably higher AUC-PR scores in sentence-level hallucination detection and higher correlation scores in passage-level factuality assessment compared to grey-box methods.</p>
                <p><strong>Cost:</strong> 0.017</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e8947.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e8947.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing self-reflection or iterative answer improvement (e.g., generate-then-reflect, self-critique, reflexion), including descriptions of the methods, tasks, performance results, mechanisms, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>SelfCheckGPT-Prompt</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>SelfCheckGPT (Prompt-based evaluator variant)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A variant of SelfCheckGPT that uses an LLM (GPT-3 or ChatGPT) prompted in a zero-shot manner to judge whether each sentence of a generated response is supported by stochastically sampled responses; Yes/No outputs are mapped to inconsistency scores and averaged over samples.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>GPT-3 (text-davinci-003) / ChatGPT (gpt-3.5-turbo)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>GPT-3 (text-davinci-003) was used to generate passages (state-of-the-art at the time); ChatGPT (gpt-3.5-turbo) and GPT-3 were used as the prompted evaluators. The paper does not report parameter counts for these proprietary models.</td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_name</strong></td>
                            <td>Prompt-based self-check (SelfCheckGPT-Prompt)</td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_description</strong></td>
                            <td>For each sentence r_i of the main response R, draw N stochastic samples S^n (N typically 20). For each sample, prompt an LLM with: 'Context: {S^n} Sentence: {r_i} Is the sentence supported by the context above? Answer Yes or No:' Map Yes -> 0.0, No -> 1.0, N/A -> 0.5; average over N to obtain inconsistency score S_Prompt(i).</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Sentence-level hallucination detection / Passage-level factuality ranking on GPT-3 generated WikiBio passages</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Detect non-factual (hallucinated) sentences and rank passages by factuality. Dataset: 238 GPT-3-generated Wikipedia-style passages (WikiBio concepts), 1908 annotated sentences with 3-class labels (major inaccurate, minor inaccurate, accurate), aggregated to sentence- and passage-level metrics.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_reflection</strong></td>
                            <td>Sentence-level AUC-PR: NonFact = 93.42, NonFact* = 53.19, Factual = 67.09; Passage-level Pearson correlation = 78.32, Spearman = 78.30 (using GPT-3-generated samples, N=20). When using ChatGPT as evaluator with N=20, similar or slightly improved scores were observed.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_reflection</strong></td>
                            <td>Grey-box baseline (GPT-3 token probabilities) Avg(-log p): Sentence-level AUC-PR NonFact = 83.21, Factual = 53.97; Passage-level Pearson = 57.04, Spearman = 53.93. Random baseline: sentence-level NonFact AUC-PR = 72.96, Factual = 27.04.</td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_comparison</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_of_reflection</strong></td>
                            <td>Prompt engineering: an LLM is prompted to judge support/contradiction between a sentence and sampled contexts; relies on sampling multiple stochastic outputs and aggregating binary judgments.</td>
                        </tr>
                        <tr>
                            <td><strong>number_of_iterations</strong></td>
                            <td>20</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_improvement</strong></td>
                            <td>Quantitative: SelfCheckGPT-Prompt outperformed all other considered methods (grey-box probability/entropy, proxy LLM, and other SelfCheckGPT variants) for sentence-level detection and passage-level ranking. Example: NonFact AUC-PR improved from 83.21 (GPT-3 Avg(-log p)) to 93.42 (Prompt); passage Pearson correlation improved from 57.04 to 78.32.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Computationally heavy and higher API cost (noted estimated costs ~$200 for GPT-3 or ~$20 for ChatGPT for full experiments); less-capable models (e.g., GPT-3 text-curie-001 or smaller open LLMs) failed to reliably perform the binary support assessment; depends on number of samples (diminishing returns but costs increase); may not be practical for all use-cases.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_methods</strong></td>
                            <td>Directly compared against grey-box token-probability and entropy methods, proxy LLMs, and other SelfCheckGPT variants (BERTScore, QA, n-gram, NLI). Prompt variant gave the highest sentence-level AUC-PR and passage-level correlations. NLI variant was the next best trade-off (good performance with lower compute).</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_study_results</strong></td>
                            <td>Ablations: varying N (number of samples) shows performance increases smoothly with sample count and plateaus; LLM choice ablation: ChatGPT as evaluator slightly outperformed GPT-3 evaluator (e.g., ChatGPT with N=20 Pearson=78.32; GPT-3 evaluator with N=4 had Pearson=73.11; ChatGPT with N=4 had Pearson=76.47), showing the evaluator model and sample count matter. Detailed per-N curves and evaluator comparisons reported.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'SelfCheckGPT: Zero-Resource Black-Box Hallucination Detection for Generative Large Language Models', 'publication_date_yy_mm': '2023-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8947.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e8947.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing self-reflection or iterative answer improvement (e.g., generate-then-reflect, self-critique, reflexion), including descriptions of the methods, tasks, performance results, mechanisms, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>SelfCheckGPT-QA</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>SelfCheckGPT (Question-Answering / MQAG variant)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A variant of SelfCheckGPT that generates multiple-choice questions from a target sentence and uses an independent answering system conditioned on other sampled responses to measure answer agreement as a proxy for factual consistency; includes Bayes-based soft-counting for answerability.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Generators: T5-Large (fine-tuned SQuAD & RACE); Answerer/Answerability: Longformer (fine-tuned RACE / SQuAD2.0). Evaluator LLMs not required for this variant.</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Question generators (G1, G2) are T5-Large variants fine-tuned on QA datasets; the answering and answerability systems are Longformer models fine-tuned on RACE and SQuAD2.0 respectively. These are treated as independent systems to answer questions over sampled contexts.</td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_name</strong></td>
                            <td>MQAG-based self-consistency (SelfCheckGPT-QA)</td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_description</strong></td>
                            <td>For sentence r_i, generate multiple-choice questions q and options o using two-stage MQAG (G1 yields question+answer; G2 yields distractors). For each sample S^n, use an answering model A to pick option a_{S^n}. Compute matches between a_R (answer when conditioned on R) and a_{S^n} across samples; convert match/mismatch counts to an inconsistency probability via a Bayes-derived formula with soft answerability weights alpha.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Sentence-level hallucination detection / Passage-level factuality ranking on GPT-3 generated WikiBio passages</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Same WikiBio GPT-3-generated dataset as above; QA-based consistency measures if answers over samples agree imply factuality.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_reflection</strong></td>
                            <td>Sentence-level AUC-PR: NonFact = 84.26, NonFact* = 40.06, Factual = 48.14; Passage-level Pearson = 61.07, Spearman = 59.29 (SelfCheckGPT-QA with Bayes + soft-counting, N=20).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_reflection</strong></td>
                            <td>Without QA-based sampling aggregation, simple-counting and Bayes variants produced slightly lower passage correlations (SimpleCount PCC 57.39; Bayes-only 56.43), showing benefit of soft-counting; compared to grey-box Avg(-log p) (sentence-level NonFact AUC-PR 83.21) QA is competitive or slightly better for some metrics.</td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_comparison</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_of_reflection</strong></td>
                            <td>Automated question generation and answering across multiple sampled outputs; aggregation via Bayes' theorem with answerability weighting (alpha) to produce inconsistency scores.</td>
                        </tr>
                        <tr>
                            <td><strong>number_of_iterations</strong></td>
                            <td>20</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_improvement</strong></td>
                            <td>Quantitative: QA variant with Bayes+alpha improved passage-level Pearson from ~56 (Bayes-only) to 61.07; performs better than some grey-box and proxy-LM baselines and is competitive among SelfCheckGPT variants.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Requires reliable question generation and answerability estimation; performance sensitive to quality of question generation and answerer; more computationally expensive (training/fine-tuning QA modules) than simple n-gram or BERTScore variants; QA variant not as strong as Prompt or NLI variants in absolute best performance.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_methods</strong></td>
                            <td>Compared to other SelfCheckGPT variants, QA is outperformed by Prompt and NLI variants on most metrics, but outperforms BERTScore and some proxy-LM baselines; Bayes+soft-counting improves over naive counting.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_study_results</strong></td>
                            <td>Ablation of simple-count vs Bayes vs Bayes+alpha shows Bayes+alpha (soft-counting using answerability) yields best passage-level correlations (PCC 61.07) and better sentence-level AUC-PR than Bayes-only.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'SelfCheckGPT: Zero-Resource Black-Box Hallucination Detection for Generative Large Language Models', 'publication_date_yy_mm': '2023-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8947.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e8947.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing self-reflection or iterative answer improvement (e.g., generate-then-reflect, self-critique, reflexion), including descriptions of the methods, tasks, performance results, mechanisms, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>SelfCheckGPT (general sampling)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>SelfCheckGPT (sampling-based consistency checking umbrella)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>The general SelfCheckGPT approach: draw multiple stochastic samples from a black-box LLM for the same prompt and measure informational consistency between the main response and samples using multiple scoring methods (BERTScore, n-gram LM, NLI, prompting, QA).</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>GPT-3 (text-davinci-003) used to generate passages; various auxiliary models used depending on variant (RoBERTa-Large for BERTScore backbone, DeBERTa-v3-large fine-tuned to MNLI for NLI, n-gram models trained on samples, etc.).</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Main text generator: GPT-3 (text-davinci-003). BERTScore backbone: RoBERTa-Large. NLI: DeBERTa-v3-large fine-tuned on MNLI. Proxy LLMs (for alternative evaluations) included LLaMA, OPT, GPT-J, GPT-NeoX in other experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_name</strong></td>
                            <td>Generate-and-compare / self-consistency via sampling (SelfCheckGPT umbrella)</td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_description</strong></td>
                            <td>Generate N stochastic samples for same prompt (N typically 20). For each sentence in main response, compute a consistency/hallucination score by aggregating pairwise comparisons between the sentence and samples using methods: BERTScore similarity, MQAG QA agreement, n-gram LM token probabilities from samples, NLI contradiction probability, or LLM prompt-based support judgments. Scores are normalized into [0,1] (except raw n-gram LM values) and averaged to obtain sentence- and passage-level scores.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Sentence-level hallucination detection and passage-level factuality ranking on GPT-3 generated WikiBio passages</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Same dataset: 238 passages, 1908 annotated sentences; evaluate per-sentence detection (AUC-PR) and passage ranking (Pearson/Spearman) against human labels.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_reflection</strong></td>
                            <td>Best performing SelfCheckGPT variants: NLI variant: Sentence-level AUC-PR NonFact = 92.50, Factual = 66.08; Passage-level Pearson = 74.14, Spearman = 73.78. Unigram (max) n-gram variant: NonFact = 85.63, Factual = 58.47; Passage Pearson = 64.71. BERTScore variant: NonFact = 81.96. Prompt variant (see entry above) yields highest absolute numbers.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_reflection</strong></td>
                            <td>Grey-box token-probability baseline (GPT-3 probabilities) Avg(-log p): Sentence-level NonFact AUC-PR = 83.21, Passage Pearson = 57.04. Proxy LLM approaches performed worse overall (e.g., LLaMA-30B Avg(-log p) passage Pearson = 21.72).</td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_comparison</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_of_reflection</strong></td>
                            <td>No external database: relies exclusively on multiple stochastic draws from the target LLM (or self-samples) and internal scorers (BERTScore, NLI classifier, n-gram LM trained on samples, prompting another LLM) to measure consistency and produce hallucination scores.</td>
                        </tr>
                        <tr>
                            <td><strong>number_of_iterations</strong></td>
                            <td>20</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_improvement</strong></td>
                            <td>Quantitative evidence across multiple variants shows sampling-based consistency measures outperform grey-box token-probability baselines in both sentence-level detection and passage-level ranking. Example: SelfCheckGPT-NLI NonFact AUC-PR 92.50 vs GPT-3 Avg(-log p) 83.21; passage Pearson 74.14 vs 57.04.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Performance depends on number of samples (more samples improve performance but increase compute/cost); some variants (n-gram) require many samples to plateau; using proxy LLMs to approximate probabilities performs poorly because different LLMs have different generation patterns; self-samples may fail when main response is total hallucination (all samples fabricated) â€” labeled 'total hallucination' cases noted in dataset; methods that rely on prompting require capable evaluators.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_methods</strong></td>
                            <td>Compared several internal scoring methods: NLI and Prompt variants outperformed BERTScore, QA, n-gram and grey-box methods. Unigram (max) n-gram (finding least-occurring token) worked surprisingly well and is cheap; NLI offered a strong trade-off between performance and compute; Prompt was best but most computationally heavy.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_study_results</strong></td>
                            <td>Ablations: varying N shows smooth performance gains with diminishing returns; n-gram performance by n (1..5) shows 1-gram max works best and higher n reduces performance; proxy LLM experiments show poor generalization of probability-approximation by other models; ablation on using external knowledge (WikiBio references) vs self-samples: some variants (NLI/Prompt) improved with external knowledge, while n-gram dropped.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'SelfCheckGPT: Zero-Resource Black-Box Hallucination Detection for Generative Large Language Models', 'publication_date_yy_mm': '2023-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8947.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e8947.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing self-reflection or iterative answer improvement (e.g., generate-then-reflect, self-critique, reflexion), including descriptions of the methods, tasks, performance results, mechanisms, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Self-evaluation (Kadavath et al.)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Self-evaluation (prompting an LLM to evaluate its own output)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Prior work that prompts an LLM to estimate the correctness or probability that its own generated answer/response is true; mentioned in the paper as related work on model self-assessment.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Language models (mostly) know what they know.</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_name</strong></td>
                            <td>Self-evaluation / self-assessment</td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_description</strong></td>
                            <td>Prompting an LLM to evaluate or assign a probability to the correctness of its own previous prediction/answer (single-step self-assessment rather than multi-sample consistency aggregation).</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_reflection</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_reflection</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_comparison</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_of_reflection</strong></td>
                            <td>Prompt engineering (asking the model to evaluate its own outputs); may use model-internal signals when available.</td>
                        </tr>
                        <tr>
                            <td><strong>number_of_iterations</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_improvement</strong></td>
                            <td>Mentioned as related work; no experimental details or numbers provided in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Not discussed in detail in this paper beyond being cited as a related approach; typically requires capability of the LLM to self-assess reliably.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_methods</strong></td>
                            <td>Cited alongside other self-assessment/self-check approaches; no direct experimental comparison in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_study_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'SelfCheckGPT: Zero-Resource Black-Box Hallucination Detection for Generative Large Language Models', 'publication_date_yy_mm': '2023-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8947.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e8947.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing self-reflection or iterative answer improvement (e.g., generate-then-reflect, self-critique, reflexion), including descriptions of the methods, tasks, performance results, mechanisms, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Self-consistency (Wang et al.)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Self-consistency decoding for chain-of-thought reasoning</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Prior work that performs multiple stochastic decodings (e.g., of chain-of-thought reasoning paths) and aggregates answers (often via majority vote) to improve reasoning accuracy; cited in the paper as relevant to sampling/self-consistency ideas.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Self-consistency improves chain of thought reasoning in language models.</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_name</strong></td>
                            <td>Self-consistency (aggregate multiple reasoning traces)</td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_description</strong></td>
                            <td>Generate multiple chain-of-thought (CoT) reasoning samples via stochastic decoding and aggregate final answers (e.g., majority voting) to yield more accurate answers than a single deterministic CoT.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_reflection</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_reflection</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_comparison</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_of_reflection</strong></td>
                            <td>Sampling-based aggregation of multiple reasoning traces; not implemented in this paper but referenced in background as related to sampling/self-consistency.</td>
                        </tr>
                        <tr>
                            <td><strong>number_of_iterations</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_improvement</strong></td>
                            <td>Cited as evidence that sampling/self-consistency can improve performance on complex reasoning tasks (reference only; no new experiments in this paper).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Not discussed in this paper beyond being cited; known limitations (from original work) include computation cost and dependence on CoT-capable models, but those details are not analyzed here.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_methods</strong></td>
                            <td>Mentioned in relation to chain-of-thought improvements; no direct comparison in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_study_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'SelfCheckGPT: Zero-Resource Black-Box Hallucination Detection for Generative Large Language Models', 'publication_date_yy_mm': '2023-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Self-consistency improves chain of thought reasoning in language models <em>(Rating: 2)</em></li>
                <li>Language models (mostly) know what they know. <em>(Rating: 2)</em></li>
                <li>The internal state of an llm knows when its lying <em>(Rating: 2)</em></li>
                <li>MQAG: Multiple-choice question answering and generation for assessing information consistency in summarization <em>(Rating: 2)</em></li>
                <li>Chatgpt as a factual inconsistency evaluator for abstractive text summarization <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-8947",
    "paper_id": "paper-7c1707db9aafd209aa93db3251e7ebd593d55876",
    "extraction_schema_id": "extraction-schema-157",
    "extracted_data": [
        {
            "name_short": "SelfCheckGPT-Prompt",
            "name_full": "SelfCheckGPT (Prompt-based evaluator variant)",
            "brief_description": "A variant of SelfCheckGPT that uses an LLM (GPT-3 or ChatGPT) prompted in a zero-shot manner to judge whether each sentence of a generated response is supported by stochastically sampled responses; Yes/No outputs are mapped to inconsistency scores and averaged over samples.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "GPT-3 (text-davinci-003) / ChatGPT (gpt-3.5-turbo)",
            "model_description": "GPT-3 (text-davinci-003) was used to generate passages (state-of-the-art at the time); ChatGPT (gpt-3.5-turbo) and GPT-3 were used as the prompted evaluators. The paper does not report parameter counts for these proprietary models.",
            "reflection_method_name": "Prompt-based self-check (SelfCheckGPT-Prompt)",
            "reflection_method_description": "For each sentence r_i of the main response R, draw N stochastic samples S^n (N typically 20). For each sample, prompt an LLM with: 'Context: {S^n} Sentence: {r_i} Is the sentence supported by the context above? Answer Yes or No:' Map Yes -&gt; 0.0, No -&gt; 1.0, N/A -&gt; 0.5; average over N to obtain inconsistency score S_Prompt(i).",
            "task_name": "Sentence-level hallucination detection / Passage-level factuality ranking on GPT-3 generated WikiBio passages",
            "task_description": "Detect non-factual (hallucinated) sentences and rank passages by factuality. Dataset: 238 GPT-3-generated Wikipedia-style passages (WikiBio concepts), 1908 annotated sentences with 3-class labels (major inaccurate, minor inaccurate, accurate), aggregated to sentence- and passage-level metrics.",
            "performance_with_reflection": "Sentence-level AUC-PR: NonFact = 93.42, NonFact* = 53.19, Factual = 67.09; Passage-level Pearson correlation = 78.32, Spearman = 78.30 (using GPT-3-generated samples, N=20). When using ChatGPT as evaluator with N=20, similar or slightly improved scores were observed.",
            "performance_without_reflection": "Grey-box baseline (GPT-3 token probabilities) Avg(-log p): Sentence-level AUC-PR NonFact = 83.21, Factual = 53.97; Passage-level Pearson = 57.04, Spearman = 53.93. Random baseline: sentence-level NonFact AUC-PR = 72.96, Factual = 27.04.",
            "has_performance_comparison": true,
            "mechanism_of_reflection": "Prompt engineering: an LLM is prompted to judge support/contradiction between a sentence and sampled contexts; relies on sampling multiple stochastic outputs and aggregating binary judgments.",
            "number_of_iterations": 20,
            "evidence_for_improvement": "Quantitative: SelfCheckGPT-Prompt outperformed all other considered methods (grey-box probability/entropy, proxy LLM, and other SelfCheckGPT variants) for sentence-level detection and passage-level ranking. Example: NonFact AUC-PR improved from 83.21 (GPT-3 Avg(-log p)) to 93.42 (Prompt); passage Pearson correlation improved from 57.04 to 78.32.",
            "limitations_or_failure_cases": "Computationally heavy and higher API cost (noted estimated costs ~$200 for GPT-3 or ~$20 for ChatGPT for full experiments); less-capable models (e.g., GPT-3 text-curie-001 or smaller open LLMs) failed to reliably perform the binary support assessment; depends on number of samples (diminishing returns but costs increase); may not be practical for all use-cases.",
            "comparison_to_other_methods": "Directly compared against grey-box token-probability and entropy methods, proxy LLMs, and other SelfCheckGPT variants (BERTScore, QA, n-gram, NLI). Prompt variant gave the highest sentence-level AUC-PR and passage-level correlations. NLI variant was the next best trade-off (good performance with lower compute).",
            "ablation_study_results": "Ablations: varying N (number of samples) shows performance increases smoothly with sample count and plateaus; LLM choice ablation: ChatGPT as evaluator slightly outperformed GPT-3 evaluator (e.g., ChatGPT with N=20 Pearson=78.32; GPT-3 evaluator with N=4 had Pearson=73.11; ChatGPT with N=4 had Pearson=76.47), showing the evaluator model and sample count matter. Detailed per-N curves and evaluator comparisons reported.",
            "uuid": "e8947.0",
            "source_info": {
                "paper_title": "SelfCheckGPT: Zero-Resource Black-Box Hallucination Detection for Generative Large Language Models",
                "publication_date_yy_mm": "2023-03"
            }
        },
        {
            "name_short": "SelfCheckGPT-QA",
            "name_full": "SelfCheckGPT (Question-Answering / MQAG variant)",
            "brief_description": "A variant of SelfCheckGPT that generates multiple-choice questions from a target sentence and uses an independent answering system conditioned on other sampled responses to measure answer agreement as a proxy for factual consistency; includes Bayes-based soft-counting for answerability.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "Generators: T5-Large (fine-tuned SQuAD & RACE); Answerer/Answerability: Longformer (fine-tuned RACE / SQuAD2.0). Evaluator LLMs not required for this variant.",
            "model_description": "Question generators (G1, G2) are T5-Large variants fine-tuned on QA datasets; the answering and answerability systems are Longformer models fine-tuned on RACE and SQuAD2.0 respectively. These are treated as independent systems to answer questions over sampled contexts.",
            "reflection_method_name": "MQAG-based self-consistency (SelfCheckGPT-QA)",
            "reflection_method_description": "For sentence r_i, generate multiple-choice questions q and options o using two-stage MQAG (G1 yields question+answer; G2 yields distractors). For each sample S^n, use an answering model A to pick option a_{S^n}. Compute matches between a_R (answer when conditioned on R) and a_{S^n} across samples; convert match/mismatch counts to an inconsistency probability via a Bayes-derived formula with soft answerability weights alpha.",
            "task_name": "Sentence-level hallucination detection / Passage-level factuality ranking on GPT-3 generated WikiBio passages",
            "task_description": "Same WikiBio GPT-3-generated dataset as above; QA-based consistency measures if answers over samples agree imply factuality.",
            "performance_with_reflection": "Sentence-level AUC-PR: NonFact = 84.26, NonFact* = 40.06, Factual = 48.14; Passage-level Pearson = 61.07, Spearman = 59.29 (SelfCheckGPT-QA with Bayes + soft-counting, N=20).",
            "performance_without_reflection": "Without QA-based sampling aggregation, simple-counting and Bayes variants produced slightly lower passage correlations (SimpleCount PCC 57.39; Bayes-only 56.43), showing benefit of soft-counting; compared to grey-box Avg(-log p) (sentence-level NonFact AUC-PR 83.21) QA is competitive or slightly better for some metrics.",
            "has_performance_comparison": true,
            "mechanism_of_reflection": "Automated question generation and answering across multiple sampled outputs; aggregation via Bayes' theorem with answerability weighting (alpha) to produce inconsistency scores.",
            "number_of_iterations": 20,
            "evidence_for_improvement": "Quantitative: QA variant with Bayes+alpha improved passage-level Pearson from ~56 (Bayes-only) to 61.07; performs better than some grey-box and proxy-LM baselines and is competitive among SelfCheckGPT variants.",
            "limitations_or_failure_cases": "Requires reliable question generation and answerability estimation; performance sensitive to quality of question generation and answerer; more computationally expensive (training/fine-tuning QA modules) than simple n-gram or BERTScore variants; QA variant not as strong as Prompt or NLI variants in absolute best performance.",
            "comparison_to_other_methods": "Compared to other SelfCheckGPT variants, QA is outperformed by Prompt and NLI variants on most metrics, but outperforms BERTScore and some proxy-LM baselines; Bayes+soft-counting improves over naive counting.",
            "ablation_study_results": "Ablation of simple-count vs Bayes vs Bayes+alpha shows Bayes+alpha (soft-counting using answerability) yields best passage-level correlations (PCC 61.07) and better sentence-level AUC-PR than Bayes-only.",
            "uuid": "e8947.1",
            "source_info": {
                "paper_title": "SelfCheckGPT: Zero-Resource Black-Box Hallucination Detection for Generative Large Language Models",
                "publication_date_yy_mm": "2023-03"
            }
        },
        {
            "name_short": "SelfCheckGPT (general sampling)",
            "name_full": "SelfCheckGPT (sampling-based consistency checking umbrella)",
            "brief_description": "The general SelfCheckGPT approach: draw multiple stochastic samples from a black-box LLM for the same prompt and measure informational consistency between the main response and samples using multiple scoring methods (BERTScore, n-gram LM, NLI, prompting, QA).",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "GPT-3 (text-davinci-003) used to generate passages; various auxiliary models used depending on variant (RoBERTa-Large for BERTScore backbone, DeBERTa-v3-large fine-tuned to MNLI for NLI, n-gram models trained on samples, etc.).",
            "model_description": "Main text generator: GPT-3 (text-davinci-003). BERTScore backbone: RoBERTa-Large. NLI: DeBERTa-v3-large fine-tuned on MNLI. Proxy LLMs (for alternative evaluations) included LLaMA, OPT, GPT-J, GPT-NeoX in other experiments.",
            "reflection_method_name": "Generate-and-compare / self-consistency via sampling (SelfCheckGPT umbrella)",
            "reflection_method_description": "Generate N stochastic samples for same prompt (N typically 20). For each sentence in main response, compute a consistency/hallucination score by aggregating pairwise comparisons between the sentence and samples using methods: BERTScore similarity, MQAG QA agreement, n-gram LM token probabilities from samples, NLI contradiction probability, or LLM prompt-based support judgments. Scores are normalized into [0,1] (except raw n-gram LM values) and averaged to obtain sentence- and passage-level scores.",
            "task_name": "Sentence-level hallucination detection and passage-level factuality ranking on GPT-3 generated WikiBio passages",
            "task_description": "Same dataset: 238 passages, 1908 annotated sentences; evaluate per-sentence detection (AUC-PR) and passage ranking (Pearson/Spearman) against human labels.",
            "performance_with_reflection": "Best performing SelfCheckGPT variants: NLI variant: Sentence-level AUC-PR NonFact = 92.50, Factual = 66.08; Passage-level Pearson = 74.14, Spearman = 73.78. Unigram (max) n-gram variant: NonFact = 85.63, Factual = 58.47; Passage Pearson = 64.71. BERTScore variant: NonFact = 81.96. Prompt variant (see entry above) yields highest absolute numbers.",
            "performance_without_reflection": "Grey-box token-probability baseline (GPT-3 probabilities) Avg(-log p): Sentence-level NonFact AUC-PR = 83.21, Passage Pearson = 57.04. Proxy LLM approaches performed worse overall (e.g., LLaMA-30B Avg(-log p) passage Pearson = 21.72).",
            "has_performance_comparison": true,
            "mechanism_of_reflection": "No external database: relies exclusively on multiple stochastic draws from the target LLM (or self-samples) and internal scorers (BERTScore, NLI classifier, n-gram LM trained on samples, prompting another LLM) to measure consistency and produce hallucination scores.",
            "number_of_iterations": 20,
            "evidence_for_improvement": "Quantitative evidence across multiple variants shows sampling-based consistency measures outperform grey-box token-probability baselines in both sentence-level detection and passage-level ranking. Example: SelfCheckGPT-NLI NonFact AUC-PR 92.50 vs GPT-3 Avg(-log p) 83.21; passage Pearson 74.14 vs 57.04.",
            "limitations_or_failure_cases": "Performance depends on number of samples (more samples improve performance but increase compute/cost); some variants (n-gram) require many samples to plateau; using proxy LLMs to approximate probabilities performs poorly because different LLMs have different generation patterns; self-samples may fail when main response is total hallucination (all samples fabricated) â€” labeled 'total hallucination' cases noted in dataset; methods that rely on prompting require capable evaluators.",
            "comparison_to_other_methods": "Compared several internal scoring methods: NLI and Prompt variants outperformed BERTScore, QA, n-gram and grey-box methods. Unigram (max) n-gram (finding least-occurring token) worked surprisingly well and is cheap; NLI offered a strong trade-off between performance and compute; Prompt was best but most computationally heavy.",
            "ablation_study_results": "Ablations: varying N shows smooth performance gains with diminishing returns; n-gram performance by n (1..5) shows 1-gram max works best and higher n reduces performance; proxy LLM experiments show poor generalization of probability-approximation by other models; ablation on using external knowledge (WikiBio references) vs self-samples: some variants (NLI/Prompt) improved with external knowledge, while n-gram dropped.",
            "uuid": "e8947.2",
            "source_info": {
                "paper_title": "SelfCheckGPT: Zero-Resource Black-Box Hallucination Detection for Generative Large Language Models",
                "publication_date_yy_mm": "2023-03"
            }
        },
        {
            "name_short": "Self-evaluation (Kadavath et al.)",
            "name_full": "Self-evaluation (prompting an LLM to evaluate its own output)",
            "brief_description": "Prior work that prompts an LLM to estimate the correctness or probability that its own generated answer/response is true; mentioned in the paper as related work on model self-assessment.",
            "citation_title": "Language models (mostly) know what they know.",
            "mention_or_use": "mention",
            "model_name": null,
            "model_description": null,
            "reflection_method_name": "Self-evaluation / self-assessment",
            "reflection_method_description": "Prompting an LLM to evaluate or assign a probability to the correctness of its own previous prediction/answer (single-step self-assessment rather than multi-sample consistency aggregation).",
            "task_name": null,
            "task_description": null,
            "performance_with_reflection": null,
            "performance_without_reflection": null,
            "has_performance_comparison": false,
            "mechanism_of_reflection": "Prompt engineering (asking the model to evaluate its own outputs); may use model-internal signals when available.",
            "number_of_iterations": null,
            "evidence_for_improvement": "Mentioned as related work; no experimental details or numbers provided in this paper.",
            "limitations_or_failure_cases": "Not discussed in detail in this paper beyond being cited as a related approach; typically requires capability of the LLM to self-assess reliably.",
            "comparison_to_other_methods": "Cited alongside other self-assessment/self-check approaches; no direct experimental comparison in this paper.",
            "ablation_study_results": null,
            "uuid": "e8947.3",
            "source_info": {
                "paper_title": "SelfCheckGPT: Zero-Resource Black-Box Hallucination Detection for Generative Large Language Models",
                "publication_date_yy_mm": "2023-03"
            }
        },
        {
            "name_short": "Self-consistency (Wang et al.)",
            "name_full": "Self-consistency decoding for chain-of-thought reasoning",
            "brief_description": "Prior work that performs multiple stochastic decodings (e.g., of chain-of-thought reasoning paths) and aggregates answers (often via majority vote) to improve reasoning accuracy; cited in the paper as relevant to sampling/self-consistency ideas.",
            "citation_title": "Self-consistency improves chain of thought reasoning in language models.",
            "mention_or_use": "mention",
            "model_name": null,
            "model_description": null,
            "reflection_method_name": "Self-consistency (aggregate multiple reasoning traces)",
            "reflection_method_description": "Generate multiple chain-of-thought (CoT) reasoning samples via stochastic decoding and aggregate final answers (e.g., majority voting) to yield more accurate answers than a single deterministic CoT.",
            "task_name": null,
            "task_description": null,
            "performance_with_reflection": null,
            "performance_without_reflection": null,
            "has_performance_comparison": false,
            "mechanism_of_reflection": "Sampling-based aggregation of multiple reasoning traces; not implemented in this paper but referenced in background as related to sampling/self-consistency.",
            "number_of_iterations": null,
            "evidence_for_improvement": "Cited as evidence that sampling/self-consistency can improve performance on complex reasoning tasks (reference only; no new experiments in this paper).",
            "limitations_or_failure_cases": "Not discussed in this paper beyond being cited; known limitations (from original work) include computation cost and dependence on CoT-capable models, but those details are not analyzed here.",
            "comparison_to_other_methods": "Mentioned in relation to chain-of-thought improvements; no direct comparison in this paper.",
            "ablation_study_results": null,
            "uuid": "e8947.4",
            "source_info": {
                "paper_title": "SelfCheckGPT: Zero-Resource Black-Box Hallucination Detection for Generative Large Language Models",
                "publication_date_yy_mm": "2023-03"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Self-consistency improves chain of thought reasoning in language models",
            "rating": 2
        },
        {
            "paper_title": "Language models (mostly) know what they know.",
            "rating": 2
        },
        {
            "paper_title": "The internal state of an llm knows when its lying",
            "rating": 2
        },
        {
            "paper_title": "MQAG: Multiple-choice question answering and generation for assessing information consistency in summarization",
            "rating": 2
        },
        {
            "paper_title": "Chatgpt as a factual inconsistency evaluator for abstractive text summarization",
            "rating": 1
        }
    ],
    "cost": 0.01691825,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>SelfCheckGPT: Zero-Resource Black-Box Hallucination Detection for Generative Large Language Models</h1>
<p>Potsawee Manakul, Adian Liusie, Mark J. F. Gales<br>ALTA Institute, Department of Engineering, University of Cambridge<br>pm574@cam.ac.uk, al826@cam.ac.uk, mjfg@eng.cam.ac.uk</p>
<h4>Abstract</h4>
<p>Generative Large Language Models (LLMs) such as GPT-3 are capable of generating highly fluent responses to a wide variety of user prompts. However, LLMs are known to hallucinate facts and make non-factual statements which can undermine trust in their output. Existing fact-checking approaches either require access to the output probability distribution (which may not be available for systems such as ChatGPT) or external databases that are interfaced via separate, often complex, modules. In this work, we propose "SelfCheckGPT", a simple sampling-based approach that can be used to fact-check the responses of black-box models in a zero-resource fashion, i.e. without an external database. SelfCheckGPT leverages the simple idea that if an LLM has knowledge of a given concept, sampled responses are likely to be similar and contain consistent facts. However, for hallucinated facts, stochastically sampled responses are likely to diverge and contradict one another. We investigate this approach by using GPT-3 to generate passages about individuals from the WikiBio dataset, and manually annotate the factuality of the generated passages. We demonstrate that SelfCheckGPT can: i) detect non-factual and factual sentences; and ii) rank passages in terms of factuality. We compare our approach to several baselines and show that our approach has considerably higher AUC-PR scores in sentence-level hallucination detection and higher correlation scores in passage-level factuality assessment compared to grey-box methods. ${ }^{1}$</p>
<h2>1 Introduction</h2>
<p>Large Language Models (LLMs) such as GPT-3 (Brown et al., 2020) and PaLM (Chowdhery et al., 2022) are capable of generating fluent and realistic responses to a variety of user prompts. They have been used in many applications such as automatic</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: SelfCheckGPT with Prompt. Each LLM-generated sentence is compared against stochastically generated responses with no external database. A comparison method can be, for example, through LLM prompting as shown above.
tools to draft reports, virtual assistants and summarization systems. Despite the convincing and realistic nature of LLM-generated texts, a growing concern with LLMs is their tendency to hallucinate facts. It has been widely observed that models can confidently generate fictitious information, and worryingly there are few, if any, existing approaches to suitably identify LLM hallucinations.</p>
<p>A possible approach of hallucination detection is to leverage existing intrinsic uncertainty metrics to determine the parts of the output sequence that the system is least certain of (Yuan et al., 2021; Fu et al., 2023). However, uncertainty metrics such as token probability or entropy require access to token-level probability distributions, information which may not be available to users for example when systems are accessed through limited external APIs. An alternate approach is to leverage fact-verification approaches, where evidence is retrieved from an external database to assess the veracity of a claim (Thorne et al., 2018; Guo et al., 2022). However, facts can only be assessed relative to the knowledge present in the database. Addition-</p>
<p>ally, hallucinations are observed over a wide range of tasks beyond pure fact verification (Kryscinski et al., 2020; Maynez et al., 2020).</p>
<p>In this paper, we propose SelfCheckGPT, a sampling-based approach that can detect whether responses generated by LLMs are hallucinated or factual. To the best of our knowledge, SelfCheckGPT is the first work to analyze model hallucination of general LLM responses, and is the first zero-resource hallucination detection solution that can be applied to black-box systems. The motivating idea of SelfCheckGPT is that when an LLM has been trained on a given concept, the sampled responses are likely to be similar and contain consistent facts. However, for hallucinated facts, stochastically sampled responses are likely to diverge and may contradict one another. By sampling multiple responses from an LLM, one can measure information consistency between the different responses and determine if statements are factual or hallucinated. Since SelfCheckGPT only leverages sampled responses, it has the added benefit that it can be used for black-box models, and it requires no external database. Five variants of SelfCheckGPT for measuring informational consistency are considered: BERTScore, question-answering, $n$-gram, NLI, and LLM prompting. Through analysis of annotated articles generated by GPT-3, we show that SelfCheckGPT is a highly effective hallucination detection method that can even outperform greybox methods, and serves as a strong first baseline for an increasingly important problem of LLMs.</p>
<h2>2 Background and Related Work</h2>
<h3>2.1 Hallucination of Large Language Models</h3>
<p>Hallucination has been studied in text generation tasks, including summarization (Huang et al., 2021) and dialogue generation (Shuster et al., 2021), as well as in a variety of other natural language generation tasks (Ji et al., 2023). Self-consistency decoding has shown to improve chain-of-thought prompting performance on complex reasoning tasks (Wang et al., 2023). Further, Liu et al. (2022) introduce a hallucination detection dataset, however, texts are obtained by perturbing factual texts and thus may not reflect true LLM hallucination.</p>
<p>Recently, Azaria and Mitchell (2023) trained a multi-layer perception classifier where an LLM's hidden representations are used as inputs to predict the truthfulness of a sentence. However, this approach is a white-box approach that uses the internal states of the LLM, which may not be available through API calls, and requires labelled data for supervised training. Another recent approach is self-evaluation (Kadavath et al., 2022), where an LLM is prompted to evaluate its previous prediction, e.g., to predict the probability that its generated response/answer is true.</p>
<h3>2.2 Sequence Level Uncertainty Estimation</h3>
<p>Token probabilities have been used as an indication of model certainty. For example, OpenAI's GPT-3 web interface allows users to display token probabilities (as shown in Figure 2), and further uncertainty estimation approaches based on aleatoric and epistemic uncertainty have been studied for autoregressive generation (Xiao and Wang, 2021; Malinin and Gales, 2021). Additionally, conditional language model scores have been used to evaluate properties of texts (Yuan et al., 2021; Fu et al., 2023). Recently, semantic uncertainty has been proposed to address uncertainty in free-form generation tasks where probabilities are attached to concepts instead of tokens (Kuhn et al., 2023).</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: Example of OpenAI's GPT-3 web interface with output token-level probabilities displayed.</p>
<h3>2.3 Fact Verification</h3>
<p>Existing fact-verification approaches follow a multi-stage pipeline of claim detection, evidence retrieval and verdict prediction (Guo et al., 2022; Zhong et al., 2020). Such methods, however, require access to external databases and can have considerable inference costs.</p>
<h2>3 Grey-Box Factuality Assessment</h2>
<p>This section will introduce methods that can be used to determine the factuality of LLM responses in a zero-resource setting when one has full access</p>
<p>to output distributions. ${ }^{2}$ We will use 'factual' to define when statements are grounded in valid information, i.e. when hallucinations are avoided, and 'zero-resource' when no external database is used.</p>
<h3>3.1 Uncertainty-based Assessment</h3>
<p>To understand how the factuality of a generated response can be determined in a zero-resource setting, we consider LLM pre-training. During pretraining, the model is trained with next-word prediction over massive corpora of textual data. This gives the model a strong understanding of language (Jawahar et al., 2019; Raffel et al., 2020), powerful contextual reasoning (Zhang et al., 2020), as well as world knowledge (Liusie et al., 2023). Consider the input "Lionel Messi is a <em>". Since Messi is a world-famous athlete who may have appeared multiple times in pre-training, the LLM is likely to know who Messi is. Therefore given the context, the token "footballer" may be assigned a high probability while other professions such as "carpenter" may be considered improbable. However, for a different input such as "John Smith is a </em>", the system will be unsure of the continuation which may result in a flat probability distribution. During inference, this is likely to lead to a non-factual word being generated.</p>
<p>This insight allows us to understand the connection between uncertainty metrics and factuality. Factual sentences are likely to contain tokens with higher likelihood and lower entropy, while hallucinations are likely to come from positions with flat probability distributions with high uncertainty.</p>
<h2>Token-level Probability</h2>
<p>Given the LLM's response $R$, let $i$ denote the $i$-th sentence in $R, j$ denote the $j$-th token in the $i$-th sentence, $J$ is the number of tokens in the sentence, and $p_{i j}$ be the probability of the word generated by the LLM at the $j$-th token of the $i$-th sentence. Two probability metrics are used:</p>
<p>$$
\begin{aligned}
&amp; \operatorname{Avg}(-\log p)=-\frac{1}{J} \sum_{j} \log p_{i j} \
&amp; \operatorname{Max}(-\log p)=\max <em i="i" j="j">{j}\left(-\log p</em>\right)
\end{aligned}
$$</p>
<p>$\operatorname{Max}(-\log p)$ measures the sentence's likelihood by assessing the least likely token in the sentence.</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<h2>Entropy</h2>
<p>The entropy of the output distribution is:</p>
<p>$$
\mathcal{H}<em _hat_w="\hat{w">{i j}=-\sum</em>)
$$} \in \mathcal{W}} p_{i j}(\hat{w}) \log p_{i j}(\hat{w</p>
<p>where $p_{i j}(\hat{w})$ is the probability of the word $\hat{w}$ being generated at the $j$-th token of the $i$-th sentence, and $\mathcal{W}$ is the set of all possible words in the vocabulary. Similar to the probability-based metrics, two entropy-based metrics are used:</p>
<p>$$
\operatorname{Avg}(\mathcal{H})=\frac{1}{J} \sum_{j} \mathcal{H}<em j="j">{i j} ; \quad \operatorname{Max}(\mathcal{H})=\max </em>\right)
$$}\left(\mathcal{H}_{i j</p>
<h2>4 Black-Box Factuality Assessment</h2>
<p>A drawback of grey-box methods is that they require output token-level probabilities. Though this may seem a reasonable requirement, for massive LLMs only available through limited API calls, such token-level information may not be available (such as with ChatGPT). Therefore, we consider black-box approaches which remain applicable even when only text-based responses are available.</p>
<h2>Proxy LLMs</h2>
<p>A simple approach to approximate the grey-box approaches is by using a proxy LLM, i.e. another LLM that we have full access to, such as LLaMA (Touvron et al., 2023). A proxy LLM can be used to approximate the output token-level probabilities of the black-box LLM generating the text. In the next section, we propose SelfCheckGPT, which is also a black-box approach.</p>
<h2>5 SelfCheckGPT</h2>
<p>SelfCheckGPT is our proposed black-box zeroresource hallucination detection scheme, which operates by comparing multiple sampled responses and measuring consistency.</p>
<p>Notation: Let $R$ refer to an LLM response drawn from a given user query. SelfCheckGPT draws a further $N$ stochastic LLM response samples $\left{S^{1}, S^{2}, \ldots, S^{n}, \ldots, S^{N}\right}$ using the same query, and then measures the consistency between the response and the stochastic samples. We design SelfCheckGPT to predict the hallucination score of the $i$-th sentence, $\mathcal{S}(i)$, such that $\mathcal{S}(i) \in[0.0,1.0]$, where $\mathcal{S}(i) \rightarrow 0.0$ if the $i$-th sentence is grounded in valid information and $\mathcal{S}(i) \rightarrow 1.0$ if the $i$-th sen-</p>
<p>tence is hallucinated. ${ }^{3}$ The following subsections will describe each of the SelfCheckGPT variants.</p>
<h3>5.1 SelfCheckGPT with BERTScore</h3>
<p>Let $\mathcal{B}(.,$.$) denote the BERTScore between two$ sentences. SelfCheckGPT with BERTScore finds the average BERTScore of the $i$-th sentence with the most similar sentence from each drawn sample:</p>
<p>$$
\mathcal{S}<em n="1">{\text {BERT }}(i)=1-\frac{1}{N} \sum</em> \max }^{N<em i="i">{k}\left(\mathcal{B}\left(r</em>\right)\right)
$$}, s_{k}^{n</p>
<p>where $r_{i}$ represents the $i$-th sentence in $R$ and $s_{k}^{n}$ represents the $k$-th sentence in the $n$-th sample $S^{n}$. This way if the information in a sentence appears in many drawn samples, one may assume that the information is factual, whereas if the statement appears in no other sample, it is likely a hallucination. In this work, RoBERTa-Large (Liu et al., 2019) is used as the backbone of BERTScore.</p>
<h3>5.2 SelfCheckGPT with Question Answering</h3>
<p>We also consider using the automatic multiplechoice question answering generation (MQAG) framework (Manakul et al., 2023) to measure consistency for SelfCheckGPT. MQAG assesses consistency by generating multiple-choice questions over the main generated response, which an independent answering system can attempt to answer while conditioned on the other sampled responses. If questions on consistent information are queried, the answering system is expected to predict similar answers. MQAG consists of two stages: question generation $G$ and question answering $A$. For the sentence $r_{i}$ in the response $R$, we draw questions $q$ and options o:</p>
<p>$$
q, \mathbf{o} \sim P_{\mathrm{G}}\left(q, \mathbf{o} \mid r_{i}, R\right)
$$</p>
<p>The answering stage A selects the answers:</p>
<p>$$
\begin{aligned}
a_{R} &amp; =\underset{k}{\operatorname{argmax}}\left[P_{\mathrm{A}}\left(o_{k} \mid q, R, \mathbf{o}\right)\right] \
a_{S^{n}} &amp; =\underset{k}{\operatorname{argmax}}\left[P_{\mathrm{A}}\left(o_{k} \mid q, S^{n}, \mathbf{o}\right)\right]
\end{aligned}
$$</p>
<p>We compare whether $a_{R}$ is equal to $a_{S^{n}}$ for each sample in $\left{S^{1}, \ldots, S^{N}\right}$, yielding #matches $N_{\mathrm{n}}$ and #not-matches $N_{\mathrm{n}}$. A simple inconsistency score for the $i$-th sentence and question $q$ based on the match/not-match counts is defined: $\mathcal{S}_{\mathrm{QA}}(i, q)=$</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup>$\frac{N_{\mathrm{n}}}{N_{\mathrm{n}}+N_{\mathrm{n}}}$. To take into account the answerability of generated questions, we show in Appendix B that we can modify the inconsistency score by applying soft-counting, resulting in:</p>
<p>$$
\mathcal{S}<em 2="2">{\mathrm{QA}}(i, q)=\frac{\gamma</em>
$$}^{N_{\mathrm{n}}^{\prime}}}{\gamma_{1}^{N_{\mathrm{n}}^{\prime}}+\gamma_{2}^{N_{\mathrm{n}}^{\prime}}</p>
<p>where $N_{\mathrm{n}}^{\prime}=$ the effective match count, $N_{\mathrm{n}}^{\prime}=$ the effective mismatch count, with $\gamma_{1}$ and $\gamma_{2}$ defined in Appendix B.1. Ultimately, SelfCheckGPT with QA is the average of inconsistency scores across $q$,</p>
<p>$$
\mathcal{S}<em q="q">{\mathrm{QA}}(i)=\mathbb{E}</em>(i, q)]
$$}[\mathcal{S}_{\mathrm{QA}</p>
<h3>5.3 SelfCheckGPT with n-gram</h3>
<p>Given samples $\left{S^{1}, \ldots, S^{N}\right}$ generated by an LLM, one can use the samples to create a new language model that approximates the LLM. In the limit as $N$ gets sufficiently large, the new language model will converge to the LLM that generated the responses. We can therefore approximate the LLM's token probabilities using the new language model.</p>
<p>In practice, due to time and/or cost constraints, there can only be a limited number of samples $N$. Consequently, we train a simple $n$-gram model using the samples $\left{S^{1}, \ldots, S^{N}\right}$ as well as the main response $R$ (which is assessed), where we note that including $R$ can be considered as a smoothing method where the count of each token in $R$ is increased by 1 . We then compute the average of the log-probabilities of the sentence in response $R$,</p>
<p>$$
\mathcal{S}<em j="j">{n \text {-gram }}^{\text {Avg }}(i)=-\frac{1}{J} \sum</em>
$$} \log \tilde{p}_{i j</p>
<p>where $\tilde{p}_{i j}$ is the probability (of the $j$-th token of the $i$-th sentence) computed using the $n$-gram model. Similar to the grey-box approach, we can also use the maximum of the negative log probabilities,</p>
<p>$$
\mathcal{S}<em j="j">{n \text {-gram }}^{\text {Max }}(i)=\max </em>\right)
$$}\left(-\log \tilde{p}_{i j</p>
<h3>5.4 SelfCheckGPT with NLI</h3>
<p>Natural Language Inference (NLI) determines whether a hypothesis follows a premise, classified into either entailment/neutral/contradiction. NLI measures have been used to measure faithfulness in summarization, where Maynez et al. (2020) use a textual entailment classifier trained on MNLI (Williams et al., 2018) to determine if a summary contradicts a context or not. Inspired by NLI-based</p>
<p>summary assessment, we consider using the NLI contradiction score as a SelfCheckGPT score.</p>
<p>For SelfCheck-NLI, we use DeBERTa-v3-large (He et al., 2023) fine-tuned to MNLI as the NLI model. The input for NLI classifiers is typically the premise concatenated to the hypothesis, which for our methodology is the sampled passage $S^{n}$ concatenated to the sentence to be assessed $r_{i}$. Only the logits associated with the 'entailment' and 'contradiction' classes are considered,</p>
<p>$$
P\left(\operatorname{contradict} \mid r_{i}, S^{n}\right)=\frac{\exp \left(z_{c}\right)}{\exp \left(z_{e}\right)+\exp \left(z_{c}\right)}
$$</p>
<p>where $z_{e}$ and $z_{c}$ are the logits of the 'entailment' and 'contradiction' classes, respectively. This normalization ignores the neutral class and ensures that the probability is bounded between 0.0 and 1.0. The SelfCheckGPT with NLI score for each sample $S^{n}$ is then defined as,</p>
<p>$$
\mathcal{S}<em n="1">{\mathrm{NLI}}(i)=\frac{1}{N} \sum</em>\right)
$$}^{N} P\left(\operatorname{contradict} \mid r_{i}, S^{n</p>
<h3>5.5 SelfCheckGPT with Prompt</h3>
<p>LLMs have recently been shown to be effective in assessing information consistency between a document and its summary in zero-shot settings (Luo et al., 2023). Thus, we query an LLM to assess whether the $i$-th sentence is supported by sample $S^{n}$ (as the context) using the following prompt.</p>
<div class="codehilite"><pre><span></span><code>Context: {}
Sentence: {}
Is the sentence supported by the context above?
Answer Yes or No:
</code></pre></div>

<p>Initial investigation showed that GPT-3 (text-davinci-003) will output either Yes or No $98 \%$ of the time, while any remaining outputs can be set to N/A. The output from prompting when comparing the $i$-th sentence against sample $S^{n}$ is converted to score $x_{i}^{n}$ through the mapping {Yes: 0.0, No: 1.0, N/A: 0.5 }. The final inconsistency score is then calculated as:</p>
<p>$$
\mathcal{S}<em n="1">{\text {Prompt }}(i)=\frac{1}{N} \sum</em>
$$}^{N} x_{i}^{n</p>
<p>SelfCheckGPT-Prompt is illustrated in Figure 1. Note that our initial investigations found that less capable models such as GPT-3 (text-curie-001) or LLaMA failed to effectively perform consistency assessment via such prompting.</p>
<h2>6 Data and Annotation</h2>
<p>As, currently, there are no standard hallucination detection datasets available, we evaluate our hallucination detection approaches by 1) generating synthetic Wikipedia articles using GPT-3 on the individuals/concepts from the WikiBio dataset (Lebret et al., 2016); 2) manually annotating the factuality of the passage at a sentence level; 3) evaluating the system's ability to detect hallucinations.</p>
<p>WikiBio is a dataset where each input contains the first paragraph (along with tabular information) of Wikipedia articles of a specific concept. We rank the WikiBio test set in terms of paragraph length and randomly sample 238 articles from the top $20 \%$ of longest articles (to ensure no very obscure concept is selected). GPT-3 (text-davinci-003) is then used to generate Wikipedia articles on a concept, using the prompt "This is a Wikipedia passage about {concept}". Table 1 provides the statistics of GPT-3 generated passages.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">#Passages</th>
<th style="text-align: center;">#Sentences</th>
<th style="text-align: center;">#Tokens/passage</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">238</td>
<td style="text-align: center;">1908</td>
<td style="text-align: center;">$184.7 \pm 36.9$</td>
</tr>
</tbody>
</table>
<p>Table 1: The statistics of WikiBio GPT-3 dataset where the number of tokens is based on the OpenAI GPT-2 tokenizer.</p>
<p>We then annotate the sentences of the generated passages using the guidelines shown in Figure 3 such that each sentence is classified as either:</p>
<ul>
<li>Major Inaccurate (Non-Factual, 1): The sentence is entirely hallucinated, i.e. the sentence is unrelated to the topic.</li>
<li>Minor Inaccurate (Non-Factual, 0.5): The sentence consists of some non-factual information, but the sentence is related to the topic.</li>
<li>Accurate (Factual, 0): The information presented in the sentence is accurate.</li>
</ul>
<p>Of the 1908 annotated sentences, 761 (39.9\%) of the sentences were labelled major-inaccurate, 631 (33.1\%) minor-inaccurate, and 516 (27.0\%) accurate. 201 sentences in the dataset had annotations from two different annotators. To obtain a single label for this subset, if both annotators agree, then the agreed label is used. However, if there is disagreement, then the worse-case label is selected (e.g., {minor inaccurate, major inaccurate} is mapped to major inaccurate). The inter-annotator agreement, as measured by Cohen's $\kappa$ (Cohen, 1960), has $\kappa$</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: Flowchart of our annotation process
values of 0.595 and 0.748 , indicating moderate and substantial agreement (Viera et al., 2005) for the 3-class and 2-class scenarios, respectively. ${ }^{4}$</p>
<p>Furthermore, passage-level scores are obtained by averaging the sentence-level labels in each passage. The distribution of passage-level scores is shown in Figure 4, where we observe a large peak at +1.0 . We refer to the points at this peak as total hallucination, which occurs when the information of the response is unrelated to the real concept and is entirely fabricated by the LLM.
<img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 4: Document factuality scores histogram plot</p>
<h2>7 Experiments</h2>
<p>The generative LLM used to generate passages for our dataset is GPT-3 (text-davinci-003), the state-of-the-art system at the time of creating and annotating the dataset. To obtain the main response, we set the temperature to 0.0 and use standard beam search decoding. For the stochastically generated samples, we set the temperature to 1.0 and generate</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup>$N=20$ samples. For the proxy LLM approach, we use LLaMA (Touvron et al., 2023), one of the bestperforming open-source LLMs currently available. For SelfCheckGPT-Prompt, we consider both GPT3 (which is the same LLM that is used to generate passages) as well as the newly released ChatGPT (gpt-3.5-turbo). More details about the systems in SelfCheckGPT and results using other proxy LLMs can be found in the appendix.</p>
<h3>7.1 Sentence-level Hallucination Detection</h3>
<p>First, we investigate whether our hallucination detection methods can identify the factuality of sentences. In detecting non-factual sentences, both major-inaccurate labels and minor-inaccurate labels are grouped together into the non-factual class, while the factual class refers to accurate sentences. In addition, we consider a more challenging task of detecting major-inaccurate sentences in passages that are not total hallucination passages, which we refer to as non-factual ${ }^{5}$. Figure 5 and Table 2 show the performance of our approaches, where the following observations can be made:</p>
<p>1) LLM's probabilities $p$ correlate well with factuality. Our results show that probability measures (from the LLM generating the texts) are strong baselines for assessing factuality. Factual sentences can be identified with an AUC-PR of 53.97, significantly better than the random baseline of 27.04 , with the AUC-PR for hallucination detection also increasing from 72.96 to 83.21 . This supports the hypothesis that when the LLMs are uncertain about generated information, generated tokens often have higher uncertainty, paving a promising direction for hallucination detection approaches. Also, the probability $p$ measure performs better than the entropy $\mathcal{H}$ measure of top- 5 tokens.
2) Proxy LLM perform noticeably worse than LLM (GPT-3). The results of proxy LLM (based on LLaMA) show that the entropy $\mathcal{H}$ measures outperform the probability measures. This suggests that using richer uncertainty information can improve factuality/hallucination detection performance, and that previously the entropy of top- 5 tokens is likely to be insufficient. In addition, when using other proxy LLMs such as GPT-NeoX or OPT-30B, the performance is near that of the random baseline. We believe this poor performance occurs as different LLMs have different generating patterns, and so even common tokens may have a</p>
<p><sup id="fnref:1"><a class="footnote-ref" href="#fn:1">2</a></sup></p>
<p><img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 5: PR-Curve of detecting non-factual and factual sentences in the GPT-3 generated WikiBio passages.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Sentence-level (AUC-PR)</th>
<th></th>
<th></th>
<th>Passage-level (Corr.)</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>NonFact</td>
<td>NonFact*</td>
<td>Factual</td>
<td>Pearson</td>
<td>Spearman</td>
</tr>
<tr>
<td>Random</td>
<td>72.96</td>
<td>29.72</td>
<td>27.04</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>GPT-3 (text-davinci-003)'s probabilities (LLM, grey-box)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Avg(-logp)</td>
<td>83.21</td>
<td>38.89</td>
<td>53.97</td>
<td>57.04</td>
<td>53.93</td>
</tr>
<tr>
<td>Avg(H)â€ </td>
<td>80.73</td>
<td>37.09</td>
<td>52.07</td>
<td>55.52</td>
<td>50.87</td>
</tr>
<tr>
<td>Max(-logp)</td>
<td>87.51</td>
<td>35.88</td>
<td>50.46</td>
<td>57.83</td>
<td>55.69</td>
</tr>
<tr>
<td>Max(H)â€ </td>
<td>85.75</td>
<td>32.43</td>
<td>50.27</td>
<td>52.48</td>
<td>49.55</td>
</tr>
<tr>
<td>LLaMA-30B's probabilities (Proxy LLM, black-box)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Avg(-logp)</td>
<td>75.43</td>
<td>30.32</td>
<td>41.29</td>
<td>21.72</td>
<td>20.20</td>
</tr>
<tr>
<td>Avg(H)</td>
<td>80.80</td>
<td>39.01</td>
<td>42.97</td>
<td>33.80</td>
<td>39.49</td>
</tr>
<tr>
<td>Max(-logp)</td>
<td>74.01</td>
<td>27.14</td>
<td>31.08</td>
<td>-22.83</td>
<td>-22.71</td>
</tr>
<tr>
<td>Max(H)</td>
<td>80.92</td>
<td>37.32</td>
<td>37.90</td>
<td>35.57</td>
<td>38.94</td>
</tr>
<tr>
<td>SelfCheckGPT (black-box)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>w/ BERTScore</td>
<td>81.96</td>
<td>45.96</td>
<td>44.23</td>
<td>58.18</td>
<td>55.90</td>
</tr>
<tr>
<td>w/ QA</td>
<td>84.26</td>
<td>40.06</td>
<td>48.14</td>
<td>61.07</td>
<td>59.29</td>
</tr>
<tr>
<td>w/ Unigram (max)</td>
<td>85.63</td>
<td>41.04</td>
<td>58.47</td>
<td>64.71</td>
<td>64.91</td>
</tr>
<tr>
<td>w/ NLI</td>
<td>92.50</td>
<td>45.17</td>
<td>66.08</td>
<td>74.14</td>
<td>73.78</td>
</tr>
<tr>
<td>w/ Prompt</td>
<td>93.42</td>
<td>53.19</td>
<td>67.09</td>
<td>78.32</td>
<td>78.30</td>
</tr>
</tbody>
</table>
<p>Table 2: AUC-PR for sentence-level detection tasks. Passage-level ranking performances are measured by Pearson correlation coefficient and Spearman's rank correlation coefficient w.r.t. human judgements. The results of other proxy LLMs, in addition to LLaMA, can be found in the appendix. â€ GPT-3 API returns the top-5 tokens' probabilities, which are used to compute entropy.</p>
<p>low probability in situations where the response is dissimilar to the generation style of the proxy LLM. We note that a weighted conditional LM score such as BARTScore (Yuan et al., 2021) could be incorporated in future investigations.</p>
<p>3) SelfCheckGPT outperforms grey-box approaches. It can be seen that SelfCheckGPT-Prompt considerably outperforms the grey-box approaches (including GPT-3's output probabilities) as well as other black-box approaches. Even other variants of SelfCheckGPT, including BERTScore, QA, and n-gram, outperform the grey-box approaches in most setups. Interestingly, despite being the least computationally expensive method, SelfCheckGPT with unigram (max) works well across different setups. Essentially, when assessing a sentence, this method picks up the token with the lowest occurrence given all the samples. This suggests that if a token only appears a few times (or once) within the generated samples (N=20), it is likely non-factual.</p>
<p>4) SelfCheckGPT with n-gram. When inves-tigating the n-gram performance from 1-gram to 5-gram, the results show that simply finding the least likely token/n-gram is more effective than computing the average n-gram score of the sen-tence, details in appendix Table 7. Additionally, as n increases, the performance of SelfCheckGPT with n-gram (max) drops.</p>
<p>5) SelfCheckGPT with NLI. The NLI-based</p>
<p><img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>Figure 6: Scatter plot of passage-level scores where Y-axis = Method scores, X-axis = Human scores. Correlations are reported in Table 2. The scatter plots of other SelfCheckGPT variants are provided in Figure 10 in the appendix.</p>
<p>method outperforms all black-box and grey-box baselines, and its performance is close to the performance of the Prompt method. As SelfCheckGPT with Prompt can be computationally heavy, SelfCheckGPT with NLI could be the most practical method as it provides a good trade-off between performance and computation.</p>
<h3>7.2 Passage-level Factuality Ranking</h3>
<p>Previous results demonstrate that SelfCheckGPT is an effective approach for predicting sentence-level factuality. An additional consideration is whether SelfCheckGPT can also be used to determine the overall factuality of passages. Passage-level factuality scores are calculated by averaging the sentence-level scores over all sentences.</p>
<p>$$
\mathcal{S}<em i="i">{\text{passage}} = \frac{1}{|R|} \sum</em>
$$} \mathcal{S}(i) \tag{12</p>
<p>where $\mathcal{S}(i)$ is the sentence-level score, and $|R|$ is the number of sentences in the passage. Since human judgement is somewhat subjective, averaging the sentence-level labels would lead to ground truths with less noise. Note that for Avg(- log p) and Avg(H), we compute the average over all tokens in a passage. Whereas for Max(- log p) and Max(H), we first take the maximum operation over tokens at the sentence level, and we then average over all sentences following Equation 12.</p>
<p>Our results in Table 2 and Figure 6 show that all SelfCheckGPT methods correlate far better with human judgements than the other baselines, including the grey-box probability and entropy methods. SelfCheckGPT-Prompt is the best-performing method, achieving the highest Pearson correlation of 78.32. Unsurprisingly, the proxy LLM approach again achieves considerably lower correlations.</p>
<h3>7.3 Ablation Studies</h3>
<h4>External Knowledge (instead of SelfCheck)</h4>
<p>If external knowledge is available, one can measure the informational consistency between the LLM response and the information source. In this experiment, we use the first paragraph of each concept that is available in WikiBio.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Sent-lvl</th>
<th></th>
<th></th>
<th>Passage-lvl</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>NoFac</td>
<td>NoFac*</td>
<td>Fact</td>
<td>Pear.</td>
<td>Spear.</td>
</tr>
<tr>
<td>SelfCk-BERT</td>
<td>81.96</td>
<td>45.96</td>
<td>44.23</td>
<td>58.18</td>
<td>55.90</td>
</tr>
<tr>
<td>WikiBio+BERT</td>
<td>81.32</td>
<td>40.62</td>
<td>49.15</td>
<td>58.71</td>
<td>55.80</td>
</tr>
<tr>
<td>SelfCk-QA</td>
<td>84.26</td>
<td>40.06</td>
<td>48.14</td>
<td>61.07</td>
<td>59.29</td>
</tr>
<tr>
<td>WikiBio+QA</td>
<td>84.18</td>
<td>45.40</td>
<td>52.03</td>
<td>57.26</td>
<td>53.62</td>
</tr>
<tr>
<td>SelfCk-1gm</td>
<td>85.63</td>
<td>41.04</td>
<td>58.47</td>
<td>64.71</td>
<td>64.91</td>
</tr>
<tr>
<td>WikiBio+1gm</td>
<td>80.43</td>
<td>31.47</td>
<td>40.53</td>
<td>28.67</td>
<td>26.70</td>
</tr>
<tr>
<td>SelfCk-NLI</td>
<td>92.50</td>
<td>45.17</td>
<td>66.08</td>
<td>74.14</td>
<td>73.78</td>
</tr>
<tr>
<td>WikiBio+NLI</td>
<td>91.18</td>
<td>48.14</td>
<td>71.61</td>
<td>78.84</td>
<td>80.00</td>
</tr>
<tr>
<td>SelfCk-Prompt</td>
<td>93.42</td>
<td>53.19</td>
<td>67.09</td>
<td>78.32</td>
<td>78.30</td>
</tr>
<tr>
<td>WikiBio+Prompt</td>
<td>93.59</td>
<td>65.26</td>
<td>73.11</td>
<td>85.90</td>
<td>86.11</td>
</tr>
</tbody>
</table>
<p>Table 3: The performance when using SelfCheckGPT samples versus external stored knowledge.</p>
<p>Our findings in Table 3 show the following. First, SelfCheckGPT with BERTScore/QA, using self-samples, can yield comparable or even better performance than when using the reference passage. Second, SelfCheckGPT with n-gram shows a large performance drop when using the WikiBio passages instead of self-samples. This failure is attributed to the fact that the WikiBio reference text alone is not sufficient to train an n-gram model. Third, in contrast, SelfCheckGPT with NLI/Prompt can benefit considerably when access to retrieved information is available. Nevertheless, in practice,</p>
<p>^{6}This method is no longer zero-resource as it requires retrieving relevant knowledge from external data.</p>
<p>it is infeasible to have an external database for every possible use case of LLM generation.</p>
<h2>The Impact of the Number of Samples</h2>
<p>Although sample-based methods are expected to perform better when more samples are drawn, this has higher computational costs. Thus, we investigate performance as the number of samples is varied. Our results in Figure 7 show that the performance of SelfCheckGPT increases smoothly as more samples are used, with diminishing gains as more samples are generated. SelfCheckGPT with $n$-gram requires the highest number of samples before its performance reaches a plateau.
<img alt="img-6.jpeg" src="img-6.jpeg" /></p>
<p>Figure 7: The performance of SelfCheckGPT methods on ranking passages (Spearman's) versus the number of samples.</p>
<h2>The Choice of LLM for SelfCheckGPT-Prompt</h2>
<p>We investigate whether the LLM generating the text can self-check its own text. We conduct this ablation using a reduced set of the samples $(N=4)$.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Text-Gen</th>
<th style="text-align: left;">SelfCk-Prompt</th>
<th style="text-align: right;">$N$</th>
<th style="text-align: left;">Pear.</th>
<th style="text-align: left;">Spear.</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">GPT-3</td>
<td style="text-align: left;">ChatGPT</td>
<td style="text-align: right;">20</td>
<td style="text-align: left;">78.32</td>
<td style="text-align: left;">78.30</td>
</tr>
<tr>
<td style="text-align: left;">GPT-3</td>
<td style="text-align: left;">ChatGPT</td>
<td style="text-align: right;">4</td>
<td style="text-align: left;">76.47</td>
<td style="text-align: left;">76.41</td>
</tr>
<tr>
<td style="text-align: left;">GPT-3</td>
<td style="text-align: left;">GPT-3</td>
<td style="text-align: right;">4</td>
<td style="text-align: left;">73.11</td>
<td style="text-align: left;">74.69</td>
</tr>
<tr>
<td style="text-align: left;">${ }^{\dagger}$ SelfCheck w/ unigram (max)</td>
<td style="text-align: left;">20</td>
<td style="text-align: right;">64.71</td>
<td style="text-align: left;">64.91</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">${ }^{\dagger}$ SelfCheck w/ NLI</td>
<td style="text-align: left;">20</td>
<td style="text-align: right;">74.14</td>
<td style="text-align: left;">73.78</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<p>Table 4: Comparison of GPT-3 (text-davinci-003) and ChatGPT (gpt-3.5.turbo) as the prompt-based text evaluator in SelfCheckGPT-Prompt. ${ }^{\dagger}$ Taken from Table 2 for comparison.</p>
<p>The results in Table 4 show that GPT-3 can selfcheck its own text, and is better than the unigram method even when using only 4 samples. However, ChatGPT shows a slight improvement over GPT-3 in evaluating whether the sentence is supported by the context. More details are in Appendix C.</p>
<h2>8 Conclusions</h2>
<p>This paper is the first work to consider the task of hallucination detection for general large language model responses. We propose SelfCheckGPT, a zero-resource approach that is applicable to any black-box LLM without the need for external resources, and demonstrate the efficacy of our method. SelfCheckGPT outperforms a range of considered grey-box and black-box baseline detection methods at both the sentence and passage levels, and we further release an annotated dataset for GPT-3 hallucination detection with sentencelevel factuality labels.</p>
<h2>Limitations</h2>
<p>In this study, the 238 GPT-3 generated texts were predominantly passages about individuals in the WikiBio dataset. To further investigate the nature of LLM's hallucination, this study could be extended to a wider range of concepts, e.g., to also consider generated texts about locations and objects. Further, this work considers factuality at the sentence level, but we note that a single sentence may consist of both factual and non-factual information. For example, the following work by Min et al. (2023) considers a fine-grained factuality evaluation by decomposing sentences into atomic facts. Finally, SelfCheckGPT with Prompt, which was convincingly the best selfcheck method, is quite computationally heavy. This might lead to impractical computational costs, which could be addressed in future work to be made more efficient.</p>
<h2>Ethics Statement</h2>
<p>As this work addresses the issue of LLM's hallucination, we note that if hallucinated contents are not detected, they could lead to misinformation.</p>
<h2>Acknowledgments</h2>
<p>This work is supported by Cambridge University Press \&amp; Assessment (CUP\&amp;A), a department of The Chancellor, Masters, and Scholars of the University of Cambridge, and the Cambridge Commonwealth, European \&amp; International Trust. We would like to thank the anonymous reviewers for their helpful comments.</p>
<h2>References</h2>
<p>Amos Azaria and Tom Mitchell. 2023. The internal state of an llm knows when its lying. arXiv preprint arXiv:2304.13734.</p>
<p>Iz Beltagy, Matthew E. Peters, and Arman Cohan. 2020. Longformer: The long-document transformer.</p>
<p>Sidney Black, Stella Biderman, Eric Hallahan, Quentin Anthony, Leo Gao, Laurence Golding, Horace He, Connor Leahy, Kyle McDonell, Jason Phang, Michael Pieler, Usvsn Sai Prashanth, Shivanshu Purohit, Laria Reynolds, Jonathan Tow, Ben Wang, and Samuel Weinbach. 2022. GPT-NeoX-20B: An opensource autoregressive language model. In Proceedings of BigScience Episode #5 - Workshop on Challenges \&amp; Perspectives in Creating Large Language Models, pages 95-136, virtual+Dublin. Association for Computational Linguistics.</p>
<p>Tom Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared D Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, et al. 2020. Language models are few-shot learners. Advances in neural information processing systems, 33:1877-1901.</p>
<p>Aakanksha Chowdhery, Sharan Narang, Jacob Devlin, Maarten Bosma, Gaurav Mishra, Adam Roberts, Paul Barham, Hyung Won Chung, Charles Sutton, Sebastian Gehrmann, et al. 2022. Palm: Scaling language modeling with pathways. arXiv preprint arXiv:2204.02311.</p>
<p>Jacob Cohen. 1960. A coefficient of agreement for nominal scales. Educational and Psychological Measurement, 20:37 - 46.</p>
<p>Jinlan Fu, See-Kiong Ng, Zhengbao Jiang, and Pengfei Liu. 2023. Gptscore: Evaluate as you desire.</p>
<p>Zhijiang Guo, Michael Schlichtkrull, and Andreas Vlachos. 2022. A survey on automated fact-checking. Transactions of the Association for Computational Linguistics, 10:178-206.</p>
<p>Pengcheng He, Jianfeng Gao, and Weizhu Chen. 2023. DeBERTav3: Improving deBERTa using ELECTRAstyle pre-training with gradient-disentangled embedding sharing. In The Eleventh International Conference on Learning Representations.</p>
<p>Yichong Huang, Xiachong Feng, Xiaocheng Feng, and Bing Qin. 2021. The factual inconsistency problem in abstractive text summarization: A survey.</p>
<p>Ganesh Jawahar, BenoÃ®t Sagot, and DjamÃ© Seddah. 2019. What does BERT learn about the structure of language? In Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics, pages 3651-3657, Florence, Italy. Association for Computational Linguistics.</p>
<p>Ziwei Ji, Nayeon Lee, Rita Frieske, Tiezheng Yu, Dan Su, Yan Xu, Etsuko Ishii, Ye Jin Bang, Andrea</p>
<p>Madotto, and Pascale Fung. 2023. Survey of hallucination in natural language generation. ACM Comput. Surv., 55(12).</p>
<p>Saurav Kadavath, Tom Conerly, Amanda Askell, Tom Henighan, Dawn Drain, Ethan Perez, Nicholas Schiefer, Zac Hatfield Dodds, Nova DasSarma, Eli Tran-Johnson, et al. 2022. Language models (mostly) know what they know. arXiv preprint arXiv:2207.05221.</p>
<p>Wojciech Kryscinski, Bryan McCann, Caiming Xiong, and Richard Socher. 2020. Evaluating the factual consistency of abstractive text summarization. In Proceedings of the 2020 Conference on Empirical Methods in Natural Language Processing (EMNLP), pages 9332-9346, Online. Association for Computational Linguistics.</p>
<p>Lorenz Kuhn, Yarin Gal, and Sebastian Farquhar. 2023. Semantic uncertainty: Linguistic invariances for uncertainty estimation in natural language generation. In The Eleventh International Conference on Learning Representations.</p>
<p>Guokun Lai, Qizhe Xie, Hanxiao Liu, Yiming Yang, and Eduard Hovy. 2017. RACE: Large-scale ReAding comprehension dataset from examinations. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, pages 785794, Copenhagen, Denmark. Association for Computational Linguistics.</p>
<p>RÃ©mi Lebret, David Grangier, and Michael Auli. 2016. Generating text from structured data with application to the biography domain. CoRR, abs/1603.07771.</p>
<p>Tianyu Liu, Yizhe Zhang, Chris Brockett, Yi Mao, Zhifang Sui, Weizhu Chen, and Bill Dolan. 2022. A token-level reference-free hallucination detection benchmark for free-form text generation. In Proceedings of the 60th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 6723-6737, Dublin, Ireland. Association for Computational Linguistics.</p>
<p>Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Danqi Chen, Omer Levy, Mike Lewis, Luke Zettlemoyer, and Veselin Stoyanov. 2019. Roberta: A robustly optimized bert pretraining approach. arXiv preprint arXiv:1907.11692.</p>
<p>Adian Liusie, Vatsal Raina, and Mark Gales. 2023. "world knowledge" in multiple choice reading comprehension. In Proceedings of the Sixth Fact Extraction and VERification Workshop (FEVER), pages 49-57, Dubrovnik, Croatia. Association for Computational Linguistics.</p>
<p>Zheheng Luo, Qianqian Xie, and Sophia Ananiadou. 2023. Chatgpt as a factual inconsistency evaluator for abstractive text summarization. arXiv preprint arXiv:2303.15621.</p>
<p>Andrey Malinin and Mark Gales. 2021. Uncertainty estimation in autoregressive structured prediction. In International Conference on Learning Representations.</p>
<p>Potsawee Manakul, Adian Liusie, and Mark JF Gales. 2023. MQAG: Multiple-choice question answering and generation for assessing information consistency in summarization. arXiv preprint arXiv:2301.12307.</p>
<p>Joshua Maynez, Shashi Narayan, Bernd Bohnet, and Ryan McDonald. 2020. On faithfulness and factuality in abstractive summarization. In Proceedings of the 58th Annual Meeting of the Association for Computational Linguistics, pages 1906-1919, Online. Association for Computational Linguistics.</p>
<p>Sewon Min, Kalpesh Krishna, Xinxi Lyu, Mike Lewis, Wen-tau Yih, Pang Wei Koh, Mohit Iyyer, Luke Zettlemoyer, and Hannaneh Hajishirzi. 2023. Factscore: Fine-grained atomic evaluation of factual precision in long form text generation. arXiv preprint arXiv:2305.14251.</p>
<p>Colin Raffel, Noam Shazeer, Adam Roberts, Katherine Lee, Sharan Narang, Michael Matena, Yanqi Zhou, Wei Li, and Peter J Liu. 2020. Exploring the limits of transfer learning with a unified text-to-text transformer. The Journal of Machine Learning Research, 21(1):5485-5551.</p>
<p>Vatsal Raina and Mark Gales. 2022. Answer uncertainty and unanswerability in multiple-choice machine reading comprehension. In Findings of the Association for Computational Linguistics: ACL 2022, pages 1020-1034, Dublin, Ireland. Association for Computational Linguistics.</p>
<p>Pranav Rajpurkar, Jian Zhang, Konstantin Lopyrev, and Percy Liang. 2016. SQuAD: 100,000+ questions for machine comprehension of text. In Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing, pages 2383-2392, Austin, Texas. Association for Computational Linguistics.</p>
<p>Kurt Shuster, Spencer Poff, Moya Chen, Douwe Kiela, and Jason Weston. 2021. Retrieval augmentation reduces hallucination in conversation. In Findings of the Association for Computational Linguistics: EMNLP 2021, pages 3784-3803, Punta Cana, Dominican Republic. Association for Computational Linguistics.</p>
<p>James Thorne, Andreas Vlachos, Oana Cocarascu, Christos Christodoulopoulos, and Arpit Mittal. 2018. The Fact Extraction and VERification (FEVER) shared task. In Proceedings of the First Workshop on Fact Extraction and VERification (FEVER).</p>
<p>Hugo Touvron, Thibaut Lavril, Gautier Izacard, Xavier Martinet, Marie-Anne Lachaux, TimothÃ©e Lacroix, Baptiste RoziÃ¨re, Naman Goyal, Eric Hambro, Faisal Azhar, et al. 2023. Llama: Open and efficient foundation language models. arXiv preprint arXiv:2302.13971.</p>
<p>Anthony J Viera, Joanne M Garrett, et al. 2005. Understanding interobserver agreement: the kappa statistic. Fam med, 37(5):360-363.</p>
<p>Ben Wang and Aran Komatsuzaki. 2021. GPT-J6B: A 6 Billion Parameter Autoregressive Language Model. https://github.com/kingoflolz/ mesh-transformer-jax.</p>
<p>Xuezhi Wang, Jason Wei, Dale Schuurmans, Quoc V Le, Ed H. Chi, Sharan Narang, Aakanksha Chowdhery, and Denny Zhou. 2023. Self-consistency improves chain of thought reasoning in language models. In The Eleventh International Conference on Learning Representations.</p>
<p>Adina Williams, Nikita Nangia, and Samuel Bowman. 2018. A broad-coverage challenge corpus for sentence understanding through inference. In Proceedings of the 2018 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long Papers), pages 1112-1122, New Orleans, Louisiana. Association for Computational Linguistics.</p>
<p>Yijun Xiao and William Yang Wang. 2021. On hallucination and predictive uncertainty in conditional language generation. In Proceedings of the 16th Conference of the European Chapter of the Association for Computational Linguistics: Main Volume, pages 2734-2744, Online. Association for Computational Linguistics.</p>
<p>Weizhe Yuan, Graham Neubig, and Pengfei Liu. 2021. Bartscore: Evaluating generated text as text generation. Advances in Neural Information Processing Systems, 34:27263-27277.</p>
<p>Susan Zhang, Stephen Roller, Naman Goyal, Mikel Artetxe, Moya Chen, Shuohui Chen, Christopher Dewan, Mona Diab, Xian Li, Xi Victoria Lin, et al. 2022. Opt: Open pre-trained transformer language models. arXiv preprint arXiv:2205.01068.</p>
<p>Zhuosheng Zhang, Yuwei Wu, Hai Zhao, Zuchao Li, Shuailiang Zhang, Xi Zhou, and Xiang Zhou. 2020. Semantics-aware bert for language understanding. In Proceedings of the AAAI Conference on Artificial Intelligence, volume 34, pages 9628-9635.</p>
<p>Wanjun Zhong, Jingjing Xu, Duyu Tang, Zenan Xu, Nan Duan, Ming Zhou, Jiahai Wang, and Jian Yin. 2020. Reasoning over semantic-level graph for fact checking. In Proceedings of the 58th Annual Meeting of the Association for Computational Linguistics, pages 6170-6180, Online. Association for Computational Linguistics.</p>
<h2>A Models and Implementation</h2>
<h2>A. 1 Entropy</h2>
<p>The entropy of the output distribution is implemented as follows,</p>
<p>$$
\mathcal{H}<em _tilde_w="\tilde{w">{i j}=2^{-\sum</em>) \log } \in \mathcal{W}} p_{i j}(\tilde{w<em i="i" j="j">{2} p</em>
$$}(\tilde{w})</p>
<p>where $\mathcal{W}$ is the set of all possible words in the vocabulary.</p>
<h2>A. 2 Proxy LLMs</h2>
<p>The proxy LLMs considered are LLaMA-{7B, 13B, 30B} (Touvron et al., 2023), OPT-{125m, 1.3B, 13B, 30B} (Zhang et al., 2022), GPT-J-6B (Wang and Komatsuzaki, 2021) and GPT-NeoX20B (Black et al., 2022).</p>
<h2>A. 3 SelfCheckGPT's Systems</h2>
<p>Question Answering: The generation systems G1 and G2 are T5-Large fine-tuned to SQuAD (Rajpurkar et al., 2016) and RACE (Lai et al., 2017), respectively. The answering system A is Longformer (Beltagy et al., 2020) fine-tuned to the RACE dataset. The answerability system $U$ is also Longformer, but fine-tuned to SQuAD2.0.</p>
<p>LLM for Prompting: We consider two LLMs, GPT-3 (text-davinci-003) and ChatGPT (gpt-3.5turbo) We note that during the data creation and annotation, GPT-3 (text-davinci-003) was the state-of-the-art LLM available; hence, GPT-3 was used as the main LLM generating WikiBio passages.</p>
<h2>B SelfCheckGPT with QA</h2>
<p>Previous work showed that implementing question generation (in Equation 2) with two generators (G1 generates the question and associated answer, and G2 generates distractors) yields higher-quality distractors (Manakul et al., 2023). Thus, a two-stage generation is adopted in this work as follows:</p>
<p>$$
q, a \sim P_{\mathrm{G} 1}\left(q, a \mid r_{i}\right) ; \quad \mathbf{o}<em _mathrm_G="\mathrm{G">{\backslash a} \sim P</em> \mid q, a, R\right)
$$} 2}\left(\mathbf{o}_{\backslash a</p>
<p>where $\mathbf{o}=\left{a, \mathbf{o}<em 1="1">{\backslash a}\right}=\left{o</em>\right}$. In addition, to filter out bad (unanswerable) questions, we define an answerability score (Raina and Gales, 2022):}, \ldots, o_{4</p>
<p>$$
\alpha=P_{\mathrm{0}}(\text { answerable } \mid q, \text { context })
$$</p>
<p>where the context is either the response $R$ or sampled passages $S^{n}$, and $\alpha \rightarrow 0.0$ for unanswerable and $\alpha \rightarrow 1.0$ for answerable. We use $\alpha$ to filter out
unanswerable questions which have $\alpha$ lower than a threshold. Next, we derive how Bayes' theorem can be applied to take into account the number of answerable/unanswerable questions.</p>
<h2>B. 1 SelfCheckGPT-QA with Bayes</h2>
<p>Let $P(\mathrm{~F})$ denote the probability of the $i$-th sentence being non-factual, and $P(\mathrm{~T})$ denote the probability of the $i$-th sentence being factual. For a question $q$, the probability of $i$-th sentence being non-factual given a set of matched answers $L_{\mathrm{n}}$ and a set of not-matched answers $L_{\mathrm{n}}$ is:</p>
<p>$$
\begin{aligned}
&amp; P(\mathrm{~F} \mid L_{\mathrm{n}}, L_{\mathrm{n}}) \
&amp; =\frac{P\left(L_{\mathrm{n}}, L_{\mathrm{n}} \mid \mathrm{F}\right) P(\mathrm{~F})}{P\left(L_{\mathrm{n}}, L_{\mathrm{n}} \mid \mathrm{F}\right) P(\mathrm{~F})+P\left(L_{\mathrm{n}}, L_{\mathrm{n}} \mid \mathrm{T}\right) P(\mathrm{~T})} \
&amp; =\frac{P\left(L_{\mathrm{n}}, L_{\mathrm{n}} \mid \mathrm{F}\right)}{P\left(L_{\mathrm{n}}, L_{\mathrm{n}} \mid \mathrm{F}\right)+P\left(L_{\mathrm{n}}, L_{\mathrm{n}} \mid \mathrm{T}\right)}
\end{aligned}
$$</p>
<p>where we assume the sentence is equally likely to be False or True, i.e. $P(\mathrm{~F})=P(\mathrm{~T})$. The probability of observing $L_{\mathrm{n}}, L_{\mathrm{n}}$ when the sentence is False (non-factual):</p>
<p>$$
\begin{aligned}
&amp; P\left(L_{\mathrm{n}}, L_{\mathrm{n}} \mid \mathrm{F}\right) \
&amp; =\prod_{a \in L_{\mathrm{n}}} P\left(a=a_{R} \mid F\right) \prod_{a^{\prime} \in L_{\mathrm{n}}} P\left(a^{\prime} \neq a_{R} \mid F\right) \
&amp; =\left(1-\beta_{1}\right)^{N_{\mathrm{n}}}\left(\beta_{1}\right)^{N_{\mathrm{n}}}
\end{aligned}
$$</p>
<p>and probability of observing $L_{\mathrm{n}}, L_{\mathrm{n}}$ when the sentence is True (factual):</p>
<p>$$
\begin{aligned}
&amp; P\left(L_{\mathrm{n}}, L_{\mathrm{n}} \mid \mathrm{T}\right) \
&amp; =\prod_{a \in L_{\mathrm{n}}} P\left(a=a_{r} \mid T\right) \prod_{a^{\prime} \in L_{\mathrm{n}}} P\left(a^{\prime} \neq a_{r} \mid T\right) \
&amp; =\left(\beta_{2}\right)^{N_{\mathrm{n}}}\left(1-\beta_{2}\right)^{N_{\mathrm{n}}}
\end{aligned}
$$</p>
<p>where $N_{\mathrm{n}}$ and $N_{\mathrm{n}}$ are the number of matched answers and the number of not-matched answers, respectively. Hence, we can simplify Equation 16:</p>
<p>$$
P\left(\mathrm{~F} \mid L_{\mathrm{n}}, L_{\mathrm{n}}\right)=\frac{\gamma_{2}^{N_{\mathrm{n}}}}{\gamma_{1}^{N_{\mathrm{n}}}+\gamma_{2}^{N_{\mathrm{n}}}}
$$</p>
<p>where $\gamma_{1}=\frac{\beta_{2}}{1-\beta_{1}}$ and $\gamma_{2}=\frac{\beta_{1}}{1-\beta_{2}}$. Lastly, instead of rejecting samples having an answerability score below a threshold, ${ }^{7}$ we find empirically that softcounting (defined below) improves the detection performance. We set both $\beta_{1}$ and $\beta_{2}$ to 0.8 .</p>
<p><sup id="fnref5:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>$$
N_{\mathrm{R}}^{\prime}=\sum_{n \text { s.t. } n_{\mathrm{n}} \in L_{\mathrm{R}}} \alpha_{n} ; \quad N_{\mathrm{R}}^{\prime}=\sum_{n \text { s.t. } n_{\mathrm{n}} \in L_{\mathrm{R}}} \alpha_{n}
$$</p>
<p>where $\alpha_{n}=P_{\emptyset}\left(\right.$ answerable $\left|q, S^{n}\right)$. Therefore, the SelfCheckGPT with QA score, $\mathcal{S}_{\mathrm{QA}}$, is:</p>
<p>$$
\mathcal{S}<em _mathrm_R="\mathrm{R">{\mathrm{QA}}=P\left(\mathrm{~F} \mid L</em>
$$}}, L_{\mathrm{R}}\right)=\frac{\gamma_{2}^{N_{\mathrm{R}}^{\prime}}}{\gamma_{1}^{N_{\mathrm{R}}^{\prime}}+\gamma_{2}^{N_{\mathrm{R}}^{\prime}}</p>
<p>In Table 5, we show empically that applying Bayes' theorem and soft counting $\alpha$ (in Equation 20) improves the performance of the SelfCheckGPT with QA method.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Varaint</th>
<th style="text-align: center;">Sentence-lvl</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Passage-lvl</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;">NoF</td>
<td style="text-align: center;">NoF*</td>
<td style="text-align: center;">Fact</td>
<td style="text-align: center;">PCC</td>
<td style="text-align: center;">SCC</td>
</tr>
<tr>
<td style="text-align: left;">SimpleCount</td>
<td style="text-align: center;">83.97</td>
<td style="text-align: center;">40.07</td>
<td style="text-align: center;">47.78</td>
<td style="text-align: center;">57.39</td>
<td style="text-align: center;">55.15</td>
</tr>
<tr>
<td style="text-align: left;">+ Bayes</td>
<td style="text-align: center;">83.04</td>
<td style="text-align: center;">38.58</td>
<td style="text-align: center;">47.41</td>
<td style="text-align: center;">56.43</td>
<td style="text-align: center;">55.03</td>
</tr>
<tr>
<td style="text-align: left;">+ Bayes $+\alpha$</td>
<td style="text-align: center;">84.26</td>
<td style="text-align: center;">40.06</td>
<td style="text-align: center;">48.14</td>
<td style="text-align: center;">61.07</td>
<td style="text-align: center;">59.29</td>
</tr>
</tbody>
</table>
<p>Table 5: Performance of SelfCheckGPT-QA's variants.</p>
<h2>C SelfCheckGPT with Prompt</h2>
<p>We use the prompt template provided in the main text (in Section 5.5) for both GPT-3 (text-davinci003) and ChatGPT (gpt-3.5-turbo). For ChatGPT, a standard system message "You are a helpful assistant." is used in setting up the system.</p>
<p>At the time of conducting experiments, the API costs per 1,000 tokens are $\$ 0.020$ for GPT-3 and $\$ 0.002$ for ChatGPT. The estimated costs for running the models to answer Yes/No on all 1908 sentences and 20 samples are around $\$ 200$ for GPT-3 and $\$ 20$ for ChatGPT. Given the cost, we conduct the experiments on 4 samples when performing the ablation about LLM choice for SelfCheckGPTPrompt (Section 7.3). Table 6 shows the breakdown of predictions made by GPT-3 and ChatGPT.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">GPT-3</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Yes</th>
<th style="text-align: center;">No</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">3179</td>
<td style="text-align: center;">1038</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">367</td>
<td style="text-align: center;">3048</td>
</tr>
</tbody>
</table>
<p>Table 6: Breakdown of predictions made by GPT-3/ChatGPT when prompted to answer Yes(supported)/No(not-supported).</p>
<h2>D Additional Experimental Results</h2>
<p>Here, we provide experimental results that are complementary to those presented in the main paper.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">$n$-gram</th>
<th style="text-align: center;">Sent-lvl AUC-PR</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Passage-lvl</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">NoFac</td>
<td style="text-align: center;">NoFac*</td>
<td style="text-align: center;">Fact</td>
<td style="text-align: center;">Pear.</td>
<td style="text-align: center;">Spear.</td>
</tr>
<tr>
<td style="text-align: center;">Avg( $=\log p)$</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">1-gram</td>
<td style="text-align: center;">81.52</td>
<td style="text-align: center;">40.33</td>
<td style="text-align: center;">41.76</td>
<td style="text-align: center;">40.68</td>
<td style="text-align: center;">39.22</td>
</tr>
<tr>
<td style="text-align: center;">2-gram</td>
<td style="text-align: center;">82.94</td>
<td style="text-align: center;">44.38</td>
<td style="text-align: center;">52.81</td>
<td style="text-align: center;">58.84</td>
<td style="text-align: center;">58.11</td>
</tr>
<tr>
<td style="text-align: center;">3-gram</td>
<td style="text-align: center;">83.56</td>
<td style="text-align: center;">44.64</td>
<td style="text-align: center;">53.99</td>
<td style="text-align: center;">62.21</td>
<td style="text-align: center;">63.00</td>
</tr>
<tr>
<td style="text-align: center;">4-gram</td>
<td style="text-align: center;">83.80</td>
<td style="text-align: center;">43.55</td>
<td style="text-align: center;">54.25</td>
<td style="text-align: center;">61.98</td>
<td style="text-align: center;">63.64</td>
</tr>
<tr>
<td style="text-align: center;">5-gram</td>
<td style="text-align: center;">83.45</td>
<td style="text-align: center;">42.31</td>
<td style="text-align: center;">53.98</td>
<td style="text-align: center;">60.68</td>
<td style="text-align: center;">62.96</td>
</tr>
<tr>
<td style="text-align: center;">Max( $=\log p)$</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">1-gram</td>
<td style="text-align: center;">85.63</td>
<td style="text-align: center;">41.04</td>
<td style="text-align: center;">58.47</td>
<td style="text-align: center;">64.71</td>
<td style="text-align: center;">64.91</td>
</tr>
<tr>
<td style="text-align: center;">2-gram</td>
<td style="text-align: center;">85.26</td>
<td style="text-align: center;">39.29</td>
<td style="text-align: center;">58.29</td>
<td style="text-align: center;">62.48</td>
<td style="text-align: center;">66.04</td>
</tr>
<tr>
<td style="text-align: center;">3-gram</td>
<td style="text-align: center;">84.97</td>
<td style="text-align: center;">37.10</td>
<td style="text-align: center;">57.08</td>
<td style="text-align: center;">57.34</td>
<td style="text-align: center;">60.49</td>
</tr>
<tr>
<td style="text-align: center;">4-gram</td>
<td style="text-align: center;">84.49</td>
<td style="text-align: center;">36.37</td>
<td style="text-align: center;">55.96</td>
<td style="text-align: center;">55.77</td>
<td style="text-align: center;">57.25</td>
</tr>
<tr>
<td style="text-align: center;">5-gram</td>
<td style="text-align: center;">84.12</td>
<td style="text-align: center;">36.19</td>
<td style="text-align: center;">54.89</td>
<td style="text-align: center;">54.84</td>
<td style="text-align: center;">55.97</td>
</tr>
</tbody>
</table>
<p>Table 7: The performance using different $n$-gram models in the SelfCheckGPT with $n$-gram method.
<img alt="img-7.jpeg" src="img-7.jpeg" /></p>
<p>Figure 8: The performance of SelfCheckGPT methods on sentence-level non-factual detection (AUC-PR) versus the number of samples. This Figure extends the passage-level results in Figure 7.
<img alt="img-8.jpeg" src="img-8.jpeg" /></p>
<p>Figure 9: Passage-level ranking performance of the Avg $(\mathcal{H})$ method using proxy LLM where the sizes are: LLaMA $={7 \mathrm{~B}$, 13B, 30B $} \mathrm{OPt}={125 \mathrm{~m}, 1.3 \mathrm{~B}, 13 \mathrm{~B}, 30 \mathrm{~B}}$, GPT-J=6B, NeoX=20B. The full results are provided in Table 8.</p>
<p><img alt="img-9.jpeg" src="img-9.jpeg" /></p>
<p>Figure 10: Scatter plot of passage-level scores where Y-axis $=$ Method scores, X -axis $=$ Human scores. Correlations are reported in Table 2. This figure provides results in addition to Figure 6.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">LLM</th>
<th style="text-align: center;">Size</th>
<th style="text-align: center;">Sentence-level (AUC-PR)</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Passage-level (Corr.)</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">NonFact</td>
<td style="text-align: center;">NonFact*</td>
<td style="text-align: center;">Factual</td>
<td style="text-align: center;">Pearson</td>
<td style="text-align: center;">Spearman</td>
</tr>
<tr>
<td style="text-align: center;">Random</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">72.96</td>
<td style="text-align: center;">29.72</td>
<td style="text-align: center;">27.04</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">Avg( $-\log p)$ Method</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">LLaMA</td>
<td style="text-align: center;">30B</td>
<td style="text-align: center;">75.43</td>
<td style="text-align: center;">30.32</td>
<td style="text-align: center;">41.29</td>
<td style="text-align: center;">21.72</td>
<td style="text-align: center;">20.20</td>
</tr>
<tr>
<td style="text-align: center;">LLaMA</td>
<td style="text-align: center;">13B</td>
<td style="text-align: center;">74.16</td>
<td style="text-align: center;">30.01</td>
<td style="text-align: center;">37.36</td>
<td style="text-align: center;">13.33</td>
<td style="text-align: center;">12.89</td>
</tr>
<tr>
<td style="text-align: center;">LLaMA</td>
<td style="text-align: center;">7B</td>
<td style="text-align: center;">71.69</td>
<td style="text-align: center;">27.87</td>
<td style="text-align: center;">31.30</td>
<td style="text-align: center;">$-2.71$</td>
<td style="text-align: center;">$-2.59$</td>
</tr>
<tr>
<td style="text-align: center;">OPT</td>
<td style="text-align: center;">30B</td>
<td style="text-align: center;">67.70</td>
<td style="text-align: center;">24.43</td>
<td style="text-align: center;">25.04</td>
<td style="text-align: center;">$-32.07$</td>
<td style="text-align: center;">$-31.45$</td>
</tr>
<tr>
<td style="text-align: center;">NeoX</td>
<td style="text-align: center;">20B</td>
<td style="text-align: center;">69.00</td>
<td style="text-align: center;">24.38</td>
<td style="text-align: center;">26.18</td>
<td style="text-align: center;">$-31.79$</td>
<td style="text-align: center;">$-34.15$</td>
</tr>
<tr>
<td style="text-align: center;">OPT</td>
<td style="text-align: center;">13B</td>
<td style="text-align: center;">67.46</td>
<td style="text-align: center;">24.39</td>
<td style="text-align: center;">25.20</td>
<td style="text-align: center;">$-33.05$</td>
<td style="text-align: center;">$-32.79$</td>
</tr>
<tr>
<td style="text-align: center;">GPT-J</td>
<td style="text-align: center;">6B</td>
<td style="text-align: center;">67.51</td>
<td style="text-align: center;">24.28</td>
<td style="text-align: center;">24.26</td>
<td style="text-align: center;">$-38.80$</td>
<td style="text-align: center;">$-40.05$</td>
</tr>
<tr>
<td style="text-align: center;">OPT</td>
<td style="text-align: center;">1.3B</td>
<td style="text-align: center;">66.19</td>
<td style="text-align: center;">24.47</td>
<td style="text-align: center;">23.47</td>
<td style="text-align: center;">$-35.20$</td>
<td style="text-align: center;">$-38.95$</td>
</tr>
<tr>
<td style="text-align: center;">OPT</td>
<td style="text-align: center;">125 m</td>
<td style="text-align: center;">66.63</td>
<td style="text-align: center;">25.31</td>
<td style="text-align: center;">23.07</td>
<td style="text-align: center;">$-30.38$</td>
<td style="text-align: center;">$-37.54$</td>
</tr>
<tr>
<td style="text-align: center;">Avg( $N$ ) Method</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">LLaMA</td>
<td style="text-align: center;">30B</td>
<td style="text-align: center;">80.80</td>
<td style="text-align: center;">39.01</td>
<td style="text-align: center;">42.97</td>
<td style="text-align: center;">33.80</td>
<td style="text-align: center;">39.49</td>
</tr>
<tr>
<td style="text-align: center;">LLaMA</td>
<td style="text-align: center;">13B</td>
<td style="text-align: center;">80.63</td>
<td style="text-align: center;">38.98</td>
<td style="text-align: center;">40.59</td>
<td style="text-align: center;">29.43</td>
<td style="text-align: center;">33.12</td>
</tr>
<tr>
<td style="text-align: center;">LLaMA</td>
<td style="text-align: center;">7B</td>
<td style="text-align: center;">78.67</td>
<td style="text-align: center;">37.22</td>
<td style="text-align: center;">33.81</td>
<td style="text-align: center;">19.44</td>
<td style="text-align: center;">21.79</td>
</tr>
<tr>
<td style="text-align: center;">OPT</td>
<td style="text-align: center;">30B</td>
<td style="text-align: center;">77.13</td>
<td style="text-align: center;">33.67</td>
<td style="text-align: center;">29.55</td>
<td style="text-align: center;">$-0.43$</td>
<td style="text-align: center;">3.43</td>
</tr>
<tr>
<td style="text-align: center;">NeoX</td>
<td style="text-align: center;">20B</td>
<td style="text-align: center;">77.40</td>
<td style="text-align: center;">32.78</td>
<td style="text-align: center;">30.13</td>
<td style="text-align: center;">5.41</td>
<td style="text-align: center;">7.43</td>
</tr>
<tr>
<td style="text-align: center;">OPT</td>
<td style="text-align: center;">13B</td>
<td style="text-align: center;">76.93</td>
<td style="text-align: center;">33.71</td>
<td style="text-align: center;">29.68</td>
<td style="text-align: center;">0.25</td>
<td style="text-align: center;">1.39</td>
</tr>
<tr>
<td style="text-align: center;">GPT-J</td>
<td style="text-align: center;">6B</td>
<td style="text-align: center;">76.15</td>
<td style="text-align: center;">33.29</td>
<td style="text-align: center;">28.30</td>
<td style="text-align: center;">$-2.50$</td>
<td style="text-align: center;">$-1.37$</td>
</tr>
<tr>
<td style="text-align: center;">OPT</td>
<td style="text-align: center;">1.3B</td>
<td style="text-align: center;">74.05</td>
<td style="text-align: center;">31.91</td>
<td style="text-align: center;">26.33</td>
<td style="text-align: center;">$-10.59$</td>
<td style="text-align: center;">$-10.00$</td>
</tr>
<tr>
<td style="text-align: center;">OPT</td>
<td style="text-align: center;">125 m</td>
<td style="text-align: center;">71.51</td>
<td style="text-align: center;">30.88</td>
<td style="text-align: center;">25.36</td>
<td style="text-align: center;">$-14.16$</td>
<td style="text-align: center;">$-13.76$</td>
</tr>
<tr>
<td style="text-align: center;">Max( $-\log p)$ Method</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">LLaMA</td>
<td style="text-align: center;">30B</td>
<td style="text-align: center;">74.01</td>
<td style="text-align: center;">27.14</td>
<td style="text-align: center;">31.08</td>
<td style="text-align: center;">$-22.83$</td>
<td style="text-align: center;">$-22.71$</td>
</tr>
<tr>
<td style="text-align: center;">LLaMA</td>
<td style="text-align: center;">13B</td>
<td style="text-align: center;">71.12</td>
<td style="text-align: center;">26.78</td>
<td style="text-align: center;">28.82</td>
<td style="text-align: center;">$-34.93$</td>
<td style="text-align: center;">$-31.70$</td>
</tr>
<tr>
<td style="text-align: center;">LLaMA</td>
<td style="text-align: center;">7B</td>
<td style="text-align: center;">69.57</td>
<td style="text-align: center;">25.91</td>
<td style="text-align: center;">26.54</td>
<td style="text-align: center;">$-42.57$</td>
<td style="text-align: center;">$-38.24$</td>
</tr>
<tr>
<td style="text-align: center;">OPT</td>
<td style="text-align: center;">30B</td>
<td style="text-align: center;">67.32</td>
<td style="text-align: center;">24.40</td>
<td style="text-align: center;">24.32</td>
<td style="text-align: center;">$-49.51$</td>
<td style="text-align: center;">$-45.50$</td>
</tr>
<tr>
<td style="text-align: center;">NeoX</td>
<td style="text-align: center;">20B</td>
<td style="text-align: center;">67.51</td>
<td style="text-align: center;">23.88</td>
<td style="text-align: center;">24.82</td>
<td style="text-align: center;">$-47.96$</td>
<td style="text-align: center;">$-44.54$</td>
</tr>
<tr>
<td style="text-align: center;">OPT</td>
<td style="text-align: center;">13B</td>
<td style="text-align: center;">67.36</td>
<td style="text-align: center;">24.67</td>
<td style="text-align: center;">24.46</td>
<td style="text-align: center;">$-50.15$</td>
<td style="text-align: center;">$-44.42$</td>
</tr>
<tr>
<td style="text-align: center;">GPT-J</td>
<td style="text-align: center;">6B</td>
<td style="text-align: center;">67.58</td>
<td style="text-align: center;">23.94</td>
<td style="text-align: center;">23.93</td>
<td style="text-align: center;">$-51.23$</td>
<td style="text-align: center;">$-47.68$</td>
</tr>
<tr>
<td style="text-align: center;">OPT</td>
<td style="text-align: center;">1.3B</td>
<td style="text-align: center;">68.16</td>
<td style="text-align: center;">25.85</td>
<td style="text-align: center;">24.66</td>
<td style="text-align: center;">$-45.60$</td>
<td style="text-align: center;">$-42.39$</td>
</tr>
<tr>
<td style="text-align: center;">OPT</td>
<td style="text-align: center;">125 m</td>
<td style="text-align: center;">69.23</td>
<td style="text-align: center;">27.66</td>
<td style="text-align: center;">24.14</td>
<td style="text-align: center;">$-39.22$</td>
<td style="text-align: center;">$-37.18$</td>
</tr>
<tr>
<td style="text-align: center;">Max( $N$ ) Method</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">LLaMA</td>
<td style="text-align: center;">30B</td>
<td style="text-align: center;">80.92</td>
<td style="text-align: center;">37.32</td>
<td style="text-align: center;">37.90</td>
<td style="text-align: center;">35.57</td>
<td style="text-align: center;">38.94</td>
</tr>
<tr>
<td style="text-align: center;">LLaMA</td>
<td style="text-align: center;">13B</td>
<td style="text-align: center;">80.98</td>
<td style="text-align: center;">37.94</td>
<td style="text-align: center;">36.01</td>
<td style="text-align: center;">32.07</td>
<td style="text-align: center;">34.01</td>
</tr>
<tr>
<td style="text-align: center;">LLaMA</td>
<td style="text-align: center;">7B</td>
<td style="text-align: center;">79.65</td>
<td style="text-align: center;">35.57</td>
<td style="text-align: center;">31.32</td>
<td style="text-align: center;">22.10</td>
<td style="text-align: center;">22.53</td>
</tr>
<tr>
<td style="text-align: center;">OPT</td>
<td style="text-align: center;">30B</td>
<td style="text-align: center;">76.58</td>
<td style="text-align: center;">33.44</td>
<td style="text-align: center;">29.31</td>
<td style="text-align: center;">1.63</td>
<td style="text-align: center;">6.41</td>
</tr>
<tr>
<td style="text-align: center;">NeoX</td>
<td style="text-align: center;">20B</td>
<td style="text-align: center;">76.98</td>
<td style="text-align: center;">31.96</td>
<td style="text-align: center;">29.13</td>
<td style="text-align: center;">5.97</td>
<td style="text-align: center;">9.31</td>
</tr>
<tr>
<td style="text-align: center;">OPT</td>
<td style="text-align: center;">13B</td>
<td style="text-align: center;">76.26</td>
<td style="text-align: center;">32.81</td>
<td style="text-align: center;">29.25</td>
<td style="text-align: center;">1.42</td>
<td style="text-align: center;">2.82</td>
</tr>
<tr>
<td style="text-align: center;">GPT-J</td>
<td style="text-align: center;">6B</td>
<td style="text-align: center;">75.30</td>
<td style="text-align: center;">32.51</td>
<td style="text-align: center;">28.13</td>
<td style="text-align: center;">$-2.14$</td>
<td style="text-align: center;">1.41</td>
</tr>
<tr>
<td style="text-align: center;">OPT</td>
<td style="text-align: center;">1.3B</td>
<td style="text-align: center;">73.79</td>
<td style="text-align: center;">31.42</td>
<td style="text-align: center;">26.38</td>
<td style="text-align: center;">$-9.84$</td>
<td style="text-align: center;">$-9.80$</td>
</tr>
<tr>
<td style="text-align: center;">OPT</td>
<td style="text-align: center;">125 m</td>
<td style="text-align: center;">71.32</td>
<td style="text-align: center;">31.65</td>
<td style="text-align: center;">25.36</td>
<td style="text-align: center;">$-18.05$</td>
<td style="text-align: center;">$-17.37$</td>
</tr>
</tbody>
</table>
<p>Table 8: AUC-PR for Detecting Non-Factual and Factual Sentences in the GPT-3 generated WikiBio passages. Passage-level PCC and SCC with LLMs used to assess GPT-3 responses. This table is an extension to Table 2.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{7} \alpha$ is between 0.0 (unanswerable) and 1.0 (answerable). Standard-counting $N_{\mathrm{n}}$ and $N_{\mathrm{n}}$ can be considered as a special case of soft-counting where $\alpha$ is set to 1.0 if $\alpha$ is greater than the answerability threshold and otherwise $\alpha$ is 0.0 .&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref5:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:1">
<p>${ }^{5}$ There are 206 non-factual ${ }^{\star}$ passages (1632 sentences).&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>