<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-6602 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-6602</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-6602</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-127.html">extraction-schema-127</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents that employ a memory mechanism to solve tasks, including details of the memory type, how it is accessed or updated, the tasks/benchmarks evaluated, performance with and without the memory, and any reported trade‑offs or limitations.</div>
                <p><strong>Paper ID:</strong> paper-7bbc7595196a0606a07506c4fb1473e5e87f6082</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/7bbc7595196a0606a07506c4fb1473e5e87f6082" target="_blank">Mamba: Linear-Time Sequence Modeling with Selective State Spaces</a></p>
                <p><strong>Paper Venue:</strong> arXiv.org</p>
                <p><strong>Paper TL;DR:</strong> This work identifies that a key weakness of subquadratic-time models based on Transformer architecture is their inability to perform content-based reasoning, and integrates selective SSMs into a simplified end-to-end neural network architecture without attention or even MLP blocks (Mamba).</p>
                <p><strong>Paper Abstract:</strong> Foundation models, now powering most of the exciting applications in deep learning, are almost universally based on the Transformer architecture and its core attention module. Many subquadratic-time architectures such as linear attention, gated convolution and recurrent models, and structured state space models (SSMs) have been developed to address Transformers' computational inefficiency on long sequences, but they have not performed as well as attention on important modalities such as language. We identify that a key weakness of such models is their inability to perform content-based reasoning, and make several improvements. First, simply letting the SSM parameters be functions of the input addresses their weakness with discrete modalities, allowing the model to selectively propagate or forget information along the sequence length dimension depending on the current token. Second, even though this change prevents the use of efficient convolutions, we design a hardware-aware parallel algorithm in recurrent mode. We integrate these selective SSMs into a simplified end-to-end neural network architecture without attention or even MLP blocks (Mamba). Mamba enjoys fast inference (5$\times$ higher throughput than Transformers) and linear scaling in sequence length, and its performance improves on real data up to million-length sequences. As a general sequence model backbone, Mamba achieves state-of-the-art performance across several modalities such as language, audio, and genomics. On language modeling, our Mamba-3B model outperforms Transformers of the same size and matches Transformers twice its size, both in pretraining and downstream evaluation.</p>
                <p><strong>Cost:</strong> 0.021</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e6602.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e6602.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents that employ a memory mechanism to solve tasks, including details of the memory type, how it is accessed or updated, the tasks/benchmarks evaluated, performance with and without the memory, and any reported trade‑offs or limitations.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Mamba</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Mamba (Selective SSM backbone)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An attention-free sequence model architecture built from stacked selective state space layers (S6) that use an input-dependent recurrent latent state to store and retrieve context; designed for linear-time scaling and fast autoregressive inference.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>Mamba</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>A homogeneous block architecture that integrates selective structured state space layers (S6) with lightweight projection/expansion layers. Memory is an internal recurrent SSM latent state (per-channel state of size N) whose update/read parameters (Δ, B, C) are computed as functions of the current input; the model thus performs content-aware writes/reads via gating-like selection.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>various (experiments reported across ≈130M up to ≈2.8B parameters; Mamba-3B also referenced)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>internal recurrent latent state (structured state space model, SSM) with input-dependent selection (selective SSM / S6)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>continuous hidden state vector h (per-channel state of dimension N, overall D×N per timestep), stored as real (default) or complex in some audio experiments</td>
                        </tr>
                        <tr>
                            <td><strong>memory_access_mechanism</strong></td>
                            <td>recurrent scan (autoregressive recurrence) where SSM parameters Δ_t, B_t, C_t are computed from the current input via small linear projections s(x); these parameters determine how much the current input is written into state and how state is exposed to outputs (e.g. reduces to gating: g_t = σ(Linear(x_t)), h_t = (1-g_t) h_{t-1} + g_t x_t in a special case)</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Selective Copying; Induction Heads (associative recall); Language modeling (Pile pretraining, zero-shot downstream); DNA pretraining and long-context classification; Audio waveform modeling and autoregressive speech generation</td>
                        </tr>
                        <tr>
                            <td><strong>task_category</strong></td>
                            <td>synthetic memory/compression tasks; in‑context associative recall; autoregressive language modeling; genomics sequence modeling; audio generation</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>Selective Copying / Induction Heads: S6-enabled Mamba variants achieve very high accuracy (examples in paper: Mamba with S6: 99.8% accuracy on synthetic selective tasks / induction-heads-style tasks and generalizes to 1M token test lengths). Language modeling: Mamba (with S6) reported perplexities as low as 8.69 in ablations (≈350M setting) and competitive PPL across sizes (e.g., Mamba-1.4B Pile PPL 6.80 in Table 3). Audio: lower NLL/BPB and improved generation metrics (e.g., SC09: Mamba small 6.1M params NLL 1.852, FID 0.94; larger Mamba 24.3M NLL 1.860, FID 0.67). DNA/audio: pretraining perplexity and downstream metrics improve relative to baselines when using selection.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td>When using non-selective (LTI) SSMs (S4) or other non-selective layers, performance degrades substantially: Selective Copying — S4 variants report much lower accuracy (examples: S4 variants ~18.3% on the selective copying baseline vs S6 ≈97% in related rows); Language modeling ablation: same architecture with S4 inner layer yields perplexity ≈10.54–10.56 vs 8.69 with S6 (≈350M setting). Audio/DNA baselines (S4/Hyena/SaShiMi) show worse NLL/BPB or deteriorate with longer context where Mamba improves.</td>
                        </tr>
                        <tr>
                            <td><strong>has_comparative_results</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td>Accuracy (synthetic tasks), Perplexity / NLL (language & DNA), Bits-per-byte (BPB) for audio pretraining, FID / IS / mlS for audio generation</td>
                        </tr>
                        <tr>
                            <td><strong>tradeoffs_reported</strong></td>
                            <td>Computation: selective (time-varying) SSMs cannot use the convolutional parallel computation path and require a recurrent scan; authors design a hardware-aware fused scan + recomputation to make it fast and memory efficient. Mamba achieves linear-time scaling and up to 4–5× higher autoregressive inference throughput compared to Transformers of similar size. Memory/IO: naive selective state expansion would be large (B×L×D×N) so the implementation stages discretization and recurrence in fast SRAM and avoids materializing expanded state; recomputation is used in backward pass. Modeling tradeoff: selection improves discrete, information-dense modalities and long-context performance, but may reduce some inductive biases beneficial for continuous modalities unless complex parameterizations are used.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Selective SSMs can impede performance on modalities where LTI SSM inductive biases help (continuous perceptual signals) unless complex-valued parameterizations are employed; the selective approach breaks convolutional-mode efficiency and necessitates careful hardware-aware implementations; scaling to very large model sizes (> few billion) is not fully explored and may require further engineering; the paper notes a 'continuous–discrete spectrum' tradeoff where selection helps discrete data (text/DNA) but may hurt continuous data.</td>
                        </tr>
                        <tr>
                            <td><strong>citation</strong></td>
                            <td>Albert Gu and Tri Dao. Mamba: Linear-Time Sequence Modeling with Selective State Spaces.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Mamba: Linear-Time Sequence Modeling with Selective State Spaces', 'publication_date_yy_mm': '2023-12'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6602.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e6602.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents that employ a memory mechanism to solve tasks, including details of the memory type, how it is accessed or updated, the tasks/benchmarks evaluated, performance with and without the memory, and any reported trade‑offs or limitations.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>S6</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Selective State Space Model (S6)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A time-varying (input-dependent) variant of structured state space layers where parameters that govern recurrence and read/write (Δ, B, C) are functions of the current input, enabling content-based selection into the recurrent state.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>S6 (Selective SSM layer)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>An SSM layer whose discretized parameters (overline{A}, overline{B}, C) vary per timestep because Δ, B, and C are outputs of small projections of the input; implements selective gating-like behavior for writing to and reading from the latent state, and is executed via a hardware-aware parallel scan.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>used as a layer inside models across reported scales (experiments with small models up to ≈2.8B Mamba models); per-layer state size N varied (e.g., N=1..16 in ablations)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>internal recurrent latent state (time-varying SSM memory)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>latent state vector h (per-channel, D×N), and time-varying SSM parameters (Δ_t, B_t, C_t) derived from input</td>
                        </tr>
                        <tr>
                            <td><strong>memory_access_mechanism</strong></td>
                            <td>recurrent scan update where Δ_t, B_t, C_t = s_Δ(x_t), s_B(x_t), s_C(x_t) determine how x_t is integrated into h_t and how h_t contributes to y_t; can reduce to explicit gating (Theorem 1) in scalar N=1 case</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Selective Copying; Induction Heads; Language modeling; DNA and audio pretraining tasks (used inside Mamba in all reported evaluations)</td>
                        </tr>
                        <tr>
                            <td><strong>task_category</strong></td>
                            <td>synthetic memory tasks; associative recall / in‑context learning; autoregressive modeling</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>Enables dramatic improvements over LTI SSMs: e.g., on Selective Copying and Induction Heads S6 variants achieve ≈97%–99.8% accuracy where S4 variants score ≈18.3%–57% depending on architecture. Language modeling ablation: replacing S4 with S6 lowers perplexity from ≈10.5 to ≈8.7 in comparable settings (≈350M models).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td>Non-selective (LTI) SSM (S4) baselines: substantially worse on content‑dependent tasks — examples: Selective Copying: S4 accuracy 18.3 (vs S6 97.0 in corresponding row); Induction Heads: S4 fails to generalize (>2×) whereas S6 generalizes to 1M.</td>
                        </tr>
                        <tr>
                            <td><strong>has_comparative_results</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td>Accuracy (synthetic), Perplexity (LM/DNA), NLL/BPB (audio), downstream generation metrics</td>
                        </tr>
                        <tr>
                            <td><strong>tradeoffs_reported</strong></td>
                            <td>Algorithmic: time-varying parameters preclude the convolutional fast path and require a scan; authors design kernel fusion, parallel scan, and recomputation to keep memory IO small and achieve competitive throughput. Selection is most effective when Δ is selective (primary) and synergizes with selective B and C. Increasing SSM state dimension N yields large gains only when B and C are also selective.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Selection can harm or not help modalities where LTI inductive biases are beneficial (continuous audio/video) unless using complex-valued parameterizations; selective SSMs require specialized implementation to be efficient (hardware-aware fused scan) and still break some conveniences of LTI convolutional computation.</td>
                        </tr>
                        <tr>
                            <td><strong>citation</strong></td>
                            <td>Albert Gu and Tri Dao. Mamba: Linear-Time Sequence Modeling with Selective State Spaces.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Mamba: Linear-Time Sequence Modeling with Selective State Spaces', 'publication_date_yy_mm': '2023-12'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6602.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e6602.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents that employ a memory mechanism to solve tasks, including details of the memory type, how it is accessed or updated, the tasks/benchmarks evaluated, performance with and without the memory, and any reported trade‑offs or limitations.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>S4</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Structured State Space (S4) / LTI SSM</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A prior class of structured state space layers with linear time-invariant (LTI) parameters enabling an equivalence between recurrence and global convolution; efficient via convolutional computation but lacks input-dependent content selection.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>S4 (LTI structured state space layer)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>An SSM with time-invariant discretized parameters (overline{A}, overline{B}, C) so the recurrence is linear time-invariant and can be computed as a global convolution for efficient parallel training; maintains a large latent state but cannot perform content-based selection into that state.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>used in ablations and baselines across model sizes in the paper (examples in small-to-medium scale experiments)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>internal recurrent latent state (LTI SSM)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>latent state h (per-channel D×N) with fixed (time-invariant) transition and read/write parameters</td>
                        </tr>
                        <tr>
                            <td><strong>memory_access_mechanism</strong></td>
                            <td>recurrence or equivalent global convolution with fixed parameters; no input-dependent writes/reads (no Δ_t/B_t/C_t functions of x_t)</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Selective Copying; Induction Heads; Language modeling ablations; baseline for DNA/audio experiments</td>
                        </tr>
                        <tr>
                            <td><strong>task_category</strong></td>
                            <td>synthetic memory/compression tasks; autoregressive modeling baselines</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>As an LTI memory, S4 can solve time-aware tasks (vanilla Copying) but fails at content-aware selective tasks: in reported results S4 variants achieve low accuracy on Selective Copying (example row: 18.3%) and perform substantially worse in induction and language-modeling ablations (perplexities ≈10.3–10.56 in comparable settings vs ≈8.7 with selective S6).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_comparative_results</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td>Accuracy (synthetic tasks); Perplexity (LM/DNA); NLL/BPB (audio)</td>
                        </tr>
                        <tr>
                            <td><strong>tradeoffs_reported</strong></td>
                            <td>Strength: supports convolutional computation (global convolution) enabling efficient parallel training and the ability to expand effective state dimension without materializing h. Weakness: inability to perform content-based selection; performance can degrade or fail on tasks requiring input-dependent filtering or associative recall.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Fails on content-dependent tasks such as Selective Copying and Induction Heads; cannot selectively ignore irrelevant inputs or reset state at boundaries, leading to worse long-context behavior on discrete modalities.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Mamba: Linear-Time Sequence Modeling with Selective State Spaces', 'publication_date_yy_mm': '2023-12'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Efficiently Modeling Long Sequences with Structured State Spaces <em>(Rating: 2)</em></li>
                <li>Hungry Hungry Hippos: Towards Language Modeling with State Space Models <em>(Rating: 2)</em></li>
                <li>Hyena Hierarchy: Towards Larger Convolutional Language Models <em>(Rating: 2)</em></li>
                <li>HyenaDNA: Long-range Genomic Sequence Modeling at Single Nucleotide Resolution <em>(Rating: 2)</em></li>
                <li>RWKV: Reinventing RNNs for the Transformer Era <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-6602",
    "paper_id": "paper-7bbc7595196a0606a07506c4fb1473e5e87f6082",
    "extraction_schema_id": "extraction-schema-127",
    "extracted_data": [
        {
            "name_short": "Mamba",
            "name_full": "Mamba (Selective SSM backbone)",
            "brief_description": "An attention-free sequence model architecture built from stacked selective state space layers (S6) that use an input-dependent recurrent latent state to store and retrieve context; designed for linear-time scaling and fast autoregressive inference.",
            "citation_title": "here",
            "mention_or_use": "use",
            "agent_name": "Mamba",
            "agent_description": "A homogeneous block architecture that integrates selective structured state space layers (S6) with lightweight projection/expansion layers. Memory is an internal recurrent SSM latent state (per-channel state of size N) whose update/read parameters (Δ, B, C) are computed as functions of the current input; the model thus performs content-aware writes/reads via gating-like selection.",
            "model_size": "various (experiments reported across ≈130M up to ≈2.8B parameters; Mamba-3B also referenced)",
            "memory_used": true,
            "memory_type": "internal recurrent latent state (structured state space model, SSM) with input-dependent selection (selective SSM / S6)",
            "memory_representation": "continuous hidden state vector h (per-channel state of dimension N, overall D×N per timestep), stored as real (default) or complex in some audio experiments",
            "memory_access_mechanism": "recurrent scan (autoregressive recurrence) where SSM parameters Δ_t, B_t, C_t are computed from the current input via small linear projections s(x); these parameters determine how much the current input is written into state and how state is exposed to outputs (e.g. reduces to gating: g_t = σ(Linear(x_t)), h_t = (1-g_t) h_{t-1} + g_t x_t in a special case)",
            "task_name": "Selective Copying; Induction Heads (associative recall); Language modeling (Pile pretraining, zero-shot downstream); DNA pretraining and long-context classification; Audio waveform modeling and autoregressive speech generation",
            "task_category": "synthetic memory/compression tasks; in‑context associative recall; autoregressive language modeling; genomics sequence modeling; audio generation",
            "performance_with_memory": "Selective Copying / Induction Heads: S6-enabled Mamba variants achieve very high accuracy (examples in paper: Mamba with S6: 99.8% accuracy on synthetic selective tasks / induction-heads-style tasks and generalizes to 1M token test lengths). Language modeling: Mamba (with S6) reported perplexities as low as 8.69 in ablations (≈350M setting) and competitive PPL across sizes (e.g., Mamba-1.4B Pile PPL 6.80 in Table 3). Audio: lower NLL/BPB and improved generation metrics (e.g., SC09: Mamba small 6.1M params NLL 1.852, FID 0.94; larger Mamba 24.3M NLL 1.860, FID 0.67). DNA/audio: pretraining perplexity and downstream metrics improve relative to baselines when using selection.",
            "performance_without_memory": "When using non-selective (LTI) SSMs (S4) or other non-selective layers, performance degrades substantially: Selective Copying — S4 variants report much lower accuracy (examples: S4 variants ~18.3% on the selective copying baseline vs S6 ≈97% in related rows); Language modeling ablation: same architecture with S4 inner layer yields perplexity ≈10.54–10.56 vs 8.69 with S6 (≈350M setting). Audio/DNA baselines (S4/Hyena/SaShiMi) show worse NLL/BPB or deteriorate with longer context where Mamba improves.",
            "has_comparative_results": true,
            "performance_metric": "Accuracy (synthetic tasks), Perplexity / NLL (language & DNA), Bits-per-byte (BPB) for audio pretraining, FID / IS / mlS for audio generation",
            "tradeoffs_reported": "Computation: selective (time-varying) SSMs cannot use the convolutional parallel computation path and require a recurrent scan; authors design a hardware-aware fused scan + recomputation to make it fast and memory efficient. Mamba achieves linear-time scaling and up to 4–5× higher autoregressive inference throughput compared to Transformers of similar size. Memory/IO: naive selective state expansion would be large (B×L×D×N) so the implementation stages discretization and recurrence in fast SRAM and avoids materializing expanded state; recomputation is used in backward pass. Modeling tradeoff: selection improves discrete, information-dense modalities and long-context performance, but may reduce some inductive biases beneficial for continuous modalities unless complex parameterizations are used.",
            "limitations_or_failure_cases": "Selective SSMs can impede performance on modalities where LTI SSM inductive biases help (continuous perceptual signals) unless complex-valued parameterizations are employed; the selective approach breaks convolutional-mode efficiency and necessitates careful hardware-aware implementations; scaling to very large model sizes (&gt; few billion) is not fully explored and may require further engineering; the paper notes a 'continuous–discrete spectrum' tradeoff where selection helps discrete data (text/DNA) but may hurt continuous data.",
            "citation": "Albert Gu and Tri Dao. Mamba: Linear-Time Sequence Modeling with Selective State Spaces.",
            "uuid": "e6602.0",
            "source_info": {
                "paper_title": "Mamba: Linear-Time Sequence Modeling with Selective State Spaces",
                "publication_date_yy_mm": "2023-12"
            }
        },
        {
            "name_short": "S6",
            "name_full": "Selective State Space Model (S6)",
            "brief_description": "A time-varying (input-dependent) variant of structured state space layers where parameters that govern recurrence and read/write (Δ, B, C) are functions of the current input, enabling content-based selection into the recurrent state.",
            "citation_title": "here",
            "mention_or_use": "use",
            "agent_name": "S6 (Selective SSM layer)",
            "agent_description": "An SSM layer whose discretized parameters (overline{A}, overline{B}, C) vary per timestep because Δ, B, and C are outputs of small projections of the input; implements selective gating-like behavior for writing to and reading from the latent state, and is executed via a hardware-aware parallel scan.",
            "model_size": "used as a layer inside models across reported scales (experiments with small models up to ≈2.8B Mamba models); per-layer state size N varied (e.g., N=1..16 in ablations)",
            "memory_used": true,
            "memory_type": "internal recurrent latent state (time-varying SSM memory)",
            "memory_representation": "latent state vector h (per-channel, D×N), and time-varying SSM parameters (Δ_t, B_t, C_t) derived from input",
            "memory_access_mechanism": "recurrent scan update where Δ_t, B_t, C_t = s_Δ(x_t), s_B(x_t), s_C(x_t) determine how x_t is integrated into h_t and how h_t contributes to y_t; can reduce to explicit gating (Theorem 1) in scalar N=1 case",
            "task_name": "Selective Copying; Induction Heads; Language modeling; DNA and audio pretraining tasks (used inside Mamba in all reported evaluations)",
            "task_category": "synthetic memory tasks; associative recall / in‑context learning; autoregressive modeling",
            "performance_with_memory": "Enables dramatic improvements over LTI SSMs: e.g., on Selective Copying and Induction Heads S6 variants achieve ≈97%–99.8% accuracy where S4 variants score ≈18.3%–57% depending on architecture. Language modeling ablation: replacing S4 with S6 lowers perplexity from ≈10.5 to ≈8.7 in comparable settings (≈350M models).",
            "performance_without_memory": "Non-selective (LTI) SSM (S4) baselines: substantially worse on content‑dependent tasks — examples: Selective Copying: S4 accuracy 18.3 (vs S6 97.0 in corresponding row); Induction Heads: S4 fails to generalize (&gt;2×) whereas S6 generalizes to 1M.",
            "has_comparative_results": true,
            "performance_metric": "Accuracy (synthetic), Perplexity (LM/DNA), NLL/BPB (audio), downstream generation metrics",
            "tradeoffs_reported": "Algorithmic: time-varying parameters preclude the convolutional fast path and require a scan; authors design kernel fusion, parallel scan, and recomputation to keep memory IO small and achieve competitive throughput. Selection is most effective when Δ is selective (primary) and synergizes with selective B and C. Increasing SSM state dimension N yields large gains only when B and C are also selective.",
            "limitations_or_failure_cases": "Selection can harm or not help modalities where LTI inductive biases are beneficial (continuous audio/video) unless using complex-valued parameterizations; selective SSMs require specialized implementation to be efficient (hardware-aware fused scan) and still break some conveniences of LTI convolutional computation.",
            "citation": "Albert Gu and Tri Dao. Mamba: Linear-Time Sequence Modeling with Selective State Spaces.",
            "uuid": "e6602.1",
            "source_info": {
                "paper_title": "Mamba: Linear-Time Sequence Modeling with Selective State Spaces",
                "publication_date_yy_mm": "2023-12"
            }
        },
        {
            "name_short": "S4",
            "name_full": "Structured State Space (S4) / LTI SSM",
            "brief_description": "A prior class of structured state space layers with linear time-invariant (LTI) parameters enabling an equivalence between recurrence and global convolution; efficient via convolutional computation but lacks input-dependent content selection.",
            "citation_title": "",
            "mention_or_use": "use",
            "agent_name": "S4 (LTI structured state space layer)",
            "agent_description": "An SSM with time-invariant discretized parameters (overline{A}, overline{B}, C) so the recurrence is linear time-invariant and can be computed as a global convolution for efficient parallel training; maintains a large latent state but cannot perform content-based selection into that state.",
            "model_size": "used in ablations and baselines across model sizes in the paper (examples in small-to-medium scale experiments)",
            "memory_used": true,
            "memory_type": "internal recurrent latent state (LTI SSM)",
            "memory_representation": "latent state h (per-channel D×N) with fixed (time-invariant) transition and read/write parameters",
            "memory_access_mechanism": "recurrence or equivalent global convolution with fixed parameters; no input-dependent writes/reads (no Δ_t/B_t/C_t functions of x_t)",
            "task_name": "Selective Copying; Induction Heads; Language modeling ablations; baseline for DNA/audio experiments",
            "task_category": "synthetic memory/compression tasks; autoregressive modeling baselines",
            "performance_with_memory": "As an LTI memory, S4 can solve time-aware tasks (vanilla Copying) but fails at content-aware selective tasks: in reported results S4 variants achieve low accuracy on Selective Copying (example row: 18.3%) and perform substantially worse in induction and language-modeling ablations (perplexities ≈10.3–10.56 in comparable settings vs ≈8.7 with selective S6).",
            "performance_without_memory": null,
            "has_comparative_results": true,
            "performance_metric": "Accuracy (synthetic tasks); Perplexity (LM/DNA); NLL/BPB (audio)",
            "tradeoffs_reported": "Strength: supports convolutional computation (global convolution) enabling efficient parallel training and the ability to expand effective state dimension without materializing h. Weakness: inability to perform content-based selection; performance can degrade or fail on tasks requiring input-dependent filtering or associative recall.",
            "limitations_or_failure_cases": "Fails on content-dependent tasks such as Selective Copying and Induction Heads; cannot selectively ignore irrelevant inputs or reset state at boundaries, leading to worse long-context behavior on discrete modalities.",
            "uuid": "e6602.2",
            "source_info": {
                "paper_title": "Mamba: Linear-Time Sequence Modeling with Selective State Spaces",
                "publication_date_yy_mm": "2023-12"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Efficiently Modeling Long Sequences with Structured State Spaces",
            "rating": 2
        },
        {
            "paper_title": "Hungry Hungry Hippos: Towards Language Modeling with State Space Models",
            "rating": 2
        },
        {
            "paper_title": "Hyena Hierarchy: Towards Larger Convolutional Language Models",
            "rating": 2
        },
        {
            "paper_title": "HyenaDNA: Long-range Genomic Sequence Modeling at Single Nucleotide Resolution",
            "rating": 2
        },
        {
            "paper_title": "RWKV: Reinventing RNNs for the Transformer Era",
            "rating": 1
        }
    ],
    "cost": 0.0205415,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Mamba: Linear-Time Sequence Modeling with Selective State Spaces</h1>
<p>Albert Gu ${ }^{\star 1}$ and Tri Dao ${ }^{\star 2}$<br>${ }^{1}$ Machine Learning Department, Carnegie Mellon University<br>${ }^{2}$ Department of Computer Science, Princeton University<br>agu@cs.cmu.edu, tri@tridao.me</p>
<h4>Abstract</h4>
<p>Foundation models, now powering most of the exciting applications in deep learning, are almost universally based on the Transformer architecture and its core attention module. Many subquadratic-time architectures such as linear attention, gated convolution and recurrent models, and structured state space models (SSMs) have been developed to address Transformers' computational inefficiency on long sequences, but they have not performed as well as attention on important modalities such as language. We identify that a key weakness of such models is their inability to perform content-based reasoning, and make several improvements. First, simply letting the SSM parameters be functions of the input addresses their weakness with discrete modalities, allowing the model to selectively propagate or forget information along the sequence length dimension depending on the current token. Second, even though this change prevents the use of efficient convolutions, we design a hardware-aware parallel algorithm in recurrent mode. We integrate these selective SSMs into a simplified end-to-end neural network architecture without attention or even MLP blocks (Mamba). Mamba enjoys fast inference ( $5 \times$ higher throughput than Transformers) and linear scaling in sequence length, and its performance improves on real data up to million-length sequences. As a general sequence model backbone, Mamba achieves state-of-the-art performance across several modalities such as language, audio, and genomics. On language modeling, our Mamba-3B model outperforms Transformers of the same size and matches Transformers twice its size, both in pretraining and downstream evaluation.</p>
<h2>1 Introduction</h2>
<p>Foundation models (FMs), or large models pretrained on massive data then adapted for downstream tasks, have emerged as an effective paradigm in modern machine learning. The backbone of these FMs are often sequence models, operating on arbitrary sequences of inputs from a wide variety of domains such as language, images, speech, audio, time series, and genomics (Brown et al. 2020; Dosovitskiy et al. 2020; Ismail Fawaz et al. 2019; Oord et al. 2016; Poli et al. 2023; Sutskever, Vinyals, and Quoc V Le 2014). While this concept is agnostic to a particular choice of model architecture, modern FMs are predominantly based on a single type of sequence model: the Transformer (Vaswani et al. 2017) and its core attention layer (Bahdanau, Cho, and Bengio 2015) The efficacy of self-attention is attributed to its ability to route information densely within a context window, allowing it to model complex data. However, this property brings fundamental drawbacks: an inability to model anything outside of a finite window, and quadratic scaling with respect to the window length. An enormous body of research has appeared on more efficient variants of attention to overcome these drawbacks (Tay, Dehghani, Bahri, et al. 2022), but often at the expense of the very properties that makes it effective. As of yet, none of these variants have been shown to be empirically effective at scale across domains.</p>
<p>Recently, structured state space sequence models (SSMs) (Gu, Goel, and Ré 2022; Gu, Johnson, Goel, et al. 2021) have emerged as a promising class of architectures for sequence modeling. These models can be interpreted as a combination of recurrent neural networks (RNNs) and convolutional neural networks (CNNs), with inspiration from classical state space models (Kalman 1960). This class of models can be computed very efficiently as either a recurrence or convolution, with linear or near-linear scaling in sequence length. Additionally, they have principled mechanisms for modeling long-range dependencies (Gu, Dao, et al. 2020) in certain data modalities, and have dominated benchmarks such as the Long Range</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>Arena (Tay, Dehghani, Abnar, et al. 2021). Many flavors of SSMs (Gu, Goel, and Ré 2022; Gu, Gupta, et al. 2022; Gupta, Gu, and Berant 2022; Y. Li et al. 2023; Ma et al. 2023; Orvieto et al. 2023; Smith, Warrington, and Linderman 2023) have been successful in domains involving continuous signal data such as audio and vision (Goel et al. 2022; Nguyen, Goel, et al. 2022; Saon, Gupta, and Cui 2023). However, they have been less effective at modeling discrete and information-dense data such as text.</p>
<p>We propose a new class of selective state space models, that improves on prior work on several axes to achieve the modeling power of Transformers while scaling linearly in sequence length.</p>
<p>Selection Mechanism. First, we identify a key limitation of prior models: the ability to efficiently select data in an input-dependent manner (i.e. focus on or ignore particular inputs). Building on intuition based on important synthetic tasks such as selective copy and induction heads, we design a simple selection mechanism by parameterizing the SSM parameters based on the input. This allows the model to filter out irrelevant information and remember relevant information indefinitely.</p>
<p>Hardware-aware Algorithm. This simple change poses a technical challenge for the computation of the model; in fact, all prior SSMs models must be time- and input-invariant in order to be computationally efficient. We overcome this with a hardware-aware algorithm that computes the model recurrently with a scan instead of convolution, but does not materialize the expanded state in order to avoid IO access between different levels of the GPU memory hierarchy. The resulting implementation is faster than previous methods both in theory (scaling linearly in sequence length, compared to pseudo-linear for all convolution-based SSMs) and on modern hardware (up to $3 \times$ faster on A100 GPUs).</p>
<p>Architecture. We simplify prior deep sequence model architectures by combining the design of prior SSM architectures (Dao, Fu, Saab, et al. 2023) with the MLP block of Transformers into a single block, leading to a simple and homogenous architecture design (Mamba) incorporating selective state spaces.</p>
<p>Selective SSMs, and by extension the Mamba architecture, are fully recurrent models with key properties that make them suitable as the backbone of general foundation models operating on sequences. (i) High quality: selectivity brings strong performance on dense modalities such as language and genomics. (ii) Fast training and inference: computation and memory scales linearly in sequence length during training, and unrolling the model autoregressively during inference requires only constant time per step since it does not require a cache of previous elements. (iii) Long context: the quality and efficiency together yield performance improvements on real data up to sequence length 1 M .</p>
<p>We empirically validate Mamba's potential as a general sequence FM backbone, in both pretraining quality and domainspecific task performance, on several types of modalities and settings:</p>
<ul>
<li>Synthetics. On important synthetic tasks such as copying and induction heads that have been proposed as being key to large language models, Mamba not only solves them easily but can extrapolate solutions indefinitely long ( $&gt;1 \mathrm{M}$ tokens).</li>
<li>Audio and Genomics. Mamba out-performs prior state-of-the-art models such as SaShiMi, Hyena, and Transformers on modeling audio waveforms and DNA sequences, both in pretraining quality and downstream metrics (e.g. reducing FID on a challenging speech generation dataset by more than half). In both settings, its performance improves with longer context up to million-length sequences.</li>
<li>Language Modeling. Mamba is the first linear-time sequence model that truly achieves Transformer-quality performance, both in pretraining perplexity and downstream evaluations. With scaling laws up to 1B parameters, we show that Mamba exceeds the performance of a large range of baselines, including very strong modern Transformer training recipes based on LLaMa (Touvron et al. 2023). Our Mamba language model has $5 \times$ generation throughput compared to Transformers of similar size, and Mamba-3B's quality matches that of Transformers twice its size (e.g. 4 points higher avg. on common sense reasoning compared to Pythia-3B and even exceeding Pythia-7B).</li>
</ul>
<p>Model code and pre-trained checkpoints are open-sourced at https://github.com/state-spaces/mamba.</p>
<h1>2 State Space Models</h1>
<p>Structured state space sequence models (S4) are a recent class of sequence models for deep learning that are broadly related to RNNs, and CNNs, and classical state space models. They are inspired by a particular continuous system (1) that maps a</p>
<h1>Selective State Space Model <br> with Hardware-aware State Expansion</h1>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: (Overview.) Structured SSMs independently map each channel (e.g. $D=5$ ) of an input $x$ to output $y$ through a higher dimensional latent state $h$ (e.g. $N=4$ ). Prior SSMs avoid materializing this large effective state ( $D N$, times batch size $B$ and sequence length $L$ ) through clever alternate computation paths requiring time-invariance: the $(\Delta, \boldsymbol{A}, \boldsymbol{B}, \boldsymbol{C})$ parameters are constant across time. Our selection mechanism adds back input-dependent dynamics, which also requires a careful hardware-aware algorithm to only materialize the expanded states in more efficient levels of the GPU memory hierarchy.</p>
<p>1-dimensional function or sequence $x(t) \in \mathbb{R} \mapsto y(t) \in \mathbb{R}$ through an implicit latent state $h(t) \in \mathbb{R}^{N}$.
Concretely, S4 models are defined with four parameters $(\Delta, \boldsymbol{A}, \boldsymbol{B}, \boldsymbol{C})$, which define a sequence-to-sequence transformation in two stages.</p>
<p>$$
\begin{aligned}
&amp; h^{\prime}(t)=\boldsymbol{A} h(t)+\boldsymbol{B} x(t) \
&amp; h_{t}=\overline{\boldsymbol{A}} h_{t-1}+\overline{\boldsymbol{B}} x_{t} \
&amp; y(t)=C h(t) \
&amp; y_{t}=C h_{t} \
&amp; \text { (2a) } \quad \overline{\boldsymbol{K}}=(C \overline{\boldsymbol{B}}, C \overline{\boldsymbol{A} \boldsymbol{B}}, \ldots, C \overline{\boldsymbol{A}} \bar{B}, \ldots) \
&amp; y=x * \overline{\boldsymbol{K}}
\end{aligned}
$$</p>
<p>Discretization. The first stage transforms the "continuous parameters" $(\Delta, \boldsymbol{A}, \boldsymbol{B})$ to "discrete parameters" $(\overline{\boldsymbol{A}}, \overline{\boldsymbol{B}})$ through fixed formulas $\overline{\boldsymbol{A}}=f_{A}(\Delta, \boldsymbol{A})$ and $\overline{\boldsymbol{B}}=f_{B}(\Delta, \boldsymbol{A}, \boldsymbol{B})$, where the pair $\left(f_{A}, f_{B}\right)$ is called a discretization rule. Various rules can be used such as the zero-order hold (ZOH) defined in equation (4).</p>
<p>$$
\overline{\boldsymbol{A}}=\exp (\Delta \boldsymbol{A}) \quad \overline{\boldsymbol{B}}=(\Delta \boldsymbol{A})^{-1}(\exp (\Delta \boldsymbol{A})-\boldsymbol{I}) \cdot \Delta \boldsymbol{B}
$$</p>
<p>Discretization has deep connections to continuous-time systems which can endow them with additional properties such as resolution invariance (Nguyen, Goel, et al. 2022) and automatically ensuring that the model is properly normalized (Gu, Johnson, Timalsina, et al. 2023; Orvieto et al. 2023). It also has connections to gating mechanisms of RNNs (Gu, Gulcehre, et al. 2020; Tallec and Ollivier 2018) which we will revisit in Section 3.5. However, from a mechanical point of view discretization can simply be viewed as the first step of the computation graph in the forward pass of an SSM. Alternate flavors of SSMs can bypass the discretization step and parameterize $(\overline{\boldsymbol{A}}, \overline{\boldsymbol{B}})$ directly instead (Zhang et al. 2023), which may be easier to reason about.</p>
<p>Computation. After the parameters have been transformed from $(\Delta, \boldsymbol{A}, \boldsymbol{B}, \boldsymbol{C}) \mapsto(\overline{\boldsymbol{A}}, \overline{\boldsymbol{B}}, \boldsymbol{C})$, the model can be computed in two ways, either as a linear recurrence (2) or a global convolution (3).</p>
<p>Commonly, the model uses the convolutional mode (3) for efficient parallelizable training (where the whole input sequence is seen ahead of time), and switched into recurrent mode (2) for efficient autoregressive inference (where the inputs are seen one timestep at a time).</p>
<p>Linear Time Invariance (LTI). An important property of equations (1) to (3) is that the model's dynamics are constant through time. In other words $(\Delta, \boldsymbol{A}, \boldsymbol{B}, \boldsymbol{C})$, and consequently $(\overline{\boldsymbol{A}}, \overline{\boldsymbol{B}})$ as well, are fixed for all time-steps. This property is</p>
<p>called linear time invariance (LTI), which is deeply connected to recurrence and convolutions. Informally, we think of LTI SSMs as being equivalent to any linear recurrence (2a) or convolution (3b), and use LTI as an umbrella term for these classes of models.</p>
<p>Thus far, all structured SSMs have been LTI (e.g. computed as convolutions) because of fundamental efficiency constraints, discussed in Section 3.3. However, a core insight of this work is that LTI models have fundamental limitations in modeling certain types of data, and our technical contributions involve removing the LTI constraint while overcoming the efficiency bottlenecks.</p>
<p>Structure and Dimensions. Finally, we note that structured SSMs are so named because computing them efficiently also requires imposing structure on the $\boldsymbol{A}$ matrix. The most popular form of structure is diagonal (Gu, Gupta, et al. 2022; Gupta, Gu, and Berant 2022; Smith, Warrington, and Linderman 2023), which we also use.
In this case, the $\boldsymbol{A} \in \mathbb{R}^{N \times N}, \boldsymbol{B} \in \mathbb{R}^{N \times 1}, \boldsymbol{C} \in \mathbb{R}^{1 \times N}$ matrices can all be represented by $N$ numbers. To operate over an input sequence $x$ of batch size $B$ and length $L$ with $D$ channels, the SSM is applied independently to each channel. Note that in this case, the total hidden state has dimension $D N$ per input, and computing it over the sequence length requires $O(B L D N)$ time and memory; this is the root of the fundamental efficiency bottleneck addressed in Section 3.3.</p>
<p>General State Space Models. We note that the term state space model has a very broad meaning which simply represents the notion of any recurrent process with a latent state. It has been used to refer to many disparate concepts in different disciplines, including Markov decision processes (MDP) (reinforcement learning (Hafner et al. 2020)), dynamic causal modeling (DCM) (computational neuroscience (Friston, Harrison, and Penny 2003)), Kalman filters (controls (Kalman 1960)), hidden Markov models (HMM) and linear dynamical systems (LDS) (machine learning), and recurrent (and sometimes convolutional) models at large (deep learning).</p>
<p>Throughout this entire paper we use the term "SSM" to refer exclusively to the class of structured SSMs or S4 models (Gu, Goel, and Ré 2022; Gu, Gupta, et al. 2022; Gupta, Gu, and Berant 2022; Hasani et al. 2023; Ma et al. 2023; Smith, Warrington, and Linderman 2023) and use these terms interchangeably. For convenience we may also include derivatives of such models, such as those focusing on either the linear-recurrence or global-convolution viewpoints (Y. Li et al. 2023; Orvieto et al. 2023; Poli et al. 2023), and clarify nuances when necessary.</p>
<p>SSM Architectures. SSMs are standalone sequence transformations that can be incorporated into end-to-end neural network architectures. (We also sometimes call SSM architectures SSNNs, which are to SSM layers as CNNs are to linear convolution layers.) We discuss some of the most well-known SSM architectures, many of which will also serve as our primary baselines.</p>
<ul>
<li>Linear attention (Katharopoulos et al. 2020) is an approximation of self-attention involving a recurrence which can be viewed as a degenerate linear SSM.</li>
<li>H3 (Dao, Fu, Saab, et al. 2023) generalized this recurrence to use S4; it can be viewed as an architecture with an SSM sandwiched by two gated connections (Figure 3). H3 also inserts a standard local convolution, which they frame as a shift-SSM, before the main SSM layer.</li>
<li>Hyena (Poli et al. 2023) uses the same architecture as H3 but replaces the S4 layer with an MLP-parameterized global convolution (Romero et al. 2021).</li>
<li>RetNet (Y. Sun et al. 2023) adds an additional gate to the architecture and uses a simpler SSM, allowing an alternative parallelizable computation path, using a variant of multi-head attention (MHA) instead of convolutions.</li>
<li>RWKV (B. Peng et al. 2023) is a recent RNN designed for language modeling based on another linear attention approximation, the attention-free Transformer (S. Zhai et al. 2021). Its main "WKV" mechanism involves LTI recurrences and can be viewed as the ratio of two SSMs.</li>
</ul>
<p>Other closely related SSMs and architectures are discussed further in an extended related work (Appendix B). We highlight in particular S5 (Smith, Warrington, and Linderman 2023), QRNN (Bradbury et al. 2016), and SRU (Lei et al. 2017), which we view as the most closely related methods to our core selective SSM.</p>
<h1>3 Selective State Space Models</h1>
<p>We motivate our selection mechanism using intuition from synthetic tasks (Section 3.1), then explain how to incorporate this mechanism into state space models (Section 3.2). The resulting time-varying SSMs cannot use convolutions, presenting a technical challenge of how to compute them efficiently. We overcome this with a hardware-aware algorithm that exploits the memory hierarchy on modern hardware (Section 3.3). We then describe a simple SSM architecture without attention or even MLP blocks (Section 3.4). Finally, we discuss some additional properties of selection mechanisms (Section 3.5).</p>
<h3>3.1 Motivation: Selection as a Means of Compression</h3>
<p>We argue that a fundamental problem of sequence modeling is compressing context into a smaller state. In fact, we can view the tradeoffs of popular sequence models from this point of view. For example, attention is both effective and inefficient because it explicitly does not compress context at all. This can be seen from the fact that autoregressive inference requires explicitly storing the entire context (i.e. the KV cache), which directly causes the slow linear-time inference and quadratic-time training of Transformers. On the other hand, recurrent models are efficient because they have a finite state, implying constant-time inference and linear-time training. However, their effectiveness is limited by how well this state has compressed the context.</p>
<p>To understand this principle, we focus on two running examples of synthetic tasks (Figure 2).</p>
<ul>
<li>The Selective Copying task modifies the popular Copying task (Arjovsky, Shah, and Bengio 2016) by varying the position of the tokens to memorize. It requires content-aware reasoning to be able to memorize the relevant tokens (colored) and filter out the irrelevant ones (white).</li>
<li>The Induction Heads task is a well-known mechanism hypothesized to explain the majority of in-context learning abilities of LLMs (Olsson et al. 2022). It requires context-aware reasoning to know when to produce the correct output in the appropriate context (black).</li>
</ul>
<p>These tasks reveal the failure mode of LTI models. From the recurrent view, their constant dynamics (e.g. the $(\overline{\boldsymbol{A}}, \overline{\boldsymbol{B}})$ transitions in (2)) cannot let them select the correct information from their context, or affect the hidden state passed along the sequence in an input-dependent way. From the convolutional view, it is known that global convolutions can solve the vanilla Copying task (Romero et al. 2021) because it only requires time-awareness, but that they have difficulty with the Selective Copying task because of lack of content-awareness (Figure 2). More concretely, the spacing between inputs-to-outputs is varying and cannot be modeled by static convolution kernels.</p>
<p>In summary, the efficiency vs. effectiveness tradeoff of sequence models is characterized by how well they compress their state: efficient models must have a small state, while effective models must have a state that contains all necessary information from the context. In turn, we propose that a fundamental principle for building sequence models is selectivity: or the context-aware ability to focus on or filter out inputs into a sequential state. In particular, a selection mechanism controls how information propagates or interacts along the sequence dimension (see Section 3.5 for more discussion).</p>
<h3>3.2 Improving SSMs with Selection</h3>
<p>One method of incorporating a selection mechanism into models is by letting their parameters that affect interactions along the sequence (e.g. the recurrent dynamics of an RNN or the convolution kernel of a CNN) be input-dependent.</p>
<p>Algorithms 1 and 2 illustrates the main selection mechanism that we use. The main difference is simply making several parameters $\Delta, \boldsymbol{B}, \boldsymbol{C}$ functions of the input, along with the associated changes to tensor shapes throughout. In particular, we highlight that these parameters now have a length dimension $L$, meaning that the model has changed from time-invariant to time-varying. (Note that shape annotations were described in Section 2.) This loses the equivalence to convolutions (3) with implications for its efficiency, discussed next.</p>
<p>We specifically choose $s_{B}(x)=\operatorname{Linear}<em C="C">{N}(x), s</em>}(x)=\operatorname{Linear<em _Delta="\Delta">{N}(x), s</em>}(x)=\operatorname{Broadcast<em 1="1">{D}\left(\operatorname{Linear}</em>=$ softplus, where Linear $}(x)\right)$, and $\tau_{\Delta<em _Delta="\Delta">{d}$ is a parameterized projection to dimension $d$. The choice of $s</em>$ is due to a connection to RNN gating mechanisms explained in Section 3.5.}$ and $\tau_{\Delta</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: (Left) The standard version of the Copying task involves constant spacing between input and output elements and is easily solved by time-invariant models such as linear recurrences and global convolutions. (Right Top) The Selective Copying task has random spacing in between inputs and requires time-varying models that can selectively remember or ignore inputs depending on their content. (Right Bottom) The Induction Heads task is an example of associative recall that requires retrieving an answer based on context, a key ability for LLMs.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Algorithm 1 SSM (S4)</th>
<th style="text-align: center;">Algorithm 2 SSM + Selection (S6)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Input: $x:(B, L, D)$</td>
<td style="text-align: center;">Input: $x:(B, L, D)$</td>
</tr>
<tr>
<td style="text-align: center;">Output: $y:(B, L, D)$</td>
<td style="text-align: center;">Output: $y:(B, L, D)$</td>
</tr>
<tr>
<td style="text-align: center;">$A:(D, N) \leftarrow$ Parameter</td>
<td style="text-align: center;">$A:(D, N) \leftarrow$ Parameter</td>
</tr>
<tr>
<td style="text-align: center;">$\rightarrow$ Represents structured $N \times N$ matrix</td>
<td style="text-align: center;">$\rightarrow$ Represents structured $N \times N$ matrix</td>
</tr>
<tr>
<td style="text-align: center;">$B:(D, N) \leftarrow$ Parameter</td>
<td style="text-align: center;">$B:(B, L, N) \leftarrow s_{B}(x)$</td>
</tr>
<tr>
<td style="text-align: center;">$C:(D, N) \leftarrow$ Parameter</td>
<td style="text-align: center;">$C:(B, L, N) \leftarrow s_{C}(x)$</td>
</tr>
<tr>
<td style="text-align: center;">$\Delta:(D) \leftarrow \tau_{\Delta}($ Parameter)</td>
<td style="text-align: center;">$\Delta:(\mathrm{B}, \mathrm{L}, \mathrm{D}) \leftarrow \tau_{\Delta}($ Parameter $+s_{\Delta}(x))$</td>
</tr>
<tr>
<td style="text-align: center;">$\overline{\boldsymbol{A}}, \overline{\boldsymbol{B}}:(D, N) \leftarrow$ discretize $(\Delta, \boldsymbol{A}, \boldsymbol{B})$</td>
<td style="text-align: center;">$\overline{\boldsymbol{A}}, \overline{\boldsymbol{B}}:(\mathrm{B}, \mathrm{L}, \mathrm{D}, \mathrm{N}) \leftarrow$ discretize $(\Delta, \boldsymbol{A}, \boldsymbol{B})$</td>
</tr>
<tr>
<td style="text-align: center;">$y \leftarrow \operatorname{SSM}(\overline{\boldsymbol{A}}, \overline{\boldsymbol{B}}, C)(x)$ <br> $\rightarrow$ Time-invariant: recurrence or convolution</td>
<td style="text-align: center;">$y \leftarrow \operatorname{SSM}(\overline{\boldsymbol{A}}, \overline{\boldsymbol{B}}, C)(x)$ <br> $\rightarrow$ Time-varying: recurrence (scan) only</td>
</tr>
<tr>
<td style="text-align: center;">7: return $y$</td>
<td style="text-align: center;">7: return $y$</td>
</tr>
</tbody>
</table>
<h1>3.3 Efficient Implementation of Selective SSMs</h1>
<p>Hardware-friendly primitives such as convolutions (Krizhevsky, Sutskever, and Hinton 2012) and attention (Bahdanau, Cho, and Bengio 2015; Vaswani et al. 2017) enjoy widespread application. Here we aim to make selective SSMs efficient on modern hardware (GPUs) as well. The selection mechanism is quite natural, and earlier works attempted to incorporate special cases of selection, such as letting $\Delta$ vary over time in recurrent SSMs (Gu, Dao, et al. 2020). However, as previously mentioned a core limitation in the usage of SSMs is their computational efficiency, which was why S4 and all derivatives used LTI (non-selective) models, most commonly in the form of global convolutions.</p>
<h3>3.3.1 Motivation of Prior Models</h3>
<p>We first revisit this motivation and overview our approach to overcome limitations of prior methods.</p>
<ul>
<li>At a high level, recurrent models such as SSMs always balance a tradeoff between expressivity and speed: as discussed in Section 3.1, models with larger hidden state dimension should be more effective but slower. Thus we want to maximize hidden state dimension without paying speed and memory costs.</li>
<li>Note that the recurrent mode is more flexible than the convolution mode, since the latter (3) is derived from expanding the former (2) (Gu, Goel, and Ré 2022; Gu, Johnson, Goel, et al. 2021). However, this would require computing and materializing the latent state $h$ with shape ( $B, L, D, N$ ), which is much larger (by a factor of $N$, the SSM state dimension) than the input $x$ and output $y$ of shape ( $B, L, D$ ). Thus the more efficient convolution mode was introduced which could bypass the state computation and materializes a convolution kernel (3a) of size only (B, L, D).</li>
<li>Prior LTI state space models leverage the dual recurrent-convolutional forms to increase the effective state dimension by a factor of $N(\approx 10-100)$, much larger than traditional RNNs, without efficiency penalties.</li>
</ul>
<h1>3.3.2 Overview of Selective Scan: Hardware-Aware State Expansion</h1>
<p>The selection mechanism is designed to overcome the limitations of LTI models; at the same time, we therefore need to revisit the computation problem of SSMs. We address this with three classical techniques: kernel fusion, parallel scan, and recomputation. We make two main observations:</p>
<ul>
<li>The naive recurrent computation uses $O(B L D N)$ FLOPs while the convolutional computation uses $O(B L D \log (L))$ FLOPs, and the former has a lower constant factor. Thus for long sequences and not-too-large state dimension $N$, the recurrent mode can actually use fewer FLOPs.</li>
<li>The two challenges are the sequential nature of recurrence, and the large memory usage. To address the latter, just like the convolutional mode, we can attempt to not actually materialize the full state $h$.</li>
</ul>
<p>The main idea is to leverage properties of modern accelerators (GPUs) to materialize the state $h$ only in more efficient levels of the memory hierarchy. In particular, most operations (except matrix multiplication) are bounded by memory bandwidth (Dao, Fu, Ermon, et al. 2022; Ivanov et al. 2021; Williams, Waterman, and Patterson 2009). This includes our scan operation, and we use kernel fusion to reduce the amount of memory IOs, leading to a significant speedup compared to a standard implementation.</p>
<p>Concretely, instead of preparing the scan input $(\overline{\boldsymbol{A}}, \overline{\boldsymbol{B}})$ of size (B, L, D, N) in GPU HBM (high-bandwidth memory), we load the SSM parameters $(\Delta, \boldsymbol{A}, \boldsymbol{B}, \boldsymbol{C})$ directly from slow HBM to fast SRAM, perform the discretization and recurrence in SRAM, and then write the final outputs of size (B, L, D) back to HBM.</p>
<p>To avoid the sequential recurrence, we observe that despite not being linear it can still be parallelized with a work-efficient parallel scan algorithm (Blelloch 1990; Martin and Cundy 2018; Smith, Warrington, and Linderman 2023).</p>
<p>Finally, we must also avoid saving the intermediate states, which are necessary for backpropagation. We carefully apply the classic technique of recomputation to reduce the memory requirements: the intermediate states are not stored but recomputed in the backward pass when the inputs are loaded from HBM to SRAM. As a result, the fused selective scan layer has the same memory requirements as an optimized transformer implementation with FlashAttention.</p>
<p>Details of the fused kernel and recomputation are in Appendix D. The full Selective SSM layer and algorithm is illustrated in Figure 1.</p>
<h3>3.4 A Simplified SSM Architecture</h3>
<p>As with structured SSMs, selective SSMs are standalone sequence transformations that can be flexibly incorporated into neural networks. The H3 architecture is the basis for the most well-known SSM architectures (Section 2), which are generally comprised of a block inspired by linear attention interleaved with an MLP (multi-layer perceptron) block. We simplify this architecture by combining these two components into one, which is stacked homogenously (Figure 3). This is inspired by the gated attention unit (GAU) (Hua et al. 2022), which did something similar for attention.</p>
<p>This architecture involves expanding the model dimension $D$ by a controllable expansion factor $E$. For each block, most of the parameters ( $3 E D^{2}$ ) are in the linear projections ( $2 E D^{2}$ for input projections, $E D^{2}$ for output projection) while the inner SSM contributes less. The number of SSM parameters (projections for $\Delta, \boldsymbol{B}, \boldsymbol{C}$, and the matrix $\boldsymbol{A}$ ) are much smaller in comparison. We repeat this block, interleaved with standard normalization and residual connections, to form the Mamba architecture. We always fix to $E=2$ in our experiments and use two stacks of the block to match the $12 D^{2}$ parameters of a Transformer's interleaved MHA (multi-head attention) and MLP blocks. We use the SiLU / Swish activation function (Hendrycks and Gimpel 2016; Ramachandran, Zoph, and Quoc V Le 2017), motivated so that the Gated MLP becomes the popular "SwiGLU" variant (Chowdhery et al. 2023; Dauphin et al. 2017; Shazeer 2020; Touvron et al. 2023). Finally, we additionally use an optional normalization layer (we choose LayerNorm (J. L. Ba, Kiros, and Hinton 2016)), motivated by RetNet's usage of a normalization layer in a similar location (Y. Sun et al. 2023).</p>
<h3>3.5 Properties of Selection Mechanisms</h3>
<p>The selection mechanism is a broader concept that can be applied in different ways, such as to more traditional RNNs or CNNs, to different parameters (e.g. $\boldsymbol{A}$ in Algorithm 2), or using different transformations $s(x)$.</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: (Architecture.) Our simplified block design combines the H3 block, which is the basis of most SSM architectures, with the ubiquitous MLP block of modern neural networks. Instead of interleaving these two blocks, we simply repeat the Mamba block homogenously. Compared to the H3 block, Mamba replaces the first multiplicative gate with an activation function. Compared to the MLP block, Mamba adds an SSM to the main branch. For $\sigma$ we use the SiLU / Swish activation (Hendrycks and Gimpel 2016; Ramachandran, Zoph, and Quoc V Le 2017).</p>
<h1>3.5.1 Connection to Gating Mechanisms</h1>
<p>We highlight the most important connection: the classical gating mechanism of RNNs is an instance of our selection mechanism for SSMs. We note that the connection between RNN gating and the discretization of continuous-time systems is well established (Funahashi and Nakamura 1993; Tallec and Ollivier 2018). In fact, Theorem 1 is an improvement of Gu, Johnson, Goel, et al. (2021, Lemma 3.1) generalizing to the ZOH discretization and input-dependent gates (proof in Appendix C). More broadly, $\Delta$ in SSMs can be seen to play a generalized role of the RNN gating mechanism. In line with prior work, we adopt the view that discretization of SSMs is the principled foundation of heuristic gating mechanisms.</p>
<p>Theorem 1. When $N=1, \boldsymbol{A}=-1, \boldsymbol{B}=1, s_{\Delta}=\operatorname{Linear}(x)$, and $\tau_{\Delta}=$ softplus, then the selective SSM recurrence (Algorithm 2) takes the form</p>
<p>$$
\begin{aligned}
&amp; g_{t}=\sigma\left(\operatorname{Linear}\left(x_{t}\right)\right) \
&amp; h_{t}=\left(1-g_{t}\right) h_{t-1}+g_{t} x_{t}
\end{aligned}
$$</p>
<p>As mentioned in Section 3.2, our specific choices of $s_{\Delta}, \tau_{\Delta}$ is from this connection. In particular, note that if a given input $x_{t}$ should be completely ignored (as necessary in the synthetic tasks), all $D$ channels should ignore it, and so we project the input down to 1 dimension before repeating/broadcasting with $\Delta$.</p>
<h3>3.5.2 Interpretation of Selection Mechanisms</h3>
<p>We elaborate on three particular mechanistic effects of selection.</p>
<p>Variable Spacing. Selectivity allows filtering out irrelevant noise tokens that may occur between inputs of interest. This is exemplified by the Selective Copying task, but occurs ubiquitously in common data modalities, particularly for discrete data - for example the presence of language fillers such as "um". This property arises because the model can mechanistically filter out any particular input $x_{t}$, for example in the gated RNN case (Theorem 1) when $g_{t} \rightarrow 0$.</p>
<p>Filtering Context. It has been empirically observed that many sequence models do not improve with longer context (F. Shi et al. 2023), despite the principle that more context should lead to strictly better performance. An explanation is that many sequence models cannot effectively ignore irrelevant context when necessary; an intuitive example are global convolutions (and general LTI models). On the other hand, selective models can simply reset their state at any time to remove extraneous history, and thus their performance in principle improves monotonicly with context length (e.g. Section 4.3.2).</p>
<p>Boundary Resetting. In settings where multiple independent sequences are stitched together, Transformers can keep them separate by instantiating a particular attention mask, while LTI models will bleed information between the sequences. Selective SSMs can also reset their state at boundaries (e.g. $\Delta_{t} \rightarrow \infty$, or Theorem 1 when $g_{t} \rightarrow 1$ ). These settings may occur artificially (e.g. packing documents together to improve hardware utilization) or naturally (e.g. episode boundaries in reinforcement learning (Lu et al. 2023)).</p>
<p>Additionally, we elaborate on effects of each selective parameter.
Interpretation of $\Delta$. In general, $\Delta$ controls the balance between how much to focus or ignore the current input $x_{t}$. It generalizes RNN gates (e.g. $g_{t}$ in Theorem 1): mechanically, a large $\Delta$ resets the state $h$ and focuses on the current input $x$, while a small $\Delta$ persists the state and ignores the current input. SSMs (1)-(2) can be interpreted as a continuous system discretized by a timestep $\Delta$, and in this context the intuition is that large $\Delta \rightarrow \infty$ represents the system focusing on the current input for longer (thus "selecting" it and forgetting its current state) while a small $\Delta \rightarrow 0$ represents a transient input that is ignored.</p>
<p>Interpretation of $\boldsymbol{A}$. We remark that while the $\boldsymbol{A}$ parameter could also be selective, it ultimately affects the model only through its interaction with $\Delta$ via $\widehat{\boldsymbol{A}}=\exp (\Delta \boldsymbol{A})$ (the discretization (4)). Thus selectivity in $\Delta$ is enough to ensure selectivity in $(\widehat{\boldsymbol{A}}, \widehat{\boldsymbol{B}})$, and is the main source of improvement. We hypothesize that making $\boldsymbol{A}$ selective in addition to (or instead of) $\Delta$ would have similar performance, and leave it out for simplicity.</p>
<p>Interpretation of $\boldsymbol{B}$ and $\boldsymbol{C}$. As discussed in Section 3.1, the most important property of selectivity is filtering out irrelevant information so that a sequence model's context can be compressed into an efficient state. In an SSM, modifying $\boldsymbol{B}$ and $\boldsymbol{C}$ to be selective allows finer-grained control over whether to let an input $x_{t}$ into the state $h_{t}$, or the state into the output $y_{t}$. These can be interpreted as allowing the model to modulate the recurrent dynamics based on content (input) and context (hidden states) respectively.</p>
<h1>3.6 Additional Model Details</h1>
<p>Real vs. Complex. Most prior SSMs use complex numbers in their state $h$, which is necessary for strong performance on many tasks in perceptual modalities (Gu, Goel, and Ré 2022). However, it has been empirically observed that completely real-valued SSMs seem to work fine, and possibly even better, in some settings (Ma et al. 2023). We use real values as the default, which work well for all but one of our tasks; we hypothesize that the complex-real tradeoff is related to the continuous-discrete spectrum in data modalities, where complex numbers are helpful for continuous modalities (e.g. audio, video) but not discrete (e.g. text, DNA).</p>
<p>Initialization. Most prior SSMs also suggest special initializations, particularly in the complex-valued case, which can help in several settings such as low-data regimes. Our default initialization for the complex case is S4D-Lin and for the real case is S4D-Real (Gu, Gupta, et al. 2022), which is based on the HIPPO theory (Gu, Dao, et al. 2020). These define the $n$-th element of $\boldsymbol{A}$ as $-1 / 2+n i$ and $-(n+1)$ respectively. However, we expect many initializations to work fine, particularly in the large-data and real-valued SSM regimes; some ablations are considered in Section 4.6.</p>
<p>Parameterization of $\Delta$. We defined the selective adjustment to $\Delta$ as $s_{\Delta}(x)=\operatorname{Broadcast}<em 1="1">{D}\left(\operatorname{Linear}</em>}(x)\right)$, which was motivated by the mechanics of $\Delta$ (Section 3.5). We observe that it can be generalized from dimension 1 to a larger dimension $R$. We set this to be a small fraction of $D$, which uses a negligible number of parameters compared to the main Linear projections in the block. We additionally note that the broadcasting operation can instead be viewed as another Linear projection, initialized to a specific pattern of 1's and 0 's; if this projection is trainable, this leads to the alternative $s_{\Delta}(x)=\operatorname{Linear<em R="R">{D}\left(\operatorname{Linear}</em>(x)\right)$, which can be viewed as a low-rank projection.</p>
<p>In our experiments, the $\Delta$ parameter (which can be viewed as a bias term) is initialized to $\tau_{\Delta}^{-1}(\operatorname{Uniform}([0.001,0.1]))$, following prior work on SSMs (Gu, Johnson, Timalsina, et al. 2023).</p>
<p>Remark 3.1. For brevity in our experimental results, we sometimes abbreviate selective SSMs as S6 models, because they are S4 models with a selection mechanism and computed with a scan.</p>
<h1>4 Empirical Evaluation</h1>
<p>In Section 4.1 we test Mamba's ability to solve the two synthetic tasks motivated in Section 3.1. We then evaluate on three domains, each evaluated on autoregressive pretraining as well as downstream tasks.</p>
<ul>
<li>Section 4.2: language model pretraining (scaling laws), and zero-shot downstream evaluation.</li>
<li>Section 4.3: DNA sequence pretraining, and fine-tuning on a long-sequence classification task.</li>
<li>Section 4.4: audio waveform pretraining, and the quality of autoregressively generated speech clips.</li>
</ul>
<p>Finally, Section 4.5 shows Mamba's computational efficiency at both training and inference time, and Section 4.6 ablates various components of the architecture and selective SSMs.</p>
<h3>4.1 Synthetic Tasks</h3>
<p>Full experiment details for these tasks including task details and training protocol are in Appendix E.1.</p>
<h3>4.1.1 Selective Copying</h3>
<p>The Copying task is one of the most well-studied synthetic tasks for sequence modeling, originally designed to test the memorization abilities of recurrent models. As discussed in Section 3.1, LTI SSMs (linear recurrences and global convolutions) can easily solve this task by only keeping track of time instead of reasoning about the data; for example, by constructing a convolution kernel of exactly the right length (Figure 2). This was explicitly validated in earlier work on global convolutions (Romero et al. 2021). The Selective Copying task prevents this shortcut by randomizing the spacing between tokens. Note that this task has been introduced before as the Denoising task (Jing et al. 2019).</p>
<p>Note that many previous works argue that adding architecture gating (multiplicative interactions) can endow models with "data-dependence" and solve related tasks (Dao, Fu, Saab, et al. 2023; Poli et al. 2023). However, we find this explanation insufficient intuitively because such gating does not interact along the sequence axis, and cannot affect the spacing between tokens. In particular architecture gating is not an instance of a selection mechanism (Appendix A).</p>
<p>Table 1 confirms that gated architectures such as H3 and Mamba only partially improve performance, while the selection mechanism (modifying S4 to S6) easily solves this task, particularly when combined with these more powerful architectures.</p>
<h3>4.1.2 Induction Heads</h3>
<p>Induction heads (Olsson et al. 2022) is a simple task from the mechanistic interpretability lens (Elhage et al. 2021) that is surprisingly predictive of the in-context learning ability of LLMs. It requires models to perform associative recall and copy: for example, if the model has seen a bigram such as "Harry Potter" in the sequence, then the next time "Harry" appears in the same sequence, the model should be able to predict "Potter" by copying from history.</p>
<p>Dataset. We train a 2-layer model on the induction heads task at sequence length 256, with a vocab size of 16, which is comparable to prior work on this task (Dao, Fu, Saab, et al. 2023) but with longer sequences. We additionally investigate generalization and extrapolation abilities by evaluating on a range of sequence lengths from $2^{6}=64$ up to $2^{20}=1048576$ at test time.</p>
<p>Models. Following established work on induction heads, we use 2 layer models, which allows attention to mechanistically solve the induction heads task (Olsson et al. 2022). We test both multi-head attention (8 heads, with various positional encodings) and SSM variants. We use a model dimension $D$ of 64 for Mamba and 128 for the other models.</p>
<p>Results. Table 2 shows that Mamba-or more precisely, its selective SSM layer-has the ability to solve the task perfectly because of its ability to selectively remember the relevant token while ignoring everything else in between. It generalizes perfectly to million-length sequences, or $4000 \times$ longer than it saw during training, while no other method goes beyond $2 \times$.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: left;">Arch.</th>
<th style="text-align: left;">Layer</th>
<th style="text-align: left;">Acc.</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">S4</td>
<td style="text-align: left;">No gate</td>
<td style="text-align: left;">S4</td>
<td style="text-align: left;">18.3</td>
</tr>
<tr>
<td style="text-align: left;">-</td>
<td style="text-align: left;">No gate</td>
<td style="text-align: left;">S6</td>
<td style="text-align: left;">$\mathbf{9 7 . 0}$</td>
</tr>
<tr>
<td style="text-align: left;">H3</td>
<td style="text-align: left;">H3</td>
<td style="text-align: left;">S4</td>
<td style="text-align: left;">57.0</td>
</tr>
<tr>
<td style="text-align: left;">Hyena</td>
<td style="text-align: left;">H3</td>
<td style="text-align: left;">Hyena</td>
<td style="text-align: left;">30.1</td>
</tr>
<tr>
<td style="text-align: left;">-</td>
<td style="text-align: left;">H3</td>
<td style="text-align: left;">S6</td>
<td style="text-align: left;">$\mathbf{9 9 . 7}$</td>
</tr>
<tr>
<td style="text-align: left;">-</td>
<td style="text-align: left;">Mamba</td>
<td style="text-align: left;">S4</td>
<td style="text-align: left;">56.4</td>
</tr>
<tr>
<td style="text-align: left;">Mamba</td>
<td style="text-align: left;">Mamba</td>
<td style="text-align: left;">Hyena</td>
<td style="text-align: left;">28.4</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">Mamba</td>
<td style="text-align: left;">S6</td>
<td style="text-align: left;">$\mathbf{9 9 . 8}$</td>
</tr>
</tbody>
</table>
<p>Table 1: (Selective Copying.)
Accuracy for combinations of architectures and inner sequence layers.
<img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Table 2: (Induction Heads.) Models are trained on sequence length $2^{8}=$ 256, and tested on increasing sequence lengths of $2^{6}=64$ up to $2^{20}=$ 1048576. Full numbers in Table 11.
<img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 4: (Scaling Laws.) Models of size $\approx 125 M$ to $\approx 1.3 B$ parameters, trained on the Pile. Mamba scales better than all other attention-free models and is the first to match the performance of a very strong "Transformer++" recipe that has now become standard, particularly as the sequence length grows.</p>
<p>Out of positional encoding variants for attention models, xPos (which was designed for length extrapolation) is slightly better than the others; also note that all attention models were only tested up to sequence length $2^{14}=16384$ due to memory limitations. Out of other SSMs, H3 and Hyena are similar, contrary to the findings in Poli et al. (2023).</p>
<h1>4.2 Language Modeling</h1>
<p>We evaluate the Mamba architecture on standard autoregressive language modeling against other architectures, on both pretraining metrics (perplexity) and zero-shot evaluations. We set the model sizes (depth and width) to mirror GPT3 specifications. We use the Pile dataset (L. Gao, Biderman, et al. 2020), and follow the training recipe described in Brown et al. (2020). All training details are in Appendix E.2.</p>
<h3>4.2.1 Scaling Laws</h3>
<p>For baselines, we compare against the standard Transformer architecture (GPT3 architecture), as well as the strongest Transformer recipe we know of (here referred to as Transformer++), based on the PaLM and LLaMa architectures (e.g. rotary embedding, SwiGLU MLP, RMSNorm instead of LayerNorm, no linear bias, and higher learning rates). We also compare against other recent subquadratic architectures (Figure 4). All model details are in Appendix E.2.</p>
<p>Figure 4 shows scaling laws under the standard Chinchilla (Hoffmann et al. 2022) protocol, on models from $\approx 125 M$ to $\approx 1.3 B$ parameters. Mamba is the first attention-free model to match the performance of a very strong Transformer recipe (Transformer++) that has now become standard, particularly as the sequence length grows. (We note that full results on context length 8 k are missing for the RWKV and RetNet baselines, prior strong recurrent models that can also be interpreted as SSMs, because of a lack of efficient implementations leading to out-of-memory or unrealistic computation requirements.)</p>
<h1>4.2.2 Downstream Evaluations</h1>
<p>Table 3 shows the performance of Mamba on a range of popular downstream zero-shot evaluation tasks. We compare against the most well-known open source models at these sizes, most importantly Pythia (Biderman et al. 2023) and RWKV (B. Peng et al. 2023) which were trained with the same tokenizer, dataset, and training length (300B tokens) as our models. (Note that Mamba and Pythia are trained with context length 2048, while RWKV was trained with context length 1024.)</p>
<p>Table 3: (Zero-shot Evaluations.) Best results for each size in bold. We compare against open source LMs with various tokenizers, trained for up to 300B tokens. Pile refers to the validation split, comparing only against models trained on the same dataset and tokenizer (GPT-NeoX-20B). For each model size, Mamba is best-in-class on every single evaluation result, and generally matches baselines at twice the model size.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Model</th>
<th style="text-align: center;">Token.</th>
<th style="text-align: center;">Pile <br> $\mathrm{PPL} \downarrow$</th>
<th style="text-align: center;">LAMBADA <br> PPL $\downarrow$</th>
<th style="text-align: center;">LAMBADA <br> $\mathrm{ACC} \uparrow$</th>
<th style="text-align: center;">HellaSwag <br> ACC $\uparrow$</th>
<th style="text-align: center;">PIQA <br> ACC $\uparrow$</th>
<th style="text-align: center;">Arc-E <br> ACC $\uparrow$</th>
<th style="text-align: center;">Arc-C <br> ACC $\uparrow$</th>
<th style="text-align: center;">WinoGrande <br> ACC $\uparrow$</th>
<th style="text-align: center;">Average <br> ACC $\uparrow$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Hybrid H3-130M</td>
<td style="text-align: center;">GPT2</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">89.48</td>
<td style="text-align: center;">25.77</td>
<td style="text-align: center;">31.7</td>
<td style="text-align: center;">64.2</td>
<td style="text-align: center;">44.4</td>
<td style="text-align: center;">24.2</td>
<td style="text-align: center;">50.6</td>
<td style="text-align: center;">40.1</td>
</tr>
<tr>
<td style="text-align: center;">Pythia-160M</td>
<td style="text-align: center;">NeoX</td>
<td style="text-align: center;">29.64</td>
<td style="text-align: center;">38.10</td>
<td style="text-align: center;">33.0</td>
<td style="text-align: center;">30.2</td>
<td style="text-align: center;">61.4</td>
<td style="text-align: center;">43.2</td>
<td style="text-align: center;">24.1</td>
<td style="text-align: center;">51.9</td>
<td style="text-align: center;">40.6</td>
</tr>
<tr>
<td style="text-align: center;">Mamba-130M</td>
<td style="text-align: center;">NeoX</td>
<td style="text-align: center;">10.56</td>
<td style="text-align: center;">16.07</td>
<td style="text-align: center;">44.3</td>
<td style="text-align: center;">35.3</td>
<td style="text-align: center;">64.5</td>
<td style="text-align: center;">48.0</td>
<td style="text-align: center;">24.3</td>
<td style="text-align: center;">51.9</td>
<td style="text-align: center;">44.7</td>
</tr>
<tr>
<td style="text-align: center;">Hybrid H3-360M</td>
<td style="text-align: center;">GPT2</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">12.58</td>
<td style="text-align: center;">48.0</td>
<td style="text-align: center;">41.5</td>
<td style="text-align: center;">68.1</td>
<td style="text-align: center;">51.4</td>
<td style="text-align: center;">24.7</td>
<td style="text-align: center;">54.1</td>
<td style="text-align: center;">48.0</td>
</tr>
<tr>
<td style="text-align: center;">Pythia-410M</td>
<td style="text-align: center;">NeoX</td>
<td style="text-align: center;">9.95</td>
<td style="text-align: center;">10.84</td>
<td style="text-align: center;">51.4</td>
<td style="text-align: center;">40.6</td>
<td style="text-align: center;">66.9</td>
<td style="text-align: center;">52.1</td>
<td style="text-align: center;">24.6</td>
<td style="text-align: center;">53.8</td>
<td style="text-align: center;">48.2</td>
</tr>
<tr>
<td style="text-align: center;">Mamba-370M</td>
<td style="text-align: center;">NeoX</td>
<td style="text-align: center;">8.28</td>
<td style="text-align: center;">8.14</td>
<td style="text-align: center;">55.6</td>
<td style="text-align: center;">46.5</td>
<td style="text-align: center;">69.5</td>
<td style="text-align: center;">55.1</td>
<td style="text-align: center;">28.0</td>
<td style="text-align: center;">55.3</td>
<td style="text-align: center;">50.0</td>
</tr>
<tr>
<td style="text-align: center;">Pythia-1B</td>
<td style="text-align: center;">NeoX</td>
<td style="text-align: center;">7.82</td>
<td style="text-align: center;">7.92</td>
<td style="text-align: center;">56.1</td>
<td style="text-align: center;">47.2</td>
<td style="text-align: center;">70.7</td>
<td style="text-align: center;">57.0</td>
<td style="text-align: center;">27.1</td>
<td style="text-align: center;">53.5</td>
<td style="text-align: center;">51.9</td>
</tr>
<tr>
<td style="text-align: center;">Mamba-790M</td>
<td style="text-align: center;">NeoX</td>
<td style="text-align: center;">7.33</td>
<td style="text-align: center;">6.02</td>
<td style="text-align: center;">62.7</td>
<td style="text-align: center;">55.1</td>
<td style="text-align: center;">72.1</td>
<td style="text-align: center;">61.2</td>
<td style="text-align: center;">29.5</td>
<td style="text-align: center;">56.1</td>
<td style="text-align: center;">57.1</td>
</tr>
<tr>
<td style="text-align: center;">GPT-Neo 1.3B</td>
<td style="text-align: center;">GPT2</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">7.50</td>
<td style="text-align: center;">57.2</td>
<td style="text-align: center;">48.9</td>
<td style="text-align: center;">71.1</td>
<td style="text-align: center;">56.2</td>
<td style="text-align: center;">25.9</td>
<td style="text-align: center;">54.9</td>
<td style="text-align: center;">52.4</td>
</tr>
<tr>
<td style="text-align: center;">Hybrid H3-1.3B</td>
<td style="text-align: center;">GPT2</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">11.25</td>
<td style="text-align: center;">49.6</td>
<td style="text-align: center;">52.6</td>
<td style="text-align: center;">71.3</td>
<td style="text-align: center;">59.2</td>
<td style="text-align: center;">28.1</td>
<td style="text-align: center;">56.9</td>
<td style="text-align: center;">53.0</td>
</tr>
<tr>
<td style="text-align: center;">OPT-1.3B</td>
<td style="text-align: center;">OPT</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">6.64</td>
<td style="text-align: center;">58.0</td>
<td style="text-align: center;">53.7</td>
<td style="text-align: center;">72.4</td>
<td style="text-align: center;">56.7</td>
<td style="text-align: center;">29.6</td>
<td style="text-align: center;">59.5</td>
<td style="text-align: center;">55.0</td>
</tr>
<tr>
<td style="text-align: center;">Pythia-1.4B</td>
<td style="text-align: center;">NeoX</td>
<td style="text-align: center;">7.51</td>
<td style="text-align: center;">6.08</td>
<td style="text-align: center;">61.7</td>
<td style="text-align: center;">52.1</td>
<td style="text-align: center;">71.0</td>
<td style="text-align: center;">60.5</td>
<td style="text-align: center;">28.5</td>
<td style="text-align: center;">57.2</td>
<td style="text-align: center;">55.2</td>
</tr>
<tr>
<td style="text-align: center;">RWKV-1.5B</td>
<td style="text-align: center;">NeoX</td>
<td style="text-align: center;">7.70</td>
<td style="text-align: center;">7.04</td>
<td style="text-align: center;">56.4</td>
<td style="text-align: center;">52.5</td>
<td style="text-align: center;">72.4</td>
<td style="text-align: center;">60.5</td>
<td style="text-align: center;">29.4</td>
<td style="text-align: center;">54.6</td>
<td style="text-align: center;">54.3</td>
</tr>
<tr>
<td style="text-align: center;">Mamba-1.4B</td>
<td style="text-align: center;">NeoX</td>
<td style="text-align: center;">6.80</td>
<td style="text-align: center;">5.04</td>
<td style="text-align: center;">64.9</td>
<td style="text-align: center;">59.1</td>
<td style="text-align: center;">74.2</td>
<td style="text-align: center;">65.5</td>
<td style="text-align: center;">32.8</td>
<td style="text-align: center;">61.5</td>
<td style="text-align: center;">59.7</td>
</tr>
<tr>
<td style="text-align: center;">GPT-Neo 2.7B</td>
<td style="text-align: center;">GPT2</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">5.63</td>
<td style="text-align: center;">62.2</td>
<td style="text-align: center;">55.8</td>
<td style="text-align: center;">72.1</td>
<td style="text-align: center;">61.1</td>
<td style="text-align: center;">30.2</td>
<td style="text-align: center;">57.6</td>
<td style="text-align: center;">56.5</td>
</tr>
<tr>
<td style="text-align: center;">Hybrid H3-2.7B</td>
<td style="text-align: center;">GPT2</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">7.92</td>
<td style="text-align: center;">55.7</td>
<td style="text-align: center;">59.7</td>
<td style="text-align: center;">73.3</td>
<td style="text-align: center;">65.6</td>
<td style="text-align: center;">32.3</td>
<td style="text-align: center;">61.4</td>
<td style="text-align: center;">58.0</td>
</tr>
<tr>
<td style="text-align: center;">OPT-2.7B</td>
<td style="text-align: center;">OPT</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">5.12</td>
<td style="text-align: center;">63.6</td>
<td style="text-align: center;">60.6</td>
<td style="text-align: center;">74.8</td>
<td style="text-align: center;">60.8</td>
<td style="text-align: center;">31.3</td>
<td style="text-align: center;">61.0</td>
<td style="text-align: center;">58.7</td>
</tr>
<tr>
<td style="text-align: center;">Pythia-2.8B</td>
<td style="text-align: center;">NeoX</td>
<td style="text-align: center;">6.73</td>
<td style="text-align: center;">5.04</td>
<td style="text-align: center;">64.7</td>
<td style="text-align: center;">59.3</td>
<td style="text-align: center;">74.0</td>
<td style="text-align: center;">64.1</td>
<td style="text-align: center;">32.9</td>
<td style="text-align: center;">59.7</td>
<td style="text-align: center;">59.1</td>
</tr>
<tr>
<td style="text-align: center;">RWKV-3B</td>
<td style="text-align: center;">NeoX</td>
<td style="text-align: center;">7.00</td>
<td style="text-align: center;">5.24</td>
<td style="text-align: center;">63.9</td>
<td style="text-align: center;">59.6</td>
<td style="text-align: center;">73.7</td>
<td style="text-align: center;">67.8</td>
<td style="text-align: center;">33.1</td>
<td style="text-align: center;">59.6</td>
<td style="text-align: center;">59.6</td>
</tr>
<tr>
<td style="text-align: center;">Mamba-2.8B</td>
<td style="text-align: center;">NeoX</td>
<td style="text-align: center;">6.22</td>
<td style="text-align: center;">4.23</td>
<td style="text-align: center;">69.2</td>
<td style="text-align: center;">66.1</td>
<td style="text-align: center;">75.2</td>
<td style="text-align: center;">69.7</td>
<td style="text-align: center;">36.3</td>
<td style="text-align: center;">63.5</td>
<td style="text-align: center;">63.3</td>
</tr>
<tr>
<td style="text-align: center;">GPT-J-6B</td>
<td style="text-align: center;">GPT2</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">4.10</td>
<td style="text-align: center;">68.3</td>
<td style="text-align: center;">66.3</td>
<td style="text-align: center;">75.4</td>
<td style="text-align: center;">67.0</td>
<td style="text-align: center;">36.6</td>
<td style="text-align: center;">64.1</td>
<td style="text-align: center;">63.0</td>
</tr>
<tr>
<td style="text-align: center;">OPT-6.7B</td>
<td style="text-align: center;">OPT</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">4.25</td>
<td style="text-align: center;">67.7</td>
<td style="text-align: center;">67.2</td>
<td style="text-align: center;">76.3</td>
<td style="text-align: center;">65.6</td>
<td style="text-align: center;">34.9</td>
<td style="text-align: center;">65.5</td>
<td style="text-align: center;">62.9</td>
</tr>
<tr>
<td style="text-align: center;">Pythia-6.9B</td>
<td style="text-align: center;">NeoX</td>
<td style="text-align: center;">6.51</td>
<td style="text-align: center;">4.45</td>
<td style="text-align: center;">67.1</td>
<td style="text-align: center;">64.0</td>
<td style="text-align: center;">75.2</td>
<td style="text-align: center;">67.3</td>
<td style="text-align: center;">35.5</td>
<td style="text-align: center;">61.3</td>
<td style="text-align: center;">61.7</td>
</tr>
<tr>
<td style="text-align: center;">RWKV-7.4B</td>
<td style="text-align: center;">NeoX</td>
<td style="text-align: center;">6.31</td>
<td style="text-align: center;">4.38</td>
<td style="text-align: center;">67.2</td>
<td style="text-align: center;">65.5</td>
<td style="text-align: center;">76.1</td>
<td style="text-align: center;">67.8</td>
<td style="text-align: center;">37.5</td>
<td style="text-align: center;">61.0</td>
<td style="text-align: center;">62.5</td>
</tr>
</tbody>
</table>
<h3>4.3 DNA Modeling</h3>
<p>Motivated by the success of large language models, there has been recent exploration into using the foundation model paradigm for genomics. DNA has been likened to language in that it consists of sequences of discrete tokens with a finite vocabulary. It is also known for requiring long-range dependencies to model (Avsec et al. 2021). We investigate Mamba as a FM backbone for pretraining and fine-tuning in the same setting as recent works on long-sequence models for DNA (Nguyen, Poli, et al. 2023). In particular, we focus on two explorations of scaling laws across model size and sequence length (Figure 5), and a difficult downstream synthetic classification task requiring long context (Figure 6).</p>
<p>For pretraining, we largely follow a standard causal language modeling (next token prediction) setup for the training and model details (see also Appendix E.2). For the dataset, we largely follow the setup of HyenaDNA (Nguyen, Poli, et al. 2023), which uses the HG38 dataset for pretraining consisting of a single human genome with about 4.5 billion tokens (DNA base pairs) in the training split.</p>
<p><img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>Figure 5: (DNA Scaling Laws.) Pretraining on the HG38 (human genome) dataset. (Left) Fixing short context length $2^{10}=1024$ and increasing size from $\approx 200 \mathrm{~K}$ to $\approx 40 M$ parameters, Mamba scales better than baselines. (Right) Fixing model size and increasing sequence lengths while keeping tokens/batch and total training tokens fixed. Unlike baselines, the selection mechanism of Mamba facilitates better performance with increasing context length.</p>
<h1>4.3.1 Scaling: Model Size</h1>
<p>In this experiment, we investigate the scaling properties of genomics foundation models with various model backbones (Figure 5 Left).</p>
<p>Training. To advantage the baselines, we train on a short sequence length of 1024; as shown in Section 4.3.2, we expect results to favor Mamba even more at longer sequence lengths. We fix a global batch size of 1024 , for a total of $2^{20} \approx 1 M$ tokens per batch. Models were trained for 10 K gradient steps for a total of 10 B tokens.</p>
<p>Results. Figure 5 (Left) shows that Mamba's pretraining perplexity improves smoothly with model size, and that Mamba scales better than both HyenaDNA and Transformer++. For example, at the largest model size of $\approx 40 M$ parameters, the curve shows that Mamba can match the Transformer++ and HyenaDNA models with roughly $3 \times$ to $4 \times$ fewer parameters.</p>
<h3>4.3.2 Scaling: Context Length</h3>
<p>In the next DNA experiment, we investigate the scaling properties of models with respect to sequence length. We only compare the HyenaDNA and Mamba models, as quadratic attention becomes prohibitively expensive at longer sequence lengths. We pretrain models on sequence lengths $2^{10}=1024,2^{12}=4096,2^{14}=16384,2^{16}=65536,2^{18}=262144$, $2^{20}=1048576$. We fix a model size of 6 layers by width 128 (about 1.3M-1.4M parameters). Models were trained for 20 K gradient steps for a total of $\approx 330 B$ tokens. The longer sequence lengths used sequence length warmup similar to (Nguyen, Poli, et al. 2023).</p>
<p>Results. Figure 5 (Right) shows that Mamba is able to make use of longer context even up to extremely long sequences of length 1M, and its pretraining perplexity improves as the context increases. On the other hand, the HyenaDNA model gets worse with sequence length. This is intuitive from the discussion in Section 3.5 on properties of the selection mechanism. In particular, LTI models cannot selectively ignore information; from a convolutional perspective, a very long convolution kernel is aggregating all information across a long sequence which may be very noisy. Note that while HyenaDNA claims to improve with longer context, their results do not control for computation time.</p>
<h3>4.3.3 Synthetic Species Classification</h3>
<p>We evaluate models on a downstream task of classifying between 5 different species by randomly sampling a contiguous segment of their DNA. This task is adapted from HyenaDNA, which used the species {human, lemur, mouse, pig, hippo}. We modify the task to be significantly more challenging by classifying between the five great apes species {human, chimpanzee, gorilla, orangutan, bonobo}, which are known to share $99 \%$ of their DNA.</p>
<p><img alt="img-6.jpeg" src="img-6.jpeg" /></p>
<p>Figure 6: (Great Apes DNA Classification.) Accuracy after finetuning on sequences of length $2^{10}=1024$ up to $2^{20}=1048576$ using pretrained models of the same context length. Numerical results in Table 13.
<img alt="img-7.jpeg" src="img-7.jpeg" /></p>
<p>Figure 7: (Audio Pretraining.) Mamba improves performance over prior state-of-the-art (Sashimi) in autoregressive audio modeling, while improving up to minute-long context or million-length sequences (controlling for computation).</p>
<h1>4.4 Audio Modeling and Generation</h1>
<p>For the audio waveform modality, we compare primarily to the SaShiMi architecture and training protocols (Goel et al. 2022). This model comprises:</p>
<ol>
<li>a U-Net backbone with two stages of pooling by a factor $p$ that doubles the model dimension $D$ per stage,</li>
<li>alternating S4 and MLP blocks in each stage.</li>
</ol>
<p>We consider replacing the S4+MLP blocks with Mamba blocks. Experiment details are in Appendix E.4.</p>
<h3>4.4.1 Long-Context Autoregressive Pretraining</h3>
<p>We evaluate pretraining quality (autoregressive next-sample prediction) on YouTubeMix (DeepSound 2017), a standard piano music dataset used by prior work consisting of 4 hours of solo piano music, sampled at a rate of 16000 Hz . Pretraining details largely follow the standard language modeling setup (Section 4.2). Figure 7 evaluates the effect of increasing training sequence lengths from $2^{13}=8192$ to $2^{20} \approx 10^{6}$, while keeping computation fixed. (There are some slight edge cases to the way the data is curated, which may lead to kinks in the scaling curves. For example, only minute-long clips were available so the maximum sequence length is actually bounded by $60 s \cdot 16000 \mathrm{~Hz}=960000$.)</p>
<p>Both Mamba and the SaShiMi (S4+MLP) baseline improve consistently with longer context lengths; Mamba is better throughout, and the gap widens at longer lengths. The main metric is bits per byte (BPB), which is a constant factor $\log (2)$ of the standard negative log-likelihood (NLL) loss for pretraining other modalities.</p>
<p>We note one important detail: this is the only experiment in this paper in which we switched from the real parameterization to complex (Section 3.6). We show additional ablations in Appendix E.4.</p>
<h3>4.4.2 Autoregressive Speech Generation</h3>
<p>SC09 is a benchmark speech generation dataset (Donahue, McAuley, and Puckette 2019; Warden 2018), consisting of 1-second clips sampled at 16000 Hz of the digits "zero" through "nine" with highly variable characteristics. We largely follow the autoregressive training setup and generation protocol of Goel et al. (2022).</p>
<p>Table 4 shows automated metrics of the Mamba-UNet model compared to a variety of baselines from Goel et al. (2022): WaveNet (Oord et al. 2016), SampleRNN (Mehri et al. 2017), WaveGAN (Donahue, McAuley, and Puckette 2019), DiffWave (Z. Kong et al. 2021), and SaShiMi. A small Mamba model outperforms the state-of-the-art (and much larger) GANAnd diffusion- based models. A larger model parameter-matched to the baselines further improves on fidelity metrics dramatically.</p>
<p>Table 5 takes the small Mamba model and investigates combinations of different architectures for the outer stages and center stage. It shows that Mamba is consistently better than S4+MLP in the outer blocks, and Mamba $&gt;$ S4+MLP $&gt;$ MHA+MLP in the center blocks.</p>
<p>Table 4: (SC09) Automated metrics for unconditional generation on a challenging dataset of fixed-length speech clips. (Top to Bottom) Autoregressive baselines, non-autoregressive baselines, Mamba, and dataset metrics.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">MODEL</th>
<th style="text-align: left;">Params</th>
<th style="text-align: left;">NLL $\downarrow$</th>
<th style="text-align: left;">FID $\downarrow$</th>
<th style="text-align: left;">IS $\uparrow$</th>
<th style="text-align: left;">mlS $\uparrow$</th>
<th style="text-align: left;">AM $\downarrow$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">SampleRNN</td>
<td style="text-align: left;">35.0 M</td>
<td style="text-align: left;">2.042</td>
<td style="text-align: left;">8.96</td>
<td style="text-align: left;">1.71</td>
<td style="text-align: left;">3.02</td>
<td style="text-align: left;">1.76</td>
</tr>
<tr>
<td style="text-align: left;">WaveNet</td>
<td style="text-align: left;">4.2 M</td>
<td style="text-align: left;">1.925</td>
<td style="text-align: left;">5.08</td>
<td style="text-align: left;">2.27</td>
<td style="text-align: left;">5.80</td>
<td style="text-align: left;">1.47</td>
</tr>
<tr>
<td style="text-align: left;">SaShiMi</td>
<td style="text-align: left;">5.8 M</td>
<td style="text-align: left;">1.873</td>
<td style="text-align: left;">1.99</td>
<td style="text-align: left;">5.13</td>
<td style="text-align: left;">42.57</td>
<td style="text-align: left;">0.74</td>
</tr>
<tr>
<td style="text-align: left;">WaveGAN</td>
<td style="text-align: left;">19.1 M</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">2.03</td>
<td style="text-align: left;">4.90</td>
<td style="text-align: left;">36.10</td>
<td style="text-align: left;">0.80</td>
</tr>
<tr>
<td style="text-align: left;">DiffWave</td>
<td style="text-align: left;">24.1 M</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">1.92</td>
<td style="text-align: left;">5.26</td>
<td style="text-align: left;">51.21</td>
<td style="text-align: left;">0.68</td>
</tr>
<tr>
<td style="text-align: left;">+ SaShiMi</td>
<td style="text-align: left;">23.0 M</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">1.42</td>
<td style="text-align: left;">5.94</td>
<td style="text-align: left;">69.17</td>
<td style="text-align: left;">0.59</td>
</tr>
<tr>
<td style="text-align: left;">Mamba</td>
<td style="text-align: left;">6.1 M</td>
<td style="text-align: left;">$\mathbf{1 . 8 5 2}$</td>
<td style="text-align: left;">$\underline{0.94}$</td>
<td style="text-align: left;">$\underline{6.26}$</td>
<td style="text-align: left;">$\underline{88.54}$</td>
<td style="text-align: left;">$\underline{0.52}$</td>
</tr>
<tr>
<td style="text-align: left;">Mamba</td>
<td style="text-align: left;">24.3 M</td>
<td style="text-align: left;">$\underline{1.860}$</td>
<td style="text-align: left;">$\mathbf{0 . 6 7}$</td>
<td style="text-align: left;">$\mathbf{7 . 3 3}$</td>
<td style="text-align: left;">$\mathbf{1 4 4 . 9}$</td>
<td style="text-align: left;">$\mathbf{0 . 3 6}$</td>
</tr>
<tr>
<td style="text-align: left;">Train</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">0.00</td>
<td style="text-align: left;">8.56</td>
<td style="text-align: left;">292.5</td>
<td style="text-align: left;">0.16</td>
</tr>
<tr>
<td style="text-align: left;">Test</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">0.02</td>
<td style="text-align: left;">8.33</td>
<td style="text-align: left;">257.6</td>
<td style="text-align: left;">0.19</td>
</tr>
</tbody>
</table>
<p>Table 5: (SC09 Model Ablations) Models with 6M parameters. In SaShiMi's U-Net backbone, there are 8 center blocks operating on sequence length 1000, sandwiched on each side by 8 outer blocks on sequence length 4000, sandwiched by 8 outer blocks on sequence length 16000 ( 40 blocks total). The architecture of the 8 center blocks are ablated independently of the rest. Note that Transformers (MHA+MLP) were not tested in the more important outer blocks because of efficiency constraints.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Outer</th>
<th style="text-align: left;">Center</th>
<th style="text-align: left;">NLL $\downarrow$</th>
<th style="text-align: left;">FID $\downarrow$</th>
<th style="text-align: left;">IS $\uparrow$</th>
<th style="text-align: left;">mlS $\uparrow$</th>
<th style="text-align: left;">AM $\downarrow$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">S4+MLP</td>
<td style="text-align: left;">MHA+MLP</td>
<td style="text-align: left;">1.859</td>
<td style="text-align: left;">1.45</td>
<td style="text-align: left;">5.06</td>
<td style="text-align: left;">47.03</td>
<td style="text-align: left;">0.70</td>
</tr>
<tr>
<td style="text-align: left;">S4+MLP</td>
<td style="text-align: left;">S4+MLP</td>
<td style="text-align: left;">1.867</td>
<td style="text-align: left;">1.43</td>
<td style="text-align: left;">5.42</td>
<td style="text-align: left;">53.54</td>
<td style="text-align: left;">0.65</td>
</tr>
<tr>
<td style="text-align: left;">S4+MLP</td>
<td style="text-align: left;">Mamba</td>
<td style="text-align: left;">1.859</td>
<td style="text-align: left;">1.42</td>
<td style="text-align: left;">5.71</td>
<td style="text-align: left;">56.51</td>
<td style="text-align: left;">0.64</td>
</tr>
<tr>
<td style="text-align: left;">Mamba</td>
<td style="text-align: left;">MHA+MLP</td>
<td style="text-align: left;">$\mathbf{1 . 8 5 0}$</td>
<td style="text-align: left;">1.37</td>
<td style="text-align: left;">5.63</td>
<td style="text-align: left;">58.23</td>
<td style="text-align: left;">0.62</td>
</tr>
<tr>
<td style="text-align: left;">Mamba</td>
<td style="text-align: left;">S4+MLP</td>
<td style="text-align: left;">1.853</td>
<td style="text-align: left;">$\underline{1.07}$</td>
<td style="text-align: left;">$\underline{6.05}$</td>
<td style="text-align: left;">$\underline{73.34}$</td>
<td style="text-align: left;">$\underline{0.51}$</td>
</tr>
<tr>
<td style="text-align: left;">Mamba</td>
<td style="text-align: left;">Mamba</td>
<td style="text-align: left;">$\underline{1.852}$</td>
<td style="text-align: left;">$\mathbf{0 . 9 4}$</td>
<td style="text-align: left;">$\mathbf{6 . 2 6}$</td>
<td style="text-align: left;">$\mathbf{8 8 . 5 4}$</td>
<td style="text-align: left;">$\mathbf{0 . 5 2}$</td>
</tr>
</tbody>
</table>
<h1>4.5 Speed and Memory Benchmarks</h1>
<p>We benchmark the speed of the SSM scan operation (state expansion $N=16$ ), as well as the end-to-end inference throughput of Mamba, in Figure 8. Our efficient SSM scan is faster than the best attention implementation that we know of (FlashAttention-2 (Dao 2024)) beyond sequence length 2 K , and up to $20-40 \times$ faster than a standard scan implementation in PyTorch. Mamba achieves $4-5 \times$ higher inference throughput than a Transformer of similar size, since without the KV cache it can use much higher batch sizes. For example, a Mamba-6.9B (untrained) would have higher inference throughput than a $5 \times$ smaller Transformer-1.3B. Details in Appendix E.5, which additionally includes a benchmark of memory consumption.
<img alt="img-8.jpeg" src="img-8.jpeg" /></p>
<p>Figure 8: (Efficiency Benchmarks.) (Left) Training: our efficient scan is $40 \times$ faster than a standard implementation. (Right) Inference: as a recurrent model, Mamba can achieve $5 \times$ higher throughput than Transformers.</p>
<h3>4.6 Model Ablations</h3>
<p>We perform a series of detailed ablations on components of our model, focusing on the setting of language modeling with size $\approx 350 \mathrm{M}$ models at Chinchilla token counts (same setting as Figure 4).</p>
<h3>4.6.1 Architecture</h3>
<p>Table 6 investigates the effects of the architecture (block) and its inner SSM layer (Figure 3). We find that</p>
<ul>
<li>Among previous non-selective (LTI) SSMs, which are equivalent to global convolutions, performance is very similar.</li>
<li>Replacing the complex-valued S4 variant from previous work with a real-valued one does not affect performance much, suggesting that (at least for LM) real-valued SSMs may be a better choice when accounting for hardware efficiency.</li>
<li>Replacing any of these with a selective SSM (S6) significantly improves performance, validating the motivation of Section 3.</li>
</ul>
<p>Table 6: (Ablations: Architecture and SSM layer.) The Mamba block performs similarly to H3 while being simpler. In the inner layer, there is little difference among different parameterizations of LTI models, while selective SSMs (S6) provide a large improvement. More specifically, the S4 (real) variant is S4D-Real and the S4 (complex) variant is S4D-Lin.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: left;">Arch.</th>
<th style="text-align: left;">SSM Layer</th>
<th style="text-align: left;">Perplexity</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Hyena</td>
<td style="text-align: left;">H3</td>
<td style="text-align: left;">Hyena</td>
<td style="text-align: left;">10.24</td>
</tr>
<tr>
<td style="text-align: left;">H3</td>
<td style="text-align: left;">H3</td>
<td style="text-align: left;">S4 (complex)</td>
<td style="text-align: left;">10.30</td>
</tr>
<tr>
<td style="text-align: left;">-</td>
<td style="text-align: left;">H3</td>
<td style="text-align: left;">S4 (real)</td>
<td style="text-align: left;">10.34</td>
</tr>
<tr>
<td style="text-align: left;">-</td>
<td style="text-align: left;">H3</td>
<td style="text-align: left;">S6</td>
<td style="text-align: left;">$\mathbf{8 . 9 5}$</td>
</tr>
</tbody>
</table>
<p>Table 7: (Ablations: Selective parameters.) $\Delta$ is the most important parameter (Theorem 1), but using multiple selective parameters together synergizes.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Selective $\Delta$</th>
<th style="text-align: left;">Selective $\boldsymbol{B}$</th>
<th style="text-align: left;">Selective $\boldsymbol{C}$</th>
<th style="text-align: left;">Perplexity</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">$\boldsymbol{x}$</td>
<td style="text-align: left;">$\boldsymbol{x}$</td>
<td style="text-align: left;">$\boldsymbol{x}$</td>
<td style="text-align: left;">10.93</td>
</tr>
<tr>
<td style="text-align: left;">$\boldsymbol{x}$</td>
<td style="text-align: left;">$\checkmark$</td>
<td style="text-align: left;">$\boldsymbol{x}$</td>
<td style="text-align: left;">10.15</td>
</tr>
<tr>
<td style="text-align: left;">$\boldsymbol{x}$</td>
<td style="text-align: left;">$\boldsymbol{x}$</td>
<td style="text-align: left;">$\checkmark$</td>
<td style="text-align: left;">9.98</td>
</tr>
<tr>
<td style="text-align: left;">$\checkmark$</td>
<td style="text-align: left;">$\boldsymbol{x}$</td>
<td style="text-align: left;">$\boldsymbol{x}$</td>
<td style="text-align: left;">9.81</td>
</tr>
<tr>
<td style="text-align: left;">$\checkmark$</td>
<td style="text-align: left;">$\checkmark$</td>
<td style="text-align: left;">$\checkmark$</td>
<td style="text-align: left;">8.71</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: left;">Arch.</th>
<th style="text-align: left;">SSM Layer</th>
<th style="text-align: left;">Perplexity</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">-</td>
<td style="text-align: left;">Mamba</td>
<td style="text-align: left;">Hyena</td>
<td style="text-align: left;">10.75</td>
</tr>
<tr>
<td style="text-align: left;">-</td>
<td style="text-align: left;">Mamba</td>
<td style="text-align: left;">S4 (complex)</td>
<td style="text-align: left;">10.54</td>
</tr>
<tr>
<td style="text-align: left;">-</td>
<td style="text-align: left;">Mamba</td>
<td style="text-align: left;">S4 (real)</td>
<td style="text-align: left;">10.56</td>
</tr>
<tr>
<td style="text-align: left;">Mamba</td>
<td style="text-align: left;">Mamba</td>
<td style="text-align: left;">S6</td>
<td style="text-align: left;">$\mathbf{8 . 6 9}$</td>
</tr>
</tbody>
</table>
<p>Table 8: (Ablations: Parameterization of $\boldsymbol{A}$.) The more standard initializations based on S4D-Lin (Gu, Gupta, et al. 2022) perform worse than S4D-Real or a random initialization, when the SSM is selective.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">$\boldsymbol{A}_{n}$ Initialization</th>
<th style="text-align: left;">Field</th>
<th style="text-align: left;">Perplexity</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">$\boldsymbol{A}_{n}=-\frac{1}{2}+n i$</td>
<td style="text-align: left;">Complex</td>
<td style="text-align: left;">9.16</td>
</tr>
<tr>
<td style="text-align: left;">$\boldsymbol{A}_{n}=-1 / 2$</td>
<td style="text-align: left;">Real</td>
<td style="text-align: left;">8.85</td>
</tr>
<tr>
<td style="text-align: left;">$\boldsymbol{A}_{n}=-(n+1)$</td>
<td style="text-align: left;">Real</td>
<td style="text-align: left;">8.71</td>
</tr>
<tr>
<td style="text-align: left;">$\boldsymbol{A}_{n} \sim \exp (\mathcal{N}(0,1))$</td>
<td style="text-align: left;">Real</td>
<td style="text-align: left;">8.71</td>
</tr>
</tbody>
</table>
<ul>
<li>The Mamba architecture performs similarly to the H3 architecture (and seems slightly better when using a selective layer).</li>
</ul>
<p>We also investigate interleaving the Mamba block with other blocks such as MLP (a traditional architecture) MHA (a hybrid attention architecture) in Appendix E.2.2.</p>
<h1>4.6.2 Selective SSM</h1>
<p>Table 7 ablates the selective SSM layer by considering different combinations of selective $\Delta, \boldsymbol{B}$, and $\boldsymbol{C}$ parameters (Algorithm 2), showing that $\Delta$ is the most important parameter due to its connection to RNN gating (Theorem 1).</p>
<p>Table 8 considers different initializations of the SSM, which have been shown to make a large difference in some data modalities and settings (Gu, Goel, and Ré 2022; Gu, Gupta, et al. 2022). On language modeling, we find that simpler real-valued diagonal initializations (S4D-Real, row 3) instead of more standard complex-valued parameterizations (S4D-Lin, row 1) perform better. Random initializations also work well, consistent with findings from prior work (Mehta et al. 2023).</p>
<p>Table 9 and Table 10 consider varying the dimension of the $\Delta$ and $(\boldsymbol{B}, \boldsymbol{C})$ projections respectively. Changing them from static to selective provides the most benefit, while increasing the dimensions further generally improves performance modestly with a small increase in parameter count.</p>
<p>Of particular note is the dramatic improvement of the selective SSM when the state size $N$ is increased, with over a 1.0 perplexity improvement for a cost of only $1 \%$ additional parameters. This validates our core motivation in Sections 3.1 and 3.3.</p>
<h2>5 Discussion</h2>
<p>We discuss related work, limitations, and some future directions.
Related Work. Appendix A discusses how the selection mechanism relates to similar concepts. Appendix B has an extended related work of SSMs and other related models.</p>
<p>Table 9: (Ablations: Expressivity of $\Delta$.) The selection mechanism of $\Delta$ constructs it with a projection of the input. Projecting it even to dim. 1 provides a large increase in performance; increasing it further provides further improvements at the cost of a modest increase in parameters. State size fixed to $N=16$.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Size of $\Delta$ proj.</th>
<th style="text-align: left;">Params (M)</th>
<th style="text-align: left;">Perplexity</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">-</td>
<td style="text-align: left;">358.9</td>
<td style="text-align: left;">9.12</td>
</tr>
<tr>
<td style="text-align: left;">1</td>
<td style="text-align: left;">359.1</td>
<td style="text-align: left;">8.97</td>
</tr>
<tr>
<td style="text-align: left;">2</td>
<td style="text-align: left;">359.3</td>
<td style="text-align: left;">8.97</td>
</tr>
<tr>
<td style="text-align: left;">4</td>
<td style="text-align: left;">359.7</td>
<td style="text-align: left;">8.91</td>
</tr>
<tr>
<td style="text-align: left;">8</td>
<td style="text-align: left;">360.5</td>
<td style="text-align: left;">8.83</td>
</tr>
<tr>
<td style="text-align: left;">16</td>
<td style="text-align: left;">362.1</td>
<td style="text-align: left;">8.84</td>
</tr>
<tr>
<td style="text-align: left;">32</td>
<td style="text-align: left;">365.2</td>
<td style="text-align: left;">8.80</td>
</tr>
<tr>
<td style="text-align: left;">64</td>
<td style="text-align: left;">371.5</td>
<td style="text-align: left;">8.71</td>
</tr>
</tbody>
</table>
<p>Table 10: (Ablations: SSM state dimension.) (Top) Constant $\boldsymbol{B}$ and $\boldsymbol{C}$ (Bottom) Selective $\boldsymbol{B}$ and $\boldsymbol{C}$. Increasing the SSM state dimension $N$, which can be viewed as an expansion factor on the dimension of the recurrent state, can significantly improve performance for a negligible cost in parameters/FLOPs, but only when $\boldsymbol{B}$ and $\boldsymbol{C}$ are also selective. Size of $\Delta$ projection fixed to 64 .</p>
<table>
<thead>
<tr>
<th style="text-align: left;">State dimension $N$</th>
<th style="text-align: left;">Params (M)</th>
<th style="text-align: left;">Perplexity</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">1</td>
<td style="text-align: left;">367.1</td>
<td style="text-align: left;">9.88</td>
</tr>
<tr>
<td style="text-align: left;">2</td>
<td style="text-align: left;">367.4</td>
<td style="text-align: left;">9.86</td>
</tr>
<tr>
<td style="text-align: left;">4</td>
<td style="text-align: left;">368.0</td>
<td style="text-align: left;">9.82</td>
</tr>
<tr>
<td style="text-align: left;">8</td>
<td style="text-align: left;">369.1</td>
<td style="text-align: left;">9.82</td>
</tr>
<tr>
<td style="text-align: left;">16</td>
<td style="text-align: left;">371.5</td>
<td style="text-align: left;">9.81</td>
</tr>
<tr>
<td style="text-align: left;">1</td>
<td style="text-align: left;">367.1</td>
<td style="text-align: left;">9.73</td>
</tr>
<tr>
<td style="text-align: left;">2</td>
<td style="text-align: left;">367.4</td>
<td style="text-align: left;">9.40</td>
</tr>
<tr>
<td style="text-align: left;">4</td>
<td style="text-align: left;">368.0</td>
<td style="text-align: left;">9.09</td>
</tr>
<tr>
<td style="text-align: left;">8</td>
<td style="text-align: left;">369.1</td>
<td style="text-align: left;">8.84</td>
</tr>
<tr>
<td style="text-align: left;">16</td>
<td style="text-align: left;">371.5</td>
<td style="text-align: left;">8.71</td>
</tr>
</tbody>
</table>
<p>No Free Lunch: Continuous-Discrete Spectrum. Structured SSMs were originally defined as discretizations of continuous systems (1), and have had a strong inductive bias toward continuous-time data modalities such as perceptual signals (e.g. audio, video). As discussed in Sections 3.1 and 3.5, the selection mechanism overcomes their weaknesses on discrete modalities such as text and DNA; but this conversely can impede their performance on data that LTI SSMs excel on. Our ablations on audio waveforms examine this tradeoff in more detail.</p>
<p>Downstream Affordances. Transformer-based foundation models (particularly LLMs) have a rich ecosystem of properties and modes of interaction with pretrained models, such as fine-tuning, adaptation, prompting, in-context learning, instruction tuning, RLHF, quantization, and so on. We are particularly interested in whether Transformer alternatives such as SSMs have similar properties and affordances.</p>
<p>Scaling. Our empirical evaluation is limited to small model sizes, below the threshold of most strong open source LLMs (e.g. Llama (Touvron et al. 2023)) as well as other recurrent models such as RWKV (B. Peng et al. 2023) and RetNet (Y. Sun et al. 2023), which have been evaluated at the 7B parameter scale and beyond. It remains to assess whether Mamba still compares favorably at these larger sizes. We also note that scaling SSMs may involve further engineering challenges and adjustments to the model that are not discussed in this paper.</p>
<h1>6 Conclusion</h1>
<p>We introduce a selection mechanism to structured state space models, allowing them to perform context-dependent reasoning while scaling linearly in sequence length. When incorporated into a simple attention-free architecture, Mamba achieves state-of-the-art results on a diverse set of domains, where it matches or exceeds the performance of strong Transformer models. We are excited about the broad applications of selective state space models to build foundation models for different domains, especially in emerging modalities requiring long context such as genomics, audio, and video. Our results suggest that Mamba is a strong candidate to be a general sequence model backbone.</p>
<h2>Acknowledgments</h2>
<p>We thank Karan Goel, Arjun Desai, and Kush Bhatia for helpful feedback on the draft.</p>
<h2>References</h2>
<p>[1] Martin Arjovsky, Amar Shah, and Yoshua Bengio. "Unitary Evolution Recurrent Neural Networks". In: The International Conference on Machine Learning (ICML). 2016, pp. 1120-1128.</p>
<p>[2] Žiga Avsec, Vikram Agarwal, Daniel Visentin, Joseph R Ledsam, Agnieszka Grabska-Barwinska, Kyle R Taylor, Yannis Assael, John Jumper, Pushmeet Kohli, and David R Kelley. "Effective Gene Expression Prediction from Sequence by Integrating Long-range Interactions". In: Nature Methods 18.10 (2021), pp. 1196-1203.
[3] Jimmy Ba, Geoffrey E Hinton, Volodymyr Mnih, Joel Z Leibo, and Catalin Ionescu. "Using Fast Weights to Attend to the Recent Past". In: Advances in Neural Information Processing Systems (NeurIPS) 29 (2016).
[4] Jimmy Lei Ba, Jamie Ryan Kiros, and Geoffrey E Hinton. "Layer Normalization". In: arXiv preprint arXiv:1607.06450 (2016).
[5] Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. "Neural Machine Translation by Jointly Learning to Align and Translate". In: The International Conference on Learning Representations (ICLR). 2015.
[6] David Balduzzi and Muhammad Ghifary. "Strongly-typed Recurrent Neural Networks". In: International Conference on Machine Learning. PMLR. 2016, pp. 1292-1300.
[7] Stella Biderman, Hailey Schoelkopf, Quentin Gregory Anthony, Herbie Bradley, Kyle O'Brien, Eric Hallahan, Mohammad Aflah Khan, Shivanshu Purohit, USVSN Sai Prashanth, Edward Raff, et al. "Pythia: A Suite for Analyzing Large Language Models across Training and Scaling". In: The International Conference on Machine Learning (ICML). PMLR. 2023, pp. 2397-2430.
[8] Yonatan Bisk, Rowan Zellers, Jianfeng Gao, Yejin Choi, et al. "PIQA: Reasoning about Physical Commonsense in Natural Language". In: Proceedings of the AAAl conference on Artificial Intelligence. Vol. 34. 2020.
[9] Sid Black, Stella Biderman, Eric Hallahan, Quentin Anthony, Leo Gao, Laurence Golding, Horace He, Connor Leahy, Kyle McDonell, Jason Phang, et al. "Gpt-NeoX-20B: An Open-source Autoregressive Language Model". In: arXiv preprint arXiv:2204.06745 (2022).
[10] Guy E Blelloch. "Prefix Sums and Their Applications". In: (1990).
[11] James Bradbury, Stephen Merity, Caiming Xiong, and Richard Socher. "Quasi-recurrent Neural Networks". In: arXiv preprint arXiv:1611.01576 (2016).
[12] Tom Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared D Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, et al. "Language Models are Few-shot Learners". In: Advances in Neural Information Processing Systems (NeurIPS) 33 (2020), pp. 1877-1901.
[13] Aydar Bulatov, Yuri Kuratov, and Mikhail S Burtsev. "Scaling Transformer to 1M tokens and Beyond with RMT". In: arXiv preprint arXiv:2304.11062 (2023).
[14] Rewon Child, Scott Gray, Alec Radford, and Ilya Sutskever. "Generating Long Sequences with Sparse Transformers". In: arXiv preprint arXiv:1904.10509 (2019).
[15] Krzysztof Choromanski, Valerii Likhosherstov, David Dohan, Xingyou Song, Andreea Gane, Tamas Sarlos, Peter Hawkins, Jared Davis, Afroz Mohiuddin, Lukasz Kaiser, et al. "Rethinking Attention with Performers". In: The International Conference on Learning Representations (ICLR). 2021.
[16] Aakanksha Chowdhery, Sharan Narang, Jacob Devlin, Maarten Bosma, Gaurav Mishra, Adam Roberts, Paul Barham, Hyung Won Chung, Charles Sutton, Sebastian Gehrmann, et al. "PaLM: Scaling Language Modeling with Pathways". In: Journal of Machine Learning Research 24.240 (2023), pp. 1-113. URL: http://jmlr.org/papers/v24/221144.html.
[17] Junyoung Chung, Caglar Gulcehre, KyungHyun Cho, and Yoshua Bengio. "Empirical Evaluation of Gated Recurrent Neural Networks on Sequence Modeling". In: arXiv preprint arXiv:1412.3555 (2014).
[18] Peter Clark, Isaac Cowhey, Oren Etzioni, Tushar Khot, Ashish Sabharwal, Carissa Schoenick, and Oyvind Tafjord. "Think you have Solved Question Answering? Try ARC, the AI2 Reasoning Challenge". In: arXiv preprint arXiv:1803.05457 (2018).
[19] Tri Dao. "FlashAttention-2: Faster Attention with Better Parallelism and Work Partitioning". In: The International Conference on Learning Representations (ICLR). 2024.
[20] Tri Dao, Daniel Y Fu, Stefano Ermon, Atri Rudra, and Christopher Ré. "FlashAttention: Fast and Memory-Efficient Exact Attention with IO-Awareness". In: Advances in Neural Information Processing Systems (NeurIPS). 2022.
[21] Tri Dao, Daniel Y Fu, Khaled K Saab, Armin W Thomas, Atri Rudra, and Christopher Ré. "Hungry Hungry Hippos: Towards Language Modeling with State Space Models". In: The International Conference on Learning Representations (ICLR). 2023.
[22] Yann N Dauphin, Angela Fan, Michael Auli, and David Grangier. "Language Modeling with Gated Convolutional Networks". In: The International Conference on Machine Learning (ICML). PMLR. 2017, pp. 933-941.
[23] DeepSound. SampleRNN. https://github.com/deepsound-project/samplernn-pytorch. 2017.
[24] Jiayu Ding, Shuming Ma, Li Dong, Xingxing Zhang, Shaohan Huang, Wenhui Wang, and Furu Wei. "LongNet: Scaling Transformers to 1,000,000,000 Tokens". In: arXiv preprint arXiv:2307.02486 (2023).</p>
<p>[25] Chris Donahue, Julian McAuley, and Miller Puckette. "Adversarial Audio Synthesis". In: The International Conference on Learning Representations (ICLR). 2019.
[26] Alexey Dosovitskiy, Lucas Beyer, Alexander Kolesnikov, Dirk Weissenborn, Xiaohua Zhai, Thomas Unterthiner, Mostafa Dehghani, Matthias Minderer, Georg Heigold, Sylvain Gelly, et al. "An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale". In: The International Conference on Learning Representations (ICLR). 2020 .
[27] Nelson Elhage, Neel Nanda, Catherine Olsson, Tom Henighan, Nicholas Joseph, Ben Mann, Amanda Askell, Yuntao Bai, Anna Chen, Tom Conerly, Nova DasSarma, Dawn Drain, Deep Ganguli, Zac Hatfield-Dodds, Danny Hernandez, Andy Jones, Jackson Kernion, Liane Lovitt, Kamal Ndousse, Dario Amodei, Tom Brown, Jack Clark, Jared Kaplan, Sam McCandlish, and Chris Olah. "A Mathematical Framework for Transformer Circuits". In: Transformer Circuits Thread (2021). https://transformer-circuits.pub/2021/framework/index.html.
[28] Mahan Fathi, Jonathan Pilault, Pierre-Luc Bacon, Christopher Pal, Orhan Firat, and Ross Goroshin. "Block-State Transformer". In: arXiv preprint arXiv:2306.09539 (2023).
[29] Yassir Fathullah, Chunyang Wu, Yuan Shangguan, Junteng Jia, Wenhan Xiong, Jay Mahadeokar, Chunxi Liu, Yangyang Shi, Ozlem Kalinli, Mike Seltzer, and Mark J. F. Gales. "Multi-Head State Space Model for Speech Recognition". In: Proc. INTERSPEECH 2023. 2023, pp. 241-245. DOI: 10.21437/Interspeech. 2023-1036.
[30] Karl J Friston, Lee Harrison, and Will Penny. "Dynamic Causal Modelling". In: Neuroimage 19.4 (2003), pp. 12731302 .
[31] Daniel Y Fu, Elliot L Epstein, Eric Nguyen, Armin W Thomas, Michael Zhang, Tri Dao, Atri Rudra, and Christopher Ré. "Simple Hardware-efficient Long Convolutions for Sequence Modeling". In: The International Conference on Machine Learning (ICML) (2023).
[32] Ken-ichi Funahashi and Yuichi Nakamura. "Approximation of Dynamical Systems by Continuous Time Recurrent Neural Networks". In: Neural Networks 6.6 (1993), pp. 801-806.
[33] Leo Gao, Stella Biderman, Sid Black, Laurence Golding, Travis Hoppe, Charles Foster, Jason Phang, Horace He, Anish Thite, Noa Nabeshima, Shawn Presser, and Connor Leahy. "The Pile: An 800GB Dataset of Diverse Text for Language Modeling". In: arXiv preprint arXiv:2101.00027 (2020).
[34] Leo Gao, Jonathan Tow, Stella Biderman, Sid Black, Anthony DiPofi, Charles Foster, Laurence Golding, Jeffrey Hsu, Kyle McDonell, Niklas Muennighoff, Jason Phang, Laria Reynolds, Eric Tang, Anish Thite, Ben Wang, Kevin Wang, and Andy Zou. A Framework for Few-shot Language Model Evaluation. Version v0.0.1. Sept. 2021. DOI: 10.5281/zenodo.5371628. URL: https://doi.org/10.5281/zenodo.5371628.
[35] Karan Goel, Albert Gu, Chris Donahue, and Christopher Ré. "It's Raw! Audio Generation with State-Space Models". In: The International Conference on Machine Learning (ICML). 2022.
[36] Albert Gu, Tri Dao, Stefano Ermon, Atri Rudra, and Christopher Ré. "HIPPO: Recurrent Memory with Optimal Polynomial Projections". In: Advances in Neural Information Processing Systems (NeurIPS). 2020.
[37] Albert Gu, Karan Goel, and Christopher Ré. "Efficiently Modeling Long Sequences with Structured State Spaces". In: The International Conference on Learning Representations (ICLR). 2022.
[38] Albert Gu, Caglar Gulcehre, Tom Le Paine, Matt Hoffman, and Razvan Pascanu. "Improving the Gating Mechanism of Recurrent Neural Networks". In: The International Conference on Machine Learning (ICML). 2020.
[39] Albert Gu, Ankit Gupta, Karan Goel, and Christopher Ré. "On the Parameterization and Initialization of Diagonal State Space Models". In: Advances in Neural Information Processing Systems (NeurIPS). 2022.
[40] Albert Gu, Isys Johnson, Karan Goel, Khaled Saab, Tri Dao, Atri Rudra, and Christopher Ré. "Combining Recurrent, Convolutional, and Continuous-time Models with the Linear State Space Layer". In: Advances in Neural Information Processing Systems (NeurIPS). 2021.
[41] Albert Gu, Isys Johnson, Aman Timalsina, Atri Rudra, and Christopher Ré. "How to Train Your HIPPO: State Space Models with Generalized Basis Projections". In: The International Conference on Learning Representations (ICLR). 2023.
[42] Ankit Gupta, Albert Gu, and Jonathan Berant. "Diagonal State Spaces are as Effective as Structured State Spaces". In: Advances in Neural Information Processing Systems 35 (2022), pp. 22982-22994.
[43] Ankit Gupta, Harsh Mehta, and Jonathan Berant. "Simplifying and Understanding State Space Models with Diagonal Linear RNNs". In: arXiv preprint arXiv:2212.00768 (2022).
[44] David Ha, Andrew Dai, and Quoc V. Le. "HyperNetworks". In: The International Conference on Learning Representations (ICLR). 2017.
[45] Danijar Hafner, Timothy Lillicrap, Jimmy Ba, and Mohammad Norouzi. "Dream to Control: Learning Behaviors by Latent Imagination". In: The International Conference on Learning Representations (ICLR). 2020.</p>
<p>[46] Ramin Hasani, Mathias Lechner, Tsun-Hsuan Wang, Makram Chahine, Alexander Amini, and Daniela Rus. "Liquid Structural State-Space Models". In: The International Conference on Learning Representations (ICLR). 2023.
[47] Mikael Henaff, Arthur Szlam, and Yann LeCun. "Recurrent Orthogonal Networks and Long-Memory Tasks". In: The International Conference on Machine Learning (ICML). 2016.
[48] Dan Hendrycks and Kevin Gimpel. "Gaussian Error Linear Units (GELUs)". In: arXiv preprint arXiv:1606.08415 (2016).
[49] Sepp Hochreiter. "Untersuchungen zu dynamischen neuronalen Netzen". In: Diploma, Technische Universität München 91.1 (1991), p. 31.
[50] Sepp Hochreiter, Yoshua Bengio, Paolo Frasconi, Jürgen Schmidhuber, et al. Gradient Flow in Recurrent Nets: The Difficulty of Learning Long-term Dependencies. 2001.
[51] Sepp Hochreiter and Jürgen Schmidhuber. "Long Short-Term Memory". In: Neural Computation 9.8 (1997), pp. 17351780 .
[52] Jordan Hoffmann, Sebastian Borgeaud, Arthur Mensch, Elena Buchatskaya, Trevor Cai, Eliza Rutherford, Diego de Las Casas, Lisa Anne Hendricks, Johannes Welbl, Aidan Clark, et al. "An Empirical Analysis of ComputeOptimal Large Language Model Training". In: Advances in Neural Information Processing Systems (NeurIPS) 35 (2022), pp. 30016-30030.
[53] Weizhe Hua, Zihang Dai, Hanxiao Liu, and Quoc Le. "Transformer Quality in Linear Time". In: The International Conference on Machine Learning (ICML). PMLR. 2022, pp. 9099-9117.
[54] Hassan Ismail Fawaz, Germain Forestier, Jonathan Weber, Lhassane Idoumghar, and Pierre-Alain Muller. "Deep Learning for Time Series Classification: A Review". In: Data Mining and Knowledge Discovery 33.4 (2019), pp. 917963 .
[55] Andrei Ivanov, Nikoli Dryden, Tal Ben-Nun, Shigang Li, and Torsten Hoefler. "Data Movement is All You Need: A Case Study on Optimizing Transformers". In: Proceedings of Machine Learning and Systems 3 (2021), pp. 711-732.
[56] Li Jing, Caglar Gulcehre, John Peurifoy, Yichen Shen, Max Tegmark, Marin Soljacic, and Yoshua Bengio. "Gated Orthogonal Recurrent Units: On Learning to Forget". In: Neural Computation 31.4 (2019), pp. 765-783.
[57] Rudolph Emil Kalman. "A New Approach to Linear Filtering and Prediction Problems". In: (1960).
[58] Angelos Katharopoulos, Apoorv Vyas, Nikolaos Pappas, and François Fleuret. "Transformers are RNNs: Fast Autoregressive Transformers with Linear Attention". In: International Conference on Machine Learning. PMLR. 2020, pp. $5156-5165$.
[59] Shiva Kaul. "Linear Dynamical Systems as a Core Computational Primitive". In: Advances in Neural Information Processing Systems 33 (2020), pp. 16808-16820.
[60] Zhifeng Kong, Wei Ping, Jiaji Huang, Kexin Zhao, and Bryan Catanzaro. "DiffWave: A Versatile Diffusion Model for Audio Synthesis". In: International Conference on Learning Representations. 2021.
[61] Chrysoula Kosma, Giannis Nikolentzos, and Michalis Vazirgiannis. "Time-Parameterized Convolutional Neural Networks for Irregularly Sampled Time Series". In: arXiv preprint arXiv:2308.03210 (2023).
[62] Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton. "ImageNet Classification with Deep Convolutional Neural Networks". In: Advances in Neural Information Processing Systems (NeurIPS) 25 (2012).
[63] Tao Lei. "When Attention Meets Fast Recurrence: Training Language Models with Reduced Compute". In: Proceedings of the 2021 Conference on Empirical Methods in Natural Language Processing. 2021, pp. 7633-7648.
[64] Tao Lei, Yu Zhang, Sida I Wang, Hui Dai, and Yoav Artzi. "Simple Recurrent Units for Highly Parallelizable Recurrence". In: arXiv preprint arXiv:1709.02755 (2017).
[65] Mario Lezcano-Casado and David Martinez-Rubio. "Cheap Orthogonal Constraints in Neural Networks: A Simple Parametrization of the Orthogonal and Unitary Group". In: The International Conference on Machine Learning (ICML). 2019.
[66] Yuhong Li, Tianle Cai, Yi Zhang, Deming Chen, and Debadeepta Dey. "What Makes Convolutional Models Great on Long Sequence Modeling?" In: The International Conference on Learning Representations (ICLR). 2023.
[67] Vasileios Lioutas and Yuhong Guo. "Time-aware Large Kernel Convolutions". In: The International Conference on Machine Learning (ICML). PMLR. 2020, pp. 6172-6183.
[68] Chris Lu, Yannick Schroecker, Albert Gu, Emilio Parisotto, Jakob Foerster, Satinder Singh, and Feryal Behbahani. "Structured State Space Models for In-Context Reinforcement Learning". In: Advances in Neural Information Processing Systems (NeurIPS). 2023.
[69] Shahar Lutati, Itamar Zimerman, and Lior Wolf. "Focus Your Attention (with Adaptive IIR Filters)". In: arXiv preprint arXiv:2305.14952 (2023).</p>
<p>[70] Xuezhe Ma, Chunting Zhou, Xiang Kong, Junxian He, Liangke Gui, Graham Neubig, Jonathan May, and Luke Zettlemoyer. "Mega: Moving Average Equipped Gated Attention". In: The International Conference on Learning Representations (ICLR). 2023.
[71] Eric Martin and Chris Cundy. "Parallelizing Linear Recurrent Neural Nets Over Sequence Length". In: The International Conference on Learning Representations (ICLR). 2018.
[72] Soroush Mehri, Kundan Kumar, Ishaan Gulrajani, Rithesh Kumar, Shubham Jain, Jose Sotelo, Aaron Courville, and Yoshua Bengio. "SampleRNN: An Unconditional End-to-End Neural Audio Generation Model". In: The International Conference on Learning Representations (ICLR). 2017.
[73] Harsh Mehta, Ankit Gupta, Ashok Cutkosky, and Behnam Neyshabur. "Long Range Language Modeling via Gated State Spaces". In: The International Conference on Learning Representations (ICLR). 2023.
[74] Zakaria Mhammedi, Andrew Hellicar, Ashfaqur Rahman, and James Bailey. "Efficient Orthogonal Parametrisation of Recurrent Neural Networks using Householder Reflections". In: International Conference on Machine Learning. PMLR. 2017, pp. 2401-2409.
[75] Eric Nguyen, Karan Goel, Albert Gu, Gordon Downs, Preey Shah, Tri Dao, Stephen Baccus, and Christopher Ré. "S4ND: Modeling Images and Videos as Multidimensional Signals with State Spaces". In: Advances in Neural Information Processing Systems (NeurIPS). 2022.
[76] Eric Nguyen, Michael Poli, Marjan Faizi, Armin Thomas, Callum Birch-Sykes, Michael Wornow, Aman Patel, Clayton Rabideau, Stefano Massaroli, Yoshua Bengio, et al. "HyenaDNA: Long-range Genomic Sequence Modeling at Single Nucleotide Resolution". In: Advances in Neural Information Processing Systems (NeurIPS). 2023.
[77] Catherine Olsson, Nelson Elhage, Neel Nanda, Nicholas Joseph, Nova DasSarma, Tom Henighan, Ben Mann, Amanda Askell, Yuntao Bai, Anna Chen, Tom Conerly, Dawn Drain, Deep Ganguli, Zac Hatfield-Dodds, Danny Hernandez, Scott Johnston, Andy Jones, Jackson Kernion, Liane Lovitt, Kamal Ndousse, Dario Amodei, Tom Brown, Jack Clark, Jared Kaplan, Sam McCandlish, and Chris Olah. "In-context Learning and Induction Heads". In: Transformer Circuits Thread (2022). https://transformer-circuits.pub/2022/in-context-learning-and-induction-heads/index.html.
[78] Aaron van den Oord, Sander Dieleman, Heiga Zen, Karen Simonyan, Oriol Vinyals, Alex Graves, Nal Kalchbrenner, Andrew Senior, and Koray Kavukcuoglu. "WaveNet: A Generative Model for Raw Audio". In: arXiv preprint arXiv:1609.03499 (2016).
[79] Antonio Orvieto, Samuel L Smith, Albert Gu, Anushan Fernando, Caglar Gulcehre, Razvan Pascanu, and Soham De. "Resurrecting Recurrent Neural Networks for Long Sequences". In: The International Conference on Machine Learning (ICML). 2023.
[80] Denis Paperno, Germán Kruszewski, Angeliki Lazaridou, Ngoc-Quan Pham, Raffaella Bernardi, Sandro Pezzelle, Marco Baroni, Gemma Boleda, and Raquel Fernández. "The LAMBADA Dataset: Word Prediction Requiring a Broad Discourse Context". In: Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics. 2016, pp. $1525-1534$.
[81] Razvan Pascanu, Tomas Mikolov, and Yoshua Bengio. "On the Difficulty of Training Recurrent Neural Networks". In: International Conference on Machine Learning. 2013, pp. 1310-1318.
[82] Bo Peng, Eric Alcaide, Quentin Anthony, Alon Albalak, Samuel Arcadinho, Huanqi Cao, Xin Cheng, Michael Chung, Matteo Grella, Kranthi Kiran GV, et al. "RWKV: Reinventing RNNs for the Transformer Era". In: arXiv preprint arXiv:2305.13048 (2023).
[83] Hao Peng, Nikolaos Pappas, Dani Yogatama, Roy Schwartz, Noah A Smith, and Lingpeng Kong. "Random Feature Attention". In: The International Conference on Learning Representations (ICLR). 2021.
[84] Michael Poli, Stefano Massaroli, Eric Nguyen, Daniel Y Fu, Tri Dao, Stephen Baccus, Yoshua Bengio, Stefano Ermon, and Christopher Ré. "Hyena Hierarchy: Towards Larger Convolutional Language Models". In: The International Conference on Machine Learning (ICML). 2023.
[85] Zhen Qin, Xiaodong Han, Weixuan Sun, Bowen He, Dong Li, Dongxu Li, Yuchao Dai, Lingpeng Kong, and Yiran Zhong. "Toeplitz Neural Network for Sequence Modeling". In: The International Conference on Learning Representations (ICLR). 2023.
[86] Zhen Qin, Xiaodong Han, Weixuan Sun, Dongxu Li, Lingpeng Kong, Nick Barnes, and Yiran Zhong. "The devil in linear transformer". In: arXiv preprint arXiv:2210.10340 (2022).
[87] Zhen Qin, Weixuan Sun, Hui Deng, Dongxu Li, Yunshen Wei, Baohong Lv, Junjie Yan, Lingpeng Kong, and Yiran Zhong. "CosFormer: Rethinking Softmax in Attention". In: The International Conference on Learning Representations (ICLR). 2022.
[88] Ali Rahimi and Benjamin Recht. "Random Features for Large-Scale Kernel Machines". In: Advances in Neural Information Processing Systems (NeurIPS) 20 (2007).</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>*Alphabetical by first name.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>