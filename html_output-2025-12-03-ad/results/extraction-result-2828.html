<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-2828 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-2828</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-2828</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-71.html">extraction-schema-71</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of LLM-based agents that use memory systems to play text games, including details about the memory architecture, the text games played, and performance results.</div>
                <p><strong>Paper ID:</strong> paper-270063284</p>
                <p><strong>Paper Title:</strong> <a href="https://export.arxiv.org/pdf/2405.16376v2.pdf" target="_blank">STRIDE: A TOOL-ASSISTED LLM AGENT FRAMEWORK FOR STRATEGIC AND INTERACTIVE DECISION-MAKING</a></p>
                <p><strong>Paper Abstract:</strong> Large Language Models (LLMs) like GPT-4 have revolutionized natural language processing, showing remarkable linguistic proficiency and reasoning capabilities. However, their application in strategic multi-agent decision-making environments is hampered by significant limitations including poor mathematical reasoning, difficulty in following instructions, and a tendency to generate incorrect information. These deficiencies hinder their performance in strategic and interactive tasks that demand adherence to nuanced game rules, long-term planning, exploration in unknown environments, and anticipation of opponents’ moves. To overcome these obstacles, this paper presents a novel LLM agent framework equipped with memory and specialized tools to enhance their strategic decision-making capabilities. We deploy the tools in a number of economically important environments, in particular bilateral bargaining and multi-agent and dynamic mechanism design. We employ quantitative metrics to assess the framework’s performance in various strategic decision-making problems. Our findings establish that our enhanced framework significantly improves the strategic decision-making capability of LLMs. While we highlight the inherent limitations of current LLM models, we demonstrate the improvements through targeted enhancements, suggesting a promising direction for future developments in LLM applications for interactive environments.</p>
                <p><strong>Cost:</strong> 0.019</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e2828.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e2828.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of LLM-based agents that use memory systems to play text games, including details about the memory architecture, the text games played, and performance results.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>STRIDE</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>STRategic and Interactive DEcision-making (STRIDE) framework</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A tool-assisted LLM agent framework that augments a pretrained LLM controller with a structured Thought sequence, external working memory, and domain-specific operational tools to emulate algorithmic behaviors (e.g., value iteration, backward induction) for strategic multi-step decision making.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>STRIDE</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>STRIDE places a pretrained LLM as a central reasoning module that generates a sequence of structured "Thought" units. Each Thought unit contains (i) natural-language text describing the next reasoning step, (ii) an ordered list of operation names (tools) to execute, and (iii) an exit flag. The framework provides operational tools (Python functions) that perform low-level computations (e.g., UpdateQbyR, UpdateQbyPV, UpdateV, GetQ, GetArgMax, CalcUtil, BackwardOneStep, CalculateScores) and interaction tools that convert textual decisions into environment actions. A separate working memory stores high-dimensional problem parameters (transition and reward tensors), intermediate numeric results (Q/V tables, computed SE/SPE prices, game-tree node scores), and episode summaries. The LLM orchestrates reasoning by proposing operations and arguments; the system validates Thoughts against simple rules, executes the operations, updates working memory, and then the LLM generates the next Thought until Exit=true. This design enables STRIDE to emulate algorithmic procedures (value iteration, UCB-VI optimistic planning, backward induction, minimax) while avoiding relying on the LLM for exact arithmetic or large matrix handling.</td>
                        </tr>
                        <tr>
                            <td><strong>base_llm</strong></td>
                            <td>GPT-3.5-Turbo-0125 (many experiments); GPT-4o-2024-05-13 used for dynamic mechanism design and bargaining experiments (temperature=0)</td>
                        </tr>
                        <tr>
                            <td><strong>uses_memory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>working memory</td>
                        </tr>
                        <tr>
                            <td><strong>memory_architecture</strong></td>
                            <td>An explicit external working memory (separate from the LLM context window) stores problem-instance parameters (e.g., full transition matrices P and reward matrices R), intermediate algorithmic results (Q_h(s,a), V_h(s), computed SPE/SE prices, game-tree scores), and empirical counts for model estimation (N(s,a) etc.). Tools read from and write to this memory via well-defined operations (e.g., GetQ, GetQExcluding, GetArgMax, UpdateMDPModel, GetSEPrice, GetScores). The reasoning module invokes operations by name and provides arguments; the system executes operations (Python functions) that directly access and modify working memory. Memory is used both during internal multi-step reasoning (backward passes for value iteration, tree expansion for minimax) and across episodes (model estimation updates for unknown MDPs).</td>
                        </tr>
                        <tr>
                            <td><strong>memory_capacity</strong></td>
                            <td>Not specified as a fixed numeric limit; described as able to hold high-dimensional tensors (transition matrices, reward matrices) and intermediate tables (Q/V) for MDP instances (authors note ability to handle state space size up to ~120 in examples). No explicit numeric capacity or maximum number of stored memories provided.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>Explicit operation-based retrieval (named operations like GetQ, GetQExcluding, GetSEPrice, GetScores) invoked by the LLM's Thought units; retrieval is therefore programmatic (keyed by time step, state, action, or game-tree depth) rather than learned semantic similarity.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_update_strategy</strong></td>
                            <td>Deterministic updates via operations: (a) during reasoning, operations write intermediate results into working memory (e.g., UpdateQbyR, UpdateVbyQ); (b) during interaction episodes with unknown MDPs, UpdateMDPModel is called after each observed transition to increment visitation counts and update empirical P and R estimates; (c) game-tree expansions write computed node scores (CalculateScores) to memory. Updates occur immediately when the corresponding operation is executed.</td>
                        </tr>
                        <tr>
                            <td><strong>text_game_benchmark</strong></td>
                            <td>Tic-Tac-Toe, Connect-N (Connect-3 and Connect-4 experiments), single-issue alternating-offer bargaining (complete and incomplete information), and other strategic game settings (though Tic-Tac-Toe and Connect-N are the discrete turn-based games used to evaluate minimax-like reasoning).</td>
                        </tr>
                        <tr>
                            <td><strong>game_characteristics</strong></td>
                            <td>Tic-Tac-Toe and Connect-N: small combinatorial game trees, perfect-information turn-taking, terminal conditions (win/loss/draw), variable board sizes (3x3, 4x4), require lookahead and backward induction (minimax). Bargaining games: multi-turn alternating offers with finite horizon, require backward induction and belief updates (in incomplete-information variants); MDPs: finite-horizon tabular MDPs with up to |S| and |A| varied, and unknown-model online learning requiring exploration (UCB-VI style). Episode lengths vary (game horizons T or MDP horizon H).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>STRIDE substantially outperforms baselines when using its working memory + tools. Representative metrics reported in the paper: (1) MDP (known-model): in some configurations STRIDE attained success rates up to 0.98 (98%) in choosing the optimal action (Table 1). (2) MDP (unknown-model, exploration): STRIDE emulating UCB-VI converged to optimal policy at similar rate as algorithmic UCB-VI (cumulative reward curves in Fig.4), while baselines failed to explore effectively. (3) Dynamic mechanism design (VCG computation): STRIDE success rates computing VCG mechanism: N=2 -> 0.89, N=4 -> 0.90, N=6 -> 0.86 (Table 2). (4) Bargaining (complete information SPE): STRIDE success rates reaching SPE: T=3 -> 0.79, T=6 -> 0.91, T=9 -> 0.74 (Table 3). (5) Bargaining (incomplete information SE): STRIDE success rates: T=3 -> 0.79, T=6 -> 0.75, T=9 -> 0.69 (Table 5). (6) Tic-Tac-Toe (10 runs, STRIDE as X): X wins 80%, ties 20%, O wins 0% (Table 6). (7) Connect-3 (10 runs): STRIDE X wins 30%, ties 70%, O wins 0% (Table 8).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td>Baselines (zero-shot CoT, zero-shot CoT w/ code, few-shot CoT w/ code) and algorithmic baselines without STRIDE's working memory/tools performed markedly worse: (1) MDP baselines often failed to find optimal policies and showed fluctuating cumulative rewards in the unknown-model setting; (2) Dynamic mechanism design baselines success rates: zero-shot CoT 0.69, zero-shot CoT w/ code 0.63, few-shot CoT w/ code 0.70 vs STRIDE ~0.89-0.90 (Table 2); (3) Bargaining baselines: none of the baseline methods attained >0.5 success rate in reaching SPE across the T values tested (Table 3); (4) Tic-Tac-Toe: RAFA and other baselines had lower X-win rates (see Table 6) and ties/losses more frequent than STRIDE.</td>
                        </tr>
                        <tr>
                            <td><strong>has_ablation_study</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>memory_ablation_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other_memory_types</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings_about_memory_effectiveness</strong></td>
                            <td>The paper's central finding is that an explicit working memory that stores problem parameters and intermediate numerical results, combined with operational tools for exact computation, significantly improves LLM performance on long-horizon, strategic, and multi-step reasoning tasks. Working memory is crucial for (i) avoiding context-length forgetting of high-dimensional parameters (e.g., transition/reward tensors), (ii) carrying intermediate algorithmic state across multi-step Thought sequences (e.g., Q/V tables during backward value iteration), and (iii) enabling reliable emulation of algorithmic procedures (UCB-VI, value iteration, backward induction, minimax), which together yield large performance gains over baselines that rely solely on prompt context or ad-hoc in-context summaries.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'STRIDE: A TOOL-ASSISTED LLM AGENT FRAMEWORK FOR STRATEGIC AND INTERACTIVE DECISION-MAKING', 'publication_date_yy_mm': '2024-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e2828.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e2828.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of LLM-based agents that use memory systems to play text games, including details about the memory architecture, the text games played, and performance results.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>RAFA</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>RAFA (baseline agent implementation / codebase used by authors)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An existing LLM-agent baseline (code referenced by the authors) used with Monte Carlo Tree Search (MCTS) or Minimax tree search; the paper adopts RAFA's memory structure for storing previously computed optimal actions when evaluating turn-based games like Tic-Tac-Toe.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>RAFA (with MCTS or Minimax)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>RAFA variants are used as baseline agents for turn-based games. The paper used two RAFA configurations: RAFA with Monte Carlo Tree Search (MCTS) and RAFA with Minimax. The authors adopted RAFA's memory structure (from its implementation) to store optimal actions and to manage game-tree expansions; prompts and LLM interactions follow RAFA's approach to expand the game tree and evaluate nodes. For RAFA w/ MCTS, the authors used search breadth parameter B=4; for RAFA w/ Minimax, they set search depth U up to full depth in experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>base_llm</strong></td>
                            <td>Not specified in paper as a distinct model; RAFA baselines were run with the same LLM family used elsewhere for baselines (GPT-3.5-Turbo-0125 for baseline experiments).</td>
                        </tr>
                        <tr>
                            <td><strong>uses_memory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>working / cached action memory (game-tree cache)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_architecture</strong></td>
                            <td>Adopted the original RAFA implementation's memory structure to store optimal actions and cached evaluations for game states during tree search. The paper states they used this structure to store optimal actions and to emulate tree expansion and evaluation, but provides no low-level implementation details in-text.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_capacity</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>Implementation-specific cached lookup keyed by game state / node during tree expansion (details not specified in paper).</td>
                        </tr>
                        <tr>
                            <td><strong>memory_update_strategy</strong></td>
                            <td>Updated during tree expansion and search (storing evaluated node scores and optimal actions) as the MCTS or Minimax procedures execute, per RAFA implementation; the paper does not provide exact timing or heuristics beyond adopting RAFA's original scheme.</td>
                        </tr>
                        <tr>
                            <td><strong>text_game_benchmark</strong></td>
                            <td>Tic-Tac-Toe (primary), also used in head-to-head comparisons against STRIDE</td>
                        </tr>
                        <tr>
                            <td><strong>game_characteristics</strong></td>
                            <td>Perfect-information, small finite game tree (3x3 board), requires full-tree or breadth-limited search, scoring +1/-1/0 for win/loss/draw nodes.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>Reported in Tic-Tac-Toe experiments (10 runs): RAFA w/ Minimax: X wins 50%, tie 30%, O wins 20%; RAFA w/ MCTS: X wins 60%, tie 20%, O wins 20% (Table 6). In head-to-head with STRIDE (Table 7), STRIDE vs RAFA w/ MCTS resulted in STRIDE wins 50%, ties 50%, opponent wins 0%.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_ablation_study</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>memory_ablation_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other_memory_types</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings_about_memory_effectiveness</strong></td>
                            <td>The paper uses RAFA's memory structure as a practical cached-action/game-tree store for baseline agents; while RAFA performs reasonably, STRIDE's explicit working-memory + tools typically outperforms or matches RAFA in the evaluated small-board games and strategic tasks. The paper does not provide a controlled ablation isolating RAFA's memory role specifically.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'STRIDE: A TOOL-ASSISTED LLM AGENT FRAMEWORK FOR STRATEGIC AND INTERACTIVE DECISION-MAKING', 'publication_date_yy_mm': '2024-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Generative agents: Interactive simulacra of human behavior <em>(Rating: 2)</em></li>
                <li>Reflexion: Language agents with verbal reinforcement learning <em>(Rating: 2)</em></li>
                <li>Using large language models to simulate multiple humans and replicate human subject studies <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-2828",
    "paper_id": "paper-270063284",
    "extraction_schema_id": "extraction-schema-71",
    "extracted_data": [
        {
            "name_short": "STRIDE",
            "name_full": "STRategic and Interactive DEcision-making (STRIDE) framework",
            "brief_description": "A tool-assisted LLM agent framework that augments a pretrained LLM controller with a structured Thought sequence, external working memory, and domain-specific operational tools to emulate algorithmic behaviors (e.g., value iteration, backward induction) for strategic multi-step decision making.",
            "citation_title": "here",
            "mention_or_use": "use",
            "agent_name": "STRIDE",
            "agent_description": "STRIDE places a pretrained LLM as a central reasoning module that generates a sequence of structured \"Thought\" units. Each Thought unit contains (i) natural-language text describing the next reasoning step, (ii) an ordered list of operation names (tools) to execute, and (iii) an exit flag. The framework provides operational tools (Python functions) that perform low-level computations (e.g., UpdateQbyR, UpdateQbyPV, UpdateV, GetQ, GetArgMax, CalcUtil, BackwardOneStep, CalculateScores) and interaction tools that convert textual decisions into environment actions. A separate working memory stores high-dimensional problem parameters (transition and reward tensors), intermediate numeric results (Q/V tables, computed SE/SPE prices, game-tree node scores), and episode summaries. The LLM orchestrates reasoning by proposing operations and arguments; the system validates Thoughts against simple rules, executes the operations, updates working memory, and then the LLM generates the next Thought until Exit=true. This design enables STRIDE to emulate algorithmic procedures (value iteration, UCB-VI optimistic planning, backward induction, minimax) while avoiding relying on the LLM for exact arithmetic or large matrix handling.",
            "base_llm": "GPT-3.5-Turbo-0125 (many experiments); GPT-4o-2024-05-13 used for dynamic mechanism design and bargaining experiments (temperature=0)",
            "uses_memory": true,
            "memory_type": "working memory",
            "memory_architecture": "An explicit external working memory (separate from the LLM context window) stores problem-instance parameters (e.g., full transition matrices P and reward matrices R), intermediate algorithmic results (Q_h(s,a), V_h(s), computed SPE/SE prices, game-tree scores), and empirical counts for model estimation (N(s,a) etc.). Tools read from and write to this memory via well-defined operations (e.g., GetQ, GetQExcluding, GetArgMax, UpdateMDPModel, GetSEPrice, GetScores). The reasoning module invokes operations by name and provides arguments; the system executes operations (Python functions) that directly access and modify working memory. Memory is used both during internal multi-step reasoning (backward passes for value iteration, tree expansion for minimax) and across episodes (model estimation updates for unknown MDPs).",
            "memory_capacity": "Not specified as a fixed numeric limit; described as able to hold high-dimensional tensors (transition matrices, reward matrices) and intermediate tables (Q/V) for MDP instances (authors note ability to handle state space size up to ~120 in examples). No explicit numeric capacity or maximum number of stored memories provided.",
            "memory_retrieval_method": "Explicit operation-based retrieval (named operations like GetQ, GetQExcluding, GetSEPrice, GetScores) invoked by the LLM's Thought units; retrieval is therefore programmatic (keyed by time step, state, action, or game-tree depth) rather than learned semantic similarity.",
            "memory_update_strategy": "Deterministic updates via operations: (a) during reasoning, operations write intermediate results into working memory (e.g., UpdateQbyR, UpdateVbyQ); (b) during interaction episodes with unknown MDPs, UpdateMDPModel is called after each observed transition to increment visitation counts and update empirical P and R estimates; (c) game-tree expansions write computed node scores (CalculateScores) to memory. Updates occur immediately when the corresponding operation is executed.",
            "text_game_benchmark": "Tic-Tac-Toe, Connect-N (Connect-3 and Connect-4 experiments), single-issue alternating-offer bargaining (complete and incomplete information), and other strategic game settings (though Tic-Tac-Toe and Connect-N are the discrete turn-based games used to evaluate minimax-like reasoning).",
            "game_characteristics": "Tic-Tac-Toe and Connect-N: small combinatorial game trees, perfect-information turn-taking, terminal conditions (win/loss/draw), variable board sizes (3x3, 4x4), require lookahead and backward induction (minimax). Bargaining games: multi-turn alternating offers with finite horizon, require backward induction and belief updates (in incomplete-information variants); MDPs: finite-horizon tabular MDPs with up to |S| and |A| varied, and unknown-model online learning requiring exploration (UCB-VI style). Episode lengths vary (game horizons T or MDP horizon H).",
            "performance_with_memory": "STRIDE substantially outperforms baselines when using its working memory + tools. Representative metrics reported in the paper: (1) MDP (known-model): in some configurations STRIDE attained success rates up to 0.98 (98%) in choosing the optimal action (Table 1). (2) MDP (unknown-model, exploration): STRIDE emulating UCB-VI converged to optimal policy at similar rate as algorithmic UCB-VI (cumulative reward curves in Fig.4), while baselines failed to explore effectively. (3) Dynamic mechanism design (VCG computation): STRIDE success rates computing VCG mechanism: N=2 -&gt; 0.89, N=4 -&gt; 0.90, N=6 -&gt; 0.86 (Table 2). (4) Bargaining (complete information SPE): STRIDE success rates reaching SPE: T=3 -&gt; 0.79, T=6 -&gt; 0.91, T=9 -&gt; 0.74 (Table 3). (5) Bargaining (incomplete information SE): STRIDE success rates: T=3 -&gt; 0.79, T=6 -&gt; 0.75, T=9 -&gt; 0.69 (Table 5). (6) Tic-Tac-Toe (10 runs, STRIDE as X): X wins 80%, ties 20%, O wins 0% (Table 6). (7) Connect-3 (10 runs): STRIDE X wins 30%, ties 70%, O wins 0% (Table 8).",
            "performance_without_memory": "Baselines (zero-shot CoT, zero-shot CoT w/ code, few-shot CoT w/ code) and algorithmic baselines without STRIDE's working memory/tools performed markedly worse: (1) MDP baselines often failed to find optimal policies and showed fluctuating cumulative rewards in the unknown-model setting; (2) Dynamic mechanism design baselines success rates: zero-shot CoT 0.69, zero-shot CoT w/ code 0.63, few-shot CoT w/ code 0.70 vs STRIDE ~0.89-0.90 (Table 2); (3) Bargaining baselines: none of the baseline methods attained &gt;0.5 success rate in reaching SPE across the T values tested (Table 3); (4) Tic-Tac-Toe: RAFA and other baselines had lower X-win rates (see Table 6) and ties/losses more frequent than STRIDE.",
            "has_ablation_study": false,
            "memory_ablation_results": null,
            "comparison_with_other_memory_types": null,
            "key_findings_about_memory_effectiveness": "The paper's central finding is that an explicit working memory that stores problem parameters and intermediate numerical results, combined with operational tools for exact computation, significantly improves LLM performance on long-horizon, strategic, and multi-step reasoning tasks. Working memory is crucial for (i) avoiding context-length forgetting of high-dimensional parameters (e.g., transition/reward tensors), (ii) carrying intermediate algorithmic state across multi-step Thought sequences (e.g., Q/V tables during backward value iteration), and (iii) enabling reliable emulation of algorithmic procedures (UCB-VI, value iteration, backward induction, minimax), which together yield large performance gains over baselines that rely solely on prompt context or ad-hoc in-context summaries.",
            "uuid": "e2828.0",
            "source_info": {
                "paper_title": "STRIDE: A TOOL-ASSISTED LLM AGENT FRAMEWORK FOR STRATEGIC AND INTERACTIVE DECISION-MAKING",
                "publication_date_yy_mm": "2024-05"
            }
        },
        {
            "name_short": "RAFA",
            "name_full": "RAFA (baseline agent implementation / codebase used by authors)",
            "brief_description": "An existing LLM-agent baseline (code referenced by the authors) used with Monte Carlo Tree Search (MCTS) or Minimax tree search; the paper adopts RAFA's memory structure for storing previously computed optimal actions when evaluating turn-based games like Tic-Tac-Toe.",
            "citation_title": "",
            "mention_or_use": "use",
            "agent_name": "RAFA (with MCTS or Minimax)",
            "agent_description": "RAFA variants are used as baseline agents for turn-based games. The paper used two RAFA configurations: RAFA with Monte Carlo Tree Search (MCTS) and RAFA with Minimax. The authors adopted RAFA's memory structure (from its implementation) to store optimal actions and to manage game-tree expansions; prompts and LLM interactions follow RAFA's approach to expand the game tree and evaluate nodes. For RAFA w/ MCTS, the authors used search breadth parameter B=4; for RAFA w/ Minimax, they set search depth U up to full depth in experiments.",
            "base_llm": "Not specified in paper as a distinct model; RAFA baselines were run with the same LLM family used elsewhere for baselines (GPT-3.5-Turbo-0125 for baseline experiments).",
            "uses_memory": true,
            "memory_type": "working / cached action memory (game-tree cache)",
            "memory_architecture": "Adopted the original RAFA implementation's memory structure to store optimal actions and cached evaluations for game states during tree search. The paper states they used this structure to store optimal actions and to emulate tree expansion and evaluation, but provides no low-level implementation details in-text.",
            "memory_capacity": null,
            "memory_retrieval_method": "Implementation-specific cached lookup keyed by game state / node during tree expansion (details not specified in paper).",
            "memory_update_strategy": "Updated during tree expansion and search (storing evaluated node scores and optimal actions) as the MCTS or Minimax procedures execute, per RAFA implementation; the paper does not provide exact timing or heuristics beyond adopting RAFA's original scheme.",
            "text_game_benchmark": "Tic-Tac-Toe (primary), also used in head-to-head comparisons against STRIDE",
            "game_characteristics": "Perfect-information, small finite game tree (3x3 board), requires full-tree or breadth-limited search, scoring +1/-1/0 for win/loss/draw nodes.",
            "performance_with_memory": "Reported in Tic-Tac-Toe experiments (10 runs): RAFA w/ Minimax: X wins 50%, tie 30%, O wins 20%; RAFA w/ MCTS: X wins 60%, tie 20%, O wins 20% (Table 6). In head-to-head with STRIDE (Table 7), STRIDE vs RAFA w/ MCTS resulted in STRIDE wins 50%, ties 50%, opponent wins 0%.",
            "performance_without_memory": null,
            "has_ablation_study": null,
            "memory_ablation_results": null,
            "comparison_with_other_memory_types": null,
            "key_findings_about_memory_effectiveness": "The paper uses RAFA's memory structure as a practical cached-action/game-tree store for baseline agents; while RAFA performs reasonably, STRIDE's explicit working-memory + tools typically outperforms or matches RAFA in the evaluated small-board games and strategic tasks. The paper does not provide a controlled ablation isolating RAFA's memory role specifically.",
            "uuid": "e2828.1",
            "source_info": {
                "paper_title": "STRIDE: A TOOL-ASSISTED LLM AGENT FRAMEWORK FOR STRATEGIC AND INTERACTIVE DECISION-MAKING",
                "publication_date_yy_mm": "2024-05"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Generative agents: Interactive simulacra of human behavior",
            "rating": 2,
            "sanitized_title": "generative_agents_interactive_simulacra_of_human_behavior"
        },
        {
            "paper_title": "Reflexion: Language agents with verbal reinforcement learning",
            "rating": 2,
            "sanitized_title": "reflexion_language_agents_with_verbal_reinforcement_learning"
        },
        {
            "paper_title": "Using large language models to simulate multiple humans and replicate human subject studies",
            "rating": 1,
            "sanitized_title": "using_large_language_models_to_simulate_multiple_humans_and_replicate_human_subject_studies"
        }
    ],
    "cost": 0.01887075,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>STRIDE: A Tool-Assisted LLM Agent Framework for Strategic and Interactive Decision-Making *
28 May 2024</p>
<p>Chuanhao Li chuanhao.li.cl2637@yale.edu 
Yale University</p>
<p>Runhan Yang 
The Chinese University of Hong</p>
<p>Tiankai Li tiankaili@mail.ustc.edu.cn 
University of Science and Technology of China</p>
<p>Milad Bafarassat milad.bafarassat@sabanciuniv.edu 
Sabanci University</p>
<p>Kourosh Sharifi kourosh.sharifi@sabanciuniv.edu 
Sabanci University</p>
<p>Dirk Bergemann dirk.bergemann@yale.edu 
Yale University</p>
<p>Zhuoran Yang zhuoran.yang@yale.edu 
Yale University</p>
<p>Kong 
STRIDE: A Tool-Assisted LLM Agent Framework for Strategic and Interactive Decision-Making *
28 May 20246ACEF71FFB6711951D72900898C35098arXiv:2405.16376v2[cs.CL]LLM agentMarkov decision making processessequential bargaining
Large Language Models (LLMs) like GPT-4 have revolutionized natural language processing, showing remarkable linguistic proficiency and reasoning capabilities.However, their application in strategic multi-agent decision-making environments is hampered by significant limitations including poor mathematical reasoning, difficulty in following instructions, and a tendency to generate incorrect information.These deficiencies hinder their performance in strategic and interactive tasks that demand adherence to nuanced game rules, long-term planning, exploration in unknown environments, and anticipation of opponents' moves.To overcome these obstacles, this paper presents a novel LLM agent framework equipped with memory and specialized tools to enhance their strategic decision-making capabilities.We deploy the tools in a number of economically important environments, in particular bilateral bargaining and multi-agent and dynamic mechanism design.We employ quantitative metrics to assess the framework's performance in various strategic decision-making problems.Our findings establish that our enhanced framework significantly improves the strategic decision-making capability of LLMs.While we highlight the inherent limitations of current LLM models, we demonstrate the improvements through targeted enhancements, suggesting a promising direction for future developments in LLM applications for interactive environments.</p>
<p>Introduction</p>
<p>Large language models (LLMs) such as GPT-4 have demonstrated exceptional proficiency in generating coherent natural language from textual inputs (Bubeck et al., 2023).These models not only exhibit strategic thinking akin to humans (Aher et al., 2022;Kwon et al., 2023) but also demonstrate a remarkable ability to reason flexibly, adeptly handling nuanced and context-specific information (Suzgun et al., 2022).These achievements have sparked significant interest in their potential for decision-making in complex environments (Yao et al., 2022;Shen et al., 2024;Wang et al., 2023).</p>
<p>To further integrate LLMs into our society, such as deploying them as fiduciary agents on behalf of individuals or organizations in a competitive environment where human and AI agents coexist, the ability to reason strategically is of vital importance.However, due to their inherent limitations in basic mathematics (Bubeck et al., 2023), instruction following (Jang et al., 2022), and susceptibility to hallucinations (Chen et al., 2023), the following challenges exist: (i) LLMs may fail to accurately interpret game rules and objectives expressed in natural language, e.g., form a well-defined utility function that reflects their preference over possible outcomes (Guo et al., 2023); (ii) LLMs are generally inept at long-horizon planning to maximize their utility, which is essential in scenarios where decisions have extended consequences (Huang et al., 2024); (iii) They exhibit poor capabilities in strategic exploration of unknown environments (Krishnamurthy et al., 2024), which hampers their ability to optimize decisions on unforeseen conditions; (iv) LLMs have limited capacity in anticipating opponents' moves and adapting their strategies accordingly (Park et al., 2024), which is a crucial aspect for any competitive interaction.These limitations collectively underscore the challenges in deploying LLMs for nuanced and dynamic strategic reasoning tasks.</p>
<p>In light of these challenges, this paper proposes a LLM agent framework designed to enhance their STRategic and Interactive DEcision making capability, named STRIDE1 , as illustrated in Figure 1.Compared to simply prompting the LLM with a description of the problem setup and potentially some chain-of-thought examples (Brookins and DeBacker, 2023;Gandhi et al., 2023), STRIDE can effectively address the aforementioned challenges and enhance the LLM's reasoning capability in strategic settings.Specifically, the LLM, which serves as the controller of the whole framework, orchestrates the reasoning process through a structured Thought sequence, as shown at the top of Figure 1.Compared with popular frameworks like ReAct (Yao et al., 2022) and Reflexion (Shinn et al., 2024), whose Thought step typically involves a single step of textual reasoning before interacting with the environment, which is depicted as the green region of Figure 1, our design is tailored to multi-step reasoning assisted with tools and memory, as shown in the blue part of Figure 1.Each Thought unit outlines a sequence of operations to be executed, which consist of tools specifically engineered to manage the low-level calculations needed in various decision-making scenarios.Additionally, an external working memory is integrated to preserve crucial parameters.Therefore, Challenge (i) can be addressed by executing an operation that evaluates the agent's utility in the Thought unit.Challenge (ii), which is mainly caused by the information loss in long-context (Liu et al., 2024), can be addressed by storing important problem parameters and intermediate results in the working memory.Challenges (iii) and (iv) can be addressed using a combination of demonstrations and dedicated operations that implement the behavior of strategic exploration or belief update.</p>
<p>To evaluate our framework, we carefully choose a collection of decision-making problems that Figure 1: Illustration of STRIDE framework, which consists of a reasoning module powered by LLMs, a working memory that stores important parameters of the problem instance and intermediate results of the reasoning process, as well as tools that facilitate reasoning (taking care of low-level computation and managing the working memory) and acting (converting reasoning texts into executable actions).</p>
<p>highlight the aforementioned challenges in significant and economically relevant real-world strategic settings.First, we evaluate our framework in a general single-agent Markov Decision Process (MDP), which exemplifies Challenges (ii) and (iii).Here the agent needs to strategically explore the unknown environment to improve their estimate of the transition and reward function, as well as planning over a long horizon to compute the optimal policy (Sutton and Barto, 2018).Second, we consider a dynamic mechanism design environment, which offers a multi-agent generalization of MDP where the mechanism designer seeks to maximize the cumulative sum of rewards over multiple agents based on agents' reported reward functions (Bergemann andVälimäki, 2010, 2019).In the multi-agent mechanism design environment, each agent has private information which evolves over time.This problem covers Challenges (i)-(iv).The mechanism designer needs to anticipate the agents' strategic behavior and makes decisions, i.e., allocation and pricing rules, to ensure that truthfully reporting the reward function is unilaterally optimal for each agent.This setting encompasses many important allocation problems such as auctions for sponsored search and display advertising.Third, we consider an important class of bilateral bargaining games, where a seller and a buyer negotiate on the price of a good over a finite number of time steps under complete or incomplete information (Rubinstein, 1982;Fudenberg and Tirole, 1991).This covers Challenges (i), (ii) and (iv), as the agent needs to assess its utility for reaching a deal at different prices and time steps, inferring the opponent's private value based on his/her past responses, as well as predicting the opponent's future behaviors.The bargaining environment has many important applications in procurement and supply-chain sourcing decisions.For each strategic environment, we offer quantitative metrics that allow us to conclude whether the agent succeeded in making the optimal decisions based on the available information.</p>
<p>Through extensive empirical evaluation on the selected decision-making problems, we show that STRIDE framework can make strategic decisions on new problem instances with high success rate with few demonstrations.This highlights the transformative potential of integrating LLMs with specialized tools, memory, and control structures to enhance strategic decision-making capabilities.</p>
<p>Related Work</p>
<p>Evaluating LLMs' Reasoning Capability in Strategic Environments.Recent advancements in LLMs have spurred investigations into their capacity for strategic reasoning.There have been several contributions recently studying the behavior of LLMs in strategic settings, e.g., matrix games like Dictator and Prisoner's Dilemma (Brookins and DeBacker, 2023;Lorè and Heydari, 2023;Fan et al., 2023;Akata et al., 2023;Guo et al., 2023).These works have been particularly interested in assessing whether LLMs can perform strategic or rational reasoning effectively with minimal initial input, often referred to as zero-shot prompting.Recent work by Davidson et al. (2024) and Bianchi et al. (2024) also used bargaining games to evaluate the strategic reasoning of LLMs.Their findings in general suggest that while LLMs can sometimes generate plausible strategies, they often lack consistency and a deep understanding of game dynamics.Another pivotal study by Gandhi et al. (2023) proposed to enhance the strategic reasoning of LLMs by providing few-shot chain-of-thought (CoT) examples for matrix games and multi-turn bargaining games, and showed that LLMs are capable of generalizing the demonstration to new game instances, but still has difficulties in games with complex rules or long horizon.A recent work by Huang et al. (2024) also made a similar observation about the limited capability of LLMs to generalize to various game instances, despite using CoT to enhance reasoning.Applications of LLM-based Agents beyond Strategic Reasoning.While our focus is on enhancing the strategic reasoning capabilities of LLMs, it is important to acknowledge the broader applications of LLM-based agents that do not primarily focus on strategic tasks (Wang et al., 2024), such as social simulation, e.g., building virtual environment with LLM-based agents to simulate social phenomena (Park et al., 2023;Aher et al., 2023), scientific research assistant, e.g., utilize LLMs for automating the design, planning, and execution of scientific experiments (Boiko et al., 2023), software development, e.g., let multiple LLM agents communicate and collaborate through natural language to complete the software development life cycle (Qian et al., 2023), and robotics, e.g., equip LLM with a wide range of manipulation and navigation skills to control a mobile manipulator robot (Ahn et al., 2022).This wide range of applications has led to various design of the LLM agent architecture to enhance its capability in the specific domain, but typically, an LLM agent architecture features memory (Zhu et al., 2023) and planning (Yao et al., 2022) modules that enable LLMs to recall past behaviors and plan future actions in a dynamic environment, and a set of tools (Qin et al., 2023) that facilitate mathematical computation, accessing internal or external memory, and interacting with the environment.LLM-Enhanced Reinforcement Learning Algorithms.The works mentioned in the previous two paragraphs, as well as the STRIDE framework proposed in this paper, utilize LLMs as the decision maker, that is, LLMs are fed prompts containing the current state of the environment, and they generate action recommendations based on this input.The reasoning process that produces the recommendation, regardless of whether it follows certain algorithmic behavior as STRIDE, happens in the language space.Another distinct line of research, emerging primarily from the reinforcement learning community, instead integrates LLMs into traditional reinforcement learning algorithms to leverage the common sense knowledge that LLMs acquire during pretraining (Hao et al., 2023;Liu et al., 2023;Zhou et al., 2023;Zhao et al., 2024).In this way, the reasoning process is hard-coded in programming language like Python, which defines how different components interact with each other.Currently, the most prevalent approach in this domain is the integration of LLMs into Monte Carlo tree search (MCTS) algorithms, where they typically serve as tree traversal policy (Zhao et al., 2024), action pruner (Liu et al., 2023), world model (Hao et al., 2023), and evaluation function (Liu et al., 2023).In comparison, our approach is much more flexible in the sense that we can repurpose the reasoning process of STRIDE to emulate different algorithmic behaviors using various tools and demonstrations.This flexibility extends the utility of our approach well beyond decision-making problems.</p>
<p>LLM Agent Framework for Strategic Decision Making</p>
<p>In this section, we first present the building components of the STRIDE framework, explain how these components interact to support strategic decision-making, and then provide a detailed example by applying it to an autonomous driving scenario, which is modeled as a MDP.</p>
<p>Main Components of the STRIDE Framework</p>
<p>Our primary strategy to address the four challenges in Section 1 is to provide the LLM with tools that take care of low-level computation and a working memory that retains important parameters.Most importantly, we introduce a reasoning module that acts as the central executive, orchestrating the information flow among components and synthesizing structured Thought sequences to solve complex problems.Figure 2 provides a flowchart that illustrates how these components collaboratively facilitate strategic decision-making in an MDP.In the following paragraphs, we will introduce these three components of STRIDE framework in detail.Tool Set.As shown in Figure 1, the tools utilized by STRIDE are categorized into two distinct Figure 2: In STRIDE framework, the LLM controls the execution of operations and access to working memory via a sequence of Thought units.Each Thought unit is a structured data containing three fields: (i) text, which suggests the next step of strategic reasoning and summarize important problem parameters; (ii) operations: a list of operations to execute, in order to compute or retrieve information necessary for reasoning; (iii) exit: a boolean value indicating whether the reasoning process is completed.With proper demonstration and operational tools, STRIDE can implement various algorithmic behaviors (the value iteration algorithm here is one example) to facilitate strategic decision making.groups: operational tools, which are tailored to support sophisticated reasoning processes, and interaction tools, designed to enable STRIDE to interact effectively with its environment.What sets our work apart from previous LLM agents, such as ReAct (Yao et al., 2022) and Reflexion (Shinn et al., 2024), is the sophisticated integration of these operational tools by the Thought sequence to execute complex calculations that traditionally pose challenges for LLMs.For instance, these operations can calculate the utility of the agent based on the outcomes of a game or update the belief about uncertainty on the environment or the other agents.A combination of such operations allows STRIDE to emulate various algorithmic behaviors such as dynamic programming to solve MDPs and Bargaining Games, facilitating a deeper and more precise decision-making process.They also enable our framework to scale to more complex problems through their abstraction of detailed computations.This scalability is crucial in handling larger and more challenging scenarios that are beyond the capacity of typical LLM agents.For instance, in the concrete MDP example to be discussed later in this section, STRIDE can easily handle a state space of size 120.After the reasoning process is completed, which produces a textual description of the LLM's decision, the interaction tools translate this unstructured text into a structured format that is actionable within the specific environment, such as selecting an action in an MDP or offering a price in a sequential bargaining game.Reasoning Module.To effectively leverage the operational tools for solving complex problems, we propose a unique design for the reasoning module, which is empowered by a pretrained LLM like GPT-4 (Achiam et al., 2023) or Claude (Anthropic, 2024), in the STRIDE framework.Using the MDP example in Figure 2, the reasoning process starts when the agent is prompted to answer the question about which action to take at the current time step, as shown on the top right corner.As the first step to answer this question, the LLM generates a Thought unit2 , whose text field describes a general plan about what needs to be done for the current reasoning step in order to answer the question and the operations field comprises an ordered list of operation names that the LLM deems necessary for completing the current step.For the MDP example in Figure 2, the LLM decides to use value iteration to compute the optimal policy, and thus the first step of its reasoning is to compute the Q values associated with the last time step H (see Appendix A for details about value iteration).To do so, operations named UpdateQbyR and UpdateVbyQ are suggested by the LLM, as shown at the bottom of the figure.Note that here the Thought unit only needs to specify which operations are necessary, that is, only the names are needed.The arguments for each selected operation are decided by the LLM on separate API calls based on the context history, as shown on the left of the figure.This particular design choice is motivated by our empirical observation that, letting the LLM simultaneously decide arguments for multiple operations is more prone to error.</p>
<p>Before the execution of the selected operations, the generated Thought unit undergoes a validation process based on predefined rules to ensure its integrity.For example, a common rule applied in our experiments is the mutual exclusivity of the exit condition and the presence of operations: the Thought unit must not simultaneously specify an exit as true while containing non-empty operations, as this often indicates a premature termination of the reasoning process.If this conflict occurs, the system will generate an appropriate error message, append it to the prompt, and prompt the LLM to revise and resubmit the Thought unit for re-evaluation.This mechanism ensures that operations proceed only with validated and logically consistent instructions.Enhanced applications of this functionality involve utilizing an additional LLM to verify whether the newly generated Thought unit adheres to the reasoning logic and language style presented in the demonstration.This step can improve consistency and prevent hallucinations.Employing a secondary LLM for cross-verification not only reinforces the accuracy of the Thought unit but also contributes to the ongoing research in maintaining coherence and reliability in LLM outputs, which is of independent interest.With the Thought unit validated, the selected operations will be executed in the specified order.The outcomes of these operations are then utilized to generate the subsequent Thought unit.This process continues until Exit is set to be true, signaling the completion of the reasoning process.Working Memory.As mentioned in Section 1, for long-horizon decision making, the LLM may forget or neglect important parameters that were mentioned early in the context history.Moreover, an accurate description of the problem instance may sometimes require parameters of high dimensions, e.g., transition matrices of MDP.In this case, storing these parameters in the context history is costly and prone to error.Therefore, STRIDE is equipped with a working memory that stores these parameters, as well as intermediate results computed by the operational tools during the reasoning process.Information contains in the working memory is retrieved by the reasoning module for decision making.</p>
<p>Example: STRIDE Framework in Highway Environment</p>
<p>To illustrate the functionality of the STRIDE framework, we apply it to the Highway Environment (Leurent, 2018) to optimally control a vehicle, as depicted in Figure 3.We will provide a detailed explanation of the operational tools available to the LLM and how they are used in the Thought sequence for strategic decision making.Tabular MDP Formulation.This decision-making problem can be formulated as a tabular MDP with known transition function P : S × A → ∆(S) and reward function R : S × A → R (S and A denote the state and action spaces, respectively), where each state s ∈ S indexes a unique three-way tensor representing the time to collision with other vehicles3 , and the action set A includes changing to left lane, idle, changing to right lane, faster, and slower.Here we focus on a finite-horizon setting, i.e., the agent interacts with the environment for some fixed H steps.At each step h = 1, 2, . . ., H, the agent observes the current state s h ∈ S, and then chooses action a h ∈ A. The environment then produces a reward feedback R(s h , a h ) to the agent, with positive reward for staying in the right lane or maintaining a high speed, and negative reward for any collision, and then the state transits to s h+1 ∼ P (• | s h , a h ).It is known that the optimal policy, in this case, the fastest way to navigate through the traffic, can be computed using value iteration, which we will refer to as a reference algorithm for STRIDE.In the next paragraph, we show how to emulate this algorithmic behavior in the reasoning of STRIDE with specialized operations and demonstration.</p>
<p>Tools and Thought Sequence that Emulate Value Iteration.Value iteration starts from the end of the horizon H and works backwards to the beginning, such that at each step h ∈
[H], it updates the Q h (s, a) = R(s, a) + s ′ ∈S P (s ′ |s, a)V h+1 (s ′ ) and V h (s) = max a∈A Q h (s, a)
, with V H+1 (s) = 0, ∀s.During interaction, the agent can simply choose a h = argmax a∈A Q h (s h ) for state s h at each step h.Therefore, to enable the LLM to compute the optimal policy for any MDP instance in this principled manner, we equip it with the following operations, i.e., a set of primitives that handle low-level calculations, thereby freeing the LLM to focus on higher-order reasoning.</p>
<p>• UpdateQbyR: add reward R(s, a) to Q h (s, a) for all (s, a) pairs at the specified time step h,</p>
<p>• UpdateQbyPV: add one-step look-ahead value s ′ ∈S P (s ′ |s, a)V h+1 (s ′ ) to Q h (s, a) for all (s, a)</p>
<p>pairs at the specified time step h, • UpdateV: take maximum V h (s) = max a∈A Q h (s, a) for the specified time step h, • GetQ: retrieve the values of Q h (s, a) for all action a ∈ A at the specified time step h and state s.</p>
<p>• GetArgMax: return the indices corresponding to the maximal value in the given list of numbers</p>
<p>To make the LLM generate Thought sequences that correctly utilize these operations to emulate value iteration, we employ a structured demonstration generation approach outlined as follows:</p>
<p>• Implement the value iteration algorithm in Python using the provided operations to handle the computational intricacies; • Augment the algorithm with annotated code that generates explanatory comments-the Thought text-at key steps to illustrate the logic and progression of the algorithm; • Sample a specific instance of the MDP, execute the augmented value iteration algorithm on this instance, and capture the resulting sequence of operation calls and textual comments.With the generated demonstration sequence, STRIDE not only performs calculations correctly but also maintains a logically coherent order when handling various MDP instances.Moreover, the flexible design of our framework, as detailed in Figure 2, allows it to emulate a broad spectrum of algorithms beyond value iteration.Consequently, STRIDE offers a flexible framework that can be extended to a diverse array of problem domains involving strategic decision-making, where algorithmic behavior of LLMs is critical.In particular, to tailor STRIDE to other domains, it suffices to construct domain-specific Tool Sets and modify the Thoughts to emulate other algorithms leveraging these tools.As we will see in the sequel, our framework can be applied to dynamic mechanism design, two-player bargaining games, and zero-sum Markov games such as Tic-Tac-Toe, where various Tool Sets and Thoughts are constructed under the STRIDE framework.</p>
<p>Experiments</p>
<p>For each decision-making problem mentioned in Section 1, we first construct the operational tools and generate the corresponding demonstrations following the procedure described in Section 3.2, so that STRIDE is able to mimic the reference algorithm when solving each problem.Descriptions of the selected reference algorithms and the constructed operations can be found in Appendix A. Then to evaluate whether STRIDE can reliably solve new problem instances given provided demonstrations, we repeat experiments on randomly sampled instances and report the averaged results.For comparison, we include the following baseline agents: (i) zero-shot Chain-of-Thought (CoT), (ii) zero-shot CoT with code interpreter, and (iii) few-shot CoT with code interpreter, where the latter two can utilize the coding capability of LLMs (through OpenAI Assistants API) to write and execute programs to solve the decision-making problems.Compared with (ii), (iii) is additionally provided with example implementation of the reference algorithm for each problem.Prompts used in all the experiments are given in Appendix B. We also conducted additional experiments on other problem setups like Tic-Tac-Toe and Connect-N games to further demonstrate the generality of STRIDE.Details about these additional experiments are given in Appendix C.</p>
<p>Markov Decision Processes</p>
<p>We first evaluate STRIDE and the baselines (GPT-3.5-Turbo-0125with temperature set to 0 is used for all agents) on MDP under both known model, where the transition function P and reward function R are given to the agent in the beginning, and unknown model, where the agent needs to estimate P and R during online interactions.In the following paragraphs, we first provide a formal definition of the objective of the agent under each setting, and then discuss the experiment setup and results.Agent's Objective in MDP with Known Model.When the transition and reward functions are known to the agent, the objective of the agent is to find a policy, denoted as π = {π h } H h=1 with π h : S → ∆(A) for h ∈ [H], that maximizes the expected cumulative rewards over H time steps:
max π E π,P H h=1 R(s h , a h ) := V π 1 , (4.1)
where the expectation is with respect to the randomness in state transitions and the stochasticity of π.Let's denote the optimal Q value function as
Q ⋆ h (s, a) for h ∈ [H].
Then for any state s h encountered by the agent at step h ∈ [H], we check whether the action a h taken by the agent satisfies a h = argmax a∈A Q ⋆ h (s, a), and report the average success rate in the following experiment.Experiment Setup and Results.We evaluate on MDPs with horizon length H ∈ {5, 10, 15}, number of states |S| ∈ {3, 10}, and number of actions |A| ∈ {3, 10}.For each configuration, we repeat the experiment for 20 times on randomly generated instances, by sampling dense tensors of size R S×A×S and R S×A as the transition function and reward function, respectively.The average success rates are reported in Table 1.For STRIDE, we only provide it with a single demonstration that solves a MDP instance with H = 5, S = 5, A = 5.We can see that STRIDE outperforms the baselines in terms of finding the optimal policy for the given MDP instances.In this setting, P and R are unknown to the agent, but the agent is allowed to repetitively interact with the same MDP instance for a total number of K episodes to explore and update its belief about P and R using the observed feedback.The objective of the agent is to choose a sequence of policies π 1 , π 2 , . . ., π K , that minimizes the cumulative regret:
min π 1 ,π 2 ,...,π K K k=1 V π ⋆ 1 − V π k 1 . (4.2)
In addition to the challenge of long-horizon planning exemplified by Eq (4.1), Eq (4.2) also requires addressing the exploration-exploitation dilemma.Specifically, the agent needs to strategically balance between exploring unfamiliar state-action pairs to learn P and R, and exploiting the current knowledge about P and R to obtain more rewards.A classic solution to this problem is UCB-VI (Azar et al., 2017), which is used as the reference algorithm for STRIDE.To help the baselines work with long context history (K × H interactions in total), an external summarization of the past episodes is added in their prompts at the beginning of each new episode, similar to Krishnamurthy et al. (2024).</p>
<p>Experiment Setup and Results.In addition to STRIDE and the aforementioned baselines, we also include UCB-VI algorithm in the experiments, which serves as a reference.We evaluate on 10 randomly generated MDP instances with H = 5, |S| = 3, and |A| = 3, with the agents repetitively playing each instance for a total number of K = 40 episodes, and average the results over the 10 instances.In Figure 4, we report how the cumulative rewards collected in each episode change as the number of episodes experienced by the agent increases.STRIDE reliably implements the behavior of UCB-VI algorithm using the provided operations, and thus converges to the optimal policy at a similar rate as UCB-VI.In comparison, the baselines, though given additional summarization of history, fail to find the optimal policy as they cannot efficiently explore the environment.</p>
<p>Dynamic Mechanism Design</p>
<p>Section 4.1 presents the challenges of long-horizon planning and strategic exploration in MDP, which only involves a single agent.Here we further evaluate STRIDE (GPT-4o-2024-05-13 with temperature set to 0) on dynamic Vickrey-Clarke-Groves (VCG) mechanism design problem (Bergemann and Välimäki, 2019), a multi-agent generalization of MDP, which further necessitates the agent's ability to anticipate other agents' behaviors and plan accordingly.</p>
<p>Agent's Objective in Dynamic Mechanism Design.Consider a mechanism designer and a set of N agents.The mechanism designer needs to elicit the reward functions { R i } N i=1 from the N agents, with each R i : S × A → R, and the agents can be untruthful.Based on reported reward functions, the designer chooses a policy π : S → ∆(A).At each step h ∈ [H], the designer takes action a h ∼ π(s h ), e,g., the allocation of some scarce resource among I agents, and each agent i ∈ [N ] receives reward R i (s h , a h ), i.e., agent i's valuation for a h at state s h .After H steps of interactions, the designer needs to charge each agent i some price p i ∈ R. The objective of each agent i is to maximize its utility u i ( R i ) = V π (P, R i ) − p i by strategically reporting the reward function R i .The objective of the designer is to maximize the expected cumulative sum of rewards, by strategically choosing the policy and pricing rule.This can be formulated as the following optimization problem
max π,{p i } i∈[N ] V π (P, n i=1 R i ) s.t. u i (R i ) ≥ u i (R ′ i ), ∀R ′ i , i (4.3)
where the constraint guarantees the incentive compatibility of all agents.It is known that the unique solution to Eq (4.3) is the VCG mechanism, i.e.,
π ⋆ := argmax π V π (P, N i=1 R i ), p ⋆ i := V π * −i (P, j̸ =i R j ) − V π * (P, j̸ =i R j ), for i = 1, 2, . . . , n,(4.4)
where π * −i := argmax π V π (P, j̸ =i R j ).Similar to Eq (4.1), Eq (4.4) can be solved by separately computing policies π ⋆ and {π * −i } N i=1 via value iteration, and then evaluating π ⋆ on MDP instances with transition function P and reward function j̸ =i R j for i = 1, 2, . . ., N (description of this reference algorithm is given in Appendix A).The success rate for the experiments on this problem is computed by considering: (i) whether the chosen action a h satisfies a h = π ⋆ h (s h ) for h ∈ [H]; and (ii) whether the charged price p i satisfies |p i − p ⋆ i | ≤ 10 −2 .Experiment Setup and Results.We evaluate on problem instances with horizon H = 5, number of states |S| = 3, number of actions |A| = 3, and number of agents N ∈ {2, 4, 6}.For each configuration, we repeat the experiment 10 times on randomly generated instances, by sampling dense tensors of size R S×A×S and R N ×S×A as the transition function and reward functions for N agents, respectively.The average success rate are reported in Table 2.We observe that the baselines, despite being capable of computing the optimal action most of the times, cannot generalize the same value iteration procedure to compute the VCG price correctly.In comparison, STRIDE can reliably compute the VCG price on most problem instances, which leads to its higher success rate.</p>
<p>Bargaining Games</p>
<p>We further evaluate STRIDE and the baselines (GPT-4o-2024-05-13 with the temperature set to 0) on bargaining games, in which a buyer and a seller engage in repeated negotiation for a finite number of steps.In order to maximize their utility, both the buyer and the seller need to predict the response of their opponent over long-horizon, based on the potentially incomplete information they have.</p>
<p>Alternating Offer Bargaining under Complete Information.We first consider the elementary yet seminal setting in which a buyer and a seller engage in a T -step bargaining process (with T &lt; ∞) over price p of the good.Specifically, at time step t = 1, the buyer offers a price to the seller and the game ends if the seller accepts the offer.Otherwise, the game continues to the next time step t = 2, where the seller makes a counteroffer.They repeat this process until the deadline T is reached.Assuming the buyer's value for the item is 1 and the seller's cost is 0, then the utility function of the buyer, denoted as u b , and that of the seller, denoted as u s , for some price p at time step t are respectively, with δ b , δ s ∈ [0, 1] being the discount factor of their utilities over time.Note that in this setting, the buyer's value 1, the seller's cost 0, and the values of δ b , δ s and T are public information.
u b (p, t) = (1 − p) • δ t−1 b , if t ≤ T , and 0 otherwise; u s (p, t) = (p − 0) • δ t−1 s , if t ≤ T ,
The optimal decision for either agent, assuming his/her opponent is also acting optimally, i.e., being rational, is to play the Subgame Perfect Equilibrium (SPE) strategy, which, in this setting, is unique and can be computed using backward induction (Fudenberg and Tirole, 1991).Description of this reference algorithm and the operations constructed for STRIDE is given in Appendix A. To evaluate whether STRIDE and the baselines can make optimal decisions, we let buyer and seller empowered by the same method to bargain with each other, and report the success rates in reaching SPE.</p>
<p>Experiment Setup and Results.We evaluate on bargaining problems with deadline T ∈ {3, 6, 9}.In each case, we repeat the experiments on 10 randomly generated instances, by sampling discount factors δ b , δ s ∈ U(0.5, 1.0).The average success rates are reported in Table 3.We can see that, none of the baseline methods attains success rate higher than 0.5, which is because when it is their turn to offer, they cannot offer a price close to SPE, though being explicitly instructed in the prompt to assume rational opponent behavior when making decisions.It is worth noting that the existence of the code interpreter did not provide any advantage this time compared with the results for MDP in Table 1.Though the LLM did attempt to implement the backward induction algorithms to solve SPE, they failed to get everything right and produce the correct results.We hypothesize that this distinction is due to the insufficiency of training data related to the implementation of backward induction algorithms for bargaining, especially compared with the value iteration algorithm for MDP.Moreover, to further illustrate the advantage of being able to strategically reason about the decisions in bargaining, we pit STRIDE against zero-shot CoT, the best-performing baseline in Table 3.The results (averaged over 10 randomly generated instances) are summarized in Table 4.</p>
<p>We can see that, by mimicking the reference algorithm, STRIDE guarantees an outcome that is no worse than the SPE regardless of the role it plays.As mentioned in the previous paragraph, the baseline cannot accurately compute the SPE price, and thus, when it serves as the buyer who needs to make the initial offer, often ends up with a sale price that is higher than SPE price, which demonstrates its sub-optimality.(v), are public information.F (•) is supported on [0, 1] and we assume F (v) = v, i.e., a uniform distribution.In each time step t = 1, 2, . . ., T , the seller offers a price and the buyer responds by acceptance or rejection.Similar to Eq (4.5), their utility functions are Different from the complete information setting where we evaluate the agents by examining whether the unique SPE is reached, here we consider sequential equilibrium (SE) due to the uncertainty on the buyer's value.Fortunately, in the particular setting described above, the SE is still unique (Cramton, 1984), and thus we can similarly evaluate the agents using the success rates of reaching SE.To compute the SE, we propose a reference algorithm for STRIDE that combines bisection search and backward induction and construct the specialized tools.More details are given in Appendix A.
u b (p, t) = (b − p) • δ t−1 b , if t ≤ T ,
Experiment Setup and Results.We evaluate the agents on problems with deadline T ∈ {3, 6, 9}.</p>
<p>In each case, we repeat the experiments on 10 randomly generated instances, by sampling discount factors δ b , δ s ∈ U(0.5, 1.0) and buyer's value b ∈ U(0.1, 0.9).The average success rates are reported in Table 5.Again, we observe that STRIDE outperforms the baseline methods, as it is able to compute the SE by mimicking the reference algorithm we designed.</p>
<p>Conclusion</p>
<p>This paper presented the STRIDE framework, enhancing LLMs' strategic decision-making capabilities.Through integrating a structured Thought process with external working memory and operational tools, STRIDE enables LLMs to overcome significant limitations such as strategic exploration and dynamic opponent interaction.Our evaluations across diverse decision-making scenarios validate STRIDE's effectiveness, suggesting its potential as a robust tool for strategic thinking in complex environments.For further development of the STRIDE framework, we propose the following research avenues.(i) Currently, STRIDE utilize specially designed Python functions as tools to facilitate the formation of strategies and the choice of actions by the agents in bilateral bargaining, an interesting direction is to replace it with models trained using data collected during interactions.</p>
<p>(ii) Automatic synthesis of operations: Another interesting direction would be developing LLMs specifically fine-tuned on implementing primitives that handle the low-level calculations of various decision-making problems.(iii) Fine-tuning on the Thought Sequence: To further enhance LLM's understanding and execution of the Thought sequence as well as the associated operations, we can fine-tune the model on the sequences generated using the procedure described in Section 3.2.</p>
<p>Appendix A Reference Algorithms for STRIDE</p>
<p>As discussed in Section 3, the main strength of STRIDE lies in its capability of emulating various algorithmic behaviors in its Thought process to solve decision-making problems that are challenging to LLMs.In this section, we provide the descriptions of the reference algorithms that STRIDE emulates when solving the problems in Section 4.</p>
<p>A
for step h = H, H − 1, • • • , 1 do 4:
▷ Thought: Now we can continue to compute the Q-values for the current step h.</p>
<p>5:</p>
<p>▷ Operation: call UpdateQbyR with inputs {time step: h} 6:</p>
<p>▷ Operation: call UpdateQbyPV with inputs {time step: h} 7:</p>
<p>▷ Operation: call UpdateVbyQ with inputs {time step: h} 8:</p>
<p>for each state s ∈ S do 9:</p>
<p>for each action a ∈ A do ▷ Exit: I should choose Action a h as it maximizes the Q values.Now exit reasoning.</p>
<p>23:</p>
<p>Take action a h = argmax a∈A Q h (s h , a)</p>
<p>24:</p>
<p>Observe reward r(s h , a h ) = R(s h , a h ) + ϵ and state transits to s h+1 25: end for Algorithm 2 Value Iteration Upper Confidence Bound for MDPs with Unknown Model 1: Initialize V H+1 (s) = 0, ∀s ∈ S 2: for episode t = 1, 2, . . ., T do 3:</p>
<p>▷ Question: Compute the Optimistic Policy for Exploration.</p>
<p>4:</p>
<p>for
step h = H, H − 1, • • • , 1 do 5:
▷ Thought: Now we can continue to compute the Q-values for the current step h.</p>
<p>6:</p>
<p>▷ Operation: call UpdateQbyR with inputs {time step: h} 7:</p>
<p>▷ Operation: call UpdateQbyPV with inputs {time step: h} 8:</p>
<p>▷ Operation: call UpdateQbyBonus with inputs {time step: h} 9:</p>
<p>▷ Operation: call UpdateVbyQ with inputs {time step: h} 10:</p>
<p>for each state s ∈ S do 11:</p>
<p>for each action a ∈ A do 12:</p>
<p>▷ Action: call Python function to calculate Q value for (s, a)</p>
<p>13:
Q h (s, a) = R(s, a) + s ′ ∈S P (s ′ |s, a)V h+1 (s ′ ) + b(N (s, a)) 14:
end for 15:
V h (s) = max a∈A Q h (s, a) 16:
end for 17:</p>
<p>end for 18:</p>
<p>▷ Thought: I have finished value iteration.Now exit reasoning.</p>
<p>19:
for step h = 1, 2, • • • , H do 20:
Observe state s h</p>
<p>21:</p>
<p>▷ Question: Which action I should take?</p>
<p>22:</p>
<p>▷ Thought: I should choose the action that maximizes the computed Q values.</p>
<p>23:</p>
<p>▷ Operation: call GetQ with inputs {time step: h, cur state: s h } 24:</p>
<p>▷ Operation: call GetArgMax with inputs {q vals: [. . .]}</p>
<p>25:</p>
<p>▷ Exit: I should choose Action a h as it maximizes the Q values.Now exit reasoning.</p>
<p>26:</p>
<p>Take action a h = argmax a∈A Q h (s h , a)</p>
<p>27:</p>
<p>Observe reward r(s h , a h ) = R(s h , a h ) + ϵ and state transits to s h+1 28:</p>
<p>▷ Question: Update estimations of P and R.</p>
<p>29:</p>
<p>▷ Thought: I should update my estimation using the observed (s h , a h , s h+1 , r h ).</p>
<p>30:</p>
<p>▷ Operation: call UpdateMDPModel with inputs {s: s h , a: a h , s prime: s h+1 , r: r h } 31:</p>
<p>▷ Thought: My estimation is updated.Now exit reasoning.</p>
<p>32:
N (s h , a h ) = N (s h , a h ) + 1, N (s h , a h , s h+1 ) = N (s h , a h , s h+1 ) + 1 33: P (s h+1 |s h , a h ) = N (s h ,a h ,s h+1 ) N (s h ,a h ) , R(s, a) = R(s, a) × N (s h ,a h )−1 N (s h ,a h ) + r(s h ,a h ) N (s h ,a h ) 34:
end for 35: end for • UpdateQbyR: add reward R(s, a) to Q h (s, a) for all (s, a) pairs at the specified time step h,</p>
<p>• UpdateQbyPV: add one-step look-ahead value s ′ ∈S P (s ′ |s, a)V h+1 (s ′ ) to Q h (s, a) for all (s, a)</p>
<p>pairs at the specified time step h, • UpdateV: take maximum V h (s) = max a∈A Q h (s, a) for the specified time step h, • GetQ: retrieve the values of Q h (s, a) for all action a ∈ A at the specified time step h and state s.</p>
<p>• GetArgMax: return the indices corresponding to the maximal value in the given list of numbers if current player = Buyer then 6:</p>
<p>▷ Operation: call BackwardOneStep with {agent: buyer, op u: 0.0, t: T } 7:</p>
<p>The SPE price p T := 0.0 8: else 9:</p>
<p>▷ Operation: call BackwardOneStep with {agent: seller, op u: 0.0, t: T } 10:</p>
<p>The SPE price p T := 1.0 Buyer utility u b (p t , t), Seller utility u s (p t , t) 24: end for 25: ▷ Thought: SPE prices for all time steps are calculated.Now exit reasoning.</p>
<p>A.4 Backward Induction for Bargaining in Incomplete Information Setting</p>
<p>Since the seller is uncertain about the value b of the buyer, at each time step t the seller decides the offer price p t based on his/her belief constructed using observations up to time step t − 1, which is denoted as U(0, b t−1 ), i.e., the true value b is uniformly distributed in [0, b t−1 ] (with b 0 = 1).Therefore, different from SPE considered in complete information setting, SE specifies not only the strategies of the players, but also the belief, which in our case is the sequence {b 0 , b 1 , . . ., b T −1 }.In classic economics literature (Sobel and Takahashi, 1983;Cramton, 1984), this sequence is obtained by: (i) backward induction from time T to time 1, which results in b 0 expressed as a function of b T −1 ; (ii) as the initial belief b 0 = 1, we can solve this equation to obtain the value of b T −1 .This provides an analytical form for {b 0 , b 1 , . . ., b T −1 } using the parameters δ b , δ s , T .To make the inner logic more transparent during reasoning, we replace this analytical solution with a bisection search when designing the reference algorithm for STRIDE, with its full description given in Algorithm 6.</p>
<p>We provide the following operational tools to STRIDE to help it emulate Algorithm 6: • CalcUtil: calculate buyer or seller's utility using Eq (4.6), with the role of the agent, the specified price and time step as inputs.
u a = u b (p, t), u r = u b (p t+1 , t + 1) 9: else 10: u a = u s (p, t), u r = u s (p t+1 , t + 1) 11: end if 12: if u a ≥ u r then 13:
▷ Thought: I should accept the offer.Now exit reasoning.▷ Thought: I should reject the offer.Now exit reasoning.</p>
<p>17:</p>
<p>return Reject 18: end if</p>
<p>• SolveLast: compute seller's expected utility and the corresponding price at the last time step (description given in Algorithm 8) • Solve: compute the expected utility and the corresponding price at the current time step, based on the results computed for the next time step (description given in Algorithm 9) • GetSEPrice: retrieve the previously computed SE price for the specified time step Then similar to the complete information setting, when deciding whether to accept an offer from the seller, the buyer can compare the utility he/she can get by accepting the current offer, and the utility he/she can get by waiting for seller's offer in the next time step.For the latter, as the buyer assumes the seller is rational, the next offer from seller is predicted using the SE price from Algorithm 6.  12:
3: l = 0, h = 1, B ′ T −1 = (l + h)/2 4: ▷ Operation: Call ComputeBt with inputs {time step: 1, b last: B ′ T −1 } 5: b ′ 0 = ComputeBt(1, b ′ T −1 ) 6: while |b ′ 0 − 1.0| ≥ 10 −3 do 7: if b ′ 0 ≤ 1.0 then 8: ▷ Thought: Since b ′ 0 is smaller than b 0 , I should focus on the region [b ′ T −1 , h] next time.h = b ′ T −1 13: end if 14: b ′ T −1 = (l + h)/2 15:
▷ Operation: Call ComputeBt with inputs {time step: 1, b last:  ▷ Thought: Now I need to continue to time step t − 1. 28: end for 29: ▷ Thought: I have reached t = 1.Exit reasoning now.
B ′ T −1 } 16: b ′ 0 = ComputeBt(1, b ′ T −1 ) 17: end while 18: ▷ Thought: Since |b ′ 0 − 1.0| &lt; 10 −3 ,</p>
<p>Algorithm 7 ComputeBt</p>
<p>1: Inputs time step, the time index of current belief, and b last, the belief at time step T .2: Initialize constants {c τ } T τ =2 with c T = 0.5 and c τ =
(1−δ b +δ b c τ +1 ) 2 2(1−δ b +δ b c τ +1 )−δsc τ +1 for τ ≥ 2. 3: Set t = time step, b T −1 = b last 4: for τ = T − 1, T − 2, . . . , t do 5: b τ −1 = 2(1−δ b +δ b c τ +1 )−δsc τ +1 1−δ b +δ b c τ +1 b τ 6: end for 7: return b t−1</p>
<p>Appendix B Prompts of the STRIDE Framework and Baselines</p>
<p>The prompts used for the LLM agents in Section 4 consist of three parts, which we mark using different colors in this section: a system prompt setting the role of the agent (gray), followed by a formal description of the decision-making problem to be solved (light blue), and then parameters of the problem instance (light green).The system prompt is problem-agnostic, which is given below.</p>
<p>System prompt for zero-shot CoT</p>
<p>You are a world class intelligent agent capable of solving various classes of decision making problems.For each decision making problem you encounter next, you will be given the description of the problem setup and your objective.You need to carefully reason about the problem step-by-step, and make optimal decisions for the encountered problem instance.</p>
<p>System prompt for zero-shot CoT w/ code interpreter You are a world class intelligent agent capable of solving various classes of decision making problems.For each decision making problem you encounter next, you will be given the description of the problem setup and your objective.You need to carefully reason about the problem step-by-step, and make optimal decisions for the encountered problem instance.You are provided with a code interpreter.You should write and run code to answer the questions.</p>
<p>System prompt for few-shot CoT w/ code interpreter You are a world class intelligent agent capable of solving various classes of decision making problems.For each decision making problem you encounter next, you will be given the description of the problem setup and your objective.Your need to carefully reason about the problem, and make optimal decisions for the encountered problem instance.You are provided with a code interpreter and an example implementation.You should write and run code to answer the questions following the example.</p>
<p>System prompt for STRIDE</p>
<p>You are a world class intelligent agent capable of solving various classes of decision making problems.For each decision making problem you encounter next, you will be given the description of the problem setup and your objective.Your need to carefully reason about the problem step-by-step, and make optimal decisions for the encountered problem instance.You are provided with a set of tools that handle low-level calculations and examples showing you how to use these tools to solve this problem.</p>
<p>In the remainder of this section, we will provide the prompts describing the decision making problems and the problem parameters to the agents.</p>
<p>B.1 MDP with Known Model</p>
<p>The following are the prompts we provide to all agents to describe the formulation and the agent's objective in MDP when the model, i.e., the transition function and reward function, is known.</p>
<p>Description of MDP with known model</p>
<p>A finite horizon tabular Markov Decision Process (MDP) is a model for decision-making in scenarios where outcomes are influenced by both randomness and controlled decisions, with decisions being made over a finite number of time steps.Components: State Space S: s 0 , s 1 , . . ., s |S|−1 , where |S| is the total number of states.Action Space A: a 0 , a 1 , . . ., a |A|−1 , where |A| is the total number of actions.Transition probability matrix P : a three-dimensional tensor with shape |S| × |A| × |A|, where each entry represents the probability of transitioning from one state after taking a specific action to another state.Reward matrix R: a matrix with shape |S| × |A|, where each entry gives the mean of the immediate reward received after taking an action in a state.Horizon length H: The total number of time steps the decision process is constrained to.Interaction protocol: For time step h = 1, 2, . . ., H Agent takes an action a h ∈ A based on the current state s h Agent receives reward r h := R[s h , a h ] + η h , where η h ∼ N (0, 1) The environment transits to the next state s h+1 with probability P [s h , a h , s h+1 ] Goal of the agent: Maximize expected cumulative rewards E H h=1 R[s h , a h ] , where the expectation is w.r.t.randomness of agent's policy and state transition.</p>
<p>For zero-shot CoT, which can only read the parameters from context, we print the complete transition matrix P and reward matrix R as shown below, where the empty curly brackets {} are substituted with actual values of the problem instance.</p>
<p>Description of problem instance</p>
<p>Now you are going to play in a finite-horizon tabular Markov decision process, with length of horizon {} (with time indices starting from h=0 to {}), number of states |S|={}, number of actions |A|={}.The transition matrix P is: {} and reward matrix R is {}.</p>
<p>For zero-shot CoT w/ code, few-shot CoT w/ code and STRIDE, which can read the parameters from their working memory or an external file, instead of directly printing the transition and reward matrices in context, we state in the prompt where these values can be accessed.</p>
<p>Description of problem instance</p>
<p>Now you are going to play in a finite-horizon tabular Markov decision process, with length of horizon {} (with time indices starting from h=0 to {}), number of states |S|={}, number of actions |A|={}.The transition matrix P and reward matrix R are stored in working memory.</p>
<p>B.2 MDP with Unknown Model</p>
<p>The following are the prompts we provide to all agents to describe the formulation and the agent's objective in MDP when the model, i.e., the transition function and reward function, is unknown.</p>
<p>Description of MDP with unknown model</p>
<p>A finite horizon tabular Markov Decision Process (MDP) is a model for decision-making in scenarios where outcomes are influenced by both randomness and controlled decisions, with decisions being made over a finite number of time steps.Components: State Space S: s 0 , s 1 , . . ., s |S|−1 , where |S| is the total number of states.Action Space A: a 0 , a 1 , . . ., a |A|−1 , where |A| is the total number of actions.Transition probability matrix P : a three-dimensional tensor with shape |S| × |A| × |A|, where each entry represents the probability of transitioning from one state after taking a specific action to another state.Reward matrix R: a matrix with shape |S| × |A|, where each entry gives the mean of the immediate reward received after taking an action in a state.Horizon length H: The total number of time steps the decision process is constrained to.Number of episodes K: The total number episodes the MDP is repeatedly played by the agent, where in each episode, the agent starts fresh, makes a series of H decisions and then the episode ends.Note that learning achieved in earlier episodes influences the behavior in later episodes.Unknown model of the environment: The transition probability matrix P and reward matrix R are unknown to the agent, and the agent needs to estimate them based on the collected observations and improve its policy after each episode.Interaction protocol: For episode k = 0, 1, 2, . . ., K − 1: For time step h = 0, 1, 2, . . ., H − 1: Agent takes an action a k,h ∈ A based on the current state s k,h Agent receives reward r k,h := R[s k,h , a k,h ] + η k,h , where η k,h ∼ N (0, 1) The environment transits to the next state s k,h+1 with probability P [s k,h , a k,h , s k,h+1 ] Agent can update its estimation of matrix P and R based on the newly observed quadruples (s k,h , a k,h , s k,h+1 , r k,h+1 ) for h = 0, 1, 2, . . ., H − 1 Goal of the agent: Maximize expected cumulative rewards
E K−1 k=0 H−1 h=0 R[s h , a h ] ,
where the expectation is w.r.t.randomness of agent's policy and state transition.</p>
<p>For STRIDE, since it can automatically update, store, and read the estimated transition and reward matrices in working memory, we simply use the following description about the problem instance for all episodes.</p>
<p>Description of problem instance</p>
<p>Now you are going to play in a finite-horizon tabular Markov decision process, with length of horizon {} (with time indices starting from h=0 to {}), number of states |S|={}, number of actions |A|={}.The transition matrix P and reward matrix R are unknown to you, so you need to estimate them based on interaction history.For all the baselines, since they cannot reliably summarize the interaction history and construct the estimation of P and R, we explicitly provide the estimation of P and R and the count of visitation of state-action pairs as shown below.This is similar to the "externally summarized interaction history" in the prompt for multi-armed bandit problems used by Krishnamurthy et al. (2024).</p>
<p>Description of problem instance</p>
<p>Now you are going to play in a finite-horizon tabular Markov decision process, with length of horizon {} (with time indices starting from h=0 to {}), number of states |S|={}, number of actions |A|={}.The transition matrix P and reward matrix R are unknown to you.Your current estimation of transition matrix P is {}, your current estimation of reward matrix R is {}, and your count of visitation of all the state-action pairs is {}.</p>
<p>B.3 Dynamic Mechanism Design Problem</p>
<p>The following are the prompts we provide to all agents to describe the formulation and the agent's objective in Dynamic Mechanism Design problem, when the model, i.e., the transition function and reward function, is known.</p>
<p>Description of dynamic mechanism design problem</p>
<p>The dynamic mechanism design problem involves creating allocation and pricing rules for decision-making, where the value of resource to the agents changes over time as the state of the environment changes.Components: Players: a mechanism designer and a set of N agents State Space S: s 0 , s 1 , . . ., s |S|−1 , where |S| is the total number of states.Action Space A: a 0 , a 1 , . . ., a |A|−1 , where |A| is the total number of actions.Each action represents the mechanism designer's allocation of some scarce resource among N agents.Transition probability matrix P : a three-dimensional tensor with shape |S| × |A| × |A|, where each entry represents the probability of transitioning from one state after taking a specific action to another state.Reward matrix R: a three-dimensional tensor with shape N × |S| × |A|, where each matrix R[i, :, :] represents the reward matrix of an agent i for i = 1, 2, . . ., N , and each of its entry gives the mean of the immediate reward received by agent i after the mechanism designer takes an action in a state.Horizon length H: The total number of time steps the decision process is constrained to.Interaction protocol: Before the interaction starts, each agent i reports a reward matrix (can be different from its true reward matrix R[i, :, :]), denoted as R[i, :, :], to the designer.Based on agents' reported reward matrix, the designer chooses a policy π : S → ∆(A) and prices {p i } N i=1 to be charged to each agent.For time step h = 1, 2, . . ., H: Mechanism designer takes an action a h ∼ π(s h ) based on the policy π and the current state s h Each agent i receives reward R[i, s h , a h ] for i = 1, 2 . . ., N The environment transits to the next state s h+1 with probability P [s h , a h , s h+1 ] After the interaction, the mechanism designer charges each agent i with some price p i Goal of the agents: Each agent wants to maximize its utility
u i = E H h=1 R[i, s h , a h ] − p i ,
that is, the difference between the expected cumulative rewards, where the expectation is w.r.t.randomness of designer's policy and state transition, and the price charged by the mechanism designer.As the agents cannot directly take actions, their only leverage is to decide whether to truthfully report their reward matrix to the designer.Goal of the mechanism designer: Maximize the expected cumulative rewards of all agents
E N i=1 H h=1 R[i, s h , a h ] ,
where the expectation is w.r.t.randomness of designer's policy and state transition.As the designer only observes agents' reported reward matrix R, to fulfil its objective, the designer needs to guarantee, with its policy and pricing strategy, no agent i has incentive to report R[i, :, :] that is different from the true reward matrix R[i, :, :] unilaterally.It is known that VCG mechanism guarantees truthfulnes of the agents, and uniquely maximizes the objective.It is defined as follows:
π ⋆ = argmax π E π,P N i=1 H h=1 R[i, s h , a h ] p ⋆ i = E π ⋆ −i ,P j̸ =i H h=1 R[j, s h , a h ] − E π ⋆ ,P j̸ =i H h=1 R[j, s h , a h ] for i = 1, 2, . . . , N , where π ⋆ −i = argmax π E π,P j̸ =i H h=1 R[j, s h , a h ]
is the optimal policy for a MDP with transition probability matrix P and reward matrix j̸ =i R[j, :, :], that is, excluding the reward matrix of agent i itself.Now as a strategic decision maker, your job is to compute the VCG mechanism based on the given transition probability matrix P and the reward matrix R reported by the agents.Then you should take an action at each time step and charges prices to each agent at the end, according to your computed VCG mechanism.</p>
<p>Description of problem instance</p>
<p>// For buyer This is the beginning of a new game instance, where you will play as the buyer.Your discount factor δ b ={}, seller's discount factor δ s ={}, and the deadline T={}.In the following, you should make your decision by assuming your opponent is rational as well.// For seller This is the beginning of a new game instance, where you will play as the seller.Your discount factor δ s ={}, buyer's discount factor δ b ={}, and the deadline T={}.In the following, you should make your decision by assuming your opponent is rational as well.</p>
<p>B.5 Single-Issue Bargaining under Incomplete Information</p>
<p>The following are the prompts we provide to all agents to describe the formulation and the agent's objective in single-issue bargaining under incomplete information.</p>
<p>Description of single-issue bargaining under incomplete information</p>
<p>This is a finite horizon bargaining game with one-sided uncertainty, in which the uninformed bargainer, the seller, makes all the offers and the informed bargainer, the buyer, can only decides to accept or reject the offer.Components: Players: Buyer (informed) and Seller (uninformed).Buyer's Value: b (the maximum price the buyer is willing to pay).Seller's Value: 0 (the minimum price the seller is willing to accept).Discount Factors (δ b and δ s ): Represents how much each player values immediate transactions over future possibilities, where δ b , δ s ∈ (0, 1).Utility associated with future offers are discounted by δ t−1 b and δ t−1 s for the buyer and the seller, respectively, where t indicates the current time step.Buyer's Utility: If a price p is agreed upon at time step t &lt;= T , then buyer's utility is u b = (b − p) * δ t−1 b .Seller's Utility: If a price p is agreed upon at time step t &lt;= T , then seller's utility is u b = (p − 0) * δ t−1 s .Deadline: If no sale is agreed upon by the end of time T, the negotiation fails, and no transaction occurs, in which case, both agents get 0 utility.Information Asymmetry: Buyer himself knows the true value of b, which is drawn from a known distribution F (v) supported on [0, 1].We assume F (v) = v, i.e., Buyer's value b is sampled from a uniform distribution.The seller does not know b but knows the distribution F (v). Interaction Protocol: Decision Turns: In each time step t = 1, 2, . . ., T , it is always Seller who makes an offer p t within the range of [0,1].</p>
<p>Responses: Buyer can either accept the proposed price, resulting in a sale and the game ending, or reject the offer, in which case the negotiation advances to the next time step.Goal of the agents: Seller's Objective: Maximize their expected payoff over the horizon of the game without knowing the true value of b.The seller must strategically decide on the prices p t to offer in each time step, considering the declining number of opportunities to make a sale and the distribution of b inferred from the buyer's responses.Buyer's Objective: Maximize their surplus, which is the difference between the true value b and the price paid p, if a transaction occurs.The buyer needs to decide whether to accept or reject the seller's offers based on the value b and the likelihood of a more favorable price in subsequent time steps, considering the finite number of time steps.</p>
<p>Description of problem instance</p>
<p>// For buyer This is the beginning of a new game instance, where you will play as the buyer.Your discount factor δ b ={}, seller's discount factor δ s ={}, and the deadline T={}.Your value b = {}, which is uniformly sampled from [0, 1].In the following, you should make your decision by assuming your opponent is rational as well.// For seller This is the beginning of a new game instance, where you will play as the seller.Your discount factor δ s ={}, buyer's discount factor δ b ={}, and the deadline T={}.The buyer's value b is unknown to you, but you know it is uniformly sampled from [0, 1].In the following, you should make your decision by assuming your opponent is rational as well.</p>
<p>B.6 Tic-Tac-Toe</p>
<p>The following are the prompts we provide to all agents to describe the formulation and the agent's objective for the Tic-Tac-Toe game.The prompts also detail the agents' goals and initial game setup.</p>
<p>Description of Tic-Tac-Toe Game Tic-Tac-Toe is a classic two-player game where players take turns marking spaces in a 3x3 grid, aiming to place three of their marks in a horizontal, vertical, or diagonal row to win.Components:</p>
<p>• Players: Two players, usually denoted as Player X and Player O.</p>
<p>• Board: A 3x3 grid where each cell can be empty, marked with an X, or marked with an O. • Marks: Each player has a unique mark (X or O) that they place on the board.Interaction Protocol:</p>
<p>• Players take turns starting with Player X.</p>
<p>• On each turn, a player marks an empty cell on the grid with their mark (X or O).</p>
<p>• The game continues until a player has three of their marks in a horizontal, vertical, or diagonal row, or all cells are filled resulting in a draw.Rules:</p>
<ol>
<li>
<p>Players alternate turns, with Player X always going first.2. A player can only mark an empty cell.</p>
</li>
<li>
<p>The game ends when one player achieves a row of three marks horizontally, vertically, or diagonally, or when all cells are filled with no winner (a draw).Goals of the Players:</p>
</li>
</ol>
<p>• Player X: Maximize the chances of placing three X's in a row before Player O does.</p>
<p>• Player O: Maximize the chances of placing three O's in a row before Player X does.Winning Conditions:</p>
<p>• A player wins if they place three of their marks in a horizontal, vertical, or diagonal row.</p>
<p>• If all cells are filled without any player achieving three marks in a row, the game results in a draw.Game Setup:</p>
<p>1.The game begins with an empty 3x3 grid.2. Players decide who will be Player X and who will be Player O.</p>
<ol>
<li>Player X makes the first move.Objective: Each player aims to either achieve a row of three of their marks or to block the opponent from doing so.Strategic planning and anticipation of the opponent's moves are crucial to winning the game.</li>
</ol>
<p>Description of problem instance</p>
<p>Now you are going to play a game of Tic-Tac-Toe.The current state of the board is {}.It is player {}'s turn.Your objective is to place three of your marks in a horizontal, vertical, or diagonal row to win while preventing your opponent from doing the same.</p>
<p>B.7 Connect-N</p>
<p>The following are the prompts we provide to all agents to describe the formulation and the agent's objective for the Connect-N game.The prompts also detail the agents' goals and initial game setup.we set B = 4 and U = 4.The experiments were conducted over 10 runs, with STRIDE playing as player 'X' and the baseline models as player 'O'.The outcomes are summarized in Table 7.</p>
<p>C.2 Connect-N</p>
<p>Agent's Objective in Connect-N.In Connect-N, available moves can be made in the lowest empty space of each column.The agent aims to drop its discs to form a line of N while preventing its opponent from doing the same.Each agent attempts to choose the best possible action based on the game's state.Similar to Tic-Tac-Toe, the game ends with a draw if both players play optimally.</p>
<p>Experiment Setup and Results</p>
<p>We conduct experiments with two configurations: (1) Connect-3 on a 3 × 3 board and (2) Connect-4 on a 4 × 4 board.Similar to the Tic-Tac-Toe game, STRIDE simulates the Breadth-First Minimax algorithm with pruning (see Algorithm 10) to find the optimal action in Connect-N.It first simulates every possible move and scores each node at each game's depth (1 for a win, -1 for a loss, and 0 for a tie or non-leaf node), then uses backward induction to update the scores for each game state.Using its working memory, STRIDE stores the computed scores for all possible actions at various depths.When the game starts, it selects the best action based on the computed scores.The results (averaged over 10 runs) are summarized in Tables 8  and 9.We provide the following operational tools to STRIDE to help it emulate Algorithm 10: • CalculateScores: expand every action at each depth and calculate the score for the nodes.</p>
<p>• GetScores: retrieve the computed scores for all actions at the specified depth of the game tree.</p>
<p>Figure 3 :
3
Figure 3: Agent's objective in Highway Environment is to control the ego-vehicle, i.e., the green box, to reach a high speed while avoiding collision with the other vehicles, i.e., the blue boxes.</p>
<p>Figure4: Comparison of cumulative rewards over episode.We observe that both STRIDE and UCB-VI exhibit rapid increases in their cumulative rewards, converging by approximately the 10th episode.This indicates that STRIDE can effectively explore the environment, by emulating UCB-VI in its reasoning process.In contrast, the cumulative rewards of other baseline methods display ongoing fluctuations throughout the episodes, showing poor exploration ability in uncertain environments.</p>
<p>▷</p>
<p>s, a) = R(s, a) + s ′ ∈S P (s ′ |s, a)V h+1 (s ′ ) s) = max a∈A Q h (s, a) 13: end for 14: end for 15: ▷ Thought: I have finished value iteration.Now exit reasoning.16: for step h = 1, 2, • • • , H do Thought: I should choose the action that maximizes the computed Q values.20: ▷ Operation: call GetQ with inputs {time step: h, cur state: s h } 21: ▷ Operation: call GetArgMax with inputs {q vals: [. . .]} 22:</p>
<p>Algorithm 6
6
Backward Induction to Compute SE of Bargaining under Incomplete Information 1: ▷ Question: Compute the SE Prices via Bisection Search and Backward Induction.2: ▷ Thought: I need to first compute my belief about buyer's value at time step T-1 under sequential equilibrium, denoted b T −1 , which can be done via bisection search.I should terminate when the value b ′ 0 computed based on b ′ T −1 gets close enough to my actual initial belief b 0 = 1.0.</p>
<p>▷</p>
<p>Thought: Since b ′ 0 is larger than b 0 , I should focus on the region [l, b ′ T −1 ] next time.</p>
<p>the value of my initial belief computed based on B ′ T −1 is close enough to the actual value b 0 = 1.Therefore, B ′ T −1 is an accurate approximation of B T −1 in SE.Now I can start backward induction to compute the SE prices from time T to 1. 19: for t = T, T − 1, . . ., 1 do 20: if t = T then 21: ▷ Operation: Call function SOLVELAST with inputs {b last: B ′ T −1 }.</p>
<p>Table 1 :
1
Success rate in taking the optimal action (20 runs).
H S A zero-shot CoT zero-shot CoT w/ code few-shot CoT w/ code STRIDE5330.580.740.700.9810 330.620.750.690.875 10 100.240.480.600.9610 10 100.210.500.680.82Agent's Objective in MDP with Unknown Model.</p>
<p>Table 2 :
2
Success rate in computing the VCG mechanism (10 runs).
N zero-shot CoT zero-shot CoT w/ code few-shot CoT w/ code STRIDE20.690.630.700.8940.570.630.540.9060.490.450.440.86</p>
<p>Table 3 :
3
Success rate in reaching SPE of single-issue bargaining (10 runs).
T zero-shot CoT zero-shot CoT w/ code few-shot CoT w/ code STRIDE30.500.350.500.7960.500.270.460.9190.340.180.270.74</p>
<p>Table 4 :
4
Outcomes of STRIDE and zero-shot CoT bargaining with each other.Seller Making Offers under Uncertainty of Buyer's Value.Now we consider the more challenging scenario where the buyer's value, denoted as b ∈ [0, 1], is privately known to himself, and thus the seller needs to update his/her belief about b based on the observed responses, i.e., buyer's rejection of seller's offers.The seller's cost (still assumed to be 0) and the prior distribution of b, represented as a cumulative distribution function F
STRIDE buyer vs zero-shot CoT seller zero-shot CoT buyer vs STRIDE sellerT avg SPE priceavg sale priceavg SPE priceavg sale price30.130.130.220.4360.570.560.650.7090.280.270.490.70</p>
<p>Table 5 :
5
Success rate in reaching SE of single-issue bargaining with one-sided uncertainty (10 runs).
T zero-shot CoT zero-shot CoT w/ code few-shot CoT w/ code STRIDE30.470.290.380.7960.440.320.300.7590.490.380.230.69</p>
<p>(Azar et al., 2017;Sutton and Barto, 2018nd Value IterationFor MDP with known and unknown model, the reference algorithms selected for STRIDE are Value Iteration (VI) and Upper Confidence Bound Value Iteration (UCB-VI)(Azar et al., 2017;Sutton and Barto, 2018).Here we provide description of these two algorithms in Algorithm 1 and Algorithm 2, together with the comments 4 showing how we augment the algorithm during the demonstration generation procedure as discussed in Section 3.2.Operational Tools.The following operational tools are provided to the LLM to help it emulate the behavior of VI and UCB-VI:Algorithm 1 Value Iteration for MDPs with Known Model.</p>
<p>1: Initialize V H+1 (s) = 0, ∀s ∈ S 2: ▷ Question: Compute the Optimal Policy.3:</p>
<p>• UpdateQbyBonus: add exploration bonus to the Q values for all state-action pairs at the specified time step Algorithm 4 Backward Induction to Compute SPE of Bargaining under Complete Information 1: ▷ Question: Compute the SPE Prices via Backward Induction.Thought: Compute the SPE price for time t, based on the results computed for time t + 1
4:if t = T then5:
2: for time step t = T, T − 1, • • • , 1 do 3:▷</p>
<p>Response to Offer in Bargaining with Complete Information 1: Inputs: current player, price p, time t, SPE prices {p t } T t=1 2: ▷ Question: Should I accept or reject opponent's offer?3: ▷ Thought: I should first compute the utility I get by accepting the offer, and then the utility I get by rejecting the offer and making a counter offer using the SPE price in the next time step.4: ▷ Operation: call CalcUtil with inputs {agent: current player, price: p, t: t} 5: ▷ Operation: call GetSPEPrice with inputs {t: t + 1} 6: ▷ Operation: call CalcUtil with inputs {agent: current player, price: p t+1 , t: t + 1} 7: if current player = buyer then
8:
• ComputeBt: compute what seller's belief about buyer's value would be at the current time step, given a guess of seller's belief at time step T − 1 (description given in Algorithm 7) Algorithm 5</p>
<p>Table 6 :
6
Model performances in Tic-Tac-Toe (10 runs).
OutcomeRAFA w/ Minimax RAFA w/ MCTS zero-shot CoT zero-shot CoT w/ code STRIDEX Wins (%)5060708020Tie (%)302002080O Wins (%)20203000</p>
<p>Table 7 :
7
STRIDE against Baseline Models in Tic-Tac-Toe (10 runs)
MatchupSTRIDE Wins (%) Tie (%) Opponent Wins (%)STRIDE vs zero-shot CoT90100STRIDE vs zero-shot CoT w/ code80200STRIDE vs RAFA w/ MCTS50500</p>
<p>Table 8 :
8
Model performances in Connect-3 (10 runs).
Outcomezero-shot CoT zero-shot CoT w/ code STRIDEX Wins (%)609030Tie (%)40070O Wins (%)0100
The code is available at https://github.com/cyrilli/STRIDE
This is achieved via the function calling feature of LLMs, which is commonly supported by models like GPT, Claude, and Gemini. These models are fine-tuned to reliably generate responses following the specified structure.
see https://highway-env.farama.org/observations for more details
Note that these are simplified comments for illustration purpose, and the results returned by the operations are omitted. For actual annotations added to the reference algorithms, please refer to our released code.
https://github.com/agentification/RAFA code
• UpdateMDPModel: update the estimation of the reward and transition function of MDP based on the observed quadruple (old state, action, new state, reward)A.2 Dynamic Programming for Dynamic Mechanism DesignFor dynamic mechanism design problem, the reference algorithm selected for STRIDE is described in Algorithm 3, which is modified based on the Markov VCG mechanism ofLyu et al. (2022).Operational Tools.The following operational tools are provided to the LLM:• UpdateQbyRExcluding: add immediate rewards, excluding the reward of excluded agent, to the Q values for all state-action pairs at current time step.If excluded agent is set to None, all agents' rewards are used.• UpdateQbyPVExcluding: add the one-step look-ahead value, excluding the reward of excluded agent, to the Q values for all state-action pairs at current time step.If excluded agent is set to None, all agents' rewards are used.• UpdateVExcluding: update the V values, excluding the reward of excluded agent, based on the computed Q values for the current time step.If excluded agent is set to None, all agents's rewards are used.• GetQExcluding: retrieve Q values, that excludes the rewards of excluded agent, for all actions at the current state and time step.If excluded agent is set to None, the Q values computed using all agents' rewards will be returned.• EvaluatePolicyExcluding: evaluate the optimal policy on an fictitious MDP that excludes the reward function of excluded agent.• GetArgMax: return the indices corresponding to the maximal value in the given list of numbers • GetMax: return the maximal value in the given list of numbers With these operational tools, STRIDE is capable of computing the dynamic VCG mechanism by emulating Algorithm 3.A.3 Backward Induction for Bargaining in Complete Information SettingFor alternating offer bargaining under complete information, the reference algorithm selected for STRIDE is the backward induction algorithm described in Algorithm 4, which given parameter of the game, including buyer's discount δ b , seller's discount δ s , and deadline T , can compute the SPE of the game.Operational Tools.The following operational tools are provided to the LLM: • CalcUtil: calculate buyer or seller's utility using Eq (4.5), with the role of the agent, the specified price and time step as inputs.• BackwardOneStep: compute the SPE price using one step of backward induction reasoning based on the opponent's utility if he/she choose to reject the offer at current time step (see the constrained optimization problem in line 14 and line 17 in Algorithm 4) • GetSPEPrice: retrieve the previously computed SPE price for the specified time step With these operational tools, STRIDE is capable of computing the SPE by emulating Algorithm 4. SPE can be used to predict the future offer to be made by the opponent, assuming the opponent is rational and that the opponent believes the player to be rational as well.When facing a new offer p made by the opponent at time step t, STRIDE will emulate Algorithm 5 to produce a response.Algorithm 8 SolveLast1: Inputs b last, the belief at time step T .Inputs u, seller's expected utility at t+1, p, the associated price, and t, the current time step.2: Set u t+1 = u, p t+1 = p, and t = t 3: Compute SPE priceDescription of problem instanceNow you are going to play in a finite-horizon dynamic mechanism design problem, with number of agents N ={}, length of horizon {} (with time indices starting from h=0 to {}), number of states |S|={}, number of actions |A|={}.The transition matrix P is:{} and reward matrix R reported by the agents is {}.B.4 Single-Issue Bargaining under Complete InformationThe following are the prompts we provide to all agents to describe the formulation and the agent's objective in single-issue bargaining under complete information.Description of single-issue bargaining under complete informationThe alternating offer bargaining game is a negotiation framework between two players, a buyer and a seller, aimed at determining the price of an item.This strategic game plays out over several rounds with a finite deadline, emphasizing the tactics of bargaining under time constraints.Components: Players: Two (Buyer and Seller).Buyer's Value: 1 (the maximum price the buyer is willing to pay).Seller's Value: 0 (the minimum price the seller is willing to accept).Discount Factors (δ b and δ s ): Represents how much each player values immediate transactions over future possibilities, where δ b , δ s ∈ (0, 1).Utility associated with future offers are discounted by δ t−1 b and δ t−1 s for the buyer and the seller, respectively, where t indicates the current round.Buyer's Utility: If a price p is agreed upon at time step t &lt;= T , then buyer's utility isb .Seller's Utility: If a price p is agreed upon at time step t &lt;= T , then seller's utility is u b = (p − 0) * δ t−1 s .Deadline: If no sale is agreed upon by the end of time T, the negotiation fails, and no transaction occurs, in which case, both agents get 0 utility.Complete Information: All details about the item's value range, the structure of the rounds, and the potential outcomes are common knowledge.Interaction Protocol: Decision Turns: Starting with the buyer, players alternate in making price offers.The player making an offer proposes a price within the range from the seller's value to the buyer's value.Responses: The opponent can either accept the proposed price, resulting in a sale and the game ending, or reject the offer, in which case the negotiation advances to the next round.Goal of the agents:The seller aims to maximize the sale price while the buyer seeks to minimize it.Each agent's goal is to negotiate a price as close as possible to their value (1 for the seller, 0 for the buyer) while considering the risk of no agreement by the deadline.Description of Connect-NConnect-N is a generalized version of Connect-4, where two players alternate turns dropping colored discs into a vertically suspended grid.The objective is to form a horizontal, vertical, or diagonal line of N discs.The game introduces a gravity effect where discs drop to the lowest available position within a column, adding a unique strategic dimension to the gameplay.Components:• Players: Two players, typically referred to as Player X and Player O, who use different colored discs.• Board: A grid with configurable dimensions, larger than the typical 3×3 Tic-Tac-Toe board.• Discs: Each player has an ample supply of discs in their respective colors.Interaction Protocol:• Players take turns, starting with Player X.• On each turn, a player chooses a column to drop a disc into.The disc falls, affected by gravity, to the lowest available position within the column.• The game continues until a player forms a line of N discs in a row (horizontally, vertically, or diagonally) or the board is completely filled, resulting in a draw.Rules:1. Players must alternate turns, with Player X always going first.2. A player can only choose a column that has available space.3. The game ends when one player forms a line of N discs or when all columns are filled without any player achieving this, which results in a draw.Goals of the Players:• Player X: Strategize to connect N of their discs in a row vertically, horizontally, or diagonally before Player O. • Player O: Similarly, aim to connect N of their discs in a row while blocking Player X's attempts.Winning Conditions:• A player wins by aligning N of their discs in a row in any direction.• The game results in a draw if the entire board is filled without either player achieving N in a row.Game Setup:1.The game starts with an empty board of the chosen dimensions.2. Players decide who will play first (Player X) and choose their disc colors.3. Player X makes the first move by dropping a disc into one of the columns.Objective: Each player aims to strategically drop their discs to form a line of N while preventing their opponent from doing the same.Anticipating the opponent's moves and effectively using the gravity-affected game-play are critical to securing a victory.Description of problem instanceAppendix C Additional ExperimentsIn this section, we conduct additional experiments that evaluate STRIDE and the baseline agents (GPT-3.5-Turbo-0125with the temperature set to 0) on Tic-Tac-Toe and Connect-N Games.For these two games, we provide STRIDE with tools and demonstration that make it emulate the Minimax algorithm as shown in Algorithm 10.C.1 Tic-Tac-ToeAgent's Objective in Tic-Tac-Toe.The primary objective for each agent is to win the Tic-Tac-Toe game by placing three markers in the same row, column, or diagonal before the opponent.If a win is not feasible, the secondary objective is to aim for a tie, preventing the opponent from winning.Each agent strives to select the optimal action based on the game's current state.If both players play optimally, the game results in a tie.Experiment Setup and Results.In addition to the baselines mentioned in Section 4, here we also include RAFA with Monte Carlo Tree Search (MCTS)(Liu et al., 2023)and RAFA with Minimax.For CoT w/ code, the LLM has been instructed to implement the Minimax algorithm to play the game, and for the RAFA agents, the search breadth denoted B, is set to 4. In addition to the original RAFA MCTS implementation 5 , we implemented RAFA with Minimax as an extra baseline.We adopt the memory structure from their original implementation to store optimal actions and use similar prompts and interactions with the LLM to expand the game tree and assess game states.Additionally, for RAFA with Minimax, we set the search depth, denoted U , to the maximum value 9.In our experiments, STRIDE is equipped with operational tools to emulate a Breadth-First version of the Minimax algorithm with alpha-beta pruning (see Algorithm 10).Starting from depth 0 and progressing to the maximum depth -determined by the total number of empty cells on the board -the algorithm evaluates potential outcomes at each node: +1 for a win, −1 for a loss, and 0 for a tie or non-terminal states.Utilizing backward induction, the algorithm recursively refines and updates these scores, ensuring that the decision path optimizes the expected outcome at each node from the current player's perspective.These scores are stored in STRIDE's working memory.When STRIDE agent starts playing the game, it retrieves the scores for each possible action and then selects the action with maximal or minimal score depending on the player's role.We repeat the experiments on a fixed set of parameters for 10 runs, with the initial player being 'X' and an empty board to start the game.The results are presented in Table6.STRIDE vs. Baseline Models We also conducted experiments that pit STRIDE against baseline models in Tic-Tac-Toe, including zero-shot CoT, zero-shot CoT w/ code, and RAFA w/ MCTS.We instructed zero-shot CoT w/ code to implement the Minimax algorithm, and for RAFA w/ MCTS,
J Achiam, S Adler, S Agarwal, L Ahmad, I Akkaya, F L Aleman, D Almeida, J Altenschmidt, S Altman, S Anadkat, arXiv:2303.08774Gpt-4 technical report. 2023arXiv preprint</p>
<p>Using large language models to simulate multiple humans. G Aher, R I Arriaga, A T Kalai, arXiv:2208.102642022arXiv preprint</p>
<p>Using large language models to simulate multiple humans and replicate human subject studies. G V Aher, R I Arriaga, A T Kalai, International Conference on Machine Learning. PMLR2023</p>
<p>M Ahn, A Brohan, N Brown, Y Chebotar, O Cortes, B David, C Finn, C Fu, K Gopalakrishnan, K Hausman, arXiv:2204.01691Do as i can, not as i say: Grounding language in robotic affordances. 2022arXiv preprint</p>
<p>E Akata, L Schulz, J Coda-Forno, S J Oh, M Bethge, E Schulz, arXiv:2305.16867Playing repeated games with large language models. 2023arXiv preprint</p>
<p>Introducing the next generation of claude. Anthropic, 2024</p>
<p>Minimax regret bounds for reinforcement learning. M G Azar, I Osband, R Munos, International conference on machine learning. PMLR2017</p>
<p>The dynamic pivot mechanism. D Bergemann, J Välimäki, Econometrica. 782010</p>
<p>Dynamic mechanism design: An introduction. D Bergemann, J Välimäki, Journal of Economic Literature. 572019</p>
<p>F Bianchi, P J Chia, M Yuksekgonul, J Tagliabue, D Jurafsky, J Zou, arXiv:2402.05863How well can llms negotiate? negotiationarena platform and analysis. 2024arXiv preprint</p>
<p>Emergent autonomous scientific research capabilities of large language models. D A Boiko, R Macknight, G Gomes, arXiv:2304.053322023arXiv preprint</p>
<p>Playing games with gpt: What can we learn about a large language model from canonical strategic games? Available at SSRN 4493398. P Brookins, J M Debacker, 2023</p>
<p>S Bubeck, V Chandrasekaran, R Eldan, J Gehrke, E Horvitz, E Kamar, P Lee, Y T Lee, Y Li, S Lundberg, arXiv:2303.12712Sparks of artificial general intelligence: Early experiments with gpt-4. 2023arXiv preprint</p>
<p>Hallucination detection: Robustly discerning reliable answers in large language models. Y Chen, Q Fu, Y Yuan, Z Wen, G Fan, D Liu, D Zhang, Z Li, Y Xiao, Proceedings of the 32nd ACM International Conference on Information and Knowledge Management. the 32nd ACM International Conference on Information and Knowledge Management2023</p>
<p>Bargaining with incomplete information: An infinite-horizon model with two-sided uncertainty. The Review of Economic Studies. P C Cramton, 198451</p>
<p>T R Davidson, V Veselovsky, M Josifoski, M Peyrard, A Bosselut, M Kosinski, R West, arXiv:2401.04536Evaluating language model agency through negotiations. 2024arXiv preprint</p>
<p>Can large language models serve as rational players in game theory? a systematic analysis. C Fan, J Chen, Y Jin, H He, arXiv:2312.054882023arXiv preprint</p>
<p>Game theory. D Fudenberg, J Tirole, 1991MIT press</p>
<p>K Gandhi, D Sadigh, N D Goodman, arXiv:2305.19165Strategic reasoning with language models. 2023arXiv preprint</p>
<p>S Guo, H Wang, H Bu, Y Ren, D Sui, Y.-M Shang, S Lu, Large language models as rational players in competitive economics games. 2023</p>
<p>S Hao, Y Gu, H Ma, J J Hong, Z Wang, D Z Wang, Z Hu, arXiv:2305.14992Reasoning with language model is planning with world model. 2023arXiv preprint</p>
<p>J Huang, -T, E J Li, M H Lam, T Liang, W Wang, Y Yuan, W Jiao, X Wang, Z Tu, M R Lyu, arXiv:2403.11807How far are we on the decision-making of llms? evaluating llms' gaming ability in multi-agent environments. 2024arXiv preprint</p>
<p>Can large language models truly follow your instructions?. J Jang, S Ye, M Seo, NeurIPS ML Safety Workshop. 2022</p>
<p>A Krishnamurthy, K Harris, D J Foster, C Zhang, A Slivkins, arXiv:2403.15371Can large language models explore in-context? arXiv preprint. 2024</p>
<p>M Kwon, S M Xie, K Bullard, D Sadigh, arXiv:2303.00001Reward design with language models. 2023arXiv preprint</p>
<p>An environment for autonomous driving decision-making. E Leurent, 2018</p>
<p>Lost in the middle: How language models use long contexts. N F Liu, K Lin, J Hewitt, A Paranjape, M Bevilacqua, F Petroni, P Liang, 2024Transactions of the Association for Computational Linguistics12</p>
<p>Z Liu, H Hu, S Zhang, H Guo, S Ke, B Liu, Z Wang, arXiv:2309.17382Reason for future, act for now: A principled framework for autonomous llm agents with provable sample efficiency. 2023arXiv preprint</p>
<p>Strategic behavior of large language models: Game structure vs. N Lorè, B Heydari, arXiv:2309.058982023contextual framing. arXiv preprint</p>
<p>Learning dynamic mechanisms in unknown environments: A reinforcement learning approach. B Lyu, Q Meng, S Qiu, Z Wang, Z Yang, M I Jordan, arXiv:2202.127972022arXiv preprint</p>
<p>C Park, X Liu, A Ozdaglar, K Zhang, arXiv:2403.16843Do llm agents have regret? a case study in online learning and games. 2024arXiv preprint</p>
<p>Generative agents: Interactive simulacra of human behavior. J S Park, J O'brien, C J Cai, M R Morris, P Liang, M S Bernstein, Proceedings of the 36th Annual ACM Symposium on User Interface Software and Technology. the 36th Annual ACM Symposium on User Interface Software and Technology2023</p>
<p>C Qian, X Cong, C Yang, W Chen, Y Su, J Xu, Z Liu, M Sun, arXiv:2307.07924Communicative agents for software development. 2023arXiv preprint</p>
<p>Y Qin, S Liang, Y Ye, K Zhu, L Yan, Y Lu, Y Lin, X Cong, X Tang, B Qian, arXiv:2307.16789Toolllm: Facilitating large language models to master 16000+ real-world apis. 2023arXiv preprint</p>
<p>Perfect equilibrium in a bargaining model. A Rubinstein, Econometrica: Journal of the Econometric Society. 1982</p>
<p>Hugginggpt: Solving ai tasks with chatgpt and its friends in hugging face. Y Shen, K Song, X Tan, D Li, W Lu, Y Zhuang, Advances in Neural Information Processing Systems. 202436</p>
<p>Reflexion: Language agents with verbal reinforcement learning. N Shinn, F Cassano, A Gopinath, K Narasimhan, S Yao, Advances in Neural Information Processing Systems. 202436</p>
<p>A multistage model of bargaining. The Review of Economic Studies. J Sobel, I Takahashi, 198350</p>
<p>Reinforcement learning: An introduction. R S Sutton, A G Barto, 2018MIT press</p>
<p>Challenging big-bench tasks and whether chain-ofthought can solve them. M Suzgun, N Scales, N Schärli, S Gehrmann, Y Tay, H W Chung, A Chowdhery, Q V Le, E H Chi, D Zhou, arXiv:2210.092612022arXiv preprint</p>
<p>A survey on large language model based autonomous agents. L Wang, C Ma, X Feng, Z Zhang, H Yang, J Zhang, Z Chen, J Tang, X Chen, Y Lin, Frontiers of Computer Science. 182024</p>
<p>Describe, explain, plan and select: Interactive planning with large language models enables open-world multi-task agents. Z Wang, S Cai, G Chen, A Liu, X Ma, Y Liang, arXiv:2302.015602023arXiv preprint</p>
<p>S Yao, J Zhao, D Yu, N Du, I Shafran, K Narasimhan, Y Cao, arXiv:2210.03629React: Synergizing reasoning and acting in language models. 2022arXiv preprint</p>
<p>Large language models as commonsense knowledge for large-scale task planning. Z Zhao, W S Lee, D Hsu, Advances in Neural Information Processing Systems. 202436</p>
<p>Language agent tree search unifies reasoning acting and planning in language models. A Zhou, K Yan, M Shlapentokh-Rothman, H Wang, Y.-X Wang, arXiv:2310.044062023arXiv preprint</p>
<p>Algorithm 3 Dynamic VCG Mechanism Design 1: Initialize V H+1 (s) = 0, V H+1,−i (s) = 0, ∀s ∈ S 2: ▷ Question: Compute the policy that maximizes all agents' reported rewards. 3: for step h = H, H − 1. X Zhu, Y Chen, H Tian, C Tao, W Su, C Yang, G Huang, B Li, L Lu, X Wang, arXiv:2305.171442023arXiv preprintGhost in the minecraft: Generally capable agents for open-world enviroments via large language models with text-based knowledge and memory. 1 do 4: ▷ Thought: Now we can continue to compute the Q-values for the current step h</p>
<p>Thought: I have finished value iteration. Now exit reasoning. 14: Denote the optimal policy as π ⋆ h (s) := argmax a∈A Q h (s, a) for h ∈ [H], s ∈ S 15: for step h = 1, 2, • • • , H do 16: Observe state s h 17: ▷ Question: Which action I should take? 18: ▷ Thought: I should choose the action that maximizes the computed Q values. 19: ▷ Operation: call GetQExcluding with {time step: h, cur state: s h , excluded agent=None} 20: ▷ Operation: call GetArgMax with {q vals. ⋆ i = V 1,−i (s 1 ) − V π * (P, j̸ =i R j ) 40: ▷ Thought: Now we know the optimal value of this fictitious MDP that ignores agent i's rewards. Next we should evaluate policy π ⋆ on this fictitious MDP. 41: ▷ Operation: call EvaluatePolicyExcluding with {excluded agent: i} 42: ▷ Thought: Then the VCG price for agent i is simply their difference. 13Now exit reasoning. 43: end for Now, you are going to play a game of Connect-N, where two players alternate turns dropping discs into a vertically suspended grid. The objective is to form a line of N discs in a row, either horizontally, vertically, or diagonally. The current state of the board is {}, the current player is Player {}, the number of discs required to win is {}. Your objective is to strategically drop your discs to form a line of {} discs while preventing your opponent from doing the same</p>            </div>
        </div>

    </div>
</body>
</html>