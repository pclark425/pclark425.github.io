<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-6988 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-6988</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-6988</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-135.html">extraction-schema-135</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of graph-to-text representations used to convert graphs into textual sequences for language model training, including their description, encoding method, properties, datasets, models, evaluation metrics, performance outcomes, and any reported advantages or limitations.</div>
                <p><strong>Paper ID:</strong> paper-9c120069f0dbd75cfa1e2cb76728d77d3d0ae830</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/9c120069f0dbd75cfa1e2cb76728d77d3d0ae830" target="_blank">Structural Information Preserving for Graph-to-Text Generation</a></p>
                <p><strong>Paper Venue:</strong> Annual Meeting of the Association for Computational Linguistics</p>
                <p><strong>Paper TL;DR:</strong> This work introduces two types of autoencoding losses, each individually focusing on different aspects (a.k.a. views) of input graphs, that can guide the model for preserving input information via multi-task training.</p>
                <p><strong>Paper Abstract:</strong> The task of graph-to-text generation aims at producing sentences that preserve the meaning of input graphs. As a crucial defect, the current state-of-the-art models may mess up or even drop the core structural information of input graphs when generating outputs. We propose to tackle this problem by leveraging richer training signals that can guide our model for preserving input information. In particular, we introduce two types of autoencoding losses, each individually focusing on different aspects (a.k.a. views) of input graphs. The losses are then back-propagated to better calibrate our model via multi-task training. Experiments on two benchmarks for graph-to-text generation show the effectiveness of our approach over a state-of-the-art baseline.</p>
                <p><strong>Cost:</strong> 0.013</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e6988.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e6988.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of graph-to-text representations used to convert graphs into textual sequences for language model training, including their description, encoding method, properties, datasets, models, evaluation metrics, performance outcomes, and any reported advantages or limitations.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Triple‑relation view</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Grounded Triple Relations (word‑level labeled arcs)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A representation that breaks an input graph into its set of labeled triples, grounds each triple to word tokens via node→word alignments, and represents the graph as a set of labeled arcs connecting word pairs; used as a reconstruction target via a biaffine classifier on decoder states.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>Grounded triple sequence / labeled arc set</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Each graph edge (v_i, label, v_j) is converted to a grounded labeled arc connecting the first word tokens of the aligned node mentions in the target sentence; for multi‑word nodes additional 'compound' arcs connect the chosen anchor word to other mention tokens. The resulting structure is a set of labeled word–word arcs (dependency‑like) used as a target for reconstruction.</td>
                        </tr>
                        <tr>
                            <td><strong>representation_type</strong></td>
                            <td>set-based, token‑based, sequentially agnostic (local relations preserved); preserves local edge information</td>
                        </tr>
                        <tr>
                            <td><strong>encoding_method</strong></td>
                            <td>Edge list / triple extraction + grounding via precomputed node→word alignments (rule‑based or off‑the‑shelf aligners such as ISI aligner); each triple becomes a labeled arc between anchored word tokens</td>
                        </tr>
                        <tr>
                            <td><strong>canonicalization</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>average_token_length</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>dataset_name</strong></td>
                            <td>LDC2015E86 (AMR), LDC2017T10 (AMR), WebNLG (KG)</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Graph‑to‑text generation (auxiliary autoencoding / reconstruction during training)</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Relation‑aware Transformer baseline (RA‑Trans‑F‑ours) + biaffine arc & label classifier</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Relation‑aware Transformer encoder (6 self‑attention layers, 8 heads, embedding & hidden size 512) as baseline; triple reconstruction implemented as deep biaffine classifier (Dozat & Manning style) over decoder states with two MLPs for arc and label representations (MLPs: 2 layers × 512 units).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td>BLEU, METEOR, human relation recall</td>
                        </tr>
                        <tr>
                            <td><strong>performance_value</strong></td>
                            <td>On LDC2015E86: baseline BLEU 29.11 → +Loss1 (Triple) BLEU 30.47 (≈+1.36); METEOR baseline 35.0 → +Loss1 35.5. Human relation recall: baseline 78.00% → +Both 85.13% (paper reports +7.13% with both losses). On LDC2017T10: +Loss1 BLEU 33.98 (baseline 31.77). On WebNLG: baseline 60.51 BLEU → +Loss1 61.78.</td>
                        </tr>
                        <tr>
                            <td><strong>impact_on_training</strong></td>
                            <td>Provides an additional, local structural reconstruction signal that improved BLEU and METEOR and increased recall of input relations in human evaluation; computationally efficient to compute in parallel (biaffine predictions are parallelizable); does not change decoding/inference cost (offline training only).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations</strong></td>
                            <td>Requires node→word alignments to ground triples into sentence tokens (aligners or heuristics); depends on availability/quality of alignments (may be harder for some graph types or multilingual scenarios); only explicitly enforces local pairwise relations and may not capture global graph structure by itself; dropping edge labels causes large performance degradation (edge labels are important).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other</strong></td>
                            <td>Faster and lower variance than linearized‑graph reconstruction because triple predictions are parallelizable and agnostic to token order; emphasizes local relation preservation but less directly enforces global graph structure compared to DFS linearization reconstruction; complementary to linearized graph view — combining both yields larger gains than either alone.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Structural Information Preserving for Graph-to-Text Generation', 'publication_date_yy_mm': '2020-07'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6988.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e6988.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of graph-to-text representations used to convert graphs into textual sequences for language model training, including their description, encoding method, properties, datasets, models, evaluation metrics, performance outcomes, and any reported advantages or limitations.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>DFS Linearization</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Depth‑First Search (DFS) Linearized Graph Sequence with Brackets</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A sequential tokenization of the entire graph produced by a depth‑first traversal that inserts brackets to preserve scoping; used as a sequence reconstruction target with a Transformer decoder to recover global graph structure.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Neural amr: Sequence-to-sequence models for parsing and generation</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>DFS linearized graph (bracketed sequence)</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>The graph is serialized into a token sequence by depth‑first traversal; node tokens, edge labels and inserted bracket tokens are emitted in traversal order so brackets mark subtree scopes and preserve graph scopes; node sense suffixes may be removed depending on preprocessing.</td>
                        </tr>
                        <tr>
                            <td><strong>representation_type</strong></td>
                            <td>sequential, token‑based, hierarchical (bracketed), approximate/reconstructible (practical but can be lossy depending on information retained)</td>
                        </tr>
                        <tr>
                            <td><strong>encoding_method</strong></td>
                            <td>Depth‑first traversal (Konstas et al., 2017 style) that emits node labels, edge labels and explicit bracket tokens to indicate scopes; children ordering follows a left‑to‑right rule but can be randomized (tested for robustness).</td>
                        </tr>
                        <tr>
                            <td><strong>canonicalization</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>average_token_length</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>dataset_name</strong></td>
                            <td>LDC2015E86 (AMR), LDC2017T10 (AMR), WebNLG (KG)</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Graph‑to‑text generation (auxiliary autoencoding / reconstruction during training)</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>RA‑Trans‑F‑ours encoder + separate Transformer decoder for graph sequence (SADecoder_g)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Same encoder/decoder base sizes as baseline (6 layer Transformer encoder, decoder architecture identical to baseline); an additional Transformer decoder conditioned on the final decoder states of the sentence decoder produces the linearized graph sequence; training uses negative log‑likelihood on the graph token sequence.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td>BLEU, METEOR, training time</td>
                        </tr>
                        <tr>
                            <td><strong>performance_value</strong></td>
                            <td>On LDC2015E86: baseline BLEU 29.11 → +Loss2 (Linearized) BLEU 31.13 (≈+2.02 vs baseline, +0.66 vs Loss1); METEOR baseline 35.0 → +Loss2 36.1. On LDC2017T10: +Loss2 BLEU 34.13 (baseline 31.77). On WebNLG: baseline 60.51 BLEU → +Loss2 62.29. Training time: Loss2 roughly doubles per‑step time versus baseline (paper reports Loss2 time 0.52s vs baseline 0.25s; both losses combined 0.61s).</td>
                        </tr>
                        <tr>
                            <td><strong>impact_on_training</strong></td>
                            <td>Provides a global structural reconstruction signal that yields larger BLEU/METEOR gains than triple‑only in some settings; enforces recovery of full graph structures and is general across graph types (does not require node→word alignments); slower to train because generation is sequential and not parallelizable.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations</strong></td>
                            <td>Slower training (roughly 2× slower per step than baseline), sensitive to the chosen linearization order (though the paper reports robustness to random child ordering with only marginal BLEU drop), and may become token‑expensive for very large graphs; requires careful handling to ensure linearization retains reconstructability for specific graph types (reentrancies, senses, etc.).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other</strong></td>
                            <td>More general than triple grounding because it does not require node→word alignments and enforces global graph structure; less parallelizable and slower than triple reconstruction; complementary — combining DFS linearization loss with triple loss gave the best performance in experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Structural Information Preserving for Graph-to-Text Generation', 'publication_date_yy_mm': '2020-07'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6988.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e6988.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of graph-to-text representations used to convert graphs into textual sequences for language model training, including their description, encoding method, properties, datasets, models, evaluation metrics, performance outcomes, and any reported advantages or limitations.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Relation‑path feature (γ_ij)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Relation Path Feature Token (γ_ij) used in Relation‑aware Transformer</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A compact tokenized representation of the structural relation between any node pair formed by concatenating edge labels along the path between nodes (with direction markers) and embedding this label sequence as a single feature token γ_ij used by a relation‑aware Transformer encoder.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Modeling graph structure in transformer for better amr-to-text generation</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>Path label embedding (relation path token)</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>For each node pair (v_i, v_j) the sequence of edge labels along the graph path (with arrows indicating direction) is concatenated into a single feature token string (e.g., ':ARG0↑ :ARG1↓ :ARG0↓') and mapped to an embedding; only the most frequent 20K such features are kept, others are UNK.</td>
                        </tr>
                        <tr>
                            <td><strong>representation_type</strong></td>
                            <td>feature token (vectorized structural feature), token‑based but not a text sequence used for generation</td>
                        </tr>
                        <tr>
                            <td><strong>encoding_method</strong></td>
                            <td>Path extraction between node pairs followed by treating the path label sequence as a single feature token and embedding it as γ_ij; frequency cutoff (top 20K features kept) with rare features mapped to UNK.</td>
                        </tr>
                        <tr>
                            <td><strong>canonicalization</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>average_token_length</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>dataset_name</strong></td>
                            <td>LDC2015E86 (AMR), LDC2017T10 (AMR) (used as encoder features in baseline RA‑Trans models)</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Graph‑to‑text generation (encoder structural feature)</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Relation‑aware Transformer (Zhu et al., 2019 style; RA‑Trans‑F‑ours baseline)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Structure‑aware Transformer encoder that augments standard self‑attention with γ_ij vectors representing relation paths between node pairs; used with standard Transformer decoder. Encoder uses 6 layers, 8 heads, hidden size 512; γ_ij is added into attention computations.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td>BLEU (baseline performance), METEOR</td>
                        </tr>
                        <tr>
                            <td><strong>performance_value</strong></td>
                            <td>Baseline RA‑Trans‑F‑ours (using relation‑path features) BLEU: 29.11 on LDC2015E86 (paper's implementation); RA‑Trans variants using relation‑aware features are among top baselines.</td>
                        </tr>
                        <tr>
                            <td><strong>impact_on_training</strong></td>
                            <td>Provides dense vectorized structural information directly in encoder attention computations and yields competitive baseline performance; reduced need for graph neural network encoders for some tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations</strong></td>
                            <td>Large number of distinct path features necessitates frequency cutoff (20K) and UNK mapping which may lose rare structural patterns; alternatives (CNN / self‑attention to compute γ_ij) are possible but more GPU‑memory intensive.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other</strong></td>
                            <td>Compared to GNN encoders (GCNs/GRNs) it achieves competitive or better results in prior work; compared to the paper's auxiliary reconstructions, γ_ij is an encoder‑side structural feature while the proposed autoencoding views are decoder‑side auxiliary training signals and are complementary.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Structural Information Preserving for Graph-to-Text Generation', 'publication_date_yy_mm': '2020-07'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Neural amr: Sequence-to-sequence models for parsing and generation <em>(Rating: 2)</em></li>
                <li>Modeling graph structure in transformer for better amr-to-text generation <em>(Rating: 2)</em></li>
                <li>Deep biaffine attention for neural dependency parsing <em>(Rating: 2)</em></li>
                <li>Aligning english strings with abstract meaning representation graphs <em>(Rating: 1)</em></li>
                <li>Deep graph convolutional encoders for structured data to text generation <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-6988",
    "paper_id": "paper-9c120069f0dbd75cfa1e2cb76728d77d3d0ae830",
    "extraction_schema_id": "extraction-schema-135",
    "extracted_data": [
        {
            "name_short": "Triple‑relation view",
            "name_full": "Grounded Triple Relations (word‑level labeled arcs)",
            "brief_description": "A representation that breaks an input graph into its set of labeled triples, grounds each triple to word tokens via node→word alignments, and represents the graph as a set of labeled arcs connecting word pairs; used as a reconstruction target via a biaffine classifier on decoder states.",
            "citation_title": "here",
            "mention_or_use": "use",
            "representation_name": "Grounded triple sequence / labeled arc set",
            "representation_description": "Each graph edge (v_i, label, v_j) is converted to a grounded labeled arc connecting the first word tokens of the aligned node mentions in the target sentence; for multi‑word nodes additional 'compound' arcs connect the chosen anchor word to other mention tokens. The resulting structure is a set of labeled word–word arcs (dependency‑like) used as a target for reconstruction.",
            "representation_type": "set-based, token‑based, sequentially agnostic (local relations preserved); preserves local edge information",
            "encoding_method": "Edge list / triple extraction + grounding via precomputed node→word alignments (rule‑based or off‑the‑shelf aligners such as ISI aligner); each triple becomes a labeled arc between anchored word tokens",
            "canonicalization": false,
            "average_token_length": null,
            "dataset_name": "LDC2015E86 (AMR), LDC2017T10 (AMR), WebNLG (KG)",
            "task_name": "Graph‑to‑text generation (auxiliary autoencoding / reconstruction during training)",
            "model_name": "Relation‑aware Transformer baseline (RA‑Trans‑F‑ours) + biaffine arc & label classifier",
            "model_description": "Relation‑aware Transformer encoder (6 self‑attention layers, 8 heads, embedding & hidden size 512) as baseline; triple reconstruction implemented as deep biaffine classifier (Dozat & Manning style) over decoder states with two MLPs for arc and label representations (MLPs: 2 layers × 512 units).",
            "performance_metric": "BLEU, METEOR, human relation recall",
            "performance_value": "On LDC2015E86: baseline BLEU 29.11 → +Loss1 (Triple) BLEU 30.47 (≈+1.36); METEOR baseline 35.0 → +Loss1 35.5. Human relation recall: baseline 78.00% → +Both 85.13% (paper reports +7.13% with both losses). On LDC2017T10: +Loss1 BLEU 33.98 (baseline 31.77). On WebNLG: baseline 60.51 BLEU → +Loss1 61.78.",
            "impact_on_training": "Provides an additional, local structural reconstruction signal that improved BLEU and METEOR and increased recall of input relations in human evaluation; computationally efficient to compute in parallel (biaffine predictions are parallelizable); does not change decoding/inference cost (offline training only).",
            "limitations": "Requires node→word alignments to ground triples into sentence tokens (aligners or heuristics); depends on availability/quality of alignments (may be harder for some graph types or multilingual scenarios); only explicitly enforces local pairwise relations and may not capture global graph structure by itself; dropping edge labels causes large performance degradation (edge labels are important).",
            "comparison_with_other": "Faster and lower variance than linearized‑graph reconstruction because triple predictions are parallelizable and agnostic to token order; emphasizes local relation preservation but less directly enforces global graph structure compared to DFS linearization reconstruction; complementary to linearized graph view — combining both yields larger gains than either alone.",
            "uuid": "e6988.0",
            "source_info": {
                "paper_title": "Structural Information Preserving for Graph-to-Text Generation",
                "publication_date_yy_mm": "2020-07"
            }
        },
        {
            "name_short": "DFS Linearization",
            "name_full": "Depth‑First Search (DFS) Linearized Graph Sequence with Brackets",
            "brief_description": "A sequential tokenization of the entire graph produced by a depth‑first traversal that inserts brackets to preserve scoping; used as a sequence reconstruction target with a Transformer decoder to recover global graph structure.",
            "citation_title": "Neural amr: Sequence-to-sequence models for parsing and generation",
            "mention_or_use": "use",
            "representation_name": "DFS linearized graph (bracketed sequence)",
            "representation_description": "The graph is serialized into a token sequence by depth‑first traversal; node tokens, edge labels and inserted bracket tokens are emitted in traversal order so brackets mark subtree scopes and preserve graph scopes; node sense suffixes may be removed depending on preprocessing.",
            "representation_type": "sequential, token‑based, hierarchical (bracketed), approximate/reconstructible (practical but can be lossy depending on information retained)",
            "encoding_method": "Depth‑first traversal (Konstas et al., 2017 style) that emits node labels, edge labels and explicit bracket tokens to indicate scopes; children ordering follows a left‑to‑right rule but can be randomized (tested for robustness).",
            "canonicalization": true,
            "average_token_length": null,
            "dataset_name": "LDC2015E86 (AMR), LDC2017T10 (AMR), WebNLG (KG)",
            "task_name": "Graph‑to‑text generation (auxiliary autoencoding / reconstruction during training)",
            "model_name": "RA‑Trans‑F‑ours encoder + separate Transformer decoder for graph sequence (SADecoder_g)",
            "model_description": "Same encoder/decoder base sizes as baseline (6 layer Transformer encoder, decoder architecture identical to baseline); an additional Transformer decoder conditioned on the final decoder states of the sentence decoder produces the linearized graph sequence; training uses negative log‑likelihood on the graph token sequence.",
            "performance_metric": "BLEU, METEOR, training time",
            "performance_value": "On LDC2015E86: baseline BLEU 29.11 → +Loss2 (Linearized) BLEU 31.13 (≈+2.02 vs baseline, +0.66 vs Loss1); METEOR baseline 35.0 → +Loss2 36.1. On LDC2017T10: +Loss2 BLEU 34.13 (baseline 31.77). On WebNLG: baseline 60.51 BLEU → +Loss2 62.29. Training time: Loss2 roughly doubles per‑step time versus baseline (paper reports Loss2 time 0.52s vs baseline 0.25s; both losses combined 0.61s).",
            "impact_on_training": "Provides a global structural reconstruction signal that yields larger BLEU/METEOR gains than triple‑only in some settings; enforces recovery of full graph structures and is general across graph types (does not require node→word alignments); slower to train because generation is sequential and not parallelizable.",
            "limitations": "Slower training (roughly 2× slower per step than baseline), sensitive to the chosen linearization order (though the paper reports robustness to random child ordering with only marginal BLEU drop), and may become token‑expensive for very large graphs; requires careful handling to ensure linearization retains reconstructability for specific graph types (reentrancies, senses, etc.).",
            "comparison_with_other": "More general than triple grounding because it does not require node→word alignments and enforces global graph structure; less parallelizable and slower than triple reconstruction; complementary — combining DFS linearization loss with triple loss gave the best performance in experiments.",
            "uuid": "e6988.1",
            "source_info": {
                "paper_title": "Structural Information Preserving for Graph-to-Text Generation",
                "publication_date_yy_mm": "2020-07"
            }
        },
        {
            "name_short": "Relation‑path feature (γ_ij)",
            "name_full": "Relation Path Feature Token (γ_ij) used in Relation‑aware Transformer",
            "brief_description": "A compact tokenized representation of the structural relation between any node pair formed by concatenating edge labels along the path between nodes (with direction markers) and embedding this label sequence as a single feature token γ_ij used by a relation‑aware Transformer encoder.",
            "citation_title": "Modeling graph structure in transformer for better amr-to-text generation",
            "mention_or_use": "use",
            "representation_name": "Path label embedding (relation path token)",
            "representation_description": "For each node pair (v_i, v_j) the sequence of edge labels along the graph path (with arrows indicating direction) is concatenated into a single feature token string (e.g., ':ARG0↑ :ARG1↓ :ARG0↓') and mapped to an embedding; only the most frequent 20K such features are kept, others are UNK.",
            "representation_type": "feature token (vectorized structural feature), token‑based but not a text sequence used for generation",
            "encoding_method": "Path extraction between node pairs followed by treating the path label sequence as a single feature token and embedding it as γ_ij; frequency cutoff (top 20K features kept) with rare features mapped to UNK.",
            "canonicalization": true,
            "average_token_length": null,
            "dataset_name": "LDC2015E86 (AMR), LDC2017T10 (AMR) (used as encoder features in baseline RA‑Trans models)",
            "task_name": "Graph‑to‑text generation (encoder structural feature)",
            "model_name": "Relation‑aware Transformer (Zhu et al., 2019 style; RA‑Trans‑F‑ours baseline)",
            "model_description": "Structure‑aware Transformer encoder that augments standard self‑attention with γ_ij vectors representing relation paths between node pairs; used with standard Transformer decoder. Encoder uses 6 layers, 8 heads, hidden size 512; γ_ij is added into attention computations.",
            "performance_metric": "BLEU (baseline performance), METEOR",
            "performance_value": "Baseline RA‑Trans‑F‑ours (using relation‑path features) BLEU: 29.11 on LDC2015E86 (paper's implementation); RA‑Trans variants using relation‑aware features are among top baselines.",
            "impact_on_training": "Provides dense vectorized structural information directly in encoder attention computations and yields competitive baseline performance; reduced need for graph neural network encoders for some tasks.",
            "limitations": "Large number of distinct path features necessitates frequency cutoff (20K) and UNK mapping which may lose rare structural patterns; alternatives (CNN / self‑attention to compute γ_ij) are possible but more GPU‑memory intensive.",
            "comparison_with_other": "Compared to GNN encoders (GCNs/GRNs) it achieves competitive or better results in prior work; compared to the paper's auxiliary reconstructions, γ_ij is an encoder‑side structural feature while the proposed autoencoding views are decoder‑side auxiliary training signals and are complementary.",
            "uuid": "e6988.2",
            "source_info": {
                "paper_title": "Structural Information Preserving for Graph-to-Text Generation",
                "publication_date_yy_mm": "2020-07"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Neural amr: Sequence-to-sequence models for parsing and generation",
            "rating": 2,
            "sanitized_title": "neural_amr_sequencetosequence_models_for_parsing_and_generation"
        },
        {
            "paper_title": "Modeling graph structure in transformer for better amr-to-text generation",
            "rating": 2,
            "sanitized_title": "modeling_graph_structure_in_transformer_for_better_amrtotext_generation"
        },
        {
            "paper_title": "Deep biaffine attention for neural dependency parsing",
            "rating": 2,
            "sanitized_title": "deep_biaffine_attention_for_neural_dependency_parsing"
        },
        {
            "paper_title": "Aligning english strings with abstract meaning representation graphs",
            "rating": 1,
            "sanitized_title": "aligning_english_strings_with_abstract_meaning_representation_graphs"
        },
        {
            "paper_title": "Deep graph convolutional encoders for structured data to text generation",
            "rating": 1,
            "sanitized_title": "deep_graph_convolutional_encoders_for_structured_data_to_text_generation"
        }
    ],
    "cost": 0.0129305,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Structural Information Preserving for Graph-to-Text Generation</h1>
<p>Linfeng Song ${ }^{1}$, Ante Wang ${ }^{2}$, Jinsong $\mathbf{S u}^{2}$; Yue Zhang ${ }^{3}$, Kun $\mathbf{X u}^{1}$, Yubin $\mathbf{G e}^{4}$ and Dong $\mathbf{Y u}^{1}$<br>${ }^{1}$ Tencent AI Lab, Bellevue, WA, USA<br>${ }^{2}$ Xiamen University, Xiamen, China<br>${ }^{3}$ School of Engineering, Westlake University, China<br>${ }^{4}$ University of Illinois at Urbana-Champaign, USA</p>
<h4>Abstract</h4>
<p>The task of graph-to-text generation aims at producing sentences that preserve the meaning of input graphs. As a crucial defect, the current state-of-the-art models may mess up or even drop the core structural information of input graphs when generating outputs. We propose to tackle this problem by leveraging richer training signals that can guide our model for preserving input information. In particular, we introduce two types of autoencoding losses, each individually focusing on different aspects (a.k.a. views) of input graphs. The losses are then back-propagated to better calibrate our model via multi-task training. Experiments on two benchmarks for graph-to-text generation show the effectiveness of our approach over a state-of-the-art baseline. Our code is available at http://github.com/ Soistesimmer/AMR-multiview.</p>
<h2>1 Introduction</h2>
<p>Many text generation tasks take graph structures as their inputs, such as Abstract Meaning Representation (AMR) (Banarescu et al., 2013), Knowledge Graph (KG) and database tables. For example, as shown in Figure 1(a), AMR-to-text generation is to generate a sentence that preserves the meaning of an input AMR graph, which is composed by a set of concepts (such as "boy" and "want-01") and their relations (such as " $:$ ARG0" and " $:$ ARG1"). Similarly, as shown in Figure 1(b), KG-to-text generation is to produce a sentence representing a KG, which contains worldwide factoid information of entities (such as "Australia" and "Above the Veil") and their relations (such as "followedBy").</p>
<p>Recent efforts on graph-to-text generation tasks mainly focus on how to effectively represent input graphs, so that an attention mechanism can better transfer input knowledge to the decoder when</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: (a) An AMR graph meaning "The boy wants the beautiful girl to eat lunch with him.", and (b) A knowledge graph carrying the meaning "Above the Veil is an Australian novel and the sequel to Aenir. It was followed by Into the Battle."
generating sentences. Taking AMR-to-text generation as an example, different graph neural networks (GNNs) (Beck et al., 2018; Song et al., 2018; Guo et al., 2019; Ribeiro et al., 2019) have been introduced to better represent input AMRs than a sequence-to-sequence model (Konstas et al., 2017), and later work (Zhu et al., 2019; Cai and Lam, 2019; Wang et al., 2020) showed that relationaware Transformers can achieve even better results than GNNs. These advances for encoding have largely pushed the state-of-the-art performance.</p>
<p>Existing models are optimized by maximizing the conditional word probabilities of a reference sentence, a common signal for training language models. As a result, these models can learn to produce fluent sentences, but some crucial input concepts and relations may be messed up or even dropped. Taking the AMR in Figure 1(a) as an example, a model may produce "the girl wants the boy to go", which conveys an opposite meaning to the AMR graph. In particular, this can be very likely if "the girl wants" appears much more frequent than "the boy wants" in the training corpus. This is a very important issue, because of its wide existence across many neural graph-to-text</p>
<p>generation models, hindering the usability of these models for real-world applications (Dušek et al., 2018, 2019; Balakrishnan et al., 2019).</p>
<p>A potential solution for this issue is improving the training signal to enhance preserving of structural information. However, little work has been done to explore this direction so far, probably because designing such signals is non-trivial. As a first step towards this goal, we propose to enrich the training signal with additional autoencoding losses (Rei, 2017). Standard autoencoding for graph-to-sequence tasks requires reconstructing (parsing into) input graphs, while the parsing algorithm for one type of graphs (such as knowledge graphs) may not generalize to other graph types or may not even exist. To make our approach general across different types of graphs, we propose to reconstruct different views of each input graph (rather than the original graph), where each view highlights one aspect of the graph and is easy to produce. Then through multi-task learning, the autoencoding losses of all views are back-propagated to the whole model so that the model can better follow the input semantic constraints.</p>
<p>Specifically, we break each input graph into a set of triples to form our first view, where each triple (such as "want-01 :ARG0 boy" in Figure 1(a)) contains a pair of entities and their relation. As the next step, the alignments between graph nodes and target words are generated to ground this view into the target sentence for reconstruction. Our second view is the linearization of each input graph produced by depth-first graph traversal, and this view is reconstructed token-by-token from the last decoder state. Overall the first view highlights the local information of each triple relation, the second view focuses on the global semantic information of the entire graph.</p>
<p>Experiments on AMR-to-text generation and WebNLG (Gardent et al., 2017) show that our graph-based multi-view autoencoding loss improves the performance of a state-of-the-art baseline by more than 2 BLEU points without introducing any parameter during decoding. Besides, human studies show that our approach is indeed beneficial for preserving more concepts and relations from input graphs.</p>
<h2>2 Related Work</h2>
<p>Previous work for neural graph-to-text generation (Konstas et al., 2017; Song et al., 2018; Beck
et al., 2018; Trisedya et al., 2018; Marcheggiani and Perez-Beltrachini, 2018; Xu et al., 2018; Cao and Clark, 2019; Damonte and Cohen, 2019; Hajdik et al., 2019; Koncel-Kedziorski et al., 2019; Hong et al., 2019; Song et al., 2019; Su et al., 2017) mainly studied how to effectively represent input graphs, and all these models are trained only with the standard language modeling loss. As the most similar one to our work, Tu et al. (2017) proposed an encoder-decoder-reconstructor model for machine translation, which is trained not only to translate each source sentence into its target reference, but also to translate the target reference back into the source text (reconstruction). Wiseman et al. (2017) extended the reconstruction loss of Tu et al. (2017) on table-to-text generation, where a table contains multiple records that fit into several fields. We study a more challenging topic on how to reconstruct a complex graph structure rather than a sentence or a table, and we propose two general and effective methods that reconstruct different complementary views of each input graph. Besides, we propose methods to breakdown the whole (graph, sentence) pair into smaller pieces of (edge, word) pairs with alignments, before training our model to reconstruct each edge given the corresponding word. On the other hand, neither of the previous efforts tried to leverage this valuable information.</p>
<p>Our work is remotely related to the previous efforts on string-to-tree neural machine translation (NMT) (Aharoni and Goldberg, 2017; Wu et al., 2017; Wang et al., 2018), which aims at generating target sentences with their syntactic trees. One major difference is that their goal is producing grammatical outputs, while ours is preserving input structures. Besides, our multi-view reconstruction framework is a detachable component on top of the decoder states for training, so no extra error propagation (for structure prediction) can be introduced. Conversely, their models generate trees together with target sentences, thus extra efforts (Wu et al., 2017) are introduced to alleviate error propagation. Finally, there exist transition-based algorithms (Nivre, 2003) to convert tree parsing into the prediction of transition actions, while we study reconstructing graphs, where there is no common parsing algorithm for all graph types.</p>
<p>Autoencoding loss by input reconstruction was mainly adopted on sequence labeling tasks, such as named entity recognition (NER) (Rei, 2017; Liu et al., 2018a; Jia et al., 2019), simile detection</p>
<p>(Liu et al., 2018b) and sentiment analysis (Rei and Søgaard, 2019). Since input reconstruction is not intuitively related to these tasks, the autoencoding loss only serves as more training signals. Different from these efforts, we leverage autoencoding loss as a means to preserve input knowledge. Besides, we study reconstructing complex graphs, proposing a general multi-view approach for this goal.</p>
<h2>3 Base: Structure-Aware Transformer</h2>
<p>Formally, an input for graph-to-text generation can be represented as $\boldsymbol{G}=\langle\boldsymbol{V}, \boldsymbol{E}\rangle$, where $\boldsymbol{V}$ is the set of graph nodes and $\boldsymbol{E}$ corresponds to all graph edges. Each edge $e \in \boldsymbol{E}$ is a triple $\left(v_{i}, l, v_{j}\right)$, showing labelled relation between two connected nodes $v_{i}$ and $v_{j}$. Given a graph, we choose a recent relation-aware transformer model (Zhu et al., 2019) as our baseline to generate the ground-truth sentence $\boldsymbol{y}=\left(y_{1}, \ldots, y_{N}\right)$ that contain the same meaning as the input graph. It exhibits the state-of-the-art performance for AMR-to-text generation.</p>
<h3>3.1 Structure-aware Transformer Encoder</h3>
<p>Similar to the standard model (Vaswani et al., 2017), the structure-aware Transformer encoder stacks multiple self-attention layers on top of an embedding layer to encode linearized graph nodes. Taking the $l$-th layer for example, it consumes the states of its preceding layer $\left(\boldsymbol{h}<em N="N">{1}^{l-1} \ldots \boldsymbol{h}</em>\right.$, or the embedding layer when $l$ is 1 ) and its states are then updated by a weighted sum:}^{l-1</p>
<p>$$
\boldsymbol{h}<em N_="N]" _in_1="\in[1" class="" j="j">{i}^{l}=\sum</em>} \alpha_{i j}\left(\boldsymbol{h<em i="i" j="j">{j}^{l-1} \boldsymbol{W}^{P}+\boldsymbol{\gamma}</em>\right)
$$} \boldsymbol{W}^{R_{1}</p>
<p>where $\boldsymbol{\gamma}<em i="i">{i j}$ is the vector representation of the relation between nodes $v</em>$, are obtained by relation-aware self-attention:}$ and $v_{j}$, and $\boldsymbol{W}^{P}$ and $\boldsymbol{W}^{R_{1}}$ are model parameters. The weights, such as $\alpha_{i j</p>
<p>$$
\begin{aligned}
\alpha_{i j} &amp; =\frac{\exp \left(e_{i j}\right)}{\sum_{k \in[1 . . N]} \exp \left(e_{i k}\right)} \
e_{i j} &amp; =\frac{\left(\boldsymbol{h}<em j="j">{i}^{l-1} \boldsymbol{W}^{Q}\right)\left(\boldsymbol{h}</em>}^{l-1} \boldsymbol{W}^{K}+\boldsymbol{\gamma<em 2="2">{i j} \boldsymbol{W}^{R</em>
\end{aligned}
$$}}\right)^{\intercal}}{\sqrt{d_{h}}</p>
<p>where $\boldsymbol{W}^{Q}, \boldsymbol{W}^{K}$ and $\boldsymbol{W}^{R_{2}}$ are model parameters, and $d_{h}$ denotes the encoder-state dimension. The encoder adopts $L$ self-attention layers and $\boldsymbol{H}^{L}=$ $\left(\boldsymbol{h}<em _boldsymbol_V="|\boldsymbol{V">{1}^{L} \ldots \boldsymbol{h}</em>\right)$ represents the concatenated top-layer hidden states of the encoder, which will be used in attention-based decoding.}|}^{L</p>
<p>Compared with the standard model, this encoder introduces the vectorized structural information (such as $\boldsymbol{\gamma}<em i="i">{i j}$ ) for all node pairs. Given a node pair $v</em>}$ and $v_{j}$, generating such information involves two main steps. First, a sequence of graph edge labels along the path from $v_{i}$ to $v_{j}$ are obtained, where a direction symbol is added to each label to distinguish the edge direction. For instance, the label sequence from "boy" to "girl" in Figure 1(a) is " $: A R G 0 \uparrow: A R G 1 \downarrow: A R G 0 \downarrow$ ". As the next step, the label sequence is treated as a single (feature) token and represented by the corresponding embedding vector, and this vector is taken as the vectorized structural information $\boldsymbol{\gamma<em i="i">{i j}$ from $v</em>$}$ to $v_{j}$. Since there are a large number of features, only the most frequent 20 K are kept, while the rest are mapped into a special $U N K$ feature. ${ }^{1</p>
<h3>3.2 Standard Transformer Decoder</h3>
<p>The decoder is the same as the standard Transformer architecture, which stacks an embedding layer, multiple ( $L$ ) self-attention layers and a linear layer with softmax activation to generate target sentences in a word-by-word manner. Each target word $y_{i}$ and decoder state $\boldsymbol{s}_{i}$ are generated sequentially by the self-attention decoder:</p>
<p>$$
y_{i}, \boldsymbol{s}<em 1="1">{i}=\operatorname{SADecoder}\left(\left[\boldsymbol{H}^{L} ; \boldsymbol{s}</em>} \ldots \boldsymbol{s<em i-1="i-1">{i-1}\right], y</em>\right)
$$</p>
<p>where SADecoder() is the function of decoding one step with the self-attention-based decoder.</p>
<h3>3.3 Training with Language Modeling Loss</h3>
<p>Same as most previous work, this model is trained with the standard language modeling loss that minimizes the negative log-likelihood of conditional word probabilities:</p>
<p>$$
\begin{aligned}
l_{\text {base }} &amp; =-\sum_{i \in[1 . . N]} \log p\left(y_{i} \mid y_{1}, \ldots, y_{i-1} ; \boldsymbol{G}\right) \
&amp; =-\sum_{i \in[1 . . N]} p\left(y_{i} \mid \boldsymbol{s}_{i} ; \boldsymbol{\theta}\right)
\end{aligned}
$$</p>
<p>where $\boldsymbol{\theta}$ represents all model parameters.</p>
<h2>4 Multi-View Autoencoding Losses</h2>
<p>Figure 2 visualizes the training framework using our multi-view autoencoding losses, where the</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: The training framework using multi-view autoencoding losses.
attention-based encoder-decoder model with the language modeling loss is the baseline. Our losses are produced by reconstructing the two proposed views (surrounded by slashed or dotted box) of the input graph, where each view represents a different aspect of the input. With the proposed losses, we expect to better refine our model for preserving the structural information of input graphs.</p>
<h3>4.1 Loss 1: Reconstructing Triple Relations with Biaffine Attention</h3>
<p>Our first view breaks each input graph into a set of triples, where each triple (such as "want-01 :ARG0 boy" in Figure 1(a)) contains a pair of nodes and their labeled relation. Next, we use pre-generated alignments between graph nodes and target words to ground the graph triples onto the target sentence. As illustrated in the slashed blue box of Figure 2, the result contains several labeled arcs, each connecting a word pair (such as "wants" and "boy"). While each arc represents a local relation, their combination implies the global input structure.</p>
<p>For certain types of graphs, a node can have multiple words. To deal with this situation, we use the first word of both associated graph nodes when grounding a graph edge onto the target sentence. Next, we also connect the first word of each grounded entity with the other words of the entity in order to represent the whole-entity information in the sentence. Taking the edge "followedBy" in Figure 1(b) as an example, we first ground it onto the target sentence to connect words "Above" and "Into". Next, we create edges with label "compound" from "Above" to words "the" and "Veil", and from "Into" to words "the" and "Battle" to indicate the two associated entity mentions.</p>
<p>For many tasks on graph-to-text generation, the node-to-word alignments can be easily generated from off-the-shell toolkits. For example, in AMR-to-text generation, there have been several aligners (Pourdamghani et al., 2014; Flanigan et al., 2016; Wang and Xue, 2017; Liu et al., 2018c; Szubert et al., 2018) available for linking AMR nodes to words. For knowledge graphs, the alignments can be produced by simple rule-based matching or an entity-linking system.</p>
<p>The resulting structure with labeled arcs connecting word pairs resembles a dependency tree, and thus we employ a deep biaffine model (Dozat and Manning, 2017) to predict this structure from the decoder states. More specifically, the model factorizes the probability for making each arc into two parts: an unlabeled factor and a labeled one. Given the decoder states $\boldsymbol{s}<em N="N">{1}, \ldots, \boldsymbol{s}</em>$ through the corresponding multi-layer perceptrons (MLPs):}$, the representation for each word $y_{i}$ as the head or the modifier of any unlabeled factor is calculated by passing its hidden state $\boldsymbol{s}_{i</p>
<p>$$
\begin{aligned}
\boldsymbol{r}<em i="i">{i}^{\mathrm{arc}-\mathrm{h}} &amp; =\operatorname{MLP}^{\mathrm{arc}-\mathrm{head}}\left(\boldsymbol{s}</em>\right) \
\boldsymbol{r}<em i="i">{i}^{\mathrm{arc}-\mathrm{m}} &amp; =\operatorname{MLP}^{\mathrm{arc}-\mathrm{mod}}\left(\boldsymbol{s}</em>\right)
\end{aligned}
$$</p>
<p>The (unnormalized) scores for the unlabeled factors with any possible head word given the modifier $y_{i}$ are calculated as:</p>
<p>$$
\boldsymbol{\phi}<em a="a">{i}^{\mathrm{arc}}=\boldsymbol{R}^{\mathrm{arc}-\mathrm{h}} \boldsymbol{U}</em>}^{\mathrm{t}} \boldsymbol{r<em a="a">{i}^{\mathrm{arc}-\mathrm{m}}+\boldsymbol{R}^{\mathrm{arc}-\mathrm{h}} \boldsymbol{v}</em>
$$</p>
<p>where $\boldsymbol{R}^{\mathrm{arc}-\mathrm{h}}$ is the concatenation of all $\boldsymbol{r}<em a="a">{i}^{\mathrm{arc}-\mathrm{h}}$, and $\boldsymbol{U}</em>}$ and $\boldsymbol{v<em i="i">{a}$ are model parameters. Similarly, the representations for word $y</em>$ being the head or the modifier of a labeled factor are calculated by</p>
<p>two additional MLPs:</p>
<p>$$
\begin{aligned}
\boldsymbol{r}<em i="i">{i}^{\text {label }-\mathrm{h}} &amp; =\mathrm{MLP}^{\text {label }-\text { head }}\left(\boldsymbol{s}</em>\right) \
\boldsymbol{r}<em i="i">{i}^{\text {label }-\mathrm{m}} &amp; =\mathrm{MLP}^{\text {label }-\mathrm{mod}}\left(\boldsymbol{s}</em>\right)
\end{aligned}
$$</p>
<p>and the (unnormalized) scores for all relation labels given the head word $y_{j}$ and the modifier $y_{i}$ are calculated as:</p>
<p>$$
\begin{aligned}
\boldsymbol{\phi}<em j="j">{i, j}^{\text {label }}=\boldsymbol{r}</em>}^{\text {label }-\mathrm{h}} \boldsymbol{U<em i="i">{l} \boldsymbol{r}</em>+ &amp; \
&amp; \left(\boldsymbol{r}}^{\text {label }-\mathrm{m}<em i="i">{j}^{\text {label }-\mathrm{h}} \oplus \boldsymbol{r}</em>}^{\text {label }-\mathrm{m}}\right)^{\top} \boldsymbol{V<em l="l">{l}+\boldsymbol{b}</em>
\end{aligned}
$$</p>
<p>where $\boldsymbol{U}<em l="l">{l}, \boldsymbol{V}</em>}$ and $\boldsymbol{b<em j="j">{l}$ are model parameters. The overall conditional probability of a labeled arc with label $l$, head word $y</em>$ is calculated by the following chain rule:}$ and modifier $y_{i</p>
<p>$$
\begin{aligned}
&amp; p\left(y_{j}, l \mid y_{i}\right)=p\left(l \mid y_{j}, y_{i}\right) \cdot p\left(y_{j} \mid y_{i}\right) \
&amp; =\operatorname{softmax}\left(\boldsymbol{\phi}<em _mid="\mid" l_="l]">{i, j}^{\text {label }}\right)</em>} \cdot \operatorname{softmax}\left(\boldsymbol{\phi<em _mid="\mid" j="j">{i}^{\mathrm{arc}}\right)</em>
\end{aligned}
$$</p>
<p>where $[x]$ in the subscript represents choosing the $x$-th item from the corresponding vector.</p>
<p>As the final step, the loss for reconstructing this view is defined as the negative log-likelihood of all target arcs $\boldsymbol{E}^{\prime}$ (the grounded triples from $\boldsymbol{E}$ ):</p>
<p>$$
l_{\text {auto1 }}=\sum_{\left(y_{j}, l, y_{i}\right) \in \boldsymbol{E}^{\prime}}-\log p\left(y_{j}, l \mid y_{i}\right)
$$</p>
<h3>4.2 Loss 2: Reconstructing Linearized Graphs with a Transformer Decoder</h3>
<p>As a supplement to our first loss for reconstructing the local information of each grounded triple, we introduce the second loss for predicting the whole graph as a linearized sequence. To minimize the loss of the graph structural information caused by linearization, we adopt an algorithm based on depth-first traversal (Konstas et al., 2017), which inserts brackets to preserve graph scopes. One linearized AMR graph is shown in the red dotted box of Figure 2, where the node suffixes (such as "-01") representing word senses are removed.</p>
<p>One may argue that we could directly predict the original graph so that no structural information would be lost. However, each type of graphs can have their own parsing algorithm due to their unique properties (such as directed vs undirected, rooted vs unrooted, etc). Such an exact prediction will hurt the generality of the proposed approach. Conversely, our solution is general, as linearization works for most types of graphs. From Figure 2 we can observe that the inserted brackets clearly
infer the original graph structure. Besides, previous work (Iyer et al., 2017; Konstas et al., 2017) has shown the effectiveness of generating linearized graphs as sequences for graph parsing, which also confirms our observation.</p>
<p>Given a linearized graph represented as a sequence of tokens $x_{1}, \ldots, x_{M}$, where each token $x_{i}$ can be a graph node, a edge label or a inserted bracket, we adopt another standard Transformer decoder (SADecoder $_{g}$ ) to produce the sequence:</p>
<p>$$
x_{i}, \boldsymbol{t}<em g="g">{i}=\operatorname{SADecoder}</em>}\left(\left[\boldsymbol{S} ; \boldsymbol{t<em i-1="i-1">{1} \ldots \boldsymbol{t}</em>\right)
$$}\right], x_{i-1</p>
<p>where $\boldsymbol{S}=\left(\boldsymbol{s}<em N="N">{1} \ldots \boldsymbol{s}</em>\right)$ denotes the concatenated states for the target sentence (Equation 4), and the loss for reconstructing this view is defined as the negative log-likelihood for the linearized graph:</p>
<p>$$
l_{\text {auto2 }}=-\sum_{i \in[1 . . M]} \log p\left(x_{i} \mid \boldsymbol{t}_{i} ; \boldsymbol{\theta}\right)
$$</p>
<p>where $\boldsymbol{\theta}$ represents model parameters.</p>
<h3>4.3 Discussion and Comparison</h3>
<p>Our autoencoding modules function as detachable components based on the target-side decoder states, and thus this brings two main benefits. First, our approaches are not only orthogonal to the recent advances (Li et al., 2016; Kipf and Welling, 2017; Veličković et al., 2018) on the encoder side for representing graphs, but also flexible with other decoders based on multi-layer LSTM (Hochreiter and Schmidhuber, 1997) or GRU (Cho et al., 2014). Second, no extra error propagation is introduced, as our approach does not affect the normal sentencedecoding process.</p>
<p>In addition to the different aspects both losses focus on, each has some merits and disadvantages over the other. In terms of training speed, calculating Loss 1 can be faster than Loss 2, because predicting the triple relations can be done in parallel, while it is not feasible for generating a linearized graph. Besides, calculating Loss 1 suffers from less variances, as the triple relations are agnostic to the token order determined by input files. Conversely, graph linearization is highly sensitive to the input order. One major merit for Loss 2 is the generality, as node-to-word alignments may not be easily obtained, especially for multi-lingual tasks.</p>
<h3>4.4 Training with Autoencoding Losses</h3>
<p>The final training signal with both proposed autoencoding losses is formalized as:</p>
<p>$$
l_{\text {final }}=l_{\text {base }}+\alpha l_{\text {auto1 }}+\beta l_{\text {auto2 }}
$$</p>
<p>where $\alpha$ and $\beta$ are coefficients for our proposed losses. Both coefficient values are selected by a development experiment.</p>
<h2>5 Experiments</h2>
<p>We study the effectiveness of our autoencoding training framework on AMR-to-text generation and KG-to-text generation. BLEU (Papineni et al., 2002) and Meteor (Denkowski and Lavie, 2014) scores are reported for comparison. Following previous work, we use the multi-bleu.perl from Moses ${ }^{2}$ for BLEU evaluation.</p>
<h3>5.1 Data</h3>
<p>AMR datasets ${ }^{3}$ We take LDC2015E86 that contains $16,833,1,368$ and 1,371 instances for training, development and testing, respectively. Each instance contains a sentence and an AMR graph. Following previous work, we use a standard AMR simplifier (Konstas et al., 2017) to preprocess our AMR graphs, and take the PTB-based Stanford tokenizer ${ }^{4}$ to tokenize the sentences. The node-toword alignments are produced by the ISI aligner (Pourdamghani et al., 2014). We use this dataset for our primary experiments. We also report our numbers on LDC2017T10, a later version of AMR dataset that has 36521, 1,368 and 1,371 instances for training, development and testing, respectively.</p>
<p>WebNLG (Gardent et al., 2017) This dataset consists of 18,102 training and 871 development KG-text pairs, where each KG is a subgraph of DBpedia ${ }^{5}$ that can contain up to 7 relations (triples). The testset has two parts: seen, containing 971 pairs where the KG entities and relations belong to the DBpedia categories that are seen in the training data, and unseen, where the entities and relations come from unseen categories. Same as most previous work, we evaluate our model on the seen part, and this is also more relevant to our setup.</p>
<p>We follow Marcheggiani and Perez-Beltrachini (2018) to preprocess the data. To obtain the alignments between a KG and a sentence, we use a method based on heuristic string matching. For more detail, we remove any abbreviations from a KG node (such as "New York (NY)" is changed to "New York"), before finding the first phrase in the</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: Development results on LDC2015E86.
sentence that matches the longest prefix of the node. As a result, we find a match for $91 \%$ KG nodes.</p>
<h3>5.2 Settings</h3>
<p>For model hyperparameters, we follow the setting of our baseline (Zhu et al., 2019), where 6 selfattention layers are adopted with 8 heads for each layer. Both sizes of embedding and hidden states are set to 512 , and the batch token-size is 4096 . The embeddings are randomly initialized and updated during training. All models are trained for 300 K steps using Adam (Kingma and Ba, 2014) with $\beta 1=0.1$. Byte-pair encoding (BPE) (Sennrich et al., 2016) with 10 K operations is applied to all datasets. We use 1080Ti GPUs for experiments.</p>
<p>For our approach, the multi-layer perceptrons for deep biaffine classifiers (Equations 6, 7, 9 and 10) take two layers of 512 units. The Transformer decoder (Equation 14) for predicting linearized graphs takes the same embedding and hidden sizes as the baseline decoder (Equation 4).</p>
<h3>5.3 Development Results</h3>
<p>Figure 3 shows the devset performances of using either Loss 1 (triple relations) or Loss 2 (linearized graph) under different coefficients. It shows the baseline performance when a coefficient equals to 0 . There are large improvements in terms of BLEU score when increasing the coefficient of either loss from 0 . These results indicate the effectiveness of our autoencoding training framework. The performance of our model with either loss slightly goes down when further increasing the coefficient. One underlying reason is that an over-large coefficient will dilute the primary signal on language modeling, which is more relevant to the BLEU metric. Particularly, we observe the highest performances when $\alpha$ and $\beta$ are 0.05 and 0.15 , respectively, and thus we set our coefficients using these values for the remaining experiments.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: center;">BLEU</th>
<th style="text-align: center;">Time</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">LSTM (Konstas et al., 2017)</td>
<td style="text-align: center;">22.00</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">GRN (Song et al., 2018)</td>
<td style="text-align: center;">23.28</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">DCGCN (Guo et al., 2019)</td>
<td style="text-align: center;">25.70</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">RA-Trans-SA (Zhu et al., 2019)</td>
<td style="text-align: center;">29.66</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">RA-Trans-F-ours</td>
<td style="text-align: center;">29.11</td>
<td style="text-align: center;">0.25</td>
</tr>
<tr>
<td style="text-align: left;">+ Loss 1 (triple relations)</td>
<td style="text-align: center;">30.47</td>
<td style="text-align: center;">0.38</td>
</tr>
<tr>
<td style="text-align: left;">+ Loss 2 (linearized graph)</td>
<td style="text-align: center;">31.13</td>
<td style="text-align: center;">0.52</td>
</tr>
<tr>
<td style="text-align: left;">+ Both</td>
<td style="text-align: center;">$\mathbf{3 1 . 4 1}$</td>
<td style="text-align: center;">0.61</td>
</tr>
<tr>
<td style="text-align: left;">DCGCN (0.3M)</td>
<td style="text-align: center;">33.2</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">GRN (2M)</td>
<td style="text-align: center;">33.6</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">LSTM (20M)</td>
<td style="text-align: center;">33.8</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">DCGCN (ensemble, 0.3M)</td>
<td style="text-align: center;">35.3</td>
<td style="text-align: center;">-</td>
</tr>
</tbody>
</table>
<p>Table 1: Main test results on LDC2015E86. Numbers such as " $2 M$ " means the number of extra silver data being used, and "ensemble" indicates model ensemble.</p>
<h3>5.4 Main Results</h3>
<p>Table 1 shows the main comparison results with existing work for AMR-to-text generation, where "Time" represents the average time (seconds) for training one step. The first group corresponds to the reported numbers of previous models on this dataset, and their main difference is the encoder for presenting graphs: LSTM (Konstas et al., 2017) applies a multi-layer LSTM on linearized AMRs, GRN (Song et al., 2018) and DCGCN (Guo et al., 2019) adopt graph neural networks to encode original AMRs, and RA-Trans-SA is the best performing model of Zhu et al. (2019), using self attention to model the relation path for each node pair.</p>
<p>The second group reports our systems, where the RA-Trans-F-ours baseline is our implementation of the feature-based model of Zhu et al. (2019). It shows a highly competitive performance on this dataset. Applying Loss 1 alone achieves an improvement of 1.36 BLEU points, and Loss 2 alone obtains 0.66 more points than Loss 1. One possible reason is that Loss 2, which aims to reconstruct the whole linearized graph, can provide more informative features. Using both losses, we observe roughly a 2.3-point gain in terms of BLEU, indicating that both losses are complementary.</p>
<p>Regarding Meteor, RA-Trans-SA reports 35.45, the highest among all previously reported numbers. The RA-Trans-F-ours baseline gets 35.0 that is slightly worse than RA-Trans-SA. Applying Loss 1 or Loss 2 alone gives a number of 35.5 and 36.1, respectively. Using both losses, our approach achieves 36.2 that is better than $R A$-Trans-SA.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: center;">Recall (\%)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">RA-Trans-F-ours</td>
<td style="text-align: center;">78.00</td>
</tr>
<tr>
<td style="text-align: left;">+ Both</td>
<td style="text-align: center;">$\mathbf{8 5 . 1 3}$</td>
</tr>
</tbody>
</table>
<p>Table 2: Human study for the recall of input relations on LDC2015E86.</p>
<p>Regarding the training speed, adopting Loss 2 requires double amount of time compared with the baseline, being much slower than Loss 1. This is because the biaffine attention calculations for different word pairs are parallelizable, while it is not for producing a linearized graph. Using both losses together, we observe a moderately longer training process (1.4-times slower) than the baseline. Please note that our autoencoding framework only affects the offline training procedure, leaving the online inference process unchanged.</p>
<p>The last group shows additional higher numbers produced by systems that use the ensemble of multiple models and/or additional silver data. They suffer from problems such as requiring massive computation resources and taking a long time for training. We leave exploring additional silver data and ensemble for further work.</p>
<h3>5.5 Quantitative Human Study on Preserving Input Relation</h3>
<p>Our multi-view autoencoding framework aims at preserving input relations, thus we further conduct a quantitative human study to estimate this aspect. To this end, we first extract all interactions of a subject, a predict and an object (corresponding to the AMR fragment "pred :ARG0 subj :ARG1 $o b j$ ") from each AMR graph, and then check how many interactions are preserved by the output of a model. The reason for considering this type of interaction comes from two folds: first, they convey fundamental information forming the backbone of a sentence, and second, they can be easily extracted from graphs and evaluated by human judges.</p>
<p>As shown in Table 2, we choose 200 AMRsentence pairs to conduct this study and compare our model with the baseline in terms of the recall number, showing the percent of preserved interactions. To determine if a sentence preserves an interaction, we ask 3 people with NLP background to make their decisions and choose the majority vote as the human judgement. Out of the 491 interactions, the baseline only preserves $78 \%$. With our multi-view autoencoding losses, $7.13 \%$ more</p>
<table>
<thead>
<tr>
<th style="text-align: center;">(r / recommend-01</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">: ARG0 (i / i)</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">: ARG1 (g / go-02</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">:ARG0 (y / you)</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">: purpose (s / see-01</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">:ARG0 y</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">:ARG1 (p / person</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">:ARG0-of (h / have-rel-role-91</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">:ARG1 y</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">:ARG2 (d / doctor)))</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">: $\bmod (t /$ too)))</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">:ARG2 y)</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>Ref: i 'd recommend you go and see your doctor too .
Baseline: i should go to see your doctor too .
Our approach: i recommend you to go to see your doctor too .</p>
<div class="codehilite"><pre><span></span><code>(c / country
    :mod (o / only)
    :ARG0-of (h / have-03
        :ARG1 (p / policy
            :consist-of (t / target-01
                :ARG1 (a / aircraft
                    :ARG0-of (t2 / traffic-01
                    :ARG1 (d / drug)))))
            :time (c3 / current))
    :domain (c2 / country
        :wiki &quot;Colombia&quot;
        :name (n / name :op1 &quot;Colombia&quot;)))
</code></pre></div>

<p>Ref: colombia is the only country that currently has a policy of targeting drug trafficking aircraft .
Baseline: colombia is the only country with drug trafficking policy .
Our approach: colombia is the only country with the current policy of targets for drug trafficking aircraft.</p>
<p>Table 3: Example system outputs.
interactions are preserved, which further confirms the effectiveness of our approach.</p>
<h3>5.6 Case Study</h3>
<p>As shown in Table 3, we further demonstrate several typical examples from our human study for better understanding how our framework helps preserve structural input information. Each example includes an input AMR, a reference sentence (Ref), the baseline output (Baseline) and the generated sentence by our approach (Our approach).</p>
<p>For the first example, the baseline output drops the key predicate "recommend" and fails to preserve the fact that "you" is the subject of "go". The reason can be that "I should go to" occurs frequently in the training corpus. On the other hand, the extra signals produced by our multi-view framework enhance the input semantic information, guiding our model to generate a correct sentence</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: left;">BLEU</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">RA-Trans-F-ours + Loss 1</td>
<td style="text-align: left;">30.47</td>
</tr>
<tr>
<td style="text-align: left;">w/o edge label</td>
<td style="text-align: left;">29.39</td>
</tr>
<tr>
<td style="text-align: left;">RA-Trans-F-ours + Loss 2</td>
<td style="text-align: left;">31.13</td>
</tr>
<tr>
<td style="text-align: left;">w/o edge label</td>
<td style="text-align: left;">30.36</td>
</tr>
<tr>
<td style="text-align: left;">random linearization</td>
<td style="text-align: left;">31.07</td>
</tr>
</tbody>
</table>
<p>Table 4: Ablation study for both views.
with the exact meaning of the input AMR.
The second example shows a similar situation, where the baseline generates a natural yet short sentence that drops some important information from the input graph. As a result of the information loss, the resulting sentence conveys an opposite meaning ("with drug trafficking policy") to the input ("targeting drug trafficking aircraft"). This is a typical problem suffered by many neural graph-tosequence models. Our multi-view framework helps recover the correct meaning: "policy of target for drug trafficking aircraft".</p>
<h3>5.7 Ablation Study</h3>
<p>As shown in Table 4, we conduct an ablation study on LDC2015E86 to analyze how important each part of the input graphs is under our framework. For Loss 1, we test the situation when no edge labels are available, and as a result, we observe a large performance drop of $1.0+$ BLEU points. This is quite intuitive, because edge labels carry important relational knowledge between the two connected nodes. Therefore, discarding these labels will cause loss of significant semantic information.</p>
<p>For Loss 2, we also observe a large performance decrease when edge labels are dropped, confirming the observation for Loss 1. In addition, we study the effect of random graph linearization, where the order for picking children is random rather than following the left-to-right order at each stage of the depth-first traversal procedure. The motivation is to investigate the robustness of Loss 2 regarding input variances, as an organized input order (such as an alphabetical order for children) may not be available for certain graph-to-sequence tasks. We observe a marginal performance drop of less than 0.1 BLEU points, indicating that our approach is very robust for input variances. It is likely because different linearization results still indicate the same graph. Besides, one previous study (Konstas et al., 2017) shows a very similar observation.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: center;">BLEU</th>
<th style="text-align: center;">Meteor</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">DCGCN</td>
<td style="text-align: center;">27.60</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">RA-Trans-CNN</td>
<td style="text-align: center;">31.82</td>
<td style="text-align: center;">36.38</td>
</tr>
<tr>
<td style="text-align: left;">RA-Trans-F-ours</td>
<td style="text-align: center;">31.77</td>
<td style="text-align: center;">37.2</td>
</tr>
<tr>
<td style="text-align: left;">+ Loss 1</td>
<td style="text-align: center;">33.98</td>
<td style="text-align: center;">37.5</td>
</tr>
<tr>
<td style="text-align: left;">+ Loss 2</td>
<td style="text-align: center;">34.13</td>
<td style="text-align: center;">37.8</td>
</tr>
<tr>
<td style="text-align: left;">+ Both</td>
<td style="text-align: center;">34.21</td>
<td style="text-align: center;">38.0</td>
</tr>
</tbody>
</table>
<p>Table 5: Main test results on LDC2017T10.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: left;">BLEU</th>
<th style="text-align: left;">Meteor</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">ADAPT</td>
<td style="text-align: left;">60.59</td>
<td style="text-align: left;">44.0</td>
</tr>
<tr>
<td style="text-align: left;">GCN $_{E C}$</td>
<td style="text-align: left;">55.90</td>
<td style="text-align: left;">39.0</td>
</tr>
<tr>
<td style="text-align: left;">RA-Trans-F-ours</td>
<td style="text-align: left;">60.51</td>
<td style="text-align: left;">42.2</td>
</tr>
<tr>
<td style="text-align: left;">+ Loss 1</td>
<td style="text-align: left;">61.78</td>
<td style="text-align: left;">43.6</td>
</tr>
<tr>
<td style="text-align: left;">+ Loss 2</td>
<td style="text-align: left;">62.29</td>
<td style="text-align: left;">43.5</td>
</tr>
<tr>
<td style="text-align: left;">+ Both</td>
<td style="text-align: left;">$\mathbf{6 2 . 8 9}$</td>
<td style="text-align: left;">44.2</td>
</tr>
</tbody>
</table>
<p>Table 6: Main test results on WebNLG</p>
<h3>5.8 Main Results on LDC2017T10</h3>
<p>Table 5 compares our results on LDC2017T10 with the highest numbers reported by single models without extra silver training data. RA-Trans-CNN is another model by Zhu et al. (2019) that adopt a convolutional neural network (LeCun et al., 1990) to model the relation path for each node pair. Again, the $R A$-Trans- $F$ baseline achieves a comparable score with $R A$-Trans-CNN, and our approach improves the baseline by nearly 2.5 BLEU points, indicating its superiority.</p>
<p>Regarding Meteor score, our advantage (1.62 points) over the previous state-of-the-art system on this dataset is larger than that ( 0.75 points) on LDC2015E86. Since LDC2017T10 has almost one time more training instances than LDC2015E86, we may conclude that the problem of dropping input information may not be effectively reduced by simply adding more supervised data, and as a result, our approach can still be effective on a larger dataset. This conclusion can also be confirmed by comparing the gains of our approach on both AMR datasets regarding BLEU score ( 2.3 vs 2.5 ).</p>
<h3>5.9 Main Results on WebNLG</h3>
<p>Table 6 shows the comparison of our results with previous results on the WebNLG testset. ADAPT (Gardent et al., 2017) is based on the standard encoder-decoder architecture (Cho et al., 2014)
with byte pair encoding (Sennrich et al., 2016), and it was the best system of the challenge. $\mathrm{GCN}_{E C}$ (Marcheggiani and Perez-Beltrachini, 2018) is a recent model using a graph convolution network (Kipf and Welling, 2017) for encoding KGs.</p>
<p>Our baseline shows a comparable performance with the previous state of the art. Based on this baseline, applying either loss leads to a significant improvement, and their combination brings a gain of more than 2 BLEU points. Although the baseline already achieves a very high BLEU score, yet the gains on this task are still comparable with those on AMR-to-text generation. This observation may imply that the problem of missing input structural knowledge can be ubiquitous among many graph-to-text problems, and as a result, our approach can be widely helpful across many tasks.</p>
<p>Following previous work, we also report Meteor scores, where our approach shows a gain of 2 points against the baseline and our final number is comparable with ADAPT. Similar with the gains on the BLEU metric, Loss 1 is comparable with Loss 2 regarding Meteor, and their combination is more useful than applying each own.</p>
<h2>6 Conclusion</h2>
<p>We proposed reconstructing input graphs as autoencoding processes to encourage preserving the input semantic information for graph-to-text generation. In particular, the auxiliary losses for recovering two complementary views (triple relations and linearized graph) of input graphs are introduced, so that our model is trained to retain input structures for better generation. Our training framework is general for different graph types. Experiments on two benchmarks showed the effectiveness of our framework under both the automatic BLEU metric and human judgements.</p>
<h2>Acknowledge</h2>
<p>Both Te An and Jinsong Su were supported by the National Key R\&amp;D Program of China (No. 2019QY1803), National Natural Science Foundation of China (No. 61672440), and the Scientific Research Project of National Language Committee of China (No. YB135-49). Yue Zhang was supported by the joint research program between BriteDreams robotics and Westlake University. We thank the anonymous reviewers for their constructive suggestions.</p>
<h2>References</h2>
<p>Roee Aharoni and Yoav Goldberg. 2017. Towards string-to-tree neural machine translation. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 2: Short Papers).</p>
<p>Anusha Balakrishnan, Jinfeng Rao, Kartikeya Upasani, Michael White, and Rajen Subba. 2019. Constrained decoding for neural NLG from compositional representations in task-oriented dialogue. In Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics.</p>
<p>Laura Banarescu, Claire Bonial, Shu Cai, Madalina Georgescu, Kira Griffitt, Ulf Hermjakob, Kevin Knight, Philipp Koehn, Martha Palmer, and Nathan Schneider. 2013. Abstract meaning representation for sembanking. In Proceedings of the 7th Linguistic Annotation Workshop and Interoperability with Discourse.</p>
<p>Daniel Beck, Gholamreza Haffari, and Trevor Cohn. 2018. Graph-to-sequence learning using gated graph neural networks. In Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers).</p>
<p>Deng Cai and Wai Lam. 2019. Graph transformer for graph-to-sequence learning. In Thirty-Fourth AAAI Conference on Artificial Intelligence.</p>
<p>Kris Cao and Stephen Clark. 2019. Factorising amr generation through syntax. In Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long and Short Papers).</p>
<p>Kyunghyun Cho, Bart van Merrienboer, Caglar Gulcehre, Dzmitry Bahdanau, Fethi Bougares, Holger Schwenk, and Yoshua Bengio. 2014. Learning phrase representations using rnn encoder-decoder for statistical machine translation. In Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP).</p>
<p>Marco Damonte and Shay B Cohen. 2019. Structural neural encoders for amr-to-text generation. In Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long and Short Papers).</p>
<p>Michael Denkowski and Alon Lavie. 2014. Meteor universal: Language specific translation evaluation for any target language. In Proceedings of the EACL 2014 Workshop on Statistical Machine Translation.</p>
<p>Timothy Dozat and Christopher D Manning. 2017. Deep biaffine attention for neural dependency parsing. In International Conference on Learning Representations.</p>
<p>Ondřej Dušek, David M Howcroft, and Verena Rieser. 2019. Semantic noise matters for neural natural language generation. In Proceedings of the 12th International Conference on Natural Language Generation.</p>
<p>Ondřej Dušek, Jekaterina Novikova, and Verena Rieser. 2018. Findings of the e2e nlg challenge. In Proceedings of the 11th International Conference on Natural Language Generation.</p>
<p>Jeffrey Flanigan, Chris Dyer, Noah A Smith, and Jaime Carbonell. 2016. Cmu at semeval-2016 task 8: Graph-based amr parsing with infinite ramp loss. In Proceedings of the 10th International Workshop on Semantic Evaluation (SemEval-2016).</p>
<p>Claire Gardent, Anastasia Shimorina, Shashi Narayan, and Laura Perez-Beltrachini. 2017. The webnlg challenge: Generating text from rdf data. In Proceedings of the 10th International Conference on Natural Language Generation.</p>
<p>Zhijiang Guo, Yan Zhang, Zhiyang Teng, and Wei Lu. 2019. Densely connected graph convolutional networks for graph-to-sequence learning. Transactions of the Association for Computational Linguistics, 7.</p>
<p>Valerie Hajdik, Jan Buys, Michael Wayne Goodman, and Emily M Bender. 2019. Neural text generation from rich semantic representations. In Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long and Short Papers).</p>
<p>Sepp Hochreiter and Jürgen Schmidhuber. 1997. Long short-term memory. Neural computation, 9(8).</p>
<p>Xudong Hong, Ernie Chang, and Vera Demberg. 2019. Improving language generation from feature-rich tree-structured data with relational graph convolutional encoders. In Proceedings of the 2nd Workshop on Multilingual Surface Realisation (MSR 2019), pages $75-80$.</p>
<p>Srinivasan Iyer, Ioannis Konstas, Alvin Cheung, Jayant Krishnamurthy, and Luke Zettlemoyer. 2017. Learning a neural semantic parser from user feedback. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 963-973.</p>
<p>Chen Jia, Xiaobo Liang, and Yue Zhang. 2019. Crossdomain ner using cross-domain language modeling. In Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics.</p>
<p>Diederik P Kingma and Jimmy Ba. 2014. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980.</p>
<p>Thomas N Kipf and Max Welling. 2017. Semisupervised classification with graph convolutional networks. In International Conference on Learning Representations.</p>
<p>Rik Koncel-Kedziorski, Dhanush Bekal, Yi Luan, Mirella Lapata, and Hannaneh Hajishirzi. 2019. Text generation from knowledge graphs with graph transformers. In Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long and Short Papers).</p>
<p>Ioannis Konstas, Srinivasan Iyer, Mark Yatskar, Yejin Choi, and Luke Zettlemoyer. 2017. Neural amr: Sequence-to-sequence models for parsing and generation. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers).</p>
<p>Yann LeCun, Bernhard E Boser, John S Denker, Donnie Henderson, Richard E Howard, Wayne E Hubbard, and Lawrence D Jackel. 1990. Handwritten digit recognition with a back-propagation network. In Advances in neural information processing systems, pages 396-404.</p>
<p>Yujia Li, Daniel Tarlow, Marc Brockschmidt, and Richard Zemel. 2016. Gated graph sequence neural networks. In International Conference on Learning Representations.</p>
<p>Liyuan Liu, Jingbo Shang, Xiang Ren, Fangzheng Xu, Huan Gui, Jian Peng, and Jiawei Han. 2018a. Empower sequence labeling with task-aware neural language model. In Thirty-Second AAAI Conference on Artificial Intelligence.</p>
<p>Lizhen Liu, Xiao Hu, Wei Song, Ruiji Fu, Ting Liu, and Guoping Hu. 2018b. Neural multitask learning for simile recognition. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing.</p>
<p>Yijia Liu, Wanxiang Che, Bo Zheng, Bing Qin, and Ting Liu. 2018c. An amr aligner tuned by transitionbased parser. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing.</p>
<p>Diego Marcheggiani and Laura Perez-Beltrachini. 2018. Deep graph convolutional encoders for structured data to text generation. In Proceedings of the 11th International Conference on Natural Language Generation.</p>
<p>Joakim Nivre. 2003. An efficient algorithm for projective dependency parsing. In Proceedings of the Eighth International Conference on Parsing Technologies.</p>
<p>Kishore Papineni, Salim Roukos, Todd Ward, and WeiJing Zhu. 2002. Bleu: a method for automatic evaluation of machine translation. In Proceedings of the 40th annual meeting on association for computational linguistics.</p>
<p>Nima Pourdamghani, Yang Gao, Ulf Hermjakob, and Kevin Knight. 2014. Aligning english strings with
abstract meaning representation graphs. In Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP).</p>
<p>Marek Rei. 2017. Semi-supervised multitask learning for sequence labeling. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers).</p>
<p>Marek Rei and Anders Søgaard. 2019. Jointly learning to label sentences and tokens. In Proceedings of the AAAI Conference on Artificial Intelligence.</p>
<p>Leonardo FR Ribeiro, Claire Gardent, and Iryna Gurevych. 2019. Enhancing amr-to-text generation with dual graph representations. In Proceedings of EMNLP-IJCNLP.</p>
<p>Rico Sennrich, Barry Haddow, and Alexandra Birch. 2016. Neural machine translation of rare words with subword units. In Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers).</p>
<p>Linfeng Song, Daniel Gildea, Yue Zhang, Zhiguo Wang, and Jinsong Su. 2019. Semantic neural machine translation using amr. Transactions of the Association for Computational Linguistics, 7:19-31.</p>
<p>Linfeng Song, Yue Zhang, Zhiguo Wang, and Daniel Gildea. 2018. A graph-to-sequence model for amr-to-text generation. In Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers).</p>
<p>Jinsong Su, Zhixing Tan, Deyi Xiong, Rongrong Ji, Xiaodong Shi, and Yang Liu. 2017. Lattice-based recurrent neural network encoders for neural machine translation. In Thirty-First AAAI Conference on Artificial Intelligence.</p>
<p>Ida Szubert, Adam Lopez, and Nathan Schneider. 2018. A structured syntax-semantics interface for englishamr alignment. In Proceedings of the 2018 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long Papers).</p>
<p>Bayu Distiawan Trisedya, Jianzhong Qi, Rui Zhang, and Wei Wang. 2018. Gtr-lstm: A triple encoder for sentence generation from rdf data. In Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), volume 1 .</p>
<p>Zhaopeng Tu, Yang Liu, Lifeng Shang, Xiaohua Liu, and Hang Li. 2017. Neural machine translation with reconstruction. In Thirty-First AAAI Conference on Artificial Intelligence.</p>
<p>Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Łukasz Kaiser, and Illia Polosukhin. 2017. Attention is all you need. In Advances in neural information processing systems.</p>
<p>Petar Veličković, Guillem Cucurull, Arantxa Casanova, Adriana Romero, Pietro Lio, and Yoshua Bengio. 2018. Graph attention networks. In International Conference on Learning Representations.</p>
<p>Chuan Wang and Nianwen Xue. 2017. Getting the most out of amr parsing. In Proceedings of the 2017 conference on empirical methods in natural language processing.</p>
<p>Tianming Wang, Xiaojun Wan, and Hanqi Jin. 2020. Amr-to-text generation with graph transformer. Transactions of the Association for Computational Linguistics, 8:19-33.</p>
<p>Xinyi Wang, Hieu Pham, Pengcheng Yin, and Graham Neubig. 2018. A tree-based decoder for neural machine translation. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing.</p>
<p>Sam Wiseman, Stuart M Shieber, and Alexander M Rush. 2017. Challenges in data-to-document generation. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, pages 2253-2263.</p>
<p>Shuangzhi Wu, Dongdong Zhang, Nan Yang, Mu Li, and Ming Zhou. 2017. Sequence-to-dependency neural machine translation. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers).</p>
<p>Kun Xu, Lingfei Wu, Zhiguo Wang, Yansong Feng, and Vadim Sheinin. 2018. Sql-to-text generation with graph-to-sequence model. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 931-936.</p>
<p>Jie Zhu, Junhui Li, Muhua Zhu, Longhua Qian, Min Zhang, and Guodong Zhou. 2019. Modeling graph structure in transformer for better amr-to-text generation. In Proceedings of EMNLP-IJCNLP.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{2}$ http://www.statmt.org/moses/
${ }^{3}$ https://amr.isi.edu/download.html
${ }^{4}$ https://nlp.stanford.edu/software/tokenizer.shtml
${ }^{5}$ https://wiki.dbpedia.org/&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>