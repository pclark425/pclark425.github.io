<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-1608 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-1608</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-1608</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-31.html">extraction-schema-31</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <p><strong>Paper ID:</strong> paper-253735179</p>
                <p><strong>Paper Title:</strong> <a href="https://export.arxiv.org/pdf/2211.10873v2.pdf" target="_blank">Interpretable Scientific Discovery with Symbolic Regression: A Review</a></p>
                <p><strong>Paper Abstract:</strong> Symbolic regression is emerging as a promising machine learning method for learning succinct underlying interpretable mathematical expressions directly from data. Whereas it has been traditionally tackled with genetic programming, it has recently gained a growing interest in deep learning as a data-driven model discovery method, achieving significant advances in various application domains ranging from fundamental to applied sciences. This survey presents a structured and comprehensive overview of symbolic regression methods and discusses their strengths and limitations.</p>
                <p><strong>Cost:</strong> 0.016</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e1608.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e1608.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>GP</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Genetic Programming</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An evolutionary algorithm that searches the space of computer programs or expression trees by maintaining a population of candidate programs and applying biologically inspired operators (crossover, mutation, selection) to evolve better solutions over generations.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Genetic Programming (tree-based)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Represents mathematical expressions or programs as unary/binary trees (internal nodes = operators, leaves = variables/constants); maintains a population of such trees and iteratively applies selection based on fitness, subtree crossover (recombination), subtree mutation (replacement), and elitist selection to produce new populations until termination criteria are met. A typical GP SR loop: initialize random population of trees T(0); for each generation k apply transition rules r_i (mutation, crossover) to F^k to produce F^{k+1}; evaluate loss/fitness; select elites for next generation.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs / expression trees</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Standard subtree crossover: select a subtree in parent A and a subtree in parent B and swap them to create two offspring; selection of crossover points may be uniform or biased by tree size/depth. (Described generically in the paper and illustrated in Fig.10 as subtree exchange.)</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Subtree mutation: select a node (subtree) in an individual and replace it with a newly generated random subtree (from the grammar/library), possibly constrained by depth/size limits; mutation probability applied per-individual or per-node each generation.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Symbolic regression / program-expression discovery (scientific equation discovery)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Compared conceptually in the survey against linear SR, neural-network SR (EQL), transformer-based SR, RL-based (DSR), and hybrid methods; used as baseline in many SR benchmarks (e.g., Eureqa, Koza-style GP).</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>GPs explicitly use crossover and mutation on expression trees to explore large, diverse solution spaces; they can produce large variations useful for out-of-distribution generalization but suffer from scalability issues to high-dimensional data and are highly sensitive to hyperparameters; the paper notes GP remains a dominant method for SR on synthetic benchmarks but lacks explicit measured novelty/diversity/executability metrics in this survey.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Interpretable Scientific Discovery with Symbolic Regression: A Review', 'publication_date_yy_mm': '2022-11'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1608.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e1608.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>NGPPS</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Neural-guided Genetic Programming Population Seeding</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A hybrid method that uses a learned generative model (RNN) to sample candidate expressions which are used to seed a genetic programming population, combining neural sampling with GP evolution to speed discovery and improve sample efficiency.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Neural-guided GP population seeding (NGPPS)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>The RNN (or other generative model) is trained/updated to produce high-quality expression skeletons; batches of expressions sampled by the RNN are used as the initial (or periodic) population seeds for a GP run. GP is then executed for S generations (using standard GP operators including subtree crossover and subtree mutation). An elite set of top-performing GP individuals is returned and used to update the RNN (closing the loop), enabling learning-from-experience across problem instances and faster convergence than random-seeded GP.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs / expression trees (symbolic expressions)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Uses standard GP subtree crossover within the GP component: two parent expression trees exchange selected subtrees to form offspring. The paper's description of NGPPS indicates GP generations operate with usual crossover but does not give additional novel crossover mechanics beyond subtree exchange.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Uses standard GP subtree mutation within the GP component: replace a selected subtree by a newly generated random subtree; mutation probability applied per-individual as in GP implementations. The survey references the mutation operation generally (Fig.10) but provides no implementation hyperparameters.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Symbolic regression benchmarks (AI-Feynman, Nguyen, Livermore, SOOSE), scientific equation discovery</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Compared against pure GP baselines, DSR (deep/RL-based), and other SR methods; survey reports claims that neural-guided seeding outperforms selected baselines in time and accuracy.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Seeding GP populations with RNN-generated expressions dramatically speeds convergence and improves time-to-solution relative to random-seeded GP; the hybrid retains GP's genetic operators (crossover/mutation) for local search/exploration while leveraging learned priors from the RNN, but the survey does not report explicit novelty/diversity/executability metrics (only qualitative/time/accuracy improvements).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Interpretable Scientific Discovery with Symbolic Regression: A Review', 'publication_date_yy_mm': '2022-11'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1608.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e1608.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Eureqa</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Eureqa (commercial GP-based symbolic regression software)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A widely used commercial symbolic regression package based on genetic programming that automatically searches for compact mathematical formulas fitting data using evolutionary operators and heuristics.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Eureqa (GP-based SR)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Implements GP-style evolutionary search over equation trees (operators/operands drawn from a user-specified library), using population-based search with crossover, mutation, selection, and domain-specific heuristics to propose compact, high-fitness formulas; commonly used as a baseline in SR research and applications.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs / expression trees / mathematical formulas</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Implements subtree crossover between parent equations to exchange sub-expressions and create offspring formulas (standard GP recombination).</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Implements subtree mutation and point mutations (e.g., changing an operator or constant) to introduce random variations in expressions.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Symbolic regression, scientific model discovery (widely used on synthetic benchmarks and applied problems)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Used as a baseline in many SR method comparisons (GP baselines) and compared against physics-inspired methods (AI-Feynman), neural SR, transformers, etc.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Eureqa popularized GP-based SR for scientific discovery and demonstrates practical GP application to real/synthetic data; survey notes GP-based tools like Eureqa achieve high prediction accuracy but are sensitive to hyperparameters and scale poorly to high-dimensional inputs; the paper does not provide measured novelty/diversity/executability statistics for Eureqa.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Interpretable Scientific Discovery with Symbolic Regression: A Review', 'publication_date_yy_mm': '2022-11'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1608.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e1608.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>MRGP / ITEA / FFX (GP-family)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Multiple-Regression Genetic Programming (MRGP), Interaction-Transformation Evolutionary Algorithm (ITEA), Fast Function Extraction (FFX) — representative GP/heuristic evolutionary SR methods</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Representative GP and evolution-inspired symbolic regression methods and toolkits (MRGP, ITEA, FFX) that apply population-based search, regression-guided variation, or deterministic evolutionary heuristics to discover symbolic models from data.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Representative GP / evolutionary SR toolkits (MRGP, ITEA, FFX, HeuristicLab)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Collection of GP-derived or evolution-inspired SR algorithms: MRGP couples GP tree evolution with local regression in nodes, ITEA applies interaction-transformation evolutionary rules to generate expressions, FFX is a deterministic (but related) fast symbolic regression technique; commonalities include population/search over symbolic structures and use of variation operators (in GP variants) such as crossover and mutation to explore model structures.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs / expression trees / symbolic formula representations</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>For GP-based variants (e.g., MRGP, ITEA when GP-like): subtree crossover exchanging subtrees between parents. For deterministic variants (FFX) no stochastic crossover is used (deterministic search instead).</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>For GP-based variants: subtree replacement or operator/terminal perturbations; for non-GP deterministic methods, mutation may be absent or replaced by deterministic transformations.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Symbolic regression benchmarks, SR library/tool comparisons</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Compared among GP family methods and against DL-based SR (EQL, transformers, RL), physics-inspired solvers (AI-Feynman), and hybrid methods.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>These GP-family methods exemplify different trade-offs: some (MRGP, ITEA) keep stochastic crossover/mutation facilitating exploration and diversity, whereas methods like FFX trade stochasticity for determinism and scalability; the survey highlights that GP-based evolutionary operators produce high-variation solution spaces but that explicit metrics of novelty/diversity/executability are generally not reported in the surveyed literature.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Interpretable Scientific Discovery with Symbolic Regression: A Review', 'publication_date_yy_mm': '2022-11'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Genetic programming as a means for programming computers by natural selection <em>(Rating: 2)</em></li>
                <li>Genetic programming: A paradigm for genetically breeding populations of computer programs to solve problems <em>(Rating: 2)</em></li>
                <li>Distilling free-form natural laws from experimental data <em>(Rating: 2)</em></li>
                <li>Deep symbolic regression: Recovering mathematical expressions from data via policy gradients <em>(Rating: 1)</em></li>
                <li>Symbolic regression via Neural-Guided GP population seeding <em>(Rating: 2)</em></li>
                <li>Eureqa: software review <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-1608",
    "paper_id": "paper-253735179",
    "extraction_schema_id": "extraction-schema-31",
    "extracted_data": [
        {
            "name_short": "GP",
            "name_full": "Genetic Programming",
            "brief_description": "An evolutionary algorithm that searches the space of computer programs or expression trees by maintaining a population of candidate programs and applying biologically inspired operators (crossover, mutation, selection) to evolve better solutions over generations.",
            "citation_title": "",
            "mention_or_use": "mention",
            "system_name": "Genetic Programming (tree-based)",
            "system_description": "Represents mathematical expressions or programs as unary/binary trees (internal nodes = operators, leaves = variables/constants); maintains a population of such trees and iteratively applies selection based on fitness, subtree crossover (recombination), subtree mutation (replacement), and elitist selection to produce new populations until termination criteria are met. A typical GP SR loop: initialize random population of trees T(0); for each generation k apply transition rules r_i (mutation, crossover) to F^k to produce F^{k+1}; evaluate loss/fitness; select elites for next generation.",
            "input_type": "programs / expression trees",
            "crossover_operation": "Standard subtree crossover: select a subtree in parent A and a subtree in parent B and swap them to create two offspring; selection of crossover points may be uniform or biased by tree size/depth. (Described generically in the paper and illustrated in Fig.10 as subtree exchange.)",
            "mutation_operation": "Subtree mutation: select a node (subtree) in an individual and replace it with a newly generated random subtree (from the grammar/library), possibly constrained by depth/size limits; mutation probability applied per-individual or per-node each generation.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Symbolic regression / program-expression discovery (scientific equation discovery)",
            "comparison_baseline": "Compared conceptually in the survey against linear SR, neural-network SR (EQL), transformer-based SR, RL-based (DSR), and hybrid methods; used as baseline in many SR benchmarks (e.g., Eureqa, Koza-style GP).",
            "key_findings": "GPs explicitly use crossover and mutation on expression trees to explore large, diverse solution spaces; they can produce large variations useful for out-of-distribution generalization but suffer from scalability issues to high-dimensional data and are highly sensitive to hyperparameters; the paper notes GP remains a dominant method for SR on synthetic benchmarks but lacks explicit measured novelty/diversity/executability metrics in this survey.",
            "uuid": "e1608.0",
            "source_info": {
                "paper_title": "Interpretable Scientific Discovery with Symbolic Regression: A Review",
                "publication_date_yy_mm": "2022-11"
            }
        },
        {
            "name_short": "NGPPS",
            "name_full": "Neural-guided Genetic Programming Population Seeding",
            "brief_description": "A hybrid method that uses a learned generative model (RNN) to sample candidate expressions which are used to seed a genetic programming population, combining neural sampling with GP evolution to speed discovery and improve sample efficiency.",
            "citation_title": "",
            "mention_or_use": "mention",
            "system_name": "Neural-guided GP population seeding (NGPPS)",
            "system_description": "The RNN (or other generative model) is trained/updated to produce high-quality expression skeletons; batches of expressions sampled by the RNN are used as the initial (or periodic) population seeds for a GP run. GP is then executed for S generations (using standard GP operators including subtree crossover and subtree mutation). An elite set of top-performing GP individuals is returned and used to update the RNN (closing the loop), enabling learning-from-experience across problem instances and faster convergence than random-seeded GP.",
            "input_type": "programs / expression trees (symbolic expressions)",
            "crossover_operation": "Uses standard GP subtree crossover within the GP component: two parent expression trees exchange selected subtrees to form offspring. The paper's description of NGPPS indicates GP generations operate with usual crossover but does not give additional novel crossover mechanics beyond subtree exchange.",
            "mutation_operation": "Uses standard GP subtree mutation within the GP component: replace a selected subtree by a newly generated random subtree; mutation probability applied per-individual as in GP implementations. The survey references the mutation operation generally (Fig.10) but provides no implementation hyperparameters.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Symbolic regression benchmarks (AI-Feynman, Nguyen, Livermore, SOOSE), scientific equation discovery",
            "comparison_baseline": "Compared against pure GP baselines, DSR (deep/RL-based), and other SR methods; survey reports claims that neural-guided seeding outperforms selected baselines in time and accuracy.",
            "key_findings": "Seeding GP populations with RNN-generated expressions dramatically speeds convergence and improves time-to-solution relative to random-seeded GP; the hybrid retains GP's genetic operators (crossover/mutation) for local search/exploration while leveraging learned priors from the RNN, but the survey does not report explicit novelty/diversity/executability metrics (only qualitative/time/accuracy improvements).",
            "uuid": "e1608.1",
            "source_info": {
                "paper_title": "Interpretable Scientific Discovery with Symbolic Regression: A Review",
                "publication_date_yy_mm": "2022-11"
            }
        },
        {
            "name_short": "Eureqa",
            "name_full": "Eureqa (commercial GP-based symbolic regression software)",
            "brief_description": "A widely used commercial symbolic regression package based on genetic programming that automatically searches for compact mathematical formulas fitting data using evolutionary operators and heuristics.",
            "citation_title": "",
            "mention_or_use": "mention",
            "system_name": "Eureqa (GP-based SR)",
            "system_description": "Implements GP-style evolutionary search over equation trees (operators/operands drawn from a user-specified library), using population-based search with crossover, mutation, selection, and domain-specific heuristics to propose compact, high-fitness formulas; commonly used as a baseline in SR research and applications.",
            "input_type": "programs / expression trees / mathematical formulas",
            "crossover_operation": "Implements subtree crossover between parent equations to exchange sub-expressions and create offspring formulas (standard GP recombination).",
            "mutation_operation": "Implements subtree mutation and point mutations (e.g., changing an operator or constant) to introduce random variations in expressions.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Symbolic regression, scientific model discovery (widely used on synthetic benchmarks and applied problems)",
            "comparison_baseline": "Used as a baseline in many SR method comparisons (GP baselines) and compared against physics-inspired methods (AI-Feynman), neural SR, transformers, etc.",
            "key_findings": "Eureqa popularized GP-based SR for scientific discovery and demonstrates practical GP application to real/synthetic data; survey notes GP-based tools like Eureqa achieve high prediction accuracy but are sensitive to hyperparameters and scale poorly to high-dimensional inputs; the paper does not provide measured novelty/diversity/executability statistics for Eureqa.",
            "uuid": "e1608.2",
            "source_info": {
                "paper_title": "Interpretable Scientific Discovery with Symbolic Regression: A Review",
                "publication_date_yy_mm": "2022-11"
            }
        },
        {
            "name_short": "MRGP / ITEA / FFX (GP-family)",
            "name_full": "Multiple-Regression Genetic Programming (MRGP), Interaction-Transformation Evolutionary Algorithm (ITEA), Fast Function Extraction (FFX) — representative GP/heuristic evolutionary SR methods",
            "brief_description": "Representative GP and evolution-inspired symbolic regression methods and toolkits (MRGP, ITEA, FFX) that apply population-based search, regression-guided variation, or deterministic evolutionary heuristics to discover symbolic models from data.",
            "citation_title": "",
            "mention_or_use": "mention",
            "system_name": "Representative GP / evolutionary SR toolkits (MRGP, ITEA, FFX, HeuristicLab)",
            "system_description": "Collection of GP-derived or evolution-inspired SR algorithms: MRGP couples GP tree evolution with local regression in nodes, ITEA applies interaction-transformation evolutionary rules to generate expressions, FFX is a deterministic (but related) fast symbolic regression technique; commonalities include population/search over symbolic structures and use of variation operators (in GP variants) such as crossover and mutation to explore model structures.",
            "input_type": "programs / expression trees / symbolic formula representations",
            "crossover_operation": "For GP-based variants (e.g., MRGP, ITEA when GP-like): subtree crossover exchanging subtrees between parents. For deterministic variants (FFX) no stochastic crossover is used (deterministic search instead).",
            "mutation_operation": "For GP-based variants: subtree replacement or operator/terminal perturbations; for non-GP deterministic methods, mutation may be absent or replaced by deterministic transformations.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Symbolic regression benchmarks, SR library/tool comparisons",
            "comparison_baseline": "Compared among GP family methods and against DL-based SR (EQL, transformers, RL), physics-inspired solvers (AI-Feynman), and hybrid methods.",
            "key_findings": "These GP-family methods exemplify different trade-offs: some (MRGP, ITEA) keep stochastic crossover/mutation facilitating exploration and diversity, whereas methods like FFX trade stochasticity for determinism and scalability; the survey highlights that GP-based evolutionary operators produce high-variation solution spaces but that explicit metrics of novelty/diversity/executability are generally not reported in the surveyed literature.",
            "uuid": "e1608.3",
            "source_info": {
                "paper_title": "Interpretable Scientific Discovery with Symbolic Regression: A Review",
                "publication_date_yy_mm": "2022-11"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Genetic programming as a means for programming computers by natural selection",
            "rating": 2,
            "sanitized_title": "genetic_programming_as_a_means_for_programming_computers_by_natural_selection"
        },
        {
            "paper_title": "Genetic programming: A paradigm for genetically breeding populations of computer programs to solve problems",
            "rating": 2,
            "sanitized_title": "genetic_programming_a_paradigm_for_genetically_breeding_populations_of_computer_programs_to_solve_problems"
        },
        {
            "paper_title": "Distilling free-form natural laws from experimental data",
            "rating": 2,
            "sanitized_title": "distilling_freeform_natural_laws_from_experimental_data"
        },
        {
            "paper_title": "Deep symbolic regression: Recovering mathematical expressions from data via policy gradients",
            "rating": 1,
            "sanitized_title": "deep_symbolic_regression_recovering_mathematical_expressions_from_data_via_policy_gradients"
        },
        {
            "paper_title": "Symbolic regression via Neural-Guided GP population seeding",
            "rating": 2,
            "sanitized_title": "symbolic_regression_via_neuralguided_gp_population_seeding"
        },
        {
            "paper_title": "Eureqa: software review",
            "rating": 1,
            "sanitized_title": "eureqa_software_review"
        }
    ],
    "cost": 0.016264,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>Interpretable Scientific Discovery with Symbolic Regression: A Review
2 May 2023</p>
<p>Nour Makke 
Qatar Computing Research Institute
HBKU
Doha</p>
<p>Sanjay Chawla 
Qatar Computing Research Institute
HBKU
Doha</p>
<p>Interpretable Scientific Discovery with Symbolic Regression: A Review
2 May 20230E01D583EBB74B548684852FB0A77144arXiv:2211.10873v2[cs.LG]
Symbolic regression is emerging as a promising machine learning method for learning succinct underlying interpretable mathematical expressions directly from data.Whereas it has been traditionally tackled with genetic programming, it has recently gained a growing interest in deep learning as a data-driven model discovery method, achieving significant advances in various application domains ranging from fundamental to applied sciences.In this survey, we present a structured and comprehensive overview of symbolic regression methods and discuss their strengths and limitations.</p>
<p>Introduction</p>
<p>Symbolic Regression (SR) is a rapidly growing subfield within machine learning (ML) to infer symbolic mathematical expressions from data [1,2].Interest in SR is being driven by the observation that it is not sufficient to only have accurate predictive models; however, it is often necessary that the learned models be interpretable [3].A model is interpretable if the relationship between the input and output of the model can be logically or mathematically traced in a succinct manner.In other words, learnable models are interpretable if expressed as mathematical equations.As "disciplines" become increasingly data-rich and adopt ML techniques, the demand for interpretable models is likely to grow.For example, in the natural sciences (e.g., physics), mathematical models derived from first principles make it possible to reason about the underlying phenomenon in a way that is not possible with predictive models like deep neural networks.In critical disciplines like healthcare, non-interpretable models may never be allowed to be deployed -however accurate they maybe [4].</p>
<p>Example: Consider a data set consisting of samples (q 1 , q 2 , r, F ), where q 1 and q 2 are the charges of two particles, r is the distance between them and F is the measured force between the particles.Assume q 1 , q 2 , and r are the input variables, and F is the output variable.Suppose we model the input-output relationship as F = θ 0 + θ 1 q 1 + θ 2 q 2 + θ 3 r.Then, using the data set, we can infer the model's parameters (θ i ).The model will be interpretable because we will know the impact of each variable on the output.For example, if θ 3 is negative, then that implies that as r increases, the force F will decrease.From physics, we know that this form of the model is unlikely to be accurate.On the other hand, we could model the relationship using a neural network F = N N (q 1 , q 2 , r, θ).We expect the model to be highly accurate and predictive because neural networks (NNs) are universal function approximators.However, the model is uninterpretable because the input-output relationship is not easily apparent.The input feature vector subsequently undergoes several layers of nonlinear transformations, i.e., y = σ
( i W i σ( j W j σ( k W k σ(• • • W x))))
, where σ is a nonlinear activation function, and W idx are the learnable parameters of NN layer of index idx.Such models, called "blackbox", do not have an internal logic to let users understand how inputs are mathematically mapped to outputs.Explainability is the application of other methods to explain model predictions and to understand how it is learned.It refers to why the model makes the decision that way.What distinguishes explainability from interpretability is that interpretable models are transparent [3].For example, the linear regression model predictions can be interpreted by evaluating the relative contribution of individual features to the predictions using their weights.An ideal SR model will return the relationship as k q1q2 r 2 , which is the definition of the Coulomb force between two charged particles with a constant1 k = 8.98 × 10 9 .However, learning the SR model is highly non-trivial as it involves searching over a large space of mathematical operations and identifying the right constant (k) that will fit the data.SR models can be directly inferred from data or can be used to "whitebox" a "blackbox" model such as a neural network.</p>
<p>The ultimate goal of SR is to bridge data and observations following the Keplerian trial and error approach [5].Kepler developed a data-driven model for planetary motion using the most accurate astronomical measurements of the era, which resulted in elliptic orbits described by a power law.In contrast, Newton developed a dynamic relationship between physical variables that described the underlying process at the origin of these elliptic orbits.Newton's approach [6] led to three laws of motion later verified by experimental observations.Whereas both methods fit the data well, Newton's approach could be generalized to predict behavior in regimes where no data were available.Although SR is regarded as a data-driven model discovery tool, it aims to find a symbolic model that simultaneously fits data well and could be generalized to uncovered regimes.SR is deployed as an interpretable and predictive ML model or a data-driven scientific discovery method.SR was investigated as early as 1970 in research works [7,8,9] aiming to rediscover empirical laws.Such works iteratively apply a set of data-driven heuristics to formulate mathematical expressions.The first AI system meant to automate scientific discovery is called BACON [10,11].It was developed by Patrick Langley in the late 1970s and was successful in rediscovering versions of various physical laws, such as Coulomb's law and Galileo's laws for the pendulum and constant acceleration, among many others.SR was later studied by Koza [12,13,1] who proposed that genetic programming (GP) can be used to discover symbolic models by encoding mathematical expressions as computational trees, where GP is an evolutionary algorithm that iteratively evolves an initial population of individuals via biology-inspired operations.SR was since then tackled with GP-based methods [1,14,15,16,17,18,19,20,21,22,23,24,25].Moreover, it was popularized as a datadriven scientific discovery tool with the commercial software Eureqa [26] based on a research work [2].Whereas GP-based methods achieve high prediction accuracy, they do not scale to high dimensional data sets and are sensitive to hyperparameters [19].More recently, SR has been addressed with deep learning-based methods [27,28,19,29,30,31,32,33] which leverage neural networks (NNs) to learn accurate symbolic models.SR has been applied in fundamental and applied sciences such as astrophysics [34], chemistry [35,36], materials science [37,38], semantic similarity measurement [39], climatology [40], medicine [41], among many others.Many of these applications are promising, showing the potential of SR.A recent SR benchmarking platform SRBench is introduced by La Cava et al. [42].It comprises 14 SR methods (among which ten are GP-based), applied on 252 data sets.The goal of SRBench was to provide a benchmark for rigorous evaluation and comparison of SR methods.</p>
<p>This survey aims to help researchers effectively and comprehensively understand the SR problem and how it could be solved, as well as to present the current status of the advances made in this growing subfield.The survey is structured as follows.First, we define the SR problem, present a structured and comprehensive review of methods, and discuss their strengths and limitations.Furthermore, we discuss the adoption of these SR methods across various application domains and assess their effectiveness.Along with this survey, a living review [25] aims to group state-of-the-art SR methods and applications and track advances made in the SR field.The objective is to update this list often to incorporate new research works.This paper is organized as follows.The SR problem definition is presented in Section 2. We present an overview of methods deployed to solve the SR problem in Section 3, and the methods are discussed in detail in Sections 4, 5 and 6.Selected applications are described and discussed in Section 7. Section 8 presents an overview of existing benchmark data sets.Finally, we summarize our conclusions and discuss perspectives in Section 10.</p>
<p>Problem Definition</p>
<p>The problem of symbolic regression can be defined in terms of classical Empirical Risk Minimization (ERM) [43].
Data: Given a data set D = {(x i , y i )} n i=1
, where x i ∈ R d is the input vector and y i ∈ R is a scalar output.</p>
<p>Function Class: Let F be a function class consisting of mappings f : R d → R.</p>
<p>Loss Function: Define the loss function for every candidate f ∈ F:
l(f ) := n i=1 l(f (x i ), y i )(1)
A common choice is the squared difference between the output and prediction, i.e. l(f
) = i (y i − f (x i )) 2 .
Optimization: The optimization task is to find the function (f ) over the set of functions F that minimizes the loss function:
f * = arg min f ∈F l(f )(2)
As stated below, what distinguishes SR from conventional regression problems is the discrete nature of the function class F. Different methods for solving the SR problem reduce to characterizing the function class.</p>
<p>Class of Function</p>
<p>In SR, to define F, we specify a library of elementary arithmetic operations and mathematical functions and variables, and an element f ∈ F is the set of all functions that can be obtained by function composition in the library [44].For example, consider a library:
L = {id(•), add(•, •), sub(•, •), mul(•, •), +1, −1}(3)
Then the set of all of the polynomials (in one variable x) with integer coefficients can be derived from L using function composition.</p>
<p>Expression representation</p>
<p>It is convenient to express symbolic expressions in a sequential form using either a unary-binary expression tree or the polish notation [45].For example, the expression f (x) = x 1 x 2 − 2x 3 can be derived using function composition from L (Eq. 3) and represented as a tree-like structure illustrated in Figure 1a.By traversing the (binary) tree top to bottom and left to right in a depth-first manner, we can represent the same expression as a unique sequence called the polish form, as illustrated in Figure 1b.In practice, the library L includes many other common elementary mathematical functions, including the basic trigonometric functions like sine, cosine, logarithm, exponential, square root, power low, etc. Prior domain knowledge is advantageous for library definition because it reduces the search space to only include the most relevant mathematical operations to the studied problem.Furthermore, a large range of possible numeric constants should be possible to express.For example, numbers in base-10 floating point notation rounded up to four significant digits can be represented as triple of (sign, mantissa, exponent) [31].The function sin(3.456x),for example, can be represented as [sin, mul, 3456, E − 3, x].
− × x 1 x 2 × + 1 1 x 3 (a) − × x 1 x 2 × + 1 1 x 3 (b)</p>
<p>Symbolic regression methods overview</p>
<p>In this survey, we categorize SR methods in the following manner: regression-based methods, expression treebased methods, physics-inspired and mathematics-inspired methods, as presented in Figure 2.For each category, a summary of the mathematical tool, the expression form, the set of unknowns, and the search space, is presented in Table 1.</p>
<p>The linear method defines the functional form as a linear combination of nonlinear functions of x that are comprised in the predefined library L. Linear models are expressed as:
f (x, θ) = j θ j h j (x)(4)
where j spans the base functions of L. The optimization problem reduces to find the set of parameters {θ} that minimizes the loss function defined over a continuous parameter space Θ = R M as follows:
θ * = arg min θ∈Θ i l(f (x i , θ), y i ) (5)
This method is advantageous for being deterministic and disadvantageous because it imposes a single model structure which is fixed during training when the model's parameters are learned.</p>
<p>The nonlinear method defines the model structure by a neural network.Nonlinear models can thus be expressed as:
f (x, W ) = σ( i W i σ( j W j σ(• • • W x)))) (6)
where σ is a nonlinear activation function, and W idx are the learnable parameters of NN layer of index idx.</p>
<p>Similarly to the linear method, the optimization problem reduces finding the set of parameters {W, b} of neural network layers, which minimizes the loss function over the space of real values.</p>
<p>Expression tree-based methods treat mathematical expressions as unary-binary trees whose internal nodes are operators and terminals are operands (variables or constants).This category comprises GP-based, deep neural transformers, and reinforcement learning-based methods.In GP-based methods, a set of transition rules (e.g., mutation, crossover) is defined over the tree space and applied to an initial population of trees throughout</p>
<p>Symbolic Regression Methods</p>
<p>Regressionbased</p>
<p>Linear y = j θ j f j (x)
y i = j θ ij f j (x)y = φ D ( φ E (z, W ), W ) Physics- inspired AI- Feynman y = φ(x , W ) Mathematics- inspired Symbolic Metamodel y = G(x, θ )
Figure 2: Taxonomy based on the type of symbolic regression methods.φ denotes a neural network function, W denotes the set of learnable parameters in NN. x denotes the input data, z denotes a reduced representation of x, and x denotes a new representation of x, e.g., by defining new features based on the original ones.T represents the final population of selected expression trees in genetic programming.many iterations until the loss function is minimized.Transformers [46] represent a novel architecture of neural network (encoder and decoder) that uses attention mechanism.The latter was primarily used to capture longrange dependencies in a sentence.Transformers were designed to operate on sequential data and to perform sequence-to-sequence (seq2seq) tasks.For their use in SR, input data points (x, y) and symbolic expressions (f ) are encoded as sequences and transformers perform set-to-sequence tasks.The unknowns are the weight parameters of the encoder and the decoder.Reinforcement learning (RL) is a machine learning method that seeks to learn a policy π(x|θ) by training an agent to perform a task by interacting with its environment in discrete time steps.An RL setting requires four components: state space, action space, state transition probabilities, and reward.The agent selects an action that is sent to the environment.A reward and a new state are sent back to the agent from its environment and used by the agent to improve its policy at the next time step.In the context of SR, symbolic expression (sequence) represents a state, predicting an element in a sequence represents an action, the parent and sibling represent the environment, and the reward is commonly chosen as the mean square error (MSE).RL-based SR methods are commonly hybrid and use various ML tools (e.g., NN, RNN, etc.) in a joint manner with RL.</p>
<p>Linear symbolic regression</p>
<p>The linear approach assumes, by definition, that the target symbolic expression (f (x)) is a linear combination of nonlinear functions of feature attributes:
f (x) = j θ j h j (x)(7)
Here x denotes the input features vector, θ j denotes a weight coefficient, and h j (•) denotes a unary operator of the library L. This approach predefines the model's structure and reduces the SR problem to learn only the model's parameters by solving a system of linear equations.The particular case where f (x) is a linear combination of degree-one monomial reduces to a conventional linear regression problem, i.e., f (x) = j θ j x j = θ 0 + θ 1 x + θ 2 x 2 + • • • .There exist two cases for this problem: (1) a unidimensional case defined by f : R d → R; and (2) a multidimensional case defined by f : R d → R m , with d the number of input features and m the number of variables required for a complete description of a system; for example, the Lorenz system for fluid flow is defined in terms of three physical variables which depend on time.
= i θ i f i (x) {θ} i R Multi-D linear system y i = j θ j f j (x) ({θ} i ) j R Nonlinear SR Neural Network y = f (W • x + b) {W, b} R Expression-tree search Genetic Programming Expression tree trees Transformers set2seq mapping {W q , W k , W v } R Reinforcement learning set2seq mapping π(θ) R Physics-inspired AI-Feynman y = f (x, θ) − − Mathematics-inspired Symbolic metamodels G(x, θ) θ R</p>
<p>Unidimensional case</p>
<p>Given a data set D = {(x i , y i )} n i=1 , the mathematical expression could be either univariate (x i ∈ R,
y i = f (x i )) or multivariate (x i ∈ R d , y i = f (x i ))
. The methodology of linear SR is presented in detail for the univariate case in Secion 4.1.1 for simplicity and is extended for the multivariate case in Section 4.1.2.</p>
<p>Univariate function
Data set: D = {x i ∈ R; y i = f (x i )}.
Library: L can include any number of mathematical operators such that the dimension of the data set is always greater than the dimension of the library matrix (see discussion below).</p>
<p>In this approach, a coefficient θ j is assigned to each candidate function (f j (•) ∈ L) as an activeness criterion such that:
y = j θ j f j (x)(8)
Applying Eq. 8 to input-output pairs (x i , y i ) yields a system of linear equations as follows:
y 1 = θ 0 + θ 1 f 1 (x 1 ) + θ 2 f 2 (x 1 ) + • • • + θ k f k (x 1 ) y 2 = θ 0 + θ 1 f 1 (x 2 ) + θ 2 f 2 (x 2 ) + • • • + θ k f k (x 2 )
. . .
y n = θ 0 + θ 1 f 1 (x n ) + θ 2 f 2 (x n ) + • • • + θ k f k (x n )(9)
which can be represented in a matrix form as:
     y 1 y 2 . . . y n      =      1 f 1 (x 1 ) f 2 (x 1 ) • • • f k (x 1 ) 1 f 1 (x 2 ) f 2 (x 2 ) • • • f k (x 2 ) . . . 1 f 1 (x n ) f 2 (x n ) • • • f k (x n )           θ 0 θ 1 . . . θ k     (10)
Equation 10 can then be presented in a compact form:
Y = U(X) • Θ (11)
where Θ ∈ R (k+1) is the sparse vector of coefficients, and U ∈ R n×(k+1) is the library matrix which can be represented as a function of the input vector X as follows:
U(X) =   | | | | 1 f 1 (X) f 2 (X) • • • f k (X) | | | |  (12)
Example: For a library defined as:
L = {1, x, (•) 2 , sin(•), cos(•), exp(•)}(13)
The matrix U becomes:
U(X) =   | | | | | | 1 X X 2 sin(X) cos(X) exp(X) | | | | | |  
Each row (of index i) in Eq. 12 is a vector of (k + 1) functions of x i .The vector of coefficients, i.e., the model's parameters, is obtained by solving Eq. 11 as follows:
2 : Θ = (U T U) −1 U T Y (14)
The magnitude of a coefficient θ k effectively measures the size of the contribution of the associated function f k (•) to the final prediction.Finally, the prediction vector Ŷ can be evaluated using Eq.11.</p>
<dl>
<dt>An exemplary schematic is illustrated in Figure 3 for the univariate function f (x) = 1 + αx 3 .Only coefficients associated with functions {1, x 3 } of the library are non-zero, with values equal to 1 and α, respectively.</dt>
<dt>Y = 1 x x 2 x 3 • • • Θ Figure 3</dt>
<dd>Schematic of the system of linear equations of Eq. 11 for f (x) = 1 + αx 3 .A library matrix U(X) of nonlinear functions of the input is constructed, where L = {1, x, x2 , x 3 , • • • }.The marked entries in the Θ vector denote the non-zero coefficients determining which functions of the library are active.</dd>
</dl>
<p>In the following, linear SR is tested on synthetic data.In each experiment, training and test data sets are generated.Each set consists of twenty data points randomly sampled from a uniform distribution U(−1, 1), and y is evaluated using a univariate function, i.e., D = {(x i , f (x i ))} n i=1 .Two libraries are considered in these experiments:
L 1 = {x, (•) 2 , (•) 3 , • • • , (•) 9 } and L 2 = L 1 ∪{sin(•), cos(•), tan(•), exp(•), sigmoid(•)}.
The results are reported in terms of the output expression (Equation 7) and the coefficient of determination R 2 .SR problems are grouped into (i) pure polynomial functions and (ii) mixed polynomial and trigonometric functions.In each experiment, parameters are learned using the training data set, and results are reported for the test data set in Table 2.For polynomial functions, an exact output is obtained using L 1 with an R 2 = 1.0, whereas only approximate output is obtained using L 2 .In the latter case, the quality of the fit depends on the size of the training data set.An exemplary result is shown in Figure 4 for f (x) = x + x 2 + x 3 .Points represent the (test) data of the input file, i.e., X; the red curve represents f (x) as a function of x, and the blue and black dashed curves represent the predicted function f (x) obtained using L 1 and L 2 respectively.An exact match between the ground-truth function and the predicted one is found using L 1 , whereas a significant discrepancy is obtained using L 2 .This discrepancy could be explained by the fact that various functions in L 2 exhibit the same x-dependence over the covered x-range.
D = {(x i ; y i )}; x i ∈ U(−1, 1, 20) and y i = f (x i ). L 1 = {x, (•) 2 , • • • , (•) 9 } and L 2 = L 1 ∪ {sin(•), cos(•), tan(•), exp(•), sigmoid(•)}. T denotes True, and F denotes False. Benchmark Expression L 1 L 2 Exp R 2 Exp R 2
Nguyen-2 For mixed polynomial and trigonometric expressions, both library choices do not produce the exact expression.However, a better R 2 -coefficient is obtained using L 1 .In the case of Nguyen-5 benchmark for example, i.e., f (x) = sin(x 2 ) cos(x) − 1, the resulting function is the Taylor expansion of f :
x 4 + x 3 + x 2 + x T 1.0 F 0.886 Nguyen-3 x 5 + x 4 + x 3 + x 2 + x T 1.0 F 0.867 Livermore-21 x 8 + x 7 + x 6 + x 5 + x 4 + x 3 + x 2 + x T 1.0 F 0.869 Livermore-9 x 9 + x 8 + x 7 + x 6 + x 5 + x 4 + x 3 + x 2 + x T 1.0 F 0.882 Livermore-6 x + 2x 2 + 3x 3 + 4x 4 T 1.0 F 0.417 Livermore-19 x + x 2 + x 4 + x 5 T 1.0 F -0.079 Livermore-14 * x + x 2 + x 3 + sin(x) F 1.0 F -0.857 Nguyen-5 sin(x 2 ) cos(x) − 1 F 0.999 F -3.97 Nguyen-6 sin(x) + sin(x + x 2 ) F 0.999 F 0.564ŷ(x) ≈ −1 + 0.9x 2 − 0.5x 4 − 0.13x 6 + O(x 8 )
In conclusion, this approach can not learn the ground-truth function when the latter is a multiplication of two functions (i.e., f
(x) = f 1 (x) * f 2 (x))
or when it has a multiplicative or an additive factor to the variable (e.g., sin(α + x), exp(λ * x), etc.).In the best case, it outputs an approximation of the ground-truth function.Furthermore, this approach fails to predict the correct mathematical expression when the library is extended to include a mixture of polynomial, trigonometric, exponential, and logarithmic functions.</p>
<p>Multivariate function</p>
<p>For a given data set
D = {x i ∈ R d ; y i = f (x 1 , • • • , x d )}
, where d is the number of features, the same equations presented in Section 4.1.1 are applicable.However, the dimension of the library matrix U changes to consider the features vector dimension.For example, for the same library shown in Eq. 13 and a two dimensional features vector, i.e., X ∈ R 2 , U(X) becomes:
U(X) =   | | | | | | 1 X X P 2 sin(X) cos(X) exp(X) | | | | | |   =   | | | | | | | | 1 x 1 x 2 x 2 1 x 1 x 2 x 2 2 sin(x 1 ) sin(x 2 ) • • • | | | | | | | |  (15)
Here, X Pq denotes polynomials in X of the order q.</p>
<p>Table 3 presents the results of the experiments performed on two-variables dependent functions, i.e., f (x 1 , x 2 ).Similarly to Section 4.1.1,training and test data sets are generated by randomly sampling twenty pairs of points
(x 1 , x 2 ) from a uniform distribution U(-1,1) such that D = {(x 1i , x 2i , f (x 1i , x 2i ))} n i=1 .
The same choices for the library are considered:
L 1 = {x, (•) 2 , • • • , (•) 9 } and L 2 = L 1 ∪ {sin(•), cos(•), tan(•), exp(•), sigmoid(•)}.
An exact match between the ground-truth and predicted function is obtained using L 1 for any polynomial function, whereas only approximate solutions are obtained for trigonometric functions.The results are approximate of the ground-truth function using L 2 .</p>
<p>Table 3: Results for multivariate functions using linear SR.
D = {(x 1 , x 2 ) ∈ U(−1, 1, 20); y = f (x 1 , x 2 )}. L 1 = {x, (•) 2 , • • • , (•) 9 } and L 2 = L 1 ∪ {sin(•), cos(•), tan(•), exp(•), sigmoid(•)}.
T and F refer to True and False.</p>
<p>Benchmark</p>
<p>Expression
L 1 L 2 Result R 2 Result R 2 Nguyen-12 x 4 1 − x 3 1 + 1 2 x 2 2 − x 2 T 1.0 F ≈ 1 Livermore-5 x 4 1 − x 3 1 + x 2 1 − x 2 T 1.0 F ≈ 1 Nguyen-9 sin(x 1 ) + sin(x 2 2 ) F ≈ 1 F ≈ 1 Nguyen-10 2 sin(x 1 ) cos(x 2 ) F ≈ 1 F ≈ 1
Furthermore, linear SR is tested on a dataset generated using a two-dimensional multivariate normal distribution N (µ, Σ), as shown in Fig. 5. Different analytic expressions for f (x 1 , x 2 ) were tested with different library bases that are summarized in Table 4, including pure polynomial basis functions, polynomial and trigonometric basis functions, and a mixed library.The function y 1 = cos(x 1 ) + sin(x 2 ) is explored with all three bases.In the case of a pure polynomial basis, the correct terms of the Taylor expansion of both cos(x 1 ) and sin(x 2 ) are identified with only approximate values of their coefficients, i.e., ŷ1 = (0.88 − 0.3x 2 1 + 0.01x 4 1 ) + (0.97 − 0.2x 3 2 ), which is reflected in the significantly high reconstruction error of the order of 30%.In both bases where trigonometric functions are enlisted, the correct terms cos(x 1 ) and sin(x 2 ) are identified with an excellent reconstruction error, that is ≥ 10 −7 .Note that the lowest reconstruction error is obtained for the library U2, which has the least number of operations and, consequently, the lowest number of coefficients.1, X, X P 2 , X P 3 , X P 4 U2 1, X, X P 2 , cos(X), sin(X) U3 1, X, X P 2 , cos(X), sin(X), tan(X), exp(X), sigmoid(X)</p>
<p>The function y 2 = x 2 1 + cos(x 2 ) is also tested.For the pure polynomial basis, the reconstructed function ŷ2 = x 2  1 + (0.83 + 0.49x 2 − x 2 2 ) predicts approximate values with a reconstruction error of ≤ 1%.An excellent prediction is made for the other bases, which enlist both operations in y 2 (x 1 , x 2 ).</p>
<p>In the same exercise, a more complicated function form is tested that includes mixed terms, i.e., y 3 = x 1 (1 + x 2 ) + cos(x 1 ) * sin(x 2 ).The difference between the true and the predicted function is illustrated in Fig. 6.The linear approach performs similarly for all three library bases.A low reconstruction error is obtained because the operation term cos(x 1 ) * sin(x 2 ) in y 3 is not enlisted in any of the libraries, showing an important limitation of the current approach.</p>
<p>Multidimensional case</p>
<p>The target mathematical expression comprises m components, i.e., Y = [y 1 , • • • , y m ], and the goal is to learn the coefficients of a system of linear equations rather than one mathematical expression.Each component (y j ) is described by:
y j = f j (x) = k θ jk h k (x)(16)
In this case, there exist m sparse vectors of coefficients, i.e., Θ = [θ 1 • • • θ m ].Consider the Lorenz system, which is a set of ordinary differential equations that captures nonlinearities in the dynamics of fluid convection.It consists of three variables {x 1 , x 2 , x 3 } and their first-order derivatives with respect to time { dx1 dt , dx2 dt , dx3 dt }, which we will refer to as {y 1 , y 2 , y 3 }.Using the library of Eq. 13, the system of linear equations is represented in a matrix form as follows:
    y 1 y 2 y 3 . . . . . . . . . . . . . . . . . .     =     1 x 1 x 2 x 2 1 x 1 x 2 x 2
Here, Y ∈ R n×3 , U(X) ∈ R n×k and Θ ∈ R k×3 , where n is the size of the input data and k is the number of columns in the library matrix U.The j th -component of the Y vector is given by:
y j = θ j,0 + θ j,1 x 1 + θ j,2 x 2 + θ j,3 x 2 1 + • • • + θ j,k exp(x 2 )(18)
Equation 17 can be written in a compact form as:
y k = U(x T )θ k(19)
The application presented in [33] uses this approach, where the authors aim to learn differential equations that govern the dynamics of a given system, such as a nonlinear pendulum and the Lorenz system.The approach successfully learned the exact weights, allowing them to recover the correct governing equations.</p>
<p>An exemplary schematic is illustrated in Figure 7 for the Lorenz system defined by ẋ = σ(y −x), ẏ = x(ρ−z)−y, ż = xy − βz.Here x, y, and z are physical variables and ẋ, ẏ, and ż are their respective time-derivatives.Only coefficients associated with functions {x 1 , x 1 x 2 , } should be non-zero and equal to the factors shown in the Lorenz system's set of equations.
y 1 y 2 y 3 = 1 x 1 x 2 x 3 x 2 1 • • • θ 1 θ 2 θ 3
Figure 7: Schematic of the system of Eq. 11 for the Lorenz system defined by
y 1 = σ(x 2 −x 1 ), y 2 = x 1 (ρ−x 3 )−x 2 , y 3 = x 1 x 2 − βx 3 .
A library U(X) of nonlinear functions of the input is constructed.The marked entries in the θs vectors denote the non-zero coefficients determining which library functions are active for each of the three variables {y 1 , y 2 , y 3 }.</p>
<p>In summary, the linear approach is only successful in particular cases and can not be generalized.Its main limitation is in predefining the model's structure as a linear combination of nonlinear functions, reducing the SR problem to solve a system of linear equations.In contrast, the main mission of SR is to learn the model's structure and parameters.A direct consequence of this limitation is that the linear approach fails to learn expressions in many cases: (i) composition of functions (e.g., f (x) = f 1 (x) * f 2 (x)); (ii) multivariate functions (e.g., exp(x * y), tan(x+y), etc.); and (iii) functions including multiplicative or additive factors to their arguments (e.g., exp(λx)).Finally the dimension of the library matrix can be challenging in computing resources for extended libraries and high-dimensional data sets.</p>
<p>Nonlinear symbolic regression</p>
<p>The nonlinear method uses deep neural networks (DNN), known for their great ability to detect and learn complex patterns directly from data.</p>
<p>DNN has the advantage of being fully differentiable in its free parameters allowing end-to-end training using back-propagation.This approach searches the target expression by replacing the standard activation functions in a neural network with elementary mathematical operations.Figure 8 shows an NN-based architecture for SR called the Equation Learner (EQL) network proposed by Martius and Lampert [47] in comparison with a standard NN.Only two hidden layers are shown for simple visualization, but the network's deepness is controlled as per the case study.</p>
<p>The EQL network uses a multi-layer feed-forward NN with one output node.A linear transformation z [l] is applied at every hidden layer (l), followed by a nonlinear transformation a</p>
<p>[l] i using unary (i.e., one argument) and binary (i.e., two arguments) activation functions as follows where {W, b} denote the weight parameters and f i denotes individual activation function from the library L = {identity, (•) n , cos, sin, exp, log, sigmoid}.In a standard NN, the same activation function is applied to all hidden units and is typically chosen among {RELU, tanh, sigmoid, softmax, etc.}.
z [l] = W [l] • a [l−1] + b [l] a [l] i = f i (z [l] i )(20)
The problem reduces to learn the correct weight parameters {W [l] , b [l] }, whereas the operators of the target mathematical expression are selected during training.To overcome the interpretability limitation of neural network-based architectures and to promote simple over complex solutions as a typical formula describing a physical process, sparsity is enforced by adding a regularization term l 1 to the l 2 loss function such that,
= 1 N N i=1 ŷ(x i ) − y i 2 + λ L l=1 |W [l] | 1(21)
Where N denotes the number of data entries and L denotes the number of layers.Whereas this method is endto-end differentiable in NN parameters and scales well to high dimensional problems, back-propagation through activation functions such as division or logarithm requires simplifications to the search space, thus limiting its ability to produce simple expressions involving divisions (e.g., sin (x/y)</p>
<p>x</p>
<p>).An extended version EQL ÷ [48] includes only the division, whereas exponential and logarithm activation functions are not included because of numerical issues.</p>
<p>Tree expression</p>
<p>This section discusses SR methods in which a mathematical expression is regarded as a unary-binary tree consisting of internal nodes and terminals.Every tree node represents a mathematical operation (e.g., +, −, ×, sin, log, etc.) that is drawn from a pre-defined function class F (Section 2.1) and every tree terminal node (or leaf) represents an operand, i.e., variable or constant, as illustrated for the example shown in Figure 9. Expression tree-based methods include genetic programming, transformers, and reinforcement learning.</p>
<p>Genetic Programming</p>
<p>Genetic programming (GP) is an evolutionary algorithm in computer science that searches the space of computer programs to solve a given problem.Starting with a "population" (set) of "individuals" (trees) that is randomly generated, GP evolves the initial population T (0) GP using a set of evolutionary "transition rules" (operations) {r i : f → f | i ∈ N} that is defined over the tree space.GP evolutionary operations include mutation, crossover, and selection.The mutation operation introduces random variations to an individual by replacing one subtree with another randomly generated subtree (Figure 10 .In each generation, each individual has a probability of undergoing a mutation operation and a probability of undergoing a crossover operation.The selection is applied when the dimension of the current population is the same as the previous one.Throughout M k iterations, the following steps are undertaken: (1) transition rules are applied to the function set
F k = {f k 1 , • • • , f k M k } such that f k+1 = r i (f k )
where k denotes the iteration index; (2) the loss function (F k ) is evaluated for the set; and (3) an elite set of individuals is selected for the next iteration step.The GP algorithm repeats this procedure until a predetermined accuracy level is achieved.Whereas GP allows for large variations in the population resulting in improved performance for out-of-distribution data, GP-based methods do not scale well to high dimensional data sets and are highly sensitive to hyperparameters [19].</p>
<p>Transformers</p>
<p>Transformer neural network (TNN) is a novel NN architecture introduced by Vaswani et al. [46] in natural language processing (NLP) to model sequential data.TNN is based on the attention mechanism that aims to model long-range dependencies in a sequence.Consider the English-to-French translation of the two following sentences:</p>
<p>En: The kid did not go to school because it was closed.</p>
<p>Fr: L'enfant n'est pas allé à l'école parce qu'elle était fermée.</p>
<p>En: The kid did not go to school because it was cold.Fr: L'enfant n'est pas allé à l'école parce qu'il faisait froid.</p>
<p>The two sentences are identical except for the last word, which refers to the school in the first sentence (i.e., "closed") and to the weather in the second one (i.e., "cold").Transformers create a context-dependent word embedding that it pays particular attention to the terms (of the sequence) with high weights.In this example, the noun that the adjective of each sentence refers to has a significant weight and is therefore considered for translating the word "it".Technically, an embedding x i is assigned to each element of the input sequence, and a set of m key-value pairs is defined, i.e., S = {(k 1 , v 1 ), • • • , (k m , v m )}.For each query, the attention mechanism computes a linear combination of values j ω j v j , where the attention weights (ω j ∝ q • k j ) are derived using the dot product between the query (q) and all keys (k j ), as follows:
Attention(q, S) = j σ(q • k j )v j(22)
Here, q = xW q is a query,
k i = x i W k is a key, v i = x i W v is
a value, and W q , W k , W v are the learnable parameters.The architecture of the self-attention mechanism is illustrated in Figure 11.</p>
<p>Figure 11: Evaluation of Attention(q, S) (Eq.22) for a query q i , computed using the input vector embedding x i .</p>
<p>In the context of SR, both input data points {(x i , y i )
| x i ∈ R d , y i ∈ R, i ∈ N n }
and mathematical expressions f are encoded as sequences of symbolic representations as discussed in Section 2.2.The role of the transformer is to create the dependencies at two levels, first between numerical and symbolic sequences and between tokens of symbolic sequence.Consider the mathematical expression f (x, y, z) = sin(x/y) − sin(z), which can be written as a sequence of tokens following the polish notation:
− sin ÷ x y sin z
Each symbol is associated with an embedding such that:</p>
<p>x 1 : − x 2 : sin x 3 : ÷ x 4 : x x 5 : y x 6 : sin x 7 : z</p>
<p>In this particular example, for query (x 7 : z), the attention mechanism will give a higher weight for the binary operator (x 1 : −) than for the variable (x 5 : y) or the division operator (x 3 : ÷).</p>
<p>Transformers consist of an encoder-decoder structure; each block comprises a self-attention layer and a feedforward neural network.TNN inputs a sequence of embeddings {x i } and outputs a "context-dependent" sequence of embeddings {y i } one at a time, through a latent representation z i .TNN is an auto-regressive model, i.e., sampling each symbol is conditioned by the previously sampled symbols and the latent sequence.An example of a TNN encoder is shown in Figure 12.</p>
<p>Figure 12: Structure of a TNN encoder [46].It comprises an attention layer and a feed-forward neural network.</p>
<p>In symbolic regression case, the encoder and the decoder do not share the same vocabulary because the decoder has a mixture of symbolic and numeric representations, while the encoder has only numeric representations.There exist two approaches to solving SR problems using transformers.First is the skeleton approach [32,49] where the transformer conducts the two-steps procedure: (1) the decoder predicts a skeleton f e , a parametric function that defines the general shape of the target expression up to a choice of constants, using the function class F and (2) the constants are fitted using optimization techniques such as the non-linear optimization solver BFGS.For example, if f = cos(2x 1 ) − 0.1 exp(x 2 ), then the decoder predicts f e = cos(• x 1 ) − • exp(x 2 ) where • denotes an unknown constant.The second is an end-to-end (E2E) approach [31] where both the skeleton and the numerical values of the constants are simultaneously predicted.Both approaches are further discussed in Section 7.</p>
<p>Reinforcement learning</p>
<p>Reinforcement learning provides a framework for learning and decision-making by trial and error [50].An RL Setting consists of four components (S, A, P, R) in a Markov decision process.In this setting, an agent observes a state s ∈ S of the environment and, based on that, takes action a ∈ A, which results in a reward r = R(s, a), and the environment then transitions to a new state s ∈ S. The interaction goes on in time steps until a terminal state is reached.The aim of the agent is to learn the policy P (also called transition dynamics), which is a mapping from states to actions that maximize the expected cumulative reward.An exemplary sketch of an RL-based SR method is illustrated in Figure 13.SR problem can be framed in RL as follows: the agent (NN) observes the environment (parent and sibling in a tree) and, based on the observation, takes an action (predict the next token of the sequence) and transitions into a new state.In this view, the NN model is like a policy, the parent and sibling are like observations, and sampled symbols are like actions.</p>
<p>Applications</p>
<p>Most existing algorithms for solving SR are GP-based, whereas many others, and more recent, are deep learning (DL)-based.There exist two different strategies to solve SR problems, as illustrated in the taxonomy of Figure 14.The first is a one-step approach, where data points are directly fed into an SR algorithm.A second is a two-step approach involving a process which either learns a new representation of data or learns a "blackbox" model, which will be then fed into SR algorithm as described below:</p>
<ol>
<li>
<p>Learn a new representation of the original data set by defining new features (reducing the number of independent variables) or a reduced representation using specific NN architectures such as principal component analysis and autoencoders.</p>
</li>
<li>
<p>Learn a "blackbox" model either using regular NN or using conceptual NN such as graph neural network (GNN).In this case, an SR algorithm is applied to the learned model or parts of it.</p>
</li>
</ol>
<p>We group the applications based on the categories presented in Section 3, and we summarize them in Table 5. GP-based applications will not be reviewed here; they are listed in the living review [25], along with DL-based applications.State-of-the-art GP-based methods are discussed in detail in [54].Among GP-based applications is the commercial software Eureqa [26], the most well-known GP-based method that uses the algorithm proposed by Schmidt and Lipson in [2].Eureqa is used as a baseline SR method in several research works.[33] is a hybrid SR method that combines autoencoder network [55] with linear SR [51].The novelty of this approach is in simultaneously learning sparse dynamical models and reduced representations of coordinates that define the model using snapshot data.Given a data set x(t) ∈ R n , this method seeks to learn coordinate transformations from original to intrinsic coordinates z = φ(x) (encoder) and back via x = ψ(z) (decoder), along with the dynamical model associated with the set of reduced coordinates z(t</p>
<p>SINDY-AE
) ∈ R d (d n): d dt z(t) = g (z(t)) (23)
through a customized loss function L, defined as a sum of four terms:
L = x − ψ(φ(x)) 2 2 reconstruction error + λ 1 ż − żpred 2 2
encoder loss
+ λ 2 ẋ − ẋpred 2 2
decoder loss
+ λ 3 Θ 1 regularizer loss(24)
Here the derivative of the reduced variables z are computed using the derivatives of the original variable x, i.e. ż = ∇ x φ(x) ẋ.Predicted coordinates denoted as a pred represent NN outputs and are expressed in terms of coefficient vector Θ and library matrix U(x) following Eq.19, i.e., z rec = U(z T )Θ = U(φ(x) T )Θ.The library is specified before training, and the coefficients Θ are learned with the NN parameters as part of the training procedure.</p>
<p>A case study is the nonlinear pendulum motion whose dynamics are governed by a second-order differential equation given by ẍ = − sin(x).The data set is generated as a series of snapshot images from a simulated video of a nonlinear pendulum.After training, the SINDY autoencoder correctly identified the equation z = −0.99sin z, which is the dynamical model of a nonlinear pendulum in the reduced representation.This approach is particularly efficient when the dynamical model may be dense in terms of functions of the original measurement coordinates x.This method and similar works [56] make the path to "Gopro physics" where researchers point a camera on an event and get back an equation capturing the underlying phenomenon using an algorithm.</p>
<p>Despite successful applications involving partial differential equations, still, one main limitation of this method is in its linear SR part.For example, a model expressed as f (x) = x 1 x 2 − 2x 2 exp(−x 3 ) + 1 2 exp(−2x 1 x 3 ) is discovered only if each term of this expression is comprised in the library, e.g., exp(−2x 1 x 2 ).The presence of the exponential function, i.e., exp(x), is insufficient to discover the second and the third terms.</p>
<p>Symbolic metamodel [30] (SM) is a model-of-a-model method for interpreting "blackbox" model predictions.It inputs a learned "blackbox") model and outputs a symbolic expression.Available post-hoc methods aim to explain ML model predictions, i.e., they can explain some aspects of the prediction but can not offer a full model interpretation.In contrast, SM is interpretable because it uncovers the functional form that underlies the learned model.The symbolic metamodel is based on Meijer G-function [57,58], which is a special univariate function characterized by a set of indices, i.e., G m,n p,q (a p , b q |x), where a and b are two sets of real-values parameters.An instance of the Meijer G-function is specified by (a, b), for example the function G 1,2 2,2 ( a,a a,b |x) takes different forms for different settings of the parameters a and b, as illustrated in Figure 15.</p>
<p>In the context of SR problem solving, the target mathematical expression is defined as a parameterization of the Meijer function, i.e., {g(x) = G(θ, x) | θ = (a, b)}, thus reducing the optimization task to a standard parameter optimization problem that can be efficiently solved using gradient descent algorithms
θ k+1 := θ k −γ i l(G(x i , θ), f (x i ))| θ=θ k .
The parameters a and b are learned during training, and the indices (m, n, p, q) are regarded as hyperparameters of the model.SM was tested on both synthetic and real data and was deployed in two modes spanning (1) only polynomial expressions (SM p ) and (2) closed-form expressions (SM c ), in comparison to a GP-based SR method.SM p produces accurate polynomial expressions for three out of four tested functions (except the Bessel function), whereas SM c produces the correct ground-truth expression for all four functions and significantly outperforms GP-based SR.</p>
<p>More generally, consider a problem in a critical discipline such as healthcare.Assuming a feature vector comprising (age, gender, weight, blood pressure, temperature, disease history, profession, etc.) with the aim to predict the risk of a given disease.Predictions made by a "blackbox" could be highly accurate.However, the learned model does not provide insights into why the risk is high or low for a patient and what parameter is the most critical or weightful in the prediction.Applying the symbolic metamodel to the learned model outputs a symbolic expression, e.g.,
f (x 1 , x 2 ) = x 1 (1 − exp(−x 2 ))
, where x 1 is the blood pressure and x 2 is the age.</p>
<p>Here, we can learn that only two features (out of many others) are crucial for the prediction and that the risk increases with high blood pressure and decreases with age.This is an ideal example showing the difference between "blackbox" and interpretable models.In addition, it is worth mentioning that methods applied for model interpretation only exploit part of the prediction and can not unveil how the model captures nonlinearities in the data.Thus model interpretation methods are insufficient to provide full insights into why and how model predictions are made and are not by any means equivalent to interpretable models.</p>
<p>End-to-end symbolic regression [31] (E2ESR) is a transformer-based method that uses end-to-end learning to solve SR problems.It is made up of three components: (1) an embedder that maps each input point (x i , y i ) to a single embedding, (2) a fully-connected feedforward network, and (3) a transformer that outputs a mathematical expression.What distinguishes E2ESR from other transformer-based applications is the use of an end-to-end approach without resorting to skeletons, thus using both symbolic representations for the operators and the variables and numeric representations for the constants.Both input data points {(x i , y i ) | i ∈ N n } and mathematical expressions f are encoded as sequences of symbolic representations following the description in Section 2.2.E2ESR is tested and compared to several GP-based and DL-based applications on SR benchmarks.Results are reported in terms of mean accuracy, formula complexity, and inference time, and it was shown E2ESR achieves very competitive results for SR and outperforms previous applications.</p>
<p>AIFeynman [27] is a physics-inspired SR method that recursively applies a set of solvers, i.e., dimensional analysis3 , polynomial fit, and brute-force search to solve an SR problem.If the problem is not solved, the algorithm searches for simplifying intrinsic properties in data (e.g.invariance, factorization) using NN and deploys them to recursively simplify the dataset into simpler sub-problems with fewer independent variables.Each sub-problem is then tackled by a symbolic regression method of choice.The authors created the Feynman SR database (see Section 8) to test their approach.All the basic equations and 90% of the bonus equations were solved by their algorithm, outperforming Eureqa.</p>
<p>Deep Symbolic Regression (DSR) [19] is an RL-based search method for symbolic regression that uses a generative recurrent neural network (RNN).RNN defines a probability distribution (p(θ)) over mathematical expressions (τ ), and batches of expressions T = {τ (i) } N i=1 are stochastically generated.An exemplary sketch of how RNN generates an expression (e.g., x 2 − cos(x)) is shown in Figure 16.Starting with the first node following the pre-order traversal (Section 2.2) of an expression tree, RNN is initially fed with empty placeholders tokens (a parent and a sibling) and produces a categorical distribution, i.e., outputs the probability of selecting every token from the defined library L = {+, −, ×, ÷, sin, cos, log, etc.}.The sampled token is fed into the first node, and the number of siblings is determined based on whether the operation is unary (one sibling) or binary (two siblings).The second node is then selected, and the RNN is fed with internal weights along with the first token and outputs a new (and potentially different) categorical distribution.This procedure is repeated until the expression is complete.Expressions are then evaluated with a reward function R(τ ) to test the goodness of the fit to the data D for each candidate expression (f ) using normalized root-mean-square error, To generate better expressions (f ), the probability distribution p(τ |θ) needs to be optimized.Using a gradientbased approach for optimization requires the reward function R(τ ) to be differentiable with respect to the RNN parameter θ, which is not the case.Instead, the learning objective is defined as the expectation of the reward under expressions from the policy, i.e., J(θ) = E τ ∼p(τ |θ) [R(τ )], and reinforcement learning is used to maximize J(θ) by means of the "standard policy gradient":
R(τ ) = 1/ 1 + 1 σy 1 n n i=1 (y i − f (X i )) 2 .∇ θ J(θ) = ∇ θ E τ ∼p(τ |θ) [R(τ )] = E τ ∼p(τ |θ) <a href="25">R(τ )∇ θ log p(τ |θ)</a>
This reinforcement learning trick, called REINFORCE [59], can be derived using the definition of the expectation E[•] and the derivative of log(•) function as follows:
∇ θ E τ ∼p(τ |θ) [R(τ )] = ∇ θ R(τ )p(τ |θ)dθ = R(τ )∇ θ p(τ |θ)dθ = R(τ ) ∇ θ p(τ |θ) p(τ |θ) p(τ |θ)dθ = R(τ ) log(p(τ |θ)p(τ |θ)dθ = E τ ∼p(τ |θ) <a href="26">R(τ )∇ θ log p(τ |θ)</a>
The importance of this result is that it allows estimating the expectation using samples from the distribution.More explicitly, the gradient of J(θ) is estimated by computing the mean over a batch of N sampled expressions as follows:
∇ θ J(θ) = 1 N N i=1 R(τ (i) )∇ θ log p(τ (i) |θ)(27)
The standard policy gradient (Eq.25) permits optimizing a policy's average performance over all samples from the distribution.Since SR requires maximizing best-case performance, i.e., to optimize the gradient over the top fraction of samples from the distribution found during training, a new learning objective is defined as a conditional expectation of rewards above the (1 − )-quantile of the distribution of rewards, as follows:
J risk (θ, ) = E τ ∼p(τ |θ) [R(τ ) | R(τ ) ≥ R (θ)] (28)
where R (θ) represent the samples from the distribution below the -threshold.The gradient of the new learning objective is given by:
∇ θ J risk (θ) = E τ ∼p(τ |θ) <a href="29">(R(τ ) − R (θ)) • ∇ θ log p(τ |θ) | R(τ ) ≥ R (θ)</a>
DSR was essentially evaluated on the Nguyen SR benchmark and several additional variants of this benchmark.An excellent recovery rate was reported for each set, and DSR solved all mysteries except the Nguyen-12 benchmark given by x 4 − x 3 + 1 2 y 2 − y.More details on SR data benchmarks can be found in Section 8.</p>
<p>Neural-guided genetic programming population seeding [29] (NGPPS) is a hybrid method that combines GP and RNN [19] and leverages the strengths of each of the two components.Whereas GP begins with random starting populations, the authors in [29] propose to use the batch of expressions sampled by RNN as a staring population for GP: T  where n can vary across examples, and the number of independent input variables is at most three.In the test phase, a set of input-output pairs {x i , y i } is fed into the encoder that maps it into a latent vector z, and the decoder iteratively samples candidates' skeletons.What distinguishes this method is the learning task, i.e., it improves over time with experience, and there is no need to be retrained from scratch on each new experiment.It was shown that NeSymReS outperforms selected baselines (including DSR) in time and accuracy by a large margin on all datasets (AI-Feynman, Nguyen, and strictly out-of-sample equations (SOOSE) with and without constants).NeSymReS is more than three orders of magnitudes faster at reaching the same maximum accuracy as GP while only running on CPU.</p>
<p>GNN [52] is a hybrid scheme performing SR by training a Graph Neural Network (GNN) and applying SR algorithms on GNN components to find mathematical equations.</p>
<p>A case study is Newtonian dynamics which describes the dynamics of particles in a system according to Newton's laws of motion.D consists of an N-body system with known interaction (force law F such as electric, gravitation, spring, etc.), where particles (nodes) are characterized by their attributes (mass, charge, position, velocity, and acceleration) and their interaction (edges) are assigned the attribute of dimension 100.The GNN functions are trained to predict instantaneous acceleration for each particle using the simulated data and then applied to a different data sample.The study shows that the most significant edge attributes, say {e 1 , e 2 }, fit to a linear combination of the true force components, {F 1 , F 2 }, which were used in the simulation showing that edge attributes can be interpreted as force laws.The most significant edge attributes were then passed into Eureqa to uncover analytical expressions that are equivalent to the simulated force laws.The proposed approach was also applied to datasets in the field of cosmology, and it discovered an equation that fits the data better than the existing hand-designed equation.</p>
<p>The same group has recently succeeded in inferring Newton's law for gravitational force using GNN and PySR for symbolic regression task [34].GNN was trained using observed trajectories (position) of the Sun, planets, and moons of the solar system collected during 30 years.The SR algorithm could correctly infer Newton's formula that describes the interaction between masses, i.e., F = −GM 1 M 2 /r 2 , and the masses and the gravitational constant as well.</p>
<p>Datasets</p>
<p>For symbolic regression purposes, there exist several benchmark data sets that can be categorized into two main groups: (1) ground-truth problems (or synthetic data) and ( 2) real-world problems (or real data), as summarized in Figure 18.In this section, we describe each category and discuss its main strength and limitations.</p>
<p>SR Benchmark</p>
<p>Ground-truth problems</p>
<p>Physics equations Mathematics equations</p>
<p>Real-world problems Observations Measurements Ground-truth regression problems are characterized by known mathematical equations, they are listed in Table 6.These include (1) physics-inspired equations [27,60] and (2) real-valued symbolic equations [1,14,15,16,17,18,19,61].The Feynman Symbolic Regression Database [62] is the largest SR database that originates from Feynman lectures on Physics series [63,64] and is proposed in [27].It consists of 1194 physics-inspired equations that describe static physical systems and various physics processes.The proposed equations depend on at least one variable and, at most, nine variables.Each benchmark (corresponding to one equation) is generated by randomly sampling one million entries.Each entry is a row of randomly generated input variables, which are sampled uniformly between 1 and 5.This range of sampling was slightly adjusted for some equations to avoid unphysical results (e.g., division by zero or the square root of a negative number).The output is evaluated using function f , e.g.
D = {x i ∈ R d , y i = f (x 1 , • • • , x d )}.
This benchmark is rich in proposing various theoretical formulae.Still, it suffers a few limitations: (1) there is no distinction between variables and constants, i.e., constants are randomly sampled and, in some cases, in domains extremely far from physical values.For example, the speed of light is sampled from a uniform distribution U(1, 20) whereas its physical value is orders of magnitude higher, i.e., c = 2.988 × 10 8 m/s, and the gravitational constant is sampled from U(1, 2) whereas its physical value is orders of magnitude smaller, G = 6.6743 × 10 −11 m 3 kg −1 s −2 , among others (e.g., vacuum permittivity ∼ 10 −12 , Boltzmann constant k b ∼ 10 −23 , Planck constant h ∼ 10 −34 ).( 2) Some variables are sampled in nonphysical ranges.For example, the gravitational force is defined between two masses distant by r as F = Gm 1 m 2 /r 2 .This force is weak unless defined between significantly massive objects (e.g., the mass of the earth is M e = 5.9722 × 10 24 kg) whereas m 1 and m 2 are sampled in U(1, 5) in the Feynman database.(3) Some variables are treated as floats while they are integers, and (4) many equations are duplicates of each other (e.g., a multiplicative function of two variables f (x, y) = x * y) or have similar functional forms.</p>
<p>The ODE-Strogatz repository [60] consists of ten physics equations that describe the behavior of dynamical systems which can exhibit chaotic and/or non-linear behavior.Each dataset is one state of a two-state system of ordinary differential equations.</p>
<p>Within the same category, there exist several benchmarks [1,14,15,16,17,18,19] consisting of real-valued symbolic functions.The majority of these benchmarks are proposed for GP-based methods and grouped into four categories: polynomial, trigonometric, logarithmic, exponential, and square-root functions, and a combination of univariate and bivariate functions.The suggested functions do not have any physical meaning, and most depend either on one or two independent variables.Datasets are generally generated by randomly sampling either 20 or 100 points in narrow ranges.The most commonly known is the so-called Nguyen benchmark, which consists of 12 symbolic functions taken from [65,66,67].Only four equations have the scalars {1,2,1/2} as constants therein.Each benchmark is defined by a ground-truth expression, training, and test datasets.The equations proposed in these benchmarks can not be found in a single repository.Therefore we list them in the appendix in Tables [7][8][9] and Tables [10][11] for completeness and for easy comparison.</p>
<p>Real-world problems are characterized by an unknown model that underlies data.This category comprises two groups: observations and measurements.Data sets in the observations category can originate from any domain, such as health informatics, environmental science, business, commerce, etc.Data could be collected online or offline from reports or studies.A wide range of problems can be assessed from the following repositories: the PMLB [68], the OpenML [69], and the UCI [70].An exemplary application in this category is wind speed forecasting [71].Measurements represent sets of data points that are collected (and sometimes analyzed) in physics experiments.Here the target model is either an underlying theory than can be derived from first principles or not.In the first case, symbolic regression would either infer the correct model structure and parameters or contribute to the theory development of the studied process, whereas in the second case, the symbolic regression output could be the awaited theory.</p>
<p>Discussion</p>
<p>SR is a growing area of ML and is gaining more attention as interpretability is increasingly promoted [3] in AI applications.SR is propelled by the fact that ML models are becoming very big in parameters at the expense of making accurate predictions.An exemplary application is the chatGPT-4, a large language model comprising hundreds of billions of parameters and trained on hundreds of terabytes of textual data.Such big models are very complicated networks.ChatGPT-4, for example, is accomplishing increasingly complicated and intelligent tasks to the point that it is showing emergent properties [72].However, it is not straightforward to understand when it works and, more importantly, when it does not.In addition, its performance improves with increasing the number of parameters, highlighting that its prediction accuracy depends on the size of the training data set.Therefore, a new paradigm is needed, especially in scientific disciplines, such as physical sciences, where problems are of causal hypothesis-driven nature.SR is by far the most potential candidate to fulfill the interpretability requirements and is expected to play a central role in the future of ML.</p>
<p>Despite the significant advances made in this subfield and the high performance of most deep learning-based SR methods proposed in the literature, still, SR methods fail to recover relatively simple relationships.A case in point is the Nguyen-12 expression, i.e., f (x, y) = x 4 − x 3 + y 2 /2 − y, where x and y are uniformly sampled in the range [0, 1].The NGPPS method could not recover this particular expression using the library basis L = {+, −, ×, ÷, sin, cos, exp, log, x, y}.A variant of this expression, Nguyen-12 , consisting of the same equation but defined over a larger domain, i.e., data points sampled in [0, 10], was successfully covered using the same library, with a recovery rate of 12%.This result is significantly below the perfect performance on all other Nguyen expressions.A similar observation is made for the Livermore-5 whose expression is f (x, y) = x 4 − x 3 + x 2 − y.</p>
<p>We ran NGPPS on Nguyen-12 with two libraries, a pure polynomial basis L 1 = {+, −, ×, ÷, (•) 2 , (•) 3 , (•) 4 , x, y} and a mixed basis L 2 = L 1 ∪ {sin, cos, exp, log, sqrt, expneg}.The algorithm succeeds in recovering Nguyen-12 only using a pure polynomial basis with a recovery rate of 3%.The same observation is made by applying linear SR on Nguyen-12.This highlights how strongly the predicted expression depends on the set of allowable mathematical operations.A practical way to encounter this limitation is to implement basic domain knowledge in SR applications whenever possible.For example, astronomical data collected by detecting the light curves of astronomical objects exhibit periodic behavior.In such cases, periodic functions such as trigonometric functions should be part of the library basis.</p>
<p>Most SR methods are only applied to synthetic data for which the input-output relationship is known.This is justified because the methods must be cross-checked, and their performance must be evaluated using groundtruth expressions.However, the reported results are for synthetic data only.To the best of our knowledge, only one physics application [34] succeeded in extracting New's laws of gravitation by applying SR to astronomical data.The absence of such applications leads us to state that SR is still a relatively nascent area with the potential to make a big impact.Physics in general, and physical sciences in particular, represent a very broad field for SR development purposes and are very rich both in data and expressions, e.g., areas such as astronomy and high-energy physics are very rich in data.In addition, lots of our acquired knowledge in physics can be used for SR methods test purposes because underlying phenomena and equations are well known.All that is needed is greater effort and investment.</p>
<p>Conclusion</p>
<p>This work presents an in-depth introduction to the symbolic regression problem and an expansive review of its methodologies and state-of-the-art applications.Also, this work highlights a number of conclusions that can be made about symbolic regression methods, including (1) linear symbolic regression suffer many limitations, all originating from predefining the model structure, (2) neural network-based methods lead to numerical issues and the library can not include all mathematical operations, (3) expression tree-based methods are yet the most powerful in terms of model performance on synthetic data, in particular transformer-based ones, (4) model predictions strongly depend on the set of allowable operations in the library basis, and (5) generally, deep learning-based methods are performing better than other ML-based methods.</p>
<p>Symbolic regression represents a powerful tool for learning interpretable models in a data-driven manner.Its application is likely to grow in the future because it balances prediction accuracy and interpretability.Despite the limited SR application to real data, the few existing ones are very promising.A potential path to boost progress in this subfield is to apply symbolic regression to experimental data in physics.</p>
<p>Table 10: Feynman physics equation [27].6 F = µN n 2 F = q 1 q 2 /(4π r 2 ) 4 E f = q 1 r/(4π r 3 ) 3
F = q 2 E f 2 F = q(E f + Bv sin(θ)) 5 K = 1/2m(v 2 + u 2 + w 2 ) 4 U = Gm1m2( 1 r2 − 1 r1 ) 5 U = mgz 3 U = 1 2 k spring x 2 2 x = (x − ut)/ 1 − u 2 /c
Figure 1 :
1
Figure 1: (a) Example of a unary-binary tree that encodes f (x) = x 1 x 2 − 2x 3 .(b) Sequence representation of the tree-like structure of f (x).</p>
<p>Figure 4 :
4
Figure 4: Result of linear SR for the Nguyen-1 benchmark, i.e., f (x) = x + x 2 + x 3 .Red points represent (test) data set.The red curve represents the true function.The blue and black dashed curves represent the learned functions using L 1 and L 2 , respectively.</p>
<p>Figure 5 :
5
Figure 5: Two-dimensional multivariate normal distribution used in test applications.</p>
<p>Figure 6 :
6
Figure 6: Difference between true (y) and predicted (ŷ) values of the function y = x 1 (1 + x 2 ) + cos(x 1 ) * sin(x 2 ), for the three libraries defined in Table 4: U1 (left), U2 (center), U3 (right).</p>
<p>Figure 8 :
8
Figure 8: Exemplary setup of a standard NN (8a) and EQL-NN (8b) with input x, output ŷ and two hidden layers.In (a), f denotes the activation function usually chosen among {RELU, tanh, sigmoid} while in EQL each node has a specific activation function drawn from the function class F.</p>
<p>Figure 9 :
9
Figure 9: (a) Expression-tree structure of f (x) = x 2 − cos(x).(b) f (x) as a function of x (blue curve) and data points (red points) generated using f (x).</p>
<p>Figure 10 :
10
Figure 10: Crossover (left) and mutation (right) operations on exemplary expression trees in genetic programming.</p>
<p>Figure 13 :
13
Figure 13: Exemplary sketch of a general RL-based SR method.s t , a t , and r t = R(s t , a t ) denote the state, action, and reward at time step t. (t + 1) denotes the next time step.</p>
<p>Figure 14 :
14
Figure 14: Strategies for solving SR problem.An SR algorithm has three types of input: data (x), a new or reduced representation of the data (x or z), or a model (f (x)) learned from the data.</p>
<p>Figure 15 :
15
Figure 15: Example of a Meijer G-function G 2,2 1,1 ( a,a a,b |x) for different values of a and b [30].</p>
<p>Figure 16 :
16
Figure 16: Exemplary sketch of RNN generating a mathematical expression x 2 − cos(x).</p>
<p>GP = T RN N .Each iteration of the proposed algorithm consists of 4 steps: (1) The batch of expressions sampled by RNN is passed as a starting population to GP, (2) S generations of GP are performed and result in a final GP population T S GP , (3) An elite set of top-performing GP samples is selected T E GP and passed to the gradient update of RNN.</p>
<p>Figure 17 :
17
Figure 17: Neural-guided genetic programming population seeding method overview [29].</p>
<p>Figure 18 :
18
Figure 18: Taxonomy based on the type of SR benchmark problems.</p>
<p>f 3 A
3
= exp(−θ 2 /2)/ (2π) 1 f = exp(−(θ/σ) 2 /2)/( (2π)σ) 2 f = exp(−((θ − θ 1 )/σ) 2 /2)/( (2π)σ) 3 d = (x 2 − x 1 ) 2 + (y 2 − y 1 ) 2 4 F = Gm1m2 ((x2−x1) 2 +(y2−y1) 2 +(z2−z1) = x 1 y 1 + x 2 y 2 + x 3 y 3</p>
<p>2 4 t 2 E = µ M B 2 x + B 2 y + B 2 zL
42222
= (t − ux/c 2 )/ 1 − u 2 /c 2 4 p = m 0 v/ 1 − v 2 /c 2 3 v = (u + v)/(1 + uv/c 2 ) 3 r = (m 1 r 1 + m 2 r 2 )/(m1 + m2) 4 τ = rF sin(θ) 3 L = mrv sin(θ) 4 E = 1 4 m(ω 2 + ω 2 0 )x 2 4 V e = q/C 2 θ 1 = arcsin(n sin(θ2)) 2 f f = 1/( 1 d1 + n d2 ) 3 k = ω/c 2 x = x 2 1 + x 2 2 − 2x 1 x 2 cos(θ 1 − θ 2 ) 4 I = I 0 sin 2 (nθ/2)/ sin 2 (θ/2) 3 θ = arcsin(λ/nd) 3 P = q 2 a 2 /(6π c 3 ) 4 P = (1/2 cE 2 f )(8πr 2 /3)(ω 4 /(ω 2 − ω 2 0 ) 2 ) 6 ω = qvB/p 4 ω = ω 0 /(1 − v/c) 3 ω = (1 + v/c)/ 1 − v 2 /c 2 ω 0 3 E = hω 2 I = I 1 + I 2 + 2 √ I 1 I 2 cos(δ) 3 r = 4π h2 /(mq 2 ) 4 E = 3 2 p F V 2 E = 1/(γ − 1)p F V 3 P F = nkb T /V 4 Function form #v n = n 0 exp(−mgx/(k b T )) L rad = hω 3 /(π 2 c 2 (exp( hω/(k b T )) − 1)) v = mu drif t qV e /d D = µ e k b T κ = 1/(γ − 1)k b v/A E = nk b T ln( V 2 V 1 ) c = (γpr/ρ) E = mc 2 / 1 − v 2 /c 2 x = x 1 (cos(ωt) + α cos(ωt) 2 ) P = κ(T 2 − T 1 )A/d F E = P wr/(4πr 2 ) V e = q/(4π r) V e = 1 4π p d cos(θ)/r 2 E f = 3 4π p d z/r 5 x 2 + y 2 E f = 3 4π p d cos(θ) sin(θ)/r 3 E = 3 5 q 2 /(4π d) E den = Ef 2 /2 E f = σ den / 1/(1 + χ) x = qE f /(m(ω 2 0 − ω 2 )) n = n 0 (1 + p d E f cos(θ)/(k b T )) P = n rho p 2 d E f /(3k b T ) P = nα/(1 − (nα/3)) E f θ = 1 + nα/(1 − (nα/3)) B = 1/(4π c 2 )2I/r ρ c = ρ c0 / 1 − v 2 /c 2 j = ρ c0 v/ 1 − v 2 /c 2 E = −µ M B cos(θ) E = −p d E f cos(θ) V e = q/(4π r(1 − v/c)) k = ω 2 /c 2 − π 2 /d 2 F E = cE 2 f E den = E 2 f I = qv/(2πr) µ M = qvr/2 ω = gqB/(2m) µ M = q h/(2m) E = gµ M BJ z / h M = n rho µ M tanh(µ M B/(k b T )) f = µ m B/(k b T ) + (µ m α)/( c 2 k b T )M E = µ M (1 + χ)B F = Y A x /d µ S = Y /(2(1 + σ)) E = hω/(exp( hω/(k b T )) − 1)Table11: Feynman physics equation[27].Function form # variablesn = 1/(exp( hω/(k b T )) − 1) n = n 0 /(exp(µ m B/(k b T )) + exp(−µ m B/(k b T ))) ω = 2µ M B/ h p γ = sin(E n t/ h) 2 p γ = (p d E f t/ h) sin((ω − ω 0 )t/2) 2 /((ω − ω 0 )t/2) = n h v = 2En d 2 k/ h I = I 0 (exp(qV e /(k b T )) − 1) E = 2U (1 − cos(kd)) m = h2 /(2E n d 2 ) k = 2πα/(nd) f = β(1 + α cos(θ)) E = −mq 4 /(2(4π ) 2h2 )(1/n 2 ) j = −ρ c0 qA vec /m</p>
<p>Table 1 :
1
Table summarizing symbolic regression methods.The mathematical tool, the expression form, the set of unknowns, and the search space are specified for each method.Set2seq abbreviates "set-to-sequence".
MethodToolExpression form UnkownSearch spaceLinear SRUni-D linear systemy</p>
<p>Table 2 :
2
Results of linear SR in the case of univariate functions.</p>
<p>Table 4 :
4
Library bases used in test problems of Sec.4.1.2
Name List of functionsU1Library</p>
<p>Table 5 :
5
Table summarizing symbolic regression applications.D refers to data input, 1 refers to data representation input, and 2 refers to model input to SR.
Application Ref Name/description(code)Year MethodStrategySINDY[51] Sparse Identification of Nonlinear Dynamics link2016 LinearDSINDY-AE [33] Data-driven discovery of coordinates and gov-2019 Linear1erning equations (https://github.com/kpchamp/SindyAutoencoders)EQL[47] Equationlearner(https://github.com/2016 non linearDKristofPusztai/EQL)EQL÷[48] Equation learner division (https://github.com/2018 Non linearDmartius-lab/EQL)Eureqa[26] Commercial software2011 GPDFFX[20] Fast function extraction (https://github.com/2011 GPDnatekupp/ffx/tree/master/ffx)ITEA[22] Interaction-Transformation Evolutionary Algorithm2019 GPDfor SR (https://github.com/folivetti/ITEA/)MRGP[23] Multiple Regression GP (https://github.com/2014 GPDflexgp/gp-learners)E2ESR[31] End-to-endSRwithtransformers2022 TNND(https://github.com/facebookresearch/symbolicregression)NeSymReS [32] NeuralSRthatscales(https://2021 TNNDgithub.com/SymposiumOrganization/NeuralSymbolicRegressionThatScales)DSR[19] Deep symbolic regression (https://github.com/2019 RNN,RLDbrendenpetersen/deep-symbolic-regression)NGPPS[29] SR via Neural-Guided GP population seed-2021 RNN,GP,RLDing(https://github.com/brendenpetersen/deep-symbolic-regression)AIFeynman [27] Physics-inspired method for SR (https://github.2019 Physics-informed 1com/SJ001/AI-Feynman)SM[30] Symbolic Metamodel (https://bitbucket.org/2019 Mathematics2mvdschaar/mlforhealthlabpub)GNN[52] Discovering Symbolic Models from DL with Induc-2020 GNN2tive Biases (https://github.com/MilesCranmer/symbolic_deep_learning)HEAL[53] Heuristic and Evolutionary Algorithms Labo-−HeuristicDratory(https://github.com/heal-research/HeuristicLab)</p>
<p>Table 6 :
6
Table summarizing ground-truth problems for symbolic regression.
TypeBenchmarkNumber of problems Year ReferencePhysics-relatedFeynman Database1192019 [27]Strogatz Repository 102011 [60]Koza31994 [1]Keijzer152003 [14]Vladislavleva82009 [15]Mathematics-relatedNguyen Korns12 152011 [17] 2011 [16]R32013 [61]Jin62019 [18]Livermore222021 [19]
k is the electric force (or Coulomb) constant, k = 8.9875517923 × 10 9 kg•m 3 •s −4 •A −2 in SI base units.
Technically the pseudo-inverse, U +
Dimensional analysis is a well-known technique in physics that uses set of units of measurements to solve an equation and/or to check the correctness of a given equation.
The equation number II.11.17 is missing in the benchmark repository.
A Datasets Benchmarks EquationsTable7: Ground-truth expressions for Koza[73], Nguyen[17], Jin[18], Keijzer[14]and R[61]benchmarks.DatasetExpression Variables Data range Koza-1 5Nguyen-1x 3 e −x cos(x) sin(x)(sin 2 (x) cos(x) − 1) 1 E[0, 10, 0.05]Table8: Ground-truth expressions for Korns[16]and Livermore[19]Livermore-9Table9: Ground-truth expressions for Vladislavleva[15]benchmark.Dataset Expression Variables Data rangeVladislavleva-1 e −(x−1) 2 1.2+(y−2.5) 2
Genetic programming as a means for programming computers by natural selection. J R Koza, Proceedings of the National Academy of Sciences. the National Academy of Sciences19944</p>
<p>Distilling free-form natural laws from experimental data. M Schmidt, H Lipson, Science. 32459232009</p>
<p>Stop explaining black box machine learning models for high stakes decisions and use interpretable models instead. C Rudin, Nature Machine Intelligence. 152019</p>
<p>Systematic poisoning attacks on and defenses for machine learning in healthcare. M Mozaffari-Kermani, S Sur-Kolay, A Raghunathan, N K Jha, IEEE Journal of Biomedical and Health Informatics. 1962015</p>
<p>J Kepler, Epitome astronomiae Copernicanae. Noscemus Wiki, </p>
<p>The Mathematical Principles of Natural Philosophy. I Newton, A Motte, J Machin, The Mathematical Principles of Natural Philosophy. B Motte, London11729</p>
<p>Information processing, data inferences, and scientific generalization. D Gerwin, Systems Research and Behavioral Science. 191974</p>
<p>Data-driven discovery of physical laws. P Langley, Cognitive Science. 511981</p>
<p>Integrating quantitative and qualitative discovery: The abacus system. B C Falkenhainer, R S Michalski, Mach. Learn. 1mar 1986</p>
<p>Bacon: A production system that discovers empirical laws. L P W , 1979</p>
<p>P Langley, H A Simon, G L Bradshaw, J M Zytkow, Scientific Discovery: Computational Explorations of the Creative Process. Cambridge, MA, USAMIT Press1987</p>
<p>Hierarchical genetic algorithms operating on populations of computer programs. J R Koza, IJCAI'89Proceedings of the 11th International Joint Conference on Artificial Intelligence. the 11th International Joint Conference on Artificial IntelligenceSan Francisco, CA, USAMorgan Kaufmann Publishers Inc19891</p>
<p>Genetic programming: A paradigm for genetically breeding populations of computer programs to solve problems. J R Koza, tech. rep. 1990</p>
<p>Improving symbolic regression with interval arithmetic and linear scaling. M Keijzer, Genetic Programming. C Ryan, T Soule, M Keijzer, E Tsang, R Poli, E Costa, Berlin, Heidelberg; Berlin HeidelbergSpringer2003</p>
<p>Order of nonlinearity as a complexity measure for models generated by symbolic regression via pareto genetic programming. E Vladislavleva, G Smits, D Hertog, IEEE Transactions on Evolutionary Computation. 132009</p>
<p>M F Korns, Accuracy in Symbolic Regression. New York, NY; New YorkSpringer2011</p>
<p>Semantically-based crossover in genetic programming: application to real-valued symbolic regression. N Q Uy, N X Hoai, M O'neill, R I Mckay, E G López, Genetic Programming and Evolvable Machines. 122010</p>
<p>Bayesian symbolic regression. Y Jin, W Fu, J Kang, J Guo, J Guo, 2019</p>
<p>Deep symbolic regression: Recovering mathematical expressions from data via policy gradients. B K Petersen, CoRR. 1912.04871, 2019</p>
<p>T Mcconaghy, FFX: Fast, Scalable, Deterministic Symbolic Regression Technology. New York, NY; New YorkSpringer2011</p>
<p>A model-based genetic programming approach for symbolic regression of small expressions. M Virgolin, T Alderliesten, C Witteveen, P A N Bosman, CoRR. 1904.02050, 2019</p>
<p>Interaction-transformation evolutionary algorithm for symbolic regression. F O De França, G S I Aldeia, CoRR. 1902.03983, 2019</p>
<p>Multiple regression genetic programming. I Arnaldo, K Krawiec, U.-M O'reilly, Proceedings of the 2014 Annual Conference on Genetic and Evolutionary Computation, GECCO '14. the 2014 Annual Conference on Genetic and Evolutionary Computation, GECCO '14New York, NY, USAAssociation for Computing Machinery2014</p>
<p>Stochastic optimization approaches to learning concise representations. W G L Cava, T R Singh, J Taggart, S Suri, J H Moore, abs/1807.00981CoRR. 2018</p>
<p>A living review of symbolic regression. N Makke, S Chawla, 2022</p>
<p>Eureqa: software review. R Dubcakova, Genetic Programming and Evolvable Machines. 12June 2011</p>
<p>Ai feynman: a physics-inspired method for symbolic regression. S.-M Udrescu, M Tegmark, 2019</p>
<p>Extrapolation and learning equations. G Martius, C H Lampert, abs/1610.02995CoRR. 2016</p>
<p>Symbolic regression via neural-guided genetic programming population seeding. T N Mundhenk, M Landajuela, R Glatt, C P Santiago, D M Faissol, B K Petersen, abs/2111.00053CoRR. 2021</p>
<p>Demystifying black-box models with symbolic metamodels. A M Alaa, M Van Der Schaar, Advances in Neural Information Processing Systems. H Wallach, H Larochelle, A Beygelzimer, F Alché-Buc, E Fox, R Garnett, New YorkCurran Associates, Inc201932</p>
<p>End-to-end symbolic regression with transformers. P.-A Kamienny, S Ascoli, G Lample, F Charton, 2022</p>
<p>Neural symbolic regression that scales. L Biggio, T Bendinelli, A Neitz, A Lucchi, G Parascandolo, abs/2106.064272021CoRR</p>
<p>Data-driven discovery of coordinates and governing equations. K Champion, B Lusch, J N Kutz, S L Brunton, Proceedings of the National Academy of Sciences. 116452019</p>
<p>Rediscovering orbital mechanics with machine learning. P Lemos, N Jeffrey, M Cranmer, S Ho, P Battaglia, 2022</p>
<p>Emerging materials intelligence ecosystems propelled by machine learning. R Batra, L Song, R Ramprasad, Nature Reviews Materials. 6Nov. 2020</p>
<p>Fast, accurate, and transferable many-body interatomic potentials by symbolic regression. A Hernandez, A Balasubramanian, F Yuan, S Mason, T Mueller, 2019</p>
<p>Symbolic regression in materials science. Y Wang, N Wagner, J M Rondinelli, MRS Communications. 9sep 2019</p>
<p>Simple descriptor derived from symbolic regression accelerating the discovery of new perovskite catalysts. B Weng, Z Song, R Zhu, Q Yan, Q Sun, C G Grice, Y Yan, W.-J Yin, Nature Communications. 112020</p>
<p>A novel method based on symbolic regression for interpretable semantic similarity measurement. J Martinez-Gil, J M Chaves-Gonzalez, Expert Systems with Applications. 1601136632020</p>
<p>Symbolic regression for scientific discovery: an application to wind speed forecasting. I A Abdellaoui, S Mehrkanoon, 2021 IEEE Symposium Series on Computational Intelligence (SSCI). 2021</p>
<p>Machine learning for the prediction of pseudorealistic pediatric abdominal phantoms for radiation dose reconstruction. M Virgolin, Z Wang, T Alderliesten, P A N Bosman, Journal of Medical Imaging. 74465012020</p>
<p>Contemporary symbolic regression methods and their relative performance. W G L Cava, P Orzechowski, B Burlacu, F O De França, M Virgolin, Y Jin, M Kommenda, J H Moore, CoRR. 2021</p>
<p>Principles of risk minimization for learning theory. V Vapnik, Advances in Neural Information Processing Systems. J Moody, S Hanson, R Lippmann, Cambridge, MassachusettsMorgan-Kaufmann19914</p>
<p>Symbolic regression is np-hard. M Virgolin, S P Pissis, 2022</p>
<p>Jan Lukasiewicz: Aristotle's syllogistic from the standpoint of modern formal logic. R Robinson, The Classical Review. 83-41958second edition enlarged. pp. xvi 222. oxford: Clarendon press, 1957. cloth, 305. net.</p>
<p>Attention is all you need. A Vaswani, N Shazeer, N Parmar, J Uszkoreit, L Jones, A N Gomez, L Kaiser, I Polosukhin, 1706.03762CoRR. 2017</p>
<p>Extrapolation and learning equations. G Martius, C H Lampert, abs/1610.02995CoRR. 2016</p>
<p>Learning equations for extrapolation and control. S S Sahoo, C H Lampert, G Martius, abs/1806.07259CoRR. 2018</p>
<p>Symbolicgpt: A generative transformer model for symbolic regression. M Valipour, B You, M Panju, A Ghodsi, 2106.14131, 2021CoRR</p>
<p>Reinforcement Learning: An Introduction. R S Sutton, A G Barto, 2018A Bradford BookCambridge, MA, USA</p>
<p>Discovering governing equations from data by sparse identification of nonlinear dynamical systems. S L Brunton, J L Proctor, J N Kutz, Proceedings of the National Academy of Sciences. 113152016</p>
<p>Discovering symbolic models from deep learning with inductive biases. M D Cranmer, A Sanchez-Gonzalez, P W Battaglia, R Xu, K Cranmer, D N Spergel, S Ho, CoRR. 2006.11287. 2020</p>
<p>. E A Heuristic, Laboratory, </p>
<p>Inference of compact nonlinear dynamic models by epigenetic local search. W La Cava, K Danai, L Spector, Engineering Applications of Artificial Intelligence. 552016</p>
<p>Learning Internal Representations by Error Propagation. D E Rumelhart, G E Hinton, R J Williams, 1986MIT PressCambridge, MA, USA</p>
<p>Discovering state variables hidden in experimental data. B Chen, K Huang, S Raghupathi, I Chandratreya, Q Du, H Lipson, 2021</p>
<p>On the g-function. C Meijer, 1946North-HollandNetherlands</p>
<p>Meijer g-functions: a gentle introduction. R Beals, J Szmigielski, Notices of the American Mathematical Society. 602013</p>
<p>Simple statistical gradient-following algorithms for connectionist reinforcement learning. R J Williams, Mach. Learn. 8may 1992</p>
<p>Inference of compact nonlinear dynamic models by epigenetic local search. W La Cava, K Danai, L Spector, Engineering Applications of Artificial Intelligence. 552016</p>
<p>Approximating geometric crossover by semantic backpropagation. K Krawiec, T Pawlak, Proceedings of the 15th Annual Conference on Genetic and Evolutionary Computation, GECCO '13. the 15th Annual Conference on Genetic and Evolutionary Computation, GECCO '13New York, NY, USAAssociation for Computing Machinery2013</p>
<p>The feynman symbolic regression database. M Tegmark, May 2019</p>
<p>R Feynman, R Leighton, M Sands, The New Millennium Edition: Mainly Mechanics, Radiation, and Heat. The Feynman Lectures on Physics. New YorkBasic Books2011IThe Feynman Lectures on Physics</p>
<p>R Feynman, R Leighton, M Sands, M Gottlieb, The Feynman Lectures on Physics. BostonPearson/Addison-Wesley20062</p>
<p>Improving symbolic regression with interval arithmetic and linear scaling. M Keijzer, Genetic Programming. C Ryan, T Soule, M Keijzer, E Tsang, R Poli, E Costa, Berlin, Heidelberg; Berlin HeidelbergSpringer2003</p>
<p>Solving the symbolic regression problem with tree-adjunct grammar guided genetic programming: the comparative results. N Hoai, R Mckay, D Essam, R Chau, Proceedings of the 2002 Congress on Evolutionary Computation. CEC'02 (Cat. No.02TH8600). the 2002 Congress on Evolutionary Computation. CEC'02 (Cat. No.02TH8600)20022</p>
<p>Genetic programming crossover: Does it cross over?. C G Johnson, Genetic Programming. L Vanneschi, S Gustafson, A Moraglio, I De Falco, M Ebner, Berlin, Heidelberg; Berlin HeidelbergSpringer2009</p>
<p>Pmlb: a large benchmark suite for machine learning evaluation and comparison. R S Olson, W La Cava, P Orzechowski, R J Urbanowicz, J H Moore, BioData Mining. 10Dec 2017</p>
<p>Openml: networked science in machine learning. J Vanschoren, J N Van Rijn, B Bischl, L Torgo, SIGKDD Explorations. 201315</p>
<p>UCI machine learning repository. D Dua, C Graff, 2017</p>
<p>Symbolic regression for scientific discovery: an application to wind speed forecasting. I A Abdellaoui, S Mehrkanoon, 2021</p>
<p>. J Wei, Y Tay, R Bommasani, C Raffel, B Zoph, S Borgeaud, D Yogatama, M Bosma, D Zhou, D Metzler, E H Chi, T Hashimoto, O Vinyals, P Liang, J Dean, W Fedus, 2022Emergent abilities of large language models</p>
<p>Genetic programming ii: Automatic discovery of reusable programs. U.-M O'reilly, Artificial Life. 141994</p>            </div>
        </div>

    </div>
</body>
</html>