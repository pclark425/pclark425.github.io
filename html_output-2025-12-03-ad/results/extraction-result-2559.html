<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-2559 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-2559</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-2559</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-65.html">extraction-schema-65</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of multi-agent AI systems that coordinate to perform scientific research tasks, including details about their coordination mechanisms, communication protocols, feedback mechanisms, agent specializations, and performance results.</div>
                <p><strong>Paper ID:</strong> paper-d1120d67b700e4dfe8b39eb1e48fbdea4e1a0c43</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/d1120d67b700e4dfe8b39eb1e48fbdea4e1a0c43" target="_blank">HuggingGPT: Solving AI Tasks with ChatGPT and its Friends in Hugging Face</a></p>
                <p><strong>Paper Venue:</strong> Neural Information Processing Systems</p>
                <p><strong>Paper TL;DR:</strong> HuggingGPT is an LLM-powered agent that leverages LLMs (e.g., ChatGPT) to connect various AI models in machine learning communities to solve AI tasks and can tackle a wide range of sophisticated AI tasks spanning different modalities and domains.</p>
                <p><strong>Paper Abstract:</strong> Solving complicated AI tasks with different domains and modalities is a key step toward artificial general intelligence. While there are numerous AI models available for various domains and modalities, they cannot handle complicated AI tasks autonomously. Considering large language models (LLMs) have exhibited exceptional abilities in language understanding, generation, interaction, and reasoning, we advocate that LLMs could act as a controller to manage existing AI models to solve complicated AI tasks, with language serving as a generic interface to empower this. Based on this philosophy, we present HuggingGPT, an LLM-powered agent that leverages LLMs (e.g., ChatGPT) to connect various AI models in machine learning communities (e.g., Hugging Face) to solve AI tasks. Specifically, we use ChatGPT to conduct task planning when receiving a user request, select models according to their function descriptions available in Hugging Face, execute each subtask with the selected AI model, and summarize the response according to the execution results. By leveraging the strong language capability of ChatGPT and abundant AI models in Hugging Face, HuggingGPT can tackle a wide range of sophisticated AI tasks spanning different modalities and domains and achieve impressive results in language, vision, speech, and other challenging tasks, which paves a new way towards the realization of artificial general intelligence.</p>
                <p><strong>Cost:</strong> 0.019</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e2559.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e2559.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of multi-agent AI systems that coordinate to perform scientific research tasks, including details about their coordination mechanisms, communication protocols, feedback mechanisms, agent specializations, and performance results.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>HuggingGPT</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>HuggingGPT: Solving AI Tasks with ChatGPT and its Friends in Hugging Face</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A multi-model collaborative system that uses a large language model (LLM) as a centralized controller to plan, select, orchestrate, and integrate the execution of many expert models (from Hugging Face) to solve complex multimodal AI tasks across language, vision, speech and cross-modality.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>HuggingGPT</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>HuggingGPT is an LLM-powered multi-agent framework where a single LLM (e.g., ChatGPT / GPT-3.5 / GPT-4) acts as a centralized controller to (1) parse a user's request into a structured task graph, (2) select suitable expert models hosted in the Hugging Face model hub for each subtask using model descriptions, (3) invoke and execute the selected expert models on local or cloud inference endpoints, handling resource dependencies and parallel execution where possible, and (4) aggregate structured inference outputs into a human-readable final response. The system uses language (prompts and model descriptions) as the generic interface between controller and expert models, a JSON task template for structured planning, and a '<resource>-task_id' token convention to wire outputs from prerequisite tasks into dependent tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>number_of_agents</strong></td>
                            <td>variable (1 centralized LLM controller + many 'expert model' agents; system supports invocation of many models and currently supports 24 task types)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_specializations</strong></td>
                            <td>1) Controller agent (LLM): task planning, model selection, orchestration, and response generation; 2) Expert model agents: specialized executors each implementing a narrow task (examples include image captioning, object detection, image classification, text-to-image, text-to-speech, ASR, VQA, document QA, segmentation, depth estimation, video generation, audio generation, etc.); 3) Hybrid endpoints (deployment components): local inference endpoints for speed/stability and cloud endpoints (Hugging Face) for breadth. Each expert is specialized by task type and model description (e.g., DETR-resnet-101 for object detection, vit-gpt2 for image captioning, stable-diffusion for text-to-image).</td>
                        </tr>
                        <tr>
                            <td><strong>research_phases_covered</strong></td>
                            <td>Primarily: planning (task decomposition), implementation/selection (model selection and deployment), execution (model inference), and evaluation/aggregation (integrating model outputs and generating final responses). It does not perform autonomous literature review or experiment design beyond decomposing user requests; it supports inference-level execution and result aggregation rather than training new models.</td>
                        </tr>
                        <tr>
                            <td><strong>coordination_mechanism</strong></td>
                            <td>Centralized controller architecture: the LLM functions as a single centralized planner and scheduler (global planning strategy), producing a structured task graph with explicit dependencies. The controller assigns tasks to expert models, manages execution order (serial and parallel execution depending on resource dependencies), and resolves resource passing using a token convention. The system implements 'global planning' (one-shot generation of full task queue) rather than iterative stepwise planning, although discussions compare both approaches.</td>
                        </tr>
                        <tr>
                            <td><strong>communication_protocol</strong></td>
                            <td>Language-based and structured messages: communication between controller and model registry uses natural-language model descriptions embedded in prompts; task specifications and inter-component messages use structured JSON templates (task entries with fields 'task','id','dep','args'); resource passing between tasks uses a special '<resource>-task_id' placeholder which is dynamically replaced at execution time; inference outputs are returned as structured data (e.g., bounding boxes, answer distributions, file paths) and fed back to the LLM for aggregation. Interactions with LLMs and models are done via API calls (OpenAI API for LLM; Hugging Face/cloud or local inference endpoints for models).</td>
                        </tr>
                        <tr>
                            <td><strong>feedback_mechanism</strong></td>
                            <td>No continuous peer-review loop between expert models is implemented; feedback is centralized through the LLM which ingests structured inference results and can re-plan if needed. For evaluation, the authors use external critics (GPT-4 as an evaluator/critic for task-planning correctness) and human expert evaluation (passing rate, rationality, success rate). Internally the system resolves resource dependencies deterministically by replacing '<resource>-task_id' tokens with produced resources; there is no described iterative refinement loop among expert model agents beyond the controller re-invoking models as part of a new plan if necessary.</td>
                        </tr>
                        <tr>
                            <td><strong>communication_frequency</strong></td>
                            <td>Stage-driven/on-demand: communication occurs at stage transitions — (1) LLM performs task planning and emits structured task graph, (2) model selection step where LLM selects models (in-context selection), (3) executor layer triggers model invocations (can run tasks in parallel when independent), (4) results returned to LLM for response generation. Thus agents communicate on-demand at each pipeline stage and after individual model execution; independent tasks may run concurrently.</td>
                        </tr>
                        <tr>
                            <td><strong>task_domain</strong></td>
                            <td>Applied to general AI tasks across modalities (language, vision, speech, audio, video, cross-modality) — i.e., professional AI task automation rather than domain-specific scientific discovery like drug design; primary domain: machine learning / multimodal AI application workflows.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Reported metrics focus on controller (task-planning) effectiveness and human evaluation of end-to-end success. Key quantitative results reported: task-planning (on GPT-4-annotated dataset): for graph tasks GPT-3.5 achieved GPT-4 Score 50.48, Precision 54.90, Recall 49.23, F1 51.91; sequential tasks (GPT-3.5) Edit Distance 0.54, Precision 61.09, Recall 45.15, F1 51.92. Human-annotated dataset: GPT-4 achieves higher planning accuracy (e.g., GPT-4 Acc for sequential tasks 41.36, Graph Acc 58.33). Human evaluation (130 requests): GPT-3.5: Task Planning Passing Rate 91.22%, Rationality 78.47%; Model Selection Passing Rate 93.89%, Rationality 84.29%; Response Success Rate 63.08%. Comparisons for open-source LLMs: Alpaca-13b Response Success Rate 6.92%, Vicuna-13b 15.64%.</td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td>Compared the central LLM controller variants (Alpaca-7b/13b, Vicuna-7b/13b, GPT-3.5, GPT-4) on planning and end-to-end tasks. Results show stronger LLMs (GPT-3.5/GPT-4) produce substantially better task planning and higher human-evaluated success rates than smaller open-source LLMs (Alpaca, Vicuna). No direct comparison to a decentralized or non-LLM orchestration baseline is provided; baseline comparisons focus on different LLM controllers and human annotations/GPT-4 critic labels.</td>
                        </tr>
                        <tr>
                            <td><strong>coordination_benefits</strong></td>
                            <td>Coordination enables multimodal problem decomposition and use of task-specialist models, leading to ability to solve complex multi-step and cross-modality requests that single LLMs or single specialist models could not. Quantitative benefits: much higher passing/success rates when using stronger LLM controllers (GPT-3.5 success rate 63.08% vs Alpaca-13b 6.92%); better planning F1/accuracy. System also benefits from parallel execution of independent tasks to improve throughput. Qualitatively: integrates best-of-breed specialized models for improved modality-specific performance (e.g., fine-tuned detectors for detection subtask rather than LLM hallucination).</td>
                        </tr>
                        <tr>
                            <td><strong>coordination_challenges</strong></td>
                            <td>Reported challenges include: heavy reliance on LLM planning quality (plans may be infeasible or suboptimal); efficiency and latency (multiple LLM interactions increase time cost); token length/context limits when including many model descriptions; instability/uncontrollability of LLM outputs (may not follow instructions or produce incorrect answers causing workflow exceptions); deployment complexity (need for hybrid endpoints and prioritization between local vs cloud).</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_studies</strong></td>
                            <td>Ablations analyzed the effect of few-shot demonstrations (number and variety) on task-planning performance. Results: increasing demonstration variety improves planning moderately; adding demonstrations helps but gains plateau after ~4 examples. Table 7 and Figure 3 provide quantitative evidence (e.g., GPT-3.5 single-task F1 increases from ~48.29 with 2 demo variety to ~53.70 with 10; GPT-4 single-task F1 increases from ~67.08 to ~71.05). No ablation isolating the coordinator/controller vs decentralized orchestration or removing resource-dependency mechanism was reported.</td>
                        </tr>
                        <tr>
                            <td><strong>optimal_configurations</strong></td>
                            <td>Paper suggests practical settings rather than a single 'optimal' config: use a powerful LLM controller (GPT-3.5/GPT-4) for better planning; employ a dynamic in-context task-model assignment filtered by task type and top-K ranking (by downloads) to reduce prompt tokens; prioritize local inference endpoints for speed/stability and fallback to cloud endpoints; use a few (≈4) diverse demonstrations to improve planning with diminishing returns beyond that; utilize global planning (one-shot full task graph) with explicit resource dependency markers ('<resource>-task_id') for deterministic orchestration.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e2559.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e2559.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of multi-agent AI systems that coordinate to perform scientific research tasks, including details about their coordination mechanisms, communication protocols, feedback mechanisms, agent specializations, and performance results.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Toolformer</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Toolformer: Language Models Can Teach Themselves to Use Tools</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A system that trains large language models to call external APIs / tools by inserting API-call tags into corpora and learning when to use them, enabling LLMs to augment generation with tool use.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Toolformer: Language Models Can Teach Themselves to Use Tools</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Toolformer</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Toolformer augments LLMs by teaching them when and how to call external tools/APIs, using inserted API call tags in training corpora so the model learns to incorporate tool-usage during generation. It is an approach to integrate external functionality rather than a multi-agent orchestration framework per se.</td>
                        </tr>
                        <tr>
                            <td><strong>number_of_agents</strong></td>
                            <td>N/A (primarily an augmentation to a single LLM to call external tools)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_specializations</strong></td>
                            <td>Not a multi-agent decomposition; the single LLM learns to call specialized external tools (search, calculator, etc.) as needed.</td>
                        </tr>
                        <tr>
                            <td><strong>research_phases_covered</strong></td>
                            <td>Tool usage during inference/generation (execution phase); enables access to external capabilities rather than comprehensive research pipeline orchestration.</td>
                        </tr>
                        <tr>
                            <td><strong>coordination_mechanism</strong></td>
                            <td>Single LLM decides tool calls internally; no decentralized agent coordination described in this paper's mention.</td>
                        </tr>
                        <tr>
                            <td><strong>communication_protocol</strong></td>
                            <td>API-call tags within generated text sequences; calls to external tools via standardized tags and API formats.</td>
                        </tr>
                        <tr>
                            <td><strong>feedback_mechanism</strong></td>
                            <td>Self-supervised learning of when to call tools during pretraining; not a peer-feedback multi-agent loop.</td>
                        </tr>
                        <tr>
                            <td><strong>communication_frequency</strong></td>
                            <td>On-demand during generation when the LLM decides to call a tool.</td>
                        </tr>
                        <tr>
                            <td><strong>task_domain</strong></td>
                            <td>General NLP/tool-augmented generation tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td>Mentioned as related work; no direct experimental comparison in HuggingGPT paper.</td>
                        </tr>
                        <tr>
                            <td><strong>coordination_benefits</strong></td>
                            <td>Demonstrates that LLMs can learn when to call external tools, improving task performance for operations better handled by specialized tools.</td>
                        </tr>
                        <tr>
                            <td><strong>coordination_challenges</strong></td>
                            <td>Not detailed in HuggingGPT paper beyond being related work; general challenges include designing tags, correct tool selection, and training signals.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_studies</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>optimal_configurations</strong></td>
                            <td>Not specified in HuggingGPT; Toolformer literature suggests learning signals and careful integration of tool calls.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e2559.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e2559.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of multi-agent AI systems that coordinate to perform scientific research tasks, including details about their coordination mechanisms, communication protocols, feedback mechanisms, agent specializations, and performance results.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Visual ChatGPT</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Visual ChatGPT: Talking, Drawing and Editing with Visual Foundation Models</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A system that integrates visual foundation models with an LLM to provide multimodal conversational capabilities by chaining vision models and using the LLM to orchestrate operations.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Visual ChatGPT: Talking, Drawing and Editing with Visual Foundation Models</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Visual ChatGPT</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Visual ChatGPT connects an LLM with a set of visual foundation models (e.g., BLIP, ControlNet) to allow conversational interaction over images, where the LLM issues commands to and composes outputs from visual models to perform perception and visual editing tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>number_of_agents</strong></td>
                            <td>variable (LLM controller + multiple visual foundation models)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_specializations</strong></td>
                            <td>LLM for language and orchestration; various visual models for perception, editing, and generation.</td>
                        </tr>
                        <tr>
                            <td><strong>research_phases_covered</strong></td>
                            <td>Execution and aggregation of multimodal perception and generation tasks; conversational interaction.</td>
                        </tr>
                        <tr>
                            <td><strong>coordination_mechanism</strong></td>
                            <td>LLM-driven orchestration chaining calls to visual models, similar to a centralized controller approach.</td>
                        </tr>
                        <tr>
                            <td><strong>communication_protocol</strong></td>
                            <td>Natural language commands and a programmatic chaining of model calls (often mediated by code or structured prompts).</td>
                        </tr>
                        <tr>
                            <td><strong>feedback_mechanism</strong></td>
                            <td>LLM integrates model outputs and can issue further calls; iterative back-and-forth mediated by the LLM but no decentralized peer review.</td>
                        </tr>
                        <tr>
                            <td><strong>communication_frequency</strong></td>
                            <td>On-demand during conversational turns and model chaining.</td>
                        </tr>
                        <tr>
                            <td><strong>task_domain</strong></td>
                            <td>Vision + language multimodal tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td>Mentioned as related work; no direct experimental baseline in HuggingGPT paper.</td>
                        </tr>
                        <tr>
                            <td><strong>coordination_benefits</strong></td>
                            <td>Enables complex visual editing and Q&A by composing specialized vision models under LLM control.</td>
                        </tr>
                        <tr>
                            <td><strong>coordination_challenges</strong></td>
                            <td>Similar challenges around chaining reliability, context length, and latency are discussed in HuggingGPT.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_studies</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>optimal_configurations</strong></td>
                            <td>Not specified in HuggingGPT; Visual ChatGPT literature emphasizes choosing appropriate vision models and prompt engineering for orchestration.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e2559.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e2559.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of multi-agent AI systems that coordinate to perform scientific research tasks, including details about their coordination mechanisms, communication protocols, feedback mechanisms, agent specializations, and performance results.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>ViperGPT</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Vipergpt: Visual inference via python execution for reasoning</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A system that converts visual queries into executable python code which calls vision models and uses execution results to answer or reason about images.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Vipergpt: Visual inference via python execution for reasoning</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>ViperGPT (Vipergpt)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>ViperGPT uses an LLM to generate Python code that orchestrates visual model calls and processes outputs programmatically; the code is executed to perform complex visual reasoning tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>number_of_agents</strong></td>
                            <td>effectively: 1 LLM + multiple invoked vision modules (treated as tools) — thus variable</td>
                        </tr>
                        <tr>
                            <td><strong>agent_specializations</strong></td>
                            <td>LLM for planning and code generation; vision modules for specific perception tasks invoked by generated code.</td>
                        </tr>
                        <tr>
                            <td><strong>research_phases_covered</strong></td>
                            <td>Execution and reasoning over vision tasks through programmatic orchestration.</td>
                        </tr>
                        <tr>
                            <td><strong>coordination_mechanism</strong></td>
                            <td>Programmatic orchestration via generated Python code executed in an environment that calls vision models; centralized decision via the LLM.</td>
                        </tr>
                        <tr>
                            <td><strong>communication_protocol</strong></td>
                            <td>Code (Python) as the communication/execution medium between the LLM and vision/tool modules.</td>
                        </tr>
                        <tr>
                            <td><strong>feedback_mechanism</strong></td>
                            <td>Execution results (from code) are returned and can be re-consumed by LLM to generate further code or answers; iterative loop mediated by generation-execution cycles.</td>
                        </tr>
                        <tr>
                            <td><strong>communication_frequency</strong></td>
                            <td>On-demand and iterative as code-generation-execute cycles occur.</td>
                        </tr>
                        <tr>
                            <td><strong>task_domain</strong></td>
                            <td>Vision inference and reasoning.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td>Mentioned as related work; HuggingGPT contrasts language-as-interface vs code-as-interface approaches.</td>
                        </tr>
                        <tr>
                            <td><strong>coordination_benefits</strong></td>
                            <td>Programmatic execution supports complex pipelines and interpretable orchestration.</td>
                        </tr>
                        <tr>
                            <td><strong>coordination_challenges</strong></td>
                            <td>Code-generation correctness, execution safety, and latency; these are discussed conceptually in the HuggingGPT paper.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_studies</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>optimal_configurations</strong></td>
                            <td>Not provided in the HuggingGPT paper; approach suggests utilities for tasks requiring structured programmatic control.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e2559.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e2559.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of multi-agent AI systems that coordinate to perform scientific research tasks, including details about their coordination mechanisms, communication protocols, feedback mechanisms, agent specializations, and performance results.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Auto-GPT</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Auto-GPT (open-source autonomous agent project)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An experimental autonomous agent framework that iteratively plans and executes tasks using LLMs and external tools (e.g., web search, code executor), often used for general daily automation tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>AutoGPT</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Auto-GPT</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Auto-GPT is an iterative autonomous agent prototype that uses LLMs to decompose goals into subtasks and iteratively execute them, leveraging tools like web search and code execution. It emphasizes iterative planning with reflexion modules in some variants.</td>
                        </tr>
                        <tr>
                            <td><strong>number_of_agents</strong></td>
                            <td>conceptually 1 autonomous agent composed of multiple tool-use components (iterative subtask generator + tool executors)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_specializations</strong></td>
                            <td>LLM-driven subtask generation, tool invocation modules (web search, code executor, etc.).</td>
                        </tr>
                        <tr>
                            <td><strong>research_phases_covered</strong></td>
                            <td>Task planning (iterative), execution using external tools; targeted at general automation rather than professional AI model orchestration.</td>
                        </tr>
                        <tr>
                            <td><strong>coordination_mechanism</strong></td>
                            <td>Iterative planning (step-by-step) with optional reflexion/check modules to validate or adjust steps.</td>
                        </tr>
                        <tr>
                            <td><strong>communication_protocol</strong></td>
                            <td>Natural language prompts and tool-specific APIs (web, code executors, etc.).</td>
                        </tr>
                        <tr>
                            <td><strong>feedback_mechanism</strong></td>
                            <td>Reflexion modules and iterative re-planning act as feedback loops to correct or refine next steps.</td>
                        </tr>
                        <tr>
                            <td><strong>communication_frequency</strong></td>
                            <td>Iterative at each planning/execution step (repeated LLM queries per step).</td>
                        </tr>
                        <tr>
                            <td><strong>task_domain</strong></td>
                            <td>General-purpose automation/daily tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td>Mentioned as related work and contrasted with HuggingGPT's global planning; no quantitative baseline provided in the HuggingGPT paper.</td>
                        </tr>
                        <tr>
                            <td><strong>coordination_benefits</strong></td>
                            <td>Iterative planning can adaptively refine plans; reflexion modules can catch errors at each step.</td>
                        </tr>
                        <tr>
                            <td><strong>coordination_challenges</strong></td>
                            <td>High LLM query cost, risk of looping or getting stuck if a step fails, and error propagation in iterative workflows (noted in HuggingGPT discussion).</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_studies</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>optimal_configurations</strong></td>
                            <td>HuggingGPT discusses trade-offs: iterative planning with reflexion vs global planning; no single optimal configuration specified.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e2559.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e2559.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of multi-agent AI systems that coordinate to perform scientific research tasks, including details about their coordination mechanisms, communication protocols, feedback mechanisms, agent specializations, and performance results.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>AgentGPT</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>AgentGPT (open-source autonomous agent project)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A community project that runs autonomous agents composed of LLM-driven planning and tool use for general tasks; mentioned as part of the ecosystem of experimental agents.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>AgentGPT</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>AgentGPT</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>AgentGPT is an experimental framework that lets LLM-driven agents perform sequences of tasks using tools; it is cited as an example of contemporary autonomous agent projects targeting daily user goals.</td>
                        </tr>
                        <tr>
                            <td><strong>number_of_agents</strong></td>
                            <td>N/A (project-level; typically single-agent instances invoking tools)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_specializations</strong></td>
                            <td>LLM planning + tool executors (varies by deployment).</td>
                        </tr>
                        <tr>
                            <td><strong>research_phases_covered</strong></td>
                            <td>Iterative planning and execution for general automation tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>coordination_mechanism</strong></td>
                            <td>Iterative stepwise planning by an LLM.</td>
                        </tr>
                        <tr>
                            <td><strong>communication_protocol</strong></td>
                            <td>Prompts and tool APIs.</td>
                        </tr>
                        <tr>
                            <td><strong>feedback_mechanism</strong></td>
                            <td>Iterative refinement in practice; not detailed in HuggingGPT paper.</td>
                        </tr>
                        <tr>
                            <td><strong>communication_frequency</strong></td>
                            <td>Iterative/on each generated subtask.</td>
                        </tr>
                        <tr>
                            <td><strong>task_domain</strong></td>
                            <td>General daily automation.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td>Mentioned for contrast with HuggingGPT's AI-area specialization and global planning.</td>
                        </tr>
                        <tr>
                            <td><strong>coordination_benefits</strong></td>
                            <td>Flexible tool use for broad tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>coordination_challenges</strong></td>
                            <td>Same high-level issues: LLM cost, instability, and iterative-loop risk.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_studies</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>optimal_configurations</strong></td>
                            <td>Not specified in HuggingGPT.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e2559.6">
                <h3 class="extraction-instance">Extracted Data Instance 6 (e2559.6)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of multi-agent AI systems that coordinate to perform scientific research tasks, including details about their coordination mechanisms, communication protocols, feedback mechanisms, agent specializations, and performance results.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>BabyAGI</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>BabyAGI (open-source autonomous agent project)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A simple iterative autonomous agent demo that uses LLMs to generate and prioritize tasks toward a goal; often used to prototype agent behaviors.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>BabyAGI</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>BabyAGI</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>BabyAGI is a minimal autonomous agent framework that iteratively generates, prioritizes, and executes tasks using LLMs and external tools; it is representative of rapidly developed agent demos aimed at general-purpose goals.</td>
                        </tr>
                        <tr>
                            <td><strong>number_of_agents</strong></td>
                            <td>N/A (single agent with iterative internal components)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_specializations</strong></td>
                            <td>LLM-based task generator, priority manager, and tool executors.</td>
                        </tr>
                        <tr>
                            <td><strong>research_phases_covered</strong></td>
                            <td>Iterative planning and execution; prototyping of autonomous behavior.</td>
                        </tr>
                        <tr>
                            <td><strong>coordination_mechanism</strong></td>
                            <td>Iterative planning loop.</td>
                        </tr>
                        <tr>
                            <td><strong>communication_protocol</strong></td>
                            <td>Natural language and tools' APIs.</td>
                        </tr>
                        <tr>
                            <td><strong>feedback_mechanism</strong></td>
                            <td>Iteration and reprioritization provide feedback; specifics not detailed in HuggingGPT.</td>
                        </tr>
                        <tr>
                            <td><strong>communication_frequency</strong></td>
                            <td>Per iteration (on-demand each generated task).</td>
                        </tr>
                        <tr>
                            <td><strong>task_domain</strong></td>
                            <td>General automation/daily tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td>Mentioned as related work for agent-style systems; contrasted with HuggingGPT's domain focus.</td>
                        </tr>
                        <tr>
                            <td><strong>coordination_benefits</strong></td>
                            <td>Demonstrates iterative autonomy and task prioritization.</td>
                        </tr>
                        <tr>
                            <td><strong>coordination_challenges</strong></td>
                            <td>Same iterative system weaknesses: cost, potential for loops, and error propagation.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_studies</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>optimal_configurations</strong></td>
                            <td>Not provided in HuggingGPT; these projects are presented as demos rather than rigorously tuned systems.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Toolformer: Language Models Can Teach Themselves to Use Tools <em>(Rating: 2)</em></li>
                <li>Visual ChatGPT: Talking, Drawing and Editing with Visual Foundation Models <em>(Rating: 2)</em></li>
                <li>Vipergpt: Visual inference via python execution for reasoning <em>(Rating: 2)</em></li>
                <li>Auto-GPT <em>(Rating: 1)</em></li>
                <li>AgentGPT <em>(Rating: 1)</em></li>
                <li>BabyAGI <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-2559",
    "paper_id": "paper-d1120d67b700e4dfe8b39eb1e48fbdea4e1a0c43",
    "extraction_schema_id": "extraction-schema-65",
    "extracted_data": [
        {
            "name_short": "HuggingGPT",
            "name_full": "HuggingGPT: Solving AI Tasks with ChatGPT and its Friends in Hugging Face",
            "brief_description": "A multi-model collaborative system that uses a large language model (LLM) as a centralized controller to plan, select, orchestrate, and integrate the execution of many expert models (from Hugging Face) to solve complex multimodal AI tasks across language, vision, speech and cross-modality.",
            "citation_title": "here",
            "mention_or_use": "use",
            "system_name": "HuggingGPT",
            "system_description": "HuggingGPT is an LLM-powered multi-agent framework where a single LLM (e.g., ChatGPT / GPT-3.5 / GPT-4) acts as a centralized controller to (1) parse a user's request into a structured task graph, (2) select suitable expert models hosted in the Hugging Face model hub for each subtask using model descriptions, (3) invoke and execute the selected expert models on local or cloud inference endpoints, handling resource dependencies and parallel execution where possible, and (4) aggregate structured inference outputs into a human-readable final response. The system uses language (prompts and model descriptions) as the generic interface between controller and expert models, a JSON task template for structured planning, and a '&lt;resource&gt;-task_id' token convention to wire outputs from prerequisite tasks into dependent tasks.",
            "number_of_agents": "variable (1 centralized LLM controller + many 'expert model' agents; system supports invocation of many models and currently supports 24 task types)",
            "agent_specializations": "1) Controller agent (LLM): task planning, model selection, orchestration, and response generation; 2) Expert model agents: specialized executors each implementing a narrow task (examples include image captioning, object detection, image classification, text-to-image, text-to-speech, ASR, VQA, document QA, segmentation, depth estimation, video generation, audio generation, etc.); 3) Hybrid endpoints (deployment components): local inference endpoints for speed/stability and cloud endpoints (Hugging Face) for breadth. Each expert is specialized by task type and model description (e.g., DETR-resnet-101 for object detection, vit-gpt2 for image captioning, stable-diffusion for text-to-image).",
            "research_phases_covered": "Primarily: planning (task decomposition), implementation/selection (model selection and deployment), execution (model inference), and evaluation/aggregation (integrating model outputs and generating final responses). It does not perform autonomous literature review or experiment design beyond decomposing user requests; it supports inference-level execution and result aggregation rather than training new models.",
            "coordination_mechanism": "Centralized controller architecture: the LLM functions as a single centralized planner and scheduler (global planning strategy), producing a structured task graph with explicit dependencies. The controller assigns tasks to expert models, manages execution order (serial and parallel execution depending on resource dependencies), and resolves resource passing using a token convention. The system implements 'global planning' (one-shot generation of full task queue) rather than iterative stepwise planning, although discussions compare both approaches.",
            "communication_protocol": "Language-based and structured messages: communication between controller and model registry uses natural-language model descriptions embedded in prompts; task specifications and inter-component messages use structured JSON templates (task entries with fields 'task','id','dep','args'); resource passing between tasks uses a special '&lt;resource&gt;-task_id' placeholder which is dynamically replaced at execution time; inference outputs are returned as structured data (e.g., bounding boxes, answer distributions, file paths) and fed back to the LLM for aggregation. Interactions with LLMs and models are done via API calls (OpenAI API for LLM; Hugging Face/cloud or local inference endpoints for models).",
            "feedback_mechanism": "No continuous peer-review loop between expert models is implemented; feedback is centralized through the LLM which ingests structured inference results and can re-plan if needed. For evaluation, the authors use external critics (GPT-4 as an evaluator/critic for task-planning correctness) and human expert evaluation (passing rate, rationality, success rate). Internally the system resolves resource dependencies deterministically by replacing '&lt;resource&gt;-task_id' tokens with produced resources; there is no described iterative refinement loop among expert model agents beyond the controller re-invoking models as part of a new plan if necessary.",
            "communication_frequency": "Stage-driven/on-demand: communication occurs at stage transitions — (1) LLM performs task planning and emits structured task graph, (2) model selection step where LLM selects models (in-context selection), (3) executor layer triggers model invocations (can run tasks in parallel when independent), (4) results returned to LLM for response generation. Thus agents communicate on-demand at each pipeline stage and after individual model execution; independent tasks may run concurrently.",
            "task_domain": "Applied to general AI tasks across modalities (language, vision, speech, audio, video, cross-modality) — i.e., professional AI task automation rather than domain-specific scientific discovery like drug design; primary domain: machine learning / multimodal AI application workflows.",
            "performance_metrics": "Reported metrics focus on controller (task-planning) effectiveness and human evaluation of end-to-end success. Key quantitative results reported: task-planning (on GPT-4-annotated dataset): for graph tasks GPT-3.5 achieved GPT-4 Score 50.48, Precision 54.90, Recall 49.23, F1 51.91; sequential tasks (GPT-3.5) Edit Distance 0.54, Precision 61.09, Recall 45.15, F1 51.92. Human-annotated dataset: GPT-4 achieves higher planning accuracy (e.g., GPT-4 Acc for sequential tasks 41.36, Graph Acc 58.33). Human evaluation (130 requests): GPT-3.5: Task Planning Passing Rate 91.22%, Rationality 78.47%; Model Selection Passing Rate 93.89%, Rationality 84.29%; Response Success Rate 63.08%. Comparisons for open-source LLMs: Alpaca-13b Response Success Rate 6.92%, Vicuna-13b 15.64%.",
            "baseline_comparison": "Compared the central LLM controller variants (Alpaca-7b/13b, Vicuna-7b/13b, GPT-3.5, GPT-4) on planning and end-to-end tasks. Results show stronger LLMs (GPT-3.5/GPT-4) produce substantially better task planning and higher human-evaluated success rates than smaller open-source LLMs (Alpaca, Vicuna). No direct comparison to a decentralized or non-LLM orchestration baseline is provided; baseline comparisons focus on different LLM controllers and human annotations/GPT-4 critic labels.",
            "coordination_benefits": "Coordination enables multimodal problem decomposition and use of task-specialist models, leading to ability to solve complex multi-step and cross-modality requests that single LLMs or single specialist models could not. Quantitative benefits: much higher passing/success rates when using stronger LLM controllers (GPT-3.5 success rate 63.08% vs Alpaca-13b 6.92%); better planning F1/accuracy. System also benefits from parallel execution of independent tasks to improve throughput. Qualitatively: integrates best-of-breed specialized models for improved modality-specific performance (e.g., fine-tuned detectors for detection subtask rather than LLM hallucination).",
            "coordination_challenges": "Reported challenges include: heavy reliance on LLM planning quality (plans may be infeasible or suboptimal); efficiency and latency (multiple LLM interactions increase time cost); token length/context limits when including many model descriptions; instability/uncontrollability of LLM outputs (may not follow instructions or produce incorrect answers causing workflow exceptions); deployment complexity (need for hybrid endpoints and prioritization between local vs cloud).",
            "ablation_studies": "Ablations analyzed the effect of few-shot demonstrations (number and variety) on task-planning performance. Results: increasing demonstration variety improves planning moderately; adding demonstrations helps but gains plateau after ~4 examples. Table 7 and Figure 3 provide quantitative evidence (e.g., GPT-3.5 single-task F1 increases from ~48.29 with 2 demo variety to ~53.70 with 10; GPT-4 single-task F1 increases from ~67.08 to ~71.05). No ablation isolating the coordinator/controller vs decentralized orchestration or removing resource-dependency mechanism was reported.",
            "optimal_configurations": "Paper suggests practical settings rather than a single 'optimal' config: use a powerful LLM controller (GPT-3.5/GPT-4) for better planning; employ a dynamic in-context task-model assignment filtered by task type and top-K ranking (by downloads) to reduce prompt tokens; prioritize local inference endpoints for speed/stability and fallback to cloud endpoints; use a few (≈4) diverse demonstrations to improve planning with diminishing returns beyond that; utilize global planning (one-shot full task graph) with explicit resource dependency markers ('&lt;resource&gt;-task_id') for deterministic orchestration.",
            "uuid": "e2559.0"
        },
        {
            "name_short": "Toolformer",
            "name_full": "Toolformer: Language Models Can Teach Themselves to Use Tools",
            "brief_description": "A system that trains large language models to call external APIs / tools by inserting API-call tags into corpora and learning when to use them, enabling LLMs to augment generation with tool use.",
            "citation_title": "Toolformer: Language Models Can Teach Themselves to Use Tools",
            "mention_or_use": "mention",
            "system_name": "Toolformer",
            "system_description": "Toolformer augments LLMs by teaching them when and how to call external tools/APIs, using inserted API call tags in training corpora so the model learns to incorporate tool-usage during generation. It is an approach to integrate external functionality rather than a multi-agent orchestration framework per se.",
            "number_of_agents": "N/A (primarily an augmentation to a single LLM to call external tools)",
            "agent_specializations": "Not a multi-agent decomposition; the single LLM learns to call specialized external tools (search, calculator, etc.) as needed.",
            "research_phases_covered": "Tool usage during inference/generation (execution phase); enables access to external capabilities rather than comprehensive research pipeline orchestration.",
            "coordination_mechanism": "Single LLM decides tool calls internally; no decentralized agent coordination described in this paper's mention.",
            "communication_protocol": "API-call tags within generated text sequences; calls to external tools via standardized tags and API formats.",
            "feedback_mechanism": "Self-supervised learning of when to call tools during pretraining; not a peer-feedback multi-agent loop.",
            "communication_frequency": "On-demand during generation when the LLM decides to call a tool.",
            "task_domain": "General NLP/tool-augmented generation tasks.",
            "performance_metrics": null,
            "baseline_comparison": "Mentioned as related work; no direct experimental comparison in HuggingGPT paper.",
            "coordination_benefits": "Demonstrates that LLMs can learn when to call external tools, improving task performance for operations better handled by specialized tools.",
            "coordination_challenges": "Not detailed in HuggingGPT paper beyond being related work; general challenges include designing tags, correct tool selection, and training signals.",
            "ablation_studies": null,
            "optimal_configurations": "Not specified in HuggingGPT; Toolformer literature suggests learning signals and careful integration of tool calls.",
            "uuid": "e2559.1"
        },
        {
            "name_short": "Visual ChatGPT",
            "name_full": "Visual ChatGPT: Talking, Drawing and Editing with Visual Foundation Models",
            "brief_description": "A system that integrates visual foundation models with an LLM to provide multimodal conversational capabilities by chaining vision models and using the LLM to orchestrate operations.",
            "citation_title": "Visual ChatGPT: Talking, Drawing and Editing with Visual Foundation Models",
            "mention_or_use": "mention",
            "system_name": "Visual ChatGPT",
            "system_description": "Visual ChatGPT connects an LLM with a set of visual foundation models (e.g., BLIP, ControlNet) to allow conversational interaction over images, where the LLM issues commands to and composes outputs from visual models to perform perception and visual editing tasks.",
            "number_of_agents": "variable (LLM controller + multiple visual foundation models)",
            "agent_specializations": "LLM for language and orchestration; various visual models for perception, editing, and generation.",
            "research_phases_covered": "Execution and aggregation of multimodal perception and generation tasks; conversational interaction.",
            "coordination_mechanism": "LLM-driven orchestration chaining calls to visual models, similar to a centralized controller approach.",
            "communication_protocol": "Natural language commands and a programmatic chaining of model calls (often mediated by code or structured prompts).",
            "feedback_mechanism": "LLM integrates model outputs and can issue further calls; iterative back-and-forth mediated by the LLM but no decentralized peer review.",
            "communication_frequency": "On-demand during conversational turns and model chaining.",
            "task_domain": "Vision + language multimodal tasks.",
            "performance_metrics": null,
            "baseline_comparison": "Mentioned as related work; no direct experimental baseline in HuggingGPT paper.",
            "coordination_benefits": "Enables complex visual editing and Q&A by composing specialized vision models under LLM control.",
            "coordination_challenges": "Similar challenges around chaining reliability, context length, and latency are discussed in HuggingGPT.",
            "ablation_studies": null,
            "optimal_configurations": "Not specified in HuggingGPT; Visual ChatGPT literature emphasizes choosing appropriate vision models and prompt engineering for orchestration.",
            "uuid": "e2559.2"
        },
        {
            "name_short": "ViperGPT",
            "name_full": "Vipergpt: Visual inference via python execution for reasoning",
            "brief_description": "A system that converts visual queries into executable python code which calls vision models and uses execution results to answer or reason about images.",
            "citation_title": "Vipergpt: Visual inference via python execution for reasoning",
            "mention_or_use": "mention",
            "system_name": "ViperGPT (Vipergpt)",
            "system_description": "ViperGPT uses an LLM to generate Python code that orchestrates visual model calls and processes outputs programmatically; the code is executed to perform complex visual reasoning tasks.",
            "number_of_agents": "effectively: 1 LLM + multiple invoked vision modules (treated as tools) — thus variable",
            "agent_specializations": "LLM for planning and code generation; vision modules for specific perception tasks invoked by generated code.",
            "research_phases_covered": "Execution and reasoning over vision tasks through programmatic orchestration.",
            "coordination_mechanism": "Programmatic orchestration via generated Python code executed in an environment that calls vision models; centralized decision via the LLM.",
            "communication_protocol": "Code (Python) as the communication/execution medium between the LLM and vision/tool modules.",
            "feedback_mechanism": "Execution results (from code) are returned and can be re-consumed by LLM to generate further code or answers; iterative loop mediated by generation-execution cycles.",
            "communication_frequency": "On-demand and iterative as code-generation-execute cycles occur.",
            "task_domain": "Vision inference and reasoning.",
            "performance_metrics": null,
            "baseline_comparison": "Mentioned as related work; HuggingGPT contrasts language-as-interface vs code-as-interface approaches.",
            "coordination_benefits": "Programmatic execution supports complex pipelines and interpretable orchestration.",
            "coordination_challenges": "Code-generation correctness, execution safety, and latency; these are discussed conceptually in the HuggingGPT paper.",
            "ablation_studies": null,
            "optimal_configurations": "Not provided in the HuggingGPT paper; approach suggests utilities for tasks requiring structured programmatic control.",
            "uuid": "e2559.3"
        },
        {
            "name_short": "Auto-GPT",
            "name_full": "Auto-GPT (open-source autonomous agent project)",
            "brief_description": "An experimental autonomous agent framework that iteratively plans and executes tasks using LLMs and external tools (e.g., web search, code executor), often used for general daily automation tasks.",
            "citation_title": "AutoGPT",
            "mention_or_use": "mention",
            "system_name": "Auto-GPT",
            "system_description": "Auto-GPT is an iterative autonomous agent prototype that uses LLMs to decompose goals into subtasks and iteratively execute them, leveraging tools like web search and code execution. It emphasizes iterative planning with reflexion modules in some variants.",
            "number_of_agents": "conceptually 1 autonomous agent composed of multiple tool-use components (iterative subtask generator + tool executors)",
            "agent_specializations": "LLM-driven subtask generation, tool invocation modules (web search, code executor, etc.).",
            "research_phases_covered": "Task planning (iterative), execution using external tools; targeted at general automation rather than professional AI model orchestration.",
            "coordination_mechanism": "Iterative planning (step-by-step) with optional reflexion/check modules to validate or adjust steps.",
            "communication_protocol": "Natural language prompts and tool-specific APIs (web, code executors, etc.).",
            "feedback_mechanism": "Reflexion modules and iterative re-planning act as feedback loops to correct or refine next steps.",
            "communication_frequency": "Iterative at each planning/execution step (repeated LLM queries per step).",
            "task_domain": "General-purpose automation/daily tasks.",
            "performance_metrics": null,
            "baseline_comparison": "Mentioned as related work and contrasted with HuggingGPT's global planning; no quantitative baseline provided in the HuggingGPT paper.",
            "coordination_benefits": "Iterative planning can adaptively refine plans; reflexion modules can catch errors at each step.",
            "coordination_challenges": "High LLM query cost, risk of looping or getting stuck if a step fails, and error propagation in iterative workflows (noted in HuggingGPT discussion).",
            "ablation_studies": null,
            "optimal_configurations": "HuggingGPT discusses trade-offs: iterative planning with reflexion vs global planning; no single optimal configuration specified.",
            "uuid": "e2559.4"
        },
        {
            "name_short": "AgentGPT",
            "name_full": "AgentGPT (open-source autonomous agent project)",
            "brief_description": "A community project that runs autonomous agents composed of LLM-driven planning and tool use for general tasks; mentioned as part of the ecosystem of experimental agents.",
            "citation_title": "AgentGPT",
            "mention_or_use": "mention",
            "system_name": "AgentGPT",
            "system_description": "AgentGPT is an experimental framework that lets LLM-driven agents perform sequences of tasks using tools; it is cited as an example of contemporary autonomous agent projects targeting daily user goals.",
            "number_of_agents": "N/A (project-level; typically single-agent instances invoking tools)",
            "agent_specializations": "LLM planning + tool executors (varies by deployment).",
            "research_phases_covered": "Iterative planning and execution for general automation tasks.",
            "coordination_mechanism": "Iterative stepwise planning by an LLM.",
            "communication_protocol": "Prompts and tool APIs.",
            "feedback_mechanism": "Iterative refinement in practice; not detailed in HuggingGPT paper.",
            "communication_frequency": "Iterative/on each generated subtask.",
            "task_domain": "General daily automation.",
            "performance_metrics": null,
            "baseline_comparison": "Mentioned for contrast with HuggingGPT's AI-area specialization and global planning.",
            "coordination_benefits": "Flexible tool use for broad tasks.",
            "coordination_challenges": "Same high-level issues: LLM cost, instability, and iterative-loop risk.",
            "ablation_studies": null,
            "optimal_configurations": "Not specified in HuggingGPT.",
            "uuid": "e2559.5"
        },
        {
            "name_short": "BabyAGI",
            "name_full": "BabyAGI (open-source autonomous agent project)",
            "brief_description": "A simple iterative autonomous agent demo that uses LLMs to generate and prioritize tasks toward a goal; often used to prototype agent behaviors.",
            "citation_title": "BabyAGI",
            "mention_or_use": "mention",
            "system_name": "BabyAGI",
            "system_description": "BabyAGI is a minimal autonomous agent framework that iteratively generates, prioritizes, and executes tasks using LLMs and external tools; it is representative of rapidly developed agent demos aimed at general-purpose goals.",
            "number_of_agents": "N/A (single agent with iterative internal components)",
            "agent_specializations": "LLM-based task generator, priority manager, and tool executors.",
            "research_phases_covered": "Iterative planning and execution; prototyping of autonomous behavior.",
            "coordination_mechanism": "Iterative planning loop.",
            "communication_protocol": "Natural language and tools' APIs.",
            "feedback_mechanism": "Iteration and reprioritization provide feedback; specifics not detailed in HuggingGPT.",
            "communication_frequency": "Per iteration (on-demand each generated task).",
            "task_domain": "General automation/daily tasks.",
            "performance_metrics": null,
            "baseline_comparison": "Mentioned as related work for agent-style systems; contrasted with HuggingGPT's domain focus.",
            "coordination_benefits": "Demonstrates iterative autonomy and task prioritization.",
            "coordination_challenges": "Same iterative system weaknesses: cost, potential for loops, and error propagation.",
            "ablation_studies": null,
            "optimal_configurations": "Not provided in HuggingGPT; these projects are presented as demos rather than rigorously tuned systems.",
            "uuid": "e2559.6"
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Toolformer: Language Models Can Teach Themselves to Use Tools",
            "rating": 2
        },
        {
            "paper_title": "Visual ChatGPT: Talking, Drawing and Editing with Visual Foundation Models",
            "rating": 2
        },
        {
            "paper_title": "Vipergpt: Visual inference via python execution for reasoning",
            "rating": 2
        },
        {
            "paper_title": "Auto-GPT",
            "rating": 1
        },
        {
            "paper_title": "AgentGPT",
            "rating": 1
        },
        {
            "paper_title": "BabyAGI",
            "rating": 1
        }
    ],
    "cost": 0.018819749999999996,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>HuggingGPT: Solving AI Tasks with ChatGPT and its Friends in Hugging Face</h1>
<p>Yongliang Shen ${ }^{1,2, \star}$, Kaitao Song ${ }^{2, \star, \dagger}$, Xu Tan ${ }^{2}$, Dongsheng $\mathbf{L i}^{2}$, Weiming $\mathbf{L u}^{1, \dagger}$, Yueting Zhuang ${ }^{1, \dagger}$<br>Zhejiang University ${ }^{1}$, Microsoft Research Asia ${ }^{2}$<br>{syl, luwm, yzhuang}@zju.edu.cn, {kaitaosong, xuta, dongsli}@microsoft.com<br>https://github.com/microsoft/JARVIS</p>
<h4>Abstract</h4>
<p>Solving complicated AI tasks with different domains and modalities is a key step toward artificial general intelligence. While there are numerous AI models available for various domains and modalities, they cannot handle complicated AI tasks autonomously. Considering large language models (LLMs) have exhibited exceptional abilities in language understanding, generation, interaction, and reasoning, we advocate that LLMs could act as a controller to manage existing AI models to solve complicated AI tasks, with language serving as a generic interface to empower this. Based on this philosophy, we present HuggingGPT, an LLM-powered agent that leverages LLMs (e.g., ChatGPT) to connect various AI models in machine learning communities (e.g., Hugging Face) to solve AI tasks. Specifically, we use ChatGPT to conduct task planning when receiving a user request, select models according to their function descriptions available in Hugging Face, execute each subtask with the selected AI model, and summarize the response according to the execution results. By leveraging the strong language capability of ChatGPT and abundant AI models in Hugging Face, HuggingGPT can tackle a wide range of sophisticated AI tasks spanning different modalities and domains and achieve impressive results in language, vision, speech, and other challenging tasks, which paves a new way towards the realization of artificial general intelligence.</p>
<h2>1 Introduction</h2>
<p>Large language models (LLMs) [1, 2, 3, 4, 5, 6], such as ChatGPT, have attracted substantial attention from both academia and industry, due to their remarkable performance on various natural language processing (NLP) tasks. Based on large-scale pre-training on massive text corpora and reinforcement learning from human feedback [2], LLMs can exhibit superior capabilities in language understanding, generation, and reasoning. The powerful capability of LLMs also drives many emergent research topics (e.g., in-context learning [1, 7, 8], instruction learning [9, 10, 11, 12, 13, 14], and chain-ofthought prompting $[15,16,17,18]$ ) to further investigate the huge potential of LLMs, and brings unlimited possibilities for us for advancing artificial general intelligence.</p>
<p>Despite these great successes, current LLM technologies are still imperfect and confront some urgent challenges on the way to building an advanced AI system. We discuss them from these aspects: 1) Limited to the input and output forms of text generation, current LLMs lack the ability to process complex information such as vision and speech, regardless of their significant achievements in NLP</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Language serves as an interface for LLMs (e.g., ChatGPT) to connect numerous AI models (e.g., those in Hugging Face) for solving complicated AI tasks. In this concept, an LLM acts as a controller, managing and organizing the cooperation of expert models. The LLM first plans a list of tasks based on the user request and then assigns expert models to each task. After the experts execute the tasks, the LLM collects the results and responds to the user.
tasks; 2) In real-world scenarios, some complex tasks are usually composed of multiple sub-tasks, and thus require the scheduling and cooperation of multiple models, which are also beyond the capability of language models; 3) For some challenging tasks, LLMs demonstrate excellent results in zero-shot or few-shot settings, but they are still weaker than some experts (e.g., fine-tuned models). How to address these issues could be the critical step for LLMs toward artificial general intelligence.</p>
<p>In this paper, we point out that in order to handle complicated AI tasks, LLMs should be able to coordinate with external models to harness their powers. Hence, the pivotal question is how to choose suitable middleware to bridge the connections between LLMs and AI models. To tackle this issue, we notice that each AI model can be described in the form of language by summarizing its function. Therefore, we introduce a concept: "Language as a generic interface for LLMs to collaborate with AI models". In other words, by incorporating these model descriptions into prompts, LLMs can be considered as the brain to manage AI models such as planning, scheduling, and cooperation. As a result, this strategy empowers LLMs to invoke external models for solving AI tasks. However, when it comes to integrating multiple AI models into LLMs, another challenge emerges: solving numerous AI tasks needs collecting a large number of high-quality model descriptions, which in turn requires heavy prompt engineering. Coincidentally, we notice that some public ML communities usually offer a wide range of applicable models with well-defined model descriptions for solving specific AI tasks such as language, vision, and speech. These observations bring us some inspiration: Can we link LLMs (e.g., ChatGPT) with public ML communities (e.g., GitHub, Hugging Face ${ }^{1}$, etc) for solving complex AI tasks via a language-based interface?</p>
<p>In this paper, we propose an LLM-powered agent named HuggingGPT to autonomously tackle a wide range of complex AI tasks, which connects LLMs (i.e., ChatGPT) and the ML community (i.e., Hugging Face) and can process inputs from different modalities. More specifically, the LLM acts as a brain: on one hand, it disassembles tasks based on user requests, and on the other hand, assigns suitable models to the tasks according to the model description. By executing models and integrating results in the planned tasks, HuggingGPT can autonomously fulfill complex user requests. The whole process of HuggingGPT, illustrated in Figure 1, can be divided into four stages:</p>
<ul>
<li>Task Planning: Using ChatGPT to analyze the requests of users to understand their intention, and disassemble them into possible solvable tasks.</li>
<li>Model Selection: To solve the planned tasks, ChatGPT selects expert models that are hosted on Hugging Face based on model descriptions.</li>
<li>Task Execution: Invoke and execute each selected model, and return the results to ChatGPT.</li>
</ul>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: Overview of HuggingGPT. With an LLM (e.g., ChatGPT) as the core controller and the expert models as the executors, the workflow of HuggingGPT consists of four stages: 1) Task planning: LLM parses the user request into a task list and determines the execution order and resource dependencies among tasks; 2) Model selection: LLM assigns appropriate models to tasks based on the description of expert models on Hugging Face; 3) Task execution: Expert models on hybrid endpoints execute the assigned tasks; 4) Response generation: LLM integrates the inference results of experts and generates a summary of workflow logs to respond to the user.</p>
<ul>
<li>Response Generation: Finally, ChatGPT is utilized to integrate the predictions from all models and generate responses for users.</li>
</ul>
<p>Benefiting from such a design, HuggingGPT can automatically generate plans from user requests and use external models, enabling it to integrate multimodal perceptual capabilities and tackle various complex AI tasks. More notably, this pipeline allows HuggingGPT to continually absorb the powers from task-specific experts, facilitating the growth and scalability of AI capabilities.</p>
<p>Overall, our contributions can be summarized as follows:</p>
<ol>
<li>
<p>To complement the advantages of large language models and expert models, we propose HuggingGPT with an inter-model cooperation protocol. HuggingGPT applies LLMs as the brain for planning and decision, and automatically invokes and executes expert models for each specific task, providing a new way for designing general AI solutions.</p>
</li>
<li>
<p>By integrating the Hugging Face hub with numerous task-specific models around ChatGPT, HuggingGPT is able to tackle generalized AI tasks covering multiple modalities and domains. Through the open collaboration of models, HuggingGPT can provide users with multimodal and reliable conversation services.</p>
</li>
<li>We point out the importance of task planning and model selection in HuggingGPT (and autonomous agents), and formulate some experimental evaluations for measuring the capability of LLMs in planning and model selection.</li>
<li>Extensive experiments on multiple challenging AI tasks across language, vision, speech, and cross-modality demonstrate the capability and huge potential of HuggingGPT in understanding and solving complex tasks from multiple modalities and domains.</li>
</ol>
<h1>2 Related Works</h1>
<p>In recent years, the field of natural language processing (NLP) has been revolutionized by the emergence of large language models (LLMs) [1, 2, 3, 4, 5, 19, 6], exemplified by models such as GPT-3 [1], GPT-4 [20], PaLM [3], and LLaMa [6]. LLMs have demonstrated impressive capabilities in zero-shot and few-shot tasks, as well as more complex tasks such as mathematical problems and commonsense reasoning, due to their massive corpus and intensive training computation. To extend the scope of large language models (LLMs) beyond text generation, contemporary research can be divided into two branches: 1) Some works have devised unified multimodal language models for solving various AI tasks [21, 22, 23]. For example, Flamingo [21] combines frozen pre-trained vision and language models for perception and reasoning. BLIP-2 [22] utilizes a Q-former to harmonize linguistic and visual semantics, and Kosmos-1 [23] incorporates visual input into text sequences to amalgamate linguistic and visual inputs. 2) Recently, some researchers started to investigate the integration of using tools or models in LLMs [24, 25, 26, 27, 28]. Toolformer [24] is the pioneering work to introduce external API tags within text sequences, facilitating the ability of LLMs to access external tools. Consequently, numerous works have expanded LLMs to encompass the visual modality. Visual ChatGPT [26] fuses visual foundation models, such as BLIP [29] and ControlNet [30], with LLMs. Visual Programming [31] and ViperGPT [25] apply LLMs to visual objects by employing programming languages, parsing visual queries into interpretable steps expressed as Python code. More discussions about related works are included in Appendix B.
Distinct from these approaches, HuggingGPT advances towards more general AI capabilities in the following aspects: 1) HuggingGPT uses the LLM as the controller to route user requests to expert models, effectively combining the language comprehension capabilities of the LLM with the expertise of other expert models; 2) The mechanism of HuggingGPT allows it to address tasks in any modality or any domain by organizing cooperation among models through the LLM. Benefiting from the design of task planning in HuggingGPT, our system can automatically and effectively generate task procedures and solve more complex problems; 3) HuggingGPT offers a more flexible approach to model selection, which assigns and orchestrates tasks based on model descriptions. By providing only the model descriptions, HuggingGPT can continuously and conveniently integrate diverse expert models from AI communities, without altering any structure or prompt settings. This open and continuous manner brings us one step closer to realizing artificial general intelligence.</p>
<h2>3 HuggingGPT</h2>
<p>HuggingGPT is a collaborative system for solving AI tasks, composed of a large language model (LLM) and numerous expert models from ML communities. Its workflow includes four stages: task planning, model selection, task execution, and response generation, as shown in Figure 2. Given a user request, our HuggingGPT, which adopts an LLM as the controller, will automatically deploy the whole workflow, thereby coordinating and executing the expert models to fulfill the target. Table 1 presents the detailed prompt design in our HuggingGPT. In the following subsections, we will introduce the design of each stage.</p>
<h3>3.1 Task Planning</h3>
<p>Generally, in real-world scenarios, user requests usually encompass some intricate intentions and thus need to orchestrate multiple sub-tasks to fulfill the target. Therefore, we formulate task planning</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Table 1: The details of the prompt design in HuggingGPT. In the prompts, we set some injectable slots such as ${{$ Demonstrations } and ${{$ Candidate Models }}. These slots are uniformly replaced with the corresponding text before being fed into the LLM.
as the first stage of HuggingGPT, which aims to use LLM to analyze the user request and then decompose it into a collection of structured tasks. Moreover, we require the LLM to determine dependencies and execution orders for these decomposed tasks, to build their connections. To enhance the efficacy of task planning in LLMs, HuggingGPT employs a prompt design, which consists of specification-based instruction and demonstration-based parsing. We introduce these details in the following paragraphs.</p>
<p>Specification-based Instruction To better represent the expected tasks of user requests and use them in the subsequent stages, we expect the LLM to parse tasks by adhering to specific specifications (e.g., JSON format). Therefore, we design a standardized template for tasks and instruct the LLM to</p>
<p>conduct task parsing through slot filing. As shown in Table 1, the task parsing template comprises four slots ("task", "id", "dep", and "args") to represent the task name, unique identifier, dependencies and arguments. Additional details for each slot can be found in the template description (see the Appendix A.1.1). By adhering to these task specifications, HuggingGPT can automatically employ the LLM to analyze user requests and parse tasks accordingly.</p>
<p>Demonstration-based Parsing To better understand the intention and criteria for task planning, HuggingGPT incorporates multiple demonstrations in the prompt. Each demonstration consists of a user request and its corresponding output, which represents the expected sequence of parsed tasks. By incorporating dependencies among tasks, these demonstrations aid HuggingGPT in understanding the logical connections between tasks, facilitating accurate determination of execution order and identification of resource dependencies. The details of our demonstrations is presented in Table 1.</p>
<p>Furthermore, to support more complex scenarios (e.g., multi-turn dialogues), we include chat logs in the prompt by appending the following instruction: "To assist with task planning, the chat history is available as {{ Chat Logs }}, where you can trace the user-mentioned resources and incorporate them into the task planning.". Here {{ Chat Logs }} represents the previous chat logs. This design allows HuggingGPT to better manage context and respond to user requests in multi-turn dialogues.</p>
<h1>3.2 Model Selection</h1>
<p>Following task planning, HuggingGPT proceeds to the task of matching tasks with models, i.e., selecting the most appropriate model for each task in the parsed task list. To this end, we use model descriptions as the language interface to connect each model. More specifically, we first gather the descriptions of expert models from the ML community (e.g., Hugging Face) and then employ a dynamic in-context task-model assignment mechanism to choose models for the tasks. This strategy enables incremental model access (simply providing the description of the expert models) and can be more open and flexible to use ML communities. More details are introduced in the next paragraph.</p>
<p>In-context Task-model Assignment We formulate the task-model assignment as a single-choice problem, where available models are presented as options within a given context. Generally, based on the provided user instruction and task information in the prompt, HuggingGPT is able to select the most appropriate model for each parsed task. However, due to the limits of maximum context length, it is not feasible to encompass the information of all relevant models within one prompt. To mitigate this issue, we first filter out models based on their task type to select the ones that match the current task. Among these selected models, we rank them based on the number of downloads ${ }^{2}$ on Hugging Face and then select the top- $K$ models as the candidates. This strategy can substantially reduce the token usage in the prompt and effectively select the appropriate models for each task.</p>
<h3>3.3 Task Execution</h3>
<p>Once a specific model is assigned to a parsed task, the next step is to execute the task (i.e., perform model inference). In this stage, HuggingGPT will automatically feed these task arguments into the models, execute these models to obtain the inference results, and then send them back to the LLM. It is necessary to emphasize the issue of resource dependencies at this stage. Since the outputs of the prerequisite tasks are dynamically produced, HuggingGPT also needs to dynamically specify the dependent resources for the task before launching it. Therefore, it is challenging to build the connections between tasks with resource dependencies at this stage.</p>
<p>Resource Dependency To address this issue, we use a unique symbol, "<resource>", to maintain resource dependencies. Specifically, HuggingGPT identifies the resources generated by the prerequisite task as <resource>-task_id, where task_id is the id of the prerequisite task. During the task planning stage, if some tasks are dependent on the outputs of previously executed tasks (e.g., task_id), HuggingGPT sets this symbol (i.e., <resource>-task_id) to the corresponding resource subfield in the arguments. Then in the task execution stage, HuggingGPT dynamically replaces this symbol with the resource generated by the prerequisite task. As a result, this strategy empowers HuggingGPT to efficiently handle resource dependencies during task execution.</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<table>
<thead>
<tr>
<th style="text-align: center;">Task Type</th>
<th style="text-align: center;">Diagram</th>
<th style="text-align: center;">Example</th>
<th style="text-align: center;">Metrics</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Single Task</td>
<td style="text-align: center;">Task 1</td>
<td style="text-align: center;">Show me a funny image of a cat</td>
<td style="text-align: center;">Precision, Recall, F1, Accuracy</td>
</tr>
<tr>
<td style="text-align: center;">Sequential Task</td>
<td style="text-align: center;">Task 1 Task 2 Task 3</td>
<td style="text-align: center;">Replace the cat with a dog in example.jpg</td>
<td style="text-align: center;">Precision, Recall, F1 Edit Distance</td>
</tr>
<tr>
<td style="text-align: center;">Graph Task</td>
<td style="text-align: center;">Task 1 <br> Task 4 <br> Task 5 <br> Task 6</td>
<td style="text-align: center;">Given a collection of image A: a.jpg, B: b.jpg, C: c.jpg, please tell me which image is more like image B in terms of semantic, A or C?</td>
<td style="text-align: center;">Precision, Recall, F1 GPT-4 Score</td>
</tr>
</tbody>
</table>
<p>Table 2: Evaluation for task planning in different task types.</p>
<p>Furthermore, for the remaining tasks without any resource dependencies, we will execute these tasks directly in parallel to further improve inference efficiency. This means that multiple tasks can be executed simultaneously if they meet the prerequisite dependencies. Additionally, we offer a hybrid inference endpoint to deploy these models for speedup and computational stability. For more details, please refer to Appendix A.1.3.</p>
<h1>3.4 Response Generation</h1>
<p>After all task executions are completed, HuggingGPT needs to generate the final responses. As shown in Table 1, HuggingGPT integrates all the information from the previous three stages (task planning, model selection, and task execution) into a concise summary in this stage, including the list of planned tasks, the selected models for the tasks, and the inference results of the models.</p>
<p>Most important among them are the inference results, which are the key points for HuggingGPT to make the final decisions. These inference results are presented in a structured format, such as bounding boxes with detection probabilities in the object detection model, answer distributions in the question-answering model, etc. HuggingGPT allows LLM to receive these structured inference results as input and generate responses in the form of friendly human language. Moreover, instead of simply aggregating the results, LLM generates responses that actively respond to user requests, providing a reliable decision with a confidence level.</p>
<h2>4 Experiments</h2>
<h3>4.1 Settings</h3>
<p>In our experiments, we employed the gpt-3.5-turbo, text-davinci-003 and gpt-4 variants of the GPT models as the main LLMs, which are publicly accessible through the OpenAI API ${ }^{3}$. To enable more stable outputs of LLM, we set the decoding temperature to 0 . In addition, to regulate the LLM output to satisfy the expected format (e.g., JSON format), we set the logit_bias to 0.2 on the format constraints (e.g., " $\left.\left.{ }^{\text {" }}{ }^{\text {" }}\right.$ and " $\left.{ }^{\text {" }}\right)$ ). We provide detailed prompts designed for the task planning, model selection, and response generation stages in Table 1, where ${{$ variable $}}$ indicates the slot which needs to be populated with the corresponding text before being fed into the LLM.</p>
<h3>4.2 Qualitative Results</h3>
<p>Figure 1 and Figure 2 have shown two demonstrations of HuggingGPT. In Figure 1, the user request consists of two sub-tasks: describing the image and object counting. In response to the request, HuggingGPT planned three tasks: image classification, image captioning, and object detection, and launched the google/vit [32], nlpconnet/vit-gpt2-image-captioning [33], and facebook/detr-resnet-101 [34] models, respectively. Finally, HuggingGPT integrated the results of the model inference and generated responses (describing the image and providing the count of contained objects) to the user.</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>A more detailed example is shown in Figure 2. In this case, the user's request included three tasks: detecting the pose of a person in an example image, generating a new image based on that pose and specified text, and creating a speech describing the image. HuggingGPT parsed these into six tasks, including pose detection, text-to-image conditional on pose, object detection, image classification, image captioning, and text-to-speech. We observed that HuggingGPT can correctly orchestrate the execution order and resource dependencies among tasks. For instance, the pose conditional text-to-image task had to follow pose detection and use its output as input. After this, HuggingGPT selected the appropriate model for each task and synthesized the results of the model execution into a final response. For more demonstrations, please refer to the Appendix A.3.</p>
<h1>4.3 Quantitative Evaluation</h1>
<p>In HuggingGPT, task planning plays a pivotal role in the whole workflow, since it determines which tasks will be executed in the subsequent pipeline. Therefore, we deem that the quality of task planning can be utilized to measure the capability of LLMs as a controller in HuggingGPT. For this purpose, we conduct quantitative evaluations to measure the capability of LLMs. Here we simplified the evaluation by only considering the task type, without its associated arguments. To better conduct evaluations on task planning, we group tasks into three distinct categories (see Table 2) and formulate different metrics for them:</p>
<ul>
<li>Single Task refers to a request that involves only one task. We consider the planning to be correct if and only if the task name (i.e., "task") and the predicted label are identically equal. In this context, we utilize F1 and accuracy as the evaluation metrics.</li>
<li>Sequential Task indicates that the user's request can be decomposed into a sequence of multiple sub-tasks. In this case, we employ F1 and normalized Edit Distance [35] as the evaluation metrics.</li>
<li>Graph Task indicates that user requests can be decomposed into directed acyclic graphs. Considering the possibility of multiple planning topologies within graph tasks, relying solely on the F1-score is not enough to reflect the LLM capability in planning. To address this, following Vicuna [36], we employed GPT-4 as a critic to evaluate the correctness of the planning. The accuracy is obtained by evaluating the judgment of GPT-4, referred to as the GPT-4 Score. Detailed information about the GPT-4 Score can be found in Appendix A.1.5.</li>
</ul>
<p>Dataset To conduct our evaluation, we invite some annotators to submit some requests. We collect these data as the evaluation dataset. We use GPT-4 to generate task planning as the pseudo labels, which cover single, sequential, and graph tasks. Furthermore, we invite some expert annotators to label task planning for some complex requests (46 examples) as a high-quality human- annotated dataset. We also plan to improve the quality and quantity of this dataset to further assist in evaluating the LLM's planning capabilities, which remains a future work. More details about this dataset are in Appendix A.2. Using this dataset, we conduct experimental evaluations on various LLMs, including Alpaca-7b [37], Vicuna-7b [36], and GPT models, for task planning.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">LLM</th>
<th style="text-align: center;">GPT-4 Score $\uparrow$</th>
<th style="text-align: center;">Pre $\uparrow$</th>
<th style="text-align: center;">Recall $\uparrow$</th>
<th style="text-align: center;">F1 $\uparrow$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Alpaca-7b</td>
<td style="text-align: center;">13.14</td>
<td style="text-align: center;">16.18</td>
<td style="text-align: center;">28.33</td>
<td style="text-align: center;">20.59</td>
</tr>
<tr>
<td style="text-align: left;">Vicuna-7b</td>
<td style="text-align: center;">19.17</td>
<td style="text-align: center;">13.97</td>
<td style="text-align: center;">28.08</td>
<td style="text-align: center;">18.66</td>
</tr>
<tr>
<td style="text-align: left;">GPT-3.5</td>
<td style="text-align: center;">50.48</td>
<td style="text-align: center;">54.90</td>
<td style="text-align: center;">49.23</td>
<td style="text-align: center;">51.91</td>
</tr>
</tbody>
</table>
<p>Table 5: Evaluation for the graph task.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">LLM</th>
<th style="text-align: center;">$\mathbf{E D} \downarrow$</th>
<th style="text-align: center;">Pre $\uparrow$</th>
<th style="text-align: center;">Recall $\uparrow$</th>
<th style="text-align: center;">F1 $\uparrow$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Alpaca-7b</td>
<td style="text-align: center;">0.83</td>
<td style="text-align: center;">22.27</td>
<td style="text-align: center;">23.35</td>
<td style="text-align: center;">22.80</td>
</tr>
<tr>
<td style="text-align: left;">Vicuna-7b</td>
<td style="text-align: center;">0.80</td>
<td style="text-align: center;">19.15</td>
<td style="text-align: center;">28.45</td>
<td style="text-align: center;">22.89</td>
</tr>
<tr>
<td style="text-align: left;">GPT-3.5</td>
<td style="text-align: center;">0.54</td>
<td style="text-align: center;">61.09</td>
<td style="text-align: center;">45.15</td>
<td style="text-align: center;">51.92</td>
</tr>
</tbody>
</table>
<p>Table 4: Evaluation for the sequential task. "ED" means Edit Distance.</p>
<p>Performance Tables 3, 4 and 5 show the planning capabilities of HuggingGPT on the three categories of GPT-4 annotated datasets, respectively. We observed that GPT-3.5 exhibits more prominent planning capabilities, outperforming the open-source LLMs Alpaca-7b and Vicuna-7b in terms of all types of</p>
<p>user requests. Specifically, in more complex tasks (e.g., sequential and graph tasks), GPT-3.5 has shown absolute predominance over other LLMs. These results also demonstrate the evaluation of task planning can reflect the capability of LLMs as a controller. Therefore, we believe that developing technologies to improve the ability of LLMs in task planning is very important, and we leave it as a future research direction.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">LLM</th>
<th style="text-align: center;">Sequential Task</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Graph Task</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;">Acc $\uparrow$</td>
<td style="text-align: center;">ED $\downarrow$</td>
<td style="text-align: center;">Acc $\uparrow$</td>
<td style="text-align: center;">F1 $\uparrow$</td>
</tr>
<tr>
<td style="text-align: left;">Alpaca-7b</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0.96</td>
<td style="text-align: center;">4.17</td>
<td style="text-align: center;">4.17</td>
</tr>
<tr>
<td style="text-align: left;">Vicuna-7b</td>
<td style="text-align: center;">7.45</td>
<td style="text-align: center;">0.89</td>
<td style="text-align: center;">10.12</td>
<td style="text-align: center;">7.84</td>
</tr>
<tr>
<td style="text-align: left;">GPT-3.5</td>
<td style="text-align: center;">18.18</td>
<td style="text-align: center;">0.76</td>
<td style="text-align: center;">20.83</td>
<td style="text-align: center;">16.45</td>
</tr>
<tr>
<td style="text-align: left;">GPT-4</td>
<td style="text-align: center;">41.36</td>
<td style="text-align: center;">0.61</td>
<td style="text-align: center;">58.33</td>
<td style="text-align: center;">49.28</td>
</tr>
</tbody>
</table>
<p>Table 6: Evaluation on the human-annotated dataset.</p>
<p>Furthermore, we conduct experiments on the high-quality human-annotated dataset to obtain a more precise evaluation. Table 6 reports the comparisons on the human-annotated dataset. These results align with the aforementioned conclusion, highlighting that more powerful LLMs demonstrate better performance in task planning. Moreover, we compare the results between human annotations and GPT-4 annotations. We find that even though GPT-4 outperforms other LLMs, there still remains a substantial gap when compared with human annotations. These observations further underscore the importance of enhancing the planning capabilities of LLMs.</p>
<h1>4.4 Ablation Study</h1>
<table>
<thead>
<tr>
<th style="text-align: center;">Demo Variety <br> (# task types)</th>
<th style="text-align: center;">LLM</th>
<th style="text-align: center;">Single Task</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Sequencial Task</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Graph Task</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Acc $\uparrow$</td>
<td style="text-align: center;">F1 $\uparrow$</td>
<td style="text-align: center;">ED (\%) $\downarrow$</td>
<td style="text-align: center;">F1 $\uparrow$</td>
<td style="text-align: center;">F1 $\uparrow$</td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;">GPT-3.5</td>
<td style="text-align: center;">43.31</td>
<td style="text-align: center;">48.29</td>
<td style="text-align: center;">71.27</td>
<td style="text-align: center;">32.15</td>
<td style="text-align: center;">43.42</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">GPT-4</td>
<td style="text-align: center;">65.59</td>
<td style="text-align: center;">67.08</td>
<td style="text-align: center;">47.17</td>
<td style="text-align: center;">55.13</td>
<td style="text-align: center;">53.96</td>
</tr>
<tr>
<td style="text-align: center;">6</td>
<td style="text-align: center;">GPT-3.5</td>
<td style="text-align: center;">51.31</td>
<td style="text-align: center;">51.81</td>
<td style="text-align: center;">60.81</td>
<td style="text-align: center;">43.19</td>
<td style="text-align: center;">58.51</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">GPT-4</td>
<td style="text-align: center;">66.83</td>
<td style="text-align: center;">68.14</td>
<td style="text-align: center;">42.20</td>
<td style="text-align: center;">58.18</td>
<td style="text-align: center;">64.34</td>
</tr>
<tr>
<td style="text-align: center;">10</td>
<td style="text-align: center;">GPT-3.5</td>
<td style="text-align: center;">52.83</td>
<td style="text-align: center;">53.70</td>
<td style="text-align: center;">56.52</td>
<td style="text-align: center;">47.03</td>
<td style="text-align: center;">64.24</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">GPT-4</td>
<td style="text-align: center;">67.52</td>
<td style="text-align: center;">71.05</td>
<td style="text-align: center;">39.32</td>
<td style="text-align: center;">60.80</td>
<td style="text-align: center;">66.90</td>
</tr>
</tbody>
</table>
<p>Table 7: Evaluation of task planning in terms of the variety of demonstrations. We refer to the variety of demonstrations as the number of different task types involved in the demonstrations.
<img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 3: Evaluation of task planning with different numbers of demonstrations.</p>
<p>As previously mentioned in our default setting, we apply few-shot demonstrations to enhance the capability of LLMs in understanding user intent and parsing task sequences. To better investigate the effect of demonstrations on our framework, we conducted a series of ablation studies from two perspectives: the number of demonstrations and the variety of demonstrations. Table 7 reports the planning results under the different variety of demonstrations. We observe that increasing the variety among demonstrations can moderately improve the performance of LLMs in conduct planning. Moreover, Figure 3 illustrates the results of task planning with different number of demonstrations. We can find that adding some demonstrations can slightly improve model performance but this improvement will be limited when the number is over 4 demonstrations. In the future, we will continue to explore more elements that can improve the capability of LLMs at different stages.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">LLM</th>
<th style="text-align: center;">Task Planning</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Model Selection</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Response</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">:--:</td>
<td style="text-align: center;">:--:</td>
<td style="text-align: center;">:--:</td>
<td style="text-align: center;">:--:</td>
<td style="text-align: center;">:--:</td>
<td style="text-align: center;">:--:</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;">Passing Rate $\uparrow$</td>
<td style="text-align: center;">Rationality $\uparrow$</td>
<td style="text-align: center;">Passing Rate $\uparrow$</td>
<td style="text-align: center;">Rationality $\uparrow$</td>
<td style="text-align: center;">Success Rate $\uparrow$</td>
</tr>
<tr>
<td style="text-align: left;">Alpaca-13b</td>
<td style="text-align: center;">51.04</td>
<td style="text-align: center;">32.17</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">6.92</td>
</tr>
<tr>
<td style="text-align: left;">Vicuna-13b</td>
<td style="text-align: center;">79.41</td>
<td style="text-align: center;">58.41</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">15.64</td>
</tr>
<tr>
<td style="text-align: left;">GPT-3.5</td>
<td style="text-align: center;">91.22</td>
<td style="text-align: center;">78.47</td>
<td style="text-align: center;">93.89</td>
<td style="text-align: center;">84.29</td>
<td style="text-align: center;">63.08</td>
</tr>
</tbody>
</table>
<p>Table 8: Human Evaluation on different LLMs. We report two metrics, passing rate (\%) and rationality $(\%)$, in the task planning and model selection stages and report a straightforward success rate (\%) to evaluate whether the request raised by the user is finally resolved.</p>
<h1>4.5 Human Evaluation</h1>
<p>In addition to objective evaluations, we also invite human experts to conduct a subjective evaluation in our experiments. We collected 130 diverse requests to evaluate the performance of HuggingGPT at various stages, including task planning, model selection, and final response generation. We designed three evaluation metrics, namely passing rate, rationality, and success rate. The definitions of each metric can be found in Appendix A.1.6. The results are reported in Table 8. From Table 8, we can observe similar conclusions that GPT-3.5 can significantly outperform open-source LLMs like Alpaca-13b and Vicuna-13b by a large margin across different stages, from task planning to response generation stages. These results indicate that our objective evaluations are aligned with human evaluation and further demonstrate the necessity of a powerful LLM as a controller in the framework of autonomous agents.</p>
<h2>5 Limitations</h2>
<p>HuggingGPT has presented a new paradigm for designing AI solutions, but we want to highlight that there still remain some limitations or improvement spaces: 1) Planning in HuggingGPT heavily relies on the capability of LLM. Consequently, we cannot ensure that the generated plan will always be feasible and optimal. Therefore, it is crucial to explore ways to optimize the LLM in order to enhance its planning abilities; 2) Efficiency poses a common challenge in our framework. To build such a collaborative system (i.e., HuggingGPT) with task automation, it heavily relies on a powerful controller (e.g., ChatGPT). However, HuggingGPT requires multiple interactions with LLMs throughout the whole workflow and thus brings increasing time costs for generating the response; 3) Token Lengths is another common problem when using LLM, since the maximum token length is always limited. Although some works have extended the maximum length to 32 K , it is still insatiable for us if we want to connect numerous models. Therefore, how to briefly and effectively summarize model descriptions is also worthy of exploration; 4) Instability is mainly caused because LLMs are usually uncontrollable. Although LLM is skilled in generation, it still possibly fails to conform to instructions or give incorrect answers during the prediction, leading to exceptions in the program workflow. How to reduce these uncertainties during inference should be considered in designing systems.</p>
<h2>6 Conclusion</h2>
<p>In this paper, we propose a system named HuggingGPT to solve AI tasks, with language as the interface to connect LLMs with AI models. The principle of our system is that an LLM can be viewed as a controller to manage AI models, and can utilize models from ML communities like Hugging Face to automatically solve different requests of users. By exploiting the advantages of LLMs in understanding and reasoning, HuggingGPT can dissect the intent of users and decompose it into multiple sub-tasks. And then, based on expert model descriptions, HuggingGPT is able to assign the most suitable models for each task and integrate results from different models to generate the final response. By utilizing the ability of numerous AI models from machine learning communities, HuggingGPT demonstrates immense potential in solving challenging AI tasks, thereby paving a new pathway towards achieving artificial general intelligence.</p>
<h1>Acknowledgement</h1>
<p>We appreciate the support of the Hugging Face team to help us in improving our GitHub project and web demo. Besides, we also appreciate the contributions of Bei Li, Kai Shen, Meiqi Chen, Qingyao Guo, Yichong Leng, Yuancheng Wang, Dingyao Yu for the data labeling and Wenqi Zhang, Wen Wang, Zeqi Tan for paper revision.
This work is partly supported by the Fundamental Research Funds for the Central Universities (No. 226-2023-00060), Key Research and Development Program of Zhejiang Province (No. 2023C01152), National Key Research and Development Project of China (No. 2018AAA0101900), and MOE Engineering Research Center of Digital Library.</p>
<h2>References</h2>
<p>[1] Tom B. Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, Sandhini Agarwal, Ariel Herbert-Voss, Gretchen Krueger, Tom Henighan, Rewon Child, Aditya Ramesh, Daniel M. Ziegler, Jeffrey Wu, Clemens Winter, Christopher Hesse, Mark Chen, Eric Sigler, Mateusz Litwin, Scott Gray, Benjamin Chess, Jack Clark, Christopher Berner, Sam McCandlish, Alec Radford, Ilya Sutskever, and Dario Amodei. Language Models are Few-Shot Learners. In NeurIPS, 2020.
[2] Long Ouyang, Jeff Wu, Xu Jiang, Diogo Almeida, Carroll L. Wainwright, Pamela Mishkin, Chong Zhang, Sandhini Agarwal, Katarina Slama, Alex Ray, John Schulman, Jacob Hilton, Fraser Kelton, Luke Miller, Maddie Simens, Amanda Askell, Peter Welinder, Paul F. Christiano, Jan Leike, and Ryan Lowe. Training language models to follow instructions with human feedback. CoRR, abs/2203.02155, 2022.
[3] Aakanksha Chowdhery, Sharan Narang, Jacob Devlin, Maarten Bosma, Gaurav Mishra, Adam Roberts, Paul Barham, Hyung Won Chung, Charles Sutton, Sebastian Gehrmann, and others. Palm: Scaling language modeling with pathways. ArXiv, abs/2204.02311, 2022.
[4] Susan Zhang, Stephen Roller, Naman Goyal, Mikel Artetxe, Moya Chen, Shuohui Chen, Christopher Dewan, Mona Diab, Xian Li, Xi Victoria Lin, Todor Mihaylov, Myle Ott, Sam Shleifer, Kurt Shuster, Daniel Simig, Punit Singh Koura, Anjali Sridhar, Tianlu Wang, and Luke Zettlemoyer. Opt: Open Pre-trained Transformer Language Models. ArXiv, abs/2205.01068, 2022.
[5] Aohan Zeng, Xiao Liu, Zhengxiao Du, Zihan Wang, Hanyu Lai, Ming Ding, Zhuoyi Yang, Yifan Xu, Wendi Zheng, Xiao Xia, Weng Lam Tam, Zixuan Ma, Yufei Xue, Jidong Zhai, Wenguang Chen, Zhiyuan Liu, Peng Zhang, Yuxiao Dong, and Jie Tang. Glm-130b: An Open Bilingual Pre-trained Model. ICLR 2023 poster, 2023.
[6] Hugo Touvron, Thibaut Lavril, Gautier Izacard, Xavier Martinet, Marie-Anne Lachaux, Timothée Lacroix, Baptiste Rozière, Naman Goyal, Eric Hambro, Faisal Azhar, Aur'elien Rodriguez, Armand Joulin, Edouard Grave, and Guillaume Lample. Llama: Open and Efficient Foundation Language Models. ArXiv, abs/2302.13971, 2023.
[7] Sang Michael Xie, Aditi Raghunathan, Percy Liang, and Tengyu Ma. An Explanation of In-context Learning as Implicit Bayesian Inference. ICLR 2022 Poster, 2022.
[8] Sewon Min, Xinxi Lyu, Ari Holtzman, Mikel Artetxe, Mike Lewis, Hannaneh Hajishirzi, and Luke Zettlemoyer. Rethinking the Role of Demonstrations: What Makes In-Context Learning Work? In Proceedings of the 2022 Conference on Empirical Methods in Natural Language Processing (EMNLP). Association for Computational Linguistics, 2022.
[9] Jason Wei, Maarten Bosma, Vincent Zhao, Kelvin Guu, Adams Wei Yu, Brian Lester, Nan Du, Andrew M. Dai, and Quoc V Le. Finetuned language models are zero-shot learners. In International Conference on Learning Representations, 2022.
[10] Yizhong Wang, Swaroop Mishra, Pegah Alipoormolabashi, Yeganeh Kordi, Amirreza Mirzaei, Atharva Naik, Arjun Ashok, Arut Selvan Dhanasekaran, Anjana Arunkumar, David Stap, Eshaan</p>
<p>Pathak, Giannis Karamanolakis, Haizhi Gary Lai, Ishan Virendrabhai Purohit, Ishani Mondal, Jacob William Anderson, Kirby C. Kuznia, Krima Doshi, Kuntal Kumar Pal, Maitreya Patel, Mehrad Moradshahi, Mihir Parmar, Mirali Purohit, Neeraj Varshney, Phani Rohitha Kaza, Pulkit Verma, Ravsehaj Singh Puri, rushang karia, Savan Doshi, Shailaja Keyur Sampat, Siddhartha Mishra, Sujan Reddy A, Sumanta Patro, Tanay Dixit, Xudong Shen, Chitta Baral, Yejin Choi, Noah A. Smith, Hannaneh Hajishirzi, and Daniel Khashabi. Super-NaturalInstructions: Generalization via Declarative Instructions on 1600+ NLP Tasks. In Proceedings of the 2022 Conference on Empirical Methods in Natural Language Processing (EMNLP). Association for Computational Linguistics, 2022.
[11] S. Iyer, Xiaojuan Lin, Ramakanth Pasunuru, Todor Mihaylov, Daniel Simig, Ping Yu, Kurt Shuster, Tianlu Wang, Qing Liu, Punit Singh Koura, Xian Li, Brian O’Horo, Gabriel Pereyra, Jeff Wang, Christopher Dewan, Asli Celikyilmaz, Luke Zettlemoyer, and Veselin Stoyanov. OptIML: Scaling Language Model Instruction Meta Learning through the Lens of Generalization. ArXiv, abs/2212.12017, 2022.
[12] Hyung Won Chung, Le Hou, Shayne Longpre, Barret Zoph, Yi Tay, William Fedus, Eric Li, Xuezhi Wang, Mostafa Dehghani, Siddhartha Brahma, Albert Webson, Shixiang Shane Gu, Zhuyun Dai, Mirac Suzgun, Xinyun Chen, Aakanksha Chowdhery, Sharan Narang, Gaurav Mishra, Adams Yu, Vincent Y. Zhao, Yanping Huang, Andrew M. Dai, Hongkun Yu, Slav Petrov, Ed H. Chi, Jeff Dean, Jacob Devlin, Adam Roberts, Denny Zhou, Quoc V. Le, and Jason Wei. Scaling instruction-finetuned language models. CoRR, abs/2210.11416, 2022.
[13] Yizhong Wang, Yeganeh Kordi, Swaroop Mishra, Alisa Liu, Noah A. Smith, Daniel Khashabi, and Hannaneh Hajishirzi. Self-instruct: Aligning language model with self generated instructions, 2022.
[14] Shayne Longpre, Le Hou, Tu Vu, Albert Webson, Hyung Won Chung, Yi Tay, Denny Zhou, Quoc V. Le, Barret Zoph, Jason Wei, and Adam Roberts. The flan collection: Designing data and methods for effective instruction tuning. CoRR, abs/2301.13688, 2023.
[15] Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, brian ichter, Fei Xia, Ed Chi, Quoc V Le, and Denny Zhou. Chain of Thought Prompting Elicits Reasoning in Large Language Models. In Conference on Neural Information Processing Systems (NeurIPS), 2022.
[16] Takeshi Kojima, Shixiang (Shane) Gu, Machel Reid, Yutaka Matsuo, and Yusuke Iwasawa. Large Language Models are Zero-Shot Reasoners. In Conference on Neural Information Processing Systems (NeurIPS), 2022.
[17] Luyu Gao, Aman Madaan, Shuyan Zhou, Uri Alon, Pengfei Liu, Yiming Yang, Jamie Callan, and Graham Neubig. Pal: Program-aided Language Models. ArXiv, abs/2211.10435, 2022.
[18] Xuezhi Wang, Jason Wei, Dale Schuurmans, Quoc V Le, Ed H. Chi, Sharan Narang, Aakanksha Chowdhery, and Denny Zhou. Self-Consistency Improves Chain of Thought Reasoning in Language Models. ICLR 2023 poster, abs/2203.11171, 2023.
[19] Jason Wei, Yi Tay, Rishi Bommasani, Colin Raffel, Barret Zoph, Sebastian Borgeaud, Dani Yogatama, Maarten Bosma, Denny Zhou, Donald Metzler, Ed H. Chi, Tatsunori Hashimoto, Oriol Vinyals, Percy Liang, Jeff Dean, and William Fedus. Emergent abilities of large language models. CoRR, abs/2206.07682, 2022.
[20] OpenAI. Gpt-4 technical report, 2023.
[21] Jean-Baptiste Alayrac, Jeff Donahue, Pauline Luc, Antoine Miech, Iain Barr, Yana Hasson, Karel Lenc, Arthur Mensch, Katie Millican, Malcolm Reynolds, Roman Ring, Eliza Rutherford, Serkan Cabi, Tengda Han, Zhitao Gong, Sina Samangooei, Marianne Monteiro, Jacob Menick, Sebastian Borgeaud, Andrew Brock, Aida Nematzadeh, Sahand Sharifzadeh, Mikolaj Binkowski, Ricardo Barreira, Oriol Vinyals, Andrew Zisserman, and Karen Simonyan. Flamingo: a visual language model for few-shot learning, 2022.
[22] Junnan Li, Dongxu Li, S. Savarese, and Steven Hoi. Blip-2: Bootstrapping Language-Image Pre-training with Frozen Image Encoders and Large Language Models. ArXiv, abs/2301.12597, 2023.</p>
<p>[23] Shaohan Huang, Li Dong, Wenhui Wang, Y. Hao, Saksham Singhal, Shuming Ma, Tengchao Lv, Lei Cui, O. Mohammed, Qiang Liu, Kriti Aggarwal, Zewen Chi, Johan Bjorck, Vishrav Chaudhary, Subhojit Som, Xia Song, and Furu Wei. Language Is Not All You Need: Aligning Perception with Language Models. ArXiv, abs/2302.14045, 2023.
[24] Timo Schick, Jane Dwivedi-Yu, Roberto Dessì, Roberta Raileanu, M. Lomeli, Luke Zettlemoyer, Nicola Cancedda, and Thomas Scialom. Toolformer: Language Models Can Teach Themselves to Use Tools. ArXiv, abs/2302.04761, 2023.
[25] Dídac Surís, Sachit Menon, and Carl Vondrick. Vipergpt: Visual inference via python execution for reasoning, 2023.
[26] Chenfei Wu, Sheng-Kai Yin, Weizhen Qi, Xiaodong Wang, Zecheng Tang, and Nan Duan. Visual ChatGPT: Talking, Drawing and Editing with Visual Foundation Models. arXiv, 2023.
[27] Yaobo Liang, Chenfei Wu, Ting Song, Wenshan Wu, Yan Xia, Yu Liu, Yang Ou, Shuai Lu, Lei Ji, Shaoguang Mao, Yun Wang, Linjun Shou, Ming Gong, and Nan Duan. Taskmatrix.ai: Completing tasks by connecting foundation models with millions of apis, 2023.
[28] Yujia Qin, Shengding Hu, Yankai Lin, Weize Chen, Ning Ding, Ganqu Cui, Zheni Zeng, Yufei Huang, Chaojun Xiao, Chi Han, Yi Ren Fung, Yusheng Su, Huadong Wang, Cheng Qian, Runchu Tian, Kunlun Zhu, Shihao Liang, Xingyu Shen, Bokai Xu, Zhen Zhang, Yining Ye, Bowen Li, Ziwei Tang, Jing Yi, Yuzhang Zhu, Zhenning Dai, Lan Yan, Xin Cong, Yaxi Lu, Weilin Zhao, Yuxiang Huang, Junxi Yan, Xu Han, Xian Sun, Dahai Li, Jason Phang, Cheng Yang, Tongshuang Wu, Heng Ji, Zhiyuan Liu, and Maosong Sun. Tool learning with foundation models, 2023.
[29] Junnan Li, Dongxu Li, Caiming Xiong, and Steven C. H. Hoi. Blip: Bootstrapping LanguageImage Pre-training for Unified Vision-Language Understanding and Generation. In International Conference on Machine Learning (ICML), pages 12888-12900, 2022.
[30] Lvmin Zhang and Maneesh Agrawala. Adding Conditional Control to Text-to-Image Diffusion Models. ArXiv, abs/2302.05543, 2023.
[31] Tanmay Gupta and Aniruddha Kembhavi. Visual Programming: Compositional visual reasoning without training. arXiv, abs/2211.11559, 2022.
[32] Alexey Dosovitskiy, Lucas Beyer, Alexander Kolesnikov, Dirk Weissenborn, Xiaohua Zhai, Thomas Unterthiner, Mostafa Dehghani, Matthias Minderer, Georg Heigold, Sylvain Gelly, Jakob Uszkoreit, and Neil Houlsby. An image is worth 16x16 words: Transformers for image recognition at scale, 2021.
[33] Ankur Kumar. The illustrated image captioning using transformers. ankur3107.github.io, 2022.
[34] Nicolas Carion, Francisco Massa, Gabriel Synnaeve, Nicolas Usunier, Alexander Kirillov, and Sergey Zagoruyko. End-to-end object detection with transformers, 2020.
[35] A. Marzal and E. Vidal. Computation of normalized edit distance and applications. IEEE Transactions on Pattern Analysis and Machine Intelligence, 15(9):926-932, 1993.
[36] Wei-Lin Chiang, Zhuohan Li, Zi Lin, Ying Sheng, Zhanghao Wu, Hao Zhang, Lianmin Zheng, Siyuan Zhuang, Yonghao Zhuang, Joseph E. Gonzalez, Ion Stoica, and Eric P. Xing. Vicuna: An open-source chatbot impressing gpt-4 with $90 \%$ * chatgpt quality, March 2023.
[37] Rohan Taori, Ishaan Gulrajani, Tianyi Zhang, Yann Dubois, Xuechen Li, Carlos Guestrin, Percy Liang, and Tatsunori B. Hashimoto. Stanford alpaca: An instruction-following llama model. https://github.com/tatsu-lab/stanford_alpaca, 2023.</p>
<h1>A Appendix</h1>
<h2>A. 1 More details</h2>
<p>In this section, we will present more details about some designs of each stage in HuggingGPT.</p>
<h2>A.1.1 Template for Task Planning</h2>
<p>To format the parsed task, we define the template [{"task": task, "id", task_id, "dep": dependency_task_ids, "args": ["text": text, "image": URL, "audio": URL, "video": URL] ]] with four slots: "task", "id", "dep", and "args". Table 9 presents the definitions of each slot.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Name</th>
<th style="text-align: center;">Definitions</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">"task"</td>
<td style="text-align: center;">It represents the type of the parsed task. It covers different tasks in language, visual, video, audio, etc. The currently supported task list of HuggingGPT is shown in Table 13.</td>
</tr>
<tr>
<td style="text-align: center;">"id"</td>
<td style="text-align: center;">The unique identifier for task planning, which is used for references to dependent tasks and their generated resources.</td>
</tr>
<tr>
<td style="text-align: center;">"dep"</td>
<td style="text-align: center;">It defines the pre-requisite tasks required for execution. The task will be launched only when all the pre-requisite dependent tasks are finished.</td>
</tr>
<tr>
<td style="text-align: center;">"args"</td>
<td style="text-align: center;">It contains the list of required arguments for task execution. It contains three subfields populated with text, image, and audio resources according to the task type. They are resolved from either the user's request or the generated resources of the dependent tasks. The corresponding argument types for different task types are shown in Table 13.</td>
</tr>
</tbody>
</table>
<p>Table 9: Definitions for each slot for parsed tasks in the task planning.</p>
<h2>A.1.2 Model Descriptions</h2>
<p>In general, the Hugging Face Hub hosts expert models that come with detailed model descriptions, typically provided by the developers. These descriptions encompass various aspects of the model, such as its function, architecture, supported languages and domains, licensing, and other relevant details. These comprehensive model descriptions play a crucial role in aiding the decision of HuggingGPT. By assessing the user's requests and comparing them with the model descriptions, HuggingGPT can effectively determine the most suitable model for the given task.</p>
<h2>A.1.3 Hybrid Endpoint in System Deployment</h2>
<p>An ideal scenario is that we only use inference endpoints on cloud service (e.g., Hugging Face). However, in some cases, we have to deploy local inference endpoints, such as when inference endpoints for certain models do not exist, the inference is time-consuming, or network access is limited. To keep the stability and efficiency of the system, HuggingGPT allows us to pull and run some common or time-consuming models locally. The local inference endpoints are fast but cover fewer models, while the inference endpoints in the cloud service (e.g., Hugging Face) are the opposite. Therefore, local endpoints have higher priority than cloud inference endpoints. Only if the matched model is not deployed locally, HuggingGPT will run the model on the cloud endpoint like Hugging Face. Overall, we think that how to design and deploy systems with better stability for HuggingGPT or other autonomous agents will be very important in the future.</p>
<h2>A.1.4 Task List</h2>
<p>Up to now, HuggingGPT has supported 24 AI tasks, which cover language, vision, speech and etc. Table 13 presents the detailed information of the supported task list in HuggingGPT.</p>
<h2>A.1.5 GPT-4 Score</h2>
<p>Following the evaluation method used by Vicuna [36], we employed GPT-4 as an evaluator to assess the planning capabilities of LLMs. In more detail, we include the user request and the task list planned by LLM in the prompt, and then let GPT-4 judge whether the list of tasks is accurate and</p>
<p>also provide a rationale. To guide GPT-4 to make the correct judgments, we designed some task guidelines: 1) the tasks are in the supported task list (see Table 13); 2) the planned task list can reach the solution to the user request; 3) the logical relationship and order among the tasks are reasonable. In the prompt, we also supplement several positive and negative demonstrations of task planning to provide reference for GPT-4. The prompt for GPT-4 score is shown in Table 10. We further want to emphasize that GPT-4 score is not always correct although it has shown a high correlation. Therefore, we also expect to explore more confident metrics to evaluate the ability of LLMs in planning.</p>
<p>As a critic, your task is to assess whether the AI assistant has properly planned the task based on the user's request. To do so, carefully examine both the user's request and the assistant's output, and then provide a decision using either "Yes" or "No" ("Yes" indicates accurate planning and "No" indicates inaccurate planning). Additionally, provide a rationale for your choice using the following structure: { "choice": "yes"/"no", "reason": "Your reason for your choice" }. Please adhere to the following guidelines: 1. The task must be selected from the following options: ${{$ Available Task List }}. 2. Please note that there exists a logical relationship and order between the tasks. 3. Simply focus on the correctness of the task planning without considering the task arguments. Positive examples: ${{$ Positive Demos }} Negative examples: ${{$ Negative Demos }} Current user request: ${{$ Input }} AI assistant's output: ${{$ Output }} Your judgement:</p>
<p>Table 10: The prompt design for GPT-4 Score.</p>
<h1>A.1.6 Human Evaluation</h1>
<p>To better align human preferences, we invited three human experts to evaluate the different stages of HuggingGPT. First, we selected 3-5 tasks from the task list of Hugging Face and then manually created user requests based on the selected tasks. We will discard samples that cannot generate new requests from the selected tasks. Totally, we conduct random sampling by using different seeds, resulting in a collection of 130 diverse user requests. Based on the produced samples, we evaluate the performance of LLMs at different stages (e.g., task planning, model selection, and response generation). Here, we designed three evaluation metrics:</p>
<ul>
<li>Passing Rate: to determine whether the planned task graph or selected model can be successfully executed;</li>
<li>Rationality: to assess whether the generated task sequence or selected tools align with user requests in a rational manner;</li>
<li>Success Rate: to verify if the final results satisfy the user's request.</li>
</ul>
<p>Three human experts were asked to annotate the provided data according to our well-designed metrics and then calculated the average values to obtain the final scores.</p>
<h2>A. 2 Datasets for Task Planning Evaluation</h2>
<p>As aforementioned, we create two datasets for evaluating task planning. Here we provide more details about these datasets. In total, we gathered a diverse set of 3,497 user requests. Since labeling this dataset to obtain the task planning for each request is heavy, we employed the capabilities of GPT-4 to annotate them. Finally, these auto-labeled requests can be categorized into three types: single task ( 1,450 requests), sequence task ( 1,917 requests), and graph task ( 130 requests). For a more reliable evaluation, we also construct a human-annotated dataset. We invite some expert annotators to label some complex requests, which include 46 examples. Currently, the human-annotated dataset includes 24 sequential tasks and 22 graph tasks. Detailed statistics about the GPT-4-annotated and human-annotated datasets are shown in Table 11.</p>
<h2>A. 3 Case Study</h2>
<h2>A.3.1 Case Study on Various Tasks</h2>
<p>Through task planning and model selection, HuggingGPT, a multi-model collaborative system, empowers LLMs with an extended range of capabilities. Here, we extensively evaluate HuggingGPT across diverse multimodal tasks, and some selected cases are shown in Figures 4 and 5. With the cooperation of a powerful LLM and numerous expert models, HuggingGPT effectively tackles</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Datasets</th>
<th style="text-align: center;">Number of Requests by Type</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Request Length</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Number of Tasks</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;">Single</td>
<td style="text-align: center;">Sequential</td>
<td style="text-align: center;">Graph</td>
<td style="text-align: center;">Max</td>
<td style="text-align: center;">Average</td>
<td style="text-align: center;">Max</td>
<td style="text-align: center;">Average</td>
</tr>
<tr>
<td style="text-align: left;">GPT-4-annotated</td>
<td style="text-align: center;">1,450</td>
<td style="text-align: center;">1,917</td>
<td style="text-align: center;">130</td>
<td style="text-align: center;">52</td>
<td style="text-align: center;">13.26</td>
<td style="text-align: center;">13</td>
<td style="text-align: center;">1.82</td>
</tr>
<tr>
<td style="text-align: left;">Human-annotated</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">24</td>
<td style="text-align: center;">22</td>
<td style="text-align: center;">95</td>
<td style="text-align: center;">10.20</td>
<td style="text-align: center;">12</td>
<td style="text-align: center;">2.00</td>
</tr>
</tbody>
</table>
<p>Table 11: Statistics on datasets for task planning evaluation.
tasks spanning various modalities, including language, image, audio, and video. Its proficiency encompasses diverse task forms, such as detection, generation, classification, and question answering.</p>
<h1>A.3.2 Case Study on Complex Tasks</h1>
<p>Sometimes, user requests may contain multiple implicit tasks or require multi-faceted information, in which case we cannot rely on a single expert model to solve them. To overcome this challenge, HuggingGPT organizes the collaboration of multiple models through task planning. As shown in Figures 6, 7 and 8, we conducted experiments to evaluate the effectiveness of HuggingGPT in the case of complex tasks:</p>
<ul>
<li>Figure 6 demonstrates the ability of HuggingGPT to cope with complex tasks in a multi-round conversation scenario. The user splits a complex request into several steps and reaches the final goal through multiple rounds of interaction. We find that HuggingGPT can track the contextual state of user requests through the dialogue context management in the task planning stage. Moreover, HuggingGPT demonstrates the ability to access user-referenced resources and proficiently resolve dependencies between tasks in the dialogue scenario.</li>
<li>Figure 7 shows that for a simple request like "describe the image in as much detail as possible", HuggingGPT can decompose it into five related tasks, namely image captioning, image classification, object detection, segmentation, and visual question answering tasks. HuggingGPT assigns expert models to handle each task to gather information about the image from various perspectives. Finally, the LLM integrates this diverse information to deliver a comprehensive and detailed description to the user.</li>
<li>Figure 8 shows two cases where a user request can contain several tasks. In these cases, HuggingGPT first performs all the tasks requested by the user by orchestrating the work of multiple expert models, and then let the LLM aggregate the model inference results to respond to the user.</li>
</ul>
<p>In summary, HuggingGPT establishes the collaboration of LLM with external expert models and shows promising performance on various forms of complex tasks.</p>
<h2>A.3.3 Case Study on More Scenarios</h2>
<p>We show more cases here to illustrate HuggingGPT's ability to handle realistic scenarios with task resource dependencies, multimodality, multiple resources, etc. To make clear the workflow of HuggingGPT, we also provide the results of the task planning and task execution stages.</p>
<ul>
<li>Figure 9 illustrates the operational process of HuggingGPT in the presence of resource dependencies among tasks. In this case, HuggingGPT can parse out concrete tasks based on abstract requests from the user, including pose detection, image captioning, and pose conditional image generation tasks. Furthermore, HuggingGPT effectively recognizes the dependencies between task #3 and tasks #1, #2, and injected the inferred results of tasks #1 and #2 into the input arguments of task #3 after the dependency tasks were completed.</li>
<li>
<p>Figure 10 demonstrates the conversational ability of HuggingGPT on audio and video modalities. In the two cases, it shows HuggingGPT completes the user-requested text-to-audio and text-to-video tasks via the expert models, respectively. In the top one, the two models are executed in parallel (generating audio and generating video concurrently), and in the bottom one, the two models are executed serially (generating text from the image first, and then generating audio based on the text). This further validates that HuggingGPT can organize the cooperation between models and the resource dependencies between tasks.</p>
</li>
<li>
<p>Figure 11 shows HuggingGPT integrating multiple user-input resources to perform simple reasoning. We can find that HuggingGPT can break up the main task into multiple basic tasks even with multiple resources, and finally integrate the results of multiple inferences from multiple models to get the correct answer.</p>
</li>
</ul>
<h1>B More Discussion about Related Works</h1>
<p>The emergence of ChatGPT and its subsequent variant GPT-4, has created a revolutionary technology wave in LLM and AI area. Especially in the past several weeks, we also have witnessed some experimental but also very interesting LLM applications, such as AutoGPT ${ }^{4}$, AgentGPT ${ }^{5}$, BabyAGI ${ }^{6}$, and etc. Therefore, we also give some discussions about these works and provide some comparisons from multiple dimensions, including scenarios, planning, tools, as shown in Table 12.</p>
<p>Scenarios Currently, these experimental agents (e.g., AutoGPT, AgentGPT and BabyAGI) are mainly used to solve daily requests. While for HuggingGPT, it focuses on solving tasks in the AI area (e.g., vision, language, speech, etc), by utilizing the powers of Hugging Face. Therefore, HuggingGPT can be considered as a more professional agent. Generally speaking, users can choose the most suitable agent based on their requirements (e.g., daily requests or professional areas) or customize their own agent by defining knowledge, planning strategy and toolkits.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: center;">Scenarios</th>
<th style="text-align: center;">Planning</th>
<th style="text-align: center;">Tools</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">BabyAGI</td>
<td style="text-align: center;">Daily</td>
<td style="text-align: center;">Iterative Planning</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">AgentGPT</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">AutoGPT</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Web Search, Code Executor, ...</td>
</tr>
<tr>
<td style="text-align: left;">HuggingGPT</td>
<td style="text-align: center;">AI area</td>
<td style="text-align: center;">Global Planning</td>
<td style="text-align: center;">Models in Hugging Face</td>
</tr>
</tbody>
</table>
<p>Table 12: Comparision between HuggingGPT and other autonomous agents.</p>
<p>Planning BabyAGI, AgentGPT and AutoGPT can all be considered as autonomous agents, which provide some solutions for task automation. For these agents, all of them adopt step-by-step thinking, which iteratively generates the next task by using LLMs. Besides, AutoGPT employs an addition reflexion module for each task generation, which is used to check whether the current predicted task is appropriate or not. Compared with these applications, HuggingGPT adopts a global planning strategy to obtain the entire task queue within one query. It is difficult to judge which one is better, since each one has its deficiencies and both of them heavily rely on the ability of LLMs, even though existing LLMs are not specifically designed for task planning. For example, iterative planning combined with reflexion requires a huge amount of LLM queries, and if one step generates an error prediction, the entire workflow would possibly enter an endless loop. While for global planning, although it can always produce a solution for each user request within one query, it still cannot guarantee the correctness of each step or the optimality of the entire plan. Therefore, both iterative and global planning have their own merits and can borrow from each other to alleviate their shortcoming. Additionally, one notable point is that the difficulty of task planning is also linearly correlated to the task range. As the scope of tasks increases, it becomes more challenging for the controller to predict precise plans. Consequently, optimizing the controller (i.e., LLM) for task planning will be crucial in building autonomous agents.</p>
<p>Tools Among these agents, AutoGPT is the main one to involve other tools for usage. More specifically, AutoGPT primarily uses some common tools (e.g., web search, code executor), while HuggingGPT utilizes the expert models of ML communities (e.g., Hugging Face). Therefore, AutoGPT has a broader task range but is not suitable for more professional problems, whereas HuggingGPT is more specialized and focuses on solving more complex AI tasks. Therefore, the</p>
<p><sup id="fnref5:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>range of tools used in LLMs will be a trade-off between task depth and task range. In addition, we also note some industry products for LLM applications (e.g., ChatGPT plugins ${ }^{7}$ ) and developer tools (e.g., LangChain ${ }^{8}$, HuggingFace Transformer Agent ${ }^{9}$, Semantic Kernels ${ }^{10}$ ) for LLM applications. We believe these rapid developments will also facilitate the community to explore how to better integrate LLMs with external tools.</p>
<p>Overall, HuggingGPT can also be considered as an autonomous agent. Compared with these experimental agents, which mainly use GPT models to generate solutions for user requests, HuggingGPT systematically presents a clear pipeline with four stages: task planning, model selection, task execution and response generation. Such a pipeline can effectively improve the success rate of solving user requests. Besides, HuggingGPT also introduces a global planning strategy to decompose user requests and thus accomplish task automation. Furthermore, HuggingGPT is a collaborative system, which fully utilizes the power of expert models from ML communities to solve AI tasks and present the huge potential of using external tools. Compared with these agents, HuggingGPT allows us to better solve tasks more effectively in professional areas and can be easily extended to any vertical domain. In the future, we will continue to enhance HuggingGPT with even more powerful abilities to develop a versatile autonomous agent with unlimited possibilities.</p>
<p><sup id="fnref6:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<h2>NLP &gt; Named Entity Recognition</h2>
<p>Query: please recognize named entities in the sentence [" that is to end the state of hostility , " Thursday's overseas edition of the People's Daily quoted Tang as saying. ]</p>
<p>Response: I have recognized named entities in the sentence 'that is to end the state of hostility , " Thursday's overseas edition of the People's Daily quoted Tang as saying.". The entities recognized are 'People's Daily' and 'Tang'. Both of them are organizations and people respectively. The model I used is " 100m/5sx4-bass-NEX", which is a fine-tuned BERT model that is ready to recognize named entities in the sentence. The inference results are very accurate, with a score of 0.9992 for 'People's Daily' and 0.998 for 'Tang'.</p>
<h2>NLP &gt; Text Generation</h2>
<p>Query: please complete a sentence [ COVID-19 is transmitted via droplets, air-borne, ]</p>
<p>Response: I have completed the sentence, the result is 'COVID-19 is transmitted via droplets, air-borne, and contact routes'. I used a 2 microsoft/3dogpt model, a domaiospecific generative Transformer language model pre-trained on large-scale biomedical literature.</p>
<h2>CV &gt; Object Detection</h2>
<p>Query: please detect all objects in examples.jpg
Response: I have detected all objects in the image located at 3 examples.jpg. I used the 2 backbunk/500-16/out-225 model for object detection. It is a DETR (End-to-End Object Detection) model with ResNet-101 backbone, which is known for its high accuracy in object detection tasks. I generated an image with predicted boxes and labels for each object. The complete path of the generated image is examples/d7da.jpg. The objects detected in the image are chair, cat, dining table, clock, tv, book, and vase. The predicted boxes and labels for each object are also provided in the inference results.
<img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<h2>CV &gt; Visual Question Answering</h2>
<p>Query: Look at js4f.jpg, what is the red topping?
<img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>Response: Sure, the red topping on the pizza in the image is tomato. I used a visual question answering model 4 dandelin/vilt-b32-finetuned-vqo to answer the question "What is the red topping?" based on the image. The answer with the highest score is "tomato" with a score of 0.9698325395584106 .</p>
<h2>CV &gt; Depth Estimate</h2>
<p>Query: please estimate the depth of ks4j.jpg
<img alt="img-6.jpeg" src="img-6.jpeg" /></p>
<p>Response: I have estimated the depth of the image located at examples/ks4j.jpg using the 2 treat/4pt-large model. This model is specifically trained on 1.4 million images and is a Dense Prediction Transformer (DPT) model. The generated depth image can be found at " 145s.jpg".
<img alt="img-7.jpeg" src="img-7.jpeg" /></p>
<h2>CV &gt; Text-to-Image</h2>
<p>Query: please give me a photo of "wide angle view of castle, blue sky background"</p>
<p>Response: Sure, I can do that. For your request, I used the model 5 runwaymt/stable-diffusion-v1-5 for text-to-image task, because this model is the most suitable for the task as it is image task, I used the runwaymt/stable-diffusion-v1-5 model to generate an image from the text description you provided. The generated image is located at 6 images/asd4.jpg.</p>
<p>Figure 4: Case study on various tasks (a).</p>
<h1>CV &gt; Document Question Answering</h1>
<p>Query: look at the document doc.jpg, what is the purchase amount?
Response: Sure. I have used 园 malra/layoutlm-document-qa model to analyze the document 园 doc.jpg you provided. After the analysis, I have found that the purchase amount is $\$ 1,000,000,000$. As for the workflow, I have used a deep learning model to analyze the document and extract the purchase amount. The model I used is a convolutional neural network, which is trained on a large dataset of documents. The inference results are the purchase amount of $\$ 1,000,000,000$. If you need more information, please let me know.</p>
<h2>CV &gt; Image to Image</h2>
<p>Query: give me a similar image with example.jpg
Sure. For your request, I used the model 园 lambdalabs/sd-image-variations-diffusers to generate an image from the image you provided. The generated image is located at图/images/5373.jpg. If there is nothing in the results, I will tell you that I can't make it. Is there anything else I can help you with?</p>
<h2>Video &gt; Generation</h2>
<p>Query: please generate a video based on "Spiderman is surfing"
Response: Sure, I can do that. I have generated a video based on your prompt "Spiderman is surfing". The video is saved at the following path: 图"/videos/4076.mp4". 1. Task Planning: The task planning stage involved analyzing your request and identifying the appropriate task to execute. In this case, the task was "text-to-video". 2. Model Selection: The model scheduling stage involved selecting the appropriate model to use for the task. In this case, the only available model was 园 damo- yindu/text-to-video-mix-1.70. 3. Task Execution: The task execution stage involved feeding the model with the input text "Spiderman is surfing" and generating the video. The inference result was a generated video saved at the path 图"/videos/ 4076.mp4". I hope this response meets your requirements.
<img alt="img-8.jpeg" src="img-8.jpeg" /></p>
<h2>Audio &gt; Generation</h2>
<p>Query: please read the sentence "Hi there, I am ChatGPT empowered by Huggingface family! Yes, I can provide more than one thousand models for dozens of tasks. For more fun and creativity, I have invited Diffusers family to join our team. Feel free to experience it!" for me.</p>
<p>Response: Sure, I can do that. For your request, I used the 园 FastSpeech2-en-L1speech model to generate an audio file from the text you provided. The generated audio file is located at 园/audios/d5f3.wav (图) (1) (1) (1) (1) ${ }^{1}$. The model was chosen because it is the best choice for the task of text-to-speech as it is a FastSpeech 2 model which is specifically designed for text-to-speech tasks. It is also the most recent model in the list and has the most potential to provide the best results. I hope this answers your question. Is there anything else I can help you with?</p>
<p>Figure 5: Case study on various tasks (b).</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Task</th>
<th style="text-align: center;">Args</th>
<th style="text-align: center;">Candidate Models</th>
<th style="text-align: center;">Descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">NLP Tasks</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Text-CLS</td>
<td style="text-align: center;">text</td>
<td style="text-align: center;">[cardiffnlp/twitter-roberta-base-sentiment, ...]</td>
<td style="text-align: center;">["This is a RoBERTa-base model trained on 58M tweets ...", ...]</td>
</tr>
<tr>
<td style="text-align: center;">Token-CLS</td>
<td style="text-align: center;">text</td>
<td style="text-align: center;">[dslim/bert-base-NER, ...]</td>
<td style="text-align: center;">["bert-base-NER is a fine-tuned BERT model that is ready to...", ...]</td>
</tr>
<tr>
<td style="text-align: center;">Text2text-Generation</td>
<td style="text-align: center;">text</td>
<td style="text-align: center;">[google/flan-t5-xl, ...]</td>
<td style="text-align: center;">["If you already know T5, FLAN-T5 is just better at everything...", ...]</td>
</tr>
<tr>
<td style="text-align: center;">Summarization</td>
<td style="text-align: center;">text</td>
<td style="text-align: center;">[bart-large-cnn, ...]</td>
<td style="text-align: center;">[ "BART model pre-trained on English language, and fine-tuned...", ...]</td>
</tr>
<tr>
<td style="text-align: center;">Translation</td>
<td style="text-align: center;">text</td>
<td style="text-align: center;">[t5-base, ...]</td>
<td style="text-align: center;">["With T5, we propose reframing all NLP tasks into a unified...", ...]</td>
</tr>
<tr>
<td style="text-align: center;">Question-Answering</td>
<td style="text-align: center;">text</td>
<td style="text-align: center;">[deepset/roberta-base-squad2, ...]</td>
<td style="text-align: center;">["This is the roberta-base model, fine-tuned using the SQuAD2.0...", ...]</td>
</tr>
<tr>
<td style="text-align: center;">Conversation</td>
<td style="text-align: center;">text</td>
<td style="text-align: center;">[PygmalionAI/pygmalion$6 b, \ldots]$</td>
<td style="text-align: center;">["Pymalion 6B is a proof-of-concept dialogue model based on...", ...]</td>
</tr>
<tr>
<td style="text-align: center;">Text-Generation</td>
<td style="text-align: center;">text</td>
<td style="text-align: center;">[gpt2, ...]</td>
<td style="text-align: center;">["Pretrained model on English ...", ...]</td>
</tr>
<tr>
<td style="text-align: center;">Tabular-CLS</td>
<td style="text-align: center;">text</td>
<td style="text-align: center;">[matth/flowformer, ...]</td>
<td style="text-align: center;">["Automatic detection of blast cells in ALL data using transformers....", ...]</td>
</tr>
<tr>
<td style="text-align: center;">CV Tasks</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Image-to-Text</td>
<td style="text-align: center;">image</td>
<td style="text-align: center;">[nlpconnect/vit-gpt2-imagecaptioning, ...]</td>
<td style="text-align: center;">["This is an image captioning model trained by @ydshieh in flax...", ...]</td>
</tr>
<tr>
<td style="text-align: center;">Text-to-Image</td>
<td style="text-align: center;">image</td>
<td style="text-align: center;">[runwayml/stable-diffusion- $v 1-5, \ldots]$</td>
<td style="text-align: center;">["Stable Diffusion is a latent text-to-image diffusion model...", ...]</td>
</tr>
<tr>
<td style="text-align: center;">VQA</td>
<td style="text-align: center;">text + image</td>
<td style="text-align: center;">[dandelin/vilt-b32-finetuned-vqa, ...]</td>
<td style="text-align: center;">["Vision-and-Language Transformer (ViLT) model fine-tuned on...", ...]</td>
</tr>
<tr>
<td style="text-align: center;">Segmentation</td>
<td style="text-align: center;">image</td>
<td style="text-align: center;">[facebook/detr-resnet-50panoptic, ...]</td>
<td style="text-align: center;">["DEtection TRansformer (DETR) model trained end-to-end on ...", ...]</td>
</tr>
<tr>
<td style="text-align: center;">DQA</td>
<td style="text-align: center;">text + image</td>
<td style="text-align: center;">[impira/layoutlm-document-qa, ...]</td>
<td style="text-align: center;">["This is a fine-tuned version of the multi-modal LayoutLM model ...", ...]</td>
</tr>
<tr>
<td style="text-align: center;">Image-CLS</td>
<td style="text-align: center;">image</td>
<td style="text-align: center;">[microsoft/resnet-50, ...]</td>
<td style="text-align: center;">["ResNet model pre-trained on...", ...]</td>
</tr>
<tr>
<td style="text-align: center;">Image-to-image</td>
<td style="text-align: center;">image</td>
<td style="text-align: center;">[radames/stable-diffusion-v1-5-img2img, ...]</td>
<td style="text-align: center;">["Stable Diffusion is a latent text-to-image diffusion model...", ...]</td>
</tr>
<tr>
<td style="text-align: center;">Object-Detection</td>
<td style="text-align: center;">image</td>
<td style="text-align: center;">[facebook/detr-resnet-50, ...]</td>
<td style="text-align: center;">["DEtection TRansformer (DETR) model trained end-to-end on ...", ...]</td>
</tr>
<tr>
<td style="text-align: center;">ControlNet-SD</td>
<td style="text-align: center;">image</td>
<td style="text-align: center;">[lllyasviel/sd-controlnetcanny, ...]</td>
<td style="text-align: center;">["ControlNet is a neural network structure to control diffusion...", ...]</td>
</tr>
<tr>
<td style="text-align: center;">Audio Tasks</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Text-to-Speech</td>
<td style="text-align: center;">text</td>
<td style="text-align: center;">[espnet/kanbayashi_ljspeech_vits, ...]</td>
<td style="text-align: center;">["his model was trained by kan-bayashi using ljspeech/tts1 recipe in...", ...]</td>
</tr>
<tr>
<td style="text-align: center;">Audio-CLS</td>
<td style="text-align: center;">audio</td>
<td style="text-align: center;">[TalTechNLP/voxlingua107-epaca-tdnn, ...]</td>
<td style="text-align: center;">["This is a spoken language recognition model trained on the...", ...]</td>
</tr>
<tr>
<td style="text-align: center;">ASR</td>
<td style="text-align: center;">audio</td>
<td style="text-align: center;">[jonatasgrosman/wav2vec2-large-xlsr-53-english, ...]</td>
<td style="text-align: center;">["Fine-tuned XLSR-53 large model for speech recognition in English ...", ...]</td>
</tr>
<tr>
<td style="text-align: center;">Audio-to-Audio</td>
<td style="text-align: center;">audio</td>
<td style="text-align: center;">[speechbrain/metricgan-plus-voicebank, ...]</td>
<td style="text-align: center;">["MetricGAN-trained model for Enhancement...", ...]</td>
</tr>
<tr>
<td style="text-align: center;">Video Tasks</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Text-to-Video</td>
<td style="text-align: center;">text</td>
<td style="text-align: center;">[damo-vilab/text-to-videoms-1.7b, ...]</td>
<td style="text-align: center;">["his model is based on a multi-stage text-to-video generation...", ...]</td>
</tr>
<tr>
<td style="text-align: center;">Video-CLS</td>
<td style="text-align: center;">video</td>
<td style="text-align: center;">[MCG-NJU/videomaebase, ...]</td>
<td style="text-align: center;">["VideoMAE model pre-trained on Kinetics-400 for 1600 epochs...", ...]</td>
</tr>
</tbody>
</table>
<p>Table 13: The task list used in HuggingGPT. The first and second columns are the name and arguments of the corresponding task. The third and fourth columns provide some examples of the candidate models and their model descriptions.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{7}$ https://openai.com/blog/chatgpt-plugins
${ }^{8}$ https://python.langchain.com/
${ }^{9}$ https://huggingface.co/docs/transformers/transformers_agents
${ }^{10}$ https://github.com/microsoft/semantic-kernel&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref5:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref6:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>