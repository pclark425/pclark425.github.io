<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-1436 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-1436</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-1436</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-26.html">extraction-schema-26</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of automated systems making scientific discoveries, including how these discoveries are characterized as incremental or transformational, and how they are evaluated and validated.</div>
                <p><strong>Paper ID:</strong> paper-36870c32e83aeddb8233c4c9b0a82740b492e8b3</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/36870c32e83aeddb8233c4c9b0a82740b492e8b3" target="_blank">AI Feynman 2.0: Pareto-optimal symbolic regression exploiting graph modularity</a></p>
                <p><strong>Paper Venue:</strong> Neural Information Processing Systems</p>
                <p><strong>Paper TL;DR:</strong> An improved method for symbolic regression that seeks to fit data to formulas that are Pareto-optimal, in the sense of having the best accuracy for a given complexity is presented.</p>
                <p><strong>Paper Abstract:</strong> We present an improved method for symbolic regression that seeks to fit data to formulas that are Pareto-optimal, in the sense of having the best accuracy for a given complexity. It improves on the previous state-of-the-art by typically being orders of magnitude more robust toward noise and bad data, and also by discovering many formulas that stumped previous methods. We develop a method for discovering generalized symmetries (arbitrary modularity in the computational graph of a formula) from gradient properties of a neural network fit. We use normalizing flows to generalize our symbolic regression method to probability distributions from which we only have samples, and employ statistical hypothesis testing to accelerate robust brute-force search.</p>
                <p><strong>Cost:</strong> 0.016</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e1436.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e1436.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of automated systems making scientific discoveries, including how these discoveries are characterized as incremental or transformational, and how they are evaluated and validated.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>AI Feynman 2.0</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>AI Feynman 2.0: Pareto-optimal symbolic regression exploiting graph modularity</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An improved automated symbolic-regression system that discovers simple symbolic formulas (including probability distributions) from data by combining neural-network fitting, gradient-based graph-modularity discovery, Pareto-front pruning (complexity vs. inaccuracy), hypothesis-testing accelerated brute-force search, and normalizing flows for density estimation.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>AI Feynman 2.0 (the method presented in this paper)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>A pipeline that (1) trains a neural network to approximate the unknown function, (2) inspects gradients to discover computational-graph modularity (compositionality, generalized symmetry, separability, generalized additivity, etc.), (3) recursively reduces the symbolic regression problem to smaller subproblems, (4) performs brute-force and polynomial searches with Pareto-front pruning in accuracy (MEDL) vs complexity (description length L_d), (5) accelerates brute-force pruning using sequential statistical hypothesis tests on batches of datapoints, and (6) uses normalizing flows to enable symbolic regression of probability densities from samples. Architecturally it uses feed-forward tanh MLPs for function approximation and RQ-NSF flows for density estimation; it applies numeric snaps (zero/integer/rational) and gradient-based reoptimization of parameters.</td>
                        </tr>
                        <tr>
                            <td><strong>discovery_domain</strong></td>
                            <td>Symbolic regression applied to physics and probability-density estimation (physics-inspired formula discovery; more generally mathematical/physical law discovery from data)</td>
                        </tr>
                        <tr>
                            <td><strong>discovery_description</strong></td>
                            <td>Discovers closed-form symbolic expressions approximating or exactly matching target functions from datasets (including physics equations from the Feynman database and analytic forms of probability distributions from samples). Examples: recovered many Feynman-database formulas (including ones that previous automated methods failed on), discovered Pareto-frontiers of formulas (e.g., relativistic kinetic energy and its low-order approximations), solved previously unsolved benchmark equations, and recovered analytic forms for several probability distributions using normalizing flows followed by symbolic regression.</td>
                        </tr>
                        <tr>
                            <td><strong>discovery_type</strong></td>
                            <td>exact and approximate (Pareto-optimal) formulas</td>
                        </tr>
                        <tr>
                            <td><strong>discovery_type_justification</strong></td>
                            <td>The paper frames discoveries as either exact symbolic formulas or approximate Pareto-optimal formulas; it emphasizes Pareto-optimality in the plane of description-length complexity (L_d) versus MEDL error as the selection criterion, arguing that both exact solutions and useful approximations are valuable. The paper does not use the terms 'incremental' or 'transformational' to categorize discoveries.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_methods</strong></td>
                            <td>Quantitative evaluation uses: (a) MEDL (mean error-description-length) across datapoints as the primary accuracy metric, (b) L_d (description length in bits) as the complexity measure, (c) Pareto-frontier pruning in the MEDL vs L_d plane, (d) sequential hypothesis-testing (z-score) to quickly reject poor brute-force candidates, (e) held-out 10% of data to rank Pareto candidates for success counting, (f) surprisal loss (-sum log p) for density-estimation ranking after normalization, and (g) noise-robustness experiments where Gaussian noise of varying standard deviation 10^r is added and the maximal r allowing correct recovery is recorded. The paper reports benchmark percentages (e.g., Table 6) and sample-size requirements for density recovery (Table 5).</td>
                        </tr>
                        <tr>
                            <td><strong>validation_approaches</strong></td>
                            <td>Validation performed by: (1) comparing discovered formulas against known ground-truth functions from the Feynman Symbolic Regression Database and problem-specific analytic distributions (exact-match check or parameter recovery to within 0.01% for irrational parameters), (2) held-out test-set ranking (10%) to ensure generalization, (3) checking normalization/non-negativity and computing surprisal loss for density estimates, (4) comparison to prior automated methods (e.g., Udrescu & Tegmark 2020 and Schmidt & Lipson 2009) and reporting improved noise robustness and additional solved cases, (5) reporting sample-size requirements for density problems, and (6) ablation/failure-mode analyses (identifying when modularity discovery or basis-function choices prevented solution). No wet-lab or physical experimental revalidation is performed because targets are synthetic/benchmark analytic formulas.</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_assessment</strong></td>
                            <td>Novelty is assessed by (a) solving benchmark problems that prior state-of-the-art methods failed on (the authors reran the 17 mysteries that [25] failed and report solving them), (b) demonstrating substantially improved noise robustness (often 1–3 orders of magnitude better than the prior AI Feynman implementation in [25] for many benchmarks), (c) extending symbolic regression to density estimation via normalizing flows, and (d) enabling discovery of more general graph modularities via gradient inspection beyond previously exploited symmetries and separabilities. The paper uses these empirical improvements on benchmark suites as evidence of novelty.</td>
                        </tr>
                        <tr>
                            <td><strong>impact_metrics</strong></td>
                            <td>Reported empirical metrics include: (a) benchmark success rates (Table 6) — FDSR basic 100: 100% solved; FDSR harder 20: 90% solved (versus 85% in [25]); 12 modular equations: 100% solved; 10 probability distributions: 80% solved; (b) per-equation noise-tolerance improvements summarized in Tables 3 and 7–8 (e.g., many equations improved allowable Gaussian noise amplitude by orders of magnitude); (c) counts such as '73 of 100 baseline problems solved with r = -1' in one reported experiment; (d) sample-size requirements for density estimation (10^2 to 10^5 samples depending on distribution in Table 5); (e) computational resources/time remarks (normalizing flows trained ~20 minutes on one CPU for moderate sample sizes).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_human_discoveries</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_details</strong></td>
                            <td>The paper compares the system quantitatively to previous automated symbolic-regression methods (not to human discoveries): it compares to the authors' prior AI Feynman [25] and to Schmidt & Lipson [10], reporting higher success rates, higher noise robustness (often 1–3 orders of magnitude better than [25]), and that it solved problems [25] failed. Exact numeric comparisons include the benchmark percentages in Table 6 and noise-tolerance shifts per equation in Tables 7–8. The paper does not present a direct comparison versus human scientists discovering new laws in the wild.</td>
                        </tr>
                        <tr>
                            <td><strong>success_rate</strong></td>
                            <td>Empirical success rates on benchmarks: 100% on the 'FDSR basic 100' benchmark (as reported in Table 6), 90% on the 'FDSR harder 20' set, 100% on 12 modular equations tested, and 80% on 10 probability-distribution estimation tasks. Additionally, in noise-robustness tests the method solved 73 of 100 baseline problems at noise level r = -1 (Gaussian noise amplitude 10^{-1}). The paper also reports solving all 17 problems that [25] had failed within a two-hour-per-problem runtime constraint.</td>
                        </tr>
                        <tr>
                            <td><strong>challenges_limitations</strong></td>
                            <td>Identified limitations include: (1) dependence on chosen basis functions — if a needed primitive (e.g., tanh) is not in the basis, brute-force may fail or take impractically long; (2) failures when modularity does not reduce problem size sufficiently (e.g., single-variable modules too complex for brute-force search in allotted time); (3) sensitivity to normalizing-flow estimation imprecision (can prefer simpler but semantically different formulas, e.g., cos(cos θ) vs cos^2 θ); (4) pragmatic runtime limits for brute-force search per iteration (authors limit brute force per iteration), (5) the description-length complexity definition sometimes prefers less interpretable forms; (6) no claim of discovering genuinely paradigm-shifting scientific results beyond benchmarks — analyses are on synthetic/benchmark problems; (7) validation limited to comparisons with known analytic ground truth and held-out test data rather than independent experimental confirmation.</td>
                        </tr>
                        <tr>
                            <td><strong>has_incremental_transformational_comparison</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'AI Feynman 2.0: Pareto-optimal symbolic regression exploiting graph modularity', 'publication_date_yy_mm': '2020-06'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1436.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e1436.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of automated systems making scientific discoveries, including how these discoveries are characterized as incremental or transformational, and how they are evaluated and validated.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>AI Feynman (original)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>AI Feynman: A physics-inspired method for symbolic regression (Udrescu & Tegmark 2020)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>The prior version of AI Feynman that used neural-network fitting combined with detection of two types of modularity (symmetry and separability) and brute-force/polynomial search to discover symbolic formulas from physics datasets; used as a baseline and conceptual predecessor in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>AI Feynman: A physics-inspired method for symbolic regression</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>AI Feynman (Udrescu & Tegmark 2020, prior version)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>An earlier symbolic-regression pipeline that trains neural networks to approximate unknown functions and exploits two types of graph modularity (symmetry and separability) plus brute-force search and polynomial fitting to find symbolic formulas; it inspired the present method but is described as less robust to noise and less general in modularity detection.</td>
                        </tr>
                        <tr>
                            <td><strong>discovery_domain</strong></td>
                            <td>Symbolic regression for physics equations</td>
                        </tr>
                        <tr>
                            <td><strong>discovery_description</strong></td>
                            <td>Automated discovery of symbolic physics formulas from benchmark datasets (the Feynman database); used to recover many physics formulas and served as a state-of-the-art baseline that the current paper improves upon.</td>
                        </tr>
                        <tr>
                            <td><strong>discovery_type</strong></td>
                            <td>automatic discovery of symbolic physics formulas</td>
                        </tr>
                        <tr>
                            <td><strong>discovery_type_justification</strong></td>
                            <td>Described as an automated method that finds symbolic expressions; the present paper contrasts its limited modularity detection and ad hoc thresholds with the more general, Pareto-optimal approach introduced here.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_methods</strong></td>
                            <td>Mentioned in this paper primarily via comparative benchmark metrics (success rates and noise robustness reported in tables), but detailed evaluation methodology for the original system is not reproduced here.</td>
                        </tr>
                        <tr>
                            <td><strong>validation_approaches</strong></td>
                            <td>In this paper, the original AI Feynman is validated only by comparison of reported benchmark results; the present work re-evaluates common benchmarks and reports improvements over those results.</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_assessment</strong></td>
                            <td>Presented here as prior art that discovered many formulas and introduced modularity-exploiting symbolic regression ideas; novelty assessment in this paper is via improved noise robustness and expanded modularity discovery compared to that prior work.</td>
                        </tr>
                        <tr>
                            <td><strong>impact_metrics</strong></td>
                            <td>Referenced indirectly via benchmark comparison numbers (e.g., this paper reports its own higher success rates versus the previously reported results for [25]).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_human_discoveries</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>comparison_details</strong></td>
                            <td>This paper compares its performance quantitatively to the prior AI Feynman (e.g., improved noise robustness by 1–3 orders of magnitude on many benchmarks and solving previously unsolved problems), but does not compare either system to human-made discoveries in the wild.</td>
                        </tr>
                        <tr>
                            <td><strong>success_rate</strong></td>
                            <td>Not directly reported in this paper beyond comparative statements; prior AI Feynman success rates are used as baselines (e.g., [25] had 85% on 'FDSR harder 20' in Table 6 whereas this paper reports 90%).</td>
                        </tr>
                        <tr>
                            <td><strong>challenges_limitations</strong></td>
                            <td>As described in this paper, limitations of the original AI Feynman include: ad hoc modularity handling (only symmetry & separability), reliance on hyperparameter thresholds for candidate acceptance, less robustness to noise and outliers, and less general modularity discovery.</td>
                        </tr>
                        <tr>
                            <td><strong>has_incremental_transformational_comparison</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'AI Feynman 2.0: Pareto-optimal symbolic regression exploiting graph modularity', 'publication_date_yy_mm': '2020-06'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1436.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e1436.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of automated systems making scientific discoveries, including how these discoveries are characterized as incremental or transformational, and how they are evaluated and validated.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Eureqa / Schmidt & Lipson</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Distilling free-form natural laws from experimental data (Schmidt & Lipson 2009)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An influential earlier automated symbolic-regression approach (genetic-programming/Eureqa family) that attempted to extract physical laws from time-series/experimental data; cited here as prior work in automated discovery of formulas.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Distilling free-form natural laws from experimental data</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Eureqa / Schmidt & Lipson (2009)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>An evolutionary/genetic-programming based symbolic-regression system that searches over functional forms to distill candidate natural laws from data; referenced as part of the historical literature on automated discovery systems but not used experimentally in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>discovery_domain</strong></td>
                            <td>Automated discovery of natural laws / symbolic regression (physics and dynamical systems)</td>
                        </tr>
                        <tr>
                            <td><strong>discovery_description</strong></td>
                            <td>Known for producing candidate symbolic laws from experimental data via genetic programming; here it is cited as prior art in the automated-discovery literature.</td>
                        </tr>
                        <tr>
                            <td><strong>discovery_type</strong></td>
                            <td>automated distillation of natural laws</td>
                        </tr>
                        <tr>
                            <td><strong>discovery_type_justification</strong></td>
                            <td>Referenced historically; the present paper positions later methods (including AI Feynman variants) as building upon and often outperforming earlier genetic-programming approaches.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_methods</strong></td>
                            <td>Not detailed in this paper; cited as part of related work. The present paper uses benchmark comparisons to literature including this work but does not reimplement or re-evaluate it directly.</td>
                        </tr>
                        <tr>
                            <td><strong>validation_approaches</strong></td>
                            <td>Mentioned only in related-work context; no new validation of Eureqa/Schmidt & Lipson is performed in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_assessment</strong></td>
                            <td>Included in the literature review as an early influential automated-discovery system; novelty is not assessed here beyond being prior art.</td>
                        </tr>
                        <tr>
                            <td><strong>impact_metrics</strong></td>
                            <td>No numerical impact metrics for this system are provided in this paper beyond being cited as a predecessor.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_human_discoveries</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>comparison_details</strong></td>
                            <td>This paper references the Schmidt & Lipson work among earlier automated-discovery efforts but does not provide direct numerical comparisons beyond positioning later methods as improvements in robustness and capability.</td>
                        </tr>
                        <tr>
                            <td><strong>success_rate</strong></td>
                            <td>Not reported in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>challenges_limitations</strong></td>
                            <td>Not discussed in detail here; the paper implies later methods addressed some limitations of earlier approaches such as robustness to noise and exploitation of modularity.</td>
                        </tr>
                        <tr>
                            <td><strong>has_incremental_transformational_comparison</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'AI Feynman 2.0: Pareto-optimal symbolic regression exploiting graph modularity', 'publication_date_yy_mm': '2020-06'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>AI Feynman: A physics-inspired method for symbolic regression <em>(Rating: 2)</em></li>
                <li>Distilling free-form natural laws from experimental data <em>(Rating: 2)</em></li>
                <li>Toward an artificial intelligence physicist for unsupervised learning <em>(Rating: 1)</em></li>
                <li>Discovering governing equations from data by sparse identification of nonlinear dynamical systems <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-1436",
    "paper_id": "paper-36870c32e83aeddb8233c4c9b0a82740b492e8b3",
    "extraction_schema_id": "extraction-schema-26",
    "extracted_data": [
        {
            "name_short": "AI Feynman 2.0",
            "name_full": "AI Feynman 2.0: Pareto-optimal symbolic regression exploiting graph modularity",
            "brief_description": "An improved automated symbolic-regression system that discovers simple symbolic formulas (including probability distributions) from data by combining neural-network fitting, gradient-based graph-modularity discovery, Pareto-front pruning (complexity vs. inaccuracy), hypothesis-testing accelerated brute-force search, and normalizing flows for density estimation.",
            "citation_title": "here",
            "mention_or_use": "use",
            "system_name": "AI Feynman 2.0 (the method presented in this paper)",
            "system_description": "A pipeline that (1) trains a neural network to approximate the unknown function, (2) inspects gradients to discover computational-graph modularity (compositionality, generalized symmetry, separability, generalized additivity, etc.), (3) recursively reduces the symbolic regression problem to smaller subproblems, (4) performs brute-force and polynomial searches with Pareto-front pruning in accuracy (MEDL) vs complexity (description length L_d), (5) accelerates brute-force pruning using sequential statistical hypothesis tests on batches of datapoints, and (6) uses normalizing flows to enable symbolic regression of probability densities from samples. Architecturally it uses feed-forward tanh MLPs for function approximation and RQ-NSF flows for density estimation; it applies numeric snaps (zero/integer/rational) and gradient-based reoptimization of parameters.",
            "discovery_domain": "Symbolic regression applied to physics and probability-density estimation (physics-inspired formula discovery; more generally mathematical/physical law discovery from data)",
            "discovery_description": "Discovers closed-form symbolic expressions approximating or exactly matching target functions from datasets (including physics equations from the Feynman database and analytic forms of probability distributions from samples). Examples: recovered many Feynman-database formulas (including ones that previous automated methods failed on), discovered Pareto-frontiers of formulas (e.g., relativistic kinetic energy and its low-order approximations), solved previously unsolved benchmark equations, and recovered analytic forms for several probability distributions using normalizing flows followed by symbolic regression.",
            "discovery_type": "exact and approximate (Pareto-optimal) formulas",
            "discovery_type_justification": "The paper frames discoveries as either exact symbolic formulas or approximate Pareto-optimal formulas; it emphasizes Pareto-optimality in the plane of description-length complexity (L_d) versus MEDL error as the selection criterion, arguing that both exact solutions and useful approximations are valuable. The paper does not use the terms 'incremental' or 'transformational' to categorize discoveries.",
            "evaluation_methods": "Quantitative evaluation uses: (a) MEDL (mean error-description-length) across datapoints as the primary accuracy metric, (b) L_d (description length in bits) as the complexity measure, (c) Pareto-frontier pruning in the MEDL vs L_d plane, (d) sequential hypothesis-testing (z-score) to quickly reject poor brute-force candidates, (e) held-out 10% of data to rank Pareto candidates for success counting, (f) surprisal loss (-sum log p) for density-estimation ranking after normalization, and (g) noise-robustness experiments where Gaussian noise of varying standard deviation 10^r is added and the maximal r allowing correct recovery is recorded. The paper reports benchmark percentages (e.g., Table 6) and sample-size requirements for density recovery (Table 5).",
            "validation_approaches": "Validation performed by: (1) comparing discovered formulas against known ground-truth functions from the Feynman Symbolic Regression Database and problem-specific analytic distributions (exact-match check or parameter recovery to within 0.01% for irrational parameters), (2) held-out test-set ranking (10%) to ensure generalization, (3) checking normalization/non-negativity and computing surprisal loss for density estimates, (4) comparison to prior automated methods (e.g., Udrescu & Tegmark 2020 and Schmidt & Lipson 2009) and reporting improved noise robustness and additional solved cases, (5) reporting sample-size requirements for density problems, and (6) ablation/failure-mode analyses (identifying when modularity discovery or basis-function choices prevented solution). No wet-lab or physical experimental revalidation is performed because targets are synthetic/benchmark analytic formulas.",
            "novelty_assessment": "Novelty is assessed by (a) solving benchmark problems that prior state-of-the-art methods failed on (the authors reran the 17 mysteries that [25] failed and report solving them), (b) demonstrating substantially improved noise robustness (often 1–3 orders of magnitude better than the prior AI Feynman implementation in [25] for many benchmarks), (c) extending symbolic regression to density estimation via normalizing flows, and (d) enabling discovery of more general graph modularities via gradient inspection beyond previously exploited symmetries and separabilities. The paper uses these empirical improvements on benchmark suites as evidence of novelty.",
            "impact_metrics": "Reported empirical metrics include: (a) benchmark success rates (Table 6) — FDSR basic 100: 100% solved; FDSR harder 20: 90% solved (versus 85% in [25]); 12 modular equations: 100% solved; 10 probability distributions: 80% solved; (b) per-equation noise-tolerance improvements summarized in Tables 3 and 7–8 (e.g., many equations improved allowable Gaussian noise amplitude by orders of magnitude); (c) counts such as '73 of 100 baseline problems solved with r = -1' in one reported experiment; (d) sample-size requirements for density estimation (10^2 to 10^5 samples depending on distribution in Table 5); (e) computational resources/time remarks (normalizing flows trained ~20 minutes on one CPU for moderate sample sizes).",
            "comparison_to_human_discoveries": false,
            "comparison_details": "The paper compares the system quantitatively to previous automated symbolic-regression methods (not to human discoveries): it compares to the authors' prior AI Feynman [25] and to Schmidt & Lipson [10], reporting higher success rates, higher noise robustness (often 1–3 orders of magnitude better than [25]), and that it solved problems [25] failed. Exact numeric comparisons include the benchmark percentages in Table 6 and noise-tolerance shifts per equation in Tables 7–8. The paper does not present a direct comparison versus human scientists discovering new laws in the wild.",
            "success_rate": "Empirical success rates on benchmarks: 100% on the 'FDSR basic 100' benchmark (as reported in Table 6), 90% on the 'FDSR harder 20' set, 100% on 12 modular equations tested, and 80% on 10 probability-distribution estimation tasks. Additionally, in noise-robustness tests the method solved 73 of 100 baseline problems at noise level r = -1 (Gaussian noise amplitude 10^{-1}). The paper also reports solving all 17 problems that [25] had failed within a two-hour-per-problem runtime constraint.",
            "challenges_limitations": "Identified limitations include: (1) dependence on chosen basis functions — if a needed primitive (e.g., tanh) is not in the basis, brute-force may fail or take impractically long; (2) failures when modularity does not reduce problem size sufficiently (e.g., single-variable modules too complex for brute-force search in allotted time); (3) sensitivity to normalizing-flow estimation imprecision (can prefer simpler but semantically different formulas, e.g., cos(cos θ) vs cos^2 θ); (4) pragmatic runtime limits for brute-force search per iteration (authors limit brute force per iteration), (5) the description-length complexity definition sometimes prefers less interpretable forms; (6) no claim of discovering genuinely paradigm-shifting scientific results beyond benchmarks — analyses are on synthetic/benchmark problems; (7) validation limited to comparisons with known analytic ground truth and held-out test data rather than independent experimental confirmation.",
            "has_incremental_transformational_comparison": false,
            "uuid": "e1436.0",
            "source_info": {
                "paper_title": "AI Feynman 2.0: Pareto-optimal symbolic regression exploiting graph modularity",
                "publication_date_yy_mm": "2020-06"
            }
        },
        {
            "name_short": "AI Feynman (original)",
            "name_full": "AI Feynman: A physics-inspired method for symbolic regression (Udrescu & Tegmark 2020)",
            "brief_description": "The prior version of AI Feynman that used neural-network fitting combined with detection of two types of modularity (symmetry and separability) and brute-force/polynomial search to discover symbolic formulas from physics datasets; used as a baseline and conceptual predecessor in this paper.",
            "citation_title": "AI Feynman: A physics-inspired method for symbolic regression",
            "mention_or_use": "mention",
            "system_name": "AI Feynman (Udrescu & Tegmark 2020, prior version)",
            "system_description": "An earlier symbolic-regression pipeline that trains neural networks to approximate unknown functions and exploits two types of graph modularity (symmetry and separability) plus brute-force search and polynomial fitting to find symbolic formulas; it inspired the present method but is described as less robust to noise and less general in modularity detection.",
            "discovery_domain": "Symbolic regression for physics equations",
            "discovery_description": "Automated discovery of symbolic physics formulas from benchmark datasets (the Feynman database); used to recover many physics formulas and served as a state-of-the-art baseline that the current paper improves upon.",
            "discovery_type": "automatic discovery of symbolic physics formulas",
            "discovery_type_justification": "Described as an automated method that finds symbolic expressions; the present paper contrasts its limited modularity detection and ad hoc thresholds with the more general, Pareto-optimal approach introduced here.",
            "evaluation_methods": "Mentioned in this paper primarily via comparative benchmark metrics (success rates and noise robustness reported in tables), but detailed evaluation methodology for the original system is not reproduced here.",
            "validation_approaches": "In this paper, the original AI Feynman is validated only by comparison of reported benchmark results; the present work re-evaluates common benchmarks and reports improvements over those results.",
            "novelty_assessment": "Presented here as prior art that discovered many formulas and introduced modularity-exploiting symbolic regression ideas; novelty assessment in this paper is via improved noise robustness and expanded modularity discovery compared to that prior work.",
            "impact_metrics": "Referenced indirectly via benchmark comparison numbers (e.g., this paper reports its own higher success rates versus the previously reported results for [25]).",
            "comparison_to_human_discoveries": null,
            "comparison_details": "This paper compares its performance quantitatively to the prior AI Feynman (e.g., improved noise robustness by 1–3 orders of magnitude on many benchmarks and solving previously unsolved problems), but does not compare either system to human-made discoveries in the wild.",
            "success_rate": "Not directly reported in this paper beyond comparative statements; prior AI Feynman success rates are used as baselines (e.g., [25] had 85% on 'FDSR harder 20' in Table 6 whereas this paper reports 90%).",
            "challenges_limitations": "As described in this paper, limitations of the original AI Feynman include: ad hoc modularity handling (only symmetry & separability), reliance on hyperparameter thresholds for candidate acceptance, less robustness to noise and outliers, and less general modularity discovery.",
            "has_incremental_transformational_comparison": null,
            "uuid": "e1436.1",
            "source_info": {
                "paper_title": "AI Feynman 2.0: Pareto-optimal symbolic regression exploiting graph modularity",
                "publication_date_yy_mm": "2020-06"
            }
        },
        {
            "name_short": "Eureqa / Schmidt & Lipson",
            "name_full": "Distilling free-form natural laws from experimental data (Schmidt & Lipson 2009)",
            "brief_description": "An influential earlier automated symbolic-regression approach (genetic-programming/Eureqa family) that attempted to extract physical laws from time-series/experimental data; cited here as prior work in automated discovery of formulas.",
            "citation_title": "Distilling free-form natural laws from experimental data",
            "mention_or_use": "mention",
            "system_name": "Eureqa / Schmidt & Lipson (2009)",
            "system_description": "An evolutionary/genetic-programming based symbolic-regression system that searches over functional forms to distill candidate natural laws from data; referenced as part of the historical literature on automated discovery systems but not used experimentally in this paper.",
            "discovery_domain": "Automated discovery of natural laws / symbolic regression (physics and dynamical systems)",
            "discovery_description": "Known for producing candidate symbolic laws from experimental data via genetic programming; here it is cited as prior art in the automated-discovery literature.",
            "discovery_type": "automated distillation of natural laws",
            "discovery_type_justification": "Referenced historically; the present paper positions later methods (including AI Feynman variants) as building upon and often outperforming earlier genetic-programming approaches.",
            "evaluation_methods": "Not detailed in this paper; cited as part of related work. The present paper uses benchmark comparisons to literature including this work but does not reimplement or re-evaluate it directly.",
            "validation_approaches": "Mentioned only in related-work context; no new validation of Eureqa/Schmidt & Lipson is performed in this paper.",
            "novelty_assessment": "Included in the literature review as an early influential automated-discovery system; novelty is not assessed here beyond being prior art.",
            "impact_metrics": "No numerical impact metrics for this system are provided in this paper beyond being cited as a predecessor.",
            "comparison_to_human_discoveries": null,
            "comparison_details": "This paper references the Schmidt & Lipson work among earlier automated-discovery efforts but does not provide direct numerical comparisons beyond positioning later methods as improvements in robustness and capability.",
            "success_rate": "Not reported in this paper.",
            "challenges_limitations": "Not discussed in detail here; the paper implies later methods addressed some limitations of earlier approaches such as robustness to noise and exploitation of modularity.",
            "has_incremental_transformational_comparison": null,
            "uuid": "e1436.2",
            "source_info": {
                "paper_title": "AI Feynman 2.0: Pareto-optimal symbolic regression exploiting graph modularity",
                "publication_date_yy_mm": "2020-06"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "AI Feynman: A physics-inspired method for symbolic regression",
            "rating": 2
        },
        {
            "paper_title": "Distilling free-form natural laws from experimental data",
            "rating": 2
        },
        {
            "paper_title": "Toward an artificial intelligence physicist for unsupervised learning",
            "rating": 1
        },
        {
            "paper_title": "Discovering governing equations from data by sparse identification of nonlinear dynamical systems",
            "rating": 1
        }
    ],
    "cost": 0.015505999999999999,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>AI Feynman 2.0: Pareto-optimal symbolic regression exploiting graph modularity</h1>
<p>Silviu-Marian Udrescu ${ }^{1}$, Andrew Tan ${ }^{1}$, Jiahai Feng ${ }^{1}$, Orisvaldo Neto ${ }^{1}$, Tailin Wu ${ }^{2}$ \&amp; Max Tegmark ${ }^{1,3}$<br>${ }^{1}$ MIT Dept. of Physics and Institute for AI \&amp; Fundamental Interactions, Cambridge, MA, USA<br>${ }^{2}$ Stanford Dept. of Computer Science, Palo Alto, CA, USA<br>${ }^{3}$ Theiss Research, La Jolla, CA, USA<br>${ }^{1}$ {sudrescu, aktan, fjiahai, oris,tegmark}@mit.edu, ${ }^{2}$ tailin@cs.stanford.edu</p>
<h4>Abstract</h4>
<p>We present an improved method for symbolic regression that seeks to fit data to formulas that are Pareto-optimal, in the sense of having the best accuracy for a given complexity. It improves on the previous state-of-the-art by typically being orders of magnitude more robust toward noise and bad data, and also by discovering many formulas that stumped previous methods. We develop a method for discovering generalized symmetries (arbitrary modularity in the computational graph of a formula) from gradient properties of a neural network fit. We use normalizing flows to generalize our symbolic regression method to probability distributions from which we only have samples, and employ statistical hypothesis testing to accelerate robust brute-force search.</p>
<h2>1 Introduction</h2>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Our symbolic regression of data on how kinetic energy depends on mass, velocity and the speed of light discovers a Pareto-frontier of four formulas that are each the most accurate given their complexity. Convex corners reveal particularly useful formulas, in this case Einstein's formula and the classical approximation $m v^{2} / 2$.</p>
<p>A central challenge in science is symbolic regression: discovering a symbolic expression that provides a simple yet accurate fit to a given data set. More specifically, we are given a table of numbers, whose rows are of the form $\left{x_{1}, \ldots, x_{n}, y\right}$ where $y=f\left(x_{1}, \ldots, x_{n}\right)$, and our task is to discover the correct symbolic expression (composing mathematical functions from a user-provided set) for the unknown mystery function $f$, optionally including the complication of noise and outliers. Science</p>
<p>aside, symbolic regression has the potential to replace some inscrutable black-box neural networks by simple yet accurate symbolic approximations, helping with the timely goal of making high-impact AI systems more interpretable and reliable [1-5].</p>
<p>Symbolic regression is difficult because of the exponentially large combinatorial space of symbolic expressions. Traditionally, it has relied on human intuition, leading to the discovery of some of the most famous formulas in science. More recently, there has been great progress toward fully automating the process [6-26], and open-source software now exists that can discover quite complex physics equations by combining neural networks with techniques inspired by physics and information theory [25]. Although [25] achieved state-of-the-art performance using a neural network approximation of the unknown function to discover simplifying function properties, it did so in an unprincipled and ad hoc way that we replace by a general, principled and much more effective method, incorporating four main contributions:</p>
<ol>
<li>We recursively exploit modularity in the function's computational graph. While [25] discovered merely two types of graph modularity (symmetry and separability) involving merely four particular bivariate functions $(+,-, \times$ and $\div)$, our method has the potential to discover any graph modularity involving any functions of $n=2,3, \ldots$ variables, by examining gradients of the neural network fit.</li>
<li>Instead of concluding that a candidate function or graph decomposition is good because the fitting accuracy exceeds arbitrary hyperparameter-determined thresholds, we eliminate these hyperparameters and use a Pareto-frontier (of description-length complexity versus inaccuracy) to prune our search over candidate expressions by discarding all candidates not on the frontier, improving robustness to noise and bad data.</li>
<li>Instead of simply rejecting formula candidates using $L_{\infty}$-norm (rejecting as soon as the error for a single data point crosses a threshold), we reject using statistical hypothesis testing, further improving robustness.</li>
<li>We use normalizing flows to enable symbolic regression of probability distributions from samples.</li>
</ol>
<p>This enables more complex formulas to be discovered and improving noise robustness by 1-3 orders of magnitude. We describe our symbolic regression algorithm (which is publicly available ${ }^{1}$ ) in Section 2 and test it with numerical experiments in Section 3.</p>
<h1>2 Method</h1>
<p>Our symbolic regression algorithm uses a divide-and-conquer approach as in [25]. We directly solve a mystery in two base cases: if the mystery function $f\left(x_{1}, \ldots, x_{n}\right)$ is a low-order polynomial or if it is simple enough to be discovered by brute-force search. Otherwise, we recursively try the strategies that we will now describe for replacing it by one or more simpler mysteries, ideally with fewer input variables.</p>
<h3>2.1 Leveraging graph modularity against the curse of dimensionality</h3>
<p>When we define and evaluate a mathematical function, we typically represent it as composed of some basis set $S$ of simpler functions. As illustrated in Figure 2 (middle panel), this representation can be specified as a graph whose nodes contain elements of $S$. The most popular basis functions in the scientific literature tend to be functions of two variables (such as + or $\times$ ), one variable (such as sin or $\log$ ) or no variables (constants such as 2 or $\pi$ ). For many functions of scientific interest, this graph is modular in the sense that it can be partitioned in terms of functions with fewer input variables, as in Figure 2 (right panel).</p>
<p>A key strategy of our symbolic regression algorithm is to recursively discover such modularity, thereby reverse-engineering the computational graph of a mystery function, starting with no information about it other than an input-output data table. This is useful because there are exponentially many ways to combine $n$ basis functions into a module, making it extremely slow and difficult for brute-force or</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: All functions can be represented as tree graphs whose nodes represent a set of basic functions (middle panel). Using a neural network trained to fit a mystery function (left panel), our algorithm seeks a decomposition of this function into others with fewer input variables (right panel), in this case of the form $f(x, y, z)=g[h(x, y), z]$.
<img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: Examples of graph modularity that our algorithm can auto-discover. Lines denote realvalued variables and ovals denote functions, with larger ones being more complex.
genetic algorithms to discover the correct function when $n$ is large. Our divide-and-conquer approach of first breaking the function into smaller modules with smaller $n$ that can be solved separately thus greatly accelerates the solution. We implement this modularity discovery algorithm in two steps:</p>
<ol>
<li>Use the user-provided data table to train a neural network $f_{\mathrm{NN}}(\mathbf{x})$ that accurately approximates the mystery function $f(\mathbf{x})$.</li>
<li>Perform numerical experiments on $f_{\mathrm{NN}}(\mathbf{x})$ to discover graph modularity.</li>
</ol>
<p>Specifically, we test for the six types of graph modularity illustrated in Figure 3 and listed in Table 1, and choose between the discovered candidates as described in Section 2.2. Our method for discovering separability is described in [25]. As we will see below, all our other types of graph modularity (compositionality, symmetry and generalized additivity) can be revealed by $\nabla f$, the gradient of our mystery function $f$.</p>
<p>Compositionality Let us first consider the case of compositionality (Figure 3, top right), where $f(\mathbf{x})=g(h(\mathbf{x}))$ and $h$ is a scalar function simpler than $f$ in the sense of being expressible with a smaller graph as in Figure 3. By the chain rule, we have</p>
<p>$$
\nabla f(\mathbf{x})=g^{\prime}(h(\mathbf{x})) \nabla h(\mathbf{x}), \quad \text { so } \quad \widehat{\nabla f}= \pm \widehat{\nabla h}
$$</p>
<p>Table 1: Simplification strategies</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Property</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr>
<td>Negativity</td>
<td>$f\left(x_{1}, x_{2}, \ldots\right)&lt;0$</td>
<td>Solve for $g \equiv-f$</td>
</tr>
<tr>
<td>Positivity</td>
<td>$f\left(x_{1}, x_{2}, \ldots\right)&gt;0$</td>
<td>Solve for $g \equiv \ln f$</td>
</tr>
<tr>
<td>Additive</td>
<td>$f\left(x_{1}, \ldots, x_{k}, x_{k+1}, \ldots, x_{n}\right)=$</td>
<td></td>
</tr>
<tr>
<td>separability</td>
<td>$g\left(x_{1}, \ldots, x_{k}\right)+h\left(x_{k+1}, \ldots, x_{n}\right)$</td>
<td>Solve for $g \&amp; h$</td>
</tr>
<tr>
<td>Multiplicative</td>
<td>$f\left(x_{1}, \ldots, x_{k}, x_{k+1}, \ldots, x_{n}\right)=$</td>
<td></td>
</tr>
<tr>
<td>separability</td>
<td>$g\left(x_{1}, \ldots, x_{k}\right) h\left(x_{k+1}, \ldots, x_{n}\right)$</td>
<td>Solve for $g \&amp; h$</td>
</tr>
<tr>
<td>Simple symmetry</td>
<td>$f\left(x_{1}, x_{2}, \ldots\right)=g\left(x_{1} \odot x_{2}, \ldots\right), \quad \odot \in{+,-, \times, /}$</td>
<td>Solve for $g$</td>
</tr>
<tr>
<td>Compositionality</td>
<td>$f\left(x_{1}, \ldots, x_{n}\right)=g\left(h\left(x_{1}, \ldots, x_{n}\right)\right), \quad h$ simpler than $f$</td>
<td>Find $h$ with $\nabla h \propto \nabla f$</td>
</tr>
<tr>
<td>Generalized</td>
<td>$f\left(x_{1}, \ldots, x_{k}, x_{k+1}, \ldots, x_{n}\right)=$</td>
<td>Find $h$ satisfying</td>
</tr>
<tr>
<td>symmetry</td>
<td>$g\left[h\left(x_{1}, \ldots, x_{k}\right), x_{k+1}, \ldots, x_{n}\right]$</td>
<td>$\frac{\partial h}{\partial x_{i}} \propto \frac{\partial f}{\partial x_{i}}, i=1, \ldots, k$</td>
</tr>
<tr>
<td>Generalized</td>
<td>$f\left(x_{1}, x_{2}\right)=F\left[g\left(x_{1}\right)+h\left(x_{2}\right)\right]$</td>
<td>Solve for $F, g \&amp; h$</td>
</tr>
<tr>
<td>additivity</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Zero-snap</td>
<td>$\tilde{f}$ has numerical parameters $\mathbf{p}$</td>
<td>Replace $p_{i}$ by 0</td>
</tr>
<tr>
<td>Integer snap</td>
<td>$\tilde{f}$ has numerical parameters $\mathbf{p}$</td>
<td>Round $p_{i}$ to integer</td>
</tr>
<tr>
<td>Rational snap</td>
<td>$\tilde{f}$ has numerical parameters $\mathbf{p}$</td>
<td>Round $p_{i}$ to fraction</td>
</tr>
<tr>
<td>Reoptimize</td>
<td>$\tilde{f}$ has numerical parameters $\mathbf{p}$</td>
<td>Reoptimize $\mathbf{p}$ to minimize inaccuracy</td>
</tr>
</tbody>
</table>
<p>where hats denote unit vectors: $\widehat{\nabla f} \equiv \nabla f /|\nabla f|$, etc. This means that if we can discover a function $h$ whose gradient is proportional to that of $f$ (which we will describe a process for in Section 2.2), then we can simply replace the variables $\mathbf{x}$ in the original mystery data table by the single variable $h(\mathbf{x})$ and recursively apply our AI Feynman algorithm to the new one-dimensional symbolic regression problem of discovering $g(h)$.</p>
<p>Generalized symmetry Let us now turn to generalized symmetry (Figure 3, bottom left), where $k$ of the $n$ arguments enter only via some scalar function $h$ of them. Specifically, we say that an $f$ has generalized symmetry if the $n$ components of the vector $\mathbf{x} \in \mathbb{R}^{n}$ can be split into groups of $k$ and $n-k$ components (which we denote by the vectors $\mathbf{x}^{\prime} \in \mathbb{R}^{k}$ and $\mathbf{x}^{\prime \prime} \in \mathbb{R}^{n-k}$ ) such that $f(\mathbf{x})=f\left(\mathbf{x}^{\prime}, \mathbf{x}^{\prime \prime}\right)=g\left[h\left(\mathbf{x}^{\prime}\right), \mathbf{x}^{\prime \prime}\right]$ for some function $g$. By the chain rule, we have</p>
<p>$$
\nabla_{\mathbf{x}^{\prime}} f\left(\mathbf{x}^{\prime}, \mathbf{x}^{\prime \prime}\right)=g_{1}\left[h\left(\mathbf{x}^{\prime}\right), \mathbf{x}^{\prime \prime}\right] \nabla h\left(\mathbf{x}^{\prime}\right), \quad \text { so } \quad \widehat{\nabla_{\mathbf{x}^{\prime}} f}= \pm \widehat{\nabla h}
$$</p>
<p>where $g_{1}$ denotes the derivative of $g$ with respect to its first argument. This means that $\widehat{\nabla_{\mathbf{x}^{\prime}}} f\left(\mathbf{x}^{\prime}, \mathbf{x}^{\prime \prime}\right)$ is independent of $\mathbf{x}^{\prime \prime}$, which it would not be for a generic function $f$. $\mathbf{x}^{\prime \prime}$-independence of the normalized gradients $\widehat{\mathbf{v}}\left(\mathbf{x}^{\prime}, \mathbf{x}^{\prime \prime}\right) \equiv \widehat{\nabla_{\mathbf{x}^{\prime}}} f\left(\mathbf{x}^{\prime}, \mathbf{x}^{\prime \prime}\right)$ thus provides a smoking gun signature of generalized symmetry. Whereas our compositionality discovery above requires discovering an explicit function $h$, we can discover generalized symmetry without knowing $h$, thus only performing the time-consuming task of searching for an $h$ satisfying equation (2) after determining that a solution exists. The Supplementary Material details how we numerically test for $\mathbf{x}^{\prime \prime}$-independence of $\widehat{\mathbf{v}}\left(\mathbf{x}^{\prime}, \mathbf{x}^{\prime \prime}\right)$.</p>
<p>Generalized additivity If $f$ is a function of two variables, then we also test for generalized additivity (Figure 3, bottom right), where $f\left(x_{1}, x_{2}\right)=F\left[g\left(x_{1}\right)+h\left(x_{2}\right)\right]$. If we define the function</p>
<p>$$
s\left(x_{1}, x_{2}\right) \equiv \frac{\partial f / \partial x_{1}}{\partial f / \partial x_{2}}, \quad \text { then } \quad s\left(x_{1}, x_{2}\right)=\frac{g^{\prime}\left(x_{1}\right)}{h^{\prime}\left(x_{2}\right)}
$$</p>
<p>if $f$ satisfies the generalized additivity property. In other words, we simply need to test if $s$ is of the multiplicatively separable form $s\left(x_{1}, x_{2}\right)=a\left(x_{1}\right) b\left(x_{2}\right)$, and we do this using a variant of the separability test described in [25]. The Supplementary Material details how we perform this separability test numerically.</p>
<p>Table 2: Complexity definitions</p>
<table>
<thead>
<tr>
<th>Object</th>
<th>Symbol</th>
<th>Description length $L_{d}$</th>
</tr>
</thead>
<tbody>
<tr>
<td>Natural number</td>
<td>$n$</td>
<td>$\log _{2} n$</td>
</tr>
<tr>
<td>Integer</td>
<td>$m$</td>
<td>$\log _{2}(1+</td>
</tr>
<tr>
<td>Rational number</td>
<td>$m / n$</td>
<td>$L_{d}(m)+L_{d}(n)=\log _{2}[(1+</td>
</tr>
<tr>
<td>Real number</td>
<td>$r$</td>
<td>$\log <em _="+">{+}(\frac{r}{r}), \quad \log </em>\right)$}(x) \equiv \frac{1}{2} \log _{2}\left(1+x^{2</td>
</tr>
<tr>
<td>Parameter vector</td>
<td>$\mathbf{p}$</td>
<td>$\sum_{i} L_{d}\left(p_{i}\right)$</td>
</tr>
<tr>
<td>Parametrized function</td>
<td>$f(\mathbf{x} ; \mathbf{p})$</td>
<td>$L_{d}(\mathbf{p})+k \log _{2} n ; n$ basis functions appear k times</td>
</tr>
</tbody>
</table>
<h1>2.2 Robustness through recursive Pareto-optimality</h1>
<p>As illustrated in Figure 1, the goal of our symbolic regression of a data set is to approximate $f(\mathbf{x})$ by functions $\tilde{f}(\mathbf{x})$ that are not only accurate, but also simple, in the spirit of Occam's razor. As in [10], we seek functions that are Pareto-optimal in the sense of there being no other function that is both simpler and more accurate. We will adopt an information-theoretical approach and use bits of information to measure lack of both accuracy and simplicity.</p>
<p>For accuracy, we wish the vector $\boldsymbol{\varepsilon}$ of prediction errors $\varepsilon_{i} \equiv y_{i}-\tilde{f}\left(\mathbf{x}<em i="i">{i}\right)$ to be small. We quantify this not by the mean-squared error $\left\langle\varepsilon</em>$ defined as in [27], summarized in Table 2.
$L_{d}$ can be viewed as a crude but computationally convenient approximation of the number of bits needed to describe each object, made differentiable where possible. We choose the precision floor $\epsilon \equiv 2^{-30} \sim 10^{-9}$. For function complexity, both input variables and mathematical functions (e.g., $\cos$ and + ) count toward $n$ and $k$. For example, the classical kinetic energy formula has $L_{d}\left({ }^{*} m \times v \times v / 2^{n}\right)=L_{d}(2)+k \log }^{2}\right\rangle$ or max-error $\max \left|\varepsilon_{i}\right|$ as in [10, 25], but by the MEDL, the mean error-description-length $\left\langle L_{d}\left(\varepsilon_{i}\right)\right\rangle$ defined in Table 2. As argued in [27] and illustrated in Figure 4, this improves robustness to outliers. We analogously quantify complexity by the description length $L_{d<em 2="2">{2} n=\log </em> 4 \approx 13.6$ bits, since the formula contains $n=4$ basis functions ( $m, v, \times$ and $/$ ) used $k=6$ times.} 3+6 \log _{2</p>
<p>We wish to make the symbolic regression implementation of [25] more robust; it sometimes fails to discover the correct expression because of noise in the data or inaccuracies introduced by the neural network fitting. The neural network accuracy may vary strongly with $\mathbf{x}$, becoming quite poor in domains with little training data or when the network is forced to extrapolate rather than interpolate, and we desire a regression method robust to such outliers. We expect our insistence on Pareto-optimal functions in the information plane of Figure 1 to increase robustness, both because $\left\langle L_{d}\left(\varepsilon_{i}\right)\right\rangle$ is robust (Figure 4) and because noise and systematic errors are unlikely to be predictable by a simple mathematical formula with small $L_{d}$. More broadly, minimization of total exact description length (which $L_{d}$ crudely approximates) provably avoids the overfitting problem that plagues many alternative machine-learning strategies [28-30].</p>
<p>Speedup by recursive Pareto frontier composition When recursively symbolically regressing various modules (see Figure 2), we end up with a Pareto frontier of candidate functions for each one. If there are $n_{i}$ functions on the $i^{\text {th }}$ frontier, then combining them all would produce $\prod_{i} n_{i}$ candidates $\hat{f}(\mathbf{x})$ for the original function $f(\mathbf{x})$. We speed up our algorithm by Pareto-pruning after each merge step: whenever two modules are combined (via composition or multiplication, say), the resulting $n_{1} n_{2}$ functions are pruned by removing all functions that are Pareto-dominated by another function that is both simpler and more accurate. Pruning models on the Pareto frontier significantly reduces the number of models that need to be evaluated, since in typical scenarios, the number of Pareto-optimal points grows only logarithmically with the total number of points.</p>
<p>Robust speedup of brute-force graph search with hypothesis testing Our recursive reduction of regression mysteries into simpler ones terminates at the base case when the mystery function has only one variable and cannot be further modularized. As in [25], we subject these (and also all multivariate modules) to two solution strategies, polynomial fitting up to some degree (4 by default) and brute-force search, and then add all candidates functions to the Pareto plane and prune as above. The brute-force search would, if run forever, try all symbolic expressions by looping</p>
<p><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 4: When fitting a function (the right panel shows the example $\frac{ax^{3}}{c^{x/b}-1}$) to data with outliers, minimizing mean-squared-error (MSE) biases the curve toward the outliers (here finding $a \approx 0.89$, $b \approx 1.056$ ), whereas minimizing mean error description length (MEDL) ignores the outliers and recovers the correct answer $a=b=1$. Left panel compares MSE and MEDL loss functions for $b=1$.
over ever-more-complex graphs (the middle panel of Figure 2 shows an example) and over function options for each node.
Our brute-force computation of the Pareto frontier simply tries all functions $f_{k}(\mathbf{x})(k=1,2 \ldots)$ in order of increasing complexity $L_{d}\left(f_{k}\right)$ and keeps only those with lower mean error-description-length $d_{k} \equiv \frac{1}{N} \sum_{i=1}^{N} d_{k i}$ than the previous record holder, where $d_{k i} \equiv L_{d}\left[y_{i}-f_{k}\left(\mathbf{x}<em i="i" k="k">{i}\right)\right]$. When instead fitting normalized gradient vectors $\widehat{\nabla f}$ as in Section 2.1, we define $d</em>} \equiv L_{d}\left[1-\left|\hat{\mathbf{y}<em k="k">{i} \cdot \widehat{\nabla f</em>}}\left(\mathbf{x<em k="k">{i}\right)\right|\right]$ to handle the sign ambiguity. The bad news is that computing $d</em>}$ exactly is slow, requiring evaluation of $f_{k}\left(\mathbf{x<em i="i">{i}\right)$ for all $N$ data points $\mathbf{x}</em>$. Let $d_{k }$. The good news is that this is usually unnecessary, since for the vast majority of all candidate functions, it becomes obvious that they provide a poor fit after trying merely a handful of data points. We therefore accelerate the search via the following procedure. Before starting the loop over candidate functions, we sort the data points in random order to be able to interpret the numbers $d_{k i}$ as random samples from a probability distribution whose mean is the sought-for $d_{k}$ and whose standard deviation is $\sigma_{k<em>}$ and $\sigma_{k </em>}$ denote the corresponding quantities that were computed for the previous best-fit function we added to the Pareto frontier. We make the simplifying approximations that $\sigma_{k}=\sigma_{k <em>}$ and that all errors are uncorrelated, so that the loss estimate from the first $m$ data points $\hat{d}<em i="1">{k m} \equiv \frac{1}{m} \sum</em>$ and standard deviation $\sigma_{k }^{m} d_{k i}$ has mean $d_{k</em>} / \sqrt{m}$. We now test our candidate function $f_{i}$ on one data point at a time and reject it as soon as</p>
<p>$$
z&gt;\nu, \quad \text { where } \quad z \equiv \sqrt{m} \frac{\hat{d}<em>{k m}-d</em>{k <em>}}{\sigma_{k </em>}}
$$</p>
<p>where $\nu$ is a hyperparameter that we can interpret as the "number of sigmas" we require to rule out a candidate function as viable when its average error exceeds the previous record holder. We find that $\nu=10$ usually works well, generically requiring no more than a handful of evaluations $m$ per candidate function asymptotically. We can further increase robustness by increasing $\nu$ at the price of longer runtime.</p>
<p>Speedup by greedy search of simplification options We do not a priori know which of the modular decompositions from Figure 3 are most promising, and recursively trying all combinations of them would involve trying exponentially many options. We therefore accelerate our algorithm with a greedy strategy where at each step we compare the decomposition in a unified way and try only the most accurate one - our runtime thus grows roughly linearly with $n$, the number of input variables. $f(\mathbf{x})$ stays constant along constant- $h$ curves for generalized symmetry, simple symmetry (where $h(x, y)=x+y, x-y, x y$ or $x / y$ ) and generalized additivity (where $h(x, y)=a(x)+b(y)$ ). We thus test the accuracy of all such $h$-candidates by starting at a datapoint $\mathbf{x}<em i="i">{i}$ and computing an error $\epsilon</em>} \equiv f\left(\hat{\mathbf{x}<em i="i">{i}\right)-f\left(\mathbf{x}</em>}\right)$ for some $\hat{\mathbf{x}<em i="i">{i}$ satisfying $h\left(\hat{\mathbf{x}}</em>}\right)=h\left(\mathbf{x<em i="i">{i}\right)$. For additive and multiplicative separability, we follow [25] by examining a rectangle in parameter space and predicting $f$ at the fourth corner from the other three, defining $\epsilon</em>$ as the mismatch. The supplementary material details how our test points are chosen.</p>
<p><img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 5: A normalizing flow $g$ maps samples from a probability distribution $f$ (right) into a normal distribution (left), enabling an estimate (middle) of $f$, here illustrated for the $n=2, l=1, m=0$ hydrogen orbital from Table 5.</p>
<p>After this greedy recursive process has terminated, we further improve the Pareto frontier in two ways. We first add models where rational numbers are replaced by reals and optimized by gradient descent to fit the data. We then add models with zero-snap, integer-snap and rational-snap from Table 1 applied to all real-valued parameters as described in [27], pruning all Pareto-dominated models after each step. For example, if there are 3 real-valued parameters, integer-snap generates 3 new models where the 1, 2 and 3 parameters closest to integers get rounded, respectively.</p>
<h1>2.3 Leveraging normalizing flows to symbolic regress probability distributions</h1>
<p>An important but more difficult symbolic regression problem is when the unknown function $f(\mathbf{x})$ is a probability distribution from which we have random samples $\mathbf{x}<em i="i">{i}$ rather than direct evaluations $y</em>}=f\left(\mathbf{x<em _mathrm_NN="\mathrm{NN">{i}\right)$. We tackle this by adding preceding the regression by a step that estimates $f(\mathbf{x})$. For this step, we use the popular normalizing flow technique [31-35], training an invertible neural network mapping $\mathbf{x} \mapsto \mathbf{x}^{\prime} \equiv g(\mathbf{x})$ such that $\mathbf{x}^{\prime}$ has a multivariate normal distribution $n\left(\mathbf{x}^{\prime}\right)$ as illustrated in Figure 5. We then obtain our estimator $f</em>)] \mid J \mid$, where $J$ is the Jacobian of $g$.
We find rational-quadratic neural spline flows (RQ-NSF) suitable for relatively low-dimensional applications due to their enhanced expressivity. Specifically, we used three steps of the RQ-NSF with RQ-NSF (C) coupling layers as described in [34], parametrized by three 16-neuron softplus layers, trained for 50,000 epochs with the Adam optimizer. The learning rate was initialized to $3 \times 10^{-4}$ and halved every time the test loss failed to improve for 2500 epochs.}}(\mathbf{x})=n[g(\mathbf{x</p>
<h3>2.4 Neural Network training</h3>
<p>Our neural network approximation $f_{\mathrm{NN}}$ of the mystery function $f$ is fully-connected, feed-forward neural network with 4 hidden layers of 128, 128, 64 and 64 neurons, respectively, all with tanh activation function. We used $80 \%$ of the available data the training and the rest for validation. We used the r.m.s. error loss function and the Adam optimizer with $\beta$-parameters of 0.9 and 0.999 . The learning rate was initialized to 0.01 and reduced by a factor of 10 whenever the validation loss failed to improve for more than 20 epoch, until it reached $10^{-5}$. As mentioned, all our code is available at https://ai-feynman.readthedocs.io and by typing "pip install aifeynman".</p>
<h2>3 Results</h2>
<p>We now turn to quantifying the performance of our method with numerical experiments, comparing it with that of [25] which recently exceded the previous state of-the-art performance of [10]. To quantify robustness to noise, we add Gaussian noise of standard deviation $10^{r}$ to $y_{i}$ and determine the largest integer $r&lt;0$ for which the method successfully discovers the correct mystery function $f(\mathbf{x})$. As seen in Table 3, our method solves 73 of 100 baseline problems from the Feynman Symbolic Regression Database [25] with $r=-1$, and is typically 1-3 orders of magnitude more robust than that of [25]. Crudely speaking, we found that adding progressively more noise shifted the most accurate</p>
<p>Table 3: Robustness to noise</p>
<table>
<thead>
<tr>
<th style="text-align: center;">New robustness</th>
<th style="text-align: center;">$10^{-5}$</th>
<th style="text-align: center;">$10^{-4}$</th>
<th style="text-align: center;">$10^{-3}$</th>
<th style="text-align: center;">$10^{-2}$</th>
<th style="text-align: center;">$10^{-1}$</th>
<th style="text-align: center;">Total</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">图</td>
<td style="text-align: center;">$10^{-5}$</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td style="text-align: center;">图</td>
<td style="text-align: center;">$10^{-4}$</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">21</td>
</tr>
<tr>
<td style="text-align: center;">图</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">35</td>
</tr>
<tr>
<td style="text-align: center;">图</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">39</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Total</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">15</td>
<td style="text-align: center;">100</td>
</tr>
</tbody>
</table>
<p>Table 4: Test equations exhibiting translational symmetry $h=x \pm y(\mathrm{~T})$, scaling symmetry $h=x / y$ (S), product symmetry $h=x y(\mathrm{P})$, generalized symmetry (G), multiplicative separability (M), compositionality (C) and generalized additivity (A).</p>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">Equation</th>
<th style="text-align: center;">Symmetries</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">$\delta=-5.41+4.9 \frac{\alpha-\beta+\gamma / \chi}{\beta \chi}$</td>
<td style="text-align: center;">TC</td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;">$\chi=0.23+14.2 \frac{\alpha+\beta}{\beta \gamma}$</td>
<td style="text-align: center;">TS</td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: center;">$\beta=213.80940889\left(1-e^{-0.54723748542 \alpha}\right)$</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">4</td>
<td style="text-align: center;">$\delta=6.87+11 \sqrt{\alpha \beta \gamma}$</td>
<td style="text-align: center;">P</td>
</tr>
<tr>
<td style="text-align: center;">5</td>
<td style="text-align: center;">$V=\left[R_{1}^{-1}+R_{2}^{-1}+R_{3}^{-1}+R_{4}^{-1}\right]^{-1} I_{0} \cos \omega t \quad$ (Parallel resistors)</td>
<td style="text-align: center;">PGSM</td>
</tr>
<tr>
<td style="text-align: center;">6</td>
<td style="text-align: center;">$I_{0}=\frac{V_{0}}{\sqrt{R^{2}+\left(\omega L-\frac{1}{\omega C}\right)^{2}}}$ (RLC circuit )</td>
<td style="text-align: center;">MG</td>
</tr>
<tr>
<td style="text-align: center;">7</td>
<td style="text-align: center;">$I=\frac{V_{0}(\cos \omega t}{\sqrt{R^{2}+\left(\omega L-\frac{1}{\omega C}\right)^{2}}}$ (RLC circuit)</td>
<td style="text-align: center;">MG</td>
</tr>
<tr>
<td style="text-align: center;">8</td>
<td style="text-align: center;">$V_{2}=\left(\frac{R_{2}}{R_{1}+R_{2}}-\frac{R_{x}}{R_{x}+R_{3}}\right) V_{1} \quad$ (Wheatstone bridge)</td>
<td style="text-align: center;">SGMA</td>
</tr>
<tr>
<td style="text-align: center;">9</td>
<td style="text-align: center;">$v=c \frac{\left(v_{1}+v_{2}+v_{3}\right) / c+v_{1} v_{2} v_{3} / c^{3}}{1+\left(v_{1} v_{2}+v_{1} v_{3}+v_{2} v_{3}\right) / c^{2}} \quad$ (Velocity addition)</td>
<td style="text-align: center;">AG</td>
</tr>
<tr>
<td style="text-align: center;">10</td>
<td style="text-align: center;">$v=c \frac{\left(v_{1}+v_{2}+v_{3}+v_{4}\right) / c+\left(v_{2} v_{3} v_{4}+v_{1} v_{3} v_{4}+v_{1} v_{2} v_{4}+v_{1} v_{2} v_{3}\right) / c^{3}}{1+\left(v_{1} v_{2}+v_{1} v_{3}+v_{1} v_{4}+v_{2} v_{3}+v_{2} v_{4}+v_{3} v_{4}\right) / c^{2}+v_{1} v_{2} v_{3} v_{4} / c^{4}} \quad$ (Velocity addition)</td>
<td style="text-align: center;">GA</td>
</tr>
<tr>
<td style="text-align: center;">11</td>
<td style="text-align: center;">$z=\left(x^{4}+y^{4}\right)^{1 / 4} \quad(L_{4}$-norm)</td>
<td style="text-align: center;">AC</td>
</tr>
<tr>
<td style="text-align: center;">12</td>
<td style="text-align: center;">$w=x y z-z \sqrt{1-x^{2}} \sqrt{1-y^{2}}-y \sqrt{1-x^{2}} \sqrt{1-z^{2}}-x \sqrt{1-y^{2}} \sqrt{1-z^{2}}$</td>
<td style="text-align: center;">GA</td>
</tr>
<tr>
<td style="text-align: center;">13</td>
<td style="text-align: center;">$z=\frac{x y+\sqrt{1-x^{2}-y^{2}+x^{2} y^{2}}}{y \sqrt{1-x^{2}}-x \sqrt{1-y^{2}}}$</td>
<td style="text-align: center;">A</td>
</tr>
<tr>
<td style="text-align: center;">14</td>
<td style="text-align: center;">$z=y \sqrt{1-x^{2}}+x \sqrt{1-y^{2}}$</td>
<td style="text-align: center;">A</td>
</tr>
<tr>
<td style="text-align: center;">15</td>
<td style="text-align: center;">$z=x y-\sqrt{1-x^{2}} \sqrt{1-y^{2}}$</td>
<td style="text-align: center;">A</td>
</tr>
<tr>
<td style="text-align: center;">16</td>
<td style="text-align: center;">$r=\frac{a}{\cot (\alpha / 2)+\cot (\beta / 2)} \quad$ (Incircle)</td>
<td style="text-align: center;">GMAC</td>
</tr>
</tbody>
</table>
<p>formula straight upward in the Pareto plane (Figure 1) until it no longer provided any accuracy gains compared with simpler approximations.
To quantify the ability of our method to discover more complex equations, we reran it on all 17 mysteries that [25] tackled and failed to solve. We also tested a dozen new mysteries exhibiting various forms of graph modularity (see Table 4) that were all chosen before any of them were tested. Allowing at most two hours of runtime, the method of [25] solved 5 of the equations, whereas our new method solved them all, as well as four of the outstanding mysteries from [25] (rows 1-4). For these first four, our method got the numerical parameters in the right ballpark with rational approximations, then discovered their exact values through gradient descent.
To quantify the ability of our method to discover probability distributions, we tested it on samples from the ten distributions in Table 5. As seen in the table, $80 \%$ were solved, requiring between $10^{2}$ and $10^{5}$ samples $\mathbf{x}_{i}$. The flows trained in about 20 minutes on one CPU, scaling roughly linearly with sample size and number of network weights.
We discuss common failure modes below. Interestingly, these do not include overfitting, for multiple reasons: (1) We early-stop training when the validation loss starts increasing. (2) We avoid using our neural network (to guess symbolic functions) outside the domain where it was trained. (3) Overfitting noise would generally reduce apparent graph modularity, thus causing failure to discover formulas rather than discovery of spurious "overfit" formulas. (4) A key desirable feature of the minimum-description-length formalism (the information-theoretical inspiration for our method) is that it provably avoids overfitting as shown in $[28,30]$.</p>
<p>Table 5: Probability distributions and number of samples $N$ required to discover them</p>
<table>
<thead>
<tr>
<th>Distribution Name</th>
<th>Probability distribution</th>
<th>$N$</th>
</tr>
</thead>
<tbody>
<tr>
<td>Laplace distribution</td>
<td>$\frac{1}{2} e^{-</td>
<td>x</td>
</tr>
<tr>
<td>Beta distribution $(\alpha=0.5, \beta=0.5)$</td>
<td>$\frac{1}{2} \frac{1}{\sqrt{x(1-x)}}$</td>
<td>$10^{4}$</td>
</tr>
<tr>
<td>Beta distribution $(\alpha=5, \beta=2)$</td>
<td>$30 x^{4}(1-x)$</td>
<td>$10^{4}$</td>
</tr>
<tr>
<td>Harmonic oscillator $\left(n=2, \frac{m \omega}{\hbar}=1\right)$</td>
<td>$\frac{2}{\sqrt{\pi}} x^{2} e^{-x^{2}}$</td>
<td>$10^{5}$</td>
</tr>
<tr>
<td>Sinc diffraction pattern</td>
<td>$\frac{1}{x}\left(\frac{\sin x}{x}\right)^{2}$</td>
<td>$10^{4}$</td>
</tr>
<tr>
<td>2D normal distribution (correlated)</td>
<td>$\frac{1}{\sqrt{3 \pi}} e^{-\frac{2}{3}\left(x^{2}-x y+y^{2}\right)}$</td>
<td>$10^{3}$</td>
</tr>
<tr>
<td>2D harmonic oscillator $\left(n=2, m=1, \frac{m \omega}{\hbar}=1\right)$</td>
<td>$\frac{2}{3} x^{2} e^{-x^{2}-y^{2}}$</td>
<td>$10^{5}$</td>
</tr>
<tr>
<td>Hydrogen orbital $\left(n=1, l=0, m=0\right)$</td>
<td>$\frac{1}{3} e^{-2 r}$</td>
<td>$10^{3}$</td>
</tr>
<tr>
<td>Hydrogen orbital $\left(n=2, l=1, m=0\right)$</td>
<td>$\frac{1}{16} r^{2} e^{-r} \cos ^{2} \theta$</td>
<td>-</td>
</tr>
<tr>
<td>Hydrogen orbital $\left(n=3, l=1, m=0\right)$</td>
<td>$\frac{1}{729} r^{2}\left(4-\frac{2 r}{3}\right)^{2} e^{-\frac{2 r}{3}} \cos ^{2} \theta$</td>
<td>-</td>
</tr>
</tbody>
</table>
<h1>4 Conclusions</h1>
<p>We have presented a symbolic regression method that exploits neural networks, graph modularity, hypothesis testing and normalizing flows, and released it at https://ai-feynman.readthedocs. io. It improves state-of-the-art performance both by being more robust towards noise and by solving harder problems, including symbolic density estimation.</p>
<p>Despite these advances, numerous equations remained unsolved, motivating further work. Here are some interesting failure modes we identified. Some cases failed because the form of the equation precluded our method from breaking it into small enough pieces. For example, for the equation</p>
<p>$$
\alpha^{3} e^{-\alpha} \cos \alpha \sin \alpha\left<a href="\beta-5">\cos \alpha(\sin \alpha)^{2}-1\right</a>
$$</p>
<p>our algorithm discovered the multiplicative separability into terms including only $\alpha$ and only $\beta$. However, the remaining $\alpha$-term was too complicated to be solved in a reasonable amount of time by the brute force code, and none of the graph modularity methods apply because they only help for functions of more than one variable. For other equations, our method fails but not irreparably. For example, for the function</p>
<p>$$
22-4.2[\cos \alpha-\tan \beta] \tanh \gamma / \sin \chi
$$</p>
<p>our code is able to discover that $\gamma$ and $\chi$ can be separated from the rest of the equation. However, given that we allow the brute force code to run for only a minute for each iteration, the expression $\tanh \gamma$ is not discovered, mainly because we did not include tanh as one of the functions used, so the brute force would have to write that as $\frac{e^{2 \gamma}-1}{e^{2 \pi}+1}$. By allowing the code to run for longer or using with other basis functions (such as tanh), the code could solve this and several other mysteries that we reported as failures. Success and failure modes are further discussed in the Supplementary Material.
There are many obvious ways in which the core ideas of this paper can be extended to further improve symbolic regression. For example, gradients can reveal more types of graph modularity than the Figure 3 examples that we exploited (e.g. where modules output more than one variable), additional simplification strategies can be included in the Pareto-optimal recursion, and flow-based regression can be used for regularized density estimation from sparse high-dimensional data. Larger and more challenging collections of science-based equations are needed to benchmark and inspire improved algorithms. A higher-level direction for improvement is to generalize the problem itself: Whereas symbolic regression takes the regression variables as given, discovering novel formulas from real-world data typically requires also the pre-regression step of mapping high-dimensional data into a low-dimensional latent space whose coordinates are promising candidates for symbolic regression; [36] provides a literature review and early steps in this direction.</p>
<p>Pareto-optimal symbolic regression has the power to not only discover exact formulas, but also approximate ones that are useful for being both accurate and simple. The mainstream view is that all known science formulas are such approximations. We live in a golden age of research with ever-larger datasets produced by both experiments and numerical computations, and we look forward to a future when symbolic regression is as ubiquitous as linear regression is today, helping us better understand the relations hidden in these datasets.</p>
<h1>Acknowledgments and Disclosure of Funding</h1>
<p>The authors with to thank Philip Tegmark for helpful comments, and the Center for Brains, Minds, and Machines (CBMM) for hospitality.</p>
<p>Funding: This work was supported by The Casey and Family Foundation, the Ethics and Governance of AI Fund, the Foundational Questions Institute, the Rothberg Family Fund for Cognitive Science and the Templeton World Charity Foundation, Inc.
Competing interests: The authors declare that they have no competing interests.
Data and materials availability: Data and code have been publicly released at https://ai-feynman.readthedocs.io.</p>
<h2>Broader Impact</h2>
<h2>Who may benefit from this research</h2>
<p>Our research presumably has quite broad impact, since discovery of mathematical patterns in data is a central problem across the natural and social sciences. Given the ubiquity of linear regression in research, one might expect that there will significant benefits to a broad range of researchers also from more general symbolic regression once freely available algorithms get sufficiently good.</p>
<h2>Who may be put at disadvantage from this research</h2>
<p>Although it is possible that some numerical modelers could get their jobs automated away by symbolic regression, we suspect that the main effect of our method, and future tools building on it, will instead be that these people will simply discover better models than today.</p>
<h2>Risk of bias, failure and other negative outcomes</h2>
<p>Pareto-optimal symbolic regression can be viewed as an extreme form of lossy data compression that uncovers the simplest possible model for any given accuracy. To the extent that overfitting can exacerbate bias, such model compression is expected to help. Moreover, since our method produces closed-form mathematical formulas that have excellent interpretability compared to black-box neural networks, they make it easier for humans to interpret the computation and pass judgement on whether it embodies unacceptable bias. This interpretability also reduces failure risk.</p>
<p>Another risk is automation bias, whereby people overly trust a formula from symbolic regression when they extrapolate it into an untested domain. This could be exacerbated if symbolic regression promotes scientific laziness and enfeeblement, where researchers fit phenomenological models instead of doing the work of building models based on first principles. Symbolic regression should inform but not replace traditional scientific discovery.
Although the choice of basis functions biases the discoverable function class, our method is agnostic to basis functions as long as they are mostly differentiable.</p>
<p>The greatest potential risk associated with this work does not stem from it failing but from it succeeding: accelerated progress in symbolic regression, modularity discovery and its parent discipline, program synthesis, could hasten the arrival of artificial general intelligence, which some authors have argued humanity still lacks the tools to manage safely [5]. On the other hand, our work may help accelerate research on intelligible intelligence more broadly, and powerful future artificial intelligence is probably safer if we understand aspects of how it works than if it is an inscrutable black box.</p>
<h1>References</h1>
<p>[1] Stuart Russell, Daniel Dewey, and Max Tegmark. Research priorities for robust and beneficial artificial intelligence. Ai Magazine, 36(4):105-114, 2015.
[2] Dario Amodei, Chris Olah, Jacob Steinhardt, Paul Christiano, John Schulman, and Dan Mané. Concrete problems in ai safety. arXiv preprint arXiv:1606.06565, 2016.
[3] Margaret Boden, Joanna Bryson, Darwin Caldwell, Kerstin Dautenhahn, Lilian Edwards, Sarah Kember, Paul Newman, Vivienne Parry, Geoff Pegman, Tom Rodden, et al. Principles of robotics: regulating robots in the real world. Connection Science, 29(2):124-129, 2017.
[4] Viktoriya Krakovna and Finale Doshi-Velez. Increasing the interpretability of recurrent neural networks using hidden markov models. arXiv preprint arXiv:1606.05320, 2016.
[5] Stuart Russell. Human compatible: Artificial intelligence and the problem of control. Penguin, 2019.
[6] James P Crutchfield and Bruce S McNamara. Equation of motion from a data series. Complex systems, 1(417-452):121, 1987.
[7] Saso Dzeroski and Ljupco Todorovski. Discovering dynamics: from inductive logic programming to machine discovery. Journal of Intelligent Information Systems, 4(1):89-108, 1995.
[8] Elizabeth Bradley, Matthew Easley, and Reinhard Stolle. Reasoning about nonlinear system identification. Artificial Intelligence, 133(1-2):139-188, 2001.
[9] Pat Langley, Dileep George, Stephen D Bay, and Kazumi Saito. Robust induction of process models from time-series data. In Proceedings of the 20th International Conference on Machine Learning (ICML-03), pages 432-439, 2003.
[10] Michael Schmidt and Hod Lipson. Distilling free-form natural laws from experimental data. science, 324(5923):81-85, 2009.
[11] Randall K McRee. Symbolic regression using nearest neighbor indexing. In Proceedings of the 12th annual conference companion on Genetic and evolutionary computation, pages 1983-1990. ACM, 2010.
[12] Dominic P Searson, David E Leahy, and Mark J Willis. Gptips: an open source genetic programming toolbox for multigene symbolic regression. In Proceedings of the International multiconference of engineers and computer scientists, volume 1, pages 77-80. IMECS Hong Kong, 2010.
[13] Renáta Dubčáková. Eureqa: software review. Genetic programming and evolvable machines, 12(2):173-178, 2011.
[14] Sean Stijven, Wouter Minnebo, and Katya Vladislavleva. Separating the wheat from the chaff: on feature selection and feature importance in regression random forests and symbolic regression. In Proceedings of the 13th annual conference companion on Genetic and evolutionary computation, pages 623-630. ACM, 2011.
[15] Michael D Schmidt, Ravishankar R Vallabhajosyula, Jerry W Jenkins, Jonathan E Hood, Abhishek S Soni, John P Wikswo, and Hod Lipson. Automated refinement and inference of analytical models for metabolic networks. Physical biology, 8(5):055011, 2011.
[16] Christopher Hillar and Friedrich Sommer. Comment on the article" distilling free-form natural laws from experimental data". arXiv preprint arXiv:1210.7273, 2012.
[17] Bryan C Daniels and Ilya Nemenman. Automated adaptive inference of phenomenological dynamical models. Nature communications, 6:8133, 2015.
[18] Pat Langley and Adam Arvay. Heuristic induction of rate-based process models. In Twenty-Ninth AAAI Conference on Artificial Intelligence, 2015.
[19] Ignacio Arnaldo, Una-May O'Reilly, and Kalyan Veeramachaneni. Building predictive models via feature synthesis. In Proceedings of the 2015 Annual Conference on Genetic and Evolutionary Computation, pages 983-990, 2015.
[20] Steven L Brunton, Joshua L Proctor, and J Nathan Kutz. Discovering governing equations from data by sparse identification of nonlinear dynamical systems. Proceedings of the National Academy of Sciences, 113(15):3932-3937, 2016.</p>
<p>[21] Matthew Guzdial, Boyang Li, and Mark O Riedl. Game engine learning from video. In IJCAI, pages 3707-3713, 2017.
[22] Markus Quade, Markus Abel, J Nathan Kutz, and Steven L Brunton. Sparse identification of nonlinear dynamics for rapid model recovery. Chaos: An Interdisciplinary Journal of Nonlinear Science, 28(6):063116, 2018.
[23] Maciej Koch-Janusz and Zohar Ringel. Mutual information, neural networks and the renormalization group. Nature Physics, 14(6):578, 2018.
[24] Weiwei Kong, Christopher Liaw, Aranyak Mehta, and D Sivakumar. A new dog learns old tricks: Rl finds classic optimization algorithms. ICLR, 2018.
[25] Silviu-Marian Udrescu and Max Tegmark. AI Feynman: A physics-inspired method for symbolic regression. Science Advances, 6(16):eaay2631, 2020.
[26] Jiechun Liang and Xi Zhu. Phillips-inspired machine learning for band gap and exciton binding energy prediction. The journal of physical chemistry letters, 10(18):5640-5646, 2019.
[27] Tailin Wu and Max Tegmark. Toward an artificial intelligence physicist for unsupervised learning. Physical Review E, 100(3):033311, 2019.
[28] J. Rissanen. Modeling by shortest data description. Automatica, 14(5):465 - 471, 1978.
[29] Marcus Hutter. A theory of universal artificial intelligence based on algorithmic complexity. arXiv preprint cs/0004001, 2000.
[30] Peter D Grünwald, In Jae Myung, and Mark A Pitt. Advances in minimum description length: Theory and applications. MIT press, 2005.
[31] Danilo Rezende and Shakir Mohamed. Variational inference with normalizing flows. In Francis Bach and David Blei, editors, Proceedings of the 32nd International Conference on Machine Learning, volume 37 of Proceedings of Machine Learning Research, pages 1530-1538, Lille, France, 07-09 Jul 2015. PMLR.
[32] Laurent Dinh, Jascha Sohl-Dickstein, and Samy Bengio. Density estimation using real nvp. 2017.
[33] Durk P Kingma and Prafulla Dhariwal. Glow: Generative flow with invertible 1x1 convolutions. In S. Bengio, H. Wallach, H. Larochelle, K. Grauman, N. Cesa-Bianchi, and R. Garnett, editors, Advances in Neural Information Processing Systems 31, pages 10215-10224. Curran Associates, Inc., 2018.
[34] Conor Durkan, Artur Bekasov, Iain Murray, and George Papamakarios. Neural spline flows. In H. Wallach et al, editor, Advances in Neural Information Processing Systems 32, pages 7511-7522. Curran Associates, Inc., 2019.
[35] I. Kobyzev, S. Prince, and M. Brubaker. Normalizing flows: An introduction and review of current methods. IEEE Transactions on Pattern Analysis and Machine Intelligence, pages 1-1, 2020.
[36] Silviu-Marian Udrescu and Max Tegmark. Symbolic pregression: Discovering physical laws from raw distorted video. arXiv preprint arXiv:2005.11212, 2020.</p>
<h1>Supplementary material</h1>
<p>Below we provide additional technical details about how we implement our method and numerical experiments.</p>
<h2>A Testing for generalized symmetry</h2>
<p>We showed that generalized symmetry can be revealed by $\widehat{\mathbf{v}}\left(\mathbf{x}^{\prime}, \mathbf{x}^{\prime \prime}\right)$ being independent of $\mathbf{x}^{\prime \prime}$. We will now describe how we test for such $\mathbf{x}^{\prime \prime}$-independence numerically. Given a point $\mathbf{x}<em j="j">{i} \in \mathbb{R}^{k}$ from our data set, we compute a set of normalized gradients $\widehat{\mathbf{v}}</em>} \equiv \widehat{\mathbf{v}<em i="i">{i}\left(\mathbf{x}</em>}^{\prime}, \mathbf{x<em j="j">{j}^{\prime \prime}\right)$, where $\mathbf{x}</em>$ correspond to a sample of $m$ other data points, and quantify the variation between then by the quantity}^{\prime \prime} \in \mathbb{R}^{n-k</p>
<p>$$
V(\mathbf{x}) \equiv 1-\max <em j="1">{|\mu|=1} \frac{1}{m} \sum</em>}^{m}\left(\widehat{\mu} \cdot \widehat{\mathbf{v}<em _mu_="1">{j}\right)^{2}=1-\max </em>} \widehat{\mu}^{t} \mathbf{V} \widehat{\mu}, \quad \text { where } \quad \mathbf{V} \equiv \frac{1}{m} \sum_{j=1}^{m} \widehat{\mathbf{v}<em j="j">{j} \widehat{\mathbf{v}}</em>
$$}^{t</p>
<p>We can intuitively interpret the optimal $\widehat{\mu}$ as maximally aligned with the vectors $\widehat{\mathbf{v}}<em j="j">{j}$ up to a sign. Equation (5) implies that our variation measure $V$ is simply one minus the smallest eigenvalue of $\mathbf{V}$, so $V$ ranges from 0 when all $\widehat{\mathbf{v}}</em>}$ are identical to $1-\frac{1}{m}$ when all eigenvalues are equal (equal to $1 / m$, since $\operatorname{tr} \mathbf{V}=1$ ). As illustrated in Figure 6, we compute $V\left(\mathbf{x<em g="g">{i}\right)$ for each subset of up to $n</em>}$ input variables, and select the subset with the smallest median $V\left(\mathbf{x<em g="g">{i}\right)$ as the most promising generalized symmetry candidate. In our numerical experiments, we set the hyperparameter $n</em>$ subsets for large $n$.
}=3$ to save time, since we do not wish to consider all $2^{n<img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>Figure 6: Distribution of $V\left(\mathbf{x}_{i}\right)$ for the function from Figure 2, revealing that evidence for the generalized symmetry $f(x, y, z)=g[h(x, y), z]$ (shaded distribution) is stronger than for $f(x, y, z)=g[h(x, z), y]$ (blue curve) or $f(x, y, z)=g[h(y, z), x]$ (red curve). The curves are shown slightly smoothed for clarity.</p>
<h2>B Testing for generalized additivity</h2>
<p>We showed that generalized additivity holds when the function $s\left(x_{1}, x_{2}\right)$ from Equation (3) from the main part of the paper is multiplicatively separable. We will now describe how we test for such separability numerically. $s\left(x_{1}, x_{2}\right)$ being multiplicative separable is equivalent to $f\left(x_{1}, x_{2}\right) \equiv$ $\ln s\left(x_{1}, x_{2}\right)$ being additively separable. We numerically test the function $\ln s_{N N}\left(x_{1}, x_{2}\right)$ for additive separability using the normalized score $S$ defining</p>
<p>$$
S[f]=\frac{\left|f_{, x y}\right|^{2}}{\left|f_{, x x} f_{, y y}\right|+\left|f_{, x y}\right|^{2}}
$$</p>
<p>It is easy to see that $S[f]=0$ if $f$ is additively separable, and $S[f]&gt;0$ otherwise. If the median value of $S$ over all points $\mathbf{x}<em>{i}$ in the dataset is below a threshold $S</em>{<em>}$, we take this as evidence for generalized additivity and proceed as below. We found empirically that the threshold choise $S_{</em>}=0.1$ produced robust results. It is important to use smooth (not, e.g., ReLU) activation functions for this derivative-based test to be useful.</p>
<p>If this property holds, then we recursively apply our algorithm to the two new 1-dimensional symbolic regression problems of discovering $a\left(x_{1}\right)$ and $b\left(x_{2}\right)$. If this succeeds and we are able to discover the</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: center;">Schmidt \&amp; Lipson 2009</th>
<th style="text-align: center;">Udrescu \&amp; Tegmark 2020</th>
<th style="text-align: center;">This paper</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">FDSR basic 100</td>
<td style="text-align: center;">$71 \%$</td>
<td style="text-align: center;">$\mathbf{1 0 0 \%}$</td>
<td style="text-align: center;">$\mathbf{1 0 0 \%}$</td>
</tr>
<tr>
<td style="text-align: left;">FDSR harder 20</td>
<td style="text-align: center;">$15 \%$</td>
<td style="text-align: center;">$85 \%$</td>
<td style="text-align: center;">$\mathbf{9 0 \%}$</td>
</tr>
<tr>
<td style="text-align: left;">12 modular equations</td>
<td style="text-align: center;">$42 \%$</td>
<td style="text-align: center;">$42 \%$</td>
<td style="text-align: center;">$\mathbf{1 0 0 \%}$</td>
</tr>
<tr>
<td style="text-align: left;">10 probability distributions</td>
<td style="text-align: center;">$60 \%$</td>
<td style="text-align: center;">$70 \%$</td>
<td style="text-align: center;">$\mathbf{8 0 \%}$</td>
</tr>
</tbody>
</table>
<p>Table 6: Fraction of symbolic regression problems solved for the benchmarks in the Feynman Database for Symbolic Regression (FDRS) and this paper.
functions $g\left(x_{1}\right)$ and $h\left(x_{2}\right)$ by symbolically integrating our solutions $g^{\prime}=a$ and $h^{\prime}=1 / h$, then we have reduced the original problem to the same state as when we found compositionality above, now with $h\left(x_{1}, x_{2}\right)=g\left(x_{1}\right)+h\left(x_{2}\right)$. Just as in that case, we simply replace the variables $\mathbf{x}$ in the original mystery data table by the single variable $h(\mathbf{x})$ and recursively apply our AI Feynman algorithm to the new 1-dimensional symbolic regression problem of discovering how $f$ depends on $h$.</p>
<p>If we have determined that generalized additivity holds but the aforementioned method for discovering $g\left(x_{1}\right)+h\left(x_{2}\right)$ fails, we make a second attempt by training a neural network of the modular form $f_{\mathrm{NN}}\left(x_{1}, x_{2}\right)=F\left[g\left(x_{1}\right)+h\left(x_{2}\right)\right]$ to fit the data. If this succeeds, we then recursively apply our AI Feynman algorithm to the three new 1-dimensional symbolic regression problems of discovering $F$, $g$ and $h$.</p>
<h1>C Further details on success and failure modes</h1>
<p>Our paper reports which symbolic regression problems our method succeeded and failed on, as detailed in Tables 6-8. Here we add specifics on how these successes and failures occurred.</p>
<p>Success definition Given a data set $\left{x_{1}, \ldots, x_{n}, y\right}$, we use $90 \%$ of the data to compute a Paretooptimal set of candidate functions $\tilde{f}_{i}(\mathbf{x})$, then rank them based on their MEDL accuracy on the held-back $10 \%$ of the data. We count our method as successful only if the top-ranked function matches the true $f(\mathbf{x})$ exactly, or, if the definition of $f$ involves irrational numerical parameters, if these parameters are recovered to better than $0.01 \%$ relative accuracy.</p>
<p>We considered an equation solved even if the top solution was not in the exact form presented in our tables, but mathematically equivalent. For example, our method predicted that Equation (12) in Table 4 was $w=\cos [\arccos (x)+\arccos (y)+\arccos (z)]$, which is mathematically equivalent within the domain of our provided data set, where $x, y, z \in[-1,1]$.
For the problem of density estimation from samples, our goal was to obtain the correct normalized probability distributions. The candidate functions on the Pareto-frontier were therefore discarded unless they were non-negative and normalizable. The surviving candidates were then normalized to integrate to unity by symbolic/numerical integration to obtain the appropriate normalization constant, and quality-ranked by the surprisal loss function</p>
<p>$$
L_{i}=-\sum \log \tilde{f}<em k="k">{i}\left(\mathbf{x}</em>\right)
$$</p>
<p>evaluated on the held-back test data.
Success examples Tables 7 and 8 below show the highest noise level allowing each of the 100 equations from the Feynman Database for Symbolic regression to be solved in the original paper analyzing it and in the present paper.
For many of the solved equations, the modularity discovery had to be used multiple times in order for the correct equation to be discovered, reflecting the power of the recursive algorithm. For example, for the quadruple velocity addition equation in Table 4, generalized symmetry was exploited twice. First, the code discovered that the first two velocities only enter in the combination $\frac{v_{1}+v_{2}}{1+v_{1} v_{2}}$, and these two variables were replaced by a new variable $v_{12}$. The same method then discovered that $v_{12}$ and $v_{3}$ only enter in that same combination $\frac{v_{12}+v_{3}}{1+v_{12} v_{3}}$, and thus the initial 3 variables $v_{1}, v_{2}$ and $v_{3}$ were replaced by a single variable $v_{123}$. Now the remaining equation had only 2 variables left, and was solved by brute force. In principle, this recursive method can be used to discover relativistic addition of an arbitrary number of velocities, by reducing the number of variables by one at each step.</p>
<p>Failure examples Some of the most obvious failure modes we discussed in the conclusions of the main text. Here we discuss some more subtle failure modes. Firstly, it is worth noting that our definition of complexity is dependent on the chosen set of operations and does not always match our intuition. For example, in fitting the probability distribution</p>
<p>$$
p(r, \theta)=\frac{1}{16} r^{2} e^{-r} \cos ^{2} \theta
$$</p>
<p>of electron positions in the $n=2, l=1, m=0$ hydrogen orbital, solutions with $\theta$-dependence $\cos (\cos \theta)$ are preferred over $\cos ^{2} \theta$. This is because, up to additive and multiplcative prefactors, the two formulas differ by at most approximately $2 \times 10^{-2}$ over our parameter range, but given a set of operations that includes only ${\times, \cos }$ denoted by "<em>" and " $C$ " respectively in reverse Polish notation, $\cos (\cos \theta))$ (encoded as" $x C C$ ") is simpler than $\cos ^{2} \theta$ (encoded as " $x C x C </em>$ "). In the presence of the imprecisions introduced by the normalizing flow, we were unable to perform the density estimation a level at which the accuracy for the correct $\cos ^{2} \theta$ was preferred over the simpler alternative.
Furthermore, more interpretable approximations (e.g. Taylor expansions) are not always favored by our definition of complexity. For example, in Figure 1, the unfamiliar solution</p>
<p>$$
m c^{2}\left(\frac{1}{\cos v / c}-1\right)
$$</p>
<p>intermediate to the more familiar $\frac{m v^{2}}{2}$ and $m c^{2}\left(\frac{1}{\sqrt{1-v^{2} / c^{2}}}-1\right)$ of can be understood as a fourthorder expansion about $v=0$ of the exact formula. Specifically, $m c^{2}\left(\frac{1}{\sqrt{1-v^{2} / c^{2}}}-1\right)=\frac{m v^{2}}{2}+$ $\frac{3 m v^{4}}{8 c^{2}}+O\left(v^{6}\right)$, and $m c^{2}\left(\frac{1}{\cos v / c}-1\right)=\frac{m v^{2}}{2}+\frac{5 m v^{4}}{24 c^{2}}+O\left(v^{6}\right)$. The Taylor expansions themselves are not preferred for reasons of complexity.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Feynman eq.</th>
<th style="text-align: center;">Equation</th>
<th style="text-align: center;">Old Noise tolerance</th>
<th style="text-align: center;">New Noise tolerance</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">I.6.20a</td>
<td style="text-align: center;">$f=e^{-\theta^{2} / 2} / \sqrt{2 \pi}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.6.20</td>
<td style="text-align: center;">$f=e^{-\frac{\theta^{2}}{2 \sigma^{2}}} / \sqrt{2 \pi \sigma^{2}}$</td>
<td style="text-align: center;">$10^{-4}$</td>
<td style="text-align: center;">$10^{-2}$</td>
</tr>
<tr>
<td style="text-align: center;">I.6.20b</td>
<td style="text-align: center;">$f=e^{-\frac{\left(\theta-\theta_{1}\right)^{2}}{2 \sigma^{2}}} / \sqrt{2 \pi \sigma^{2}}$</td>
<td style="text-align: center;">$10^{-4}$</td>
<td style="text-align: center;">$10^{-2}$</td>
</tr>
<tr>
<td style="text-align: center;">I.8.14</td>
<td style="text-align: center;">$d=\sqrt{\left(x_{2}-x_{1}\right)^{2}+\left(y_{2}-y_{1}\right)^{2}}$</td>
<td style="text-align: center;">$10^{-4}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.9.18</td>
<td style="text-align: center;">$F=\frac{G m_{1} m_{2}}{\left(x_{2}-x_{1}\right)^{2}+\left(y_{2}-y_{1}\right)^{2}+\left(z_{2}-z_{1}\right)^{2}}$</td>
<td style="text-align: center;">$10^{-5}$</td>
<td style="text-align: center;">$10^{-3}$</td>
</tr>
<tr>
<td style="text-align: center;">I. 10.7</td>
<td style="text-align: center;">$m=\frac{m_{0}}{\sqrt{1-\frac{x_{2}^{2}}{c^{2}}}}$</td>
<td style="text-align: center;">$10^{-4}$</td>
<td style="text-align: center;">$10^{-2}$</td>
</tr>
<tr>
<td style="text-align: center;">I.11.19</td>
<td style="text-align: center;">$A=x_{1} y_{1}+x_{2} y_{2}+x_{3} y_{3}$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.12.1</td>
<td style="text-align: center;">$F=\mu N_{n}$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.12.1a</td>
<td style="text-align: center;">$K=\frac{1}{2} m\left(v^{2}+u^{2}+w^{2}\right)$</td>
<td style="text-align: center;">$10^{-4}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.12.2</td>
<td style="text-align: center;">$F=\frac{q_{1} q_{2}}{4 \pi c c^{2}}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.12.4</td>
<td style="text-align: center;">$U=\frac{q_{1}}{4 \pi c c^{2}}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.12.5</td>
<td style="text-align: center;">$F=q_{2} E_{f}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.12.11</td>
<td style="text-align: center;">$F=q\left(E_{f}+B v \sin \theta\right)$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.13.12</td>
<td style="text-align: center;">$U=G m_{1} m_{2}\left(\frac{1}{r_{2}}-\frac{1}{r_{1}}\right)$</td>
<td style="text-align: center;">$10^{-4}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.14.3</td>
<td style="text-align: center;">$U=m g z$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.14.4</td>
<td style="text-align: center;">$U=\frac{k_{z p r i n g} \sigma^{2}}{2}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.15.3x</td>
<td style="text-align: center;">$x_{1}=\frac{\theta}{2 \pi} \frac{1}{\sqrt{1-\psi^{2} / c^{2}}}$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-3}$</td>
</tr>
<tr>
<td style="text-align: center;">I.15.3t</td>
<td style="text-align: center;">$t_{1}=\frac{1-\alpha e / c^{2}}{\sqrt{1-u^{2} / c^{2}}}$</td>
<td style="text-align: center;">$10^{-4}$</td>
<td style="text-align: center;">$10^{-3}$</td>
</tr>
<tr>
<td style="text-align: center;">I.15.1</td>
<td style="text-align: center;">$p=\frac{m_{0} v}{\sqrt{1-v^{2} / c^{2}}}$</td>
<td style="text-align: center;">$10^{-4}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.16.6</td>
<td style="text-align: center;">$v_{1}=\frac{u+c}{1+u v / c^{2}}$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-2}$</td>
</tr>
<tr>
<td style="text-align: center;">I.18.4</td>
<td style="text-align: center;">$r=\frac{m_{1} r_{1}+m_{2} r_{2}}{m_{1}+m_{2}}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.18.12</td>
<td style="text-align: center;">$\tau=r F \sin \theta$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.18.14</td>
<td style="text-align: center;">$L=m r v \sin \theta$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.24.6</td>
<td style="text-align: center;">$E=\frac{1}{4} m\left(\omega^{2}+\omega_{0}^{2}\right) x^{2}$</td>
<td style="text-align: center;">$10^{-4}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.25.13</td>
<td style="text-align: center;">$V_{e}=\frac{q}{L}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.26.2</td>
<td style="text-align: center;">$\theta_{1}=\arcsin \left(n \sin \theta_{2}\right)$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.27.6</td>
<td style="text-align: center;">$f_{f}=\frac{1}{\frac{1}{d_{1}}+\frac{u}{d_{2}}}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.29.4</td>
<td style="text-align: center;">$k=\frac{\omega}{2}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.29.16</td>
<td style="text-align: center;">$x=\sqrt{x_{1}^{2}+x_{2}^{2}-2 x_{1} x_{2} \cos \left(\theta_{1}-\theta_{2}\right)}$</td>
<td style="text-align: center;">$10^{-4}$</td>
<td style="text-align: center;">$10^{-3}$</td>
</tr>
<tr>
<td style="text-align: center;">I.30.3</td>
<td style="text-align: center;">$I_{<em>}=I_{</em>} \frac{\sin (\alpha \theta / 2)}{\sin (\theta / 2)}$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-3}$</td>
</tr>
<tr>
<td style="text-align: center;">I.30.5</td>
<td style="text-align: center;">$\theta=\arcsin \left(\frac{4}{n d}\right)$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.32.5</td>
<td style="text-align: center;">$P=\frac{q^{2} \sigma^{2}}{6 \pi c^{2}}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.32.17</td>
<td style="text-align: center;">$P=\left(\frac{1}{2} e c E_{f}^{2}\right)\left(8 \pi r^{2} / 3\right)\left(\omega^{4} /\left(\omega^{2}-\omega_{0}^{2}\right)^{2}\right)$</td>
<td style="text-align: center;">$10^{-4}$</td>
<td style="text-align: center;">$10^{-3}$</td>
</tr>
<tr>
<td style="text-align: center;">I.34.8</td>
<td style="text-align: center;">$\omega=\frac{q c B}{\pi}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.34.10</td>
<td style="text-align: center;">$\omega=\frac{1+v / c}{1-v / c} \omega_{0}$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-2}$</td>
</tr>
<tr>
<td style="text-align: center;">I.34.14</td>
<td style="text-align: center;">$\omega=\frac{1+v / c}{\sqrt{1-v^{2} / c^{2}}} \omega_{0}$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-3}$</td>
</tr>
<tr>
<td style="text-align: center;">I.34.27</td>
<td style="text-align: center;">$E=\hbar \omega$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.37.4</td>
<td style="text-align: center;">$I_{*}=I_{1}+I_{2}+2 \sqrt{I_{1} I_{2}} \cos \delta$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-2}$</td>
</tr>
<tr>
<td style="text-align: center;">I.38.12</td>
<td style="text-align: center;">$r=\frac{4 \pi e k^{2}}{3 \pi r}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.39.10</td>
<td style="text-align: center;">$E=\frac{3}{5} p_{F} V$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.39.11</td>
<td style="text-align: center;">$E=\frac{1}{c-1} p_{F} V$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.39.22</td>
<td style="text-align: center;">$P_{F}=\frac{n k_{b} T}{V}$</td>
<td style="text-align: center;">$10^{-4}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.40.1</td>
<td style="text-align: center;">$n=n_{0} e^{-\frac{\hbar \omega \sigma}{k_{b} T}}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.41.16</td>
<td style="text-align: center;">$L_{r a d}=\frac{\hbar \omega^{3}}{\pi^{2} c^{2}\left(\kappa^{2} k_{b} T-1\right)}$</td>
<td style="text-align: center;">$10^{-5}$</td>
<td style="text-align: center;">$10^{-4}$</td>
</tr>
<tr>
<td style="text-align: center;">I.43.16</td>
<td style="text-align: center;">$v=\frac{\mu_{d} c_{1} i_{1} q V_{c}}{T}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.43.31</td>
<td style="text-align: center;">$D=\mu_{e} k_{b} T$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.43.43</td>
<td style="text-align: center;">$\kappa=\frac{1}{c-1} \frac{\hbar \omega}{A}$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.44.4</td>
<td style="text-align: center;">$E=n k_{b} T \ln \left(\frac{V_{2}}{V_{1}}\right)$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.47.23</td>
<td style="text-align: center;">$c=\sqrt{\frac{\pi e c}{\mu}}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">I.48.2</td>
<td style="text-align: center;">$E=\frac{m c^{2}}{\sqrt{1-v^{2} / c^{2}}}$</td>
<td style="text-align: center;">$10^{-5}$</td>
<td style="text-align: center;">$10^{-3}$</td>
</tr>
<tr>
<td style="text-align: center;">I.50.26</td>
<td style="text-align: center;">$x=x_{1}[\cos (\omega t)+\alpha \cos (\omega t)^{2}]$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
</tbody>
</table>
<p>Table 7: Tested Equations, part 1</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Feynman eq.</th>
<th style="text-align: center;">Equation</th>
<th style="text-align: center;">Old Noise tolerance</th>
<th style="text-align: center;">New Noise tolerance</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">II.2.42</td>
<td style="text-align: center;">$\mathrm{P}=\frac{\kappa\left(T_{2}-T_{1}\right) A}{}$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">II.3.24</td>
<td style="text-align: center;">$F_{E}=\frac{p^{2}}{4 \pi r^{2}}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">II.4.23</td>
<td style="text-align: center;">$V_{e}=\frac{q}{4 \pi e r}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">II.6.11</td>
<td style="text-align: center;">$V_{e}=\frac{1}{4 \pi e} \frac{p_{d} \cos (\theta)}{p^{2}}$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">II.6.15a</td>
<td style="text-align: center;">$E_{f}=\frac{3}{4 \pi e} \frac{E d^{2}}{r^{2}} \sqrt{x^{2}+y^{2}}$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-2}$</td>
</tr>
<tr>
<td style="text-align: center;">II.6.15b</td>
<td style="text-align: center;">$E_{f}=\frac{3}{4 \pi e} \frac{p_{d}}{r^{2}} \cos \theta \sin \theta$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-2}$</td>
</tr>
<tr>
<td style="text-align: center;">II.8.7</td>
<td style="text-align: center;">$E=\frac{3}{5} \frac{q^{2}}{4 \pi e d}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">II.8.31</td>
<td style="text-align: center;">$E_{d e n}=\frac{\epsilon E_{f}^{2}}{2}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">II.10.9</td>
<td style="text-align: center;">$E_{f}=\frac{\sigma_{d e n}}{r} \frac{1}{1+\chi}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">II.11.3</td>
<td style="text-align: center;">$x=\frac{q E_{f}}{m\left(\omega_{0}^{2}-\omega^{2}\right)}$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-2}$</td>
</tr>
<tr>
<td style="text-align: center;">II.11.7</td>
<td style="text-align: center;">$n=n_{0}\left(1+\frac{p_{d} E_{f} \cos \theta}{k_{b} T}\right)$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">II.11.20</td>
<td style="text-align: center;">$P_{*}=\frac{n_{0} p_{d}^{2} E_{f}}{3 k_{b} T}$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">II.11.27</td>
<td style="text-align: center;">$P_{*}=\frac{n_{0}}{1-\alpha / 3} \epsilon E_{f}$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">II.11.28</td>
<td style="text-align: center;">$\theta=1+\frac{n \alpha}{1-(\alpha \alpha / 3)}$</td>
<td style="text-align: center;">$10^{-4}$</td>
<td style="text-align: center;">$10^{-2}$</td>
</tr>
<tr>
<td style="text-align: center;">II.13.17</td>
<td style="text-align: center;">$B=\frac{1}{4 \pi e \rho_{c} T} \frac{2 I}{T}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">II.13.23</td>
<td style="text-align: center;">$\rho_{c}=\frac{\rho_{c_{0}}}{\sqrt{1-v^{2} / c^{2}}}$</td>
<td style="text-align: center;">$10^{-4}$</td>
<td style="text-align: center;">$10^{-2}$</td>
</tr>
<tr>
<td style="text-align: center;">II.13.24</td>
<td style="text-align: center;">$j=\frac{\rho_{c_{0}} v}{\sqrt{1-v^{2} / c^{2}}}$</td>
<td style="text-align: center;">$10^{-4}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">II.15.4</td>
<td style="text-align: center;">$E=-\mu_{M} B \cos \theta$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">II.15.5</td>
<td style="text-align: center;">$E=-p_{d} E_{f} \cos \theta$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">II.21.32</td>
<td style="text-align: center;">$V_{e}=\frac{q}{4 \pi e r(1-v / c)}$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">II.24.17</td>
<td style="text-align: center;">$k=\sqrt{\frac{\omega^{2}}{c^{2}}-\frac{x^{2}}{d^{2}}}$</td>
<td style="text-align: center;">$10^{-5}$</td>
<td style="text-align: center;">$10^{-2}$</td>
</tr>
<tr>
<td style="text-align: center;">II.27.16</td>
<td style="text-align: center;">$F_{E}=\epsilon c E_{f}^{2}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">II.27.18</td>
<td style="text-align: center;">$E_{d e n}=\epsilon E_{f}^{2}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">II.34.2a</td>
<td style="text-align: center;">$I=\frac{q v}{2 \pi e}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">II.34.2</td>
<td style="text-align: center;">$\mu_{M}=\frac{q v r}{2}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">II.34.11</td>
<td style="text-align: center;">$\omega=\frac{g_{c} q B}{2 m}$</td>
<td style="text-align: center;">$10^{-4}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">II.34.29a</td>
<td style="text-align: center;">$\mu_{M}=\frac{q h}{4 \pi m}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">II.34.29b</td>
<td style="text-align: center;">$E=\frac{g_{c} \mu_{M} B J_{z}}{h}$</td>
<td style="text-align: center;">$10^{-4}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">II.35.18</td>
<td style="text-align: center;">$n=\frac{n_{0}}{\exp \left(\mu_{m} B /\left(k_{b} T\right)\right)+\exp \left(-\mu_{m} B /\left(k_{b} T\right)\right)}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-2}$</td>
</tr>
<tr>
<td style="text-align: center;">II.35.21</td>
<td style="text-align: center;">$M=n_{p} \mu_{M} \tanh \left(\frac{\mu_{M} B}{k_{b} T}\right)$</td>
<td style="text-align: center;">$10^{-4}$</td>
<td style="text-align: center;">$10^{-4}$</td>
</tr>
<tr>
<td style="text-align: center;">II.36.38</td>
<td style="text-align: center;">$f=\frac{\mu_{m} B}{k_{b} T}+\frac{\mu_{m} \alpha M}{\epsilon c^{2} k_{b} T}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">II.37.1</td>
<td style="text-align: center;">$E=\mu_{M}(1+\chi) B$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">II.38.3</td>
<td style="text-align: center;">$F=\frac{1 A x}{T}$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">II.38.14</td>
<td style="text-align: center;">$\mu_{S}=\frac{d}{2(1+\sigma)}$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">III.4.32</td>
<td style="text-align: center;">$n=\frac{1}{e^{\frac{1}{k_{b} T}}-1}$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-2}$</td>
</tr>
<tr>
<td style="text-align: center;">III.4.33</td>
<td style="text-align: center;">$E=\frac{h \omega}{e^{\frac{2}{k_{b} T}}-1}$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-3}$</td>
</tr>
<tr>
<td style="text-align: center;">III.7.38</td>
<td style="text-align: center;">$\omega=\frac{2 \mu_{M} B}{h}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">III.8.54</td>
<td style="text-align: center;">$p_{\gamma}=\frac{\sin \left(\frac{E t}{h}\right)^{2}}{h}$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-3}$</td>
</tr>
<tr>
<td style="text-align: center;">III.9.52</td>
<td style="text-align: center;">$p_{\gamma}=\frac{\frac{\nu_{d} E_{f} V}{h} \sin \left(\left(\omega-\omega_{0}\right) t / 2\right)^{2}}{\left(\left(\omega-\omega_{0}\right) t / 2\right)^{2}}$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">III.10.19</td>
<td style="text-align: center;">$E=\mu_{M} \sqrt{B_{x}^{2}+B_{y}^{2}+B_{z}^{2}}$</td>
<td style="text-align: center;">$10^{-4}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">III.12.43</td>
<td style="text-align: center;">$L=n \hbar$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">III.13.18</td>
<td style="text-align: center;">$v=\frac{2 E d^{2} k}{h}$</td>
<td style="text-align: center;">$10^{-4}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">III.14.14</td>
<td style="text-align: center;">$I=I_{0}\left(e^{\frac{2 V_{c}}{k_{b} T}}-1\right)$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">III.15.12</td>
<td style="text-align: center;">$E=2 U(1-\cos (k d))$</td>
<td style="text-align: center;">$10^{-4}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">III.15.14</td>
<td style="text-align: center;">$m=\frac{k^{2}}{2 E d^{2}}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">III.15.27</td>
<td style="text-align: center;">$k=\frac{2 \pi \alpha}{n d}$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">III.17.37</td>
<td style="text-align: center;">$f=\beta(1+\alpha \cos \theta)$</td>
<td style="text-align: center;">$10^{-3}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
<tr>
<td style="text-align: center;">III.19.51</td>
<td style="text-align: center;">$E=\frac{-m q^{4}}{2(4 \pi e)^{2} h^{2}} \frac{1}{n^{2}}$</td>
<td style="text-align: center;">$10^{-5}$</td>
<td style="text-align: center;">$10^{-2}$</td>
</tr>
<tr>
<td style="text-align: center;">III.21.20</td>
<td style="text-align: center;">$j=\frac{-\rho_{c_{0}} q A_{o s c}}{m}$</td>
<td style="text-align: center;">$10^{-2}$</td>
<td style="text-align: center;">$10^{-1}$</td>
</tr>
</tbody>
</table>
<p>Table 8: Tested Equations, part 2.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{1}$ Our code is can be installed by typing pip install aifeynman and is also available at https://ai-feynman. readthedocs.io.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>