<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-3356 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-3356</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-3356</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-77.html">extraction-schema-77</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models solving puzzle games that require spatial knowledge (such as Sudoku), including details about the models, the puzzles, the methods used, performance, and any analysis of how the models solve these tasks.</div>
                <p><strong>Paper ID:</strong> paper-2ad3b9d7f03a6382fa3577a285d62946a5703820</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/2ad3b9d7f03a6382fa3577a285d62946a5703820" target="_blank">Learning to Automatically Solve Logic Grid Puzzles</a></p>
                <p><strong>Paper Venue:</strong> Conference on Empirical Methods in Natural Language Processing</p>
                <p><strong>Paper TL;DR:</strong> This system, LOGICIA, is the first learning system that can solve logic grid puzzles described in natural language in a fully automated manner and learns to automatically translate a clue with 81.11% accuracy and is able to solve 71% of the problems of a corpus.</p>
                <p><strong>Paper Abstract:</strong> Logic grid puzzle is a genre of logic puzzles in which we are given (in a natural language) a scenario, the object to be deduced and certain clues. The reader has to figure out the solution using the clues provided and some generic domain constraints. In this paper, we present a system, LOGICIA, that takes a logic grid puzzle and the set of elements in the puzzle and tries to solve it by translating it to the knowledge representation and reasoning language of Answer Set Programming (ASP) and then using an ASP solver. The translation to ASP involves extraction of entities and their relations from the clues. For that we use a novel learning based approach which uses varied supervision, including the entities present in a clue and the expected representation of a clue in ASP. Our system, LOGICIA, learns to automatically translate a clue with 81.11% accuracy and is able to solve 71% of the problems of a corpus. This is the first learning system that can solve logic grid puzzles described in natural language in a fully automated manner. The code and the data will be made publicly available at http://bioai.lab . asu.edu/logicgridpuzzles.</p>
                <p><strong>Cost:</strong> 0.004</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <p class="empty-note">No extracted data.</p>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <p class="empty-note">No potentially relevant new papers extracted.</p>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-3356",
    "paper_id": "paper-2ad3b9d7f03a6382fa3577a285d62946a5703820",
    "extraction_schema_id": "extraction-schema-77",
    "extracted_data": [],
    "potentially_relevant_new_papers": [],
    "cost": 0.0038269999999999997,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Learning to Automatically Solve Logic Grid Puzzles</h1>
<p>Arindam Mitra<br>SCIDSE<br>Arizona State University<br>amitra7@asu.edu</p>
<h2>Chitta Baral SCIDSE<br>Arizona State University<br>chitta@asu.edu</h2>
<h4>Abstract</h4>
<p>Logic grid puzzle is a genre of logic puzzles in which we are given (in a natural language) a scenario, the object to be deduced and certain clues. The reader has to figure out the solution using the clues provided and some generic domain constraints. In this paper, we present a system, LOGICIA, that takes a logic grid puzzle and the set of elements in the puzzle and tries to solve it by translating it to the knowledge representation and reasoning language of Answer Set Programming (ASP) and then using an ASP solver. The translation to ASP involves extraction of entities and their relations from the clues. For that we use a novel learning based approach which uses varied supervision, including the entities present in a clue and the expected representation of a clue in ASP. Our system, LOGICIA, learns to automatically translate a clue with $81.11 \%$ accuracy and is able to solve $71 \%$ of the problems of a corpus. This is the first learning system that can solve logic grid puzzles described in natural language in a fully automated manner. The code and the data will be made publicly available at http://bioai.lab. asu.edu/logicgridpuzzles.</p>
<h2>1 Introduction</h2>
<p>Understanding natural language to solve problems be it algebraic word problems (Kushman et al., 2014; Hosseini et al., 2014) or questions from biology texts (Berant et al., 2014; Kim et al., 2011), has attracted a lot of research interest over the past few decades. For NLP, these problems are of particular interest as they are concise, yet rich in information. In this paper, we attempt to solve another problem of this kind, known as Logic Grid</p>
<p>Puzzle. Problem. 1 shows an example of the same. Puzzle problems in the same spirit as the previously mentioned science problems, do not restrict the vocabulary; they use everyday language and have diverse background stories. The puzzle problems, however, are unique in their requirement of high precision understanding of the text. For a puzzle problem, the solution is never in the text and requires involved reasoning. Moreover, one needs to correctly understand each of the given clues to successfully solve a problem. Another interesting property is that only a small core of the world knowledge, noticeably spatial, temporal and knowledge related to numbers, is crucial to solve these problems.</p>
<h2>PROBLEM . 1 A LOGIC GRID PUZZLE</h2>
<p>Waterford Spa had a full appointment calendar booked today. Help Janice figure out the schedule by matching each masseuse to her client, and determine the total price for each.</p>
<ol>
<li>Hannah paid more than Teri's client.</li>
<li>Freda paid 20 dollars more than Lynda's client.</li>
<li>Hannah paid 10 dollars less than Nancy's client.</li>
<li>Nancy's client, Hannah and Ginger were all different clients.</li>
<li>Hannah was either the person who paid $\$ 180$ or Lynda's client.</li>
</ol>
<p>Clients: Aimee, Ginger, Freda, Hannah. Prices: $\$ 150, \$ 160, \$ 170, \$ 180$.
Masseuses: Lynda, Nancy, Tery, Whitney.</p>
<p>A logic grid puzzle contains a set of categories and an equal number of elements in each category.</p>
<p>And the goal is to find out which elements are linked together based on a series of given clues. Each element is used only once. Each puzzle has a unique solution and can be solved using logical reasoning. A logic grid puzzle is called a $(n, m)$ puzzle if it contains $n$ categories and each category has $m$ elements. For the example in Problem.1, there are three categories, namely clients, prices, masseuses and each category has four elements which are shown in the respective columns. A total of five clues are given in free text and the goal is to find the members of the four tuples, where each tuple shall contain exactly one element from each category such that all the members in a tuple are linked together.</p>
<p>To solve such a puzzle problem, it is crucial to understand the clues (for example, "Hannah paid more than Teri's client."). Each clue talks about a set of entities (for example, "Hannah", "client", "Terry") and their relations ("a greater-than relation between Hannah and the client of Terry on the basis of payment"). Our system, LOGICIA, learns to discover these entities and the underlying semantics of the relations that exist between them. Once the relations are discovered, a pair of Answer Set Programming (ASP) (Baral, 2003) rules are created. The reasoning module takes these ASP rules as input and finds a group configuration that satisfies all the clues. LOGICIA has "knowledge" about a fixed set of predicates which models different relations that hold between entities in a puzzle world. Clues in the puzzle text that are converted into ASP rules, use these predicates as building blocks. In this research, our goal is to build a system which can automatically do this conversion and then reason over it to find the solution. The set of predicates that the reasoning model is aware of is not sufficient to represent all logic grid puzzles. The family of logic grid puzzles is broad and contains variety of clues. Our future work involves dealing with such a diverse set of relations. In this work we assume that the relations in Table 1 are sufficient to represent the clues. Following are some examples of clues that cannot be modeled using the predicates in Table 1.</p>
<ul>
<li>Esther's brother's seat is at one end of the block of seven.</li>
<li>The writer of Lifetime Ambition has a first name with more letters than that of the tennis star.</li>
<li>Edward was two places behind Salim in one of the lines, both being in odd-numbered positions.</li>
<li>Performers who finished in the top three places, in no particular order, are Tanya, the person who performed the fox trot, and the one who performed the waltz.</li>
</ul>
<p>The rest of the paper is organized as follows: in section 2, we describe the representation of a puzzle problem in ASP and delineate how it helps in reasoning; in section 3, we present our novel method for learning to automatically translate a logic problem described in natural language to its ASP counterpart. In section 4, we describe the related works. In section 5, we discuss the detailed experimental evaluation of our system. Finally, section 6 concludes our paper.</p>
<h2>2 Puzzle Representation</h2>
<p>Answer Set Programming (ASP) (Baral, 2003; Lifschitz, 1999; Gelfond and Lifschitz, 1991) has been used to represent a puzzle and reason over it. This choice is facilitated by the two important reasons: 1) non-monotonic reasoning may occur in a puzzle (Nagy and Allwein, 2004) and 2) ASP constructs greatly simplify the reasoning module, as we will see in this section. We now briefly describe a part of ASP. Our discussion is informal. For a detailed account of the language, readers are referred to (Baral, 2003).</p>
<h3>2.1 Answer Set Programming</h3>
<p>An answer set program is a collection of rules of the form,
$L_{0}|\ldots| L_{k}:-L_{k+1}, \ldots, L_{m}$, not $L_{m+1}, \ldots$, not $L_{n}$
where each of the $L_{i}$ 's is a literal in the sense of a classical logic. Intuitively, the above rule means that if $L_{k+1}, \ldots, L_{m}$ are to be true and if $L_{m+1}, \ldots, L_{n}$ can be safely assumed to be false then at least one of $L_{0}, \ldots, L_{k}$ must be true. The left-hand side of an ASP rule is called the head and the right-hand side is called the body. A rule with no head is often referred to as a constraint. A rule with empty body is referred to as a $f a c t$ and written as,</p>
<p>$$
L_{0}\left|L_{1}\right| \ldots \mid L_{k}
$$</p>
<h2>Example</h2>
<p>$$
\text { fly(X) :- bird(X), not } \operatorname{ab}(\mathrm{X})
$$</p>
<p>The above program represents the knowledge that "Most birds fly". If we add the following rule (fact) to the program,</p>
<p>$$
\operatorname{bird}(\text { penguin })
$$</p>
<p>the answer set of the program will contain the belief that penguins can fly, {bird(penguin), fly(penguin)}. However, adding one more fact, ' $a b($ penguin).', to convey that the penguin is an abnormal bird, will change the belief that the penguin can fly and correspondingly the answer set, ${\operatorname{bird}($ penguin $), a b($ penguin $})}$, will not contain the fact, fly(penguin).</p>
<h2>Choice Rule</h2>
<p>$$
m{p(X): q(X)} n:-L_{1}, \ldots, L_{k}, \ldots, \text { not } L_{n}
$$</p>
<p>Rules of this type allow inclusion in the program's answer sets of arbitrary collections $S$ of atoms of the form $p(t)$ such that, $m \leq|S| \leq n$ and if $p(t) \in$ $S$ then $q(t)$ belongs to the corresponding answer set.</p>
<h3>2.2 Representing Puzzle Entities</h3>
<p>A $(m, n)$-puzzle problem contains $m$ categories and $n$ elements in each category. The term 'puzzle entity' is used to refer to any of them. Each category is assigned an unique index, denoted by the predicate cindex $/ 1$ (the number after the ' $/$ ' denotes the arity of the predicate). The predicate etype $/ 2$ captures this association. Each element is represented, by the element/2 predicate which connects a category index to its element. The predicate eindex $/ 1$, denotes the tuple indices. The following blocks of code shows the representation of the entities for the puzzle in Problem.1.</p>
<div class="codehilite"><pre><span></span><code><span class="nx">cindex</span><span class="p">(</span><span class="mi">1</span><span class="o">...</span><span class="mi">3</span><span class="p">).</span>
<span class="nx">eindex</span><span class="p">(</span><span class="mi">1</span><span class="o">...</span><span class="mi">4</span><span class="p">).</span>
<span class="nx">etype</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nx">clients</span><span class="p">).</span>
<span class="nx">etype</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="nx">prices</span><span class="p">).</span>
<span class="nx">etype</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="nx">masseuses</span><span class="p">).</span>
<span class="nx">element</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nx">aimee</span><span class="p">;;</span><span class="mi">1</span><span class="p">,</span><span class="nx">ginger</span><span class="p">).</span>
<span class="nx">element</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nx">freda</span><span class="p">;;</span><span class="mi">1</span><span class="p">,</span><span class="nx">hannah</span><span class="p">).</span>
<span class="nx">element</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">150</span><span class="p">;;</span><span class="mi">2</span><span class="p">,</span><span class="mi">160</span><span class="p">).</span>
<span class="nx">element</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">170</span><span class="p">;;</span><span class="mi">2</span><span class="p">,</span><span class="mi">180</span><span class="p">).</span>
<span class="nx">element</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="nx">lynda</span><span class="p">;;</span><span class="mi">3</span><span class="p">,</span><span class="nx">nancy</span><span class="p">).</span>
<span class="nx">element</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="nx">teri</span><span class="p">;;</span><span class="mi">3</span><span class="p">,</span><span class="nx">whitney</span><span class="p">).</span>
</code></pre></div>

<h3>2.3 Representing Solution</h3>
<p>Solution to a logic grid puzzle is a set of tuples containing related elements. The tuple/3 predicate captures this tuple membership information of the elements. For example, the fact, tuple (2, 1, aimee), states that the element aimee from the category with index 1 is in the tuple 2 . The $\mathrm{rel} / \mathrm{m}$ predicate captures all the elements in a tuple for a $(m, n)$-puzzle and is defined using the tuple/3 predicate.</p>
<h3>2.4 Domain Constraints</h3>
<p>In the proposed approach, the logic grid puzzle problem is solved as a constraint satisfaction problem. Given a puzzle problem the goal is to enumerate over all possible configurations of tuple/3, and select the one which does not violate the constraints specified in the clues. However, 1) each tuple in a logic grid puzzle will contain exactly one element from each category and 2) an element will belong to exactly one tuple. These constraints come from the specification of a puzzle problem and will hold irrespective of the problem instance. Following blocks of code show an elegant representation of these domain constraints in ASP along with the enumeration.</p>
<div class="codehilite"><pre><span></span><code><span class="nf">%enumerate</span><span class="w"> </span><span class="n">over</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">tuple</span>
<span class="nf">%assignments</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">constraint</span><span class="err">#</span><span class="mi">1</span>
<span class="mi">1</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">tuple</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">Cat</span><span class="p">,</span><span class="n">Elem</span><span class="p">)</span><span class="o">:</span>
<span class="w">    </span><span class="n">element</span><span class="w"> </span><span class="p">(</span><span class="n">Cat</span><span class="p">,</span><span class="n">Elem</span><span class="p">)</span>
<span class="p">}</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:-</span><span class="w"> </span><span class="n">cindex</span><span class="p">(</span><span class="n">Cat</span><span class="p">),</span>
<span class="w">        </span><span class="n">eindex</span><span class="p">(</span><span class="n">G</span><span class="p">).</span>
<span class="nf">%domain</span><span class="w"> </span><span class="n">constraint</span><span class="err">#</span><span class="mi">2</span>
<span class="o">:-</span><span class="n">tuple</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span><span class="n">Cat</span><span class="p">,</span><span class="n">Elem</span><span class="p">),</span>
<span class="w">    </span><span class="n">tuple</span><span class="p">(</span><span class="n">G2</span><span class="p">,</span><span class="n">Cat</span><span class="p">,</span><span class="n">Elem</span><span class="p">),</span>
<span class="w">    </span><span class="n">G1</span><span class="o">!=</span><span class="n">G2</span><span class="p">.</span>
</code></pre></div>

<h3>2.5 Representing clues</h3>
<p>Each clue describes some entities and the relations that hold between them. In its simplest form, the relations will suggest if the entities are linked together or not. However, the underlying semantics of such relations can be deep such as the one in clue 5 of Problem.1. There are different ways to express the same relation that holds between entities. For example, in Problem.1, the possessive relation has been used to express the linking between clients and masseuses; and the word paid</p>
<p>expresses the linking between the clients and the prices. Depending on the puzzles the phrases that are used to express the relations will vary and it is crucial to identify their underlying semantics to solve the problems in systematic way.</p>
<p>In the current version, the reasoning module has knowledge of a selected set of relations and the translation module tries to represent the clue as a conjunction of these relations. All these relations and their underlying meanings are described in table 1. In this subsection, we describe the representation of a clue in terms of these relations in ASP and show how it is used by the reasoning module. In the next section, we present our approach to automate this translation.</p>
<p>Let us consider the clues and their representation from Problem.1:
[1] Hannah paid more than Teri's client.</p>
<div class="codehilite"><pre><span></span><code>clue1 <span class="o">:-</span>
    greaterThan(hannah,<span class="m">1</span>,<span class="nv">X</span>,<span class="m">1</span>,<span class="m">2</span>),
    sameTuple(<span class="nv">X</span>,<span class="m">1</span>,teri,<span class="m">3</span>).
<span class="p">:- </span><span class="err">not </span>clue1.
</code></pre></div>

<p>The first rule clue 1 evaluates to true (will be in the answer set) if the element from category 1 with value hannah is linked to some element from category 2 which has a higher value than the element from its own category which is linked to an element from category 1 which is linked to teri from category 3 . Since the desired solution must satisfy the relations described in the clue, the second ASP rule is added. A rule of this form that does not have a head is known as a constraint and the program must satisfy it to have an answer set. As the reasoning module enumerates over all possible configurations, in some cases the clue 1 will not hold and subsequently those branches will be pruned. Similar constraints will be added for all clues. In the below, we show some more examples. A configuration which satisfies all the clue constraints and the domain constraints described in the previous section, will be accepted as the solution to the puzzle.
[2] Nancy's client, Hannah and Ginger were all different clients.</p>
<div class="codehilite"><pre><span></span><code>clue4 <span class="o">:-</span>
    diffTuple(hannah,<span class="m">1</span>,ginger,<span class="m">1</span>),
    diffTuple(hannah,<span class="m">1</span>,<span class="nv">X</span>,<span class="m">1</span>),
    diffTuple(<span class="nv">X</span>,<span class="m">1</span>,ginger,<span class="m">1</span>),
    sameTuple ( <span class="k">}</span><span class="nv">X</span>,<span class="m">1</span>,<span class="o">\</span>mathrm<span class="k">{</span> nancy,<span class="m">3</span>).
<span class="p">:- </span><span class="err">not </span>clue4.
</code></pre></div>

<p>[3] Hannah was either the person who paid $\$ 180$ or Lynda's client.</p>
<div class="codehilite"><pre><span></span><code>clue5 <span class="o">:-</span>
    eitherOr(hannah,<span class="m">1</span>,<span class="nv">X</span>,<span class="m">1</span>,<span class="nv">Y</span>,<span class="m">1</span>),
    sameTuple ( <span class="k">}</span><span class="nv">X</span>,<span class="m">1</span>,<span class="m">180</span>,<span class="m">2</span>)
    sameTuple(<span class="nv">Y</span>,<span class="m">1</span>,lynda,<span class="m">3</span>).
<span class="p">:- </span>clue5.
</code></pre></div>

<h2>3 Learning Translation</h2>
<p>To automate the translation of a clue to the pair of ASP rules, the translation module needs to identify the entities that are present in the clue, their category and their value; and the underlying interpretations of all the relations that hold between them. Once all the relation instances $\left{R_{1}\left(\arg <em p__1="p_{1">{1}, \ldots, \arg </em>\left(\arg }}\right), \ldots, R_{q<em p__q="p_{q">{1}, \ldots, \arg </em>\right)\right}$, in the clue are identified, the ASP representation of the clue is generated in the following way:
clue : $-R_{1}\left(\arg }<em p__1="p_{1">{1} \ldots, \arg </em>\left(\arg }}\right), \ldots, R_{q<em p__q="p_{q">{1} \ldots, \arg </em>\right)$
The entity classification problem for logic grid puzzles poses several challenges. First, the existence of a wide variety in the set of entities. Entities can be names of objects, time related to some event, numbers, dates, currency, some form of ID etc. And it is not necessary that the entities in puzzles are nouns. It can be verbs, adjectives etc. Second and of paramount important, the "category" of a puzzle "element" is specific to a puzzle problem. Same element may have different category in different problems. Also, a constituent in a clue which refers to an entity in a particular problem may not refer to an entity in another problem. We formalize this problem in this section and propose one approach to solve the problem. Next, we discuss the method that is used to extract relations from clues. To the best of our knowledge, this type of entity classification problem has never been studied before.}</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Relation</th>
<th style="text-align: left;">Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">sameTuple(E1, C1, E2, C2)</td>
<td style="text-align: left;">States that two elements, (C1,E1) and (C2,E2) are in <br> the same tuple. The dictionary also contains the nega- <br> tion of it, diffTuple(E1, C1, E2, C2).</td>
</tr>
<tr>
<td style="text-align: left;">referrent(E1, C1, E2, C2)</td>
<td style="text-align: left;">States that the elements are identical.</td>
</tr>
<tr>
<td style="text-align: left;">posDiff(E1, C1, E2, C2, N1, NC1)</td>
<td style="text-align: left;">If (C1,E1) is related to (NC1,X1) and (E2,C2) is re- <br> lated to (NC1,X2), then difference(X1,X2)=N1. Sim- <br> ilarly the dictionary contains the predicate negDiff.</td>
</tr>
<tr>
<td style="text-align: left;">greaterThan(E1, C1, E2, C2, NC1)</td>
<td style="text-align: left;">Similar to posDiff however the difference(X1,X2) &gt; <br> 0. The dictionary also contains its opposite predicate <br> lessThan.</td>
</tr>
<tr>
<td style="text-align: left;">members(E1, C1, E2, C2,..., EN, CN)</td>
<td style="text-align: left;">All the elements are distinct and do not share a tuple.</td>
</tr>
<tr>
<td style="text-align: left;">eitherOr(E1, C1, E2, C2,..., EN, CN)</td>
<td style="text-align: left;">The first element is related to one of the last $N-1$ <br> elements. The last $N-1$ elements are assumed to be <br> different unless contradicts with other beliefs.</td>
</tr>
<tr>
<td style="text-align: left;">referrent22(E1, C1, E2, C2, E3, C3, E4, C4)</td>
<td style="text-align: left;">The first two elements are different and referring to <br> the last two elements.</td>
</tr>
</tbody>
</table>
<p>Table 1: Describes the various relations that are part of the reasoning module.</p>
<h3>3.1 Entity Classification</h3>
<p>The entity classification problem is defined as follows:</p>
<p>Problem description Given $m$ categories $C_{1}$, $\ldots, C_{m}$ and a text $T$, each category $C_{i}, 1 \leq i \leq m$, contains a collection of elements $E_{i}$ and an optional textual description $d_{i}$. The goal is to find the class information of all the constituents in the text $T$. Each category contributes two classes, where one of them represents the category itself and the other represents an instance of that category. Also, a constituent may not refer to any category or any instance of it, in that case the class of that constituent is null. So, there are a total $2 m+1$ classes and a constituent will take one value from them.</p>
<p>Example In the puzzle of Problem.1, there are 3 categories with, $C_{1}={$ Aimee, Freda, Ginger, Hannah $}, C_{2}={\$ 150, \$ 160, \$ 170, \$ 180}, C_{3}$ $={$ Lynda, Nancy, Terry, Whiteney $}$ and $d_{1}=$ "clients", $d_{2}=$ "prices", $d_{3}=$ "masseuses". The text $T$, is the concatenation of all clues. In the last clue, there are a total 5 entities, namely "Hannah", "person", "\$180", "Lydia","client" and the corresponding classes are "Instance of $C_{1}$ ", "Instance of $C_{1}$ ", "Instance of $C_{2}$ ", "Instance of $C_{3}$ " and "Instance of $C_{1}$ " respectively. The remaining constituents in that clue have the class value null. The constituent "clients" in the fourth clue refers to the category $C_{1}$.</p>
<p>Our approach We model the Entity Classification problem as a decoding query on Pairwise Markov Network (Koller and Friedman, 2009; Kindermann et al., 1980; Zhang et al., 2001). A pairwise Markov network over a graph $\mathcal{H}$, is associated with a set of node potentials $\left{\phi\left(X_{i}\right): i=\right.$ $1, \ldots, n}$ and a set of edge potentials $\left{\phi\left(X_{i}, X_{j}\right)\right.$ : $\left.\left(X_{i}, X_{j}\right) \in \mathcal{H}\right}$. Each node $X_{i} \in \mathcal{H}$, represents a random variable. Here, each $X_{i}$ can take value from the set ${1 \ldots 2 m+1}$, denoting the class of the corresponding constituent in the text $T$.</p>
<p>In our implementation, the node potential captures the chances of that node to be classified as one of the possible categories without being affected by the given text $T$. And the edge potentials captures hints from the context in $T$ for classification. After constructing the pairwise Markov network, a decoding query is issued to obtain the configuration that maximizes the joint probability distribution of the pairwise Markov network in consideration. The proposed approach is inspired by the following two observations: 1) to find the class of a constituent one needs some background knowledge; 2) however, background knowledge is not sufficient on its own, one also needs to understand the text to properly identify the class of each constituent. For example, let us consider the word "person" in clue 5 of Problem.1. Just skimming through the categories, one can discover that the word "person" is very unlikely to be a instance of the category "prices", which is from her knowledge about those constituents. However a proper</p>
<p>disambiguation may face an issue here as there are two different categories of human beings. To properly classify the word "person" it is necessary to go through the text.</p>
<p>The following paragraphs describe the construction of the grah $\mathcal{H}$, and the algorithm that is used in the computation of associated set of node potentials and edge potentials.</p>
<p>Construction of the graph While constructing the graph, we assign a label, $L$, to each edge in $\mathcal{H}$ which will be used in the edge potential computation. Let $\mathcal{D}<em 1="1">{\mathcal{G}}$ denotes the dependency graph of the text $T$ obtained from the Stanford dependency parser (Chen and Manning, 2014) and $\operatorname{dep}\left(v</em>$, is constructed as follows:}, v_{2}\right)$ denotes the grammatical relation between $\left(v_{1}, v_{2}\right)$ $\in \mathcal{D}_{\mathcal{G}}$. Then the graph, $\mathcal{H</p>
<ol>
<li>Create a node in $\mathcal{H}$ for each constituent $w_{j}$ in $T$ if $w_{j} \in \mathcal{D}_{\mathcal{G}}$.</li>
<li>Add an edge $\left(X_{i}, X_{j}\right)$ to $\mathcal{H}$ if the corresponding edge $\left(w_{p}, w_{q}\right) \in \mathcal{D}<em i="i">{\mathcal{G}} . \quad L\left(X</em>\right)$.}, X_{j}\right):=$ $\operatorname{dep}\left(w_{p}, w_{q</li>
<li>Add an edge between a pair of nodes $\left(X_{i}, X_{j}\right)$ if the corresponding words are synonyms. $L\left(X_{i}, X_{j}\right):=$ synonymy.</li>
<li>Create a node for each element and category specified in the puzzle and add an edge from them to others if the corresponding string descriptions are 'same'. In this case, the edges are labeled as exact_match.</li>
<li>If $\left(X_{i}, X_{j}\right) \in \mathcal{H}$ and $L\left(X_{i}, X_{j}\right)=$ exact_match and both of them are referring to a verb, then add more edges $\left(X_{i}^{\prime}, X_{j}^{\prime}\right)$ to $\mathcal{H}$ with label spatial_symmetry, where $L\left(X_{i}, X_{i}^{\prime}\right)=L\left(X_{j}, X_{j}^{\prime}\right)$.</li>
</ol>
<p>Determining Node potentials For each element in the $m$ category, a set of naive regular-expression based taggers are used to detect it's type (For example, "am-pm time"). Each element type maps to a WordNet (Miller, 1995) representative (For example, "time_unit#n"). For each constituent $w$ a similarity score, $\operatorname{sim}(w, c)$, is calculated to each class $c \in{1 \ldots 2 m+1}$, in the following way:
-Class $c$ is denoting instance of some category $C_{i}$ Similarity scores are computed between the textual description of the constituent to both the WordNet representative of $E_{i}$ and the textual
description $d_{i}$ using the HSO WordNet similarity algorithm (Hirst and St-Onge, 1998). The similarity score, $\operatorname{sim}(w, c)$, is chosen to be the maximum of them.
-Class $c$ is denoting a category $C_{i}: \operatorname{sim}(w, c)$ is assigned the value of HSO Similarity between the textual description and $d_{i}$.
-Class $c$ is null : In this case similarity is calculated using the following formula:</p>
<p>$$
\operatorname{sim}(w, \text { null })=\operatorname{MAX}<em _neq="\neq" c="c" l="l" n="n" u="u">{H S O}-\max </em>(w, c)
$$} \operatorname{sim</p>
<p>where $M A X_{H S O}$ denotes the maximum similarity score returned by HSO algorithm, which is 16.</p>
<p>Node potential for each node $X_{i} \in \mathcal{H}$, corresponding to the constituent $w_{j}$, are then calculated by,</p>
<p>$$
\phi\left(X_{i}=c\right)=1+\operatorname{sim}\left(w_{j}, c\right), \forall c
$$</p>
<p>Determining Edge potentials For each edge in the graph $H$, the edge potential, $\phi\left(X_{i}, X_{j}\right)$ is calculated using the following formula,</p>
<p>$$
\begin{gathered}
\phi\left(X_{i}=c_{1}, X_{j}=c_{2}\right)= \
1+ \begin{cases}P\left(X_{i}=X_{j} \mid L\left(X_{i}, X_{j}\right)\right), &amp; \text { if } c_{1}=c_{2} \
P\left(X_{i} \neq X_{j} \mid L\left(X_{i}, X_{j}\right)\right), &amp; \text { otherwise }\end{cases}
\end{gathered}
$$</p>
<p>In the training phase, each entity in a clue is tagged with its respective class. The probability values are then calculated from the training dataset using simple count.</p>
<h3>3.2 Learning To Extract Relations</h3>
<p>The goal here is to identify all the relations $R\left(\arg <em p="p">{1}, \ldots, \arg </em>\right)$ that are present in a clue, where each relation belongs to the logical vocabulary described in Table 1 . This problem is known as Complex relation extraction (McDonald et al., 2005; Bach and Badaskar, 2007; Fundel et al., 2007; Zhou et al., 2014). The common approach for solving the Complex relation extraction problem is to first find the relation between each pair of entities and then discover the complex relations from binary ones using the definition of each relation.</p>
<p>Figure 1 depicts the scenario. The goal is to identify the relation $\operatorname{possDiff}(E 1, E 2, E 3)$, where $E 1, E 2, E 3$ are constituents having a nonnull class value. However instead of identifying $\operatorname{posDiff}(E 1, E 2, E 3)$ directly, first the relation</p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Binary representation of the relation possDiff
between each pair of entities will be identified. If the relations $\left{\right.$ posDiff $<em 1="1">{a r g</em>\right)$, posDiff $}-a r g_{2}}\left(E_{1}, E_{2<em 2="2">{a r g</em>\right), \quad$ posDiff $}-a r g_{3}}\left(E_{2}, E_{3<em 1="1">{a r g</em>(E 1, E 2, E 3)$ holds. In a similar manner, a set of total 39 binary relations are created for all the relations described in Table 1.}-a r g_{3}}$ $\left.\left(E_{1}, E_{3}\right)\right}$ are identified, the extraction module will infer that $\operatorname{posDiff</p>
<p>In the training phase, all the relations and their respective arguments in each clue are given. Using this supervision, we have built a Maximum Entropy based model (Berger et al., 1996; Della Pietra et al., 1997) to classify the relation between a pair of entities present in a clue. Maximum entropy classifier has been successfully applied in many natural language processing applications (Charniak, 2000; Chieu and Ng, 2002; Ratnaparkhi and others, 1996) and allows the inclusion of various sources of information without necessarily assuming any independence between the features. In this model, the conditional probability distribution is given by:</p>
<p>$$
P(c \mid d)=\frac{\prod_{j=1 \ldots K} e^{\lambda_{i} f_{i}(d, c)}}{\sum_{c^{\prime} \in C} \prod_{j=1 \ldots K} e^{\lambda_{i} f_{i}\left(d, c^{\prime}\right)}}
$$</p>
<p>where the denominator is the normalization term and the parameter $\lambda_{i}$ correspond to the weight for the feature $f_{i}$. Features in Maximum Entropy model are functions from context and classes to the set of real numbers. A detailed description of the model or parameter estimation method used - Generalized Iterative Scaling, can be found at (Darroch and Ratcliff, 1972).</p>
<p>Table 2 describes the features that are used in the classification task. Here, path $\left(E_{1}, E_{2}\right)$ denotes all the words that occur in the path(s) con-
necting $E_{1}$ and $E 2$ in the dependency graph of the clue.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Feature Set</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Class of $E_{1}$ and $E_{2}$</td>
</tr>
<tr>
<td style="text-align: left;">All the grammatical relations between the</td>
</tr>
<tr>
<td style="text-align: left;">words in $\operatorname{path}\left(E_{1}, E_{2}\right)$</td>
</tr>
<tr>
<td style="text-align: left;">All the adjectives and adverbs in $\operatorname{path}\left(E_{1}, E_{2}\right)$.</td>
</tr>
<tr>
<td style="text-align: left;">POS tags of all the words in $\operatorname{path}\left(E_{1}, E_{2}\right)$</td>
</tr>
<tr>
<td style="text-align: left;">TypeMatched $=\left[\left[\right.\right.$ class of $E_{1}=$ class of $\left.E_{2}\right]\right]$</td>
</tr>
<tr>
<td style="text-align: left;">Is $E_{1}$ Numeric $=\left[\left[\right.\right.$ class of $E_{1}$ is Numeric $\left.\left.\right]\right]$</td>
</tr>
<tr>
<td style="text-align: left;">Is $E_{2}$ Numeric $=\left[\left[\right.\right.$ class of $E_{2}$ is Numeric $\left.\left.\right]\right]$</td>
</tr>
<tr>
<td style="text-align: left;">All the words that appears in the following</td>
</tr>
<tr>
<td style="text-align: left;">grammatical relations $a d v m o d, a m o d, \operatorname{cop}$,</td>
</tr>
<tr>
<td style="text-align: left;">det with the words in $\operatorname{path}\left(E_{1}, E_{2}\right)$.</td>
</tr>
<tr>
<td style="text-align: left;">hasNegativeWord $=\left[\left[\exists \mathrm{w} \in \operatorname{path}\left(E_{1}, E_{2}\right)\right.\right.$ s.t.</td>
</tr>
<tr>
<td style="text-align: left;">w has a neg relation starting with it.]]</td>
</tr>
</tbody>
</table>
<p>Table 2: Features used in the classification task</p>
<p>The relation between each pair of entities in a clue is the one which maximizes the conditional probability in equation (1).</p>
<h3>3.2.1 Missing Entity</h3>
<p>In the case of comparative relations in Table 1, such as greaterThan, the basis of the comparison can be hidden. For example, in clue 1 of the example problem, the two entities, "Hannah" and "client" have been compared on the basis of "price", however there is no constituent in the clue which refers to an element from that category. The basis of comparison is hidden in this case and is implied by the word "paid". In the current implementation, the translation module does not handle this case. For puzzles that contain only one category consisting of numeric elements, the translation module goes with the obvious choice. This is part of our future work.</p>
<h2>4 Related Work</h2>
<p>There has been a significant amount of work on the representation of puzzle problems in a formal language (Gelfond and Kahl, 2014; Baral, 2003; Celik et al., 2009). However, there has not been any work that can automatically solve a logic grid puzzle. The latest work (Baral and Dzifcak, 2012) on this problem, assumes that the entities in a clue are given and the authors manually simplify the sentences for translation. Furthermore their representation of logic grid puzzles does not consider the category of a variable in the formal representation</p>
<p>i.e. uses element/1 and tuple/2 predicates and thus cannot solve puzzles containing more than one numeric categories.</p>
<p>In the same work (Baral and Dzifcak, 2012), the authors propose to use a semantic parser to do the translation. This method works well for simple sentences such as "Donna dale does not have green fleece" however it faces several challenges while dealing with real world puzzle sentences. The difficulty arises due to the restrictions enforced in the translation models used by the existing semantic parsers. Traditional semantic parsers (Vo et al., 2015; Zettlemoyer and Collins, 2005) assign meanings to each word in a dictionary and combine the meaning of the words to characterize the complete sentence. A phrase structure grammar formalism such as Combinatory Categorial Grammar (Steedman and Baldridge, 2011; Vo et al., 2015; Zettlemoyer and Collins, 2005), Context Free Grammar (Aho and Ullman, 1972; Wong and Mooney, 2006), is normally used to obtain the way words combine with each other. In the training phase, the semantic parser learns the meanings of words given a corpus of $&lt;$ sentence, meaning $&gt;$ pairs and stores them in a dictionary. During translation, the semantic parser uses those learned meanings to obtain the meaning of the sentence. Firstly, for the puzzle problems the meaning of the words changes drastically depending on the puzzle. A word may be an entity in one puzzle, but, in a different problem it might not be an entity or might belong to a different category altogether. Thus a learned dictionary may not be useful while translating clues in a new puzzle. Secondly, in puzzles relations are normally expressed by phrases. For example, in the clue "The person who played at Eden Gardens played for India", the phrases "played at" and "played for" are used to express two different relations. Thus, using a model that assigns meaning to each word may not be suitable here. Finally, it is difficult to identify the participants of a relation with a parse tree generated following a phrase structure grammar. For example, consider the parse tree of the clue "The person who trekked for 8 miles started at Bull Creek". Even though, the relation "started at" takes the word 'person' and 'Bull Creek' as its input, it receives the entire phrase "the person who trekked for 8 miles" as its argument along with the other input 'Bull Creek'.</p>
<p>The entity classification problem studied in this
<img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: Parse tree of an example sentence in Combinatory categorial grammar
research shares many similarity with Named Entity Recognition (Nadeau and Sekine, 2007; Zhou and Su, 2002) and the Word Sense disambiguation (Stevenson and Wilks, 2003; Sanderson, 1994) task. However, our work has a major difference; in the entity classification problem, the class of an entity varies with the problem and does not belong to a known closed set, whereas for the other two problems the possible classes are pre-specified.</p>
<h2>5 Experimental Evaluation</h2>
<p>Dataset To evaluate our method we have built a dataset of logic grid puzzles along with their correct solutions. A total of 150 problems are collected from logic-puzzles.org. Out of them 100 problems are fully annotated with the entities and the relations information. The remaining 50 puzzles do not have any annotation except their solution. The set of annotated puzzles contain a total of 467 clues, 5687 words, 1681 entities and 862 relations. The set of 50 puzzles contain a total of 222 clues with 2604 words.</p>
<p>Tasks We evaluate LOGICIA on three tasks: 1) puzzle solving; 2) entity classification; and 3) relation extraction. We use the percentage of correct answers as the evaluation metric for all the three tasks. In case of a logic grid puzzle solving, an answer is considered correct if it exactly matches the solution of that puzzle.</p>
<p>Training-Testing Out of the 100 annotated puzzle problems 50 are used as training samples and remaining 50 puzzles are used in testing. The set of 50 unannotated puzzles are used solely for the task of testing puzzle solving.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;">Entity classification</th>
<th style="text-align: center;">Binary relation classification <br> with annotation</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Relation extraction <br> with annotation</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Solution</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">Total</td>
<td style="text-align: left;">1766</td>
<td style="text-align: center;">960</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">450</td>
<td style="text-align: center;">50</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">Correct</td>
<td style="text-align: left;">1502</td>
<td style="text-align: center;">922</td>
<td style="text-align: center;">854</td>
<td style="text-align: center;">410</td>
<td style="text-align: center;">365</td>
<td style="text-align: center;">37</td>
</tr>
<tr>
<td style="text-align: left;">Percentage</td>
<td style="text-align: left;">$85.05 \%$</td>
<td style="text-align: center;">$96.04 \%$</td>
<td style="text-align: center;">$88.95 \%$</td>
<td style="text-align: center;">$90.90 \%$</td>
<td style="text-align: center;">$81.11 \%$</td>
<td style="text-align: center;">$74 \%$</td>
</tr>
</tbody>
</table>
<p>Table 3: Accuracy on 50 annotated puzzle problems in the Test set.</p>
<p>Results Table $3 \&amp; 4$ shows the efficacy of our approach in solving logic grid puzzles with the selected set of relations. LOGICIA is able to classify the constituents with $85.05 \%$ accuracy and is able to solve 71 problems out of the 100 test puzzles. It should be noted that puzzle problems requires precise understanding of the text and to obtain the correct solution of a puzzle problem all the entities and their relations in the puzzle need to be identified. Columns 2 and 3 in Table 3 compares the performance on relation extraction when it is used in conjunction with the entity classification and when it directly uses the annotated entity.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;">Puzzle Solving</th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Total</td>
<td style="text-align: left;">Correct</td>
<td style="text-align: left;">Percentage</td>
</tr>
<tr>
<td style="text-align: left;">50</td>
<td style="text-align: left;">34</td>
<td style="text-align: left;">$68 \%$</td>
</tr>
</tbody>
</table>
<p>Table 4: Accuracy on unannotated 50 test puzzle problems.</p>
<p>Error Analysis The errors in entity classification falls into two major categories. In the first category, more knowledge of similarity is needed than what is currently obtained from the WordNet. Consider for example, the categories are "class number" and "class size" and the constituent is "20 students". Even though the constituent is closer to "class size", standard WordNet based similarity methods are unable to provide such information. In the second category, the WordNet similarity of the constituent to one of the classes is quite high due to their position in the WordNet hierarchy; however with respect to the particular problem the constituent is not an entity. The relation extraction task performs fairly well, however the binary relation classification task does not jointly consider the relation between all the entities and because of that if one of the necessary binary relation of a complex relation is misclassified, the extraction of the entire relation gets affected.</p>
<h2>6 Conclusion \&amp; Future Work</h2>
<p>This paper presents a novel approach for solving logic grid puzzle. To the best of our knowledge, this is a novel work with respect to the fact that that it can automatically solve a given logic grid puzzle.</p>
<p>There are several advantages of our approach. The inclusion of knowledge in terms of a vocabulary of relations makes it scalable. For puzzles which make use of a different set of constraints, such as "Lynda sat on an even numbered position", can be easily integrated into the vocabulary and the system can then be trained to identify those relations for new puzzles. Also, the proposed approach separates the representation from reasoning. The translation module only identifies the relation and their arguments; it is not aware of the meaning of those relations. The reasoning module, on the other hand, knows the definition of each relation and subsequently prunes those possibilities when relations appearing in a clue does not hold. This separation of representation from reasoning allows the system to deal with the complex relations that appear in a clue.</p>
<p>There are a few practical and theoretical issues which need to be addressed. One of those is updating the logical vocabulary in a scalable manner. Logic grid puzzle is a wide family of puzzles and it will require more knowledge of relations than what is currently available. Another challenge that needs to be addressed is the computation of similarity between complex concepts such as "size of class" and " 20 students". Also, the case of "missing entity" (3.2) needs to be modeled properly. This work is the first step towards further understanding these important issues.</p>
<h2>Acknowledgements</h2>
<p>We thank NSF for the DataNet Federation Consortium grant OCI-0940841 and ONR for their grant N00014-13-1-0334 for partially supporting this research.</p>
<h2>References</h2>
<p>Alfred V Aho and Jeffrey D Ullman. 1972. The theory of parsing, translation, and compiling. PrenticeHall, Inc.</p>
<p>Nguyen Bach and Sameer Badaskar. 2007. A review of relation extraction. Literature review for Language and Statistics II.</p>
<p>Chitta Baral and Juraj Dzifcak. 2012. Solving puzzles described in english by automated translation to answer set programming and learning how to do that translation. In Principles of Knowledge Representation and Reasoning: Proceedings of the Thirteenth International Conference, KR 2012, Rome, Italy, June 10-14, 2012.</p>
<p>Chitta Baral. 2003. Knowledge representation, reasoning and declarative problem solving. Cambridge university press.</p>
<p>Jonathan Berant, Vivek Srikumar, Pei-Chun Chen, Brad Huang, Christopher D Manning, Abby Vander Linden, Brittany Harding, and Peter Clark. 2014. Modeling biological processes for reading comprehension. In Proc. EMNLP.</p>
<p>Adam L Berger, Vincent J Della Pietra, and Stephen A Della Pietra. 1996. A maximum entropy approach to natural language processing. Computational linguistics, 22(1):39-71.</p>
<p>Mehmet Celik, Halit Erdogan, Firat Tahaoglu, Tansel Uras, and Esra Erdem. 2009. Comparing asp and cp on four grid puzzles. In Proceedings of the Sixteenth RCRA International Workshop on Experimental Evaluation of Algorithms for Solving Problems with Combinatorial Explosion (RCRA09). CEUR Workshop Proceedings.</p>
<p>Eugene Charniak. 2000. A maximum-entropyinspired parser. In Proceedings of the 1st North American chapter of the Association for Computational Linguistics conference, pages 132-139. Association for Computational Linguistics.</p>
<p>Danqi Chen and Christopher D Manning. 2014. A fast and accurate dependency parser using neural networks. In Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), pages 740-750.</p>
<p>Hai Leong Chieu and Hwee Tou Ng. 2002. Named entity recognition: a maximum entropy approach using global information. In Proceedings of the 19th international conference on Computational linguisticsVolume 1, pages 1-7. Association for Computational Linguistics.</p>
<p>John N Darroch and Douglas Ratcliff. 1972. Generalized iterative scaling for log-linear models. The annals of mathematical statistics, pages 1470-1480.</p>
<p>Stephen Della Pietra, Vincent Della Pietra, and John Lafferty. 1997. Inducing features of random fields.</p>
<p>Pattern Analysis and Machine Intelligence, IEEE Transactions on, 19(4):380-393.</p>
<p>Katrin Fundel, Robert Kffner, and Ralf Zimmer. 2007. Relexrelation extraction using dependency parse trees. Bioinformatics, 23(3):365-371.</p>
<p>Michael Gelfond and Yulia Kahl. 2014. Knowledge representation, reasoning, and the design of intelligent agents: The answer-set programming approach. Cambridge University Press.</p>
<p>Michael Gelfond and Vladimir Lifschitz. 1991. Classical negation in logic programs and disjunctive databases. New generation computing, 9(3-4):365385.</p>
<p>Graeme Hirst and David St-Onge. 1998. Lexical chains as representations of context for the detection and correction of malapropisms. WordNet: An electronic lexical database, 305:305-332.</p>
<p>Mohammad Javad Hosseini, Hannaneh Hajishirzi, Oren Etzioni, and Nate Kushman. 2014. Learning to solve arithmetic word problems with verb categorization. In Conference on Empirical Methods in Natural Language Processing (EMNLP).</p>
<p>Jin-Dong Kim, Sampo Pyysalo, Tomoko Ohta, Robert Bossy, Ngan Nguyen, and Jun'ichi Tsujii. 2011. Overview of bionlp shared task 2011. In Proceedings of the BioNLP Shared Task 2011 Workshop, pages 1-6. Association for Computational Linguistics.</p>
<p>Ross Kindermann, James Laurie Snell, et al. 1980. Markov random fields and their applications, volume 1. American Mathematical Society Providence, RI.</p>
<p>Daphne Koller and Nir Friedman. 2009. Probabilistic graphical models: principles and techniques. MIT press.</p>
<p>Nate Kushman, Yoav Artzi, Luke Zettlemoyer, and Regina Barzilay. 2014. Learning to automatically solve algebra word problems. ACL (1), pages 271281.</p>
<p>Vladimir Lifschitz. 1999. Answer set planning. In Logic Programming and Nonmonotonic Reasoning, pages 373-374. Springer.</p>
<p>Ryan McDonald, Fernando Pereira, Seth Kulick, Scott Winters, Yang Jin, and Pete White. 2005. Simple algorithms for complex relation extraction with applications to biomedical ie. In Proceedings of the 43rd Annual Meeting on Association for Computational Linguistics, pages 491-498. Association for Computational Linguistics.</p>
<p>George A Miller. 1995. Wordnet: a lexical database for english. Communications of the ACM, 38(11):39-41.</p>
<p>David Nadeau and Satoshi Sekine. 2007. A survey of named entity recognition and classification. Lingvisticae Investigationes, 30(1):3-26.</p>
<p>Benedek Nagy and Gerard Allwein. 2004. Diagrams and non-monotonicity in puzzles. In Diagrammatic Representation and Inference, pages 8296. Springer.</p>
<p>Adwait Ratnaparkhi et al. 1996. A maximum entropy model for part-of-speech tagging. In Proceedings of the conference on empirical methods in natural language processing, volume 1, pages 133-142. Philadelphia, PA.</p>
<p>Mark Sanderson. 1994. Word sense disambiguation and information retrieval. In Proceedings of the 17th annual international ACM SIGIR conference on Research and development in information retrieval, pages 142-151. Springer-Verlag New York, Inc.</p>
<p>Mark Steedman and Jason Baldridge. 2011. Combinatory categorial grammar. Non-Transformational Syntax: Formal and Explicit Models of Grammar. Wiley-Blackwell.</p>
<p>Mark Stevenson and Yorick Wilks. 2003. Word sense disambiguation. The Oxford Handbook of Comp. Linguistics, pages 249-265.</p>
<p>Nguyen Ha Vo, Arindam Mitra, and Chitta Baral. 2015. The NL2KR platform for building natural language translation systems. In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing of the Asian Federation of Natural Language Processing, ACL 2015, July 26-31, 2015, Beijing, China, Volume 1: Long Papers, pages 899-908.</p>
<p>Yuk Wah Wong and Raymond J Mooney. 2006. Learning for semantic parsing with statistical machine translation. In Proceedings of the main conference on Human Language Technology Conference of the North American Chapter of the Association of Computational Linguistics, pages 439-446. Association for Computational Linguistics.</p>
<p>Luke S. Zettlemoyer and Michael Collins. 2005. Learning to Map Sentences to Logical Form: Structured Classification with Probabilistic Categorial Grammars. In UAI, pages 658-666. AUAI Press.</p>
<p>Yongyue Zhang, Michael Brady, and Stephen Smith. 2001. Segmentation of brain mr images through a hidden markov random field model and the expectation-maximization algorithm. Medical Imaging, IEEE Transactions on, 20(1):45-57.</p>
<p>GuoDong Zhou and Jian Su. 2002. Named entity recognition using an hmm-based chunk tagger. In proceedings of the 40th Annual Meeting on Association for Computational Linguistics, pages 473-480. Association for Computational Linguistics.</p>
<p>Deyu Zhou, Dayou Zhong, and Yulan He. 2014. Biomedical relation extraction: From binary to complex. Computational and mathematical methods in medicine, 2014.</p>            </div>
        </div>

    </div>
</body>
</html>