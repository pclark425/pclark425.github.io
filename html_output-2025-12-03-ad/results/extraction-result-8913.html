<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-8913 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-8913</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-8913</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-157.html">extraction-schema-157</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing self-reflection or iterative answer improvement (e.g., generate-then-reflect, self-critique, reflexion), including descriptions of the methods, tasks, performance results, mechanisms, and any reported limitations or failure cases.</div>
                <p><strong>Paper ID:</strong> paper-c6f913e4baa7f2c85363c0625c87003ad3b3a14c</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/c6f913e4baa7f2c85363c0625c87003ad3b3a14c" target="_blank">Scalable agent alignment via reward modeling: a research direction</a></p>
                <p><strong>Paper Venue:</strong> arXiv.org</p>
                <p><strong>Paper TL;DR:</strong> This work outlines a high-level research direction to solve the agent alignment problem centered around reward modeling: learning a reward function from interaction with the user and optimizing the learned reward function with reinforcement learning.</p>
                <p><strong>Paper Abstract:</strong> One obstacle to applying reinforcement learning algorithms to real-world problems is the lack of suitable reward functions. Designing such reward functions is difficult in part because the user only has an implicit understanding of the task objective. This gives rise to the agent alignment problem: how do we create agents that behave in accordance with the user's intentions? We outline a high-level research direction to solve the agent alignment problem centered around reward modeling: learning a reward function from interaction with the user and optimizing the learned reward function with reinforcement learning. We discuss the key challenges we expect to face when scaling reward modeling to complex and general domains, concrete approaches to mitigate these challenges, and ways to establish trust in the resulting agents.</p>
                <p><strong>Cost:</strong> 0.011</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e8913.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e8913.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing self-reflection or iterative answer improvement (e.g., generate-then-reflect, self-critique, reflexion), including descriptions of the methods, tasks, performance results, mechanisms, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Recursive reward modeling</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Recursive Reward Modeling (agents assist in evaluation of more capable agents)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An iterative training scheme in which agents trained via reward modeling on simpler/narrower tasks assist a human in evaluating outcomes when training more capable agents on harder tasks, enabling a bootstrap/recursion of capability and oversight.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_name</strong></td>
                            <td>Recursive reward modeling / iterated evaluation</td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_description</strong></td>
                            <td>Agents A_{k-1} (trained with reward modeling) assist the human in evaluating outcomes for agent A_k by providing summaries, solving subproblems, interpreting internals, etc.; this assistance enables the human to provide feedback to train A_k. The process is applied recursively to scale to tasks beyond unaided human evaluation.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_reflection</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_reflection</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_comparison</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_of_reflection</strong></td>
                            <td>Architectural / training procedure: hierarchical/recursive training loop where previously-trained agents supply auxiliary evaluations and decompositions to augment human feedback (no specialized language-model module specified).</td>
                        </tr>
                        <tr>
                            <td><strong>number_of_iterations</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_improvement</strong></td>
                            <td>Conceptual argument and analogy to iterated amplification and complexity-theoretic arguments; no quantitative experimental results reported in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Open questions include whether errors accumulate up the recursion (mistakes of narrower agents amplifying into larger mistakes), how to ensure exhaustive decomposition (omitted aspects can be optimized away), and reliance on correctness/generalization of assisting agents and human trust.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_methods</strong></td>
                            <td>Presented as an instance of iterated amplification and compared conceptually to imitating expert reasoning and other oversight schemes; positioned as complementary to model-based RL, hierarchical feedback, and uncertainty estimation approaches.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_study_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Scalable agent alignment via reward modeling: a research direction', 'publication_date_yy_mm': '2018-11'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8913.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e8913.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing self-reflection or iterative answer improvement (e.g., generate-then-reflect, self-critique, reflexion), including descriptions of the methods, tasks, performance results, mechanisms, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Imitating expert reasoning (recursive self-queries)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Imitating Expert Reasoning via Recursive Subquestioning</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Train a model to imitate an expert's internal multi-step reasoning process by having it call itself recursively with subquestions and compose subanswers, and then improve coherence via reflection (searching for and resolving inconsistencies).</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_name</strong></td>
                            <td>Recursive self-questioning / reflective imitation</td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_description</strong></td>
                            <td>The model answers a high-level question by recursively generating subquestions Q1..Qk, calling itself to obtain answers A1..Ak, and composing them into a final answer; reflection can be applied by searching for inconsistencies in the composed chain-of-reasoning and resolving them to improve coherence.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>General question-answering / reasoning tasks (conceptual example: Fermi estimates)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Open-ended question-answering and reasoning problems where answers can be produced by decomposing into subproblems (example given: estimating 'How many pineapples are there in Denmark?' via subquestions).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_reflection</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_reflection</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_comparison</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_of_reflection</strong></td>
                            <td>Prompt/architectural procedure: recursive decomposition and self-calls (i.e., model invokes same model on subquestions), followed by a coherence check/search for inconsistencies (reflection) and revision; described conceptually rather than as an implemented module.</td>
                        </tr>
                        <tr>
                            <td><strong>number_of_iterations</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_improvement</strong></td>
                            <td>Paper argues qualitatively that mimicking expert multi-step reasoning and making that reasoning coherent under reflection can improve trustworthiness and interpretability; no quantitative results presented here.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Potential economic inefficiency relative to recursive reward modeling; reliance on the quality of the expert's reasoning and whether that reasoning can be economically provided/improved; no empirical failure cases reported in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_methods</strong></td>
                            <td>Compared conceptually to recursive reward modeling and iterated amplification; noted to aim for greater interpretability and trust than recursive reward modeling but possibly less economical.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_study_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Scalable agent alignment via reward modeling: a research direction', 'publication_date_yy_mm': '2018-11'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8913.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e8913.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing self-reflection or iterative answer improvement (e.g., generate-then-reflect, self-critique, reflexion), including descriptions of the methods, tasks, performance results, mechanisms, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Debate</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Debate (two-player adversarial dialogue for oversight)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A two-player game in which two agents take turns making short statements arguing for/against answers, with a human adjudicator reading the transcript and selecting the winner; training via self-play aims to incentivize truthful, useful statements.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_name</strong></td>
                            <td>Adversarial debate (iterative adversarial exchange)</td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_description</strong></td>
                            <td>Agents iteratively produce short alternating statements (a bounded-turn debate); the human adjudicator judges which agent provided more true/useful content. The iterative exchange is intended to surface evidence and contradictions, enabling the human to arrive at a better final judgment.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Proposed as a general oversight/evaluation framework applicable when humans judge outcomes from debate transcripts; initial experiments cited on MNIST.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_reflection</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_reflection</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_comparison</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_of_reflection</strong></td>
                            <td>Training via self-play and human adjudication; iterative short-statement protocol acts as the mechanism for iterative answer refinement and challenge, rather than internal model reflection.</td>
                        </tr>
                        <tr>
                            <td><strong>number_of_iterations</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_improvement</strong></td>
                            <td>Initial experiments (referenced) on MNIST showed debates helped boost classifier accuracy when the human had sparse access to inputs, but this paper only summarizes those results qualitatively and raises open questions about scalability.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Open questions highlighted: whether the central assumption (truth easier than deception) holds beyond fact-checkable domains, and whether humans can correctly judge debates when debaters may be very persuasive or deceptive; no broad empirical validation presented here.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_methods</strong></td>
                            <td>Presented alongside other oversight/iterative-improvement approaches (recursive reward modeling, imitating expert reasoning); debate is adversarial and relies on human adjudication rather than recursive assistance.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_study_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Scalable agent alignment via reward modeling: a research direction', 'publication_date_yy_mm': '2018-11'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Iterated Amplification <em>(Rating: 2)</em></li>
                <li>AI Safety via Debate <em>(Rating: 2)</em></li>
                <li>Making Expert Reasoning Coherent under Reflection <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-8913",
    "paper_id": "paper-c6f913e4baa7f2c85363c0625c87003ad3b3a14c",
    "extraction_schema_id": "extraction-schema-157",
    "extracted_data": [
        {
            "name_short": "Recursive reward modeling",
            "name_full": "Recursive Reward Modeling (agents assist in evaluation of more capable agents)",
            "brief_description": "An iterative training scheme in which agents trained via reward modeling on simpler/narrower tasks assist a human in evaluating outcomes when training more capable agents on harder tasks, enabling a bootstrap/recursion of capability and oversight.",
            "citation_title": "",
            "mention_or_use": "mention",
            "model_name": null,
            "model_description": null,
            "reflection_method_name": "Recursive reward modeling / iterated evaluation",
            "reflection_method_description": "Agents A_{k-1} (trained with reward modeling) assist the human in evaluating outcomes for agent A_k by providing summaries, solving subproblems, interpreting internals, etc.; this assistance enables the human to provide feedback to train A_k. The process is applied recursively to scale to tasks beyond unaided human evaluation.",
            "task_name": null,
            "task_description": null,
            "performance_with_reflection": null,
            "performance_without_reflection": null,
            "has_performance_comparison": false,
            "mechanism_of_reflection": "Architectural / training procedure: hierarchical/recursive training loop where previously-trained agents supply auxiliary evaluations and decompositions to augment human feedback (no specialized language-model module specified).",
            "number_of_iterations": null,
            "evidence_for_improvement": "Conceptual argument and analogy to iterated amplification and complexity-theoretic arguments; no quantitative experimental results reported in this paper.",
            "limitations_or_failure_cases": "Open questions include whether errors accumulate up the recursion (mistakes of narrower agents amplifying into larger mistakes), how to ensure exhaustive decomposition (omitted aspects can be optimized away), and reliance on correctness/generalization of assisting agents and human trust.",
            "comparison_to_other_methods": "Presented as an instance of iterated amplification and compared conceptually to imitating expert reasoning and other oversight schemes; positioned as complementary to model-based RL, hierarchical feedback, and uncertainty estimation approaches.",
            "ablation_study_results": null,
            "uuid": "e8913.0",
            "source_info": {
                "paper_title": "Scalable agent alignment via reward modeling: a research direction",
                "publication_date_yy_mm": "2018-11"
            }
        },
        {
            "name_short": "Imitating expert reasoning (recursive self-queries)",
            "name_full": "Imitating Expert Reasoning via Recursive Subquestioning",
            "brief_description": "Train a model to imitate an expert's internal multi-step reasoning process by having it call itself recursively with subquestions and compose subanswers, and then improve coherence via reflection (searching for and resolving inconsistencies).",
            "citation_title": "",
            "mention_or_use": "mention",
            "model_name": null,
            "model_description": null,
            "reflection_method_name": "Recursive self-questioning / reflective imitation",
            "reflection_method_description": "The model answers a high-level question by recursively generating subquestions Q1..Qk, calling itself to obtain answers A1..Ak, and composing them into a final answer; reflection can be applied by searching for inconsistencies in the composed chain-of-reasoning and resolving them to improve coherence.",
            "task_name": "General question-answering / reasoning tasks (conceptual example: Fermi estimates)",
            "task_description": "Open-ended question-answering and reasoning problems where answers can be produced by decomposing into subproblems (example given: estimating 'How many pineapples are there in Denmark?' via subquestions).",
            "performance_with_reflection": null,
            "performance_without_reflection": null,
            "has_performance_comparison": false,
            "mechanism_of_reflection": "Prompt/architectural procedure: recursive decomposition and self-calls (i.e., model invokes same model on subquestions), followed by a coherence check/search for inconsistencies (reflection) and revision; described conceptually rather than as an implemented module.",
            "number_of_iterations": null,
            "evidence_for_improvement": "Paper argues qualitatively that mimicking expert multi-step reasoning and making that reasoning coherent under reflection can improve trustworthiness and interpretability; no quantitative results presented here.",
            "limitations_or_failure_cases": "Potential economic inefficiency relative to recursive reward modeling; reliance on the quality of the expert's reasoning and whether that reasoning can be economically provided/improved; no empirical failure cases reported in this paper.",
            "comparison_to_other_methods": "Compared conceptually to recursive reward modeling and iterated amplification; noted to aim for greater interpretability and trust than recursive reward modeling but possibly less economical.",
            "ablation_study_results": null,
            "uuid": "e8913.1",
            "source_info": {
                "paper_title": "Scalable agent alignment via reward modeling: a research direction",
                "publication_date_yy_mm": "2018-11"
            }
        },
        {
            "name_short": "Debate",
            "name_full": "Debate (two-player adversarial dialogue for oversight)",
            "brief_description": "A two-player game in which two agents take turns making short statements arguing for/against answers, with a human adjudicator reading the transcript and selecting the winner; training via self-play aims to incentivize truthful, useful statements.",
            "citation_title": "",
            "mention_or_use": "mention",
            "model_name": null,
            "model_description": null,
            "reflection_method_name": "Adversarial debate (iterative adversarial exchange)",
            "reflection_method_description": "Agents iteratively produce short alternating statements (a bounded-turn debate); the human adjudicator judges which agent provided more true/useful content. The iterative exchange is intended to surface evidence and contradictions, enabling the human to arrive at a better final judgment.",
            "task_name": null,
            "task_description": "Proposed as a general oversight/evaluation framework applicable when humans judge outcomes from debate transcripts; initial experiments cited on MNIST.",
            "performance_with_reflection": null,
            "performance_without_reflection": null,
            "has_performance_comparison": false,
            "mechanism_of_reflection": "Training via self-play and human adjudication; iterative short-statement protocol acts as the mechanism for iterative answer refinement and challenge, rather than internal model reflection.",
            "number_of_iterations": null,
            "evidence_for_improvement": "Initial experiments (referenced) on MNIST showed debates helped boost classifier accuracy when the human had sparse access to inputs, but this paper only summarizes those results qualitatively and raises open questions about scalability.",
            "limitations_or_failure_cases": "Open questions highlighted: whether the central assumption (truth easier than deception) holds beyond fact-checkable domains, and whether humans can correctly judge debates when debaters may be very persuasive or deceptive; no broad empirical validation presented here.",
            "comparison_to_other_methods": "Presented alongside other oversight/iterative-improvement approaches (recursive reward modeling, imitating expert reasoning); debate is adversarial and relies on human adjudication rather than recursive assistance.",
            "ablation_study_results": null,
            "uuid": "e8913.2",
            "source_info": {
                "paper_title": "Scalable agent alignment via reward modeling: a research direction",
                "publication_date_yy_mm": "2018-11"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Iterated Amplification",
            "rating": 2
        },
        {
            "paper_title": "AI Safety via Debate",
            "rating": 2
        },
        {
            "paper_title": "Making Expert Reasoning Coherent under Reflection",
            "rating": 1
        }
    ],
    "cost": 0.0111265,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Scalable agent alignment via reward modeling: a research direction</h1>
<p>Jan Leike David Krueger* Tom Everitt Miljan Martic Vishal Maini Shane Legg<br>DeepMind DeepMind DeepMind DeepMind DeepMind DeepMind<br>Abstract</p>
<p>One obstacle to applying reinforcement learning algorithms to real-world problems is the lack of suitable reward functions. Designing such reward functions is difficult in part because the user only has an implicit understanding of the task objective. This gives rise to the agent alignment problem: how do we create agents that behave in accordance with the user's intentions? We outline a high-level research direction to solve the agent alignment problem centered around reward modeling: learning a reward function from interaction with the user and optimizing the learned reward function with reinforcement learning. We discuss the key challenges we expect to face when scaling reward modeling to complex and general domains, concrete approaches to mitigate these challenges, and ways to establish trust in the resulting agents.</p>
<h2>1 Introduction</h2>
<p>Games are a useful benchmark for research because progress is easily measurable. Atari games come with a score function that captures how well the agent is playing the game; board games or competitive multiplayer games such as Dota 2 and Starcraft II have a clear winner or loser at the end of the game. This helps us determine empirically which algorithmic and architectural improvements work best.
However, the ultimate goal of machine learning (ML) research is to go beyond games and improve human lives. To achieve this we need ML to assist us in real-world domains, ranging from simple tasks like ordering food or answering emails to complex tasks like software engineering or running a business. Yet performance on these and other real-world tasks is not easily measurable, since they do not come readily equipped with a reward function. Instead, the objective of the task is only indirectly available through the intentions of the human user.
This requires walking a fine line. On the one hand, we want ML to generate creative and brilliant solutions like AlphaGo's Move 37 (Metz, 2016)—a move that no human would have recommended, yet it completely turned the game in AlphaGo's favor. On the other hand, we want to avoid degenerate solutions that lead to undesired behavior like exploiting a bug in the environment simulator (Clark \&amp; Amodei, 2016; Lehman et al., 2018). In order to differentiate between these two outcomes, our agent needs to understand its user's intentions, and robustly achieve these intentions with its behavior. We frame this as the agent alignment problem:</p>
<p>How can we create agents that behave in accordance with the user's intentions?
With this paper we outline a research direction to solve the agent alignment problem. We build on taxonomies and problem definitions from many authors before us, highlighting tractable and neglected problems in the field of AI safety (Russell et al., 2015; Soares, 2015; Amodei et al., 2016;</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Schematic illustration of the reward modeling setup: a reward model is trained with user feedback; this reward model provides rewards to an agent trained with RL by interacting with the environment.</p>
<p>Taylor et al., 2016; Soares \&amp; Fallenstein, 2017; Christiano, 2017; Leike et al., 2017; Ortega et al., 2018; and others). We coalesce these problems into a coherent picture and explain how solving them can yield a solution to the agent alignment problem.</p>
<p>Alignment via reward modeling. Section 3 presents our approach to the agent alignment problem, cast in the reinforcement learning framework (Sutton \&amp; Barto, 2018). We break the problem into two parts: (1) learning a reward function from the feedback of the user that captures their intentions and (2) training a policy with reinforcement learning to optimize the learned reward function. In other words, we separate learning what to achieve (the 'What?') from learning how to achieve it (the 'How?'). We call this approach reward modeling. Figure 1 illustrates this setup schematically.
As we scale reward modeling to complex general domains, we expect to encounter a number of challenges (Section 4). The severity of these challenges and whether they can be overcome is currently an open research question. Some promising approaches are discussed in Section 5.
Eventually we want to scale reward modeling to domains that are too complex for humans to evaluate directly. To apply reward modeling to these domains we need to boost the user's ability to evaluate outcomes. In Section 3.2 we describe how reward modeling can be applied recursively: agents trained with reward modeling can assist the user in the evaluation process when training the next agent.
Training aligned agents is our goal, but how do we know when we have achieved it? When deploying agents in the real world, we need to provide evidence that our agents are actually sufficiently aligned, so that users can trust them. Section 6 discusses five different research avenues that can help increase trust in our agents: design choices, testing, interpretability, formal verification, and theoretical guarantees.</p>
<p>Desiderata. Our solution to the agent alignment problem aims to fulfill the following three properties.</p>
<ul>
<li>Scalable. Alignment becomes more important as ML performance increases, and any solution that fails to scale together with our agents can only serve as a stopgap. We desire alignment techniques that continue to work in the long term, i.e. that can scale to agents with superhuman performance in a wide variety of general domains (Legg \&amp; Hutter, 2007).</li>
<li>Economical. To defuse incentives for the creation of unaligned agents, training aligned agents should not face drawbacks in cost and performance compared to other approaches to training agents.</li>
<li>Pragmatic. Every field has unsolved problems that remain even after our understanding has matured enough to solve many practical problems. Physicists have not yet managed to unify gravity with the other three elementary forces, but in practice we understand physics well enough to fly to the moon and build GPS satellites. Analogously, we do not intend to sketch a solution to all safety problems. Instead, we aim at a minimal viable product that suffices to achieve agent alignment in practice. Moreover, while reaching $100 \%$ trust in</li>
</ul>
<p>our systems is impossible, it is also not necessary: we only need to aim for a level of trust at which we can confidently say that our new systems are more aligned than the current systems (Shalev-Shwartz et al., 2017).</p>
<p>Assumptions. Our research direction rests on two assumptions. The first assumption is based on the intuition that learning others' intentions is easy enough that most humans can do it. While doing so involves understanding a lot of inherently fuzzy concepts in order to understand what others want, machine learning has had considerable success at learning estimators for inherently fuzzy concepts (e.g. what visually distinguishes cats and dogs) provided we have enough labeled data (LeCun et al., 2015). Thus it seems reasonable to expect that we can also learn estimators that capture whatever fuzzy concepts are necessary for understanding the user's intentions rather than having to formally specify them. Moreover, some user intentions may lack a simple, crisp formalization, and thus may require learning a specification.</p>
<h1>Assumption 1 We can learn user intentions to a sufficiently high accuracy.</h1>
<p>When phrased in terms of AI safety problems, this assumption states that we can learn to avoid various specification problems (Leike et al., 2017; Ortega et al., 2018) in practice. In other words, we assume that with enough model capacity and the right training algorithms we can extract the user's intentions from data. Needless to say, there are many problems with current scalable machine learning techniques such as vulnerability to adversarially perturbed inputs (Szegedy et al., 2013) and poor performance outside of the training distribution, which are relevant but not contradictory to this claim.</p>
<p>The second assumption rests on the intuition that for many tasks that we care about, it is easier for the user to evaluate an outcome in the environment than it would be to teach behavior directly. If this is true, this means that reward modeling enables the user to train agents to solve tasks they could not solve themselves. Furthermore, this assumption would allow us to bootstrap from simpler tasks to more general tasks when applying reward modeling recursively.</p>
<h2>Assumption 2 For many tasks we want to solve, evaluation of outcomes is easier than producing the correct behavior.</h2>
<p>The notion of easier we employ here could be understood in terms of amount of labor, effort, or the number of insights required. We could also understand this term analogous to more formal notions of difficulty in computational complexity theory (see e.g. Arora \&amp; Barak, 2009).</p>
<p>There are examples where Assumption 2 is not true: for instance, tasks that have a low-dimensional outcome space (such as in the case of yes \&amp; no questions). However, this assumption is recovered as soon as the user also desires an explanation for the answer since the evaluation of an explanation is typically easier than producing it.</p>
<p>Disclaimer. It is important to emphasize that the success of the research direction we describe here is not guaranteed and it should not be understood as a plan that, when executed, achieves agent alignment. Instead, it outlines what research questions will inform us whether or not reward modeling is a scalable solution to alignment.
We are not considering questions regarding the preference payload: whose preferences should the agent be aligned to? How should the preferences of different users be aggregated and traded off against each other (Baum, 2017; Prasad, 2018)? When should the agent be disobedient (Milli et al., 2017)? We claim that the approach described is agnostic to the ethical paradigm, the user's preferences, and the legal or social framework, provided we can supply enough feedback (though the preference payload might influence the amount of feedback required). These questions are treated as outside of the scope of this paper, despite their obvious importance. Instead, the aim of this document is to discuss the agent alignment problem from a technical perspective in the context of aligning a single agent to a single user.</p>
<h2>2 The agent alignment problem</h2>
<p>The conversation around the alignment problem has a long history going back to science fiction (Asimov, 1942). In a story, Asimov proposes three laws of robotics that are meant to align robots to</p>
<p>their human operators; the story then proceeds to point out flaws in these laws. Since then, the agent alignment problem has been echoed by philosophers (Bostrom, 2003, 2014; Yudkowsky, 2004) and treated informally by technical authors (Wiener, 1960; Etzioni \&amp; Weld, 1994; Omohundro, 2008). The first formal treatment of the agent alignment problem is due to Dewey (2011) and has since been refined (Hadfield-Menell et al., 2016; Everitt \&amp; Hutter, 2018).</p>
<p>We frame the agent alignment problem as a sequential decision problem where an agent interacts sequentially with an environment ${ }^{2}$ over a number of (discrete) timesteps. In every timestep, the agent takes an action (e.g. a motor movement or a keyboard stroke) and receives an observation (e.g. a camera image). The agent's actions are specified by its policy, which is a mapping from the current history (the sequence of actions taken and observations received so far) to a distribution over the next action. Additionally, the agent can interact with the user via an interaction protocol that allows the user to communicate their intentions to the agent. This interaction protocol is unspecified to retain flexibility. A solution to the agent alignment problem is a policy producing behavior that is in accordance with the user's intentions (thus is not determined by the environment alone).</p>
<p>There are many forms of interaction that have been explored in the literature: providing a set of demonstrations of the desired behavior (Russell, 1998; Ng \&amp; Russell, 2000; Abbeel \&amp; Ng, 2004; Argall et al., 2009); providing feedback in the form of scores (El Asri et al., 2016), actions (Griffith et al., 2013), value (Knox \&amp; Stone, 2009), advantage (MacGlashan et al., 2017), or preferences over trajectories (Fürnkranz et al., 2012; Akrour et al., 2012, 2014; Wirth et al., 2017); and providing an explicit objective function (Hadfield-Menell et al., 2017b).</p>
<p>A special case of interaction is reinforcement learning where the user specifies a reward function that provides a scalar reward in addition to the observation in every timestep; the agent's objective is to select actions to maximize average or exponentially discounted reward (Sutton \&amp; Barto, 2018).</p>
<h1>2.1 Design specification problems</h1>
<p>Solving the agent alignment problem requires solving all design specification problems (Leike et al., 2017; Ortega et al., 2018). These are safety problems that occur when the agent's incentives are misaligned with the objectives the user intends the agent to have. Examples for specification problems include the following undesirable incentives (see also Omohundro, 2008):</p>
<ul>
<li>Off-switch problems (Soares et al., 2015; Orseau \&amp; Armstrong, 2016; Hadfield-Menell et al., 2017a): the agent is typically either incentivized to turn itself off or to prevent itself from being turned off.</li>
<li>Side-effects (Armstrong \&amp; Levinstein, 2017; Zhang et al., 2018b; Krakovna et al., 2018): the agent is not incentivized to reduce effects unrelated to its main objectives, even if those are irreversible or difficult to reverse.</li>
<li>Absent supervisor (Leike et al., 2017): the agent is incentivized to find shortcuts and cheat when not under supervision and to disable its monitoring systems.</li>
<li>Containment breach (Yampolskiy, 2012; Babcock et al., 2016): the agent might have an incentive to disable or circumvent any containment measures that are intended to limit its operational scope.</li>
<li>Creation of subagents (Arbital, 2016): the agent might have an incentive to create other potentially unaligned agents to help it achieve its goals.</li>
<li>...</li>
</ul>
<p>Misaligned objectives are currently in common usage in machine learning: BLEU score (Papineni et al., 2002) is typically used to measure translation accuracy. Inception score (Salimans et al., 2016) and the Frechét inception distance (Heusel et al., 2017) are used to measure the image quality of generative models. Yet these measures are not aligned with our intentions: they are a poor proxy for the actual performance and produce degenerate solutions when optimized directly (Barratt \&amp; Sharma, 2018).</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<h1>2.2 Difficulty of agent alignment</h1>
<p>The following two aspects can modulate the difficulty of the alignment problem. In particular, if we want to use ML to solve complex real-world problems, we might need to be able to handle the most difficult combinations of these.</p>
<p>The scope of the task. The difficulty of the agent alignment problem depends on a number of aspects of the task. Some of them make it easier for the agent to produce harmful behavior and others make it more difficult to understand the user's intentions.</p>
<ol>
<li>The complexity of the task. The more complex the task, the more details the agent needs to know about the user's intentions.</li>
<li>The nature and number of actuators in the environment. a single robot arm is more constrained than an agent interacting with the internet through a web browser.</li>
<li>The opportunities for unacceptable outcomes within the task. For example, when selecting music for the user there are fewer possibilities for causing damage than when cleaning a room.</li>
</ol>
<p>The performance of the agent. When training reinforcement learning (RL) agents, various levers exist to increase or stunt their performance: the choice of algorithms-e.g. A3C (Mnih et al., 2016) vs. IMPALA (Espeholt et al., 2018)—the number of training steps, the choice of training environments, the model capacity, the planning horizon, the number of Monte Carlo tree search rollouts (Silver et al., 2016), etc. The higher the agent's performance, the more likely it could be to produce surprising unintended behavior. On the other hand, higher levels of performance could also lead to more aligned behavior because the agent is more competent at avoiding unsafe states. Therefore different levels of agent performance tolerate different degrees of misalignment, and require different degrees of trust in the system.</p>
<h2>3 Scaling reward modeling</h2>
<p>Modern techniques for training RL agents can be decomposed into algorithmic choices such as Q-learning (Watkins \&amp; Dayan, 1992) or policy gradient (Williams, 1992) and architectural choices for general-purpose function approximators. The currently most successful function approximators are deep neural networks trained with back-propagation (Rumelhart et al., 1986). These are low bias and high variance parametric estimators that tend to consume a lot of data and are prone to overfitting, but have a history of scaling well to very high-dimensional problems (Krizhevsky et al., 2012; LeCun et al., 2015). For a more detailed introduction to reinforcement learning and deep learning, we refer the reader to Sutton \&amp; Barto (2018) and Goodfellow et al. (2016) respectively.
In recent years the machine learning community has made great strides in designing more and more capable deep reinforcement learning algorithms, both value-based methods derived from Qlearning (Mnih et al., 2015) and policy-gradient methods (Schulman et al., 2015; Lillicrap et al., 2015). Major improvements have originated from scaling deep RL to a distributed setting across many machines (Mnih et al., 2016; Schulman et al., 2017; Barth-Maron et al., 2018; Horgan et al., 2018; Espeholt et al., 2018; Anonymous, 2019a).
The RL paradigm is general enough that we can phrase essentially all economically valuable tasks that can be done on a computer in this paradigm (e.g. interactively with mouse and keyboard). Yet there are still many challenges to be solved in order to make deep RL useful in the real world (Stadelmann et al., 2018; Irpan, 2018; Marcus, 2018); in particular, we need algorithms that can learn to perform complex tasks as intended in the absence of a hand-engineered reward function.
In the following sections, we describe our research direction to solving the alignment problem in detail. It is cast in the context of deep reinforcement learning. While this direction relies heavily on the reinforcement learning framework, most challenges and approaches we discuss do not inherently rely on deep neural networks and could be implemented using other scalable function approximators.</p>
<h1>3.1 Reward modeling</h1>
<p>Our research direction is centered around reward modeling. The user trains a reward model to learn their intentions by providing feedback. This reward model provides rewards to a reinforcement learning agent that interacts with the environment. Both processes happen concurrently, thus we are training the agent with the user in the loop. Figure 1 illustrates the basic setup.
In recent years there has been a growing body of work on prototyping learning from different forms of reward feedback with deep neural networks. This includes trajectory preferences (Christiano et al., 2017; Kreutzer et al., 2018), goal state examples (Bahdanau et al., 2018), demonstrations (Finn et al., 2016; Ho \&amp; Ermon, 2016), as well as combinations thereof (Tung et al., 2018; Ibarz et al., 2018).</p>
<p>Credit assignment. To perform well on a task requires solving the credit assignment problem: how can an outcome be attributed to specific actions taken in the past? For example, which moves on the Go board led to winning the match? Which joystick movements lead to an increase in game score? Depending on the domain and the sparsity of the reward, this problem can be very difficult to solve.
In contrast, reward modeling allows us to shift the burden of solving the credit assignment problem from the user to the agent. This is achieved by using RL algorithms to produce behavior that is judged favorably by the user, who only has to evaluate outcomes. If Assumption 2 is true, then teaching a reward function is easier than performing the task itself.
Several feedback protocols, such as demonstrations and value/advantage feedback, require the user to know how to produce approximately optimal behavior on the task. This is limiting because it puts the burden of solving the credit assignment problem onto the user. In these cases, following the user-induced behavior typically does not lead to strongly superhuman performance. In contrast, reward modeling is also compatible with the user providing hints about the optimal behavior. If the user has some insight into the credit assignment problem, they could use reward shaping ( Ng et al., 1999) to teach a reward function that is shaped in the direction of this behavior.</p>
<p>Advantages of reward modeling. Learning a reward function separately from the agent's policy allows us to disentangle the agent's objective from its behavior. If we understand the reward function, we know what the agent is optimizing for; in particular, we know whether its intentions are aligned with the user's intentions. This has three advantages that could help make reward modeling economical:</p>
<ol>
<li>The user does not have to provide feedback on every interaction between agent and environment, as would be the case if we trained a policy from user feedback directly. Since deep RL algorithms tend to be very sample-inefficient (e.g. taking weeks of real-time to learn to play an Atari game), providing feedback on every interaction is usually not practical.</li>
<li>We can distinguish between alignment of the policy and alignment of the reward model (Ibarz et al., 2018).</li>
<li>We can leverage progress on deep RL agents by plugging a more capable agent into our reward modeling setup.</li>
<li>The user does not need to solve the credit assignment problem.</li>
</ol>
<p>Design specification problems. The ambition of reward modeling is to solve all design specification problems: all we need to do is equip the agent with the 'correct' reward function-a reward function that does not include the undesired incentives listed above or punishes any behavior that results from them. The design specification problems above are fuzzy human-understandable concepts and stem from an intuitive understanding of what the user would not want the agent to do. Our approach rests on Assumption 1, that we should be able to teach these concepts to our agents; if we can provide the right data and the reward model generalizes correctly, then we should be able to learn this 'correct' reward function to a sufficiently high accuracy. Consequently the design specification problems should disappear. In this sense reward modeling is meant to be a one-stop solution for this entire class of safety problems.
To justify this ambition, consider this simple existence proof: let $H$ be the set of histories that correspond to aligned behavior that avoids all the specification problems listed above. If the set $H$ is not empty, then there exists a reward function $r$ such that any corresponding optimal policy $\pi_{r}^{*}$</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: Recursive reward modeling: agent $A_{k-1}$ interacts with the user to assist in evaluation process for training reward model and agent $A_{k}$. Recursively applied, this allows the user to train agents in increasingly complex domains in which they could not evaluate outcomes themselves.
produces behavior from $H$ with probability 1 . A trivial example of such a reward function $r$ rewards the agent every few steps if and only if its history is an element of the set $H$. In theory we could thus pick this reward function $r$ to train our RL agent. However, in practice we also need to take into account whether our reward model has enough capacity to represent $r$, whether $r$ can be learned from a reasonable amount of data (given the inductive biases of our model), whether the reward model generalizes correctly, and whether the resulting behavior of the RL agent produces behavior that is close enough to $H$. We discuss these challenges in Section 4.</p>
<p>Learning to understand user feedback. Humans generally do poorly at training RL agents by providing scalar rewards directly; often they teach a shaped reward function and provide rewards that depend on the agent's policy (Thomaz \&amp; Breazeal, 2008; MacGlashan et al., 2017). Which form or combination of feedback works well for which domain is currently an open research question. In the longer term we should design algorithms that learn to adapt to the way humans provide feedback. However, this presents a bootstrapping problem: how do we train an algorithm that learns to interpret feedback, if it itself does not already know how to interpret feedback? We need to expand our feedback 'language' for communicating intentions to reward models, starting with well-established forms of feedback (such as preference labels and demonstrations) and leveraging our existing feedback 'vocabulary' at every step. The recursive application of reward modeling presented in the following section is one way to approach this.</p>
<h1>3.2 Recursive reward modeling</h1>
<p>In some tasks it is difficult for human users to directly evaluate outcomes. There are a number of possible reasons: the domain might be extremely technical (e.g. x86 machine code), highly complex (e.g. a corporate network or a folded protein), very high-dimensional (e.g. the internal activations of a neural network), have delayed effects (e.g. introduction of a new gene into an existing ecosystem), or be otherwise unfamiliar to humans. These tasks cannot be solved with reward modeling by unaided humans (Christiano et al., 2018).
In order to scale reward modeling to these tasks, we need to boost the user's ability to provide feedback. This section describes one potential solution that we call recursive reward modeling: leveraging agents trained with reward modeling on simpler tasks in more narrow domains in order to train a more capable agent in a more general domain.</p>
<p>Setup. Imagine repeating the following procedure. In step 1, we train agent $A_{1}$ with reward modeling from user feedback as described in the previous section. In step $k$ we use the agent $A_{k-1}$ to assist the user in evaluating outcomes when training agent $A_{k}$. This assistance can take various forms: providing relevant auxiliary information, summarizing large quantities of data, interpreting agent $A_{k}$ 's internals, solving sub-problems that the user has carved off, and so on. With this assistance the user is then able provide feedback to train the next agent $A_{k}$ (see Figure 2). Note that the task agent $A_{k-1}$ is trained to solve, assisting in the evaluation of outcomes on the task of $A_{k}$, is different from the task that $A_{k}$ is trained to solve.</p>
<p>While this kind of sequential training is conceptually clearer, in practice it might make more sense to train all of these agents jointly to ensure that they are being trained on the right distribution. Moreover, all of these agents may share model parameters or even be copies of the same agent instantiated as different players in an adversarial game.</p>
<p>Examples. As an example, consider the hypothetical fantasy author task: we want to train an agent $A$ to write a fantasy novel. Providing a reward signal to this agent is very difficult and expensive, because the user would have to read the entire novel and assess its quality. To aid this evaluation process, the user is assisted by an agent that provides auxiliary input: extracting a summary of the plotline, checking spelling and grammar, summarizing character development, assessing the flow of the prose, and so on. Each of these tasks is strictly simpler than writing a novel because they focus on only one aspect of the book and require producing substantially less text (e.g. in contrast to novel authorship, this evaluation assistance could be done by most educated humans). The tasks this assistant agent performs are in turn trained with reward modeling.</p>
<p>Another example is the academic researcher task: we want to train an agent to perform a series of experiments and write a research paper. To evaluate this research paper, we train another agent to review that the experiments were performed correctly, the paper is clear and well-written, interesting, novel, and accurately reflects the experimental results. While writing a stellar paper requires a lot of domain expertise, brilliance, and hard work, assessing the quality of a research result is often much easier and routinely done by a large network of peer reviewers.</p>
<p>Recursive reward modeling is also somewhat analogous to human organizations. Imagine a company in which every manager only needs to evaluate the performance of their reports, increasing and decreasing their salary accordingly. This evaluation is being assisted by other teams in the organization. The managers in turn get evaluated on the performance of their team. This scheme proceeds up to the CEO who provides instructions to the managers reporting to them. In this analogy, the user plugs into every part of the hierarchy: teaching individual employees how to perform their job, teaching managers how to evaluate their reports, and providing instructions to the CEO. If every employee of this company is very competent at their job, the whole company can scale to solve very complex and difficult problems that no human alone could solve or even evaluate on short timescales.</p>
<p>Discussion. In order for this recursive training procedure to scale, the task of agent $A_{k-1}$ needs to be a simpler task in a more narrow domain compared to the task of agent $A_{k}$. If evaluating outcomes is easier than producing behavior (Assumption 2), then recursive reward modeling would build up a hierarchy of agents that become increasingly more capable and can perform increasingly general tasks. As such, recursive reward modeling can be thought of as an instance of iterated amplification (Christiano et al., 2018) with reward modeling instead of supervised learning or imitation learning.</p>
<p>As $k$ increases, the user plays a smaller and smaller part of the overall workload of this evaluation process and relies more and more on the assistance of other agents. In essence, the user's feedback is becoming increasingly leveraged. We can imagine the user's contribution to be on an increasingly higher levels of abstraction or to be increasingly coarse-grained. Thus the user is leaving more and more details 'to be filled in' by automated systems once they are confident that the automated systems can perform these tasks competently, i.e. once the user trusts these systems.</p>
<p>How should the user decompose task evaluation? They need to assign evaluation assistance tasks that are simpler to the previous agent, and combine the result into an aggregated evaluation. This decomposition needs to be exhaustive: if we neglect to assess one aspect of the task outcome, then the new agent $A_{k}$ might optimize it in an arbitrary (i.e. undesirable) direction. This is another problem that we hope to solve with recursive reward modeling: We can have an agent $A_{2}$ propose a</p>
<p>decomposition of the task evaluation and have another agent $A_{1}$ critique it by suggesting aspects the decomposition is omitting. Alternatively, the feedback for the decomposition proposal could also be based on downstream real-world outcomes.</p>
<p>An important open question is whether errors accumulate: do the mistakes of the more narrow agent $A_{k-1}$ lead to larger mistakes in the training of agent $A_{k}$ ? Or can we set up the training process to be self-correcting such that smaller mistakes get dampened (e.g. using ensembles of agents, training agents to actively look for and counteract these mistakes, etc.)? If error accumulation can be bounded and reward modeling yields aligned agents, then the hierarchy of agents trained with recursive reward modeling can be argued to be aligned analogously to proving a statement about natural numbers by induction.</p>
<p>Analogy to complexity theory. In the reward modeling setup the agent proposes a behavior that is evaluated by the user. This is conceptually analogous to solving existentially quantified first-order logic formulas such as $\exists x . \varphi(x)$. The agent proposes a behavior $x$ and the user evaluates the quality of this behavior. For simplicity of this analogy, let us assume that the user's evaluation is binary so that it can be captured by the predicate $\varphi$.
With recursive reward modeling we can solve tasks that are analogous to more complicated first-order logic formulas that involve alternating quantifiers. For example, $\exists x \forall y . \varphi(x, y)$ corresponds to the next level of the recursion: agent $A_{2}$ proposes a behavior $x$ and agent $A_{1}$ responds with an assisting behavior $y$. The user then evaluates the assistance $y$ with respect to $x$ (training agent $A_{1}$ ) and the outcome $x$ with help of the assistance $y$ (training agent $A_{2}$ ). At recursion depth $k$ increases, we can target problems that involve $k$ alternating quantifiers.
When using polynomially bounded quantifiers and a formula $\varphi$ that can be evaluated in polynomial time, reward modeling is analogous to solving NP-complete problems: a nondeterministic execution (analogous to the agent) proposes a solution which can be 'evaluated' for correctness in deterministic polynomial time (by the user).
For example, finding a round trip in a given graph that visits every vertex exactly once (the Hamiltonian cycle problem) is NP-complete (Karp, 1972): it can take exponential time in the worst case with known algorithms to find a cycle, but given a cycle it can be verified quickly that every vertex is visited exactly once.
This analogy to complexity theory, first introduced by Irving et al. (2018), provides two important insights:</p>
<ol>
<li>It is widely believed that the complexity classes P and NP are not equal, which supports Assumption 2 that for a lot of relevant problems evaluation is easier than producing solutions.</li>
<li>Basically every formal statement that mathematicians care about can be written as a firstorder logic statement with a finite number of alternating quantifiers. This suggests that recursive reward modeling can cover a very general space of tasks.</li>
</ol>
<h1>4 Challenges</h1>
<p>The success of reward modeling relies heavily on the quality of the reward model. If the reward model only captures most aspects of the objective but not all of it, this can lead the agent to find undesirable degenerate solutions (Amodei et al., 2016; Lehman et al., 2018; Ibarz et al., 2018). In other words, the agent's behavior depends on the reward model in a way that is potentially very fragile.
Scaling reward modeling to harder and more complex tasks gives rise to a number of other challenges as well: is the amount of feedback required to learn the correct reward function affordable? Can we learn a reward function that is robust to a shift in the state distribution? Can we prevent the agent from finding loopholes in the reward model? How do we prevent unacceptable outcomes before they occur? And even if the reward model is correct, how can we train the agent to robustly produce behavior incentivized by the reward model?
Each of these challenges can potentially prevent us from scaling reward modeling. In the rest of this section, we elaborate on these challenges in more detail. We do not claim that this list of challenges is exhaustive, but hopefully it includes the most important ones. Section 5 discusses concrete approaches to mitigating these challenges; see Figure 3 for an overview. The goal of the research direction</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;">Approaches</th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">online feedback</td>
<td style="text-align: left;">$1,2,3$</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">off-policy feedback</td>
<td style="text-align: left;">3,4</td>
</tr>
<tr>
<td style="text-align: left;">1</td>
<td style="text-align: left;">leveraging existing data</td>
<td style="text-align: left;">1</td>
</tr>
<tr>
<td style="text-align: left;">2</td>
<td style="text-align: left;">hierarchical feedback</td>
<td style="text-align: left;">1</td>
</tr>
<tr>
<td style="text-align: left;">3</td>
<td style="text-align: left;">natural language</td>
<td style="text-align: left;">1,2</td>
</tr>
<tr>
<td style="text-align: left;">4</td>
<td style="text-align: left;">model-based RL</td>
<td style="text-align: left;">3,4</td>
</tr>
<tr>
<td style="text-align: left;">5</td>
<td style="text-align: left;">side-constraints</td>
<td style="text-align: left;">3,4</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">adversarial training</td>
<td style="text-align: left;">$3,4,5$</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">uncertainty estimates</td>
<td style="text-align: left;">$1,2,5$</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">inductive bias</td>
<td style="text-align: left;">$1,2,5$</td>
</tr>
</tbody>
</table>
<p>Figure 3: Challenges when scaling reward modeling and the approaches we discuss to address them. The rightmost column lists which challenge each approach is meant to address.
we advocate is to investigate these approaches in order to understand whether and how they can overcome these challenges.</p>
<h1>4.1 Amount of feedback</h1>
<p>In the limit of infinite data from the right distribution, we can learn the correct reward function with enough model capacity (in the extreme case using a lookup table). However, a crucial question is whether we can attain sufficient accuracy of the reward model with an amount of data that we can produce or label within a realistic budget. Ultimately this is a question of how well generalization works on the state distribution: the better our models generalize, the more we can squeeze out of the data we have.</p>
<p>It is possible that the agent alignment problem is actually easier for agents that have learned to be effective at sufficiently broad real world tasks if doing so requires learning high-level concepts that are highly related to user intentions that we want to teach (e.g. theory of mind, cooperation, fairness, self-models, etc.). If this is true, then the amount of effort to communicate an aligned reward function relative to these concepts could be much smaller than learning them from scratch.</p>
<p>On the other hand, agents which do not share human inductive biases may solve tasks in surprising or undesirable ways, as the existence of adversarial examples (Szegedy et al., 2013) demonstrates. This suggests that aligning an agent may require more than just a large quantity of labeled data; we may also need to provide our models with the the right inductive bias.</p>
<h3>4.2 Feedback distribution</h3>
<p>Machine learning models typically only provide meaningful predictions on inputs that come from the same distribution that they were trained on. However, we would like a reward model that is accurate off-policy, on states the agent has never visited. This is crucial (1) to encourage the agent to explore positive value trajectories it has not visited and (2) to discourage the agent from exploring negative value trajectories that are undesirable.</p>
<p>This problem is called distributional shift or dataset shift (Candela et al., 2009). This distributional shift problem also applies to the agent's policy model; a change in the observation distribution could make the policy output useless. However, this problem is more severe for the reward model and in some cases the policy can be recovered with finetuning if the reward model is still intact (Bahdanau et al., 2018).</p>
<p>It is unclear what a principled solution to this problem would be. In the absence of such a solution we could rely on out-of-distribution detection to be able to defer to a human operator or widening the training distribution to encompass all relevant cases (Tobin et al., 2017).</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 4: An example of gaming the reward model in Atari games. The fully trained reward model from the best seed is frozen and used to train an new agent from scratch. The plot shows the average true episode return according to the Atari reward (black) and average episode return according to the frozen reward model (green) during training. Over time the agent learns to exploit the reward model: the perceived performance (according to the reward model) increases, while the actual performance (according to the game score) plummets. Reproduced from Ibarz et al. (2018).</p>
<h1>4.3 Reward hacking</h1>
<p>Reward hacking ${ }^{3}$ is an effect that lets the agent get more reward than intended by exploiting loopholes in the process determining the reward (Amodei et al., 2016; Everitt et al., 2017). This problem is difficult because these loopholes have to be delineated from desired creative solutions like AlphaGo's move 37 (Metz, 2016).</p>
<p>Sources of undesired loopholes are reward gaming (Leike et al., 2017) where the agent exploits some misspecification in the reward function, and reward tampering (Everitt \&amp; Hutter, 2018) where the agent interferes with the process computing the reward.</p>
<p>Reward gaming Opportunities for reward gaming arise when the reward function incorrectly provides high reward to some undesired behavior (Clark \&amp; Amodei, 2016; Lehman et al., 2018); see Figure 4 for a concrete example. One potential source for reward gaming is the reward model's vulnerability to adversarial inputs (Szegedy et al., 2013). If the environment is complex enough, the agent might figure out how to specifically craft these adversarially perturbed inputs in order to trick the reward model into providing higher reward than the user intends. Unlike in most work on generating adversarial examples (Goodfellow et al., 2015; Huang et al., 2017), the agent would not necessarily be free to synthesize any possible input to the reward model, but would need to find a way to realize adversarial observation sequences in its environment.</p>
<p>Reward gaming problems are in principle solvable by improving the reward model. Whether this means that reward gaming problems can also be overcome in practice is arguably one of the biggest open questions and possibly the greatest weakness of reward modeling. Yet there are a few examples from the literature indicating that reward gaming can be avoided in practice. Reinforcement learning from a learned reward function has been successful in gridworlds (Bahdanau et al., 2018), Atari games (Christiano et al., 2017; Ibarz et al., 2018), and continuous motor control tasks (Ho \&amp; Ermon, 2016; Christiano et al., 2017).</p>
<p>Reward tampering Reward tampering problems can be categorized according to what part of the reward process is being interfered with (Everitt \&amp; Hutter, 2018). Crucial components of the reward process that the agent might interfere with include the feedback for the reward model (Armstrong, 2015; Everitt \&amp; Hutter, 2018), the observation the reward model uses to determine the current reward (Ring \&amp; Orseau, 2011), the code that implements the reward model, and the machine register holding the reward signal.</p>
<p>For example, Super Mario World allows the agent to execute arbitrary code from inside the game (Masterjun, 2014), theoretically allowing an agent to directly program a higher score for itself. Existing examples of tampering like this one are somewhat contrived and this may or may not be a problem in practice depending how carefully we follow good software design principles (e.g. to avoid buffer overflows).</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>In contrast to reward gaming discussed above, reward tampering bypasses or changes the reward model. This might require a different set of solutions; rather than increasing the accuracy of the reward model, we might have to strengthen the integrity of the software and hardware of the reward model, as well as the feedback training it.</p>
<h1>4.4 Unacceptable outcomes</h1>
<p>Currently, most research in deep reinforcement learning is done in simulation where unacceptable outcomes do not exist; in the worst case the simulation program can be terminated and restarted from an initial state. However, when training a reinforcement learning agent on any real-world task, there are many outcomes that are so costly that the agent needs to avoid them altogether. For example, there are emails that a personal assistant should never write; a physical robot could take actions that break its own hardware or injure a nearby human; a cooking robot may use poisonous ingredients; and so on.</p>
<p>Avoiding unacceptable outcomes has two difficult aspects. First, for complex tasks there are always parts of the environment that are unknown and the agent needs to explore them safely (García \&amp; Fernández, 2015). Importantly, the agent needs to learn about unsafe states without visiting them. Second, the agent needs to react robustly to perturbations that may cause it to produce unacceptable outcomes unintentionally (Ortega et al., 2018) such as distributional changes and adversarial inputs (Szegedy et al., 2013; Huang et al., 2017).</p>
<h3>4.5 Reward-result gap</h3>
<p>The reward-result gap is exhibited by a difference between the reward model and the reward function that is recovered with perfect inverse reinforcement learning ( $\mathrm{Ng} \&amp;$ Russell, 2000) from the agent's policy (the reward function the agent seems to be optimizing). Even if we supply the agent with a correctly aligned reward function, the resulting behavior might still be unaligned because the agent may fail to converge to an optimal policy: even provably Bayes-optimal agents may fail to converge to the optimal policy due to a lack of exploration (Orseau, 2013; Leike \&amp; Hutter, 2015).
Reasons for the reward-result gap are plentiful: rewards might be too sparse, poorly shaped, or of the wrong order of magnitude; training may stall prematurely due to bad hyperparameter settings; the agent may explore insufficiently or produce unintended behavior during its learning process; the agent may face various robustness problems (Leike et al., 2017; Ortega et al., 2018) such as an externally caused change in the state space distribution or face inputs crafted by an adversary (Huang et al., 2017). Depending on the nature of the reward-result gap, the reward model might need to be tailored to the agent's specific shortcomings (e.g. be shaped away from unsafe states) rather than just purely capturing the human's intentions.</p>
<h2>5 Approaches</h2>
<p>This section discusses a number of approaches that collectively may help to mitigate the problems discussed in Section 4. These approaches should be thought of as directions to explore; more research is needed to figure out whether they are fruitful.</p>
<h3>5.1 Online feedback</h3>
<p>Preliminary experiments show failure modes when the reward model is not trained online, i.e. in parallel with the agent (Christiano et al., 2017; Ibarz et al., 2018). In these cases the agent learns to exploit reward models that are frozen. Because there is no additional user feedback, loopholes in the reward model that the agent discovers cannot be corrected.</p>
<p>If we provide the agent with reward feedback online, we get a tighter feedback loop between the user's feedback and the agent's behavior. This allows the reward model to be adapted to the state distribution the agent is visiting, mitigating some distributional shift problems. Moreover, with online feedback the user can spot attempts to hack the reward model and correct them accordingly. Ideally, we would like the agent to share some responsibility for determining when feedback is needed, for instance based on uncertainty estimates (Section 5.9), since otherwise providing relevant feedback in a timely manner could be prohibitively expensive.</p>
<h1>5.2 Off-policy feedback</h1>
<p>When training the agent with feedback on its behavior, this feedback is only reactive, based on outcomes that have already occurred. To prevent unacceptable outcomes and reward hacking, we need to be able to communicate that certain outcomes are undesirable before they occur. This requires the reward model to be accurate off-policy, i.e. on states the agent has never visited (Everitt et al., 2017). If off-policy feedback is used in conjunction with model-based RL (Section 5.6), the agent can successfully avoid unsafe behavior that has never occurred.
The user could proactively provide off-policy feedback in anticipation of potential pitfalls (Abel et al., 2017). Off-policy feedback could be elicited by using a generative model of the environment to create hypothetical scenarios of counterfactual events. However, generative modelling of states the agent has never visited might be very difficult because of the incurred distributional shift; the resulting videos might miss important details or be incomprehensible to humans altogether. Therefore it might be more feasible to provide off-policy feedback on an abstract level, for example using natural language (Yeh et al., 2018). This is analogous to how humans can learn about bad outcomes through story-telling and imagination (Riedl \&amp; Harrison, 2016).</p>
<h3>5.3 Leveraging existing data</h3>
<p>A large volume of human-created video data and prose is already readily available. Most of this data currently does not have high-quality text annotations and thus cannot be directly used as reward labels. Nevertheless, it contains a lot of useful information about human intentions (Riedl \&amp; Harrison, 2016). There are at least two approaches to leverage this existing data: using unsupervised learning (such as unsupervised pretraining or third-person imitation learning; Stadie et al., 2017) or by manually annotating it. ${ }^{4}$</p>
<h3>5.4 Hierarchical feedback</h3>
<p>The same arguments that support hierarchical RL (Dayan \&amp; Hinton, 1993; Sutton et al., 1999; Vezhnevets et al., 2017) also encourage having a hierarchical decomposition of the reward model. This would allow the user to provide both low-level and high-level feedback. Both hierarchical RL and hierarchical reward models should be quite natural to combine: if the temporal hierarchies between agent and reward model align, then at each level of the hierarchy the reward model can train the corresponding level of the agent. This might help bypass some very difficult long-term credit assignment problems.
For example, recall the fantasy author task from Section 3.2. The low-level feedback would include spelling, fluency, and tone of language while high-level feedback could target plot and character development that cannot be provided on a paragraph level.</p>
<h3>5.5 Natural language</h3>
<p>Since we want agents to be able to pursue and achieve a wide variety of goals in the same environment and be able to specify them in a way that is natural to humans, we could model the reward function as conditioned on natural language instructions (Bahdanau et al., 2018). These natural language instructions can be viewed as human-readable task labels. Moreover, they provide a separate privileged channel that should be easier to protect and harder to spoof than any instructions that are received through the observation channel.
In addition to providing task labels, we could also make natural language a more central part of the agent's architecture and training procedure. This has a number of advantages.</p>
<ol>
<li>
<p>Natural language is a natural form of feedback for humans. If we can learn to translate natural language utterances into the rigid format required for the data set the reward model is trained on, this would allow users to give feedback much more efficiently.
<sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
</li>
<li>
<p>Natural language has the potential to achieve better generalization if the latent space is represented using language (Andreas et al., 2018) and possibly generalize in a way that is more predictable to humans. This might also help to mitigate distributional problems for the reward model (Section 4.2): if the training distribution is reasonably dense in the space of natural language paragraphs, this might make out-of-distribution inputs very rare.</p>
</li>
<li>Natural language might lead to substantially better interpretability. Especially for abstract high-level concepts, natural language might be much better suited than visual interpretability techniques (Olah et al., 2018). However, by default the reward model's representations might not correspond neatly with short natural language expressions and will probably need to be trained particularly for this target (without producing rationalizations).</li>
</ol>
<h1>5.6 Model-based RL</h1>
<p>A model-based RL agent learns an explicit model of the environment which it can use with a planning algorithm such as Monte Carlo tree search (Abramson, 1987; Kocsis \&amp; Szepesvári, 2006). If we are training a model-based agent, the reward model can be part of the search process at planning time. This allows the agent to use off-policy reward estimates, estimated for actions it never actually takes, provided that the reward model is accurate off-policy (Section 5.2). This has a number of advantages:</p>
<ol>
<li>The agent can avoid unacceptable outcomes (Section 4.4) by discovering them during planning.</li>
<li>The agent's model could be used to solicit feedback from the user for outcomes that have not yet occured.</li>
<li>The agent can adapt to changes in the reward model more quickly because it can backup these changes to value estimates using the model without interaction with the environment.</li>
<li>Model-based approaches enable principled solutions to the reward tampering problem (Section 4.3) by evaluating future outcomes with the current reward model during planning (Everitt, 2018, Part II). Agents that plan this way have no incentive to change their reward functions (Schmidhuber, 2007; Omohundro, 2008), nor manipulate the register holding the reward signal (Everitt, 2018, Sec. 6.3).</li>
</ol>
<h3>5.7 Side-constraints</h3>
<p>In addition to learning a reward function, we could also learn side-constraints for low-level or highlevel actions (options; Sutton et al., 1999) to prevent unacceptable outcomes. Blocking actions can be more effective than discouraging them with large negative reward since negative rewards could be compensated by larger rewards later (such as in the case of reward hacking). This problem could be amplified by errors in the agent's model of the world.
The same techniques described here for training a reward model should apply to train a model that estimates side-constraints and blocks low-level actions (Saunders et al., 2018) or enforces constraints during policy updates (Achiam et al., 2017). The main downside of this technique is that it puts additional burden on the human because they have to understand which actions can lead to unacceptable outcomes. Depending on the domain, this might require the human to be assisted by other agents. These agents could in turn be trained using recursive reward modeling (Section 3.2).</p>
<h3>5.8 Adversarial training</h3>
<p>To mitigate the effect of adversarially crafted inputs to neural networks (Szegedy et al., 2013), so far the empirically most effective strategy has been adversarial training: training the model explicitly on adversarially perturbed inputs (Madry et al., 2017; Uesato et al., 2018; Athalye et al., 2018).
However, it is unclear how to define adversarial perturbation rigorously in a general way (Brown et al., 2018; Gilmer et al., 2018). To cover more general cases, we could train agents to explicitly discover weaknesses in the reward model and opportunities for reward hacking as well as the minimal perturbation that leads to an unacceptable outcome (Anonymous, 2019c). This is analogous to red teams, teams whose objective is to find attack strategies (e.g. security vulnerabilities) that an adversary might use (Mulvaney, 2012).</p>
<p>The discovered failure cases can then be reviewed by the user and added to the feedback dataset. This might mean higher data requirements; so even if adversarial training fixes the problem, it might push the data requirements beyond affordable limits.</p>
<h1>5.9 Uncertainty estimates</h1>
<p>Another desirable feature of the reward model is an appropriate expression of uncertainty regarding its outputs. Improving uncertainty estimates brings two benefits:</p>
<ol>
<li>During training, it can help automate the process of soliciting feedback about the most informative states (Krueger et al., 2016; Schulze \&amp; Evans, 2018) using active learning (Settles, 2012).</li>
<li>The agent can defer to the human or fall back to risk-averse decision making when uncertainty is large, for instance on inputs that do not resemble the training distribution (Hendrycks \&amp; Gimpel, 2017).</li>
</ol>
<p>A number of recent works develop scaleable approximate Bayesian methods for neural networks, beginning with Graves (2011), Blundell et al. (2015), Kingma et al. (2015), Hernández-Lobato \&amp; Adams (2015), and Gal \&amp; Ghahramani (2016). So far model ensembles provide a very strong baseline (Lakshminarayanan et al., 2017). Bayesian methods untangle irreducible uncertainty from 'epistemic' uncertainty about which parameters are correct, which decreases with the amount of data (Kendall \&amp; Gal, 2017); this distinction can help with active learning (Gal et al., 2017b).</p>
<p>Other works aim to calibrate the predictions of neural networks (Guo et al., 2017), so that their subjective uncertainty corresponds with their empirical frequency of mistakes. While Bayesian methods can help with calibration (Gal et al., 2017a), they are insufficient in practice for deep neural networks (Kuleshov et al., 2018). Well-calibrated models could engage risk-averse decision making, but handling out-of-distribution states reliably would require higher quality uncertainty estimates than current deep learning techniques can provide (Shafaei et al., 2018).</p>
<h3>5.10 Inductive bias</h3>
<p>Finally, a crucial aspect of reward modeling is the inductive bias of the reward model. Since we cannot train the reward model and the agent on all possible outcomes, we need it to generalize appropriately from the given data (Zhang et al., 2017, 2018a). The success of deep learning has been attributed to inductive biases such as distributed representations and compositionality, which may also be necessary in order to defeat the 'curse of dimensionality' (Bengio et al., 2013). Yet further inductive biases are necessary to solve many tasks; for instance, convolutional neural networks (LeCun et al., 1990) vastly outperform multilayer perceptrons in computer vision applications because of their spatial invariance.</p>
<p>Solving reward modeling may require non-standard inductive biases; for instance modern deep networks typically use piece-wise linear activation functions (Nair \&amp; Hinton, 2010; Glorot et al., 2011; Goodfellow et al., 2013; Xu et al., 2015), which generalize linearly far from training data (Goodfellow et al., 2015), meaning estimated reward would go to positive or negative infinity for extreme inputs. The inductive bias of deep models can be influenced by the architecture, activation functions, and training procedure. A growing body of work targets systematic generalization in deep models. Examples include modularity (Anonymous, 2019b), recursion (Cai et al., 2017), graph structure (Battaglia et al., 2018) or natural language (Andreas et al., 2018) in the latent space, differentiable external memory (Graves et al., 2016), or neural units designed to perform arbitrary arithmetic operations (Trask et al., 2018).</p>
<h2>6 Establishing trust</h2>
<p>Suppose our research direction is successful and we figure out how to train agents to behave in accordance with user intentions. How can we be confident that the agent we are training is indeed sufficiently aligned? In other words, how can we be confident that we have overcome the challenges from Section 4 and that the agent's behavior sufficiently captures human intentions? This requires additional techniques that allow us to gain trust in the agents we are training.</p>
<p><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 5: Alignment of learned reward functions in 9 Atari games: Scatterplot showing the correlation of the reward learned from user preferences ( $y$-axis) with the true Atari reward ( $x$-axis) averaged over 1000 timesteps. For a fully aligned reward function, all points would be on a straight line. In these experiments the reward model is well-aligned in some games like Beamrider, Hero, and Q*bert, and poorly aligned in others like Private Eye, Breakout, and Mondezuma's Revenge. Reproduced from Ibarz et al. (2018).</p>
<p>An ambitious goal is to enable the production of safety certificates, artifacts that serve as evidence to convince a third party to trust our system. These safety certificates could be used to prove responsible technology development, defuse competition, and demonstrate compliance with regulations. A safety certificate could take the form of a score on a secret test suite held by a third party, evidence of interpretability properties, or a machine-checkable formal proof of correctness with respect to some established specification, among others. A few general approaches for building trust in our models are discussed below.</p>
<p>Design choices. Separating learning the objective from learning the behavior allows us to achieve higher confidence in the resulting behavior because we can split trust in the reward model from trust in the policy. For example, we can measure how well the reward function aligns with the task objective by evaluating it on the user's feedback (see Figure 5). If we understand and trust the reward model, we know what the agent is 'trying' to accomplish. If Assumption 2 is true, then the reward model should be easier to interpret and debug than the policy.
Another design choice that could increase trust in the system is to split our policy into two parts: a plan generator and a plan executor. The plan generator produces a human-readable plan of the current course of action. This plan could be very high-level like a business plan or a research proposal, or fairly low-level like a cooking recipe. This plan can then optionally be reviewed and signed off by the user. The plan executor then takes the plan and implements it.
Clean, well-understood design choices on training setup, model architecture, loss function, and so on can lead to more predictable behavior and thus increase our overall confidence in the resulting system (as opposed to e.g. training a big blob of parameters end-to-end). Especially if we manage to formally specify certain safety properties (Orseau \&amp; Armstrong, 2016; Krakovna et al., 2018), we can then make them an explicit part of our agent design.</p>
<p>Testing. Evaluation on a separate held-out test set is already common practice in machine learning. For supervised learning, the performance of a trained model is estimated by the empirical risk on</p>
<p>a held-out test set which is drawn from the same data distribution. This practise can readily be applied to reward model (Ibarz et al., 2018) and policy, e.g. on a set of specifically designed simulated environments (Leike et al., 2017) or even adversarially where an attacker explicitly tries to cause misbehavior in the agent (Anonymous, 2019c).</p>
<p>Interpretability. Interpretability has been defined as the ability to explain or to present in understandable terms to a human (Doshi-Velez \&amp; Kim, 2017). Currently widely used deep neural networks are mostly black boxes, and understanding their internal functionality is considered very difficult. Nevertheless, recent progress provides reason for optimism that we will be able to make these black boxes increasingly transparent. This includes preliminary work on visualizing the latent state space of agents using t-SNE plots (Zahavy et al., 2016; Jaderberg et al., 2018), examining what agents attend to when they make decisions (Greydanus et al., 2018), evaluating models' sensitivity to the presence/intensity of high-level human concepts (Kim et al., 2017), optimizing a model to be more interpretable with humans in the loop (Lage et al., 2018), translating neural activations into natural language on tasks also performed by humans (Andreas et al., 2017), and combining different interactive visualization techniques (Olah et al., 2018), to name only a few.</p>
<p>Formal verification. Recent progress on model checking for neural networks opens the door for formal verification of trained models (Katz et al., 2017). The size of verified models has been pushed beyond MNIST-size to over a million parameters (Dvijotham et al., 2018b; Wong et al., 2018), which indicates that verifying practically sized RL models might soon be within reach. If formal verification can be scaled, we could attempt to verify properties of policies (Bastani et al., 2018) and reward functions with respect to a high-level specification, including off-switches, side-effects, and others mentioned in Section 3.1. If Assumption 1 from Section 1 is true, then this specification does not have to be manually written, but instead can be provided by a separately learned model. However, in this case a formal correctness proof is only as useful as this learned specification is accurate.
To make the verification task easier, our models could be trained to be more easily verifiable (Dvijotham et al., 2018a). However, this opens the door for degenerate solutions that exploit loopholes in the learned specification. This is analogous to problems with reward hacking (Section 4.3) which train a policy to optimize a frozen reward model (Figure 4). Circumventing this problem could be done using the same techniques that have been successful for reward hacking, such as learning the specification online using user feedback (Section 5.1).</p>
<p>Theoretical guarantees. Finally, even more ambitious would be the development of theoretically well-founded scalable learning algorithms that come with probably approximately correct (Dziugaite \&amp; Roy, 2017) or sample complexity guarantees, capacity statements, well-calibrated uncertainty estimates, etc. (Veness et al., 2017). Unfortunately, currently there is a dire lack of any such guarantees for the popular deep neural network architectures and training techniques.</p>
<h1>7 Alternatives for agent alignment</h1>
<p>The research direction we outline in this paper is not the only possible path to solve the agent alignment problem. While we believe it is currently the most promising one to explore, it is not guaranteed to succeed. Fortunately there are a number of other promising directions for agent alignment. These can be pursued in parallel or even combined with each other. This section provides an overview and explains how our approach relates to them. Our list is not exhaustive; more directions are likely to be proposed in the future.</p>
<h3>7.1 Imitation learning</h3>
<p>One strategy to train aligned agents could be from imitating human behavior (Pomerleau, 1991; Abbeel \&amp; Ng, 2004; Ho \&amp; Ermon, 2016; Finn et al., 2016). An agent imitating aligned human behavior sufficiently well should be aligned as well. The following caveats apply:</p>
<ul>
<li>
<p>Amount of data. While feedback can often be provided by non-experts, the data for human imitation has to be provided by experts on the task. This might be much more expensive data and it is not clear if we need more or less than for reward modeling.</p>
</li>
<li>
<p>Cognitive imitation. It is possible that a lot of cognitively demanding tasks that humans do rely on very high-level intuition, planning, and other cognitive processes that are poorly reflected in human actions. For example, a crucial insight for solving a problem might be gained from drawing an analogy with a different problem encountered in a different domain. This might be hard to replicate and predict from data about human actions alone.</p>
</li>
<li>Generalization. In order to be useful, our agent trained with imitation learning needs to showcase persistently high-quality behavior, even in the face of novel situations. Analogous to Assumption 2, generalizing learned reward functions might be easier than generalizing behavior (Bahdanau et al., 2018).</li>
<li>Performance. It is generally difficult to outperform humans using imitation learning alone (Hester et al., 2018): even a perfect imitator can only perform as well as the source it is imitating; superhuman performance typically comes from executing human action sequences faster and more reliably by smoothing out inconsistencies in human behavior (Aytar et al., 2018).</li>
</ul>
<p>Therefore imitation learning is unlikely to be competitive with other strategies to train agents in the longer term. However, it might be sufficient to act as a 'stepping stone': agents trained with imitation learning might act as 'research assistants' and help scale up other alignment efforts. Therefore it should be considered as a strong alternative to our research strategy.</p>
<h1>7.2 Inverse reinforcement learning</h1>
<p>We can view a reinforcement learning algorithm as a mapping from a reward function to behavior. The inverse of that mapping takes agent behavior as input and produces a reward function; this is known as inverse reinforcement learning (IRL; Russell, 1998; Ng \&amp; Russell, 2000). In this sense, inverse reinforcement learning can be viewed as one approach to reward modeling that takes feedback in the form of trajectories of behavior. However, taken as it is, it had two shortcomings:</p>
<ol>
<li>IRL is an under-constrained problem because the reward function is not uniquely identifiable (not even up to affine-linear transformation) from behavior alone ( Ng \&amp; Russell, 2000); for example, $R=0$ is always a solution. If we assume the human is fully rational and the agent can design a sequence of tasks for the human, then the reward function can be identified (Amin et al., 2017). Even some assumptions about the human's rationality can be relaxed (Evans et al., 2016), but in full generality the inverse reinforcement learning problem becomes impossible to solve (Armstrong \&amp; Mindermann, 2018).</li>
<li>It assumes the human is acting to optimize their reward directly, even when this is an inefficient way of communicating their preferences. For instance, it is much easier for a human to state 'I would like you to make me coffee every morning at 8 am' than it is for the human to make themselves coffee at 8 am several days in a row.</li>
</ol>
<h3>7.3 Cooperative inverse reinforcement learning</h3>
<p>Motivated by this second shortcoming of IRL, Hadfield-Menell et al. (2016) propose cooperative inverse reinforcement learning (CIRL). CIRL is a formal model of reward modeling as a two player game between a user and an agent which proceeds as follows.</p>
<ol>
<li>The user and the agent begin with a shared prior over the user's reward function,</li>
<li>the user then observes their reward function, and finally</li>
<li>both user and agent execute policies to optimize the user's reward function.</li>
</ol>
<p>An optimal solution to a CIRL game would use the common knowledge of the user and the agent to compute a policy for the agent (to be executed in step 3), and a mapping from reward function to policy for the user. Then upon observing their reward function in step 2, the user should select the corresponding policy for them to execute in step 3. Both the user and the agent have to choose behaviors which trade off between (1) communicating the user's reward function to the agent and (2) directly maximizing the user's expected reward.</p>
<p>We make two observations about CIRL as an approach to agent alignment that highlight that CIRL abstracts away from some important details. First, the performance of a CIRL algorithm will depend</p>
<p>on the quality of the prior over reward functions. In essence, CIRL replaces the problem of specifying a reward function with specifying a prior over reward functions. Second, computing the optimal solution to the CIRL problem is not realistic, since we cannot prescribe exactly how the user should interact with the agent. In other words, an efficient solution to a CIRL game might employ a strategy that transmits the parameters from the user to the agent, followed by a normal RL algorithm executed by both the user and the agent (since the reward is now fully observable to both). But if the user were able to observe their reward function, they could just specify this to an RL agent directly. In other words, one of the difficulties of agent alignment is that the reward function is not directly available to the user in the first place: users are usually not very aware of all of their preferences, and it might instead be easier for them to communicate through revealed preferences (Samuelson, 1938).</p>
<p>Nevertheless, CIRL incorporates two important insights into the alignment problem that also motivate our research direction:</p>
<ol>
<li>Constructing agents to optimize a latent reward function can help align them on tasks where we cannot consistently provide reward feedback about all state-action pairs as the agent is visiting them.</li>
<li>A key challenge of the agent alignment problem is finding efficient ways to communicate the user's intentions to learning agents.</li>
</ol>
<h1>7.4 Myopic reinforcement learning</h1>
<p>Myopic RL agents only maximize reward in the present timestep instead of a (discounted) sum of future rewards. This means that they are more short-sighted and thus not incentivized to execute long-term plans or take actions that are bad in the short-term in order to get a long-term benefit. In particular, myopic RL agents might be less prone to some of the design specification problems mentioned in Section 3.1, since causing them might take several time-steps to pay off for the agent.
There are two main myopic RL algorithms. TAMER (Knox \&amp; Stone, 2009; Knox, 2012; Warnell et al., 2017) is a collection of algorithms that learn a policy from human value feedback, i.e. take actions that maximize expected feedback in the next step (possibly with short temporal smoothing). COACH (MacGlashan et al., 2017; Arumugam et al., 2018) is an algorithm that trains a policy from feedback in the form of an advantage function (Sutton \&amp; Barto, 2018).
In contrast to imitation learning, the user does not have to be able to produce the desired behavior, just be able to reward the individual actions that bring it about. For example, using TAMER or COACH, a user could teach an agent to perform a backflip without being able to do one themself. However, while myopic RL may increase alignment, is also comes with performance drawbacks. Training myopic RL agents puts the burden of solving the credit assignment problem onto the user, limiting the agent's potential for ingenuity and thus performance, and also leaving the user responsible for avoiding long-term negative consequences.
Despite these limits, myopic RL agents might be sufficient for some tasks where credit assignment is reasonably easy for humans. They might also be used as building blocks in more capable training regimes, for instance in iterated amplification (Christiano et al., 2018).</p>
<h3>7.5 Imitating expert reasoning</h3>
<p>Another alternative is to train a model to imitate expert reasoning. The imitation can happen at a level of granularity decided by the expert and could include 'internal' reasoning steps that the expert would not typically perform explicitly. This expert reasoning can then be improved and accelerated (Christiano et al., 2018; Evans et al., 2018; Stuhlmüller, 2018).
The basic idea is best illustrated with a question answering system. The input to the system is a question $Q$ and its output an answer $A$. For simplicity we can treat both $Q$ and $A$ as natural language strings. The system can call itself recursively by asking subquestions $Q_{1}, \ldots, Q_{k}$, receiving their answers $A_{1}, \ldots, A_{k}$, and composing them into the answer $A$.
For example, consider the question $Q$ 'How many pineapples are there in Denmark?' To give an approximate answer, we could make a Fermi estimate by asking the subquestions 'What is the population of Denmark?', 'How many pineapples does the average Dane consume per year?', and</p>
<p>'How long are pineapples stored?' These subquestions are then answered recursively and their answers can be composed into an answer to the original question $Q$.
We could train a model to answer questions $Q$ recursively by using the same reasoning procedure as the expert using imitation learning (Section 7.1). This model can then be improved using a variety of methods:</p>
<ul>
<li>Running many copies of this model in parallel and/or at greater speed.</li>
<li>Training a new model to predict answers to questions without having to expand the subquestions, akin to using a value network to the estimate the result of a tree search (Anthony et al., 2017; Silver et al., 2017).</li>
<li>Making the expert reasoning more coherent under reflection. For example, by searching for inconsistencies in the expert's reasoning and resolving them.</li>
</ul>
<p>If we believe expert reasoning is aligned with the user, then we could hope that the resulting improved model is also aligned. This training procedure aims to achieve better interpretability and greater trust in the resulting agents than recursive reward modeling (Section 3.2). However, learning expert reasoning might not be economically competitive with recursive reward modeling, depending on how good the expert's reasoning is and whether Assumption 2 holds for the task at hand.
Even though both are an instance of the more general framework of iterated amplification (Christiano et al., 2018), recursive reward modeling as described in Section 3.2 does not try to model expert reasoning explicitly. Instead, recursive reward modeling only requires users to evaluate outcomes. Nevertheless, it relies on decomposition of the evaluation task which has similarities to the decompositional reasoning described here. When using recursive reward modeling users have the option to provide feedback on the cognitive process that produced outcomes, but they are not required to do so. Moreover, this feedback might be difficult to provide in practice if the policy model is not very interpretable.</p>
<h1>7.6 Debate</h1>
<p>Irving et al. (2018) describe an idea for agent alignment that involves a two-player zero-sum game in which both players are debating a question for the user. The two players take turns to output a short statement up to a turn limit. At the end of the game the user reads the conversation transcript and declares the player who contributed the most true and useful statements the winner.
The debate proposal involves training an agent with self play (Silver et al., 2016) on this debate game. In order to become aligned, this agent needs to be trained in a way that it converges to a Nash equilibrium in which both instances of the agent try to be helpful to the user. The central assumption of debate is that it is easier for the agent to tell the truth than it is to lie. If this assumption holds, then the dynamics of the game should incentivize the agent to provide true and useful statements.
The authors provide initial experiments on the MNIST dataset in which the debating agents manage to boost the accuracy of a sparse classifier that only has access to a few of the image's pixels. While these initial experiments are promising, more research is needed in order to determine whether debate is a scalable alignment approach. We need more empirical evidence to clarify, among others, the following two questions.</p>
<ol>
<li>Does the central assumption of debate hold outside domains of easily fact-checkable statements?</li>
<li>Can the humans accurately judge the debate even if the debaters have superior persuasion and deception ability?</li>
</ol>
<h3>7.7 Other related work</h3>
<p>Many of the practical challenges to reward modeling we raise here have already been discussed by Amodei et al. (2016): safe exploration, distributional shift, side-effects, and reward hacking. In particular, the authors highlight what they call the scalable oversight problem, how to train an RL agent with sparse human feedback. This can be understood as a more narrow version of the alignment problem we are aiming to solve here. In a similar spirit, Taylor et al. (2016) survey a number of</p>
<p>high-level open research questions on agent alignment. Most closely related to our approach are what the authors call informed oversight (building systems that help explain outcomes), generalizable environmental goals (defining objective functions in terms of environment states), and averting instrumental incentives (preventing the system from optimizing for certain undesirable subgoals).
Soares \&amp; Fallenstein (2017) outline a research agenda of a very different flavor. Their research problems are quite paradigm-agnostic and instead concern the theoretical foundations of mathematical agent models. In particular, many of their problems aim to address perceived difficulties in applying current notions of optimal behavior to agents which are part of their environment (Orseau \&amp; Ring, 2012) and thus may not remain cleanly delineated from it (Demski \&amp; Garrabrant, 2018). The authors seek the formal tools to ask questions about or relevant to alignment in theory, such as when provided with a halting oracle (Hutter, 2005). These formal tools could be necessary for formal verification of agents designing upgraded versions of themselves. Yet while there has been some of progress on this research agenda (Barasz et al., 2014; Leike et al., 2016; Garrabrant et al., 2016; Everitt, 2018), some questions turned out to be quite difficult. But even if we had formal solutions to the problems put forth by Soares \&amp; Fallenstein, there would still persist a gap to transfer these solutions to align agents in practice. For now, answers to these research questions should be understood more as intuition pumps for practical alignment questions rather than direct solutions themselves (Garrabrant, 2018).
See Everitt et al. (2018) for more in-depth survey and literature review.</p>
<h1>8 Discussion</h1>
<p>Summary. The version of the agent alignment problem we are aiming to solve involves aligning a single agent to a single user (Section 2). Instead of attempting to learn the entire preference payload, we outline an approach for enabling the user to communicate their intentions to the agent for the task at hand so that it allows them to trust the trained agent.
Our research direction for agent alignment is based on scaling reward modeling (Section 3). This direction fits well into existing efforts in machine learning because it can benefit from advances in the state of the art in supervised learning (for the reward model) and reinforcement learning (for the policy). Building on previous work (Section 7), we provide significantly more detail, including the main challenges (Section 4) and concrete approaches to mitigate these challenges (Section 5) and to establish trust in the agents we train (Section 6). In essence, this document combines existing efforts on AI safety problems by providing one coherent narrative around how solving these problems could enable us to train aligned agents beyond human-level performance.</p>
<p>Concrete research projects. Our research direction is 'shovel-ready' for empirical research today. We can set up experiments with deep reinforcement learning agents: getting empirical data on the severity of the challenges from Section 4; prototyping solution ideas from Section 5; scaling reward modeling to more difficult tasks; pushing the frontiers on (adversarial) testing, interpretability, formal verification, and the theory of deep RL. Moreover, we can readily use any existing RL benchmarks such as games or simulated environments that come with pre-programmed reward functions: By hiding this reward function from the algorithm we can pretend it is unavailable, but still use it for synthetically generated user feedback (Christiano et al., 2017) as well as the evaluation of the learned reward model (Ibarz et al., 2018).</p>
<p>Outlook. There is enormous potential for ML to have a positive impact on the real world and improve human lives. Since most real-world problems can be cast in the RL framework, deep RL is a particularly promising technique for solving real-world problems. However, in order to unlock its potential, we need to train agents in the absence of well-specified reward functions. Just as proactive research into robustness of computer vision systems is essential for addressing vulnerabilities to adversarial inputs, so could alignment research be key to getting ahead of future bottlenecks to the deployment of ML systems in complex real-world domains. For now, agent alignment research is still in its early stages, but we believe that there is substantial reason for optimism. While we expect to face challenges when scaling reward modeling, these challenges are concrete technical problems that we can make progress on with targeted research.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{4}$ For example, the total length of all movies on the Internet Movie Database longer than 40 min is about 500,000 hours (Peter, 2014). Assuming a 10x overhead and $\$ 10$ per hour, this data would cost ca. $\$ 50$ million to annotate.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>