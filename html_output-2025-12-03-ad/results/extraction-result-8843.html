<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-8843 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-8843</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-8843</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-154.html">extraction-schema-154</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models being evaluated on strict logical reasoning tasks, including details about the models, the logical reasoning tasks or benchmarks, the methods or approaches used to improve logical reasoning, the performance or results, comparisons to baselines or ablations, and any reported limitations or failure cases.</div>
                <p><strong>Paper ID:</strong> paper-258865989</p>
                <p><strong>Paper Title:</strong> <a href="https://export.arxiv.org/pdf/2305.15408v3.pdf" target="_blank">Towards Revealing the Mystery behind Chain of Thought: A Theoretical Perspective</a></p>
                <p><strong>Paper Abstract:</strong> Recent studies have discovered that Chain-of-Thought prompting (CoT) can dramatically improve the performance of Large Language Models (LLMs), particularly when dealing with complex tasks involving mathematics or reasoning. Despite the enormous empirical success, the underlying mechanisms behind CoT and how it unlocks the potential of LLMs remain elusive. In this paper, we take a first step towards theoretically answering these questions. Specifically, we examine the expressivity of LLMs with CoT in solving fundamental mathematical and decision-making problems. We start by giving an impossibility result showing that bounded-depth Transformers are unable to directly produce correct answers for basic arithmetic/equation tasks unless the model size grows super-polynomially with respect to the input length. In contrast, we then prove by construction that autoregressive Transformers of constant size suffice to solve both tasks by generating CoT derivations using a commonly-used math language format. Moreover, we show LLMs with CoT are capable of solving a general class of decision-making problems known as Dynamic Programming, thus justifying its power in tackling complex real-world tasks. Finally, extensive experiments on four tasks show that, while Transformers always fail to predict the answers directly, they can consistently learn to generate correct solutions step-by-step given sufficient CoT demonstrations.</p>
                <p><strong>Cost:</strong> 0.017</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e8843.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e8843.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models being evaluated on strict logical reasoning tasks, including details about the models, the logical reasoning tasks or benchmarks, the methods or approaches used to improve logical reasoning, the performance or results, comparisons to baselines or ablations, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Arithmetic (Arithmetic(n,p))</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Arithmetic expression evaluation over finite field Z_p (Arithmetic(n,p))</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Evaluation of arithmetic expressions (numbers, +, -, ×, ÷, brackets) on a finite field Z_p; studied both theoretically and empirically, with Chain-of-Thought (CoT) derivations as the target intermediate representation.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Autoregressive Transformer (minGPT-style)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Standard autoregressive Transformer (minGPT implementation) with token embeddings, causal attention, GeLU activations; experiments used hidden dimension d=256, 4 attention heads, FFN hidden size 1024, depths L varied; trained with AdamW on synthetic datasets (1M train / 0.1M test).</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>hidden_dim=256, heads=4, FFN=1024, depth L varied (1–5 in experiments); parameter count not specified</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_name</strong></td>
                            <td>Arithmetic expression evaluation (Arithmetic(n,p))</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_description</strong></td>
                            <td>Compute the value of arithmetic expressions containing integer tokens and operators (+, −, ×, ÷) and brackets; implemented in experiments over the finite field Z_p (p=11) so numbers are discrete tokens.</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_approach</strong></td>
                            <td>Train-to-generate Chain-of-Thought (CoT) derivations: datasets constructed as <problem, CoT steps, answer> and models trained to autoregressively generate intermediate steps and final answer; baseline is direct prediction dataset without CoT steps.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>Models trained on CoT achieve near-perfect test accuracy across all difficulty levels in the paper's experiments (reported as near-100%); models trained to predict answers directly perform poorly (accuracy mostly below 60%). Training data: 1M samples; test: 0.1M samples.</td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td>Direct prediction (no CoT) vs CoT: CoT-trained models substantially outperform direct models. Increasing Transformer depth improves direct-prediction performance somewhat but typically remains far below CoT; a small (3-layer) Transformer with CoT already attains near-perfect results. Ablations include varying model depth and dataset difficulty (number of operators).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failures</strong></td>
                            <td>Direct-answer generation by bounded-depth, polynomial-size Transformers provably fails (circuit-complexity lower bounds) unless model size grows super-polynomially with input length; empirical direct-training accuracies remain low. The paper does not study how to reliably trigger CoT in practice (i.e., which prompts cause generation of CoT) nor how few CoT examples suffice; precision/number-field simplification (mod p) used in theory diverges from real-valued floating-point concerns.</td>
                        </tr>
                        <tr>
                            <td><strong>insights_or_conclusions</strong></td>
                            <td>Chain-of-Thought generation turns a shallow Transformer into an effectively much deeper computation (generation loop increases effective depth), enabling small autoregressive Transformers to implement stepwise algorithms (e.g., handle-by-handle reduction) and thereby solve arithmetic tasks that are otherwise intractable for bounded-depth models; empirically, CoT training enables models to learn and generalize the procedural solution (including some length extrapolation).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Towards Revealing the Mystery behind Chain of Thought: A Theoretical Perspective', 'publication_date_yy_mm': '2023-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8843.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e8843.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models being evaluated on strict logical reasoning tasks, including details about the models, the logical reasoning tasks or benchmarks, the methods or approaches used to improve logical reasoning, the performance or results, comparisons to baselines or ablations, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>LinearEquations (Equation(m,p))</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Solving systems of linear equations over finite field Z_p (Equation(m,p))</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Solve m linear equations in m variables (unique-solution systems) by generating stepwise Gaussian-elimination style CoT derivations; analyzed theoretically and evaluated empirically.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Autoregressive Transformer (minGPT-style)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Same experimental Transformer configuration as arithmetic experiments: autoregressive causal Transformer (minGPT codebase) with d=256, 4 heads, FFN=1024, varying depth; trained on synthetic linear-system examples and CoT Gaussian-elimination traces.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>hidden_dim=256, heads=4, FFN=1024, depth L varied (1–5 in experiments); parameter count not specified</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_name</strong></td>
                            <td>System of linear equations solving (Equation(m,p))</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_description</strong></td>
                            <td>Given a sequence encoding m linear equations in m variables over finite field Z_p (p=11 in experiments), produce the variable assignments satisfying the system; CoT format corresponds to Gaussian elimination steps.</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_approach</strong></td>
                            <td>Train models to autoregressively generate full Gaussian-elimination CoT derivations and final solutions (CoT dataset) versus train models to directly output final solutions (direct dataset). Theoretical constructions show small constant-size autoregressive Transformers can emit CoT that implements Gaussian elimination.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>CoT-trained Transformers achieve near-perfect empirical accuracy across tested variable counts (m ∈ {3,4,5}); direct-trained Transformers perform poorly (accuracy mostly below 60%).</td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td>Direct prediction (no CoT) vs CoT: CoT yields large gains; depth ablations show deeper direct models improve somewhat but still fail to match CoT performance. Theoretical baselines: bounded-depth log-precision Transformers without CoT lie in circuit-class TC0 and cannot solve Equation(m,p) unless size grows super-polynomially (reduction to NC1-complete problems).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failures</strong></td>
                            <td>Without CoT, provable impossibility for bounded-depth polynomial-size models. Practical limitations include use of finite-field setting for theoretical convenience; the mechanism that triggers CoT generation from prompts is not analyzed; scalability and sample-efficiency when CoT data is limited remain open.</td>
                        </tr>
                        <tr>
                            <td><strong>insights_or_conclusions</strong></td>
                            <td>CoT enables autoregressive Transformers to implement algorithmic procedures (Gaussian elimination) with constant internal model size by leveraging the recursion of generation to increase effective computation depth; empirical training on CoT demonstrations allows the model to learn complete elimination procedures and generalize.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Towards Revealing the Mystery behind Chain of Thought: A Theoretical Perspective', 'publication_date_yy_mm': '2023-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8843.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e8843.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models being evaluated on strict logical reasoning tasks, including details about the models, the logical reasoning tasks or benchmarks, the methods or approaches used to improve logical reasoning, the performance or results, comparisons to baselines or ablations, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>LIS (Longest Increasing Subsequence)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Longest Increasing Subsequence (LIS) via Dynamic Programming with CoT</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A Dynamic Programming (DP) task reformulated so a CoT output is the DP table/chain; used to test whether Transformers can learn DP algorithms when trained to produce CoT derivations.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Autoregressive Transformer (minGPT-style)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Same Transformer experimental setup (d=256, 4 heads, FFN=1024, variable depth). Datasets: synthetic integer sequences, vocabulary sized (150 tokens), three difficulty levels (lengths 50, 80, 100); training 1M samples, test 0.1M.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>hidden_dim=256, heads=4, FFN=1024, depth L varied (1–5 in experiments); parameter count not specified</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_name</strong></td>
                            <td>Longest Increasing Subsequence (LIS) via DP</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_description</strong></td>
                            <td>Compute length of the longest increasing subsequence in an integer sequence; CoT format is the DP array (intermediate dp values) produced step-by-step.</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_approach</strong></td>
                            <td>Train to generate entire DP computation chain (CoT dataset) vs directly predict final answer without intermediate steps (direct dataset). The CoT generation produces the DP states in topological order.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>CoT-trained models achieve near-perfect accuracy across difficulty levels in experiments; direct-prediction models perform substantially worse (often below ~60%).</td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td>CoT vs direct: CoT yields large improvements. Ablations with varying Transformer depth show direct models need greater depth to improve but still lag. Experiments used multiple depths and reported error bars over five runs.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failures</strong></td>
                            <td>Direct-generation approaches fail empirically; theoretical guarantees depend on assumptions that DP transition functions are implementable by small perceptrons (assumptions verified for LIS in appendix). The paper does not explore limited-CoT-data regimes or prompt-based triggering of CoT.</td>
                        </tr>
                        <tr>
                            <td><strong>insights_or_conclusions</strong></td>
                            <td>CoT aligns naturally with DP's sequential decomposition: generating dp(i) values one-by-one matches CoT's autoregressive generation and permits small Transformers to emulate DP algorithms; empirical success corroborates theoretical construction that CoT lets small models implement DP.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Towards Revealing the Mystery behind Chain of Thought: A Theoretical Perspective', 'publication_date_yy_mm': '2023-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8843.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e8843.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models being evaluated on strict logical reasoning tasks, including details about the models, the logical reasoning tasks or benchmarks, the methods or approaches used to improve logical reasoning, the performance or results, comparisons to baselines or ablations, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>ED (Edit Distance)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Edit Distance (ED) via Dynamic Programming with CoT</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Compute edit distance (minimum cost of insert/delete/replace) between two strings via DP; CoT output is the DP table and final minimal cost.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Autoregressive Transformer (minGPT-style)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Same Transformer experimental configuration (d=256, 4 heads, FFN=1024); datasets: concatenated string pairs, vocabulary size 26, three difficulty levels (average string lengths ~12, 16, 20); 1M training samples and 0.1M test samples.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>hidden_dim=256, heads=4, FFN=1024, depth L varied (1–5 in experiments); parameter count not specified</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_name</strong></td>
                            <td>Edit Distance (ED) via Dynamic Programming</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_description</strong></td>
                            <td>Compute minimum edit cost to transform one string into another using insert/delete/replace (costs a,b,c); CoT format enumerates DP array entries (intermediate dp values) and the final answer.</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_approach</strong></td>
                            <td>Train-to-generate DP CoT sequences (full DP table/traces) versus direct-answer training; inference generates CoT token-by-token until final answer.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>CoT-trained Transformers achieve near-perfect accuracy for all tested difficulty levels; direct-trained Transformers perform much worse (accuracy typically below ~60%).</td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td>Direct vs CoT: CoT yields substantial improvements. Depth ablations indicate direct models benefit from depth but still underperform CoT-trained models. Experiments include multiple random seeds and error bars.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failures</strong></td>
                            <td>Direct prediction fails for bounded-depth models; theoretical justification depends on DP assumptions (functions approximable by small perceptrons). Triggering CoT and few-shot CoT sample efficiency are not addressed in this work.</td>
                        </tr>
                        <tr>
                            <td><strong>insights_or_conclusions</strong></td>
                            <td>CoT permits autoregressive Transformers to implement DP algorithms by sequentially emitting subproblem solutions; empirically, training on CoT demonstrations enables the model to learn DP computations and generalize across sequence lengths.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Towards Revealing the Mystery behind Chain of Thought: A Theoretical Perspective', 'publication_date_yy_mm': '2023-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Chain of thought prompting elicits reasoning in large language models <em>(Rating: 2)</em></li>
                <li>Show your work: Scratchpads for intermediate computation with language models <em>(Rating: 2)</em></li>
                <li>What can transformers learn in-context? a case study of simple function classes <em>(Rating: 1)</em></li>
                <li>Language models are few-shot learners <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-8843",
    "paper_id": "paper-258865989",
    "extraction_schema_id": "extraction-schema-154",
    "extracted_data": [
        {
            "name_short": "Arithmetic (Arithmetic(n,p))",
            "name_full": "Arithmetic expression evaluation over finite field Z_p (Arithmetic(n,p))",
            "brief_description": "Evaluation of arithmetic expressions (numbers, +, -, ×, ÷, brackets) on a finite field Z_p; studied both theoretically and empirically, with Chain-of-Thought (CoT) derivations as the target intermediate representation.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "Autoregressive Transformer (minGPT-style)",
            "model_description": "Standard autoregressive Transformer (minGPT implementation) with token embeddings, causal attention, GeLU activations; experiments used hidden dimension d=256, 4 attention heads, FFN hidden size 1024, depths L varied; trained with AdamW on synthetic datasets (1M train / 0.1M test).",
            "model_size": "hidden_dim=256, heads=4, FFN=1024, depth L varied (1–5 in experiments); parameter count not specified",
            "reasoning_task_name": "Arithmetic expression evaluation (Arithmetic(n,p))",
            "reasoning_task_description": "Compute the value of arithmetic expressions containing integer tokens and operators (+, −, ×, ÷) and brackets; implemented in experiments over the finite field Z_p (p=11) so numbers are discrete tokens.",
            "method_or_approach": "Train-to-generate Chain-of-Thought (CoT) derivations: datasets constructed as &lt;problem, CoT steps, answer&gt; and models trained to autoregressively generate intermediate steps and final answer; baseline is direct prediction dataset without CoT steps.",
            "performance": "Models trained on CoT achieve near-perfect test accuracy across all difficulty levels in the paper's experiments (reported as near-100%); models trained to predict answers directly perform poorly (accuracy mostly below 60%). Training data: 1M samples; test: 0.1M samples.",
            "baseline_comparison": "Direct prediction (no CoT) vs CoT: CoT-trained models substantially outperform direct models. Increasing Transformer depth improves direct-prediction performance somewhat but typically remains far below CoT; a small (3-layer) Transformer with CoT already attains near-perfect results. Ablations include varying model depth and dataset difficulty (number of operators).",
            "limitations_or_failures": "Direct-answer generation by bounded-depth, polynomial-size Transformers provably fails (circuit-complexity lower bounds) unless model size grows super-polynomially with input length; empirical direct-training accuracies remain low. The paper does not study how to reliably trigger CoT in practice (i.e., which prompts cause generation of CoT) nor how few CoT examples suffice; precision/number-field simplification (mod p) used in theory diverges from real-valued floating-point concerns.",
            "insights_or_conclusions": "Chain-of-Thought generation turns a shallow Transformer into an effectively much deeper computation (generation loop increases effective depth), enabling small autoregressive Transformers to implement stepwise algorithms (e.g., handle-by-handle reduction) and thereby solve arithmetic tasks that are otherwise intractable for bounded-depth models; empirically, CoT training enables models to learn and generalize the procedural solution (including some length extrapolation).",
            "uuid": "e8843.0",
            "source_info": {
                "paper_title": "Towards Revealing the Mystery behind Chain of Thought: A Theoretical Perspective",
                "publication_date_yy_mm": "2023-05"
            }
        },
        {
            "name_short": "LinearEquations (Equation(m,p))",
            "name_full": "Solving systems of linear equations over finite field Z_p (Equation(m,p))",
            "brief_description": "Solve m linear equations in m variables (unique-solution systems) by generating stepwise Gaussian-elimination style CoT derivations; analyzed theoretically and evaluated empirically.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "Autoregressive Transformer (minGPT-style)",
            "model_description": "Same experimental Transformer configuration as arithmetic experiments: autoregressive causal Transformer (minGPT codebase) with d=256, 4 heads, FFN=1024, varying depth; trained on synthetic linear-system examples and CoT Gaussian-elimination traces.",
            "model_size": "hidden_dim=256, heads=4, FFN=1024, depth L varied (1–5 in experiments); parameter count not specified",
            "reasoning_task_name": "System of linear equations solving (Equation(m,p))",
            "reasoning_task_description": "Given a sequence encoding m linear equations in m variables over finite field Z_p (p=11 in experiments), produce the variable assignments satisfying the system; CoT format corresponds to Gaussian elimination steps.",
            "method_or_approach": "Train models to autoregressively generate full Gaussian-elimination CoT derivations and final solutions (CoT dataset) versus train models to directly output final solutions (direct dataset). Theoretical constructions show small constant-size autoregressive Transformers can emit CoT that implements Gaussian elimination.",
            "performance": "CoT-trained Transformers achieve near-perfect empirical accuracy across tested variable counts (m ∈ {3,4,5}); direct-trained Transformers perform poorly (accuracy mostly below 60%).",
            "baseline_comparison": "Direct prediction (no CoT) vs CoT: CoT yields large gains; depth ablations show deeper direct models improve somewhat but still fail to match CoT performance. Theoretical baselines: bounded-depth log-precision Transformers without CoT lie in circuit-class TC0 and cannot solve Equation(m,p) unless size grows super-polynomially (reduction to NC1-complete problems).",
            "limitations_or_failures": "Without CoT, provable impossibility for bounded-depth polynomial-size models. Practical limitations include use of finite-field setting for theoretical convenience; the mechanism that triggers CoT generation from prompts is not analyzed; scalability and sample-efficiency when CoT data is limited remain open.",
            "insights_or_conclusions": "CoT enables autoregressive Transformers to implement algorithmic procedures (Gaussian elimination) with constant internal model size by leveraging the recursion of generation to increase effective computation depth; empirical training on CoT demonstrations allows the model to learn complete elimination procedures and generalize.",
            "uuid": "e8843.1",
            "source_info": {
                "paper_title": "Towards Revealing the Mystery behind Chain of Thought: A Theoretical Perspective",
                "publication_date_yy_mm": "2023-05"
            }
        },
        {
            "name_short": "LIS (Longest Increasing Subsequence)",
            "name_full": "Longest Increasing Subsequence (LIS) via Dynamic Programming with CoT",
            "brief_description": "A Dynamic Programming (DP) task reformulated so a CoT output is the DP table/chain; used to test whether Transformers can learn DP algorithms when trained to produce CoT derivations.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "Autoregressive Transformer (minGPT-style)",
            "model_description": "Same Transformer experimental setup (d=256, 4 heads, FFN=1024, variable depth). Datasets: synthetic integer sequences, vocabulary sized (150 tokens), three difficulty levels (lengths 50, 80, 100); training 1M samples, test 0.1M.",
            "model_size": "hidden_dim=256, heads=4, FFN=1024, depth L varied (1–5 in experiments); parameter count not specified",
            "reasoning_task_name": "Longest Increasing Subsequence (LIS) via DP",
            "reasoning_task_description": "Compute length of the longest increasing subsequence in an integer sequence; CoT format is the DP array (intermediate dp values) produced step-by-step.",
            "method_or_approach": "Train to generate entire DP computation chain (CoT dataset) vs directly predict final answer without intermediate steps (direct dataset). The CoT generation produces the DP states in topological order.",
            "performance": "CoT-trained models achieve near-perfect accuracy across difficulty levels in experiments; direct-prediction models perform substantially worse (often below ~60%).",
            "baseline_comparison": "CoT vs direct: CoT yields large improvements. Ablations with varying Transformer depth show direct models need greater depth to improve but still lag. Experiments used multiple depths and reported error bars over five runs.",
            "limitations_or_failures": "Direct-generation approaches fail empirically; theoretical guarantees depend on assumptions that DP transition functions are implementable by small perceptrons (assumptions verified for LIS in appendix). The paper does not explore limited-CoT-data regimes or prompt-based triggering of CoT.",
            "insights_or_conclusions": "CoT aligns naturally with DP's sequential decomposition: generating dp(i) values one-by-one matches CoT's autoregressive generation and permits small Transformers to emulate DP algorithms; empirical success corroborates theoretical construction that CoT lets small models implement DP.",
            "uuid": "e8843.2",
            "source_info": {
                "paper_title": "Towards Revealing the Mystery behind Chain of Thought: A Theoretical Perspective",
                "publication_date_yy_mm": "2023-05"
            }
        },
        {
            "name_short": "ED (Edit Distance)",
            "name_full": "Edit Distance (ED) via Dynamic Programming with CoT",
            "brief_description": "Compute edit distance (minimum cost of insert/delete/replace) between two strings via DP; CoT output is the DP table and final minimal cost.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "Autoregressive Transformer (minGPT-style)",
            "model_description": "Same Transformer experimental configuration (d=256, 4 heads, FFN=1024); datasets: concatenated string pairs, vocabulary size 26, three difficulty levels (average string lengths ~12, 16, 20); 1M training samples and 0.1M test samples.",
            "model_size": "hidden_dim=256, heads=4, FFN=1024, depth L varied (1–5 in experiments); parameter count not specified",
            "reasoning_task_name": "Edit Distance (ED) via Dynamic Programming",
            "reasoning_task_description": "Compute minimum edit cost to transform one string into another using insert/delete/replace (costs a,b,c); CoT format enumerates DP array entries (intermediate dp values) and the final answer.",
            "method_or_approach": "Train-to-generate DP CoT sequences (full DP table/traces) versus direct-answer training; inference generates CoT token-by-token until final answer.",
            "performance": "CoT-trained Transformers achieve near-perfect accuracy for all tested difficulty levels; direct-trained Transformers perform much worse (accuracy typically below ~60%).",
            "baseline_comparison": "Direct vs CoT: CoT yields substantial improvements. Depth ablations indicate direct models benefit from depth but still underperform CoT-trained models. Experiments include multiple random seeds and error bars.",
            "limitations_or_failures": "Direct prediction fails for bounded-depth models; theoretical justification depends on DP assumptions (functions approximable by small perceptrons). Triggering CoT and few-shot CoT sample efficiency are not addressed in this work.",
            "insights_or_conclusions": "CoT permits autoregressive Transformers to implement DP algorithms by sequentially emitting subproblem solutions; empirically, training on CoT demonstrations enables the model to learn DP computations and generalize across sequence lengths.",
            "uuid": "e8843.3",
            "source_info": {
                "paper_title": "Towards Revealing the Mystery behind Chain of Thought: A Theoretical Perspective",
                "publication_date_yy_mm": "2023-05"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Chain of thought prompting elicits reasoning in large language models",
            "rating": 2
        },
        {
            "paper_title": "Show your work: Scratchpads for intermediate computation with language models",
            "rating": 2
        },
        {
            "paper_title": "What can transformers learn in-context? a case study of simple function classes",
            "rating": 1
        },
        {
            "paper_title": "Language models are few-shot learners",
            "rating": 1
        }
    ],
    "cost": 0.017148499999999997,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>Towards Revealing the Mystery behind Chain of Thought: A Theoretical Perspective
28 Jun 2023</p>
<p>Guhao Feng fenguhao@stu.pku.edu.cn 
Di He Liwei
Wang Peking University</p>
<p>Bohang Zhang zhangbohang@pku.edu.cn 
Di He Liwei
Wang Peking University</p>
<p>Yuntian Gu guyuntian@stu.pku.edu.cn 
Di He Liwei
Wang Peking University</p>
<p>Haotian Ye haotianye@pku.edu.cn 
Di He Liwei
Wang Peking University</p>
<p>Towards Revealing the Mystery behind Chain of Thought: A Theoretical Perspective
28 Jun 2023CD624B279D8DC25C2B07C49B8946CC65arXiv:2305.15408v3[cs.LG]
Recent studies have discovered that Chain-of-Thought prompting (CoT) can dramatically improve the performance of Large Language Models (LLMs), particularly when dealing with complex tasks involving mathematics or reasoning.Despite the enormous empirical success, the underlying mechanisms behind CoT and how it unlocks the potential of LLMs remain elusive.In this paper, we take a first step towards theoretically answering these questions.Specifically, we examine the expressivity of LLMs with CoT in solving fundamental mathematical and decision-making problems.We start by giving an impossibility result showing that bounded-depth Transformers are unable to directly produce correct answers for basic arithmetic/equation tasks unless the model size grows super-polynomially with respect to the input length.In contrast, we then prove by construction that autoregressive Transformers of constant size suffice to solve both tasks by generating CoT derivations using a commonly-used math language format.Moreover, we show LLMs with CoT are capable of solving a general class of decision-making problems known as Dynamic Programming, thus justifying its power in tackling complex real-world tasks.Finally, extensive experiments on four tasks show that, while Transformers always fail to predict the answers directly, they can consistently learn to generate correct solutions step-by-step given sufficient CoT demonstrations.* Equal contributions. 2 Throughout this paper, we use the term CoT to refer to the general framework of the step-by-step generation process rather than a specific prompting technique.In other words, this paper studies why an LLM equipped with CoT can succeed in math/reasoning tasks rather than which prompt can trigger this process.Preprint.Under review.</p>
<p>Introduction</p>
<p>Transformer-based Large Language Models (LLMs) have emerged as a foundation model in natural language processing.Among them, the autoregressive paradigm has gained arguably the most popularity [45,8,40,62,52,13,46,48], based on the philosophy that all different tasks can be uniformly treated as sequence generation problems.Specifically, given any task, the input along with the task description can be together encoded as a sequence of tokens (called the prompt); the answer is then generated by predicting subsequent tokens conditioned on the prompt in an autoregressive way.</p>
<p>Previous studies highlighted that a carefully-designed prompt greatly matters LLMs' performance [27,32].In particular, the so-called Chain-of-Thought prompting (CoT) [56] has been found crucial for tasks involving arithmetic or reasoning, where the correctness of generated answers can be dramatically improved via a modified prompt that triggers LLMs to output intermediate derivations.Practically, this can be achieved by either adding special phrases such as "let's think step by step" or by giving few-shot CoT demonstrations [29,56,51,38,63,58].However, despite the striking performance, the underlying mechanism behind CoT remains largely unclear and mysterious.On one hand, are there indeed inherent limitations of LLMs in directly answering math/reasoning questions?On the other hand, what is the essential reason behind the success of CoT 2 in boosting the performance of LLMs?</p>
<p>This paper takes a step towards theoretically answering the above questions.We begin with studying the capability of LLMs on two basic mathematical tasks: evaluating arithmetic expressions and solving linear equations.Both tasks are extensively employed and serve as elementary building blocks in solving complex real-world math problems [9].We first provide fundamental impossibility results showing that none of these tasks can be solved using bounded-depth Transformer models without CoT unless the model size grows super-polynomially with respect to the input length (Theorems 3.1 and 3.2).Remarkably, our proofs provide insights into why this happens: the reason is not due to the (serialized) computational cost of these problems but rather to their parallel complexity [2].We next show that the community may largely undervalue the strength of autoregressive generation: we prove by construction that autoregressive Transformer models of constant size can already perfectly solve both tasks by generating intermediate derivations in a step-by-step manner using a commonly-used math language format (Theorems 3.3 and 3.4).Intuitively, this result hinges on the recursive nature of CoT, which increases the "effective depth" of the Transformer to be proportional to the generation steps.</p>
<p>Besides mathematics, CoT also exhibits remarkable performance across a wide range of reasoning tasks.To gain a systematic understanding of why CoT is beneficial, we next turn to a fundamental class of problems known as Dynamic Programming (DP) [5].DP represents a golden framework for solving sequential decision-making tasks: it decomposes a complex problem into a sequence (or chain) of subproblems, and by following the reasoning chain step by step, each subproblem can be solved based on the results of previous subproblems.Our main finding demonstrates that, for general DP problems of the form (5), LLMs with CoT can generate the complete chain and output the correct answer (Theorem 4.7).However, it is impossible to directly generate the answer in general: as a counterexample, we prove that bounded-depth Transformers of polynomial size cannot solve a classic DP problem known as Context-Free Grammar Membership Testing (Theorem 4.8).</p>
<p>Our theoretical findings are complemented by an extensive set of experiments.We consider the two aforementioned math tasks plus two celebrated DP problems listed in the "Introduction to Algorithms" book [14], known as longest increasing subsequence (LIS) and edit distance (ED).For all these tasks, our experimental results show that directly predicting the answers without CoT always fails (accuracy mostly below 60%).In contrast, autoregressive Transformers equipped with CoT can learn entire solutions given sufficient training demonstrations.Moreover, they even generalize well to longer input sequences, suggesting that the models have learned the underlying reasoning process rather than statistically memorizing input-output distributions.These results verify our theory and reveal the strength of autoregressive LLMs and the importance of CoT in practical scenarios.</p>
<p>Preliminary</p>
<p>An (autoregressive) Transformer [53,44] is a neural network architecture designed to process a sequence of input tokens and generate tokens for subsequent positions.Given an input sequence s of length n, a Transformer operates the sequence as follows.First, each input token s i (i ∈ [n]) is converted to a d-dimensional vector v i = Embed(s i ) ∈ R d using an embedding layer.To identify the sequence order, there is also a positional embedding p i ∈ R d applied to token s i .The embedded input can be compactly written into a matrix
X (0) = [v 1 + p 1 , • • • , v n + p n ] ∈ R n×d .
Then, L Transformer blocks follow, each of which transforms the input based on the formula below: X (l) = X (l−1) + Attn (l) (X (l−1) ) + FFN (l) X (l−1) + Attn (l)
(X (l−1) ) , l ∈ [L],(1)
where Attn (l) and FFN (l) denote the multi-head self-attention layer and the feed-forward network for the l-th Transformer block, respectively:
Attn (l) (X) = H h=1 softmax XW (l,h) Q (XW (l,h) K ) + M XW (l,h) V W (l,h) O ,(2)
FFN (l) (X) = σ(XW
(l) 1 )W (l) 2 .(3)
Here, we focus on the standard setting adopted in Vaswani et al. [53], namely, an H-head softmax attention followed by a two-layer pointwise FFN, both with residual connections.The size of the Transformer is determined by three key quantities: its depth L, width d, and the number of heads H.The parameters W chosen as GeLU [25], following [45,18].The matrix M ∈ {−∞, 0} n×n is a causal mask defined as M ij = −∞ iff i &lt; j.This ensures that each position i can only attend to preceding positions j ≤ i and is the core design for autoregressive generation.</p>
<p>After obtaining X (L) ∈ R n×d , its last entry X (L) n,: ∈ R d will be used to predict the next token s n+1 (e.g., via a softmax classifier).By concatenating s n+1 to the end of the input sequence s, the above process can be repeated to generate subsequent token s n+2 .The process continues iteratively until a designated End-of-Sentence token is generated, signifying the completion of the process.</p>
<p>Chain-of-Thought prompting.Autoregressive Transformers possess the ability to tackle a wide range of tasks by encoding the task description into a partial sentence, with the answer being derived by complementing the subsequent sentence [8].However, for some challenging tasks involving math or general reasoning, a direct generation often struggles to yield a correct answer.To address this shortcoming, researchers proposed the CoT prompting that induces LLMs to generate intermediate reasoning steps before reaching the answer [56,29,51,38,63,10].In this paper, our primary focus lies in understanding the mechanism behind CoT, while disregarding the aspect of how prompting facilitates its triggering.Specifically, we examine CoT from an expressivity perspective: for both mathematical problems and general decision-making tasks studied in Sections 3 and 4, we will investigate whether autoregressive Transformers are expressive for (i) directly generating the answer, and (ii) generating a CoT solution for the tasks.</p>
<p>3 CoT is the Key to Solving Mathematical Problems Previous studies have observed that Transformer-based LLMs exhibit surprising math abilities in various aspects [40,9].In this section, we begin to explore this intriguing phenomenon via two well-chosen tasks: arithmetic and equation.We will give concrete evidence that LLMs are capable of solving both tasks when equipped with CoT, while LLMs without CoT are provably incapable.Arithmetic.The first task focuses on evaluating arithmetic expressions.As shown in Figure 1 (left), the input of this task is a sequence consisting of numbers, addition (+), subtraction (−), multiplication (×), division (÷), and brackets, followed by an equal sign.The goal is to calculate the arithmetic expression and generate the correct result.This task has a natural CoT solution, where each step performs an intermediate computation, gradually reducing one atomic operation at a time while copying down other unrelated items.Figure 1 (left) gives an illustration, and the formal definition of the CoT format is deferred to Appendix B.</p>
<p>Problem formulation</p>
<p>Equation.The second task considers solving linear equations.As shown in Figure 1 (right), the input of this task is a sequence consisting of m linear equations, each of which involves m variables.</p>
<p>The input ends with a special symbol =⇒.The goal is to output the value of these variables that satisfies the set of equations (assuming the solution is unique).A natural CoT solution is the Gaussian elimination algorithm: at each step, it eliminates a certain variable in all but one equations.After m − 1 steps, all equations will have only one variable and the problem gets solved.Figure 1 (right) gives an illustration, and we defer the formal definition of the CoT format to Appendix B.</p>
<p>Number field.Ideally, for both tasks, the input sequences involve not only symbol tokens but also (infinitely many) floating-point numbers.This complicates the definitions of the model's input/output format and further entails intricate precision considerations when dealing with floating-point divisions.</p>
<p>To simplify our subsequent analysis, here we turn to a more convenient setting by transitioning to the finite field generated by integers modulo p for a prime number p. Importantly, the finite field contains only p numbers (ranging from 0 to p − 1) and thus can be uniformly treated as tokens in a pre-defined dictionary (like other operators or brackets), making the problem setting much cleaner.</p>
<p>Moreover, arithmetic operations (+, −, ×, ÷) are well-defined and parallel the real number field (see Appendix A.1 for details).Therefore, this setting does not lose generalities.</p>
<p>In subsequent sections, we denote Arithmetic(n, p) as the arithmetic evaluation task defined on the finite field modulo p, where the input length does not exceed n.Similarly, we denote Equation(m, p) as the linear equation task defined on the finite field modulo p with no more than m variables.</p>
<p>Theoretical results</p>
<p>We begin by investigating whether Transformers can directly produce answers for the aforementioned problems.This corresponds to generating, for instance, the number "3" or the solution "x = 1; y = 1; z = 0" in Figure 1 immediately after the input sequence (without outputting intermediate steps).This question can be examined via different theoretical perspectives.One natural approach is to employ the classic representation theory, which states that perceptrons with sufficient size (e.g., the depth or width approaches infinity) are already universal function approximators [15,30,34].</p>
<p>Recently, such results have been well extended to Transformer models [60].However, the above results become elusive when taking the representation efficiency into account, since it says nothing about the required model size for any specific task.Below, we would like to give a more fine-grained analysis on how large the network needs to be by leveraging the tool of complexity theory.</p>
<p>We focus on a realistic setting called the log-precision Transformer [36,31]: it refers to a Transformer whose internal neurons can only store floating-point numbers within a finite O(log n) bit precision where n is the maximal length of the input sequence (see Appendix A.3 for a formal definition).Such an assumption well-resembles practical situations, in which the machine precision (e.g., 16 or 32 bits) is typically much smaller than the input length (e.g., 2048 in GPT), avoiding the unrealistic (but crucial) assumption of infinite precision made in several prior works [? 17].Furthermore, log-precision implies that the number of values each neuron can take is polynomial in the input length, which is a necessary condition for representing important quantities like positional embedding.Equipped with the concept of log-precision, we are ready to present a central impossibility result, showing that the required network size must be prohibitively large for both math problems: Why does this happen?As presented in Appendices D.2 and E.2, the crux of our proof lies in applying circuit complexity theory [2].By framing the finite-precision Transformer as a computation model, one can precisely delineate its expressivity limitation through an analysis of its circuit complexity.</p>
<p>Here, bounded-depth log-precision Transformers of polynomial size represent a class of shallow circuits with complexity upper bounded by TC 0 [36].On the other hand, we prove that the complexity of both math problems above are lower bounded by NC 1 by applying reduction from NC 1 -complete problems.Consequently, they are intrinsically hard to be solved by a well-parallelized Transformer unless the two complexity classes collapse (i.e., TC 0 = NC 1 ), a scenario widely regarded as impossible.</p>
<p>How about generating a CoT solution?We next turn to the setting of generating CoT solutions for these problems.From an expressivity perspective, one might intuitively perceive this problem as more challenging as the model is required to express the entire problem solving process, potentially necessitating a larger model size.However, we show this is not the case: a constant-size autoregressive Transformer already suffices to generate solutions for both math problems.Remark 3.5.The polynomial upper bound for parameters in Theorems 3.3 and 3.4 readily implies that these Transformers can be implemented using log-precision without loss of accuracy.See Appendix A.3 for a detailed discussion on how this can be achieved.</p>
<p>The proof of Theorems 3.3 and 3.4 is deferred to Appendices D.1 and E.1, with several discussions made as follows.Firstly, the constructions in our proof reveal the significance of several key components in the Transformer design, such as softmax attention, multi-head, and residual connection.We show how these components can be combined to implement basic operations like substring copying, symbol counting, and conditional selection, which serve as building blocks for generating a complete CoT solution.Secondly, we highlight that these CoT derivations are purely written in a readable math language format, largely resembling how human write solutions.In a broad sense, our findings suggest that LLMs have the potential to convey meaningful human thoughts through grammatically precise sentences.Finally, one may ask how LLMs equipped with CoT can bypass the impossibility results outlined in Theorems 3.1 and 3.2.Actually, this can be understood via the effective depth of the Transformer circuit.By employing CoT, the effective depth is no longer L since the generated outputs are repeatedly looped back to the input.The dependency between output tokens leads to a significantly deeper circuit with depth proportional to the length of the CoT solution.Even if the recursive procedure is repeated within a fixed Transformer (or circuit), the expressivity can still be far beyond TC 0 .</p>
<p>CoT is the Key to Solving Decision-Making Problems</p>
<p>The previous section has delineated the critical role of CoT in solving math problems.In this section, we will switch our attention to a more general setting beyond mathematics.Remarkably, we find that LLMs with CoT are theoretically capable of emulating a powerful decision-making framework called Dynamic Programming [5], thus strongly justifying the ability of CoT in solving complex tasks.</p>
<p>Dynamic Programming</p>
<p>Dynamic programming (DP) is widely regarded as a core technique to solve decision-making problems [50].The basic idea of DP lies in breaking down a complex problem into a series of small subproblems that can be tackled in a sequential manner.Here, the decomposition ensures that there is a significant interconnection (overlap) among various subproblems, so that each subproblem can be efficiently solved by utilizing the answers (or other relevant information) obtained from previous ones.</p>
<p>Formally, a general DP algorithm can be characterized via three key ingredients: the state space I, the transition function T , and the aggregation function A. The state space I represents the finite set of decomposed subproblems, where each state i ∈ I is an index signifying a specific subproblem.The size of the state space grows with the input size.We denote by dp(i) the answer of subproblem i (as well as other information stored in the DP process).Furthermore, there is a partial order relation between different states: we say state j precedes state i (denoted as j ≺ i) if subproblem j should be solved before subproblem i, i.e., the value of dp(i) depends on that of dp(j).This partial order creates a directed acyclic graph (DAG) within the state space, thereby establishing a reasoning chain where subproblems are resolved in accordance with the topological ordering of the DAG.</p>
<p>The transition function T characterizes the interconnection among subproblems and defines how a subproblem can be solved based on the results of previous subproblems.It can be generally written as
dp(i) = T (i, s, {(j, dp(j)) : j ≺ i}) ,(4)
where s is the input sequence.In this paper, we focus on a restricted setting where each state i only depends on (i) a finite number of tokens in the input sequence s and (ii) a finite number of previous states.Under this assumption, we can rewrite (4) into a more concrete form:
dp(i) = f i, s g1(i) , • • • , s g J (i) , dp(h 1 (i)), • • • , dp(h K (i)) ,(5
) where J and K are constant integers.The functions f, g, h fully determine the transition function T and have the form f : I × X J × Y K → Y, g : I → (N ∪ {∅}) J , h : I → (I ∪ {∅}) K , where the state space I, input space X , and DP output space Y can be arbitrary domains.The special symbol ∅ denotes a placeholder, such that all terms s ∅ and dp(∅) are unused in function f .After solving all subproblems, the aggregation function A is used to combine all results to obtain the final answer.We consider a general class of aggregation functions with the following form:
A ({(i, dp(i)) : i ∈ I}, s) = u ( i∈A dp(i)) ,(6)
where A ⊂ I is a set of states that need to be aggregated, is an aggregation function such as min, max, or , and u : Y → Z is an arbitrary function, where Z denotes the space of possible answers.</p>
<p>A variety of popular DP problems fits the above framework.As examples, the longest increasing subsequence (LIS) and edit distance (ED) are two well-known DP problems presented in the "Introduction to Algorithms" book [14] (see Appendix F.1 for problem descriptions and DP solutions).We list the state space, transition function, and aggregation function of the two problems in the table below.</p>
<dl>
<dt>Problem Longest increasing subsequence Edit distance Input A string s of length n Two strings s (1) , s (2) of length n1 = |s (1) | and n2 = |s (2) |, concatenated together State space {(j, k)</dt>
<dd>j ∈ [n], k ∈ {0, • • • , j −1}} {0, • • • , n1} × {0, • • • , n2} Transition function dp(j, k) =        1 if k = 0 max(dp(j, k−1), dp(k, k−1)× I[sj &gt; s k ]+1) if k &gt; 0 dp(j, k) =                ak if j = 0 bj if k = 0 min(dp(j, k−1) + a, dp(j −1, k) + b, dp(j −1, k−1) + cI[s(1)j = s (2) k ]) otherwise Aggregation function max i∈[n] dp(i, i − 1) dp(n1, n2)</dd>
</dl>
<p>Theoretical results</p>
<p>We begin by investigating whether LLMs with CoT can solve the general DP problems defined above.</p>
<p>We consider a natural CoT generation process, where the generated sequence has the following form:
input 1 | • • • | input N | (i 1 , dp(i 1 )) . . . (i |I| , dp(i |I| )) final answer
Here, the input sequence s consists of N strings separated by special symbols, and their lengths n := (n 1 , • • • , n N ) determine the size of the state space I;
(i 1 , • • • , i |I|
) is a feasible topological ordering of the state space I.We assume that all domains I, X , Y, Z belong to the real vector space so that their elements can be effectively represented and handled by a neural network.Each (i, dp(i)) ∈ I×Y above will be represented as a single vector and generated jointly in the CoT output.We further assume that X , Y, Z are discrete spaces (e.g., integers) so that the elements can be precisely represented using log-precision.To simplify our analysis, we consider a regression setting where each element in the CoT output directly corresponds to the output of the last Transformer layer (without using a softmax layer for tokenization as in Section 3).Instead, the Transformer output is simply projected to the nearest element in the corresponding discrete space (e.g., I×Y or Z).Likewise, each generated output is directly looped back to the Transformer input without an embedding layer.This regression setting is convenient for manipulating numerical values and has been extensively adopted in prior works [21,1].</p>
<p>Before presenting our main result, we make the following assumptions: Definition 4.1 (Polynomially-efficient approximation).Given neural network P θ and target function f : X in → X out where X in ⊂ R din and X out ⊂ R dout , we say f can be approximated by P θ with polynomial efficiency if there exist ρ &gt; 0, λ &gt; 0 such that for any any &gt; 0, there exists parameter
θ satisfying that (i) f (x) − P θ (x + δ) ∞ &lt; + λ δ ∞ for all x ∈ X in</p>
<p>Experiments</p>
<p>In previous sections, we proved by construction that LLMs exhibit sufficient expressive power to solve mathematical and decision-making tasks.On the other hand, it is still essential to check whether a Transformer model can learn such ability directly from training data.Below, we will complement our theoretical results with experimental evidence, showing that the model can easily learn underlying task solutions when equipped with CoT training demonstrations.</p>
<p>Experimental Design</p>
<p>Tasks and datasets.We choose four tasks for evaluation: Arithmetic, Equation, LIS, and ED.The first two tasks (Arithmetic and Equation) as well as their input/CoT formats have been illustrated in Figure 1.For the LIS task, the goal is to find the length of the longest increasing subsequence of a given integer sequence.For the ED task, the goal is to calculate the minimum cost required (called edit distance) to convert one sequence to another using three basic edit operations: insert, delete and replace.All input sequences, CoT demonstrations, and answers in LIS and ED are bounded-range integers and can therefore be tokenized (similar to the first two tasks).We consider two settings: (i) CoT datasets, which consist of <problem, CoT steps, answer> samples; (ii) Direct datasets, which are used to train models that directly predict the answer without CoT steps.These datasets are constructed by removing all intermediate derivations from the CoT datasets.</p>
<p>For each task, we construct three datasets with increasing difficulty.For Arithmetic, we build datasets with different number of operators ranging from {4, 5, 6}.For Equation, we build datasets with different number of variables ranging from {3, 4, 5}.For LIS, we build datasets with different input sequence lengths ranging from {50, 80, 100}.For ED, we build datasets with different string lengths, where the average length of the two strings is 12, 16, 20, respectively.We generate 1M samples for each training dataset and 0.1M for testing, while ensuring that duplicate samples between training and testing are removed.More details about the dataset construction can be found in Appendix G.</p>
<p>Model training and inference.For all experiments, we use standard Transformer models with hidden dimension d = 256, heads H = 4, and different model depths L. We adopt the AdamW optimizer [33] with β 1 = 0.9, β 2 = 0.999, lr = 10 −4 , and weight decay = 0.01 in all experiments.We use a fixed dropout ratio of 0.1 for all experiments to improve generalization.For CoT datasets, we optimize the negative log-likelihood loss on all tokens in the CoT steps and answers.For direct datasets, we optimize the negative log-likelihood loss on answer tokens.All models are trained on 4 V100 GPUs for 100 epochs.During inference, models trained on the direct datasets are required to output the answer directly, and models trained on CoT datasets will generate the whole CoT process token-by-token (using greedy search) until generating the End-of-Sentence token, where the output in the final step is regarded as the answer.We report the accuracy as evaluation metric.</p>
<p>Please refer to Appendix G for more training configuration details.</p>
<p>Experimental Results</p>
<p>All results are shown in Figure 2, where each subfigure corresponds to a task with x-axis representing the difficulty level and y-axis representing the test accuracy (%).We repeat each experiment five times and report the error bars.In each subfigure, the purple bar and blue bars indicate the performance of the model trained on the CoT and direct datasets, respectively.The model depths are specified in the legend.From these results, one can easily see that Transformers with CoT achieve near-perfect performance for all tasks and all difficulty levels.In contrast, models trained on direct datasets perform much worse even when using larger depths.While increasing the depth usually helps the performance of direct prediction (which is consistent to our theory), the performance is still poor when the length of the input sequence grows.These empirical findings verify our theoretical results and clearly demonstrate the benefit of CoT in autoregressive generation.Length extrapolation.We next study whether the learned autoregressive models can further extrapolate to data with longer length.We construct a CoT training dataset for the arithmetic task with the number of operators ranging from 1 to 15, and test the model on expressions with the number of operators in {16, 17, 18}.As shown in Figure 3, our three-layer Transformer model still performs well on longer sequences, suggesting that the model indeed learns the solution to some extent (instead of memorizing data distributions).Potentially, we believe models trained on more data with varying lengths can eventually reveal the complete arithmetic rules.</p>
<p>Related Work</p>
<p>Owing to the tremendous success of Transformers and Large Language Models across diverse domains, there has been a substantial body of works dedicated to theoretically comprehending their capabilities and limitations.Initially, researchers primarily focused on exploring the expressive power of Transformers in the context of function approximation.Yun et al. [60] proved that Transformers with sufficient size can universally approximate arbitrary continuous sequence-to-sequence functions on a compact domain.Recently, universality results have been extended to model variants such as Sparse Transformers [61] and Transformers with relative positional encodings (RPE) [35].</p>
<p>More relevant to this paper, another line of works investigated the power of Transformers from a computation perspective.Early results have shown that both standard encoder-decoder Transformers [53] and looped Transformer encoders are Turing-complete [? 41,17,7].However, these results depend on the unreasonable assumption of infinite precision, yielding a quite unrealistic construction that does not match practical scenarios.Recently, Giannou [22] demonstrated that a constant-depth looped Transformer encoder can simulate practical computer programs.Wei et al. [55] showed that finite-precision encoder-decoder Transformers can approximately simulate Turing machines with bounded computation time.Liu et al. [31] considered a restricted setting of learning automata, for which a shallow non-recursive Transformer provably suffices.Besides affirmative results, other works characterized the expressivity limitation of Transformers via the perspective of modeling formal languages [23,6,57] or simulating circuits [24,37,36].However, none of these works explored the setting of autoregressive Transformers typically adopted in LLMs, which we study in this paper.Moreover, we consider a more practical setting that targets the emergent ability of LLMs in solving basic reasoning problems via a readable CoT output, which aligns well with real-world scenarios.</p>
<p>Recently, the power of Transformers has regained attention due to the exceptional in-context learnability exhibited by LLMs [8].Garg et al. [21] demonstrated that autoregressive Transformers can in-context learn basic function classes (e.g., linear functions, MLPs, and decision trees) via input sample sequences.Subsequent works further revealed that Transformers can implement learning algorithms such as linear regression [1], gradient descent [1,54,16], and Bayesian inference [59].</p>
<p>The works of [20,39] studied in-context learning via the concept of "induction heads".All the above works investigated the power of (autoregressive) Transformer models from an expressivity perspective, which shares similarities to this paper.Here, we focus on the reasoning capability of Transformers and underscore the key role of CoT in improving the power of LLMs.</p>
<p>Limitations and Future Directions</p>
<p>In this work, from a model-capacity perspective, we theoretically analyze why Chain-of-Thought prompting is essential in solving mathematical and decision-making problems.Focusing on two basic mathematical problems as well as Dynamic Programming, we show that a bounded-depth Transformer without CoT struggles with these tasks unless its size grows prohibitively large.In contrast to our negative results, we prove by construction that when equipped with CoT, constant-size Transformers are sufficiently capable to address these tasks by generating intermediate derivations sequentially.Extensive experiments show that models trained on CoT datasets can indeed learn solutions almost perfectly, while direct prediction always fails.We further demonstrate that CoT has the potential to generalize to unseen data with longer length.</p>
<p>Several foundational questions remain to be answered.Firstly, while this paper investigates why CoT enhances the expressivity of LLMs, we do not yet answer how the CoT generation process is triggered by specific prompts.Revealing the relation between prompts and outputs is valuable for better harnessing LLMs.Secondly, it has been empirically observed that scaling the model size significantly improves the CoT ability [56].Theoretically understanding how model size plays a role in CoT would be an interesting research problem.Thirdly, this paper main studies the expressivity of LLMs in generating CoT solutions, without theoretically thinking about their generalization ability.Given our experimental results, we believe it is an important future direction for theoretically studying how LLMs can generalize from CoT demonstrations (even in the out-of-distribution setting, e.g., length extrapolation (Figure 3)) [55,12].Finally, from a practical perspective, it is interesting to investigate how models can learn CoT solutions when there are only limited CoT demonstrations in training (or even purely from direct datasets).We would like to leave these questions as future work, which we believe are beneficial to better reveal the power and limitations of LLMs.</p>
<p>Appendix</p>
<p>The Appendix is organized as follows.Appendix A introduces additional mathematical background and useful notations.Appendix B presents formal definitions and CoT solutions of the arithmetic expression task and the linear equation task.Appendix C gives several useful lemmas, which will be frequently used in our subsequent proofs.The formal proofs for arithmetic expression, linear equation, and dynamic programming tasks are given in Appendices D to F, respectively.We finally present experimental details in Appendix G.</p>
<p>A Additional Background and Notation</p>
<p>A.1 Finite field</p>
<p>Intuitively, a field is a set F on which addition, subtraction, multiplication, and division are defined and behave as the corresponding operations on rational and real numbers do.Formally, the two most basic binary operations in a field is the addition (+) and multiplication (×), which satisfy the following properties:</p>
<p>• Associativity: for any a, b, c ∈ F, (a + b)
+ c = a + (b + c) and (a × b) × c = a × (b × c); • Commutativity: for any a, b ∈ F, a + b = b + a and a × b = b × a;
• Identity: there exist two different elements 0, 1 ∈ F such that a + 0 = a and a × 1 = a for all a ∈ F; • Additive inverses: for any a ∈ F, there exists an element in F, denoted as −a, such that a + (−a) = 0; • Multiplicative inverses: for any a ∈ F and a = 0, there exists an element in F, denoted as a −1 , such that a × a −1 = 1; • Distributivity of multiplication over addition: for any a, b, c ∈ F, a×(b+c) = (a×b)+(a×c).</p>
<p>Then, subtraction (−) is defined by a
− b = a + (−b) for all a, b ∈ F; division (÷) is defined by a ÷ b = a × b −1 for all a, b ∈ F, b = 0.
Two most widely-used fileds are the rational number field Q and the real number field R, both of which satisfy the above properties.However, both fields contain an infinite number of elements.In this paper, we consider a class of fields called finite fields, which contain a finite number of elements.Given a prime number p, the finite field Z p is the field consisting of p elements, which can be denoted as 0, 1, • • • , p − 1.In Z p , both addition and multiplication are defined by simply adding/multiplying two input integers and then taking the remainder modulo p.It can be easily checked that the two operations satisfy the six properties described above.Thus, subtraction and division can be defined accordingly.Remarkably, a key result in abstract algebra shows that all finite fields with p elements are isomorphic, which means that the above definitions of addition, subtraction, multiplication, and division are unique (up to isomorphism).</p>
<p>As an example, consider the finite field Z 5 .We have that 2 + 3 equals 0, since (2 + 3) mod 5 = 0. Similarly, 2 × 3 equals 1; 2 − 3 equals 4; and 2 ÷ 3 equals 4.</p>
<p>In Section 3, we utilize the field Z p to address the issue of infinite tokens.Both tasks of evaluating arithmetic expressions and solving linear equations (Section 3.1) are well-defined in this field.</p>
<p>A.2 Circuit complexity</p>
<p>In circuit complexity theory, there are several fundamental complexity classes that capture different levels of computation power.Below, we provide a brief overview of these classes; however, for a comprehensive introduction, we recommend readers refer to Arora &amp; Barak [2].</p>
<p>The basic complexity classes we will discuss in this subsection are NC 0 , AC 0 , TC 0 , NC 1 , and P.These classes represent increasing levels of computation complexity.The relationships between these classes can be summarized as follows:</p>
<p>NC 0 AC 0 TC 0 ⊂ NC 1 ⊂ P Moreover, in the field of computational theory, it is widely conjectured that all subset relations in the hierarchy are proper subset relations.This means that each class is believed to capture a strictly larger set of computational problems than its predecessor in the hierarchy.However, proving some of these subset relations to be proper remains a critical open question in computational complexity theory.For example, NC 1 = P will imply P = NP, which is widely regarded as impossible but is still a celebrated open question in computer science.</p>
<p>To formally define these classes, we first introduce the concept of Boolean circuits.A Boolean circuit with n input bits is a directed acyclic graph (DAG), in which every node is either an input bit or an internal node representing one bit (also called a gate).The value of each internal node depends on its direct predecessors.Furthermore, several internal nodes are designated as output nodes, representing the output of the Boolean circuit.The in-degree of a node is called its fan-in number, and the input nodes have zero fan-in.</p>
<p>A Boolean circuit can only simulate a computation problem of a fixed number of input bits.When the input length varies, a series of distinct Boolean circuits will be required, each designed to process a specific length.In this case, circuit complexity studies how the circuit size (e.g., depth, fan-in number, width) increases with respect to the input length for a given computation problem.We now describe each complexity class as follows:</p>
<p>• NC 0 is the class of constant-depth, constant-fan-in, polynomial-sized circuits consisting of AND, OR, and NOT gates.NC 0 circuits is the weakest class in the above hierarchy with limited expressive power because they cannot express functions that depend on a growing number of inputs as the input size increases.For example, the basic logical-AND function with an arbitrary number of input bits is not in NC 0 .In [19], the authors considered a restricted version of the Transformer model with constant depth and a constant-degree sparse selection construction, which can be characterized by this complexity class.• AC 0 is the class of constant-depth, unbounded-fan-in, polynomial-sized circuits consisting of AND, OR, and NOT gates, with NOT gates allowed only at the inputs.It is strictly more powerful than NC 0 mainly because the fan-in number can (polynomially) depend on the input length.However, there are still several fundamental Boolean functions that are not in this complexity class, such as the parity function or the majority function (see below).• TC 0 is an extension of AC 0 that introduces an additional gate called MAJ (i.e., the majority).</p>
<p>The MAJ gate takes an arbitrary number of input bits and evaluates to false when half or more of the input bits are false, and true otherwise.Previous work [36,37] showed that the log-precision Transformer is in this class.• NC 1 is a complexity class that consists of constant-fan-in, polynomial-sized circuits with a logarithmic depth of O(log n), where n is the input length.Similar to NC 0 , the basic logical gates are AND, OR, and NOT.Allowing the number of layers to depend on the input length significantly increases the expressiveness of the circuit.On the other hand, the logarithmic dependency still enables a descent parallelizability.Indeed, NC 1 is widely recognized as an important complexity class that captures efficiently parallelizable algorithms.• P is the complexity class that contains problems that can be solved by a Turing machine in polynomial time.It contains a set of problems that do not have an efficient parallel algorithm.For example, the Context-Free-Grammar Membership Testing is in this class and is proved to be P-complete [28].</p>
<p>A.3 Log-precision</p>
<p>In this work, we focus on Transformers whose neuron values are restricted to be floating-point numbers of finite precision, and all computations operated on floating-point numbers will be finally truncated, similar to how a computer processes real numbers.In practice, the two most common formats to store real numbers are the fixed-point format and floating-point format (e.g., the IEEE-754 standard [26]).Likewise, there are several popular truncation approaches (also called rounding), such as round-to-the-nearest, round-to-zero, round-up, and round-down.Our results in this paper hold for both formats and all these truncation approaches.</p>
<p>Specifically, the log-precision assumption means that we can use O(log(n)) bits to represent a real number, where the length of the input sequence is bounded by n.For any floating-point format described above with O(log(n)) bits, an important property is that it can represent all real numbers of magnitude O(poly(n)) within O(poly(1/n)) truncation error.We next analyze how the truncation error will propagate and magnify in a log-precision Transformer from the input to the output layer.Note that since the functions represented by Transformers are continuous, the approximation error in a hidden neuron will smoothly influence the approximation error of subsequent neurons in deeper layers.This impact can be bounded by the Lipschitz constant of the Transformer, which depends on its basic layers.In particular, the softmax function (in attention) is 1-Lipschitz, the GeLU activation is 2-Lipschitz, and the Lipschitz constant of a linear layer depends on the scale of its weight parameters.Combining these together leads to the following result: given a bounded-depth log-precision Transformer of polynomial size, when all parameter values of the Transformer are further bounded by O(poly(n)), all neuron values only yield an O(poly(1/n)) approximation error compared to the infinite-precision counterpart.Therefore, if a problem can be solved by a boundeddepth polynomial-size infinite-precision Transformer with polynomially-bounded parameters, it can also be solved by a log-precision Transformer of the same size.This finding is helpful for understanding Theorems 3.3, 3.4 and 4.7.</p>
<p>Finally, we point out that a key property of log-precision Transformer is that each neuron can only hold O(log(n))-bit information and thus cannot store the full information of the entire input sequence.Therefore, the log-precision assumption captures the idea that the computation must be somehow distributed on each token, which well-resembles practical situations and the way Transformers work.</p>
<p>B Formal Definitions of CoT in Section 3</p>
<p>In this section, we will formally define the CoT derivation formats for the two math problems described in Section 3.</p>
<p>Arithmetic expression.</p>
<p>In an arithmetic expression that contains operators, there exists at least one pair of neighboring numbers connected by an operator that can be calculated, which we refer to as a handle.More precisely, one can represent an arithmetic expression into a (binary) syntax tree where each number is a leaf node and each operator is an internal node that has two children.In this case, a pair of neighboring numbers is a handle if they share the same parent in the syntax tree.For instance, consider the arithmetic formula 7 × (6 + 5 + 4 × 5).Then, 6 + 5 and 4 × 5 are two handles.</p>
<p>An important observation is that we can determine whether a pair of numbers a and b can form a handle with the operator op by examining the token before a and the token after b, where these tokens are either operators, brackets, or empty (i.e., approaching the beginning/ending of the sequence, including the equal sign '=').Specifically, given subsequence s 1 a op b s 2 , we have that a op b forms a handle iff one of the following conditions holds:</p>
<p>• op ∈ {+, −} and s 1 ∈ { ( , empty}, s 2 / ∈ {×, ÷};</p>
<p>• op ∈ {×, ÷} and s 1 / ∈ {× , ÷}.</p>
<p>In the proposed chain of thought (CoT), an autoregressive Transformer calculates one handle at each step.If there are multiple handles, the leftmost handle is selected.The subsequence a op b is then replaced by the calculated result.For the case of s 1 = ( and s 2 = ), there will be a pair of redundant brackets and thus the two tokens are removed.It is easy to see that the resulting sequence is still a valid arithmetic expression.By following this process, each CoT step reduces one operator and the formula is gradually simplified until there is only one number left, yielding the final answer.</p>
<p>System of linear equations.Assume that we have a system of m linear equations with variables x 1 , x 2 , . . ., x m .The i-th equation in the input sequence is grammatically written as
a i1 x 1 + a i2 x 2 + • • • + a im x m = b i , where a ij ∈ {0, • • • , p − 1} and b i ∈ {0, • • • , p − 1}.
For simplicity, we do not omit the token a ij or a ij x j in the input sequence when a ij ∈ {1, 0}.</p>
<p>We can construct the following CoT to solve the equations by using the Gaussian elimination algorithm.At each step i, we select an equation k satisfying the following two conditions:
• The coefficient of x i is nonzero. • The coefficients of x 1 , • • • , x i−1 are all zero.
Such an equation must exist, otherwise the solution is not unique or does not exist.If there are multiple equations satisfying the above conditions, we choose the k-th equation with the smallest index k.We then swap it with equation i, so that the i-th equation now satisfy the above conditions.</p>
<p>We then eliminate the variable x i in all other equations by leveraging equation i. Formally, denote the i-th equation at the i-th step as
a (i) ii x i + a (i) i,i+1 x i+1 + • • • + a (i) im x m = b i ,(7)
and denote the coefficient of x i in the j-th equation (j = i) as a (i)</p>
<p>ji .We can multiply (7) by −(a
(i) ii ) −1 a (i)
ji and add the resulting equation to the j-th equation.This will eliminate the term x i in the j-th equation.We further normalize equation i so that the coefficient a
(i)
ii becomes 1. Depending on whether j ≤ i or j &gt; i, the resulting equation in the CoT output will have the following grammatical form:</p>
<p>• If j ≤ i, the j-th equation will be written as x j + ãj,i+1 x i+1 + • • • + ãjm x m = bj ; • If j &gt; i, the j-th equation will be written as ãj,i+1
x i+1 + • • • + ãjm x m = bj .
Note that we remove all zero terms ãjk x k for k ≤ i, k = j in the CoT output and also remove the coefficient 1 in ãkk x k for k ≤ i, similar to how human write solutions (see Figure 1 for an illustration).However, to simplify our proof, we reserve the coefficient 0 or 1 (i.e., outputting 0x k or 1x k ) when k &gt; i since it cannot be determined easily before computing the coefficient.The above process is repeated for m − 1 steps, and after the final step we obtain the solution.</p>
<p>C Technical Lemmas C.1 Useful lemmas for MLP</p>
<p>In this subsection, we will demonstrate the representation efficiency of two-layer MLPs in performing several basic operations, such as multiplication, linear transformation, conditional selection, and look-up table.These operations will serve as building blocks in performing complex tasks.</p>
<p>We first show that a two-layer MLP with GeLU activation can efficiently approximate the scalar multiplication, with all weights bounded by O(poly(1/ )) where is the approximation error.Proof.Denote the input vector to the MLP as (a, b) ∈ R 2 .After the first linear layer, it is easy to construct a weight matrix such that the hidden vector is
1 λ (a + b, −a − b, a − b, −a + b) ∈ R 4
, where λ is an arbitrary scaling factor.Let σ be the GeLU activation.We can similarly construct a weight vector such that the final output of the MLP is
f (a, b) = √ 2πλ 2 8 σ a + b λ + σ −a − b λ − σ a − b λ − σ −a + b λ .
We will prove that the above MLP satisfies the theorem by picking an appropriate λ.By definition of GeLU activation, σ(x) = xΦ(x) where Φ(x) is the standard Gaussian cumulative distribution function.We thus have σ (0) = 0.5 and σ (0) = 2/π.Applying Taylor's formula and assuming λ &gt; 2M , we have
σ a + b λ + σ −a − b λ − σ a − b λ − σ −a + b λ − 8ab √ 2πλ 2 ≤ 1 2 2 π a + b λ 2 + −a − b λ 2 − a − b λ 2 − −a + b λ 2 − 8ab √ 2πλ 2 + 4 3! (2M ) 3 λ 3 max x∈[−1,1] σ (3) (x) = 16M 3 3λ 3 max x∈[−1,1] 1 √ 2π (x 3 − 4x) exp(− x 2 2 ) &lt; 80M 3 3 √ 2πλ 3 . Therefore,|f (a, b)−ab| &lt; 10M 3 3λ . Set λ ≥ 10M 3 3
, and then we can obtain |f (a, b)−ab| &lt; .Moreover, each weight element in the MLP is upper bounded by O(λ 2 ), which is clearly O(poly(M, 1/ )).</p>
<p>Next, we will demonstrate that a two-layer MLP with GeLU activation can efficiently approximate a two-layer MLP with ReLU activation, with all weights upper bounded by O(poly(1/ )).This result is useful in proving subsequent lemmas.Lemma C.2.Let g : R d1 → R d2 be a two-layer MLP with ReLU activation, and all parameter values are upper bounded by M .Then, for any &gt; 0, there exists a two-layer MLP f of the same size with GeLU activation and parameters upper bounded by O(poly(M, 1/ )) in the ∞ norm, such that for all x ∈ R d1 , we have f
(x) − g(x) ∞ ≤ . Proof. Let g(x) = W 2 • ReLU(W 1 x). We construct f (x) = 1 λ W 2 • GeLU(λW 1 x) where λ &gt; 0 is a sufficiently large constant. To prove that f (x) − g(x) ∞ ≤ for all x ∈ R d1 , it suffices to prove that W 2 (ReLU(z) − 1 λ GeLU(λz)) ∞ ≤ for all z ∈ R d where d is the hidden size. Since W 2 ReLU(z) − 1 λ GeLU(λz) ∞ ≤ W 2 ∞ ReLU(z) − 1 λ GeLU(λz)) ∞ ≤ M d ReLU(z) − 1 λ GeLU(λz)) ∞ ,
it suffices to consider the scalar setting and prove that | 1 λ GeLU(λy) − ReLU(y)| ≤ /M d for all y ∈ R. By definition of ReLU and GeLU, we have
1 λ GeLU(λy) − ReLU(y) = 1 λ ReLU(λy) − λy −∞ λy √ 2π exp − t 2 2 dt .(8)
When y ≥ 0, (8) becomes
1 λ +∞ −∞ λy √ 2π exp − t 2 2 dt − λy −∞ λy √ 2π exp − t 2 2 dt = 1 λ +∞ λy λy √ 2π exp − t 2 2 dt.
Combined with the case of y &lt; 0, (8) can be consistently written as
1 λ GeLU(λy) − ReLU(y) = 1 λ +∞ λ|y| λ|y| √ 2π exp − t 2 2 dt ≤ 1 √ 2πλ +∞ λ|y| t exp − t 2 2 dt = 1 √ 2πλ exp − λ 2 y 2 2 ≤ 1 √ 2πλ .
Picking λ = M d √ 2π yields the desired result and completes the proof.</p>
<p>Equipped with the above result, we now prove that a two-layer MLP with GeLU activation can perform linear transformation and conditional selection.Proposition C.3.Let f : R d1 → R d2 be a two-layer MLP with GeLU activation, and the hidden dimension is 2d 2 .Let W ∈ R d2×d1 be any matrix and denote M = max ij |W ij |.Then, for any &gt; 0, there exist MLP parameters with ∞ norm bounded by O(poly(M, 1/ )), such that for any
x ∈ R d1 , we have f (x) − W x ∞ ≤ .
Proof.We can use a two-layer MLP with ReLU activation to implement g(x) = W x by the following construction:
W x = ReLU(W x) + ReLU(−W x)
Combined with Lemma C.2, we can also implement g(x) by a two-layer MLP with GeLU activation.</p>
<p>Lemma C.4. Define the selection function
g : R d × R d × R → R d as follows: g(x, y, t) = x if t ≥ 0, y if t &lt; 0.(9)
Let f : R d × R d × R → R d be a two-layer MLP with GeLU activation, and the hidden dimension is 2d + 2.Then, for any &gt; 0, α &gt; 0, and M &gt; 0, there exist MLP parameters with ∞ norm bounded by O(poly(M, 1/α, 1/ )), such that for all
x ∈ [−M, M ] d , y ∈ [−M, M ] d , and t ∈ [−∞, −α] ∪ [α, +∞], we have f (x, y, t) − g(x, y, t) ∞ ≤ .
Proof.We can simply use a two-layer MLP with ReLU activation to implement g by the following construction:
h(x, y, t) = (h 1 , h 2 , h 3 , h 4 ) := (x + α −1 M t1 d , y − α −1 M t1 d , α −1 M t, −α −1 M t) ∈ R 2d+2 , f (x, y, t) = ReLU(h 1 ) − ReLU(h 3 )1 d + ReLU(h 2 ) − ReLU(h 4 )1 d ,δ ∈ [−1/2k, 1/2k] k×d , we have f (x + δ) − g(x) ∞ ≤ + 2k δ ∞
, where δ ∞ is the vector ∞ -norm applied to the flattended matrix δ.</p>
<p>Proof.We can simply use a two-layer MLP with ReLU activation to implement g by the following construction.Denote the index of the MLP hidden layer as
(i 1 , • • • , i k ) ∈ [d] k .
We can construct the weights of the first MLP layer such that
h (i1,••• ,i k ) (x) = 2(x i1 + x d+i2 • • • + x (k−1)d+i k ) − 2k + 1.
We can then construct the weights of the second layer such that the final output of the MLP is
f j (x) = gj (ei 1 ,••• ,ei k )=1 ReLU(h (i1,••• ,i k ) (x)).
One can check that f (x) = g(x) holds for all x ∈ D k ⊂ R d×k .Furthermore, we have
f (x + δ) − g(x) ∞ = f (x + δ) − f (x) ∞ = max j∈[d] gj (ei 1 ,••• ,ei k )=1 ReLU(h (i1,••• ,i k ) (x + δ)) − ReLU(h (i1,••• ,i k ) (x) ≤ max (i1,••• ,i k )∈[d] k h (i1,••• ,i k ) (x + δ) − h (i1,••• ,i k ) (x) ≤ 2k δ ∞
for all perturbations δ ∈ [−1/2k, 1/2k] k×d .Thus by using Lemma C.2, we can also implement g(x) by a two-layer MLP with GeLU activation and all parameters are bounded by O(poly(k, 1/ )).</p>
<p>C.2 Useful lemmas for the attention layer</p>
<p>In this subsection, we will introduce two special operations that can be performed by the attention layer (with causal mask).Below, let n ∈ N be an integer and let x 1 , x 2 , • • • , x n be a sequence of vectors where
x i = ( xi , r i , 1) ∈ [−M, M ] d+2 , xi ∈ R d , r i ∈ R, and M is a large constant. Let K, Q, V ∈ R d ×(d+2)
be any matrices with V ∞ ≤ 1, and let 0 &lt; ρ, δ &lt; M be any real numbers.Denote q i = Qx i , k j = Kx j , v j = V x j , and define the matching set S i = {j ≤ i :
|q i • k j | ≤ ρ}.
Equipped with these notations, we define two basic operations as follows:</p>
<p>• COPY: The output is a sequence of vectors u 1 , • • • , u n with u i = v pos(i) , where pos(i) = argmax j∈Si r j .• MEAN: The output is a sequence of vectors u 1 , • • • , u n with u i = mean j∈Si v j .</p>
<p>The output u i is undefined when S i = ∅.We next make the following regularity assumption: Assumption C.6.The matrices Q, K, V and scalars ρ, δ satisfy that for all considered sequences x 1 , x 2 , • • • , x n , the following hold:
• For any i, j ∈ [n], either |q i • k j | ≤ ρ or q i • k j ≤ −δ.
• For any i, j ∈ [n], either i = j or |r i − r j | ≥ δ.</p>
<p>Assumption C.6 says that there are sufficient gaps between the attended position (e.g., pos(i)) and other positions.The two lemmas below show that the attention layer with casual mask can implement both COPY operation and MEAN operation efficiently.</p>
<p>Lemma C.7. Assume Assumption C.6 holds with ρ ≤ δ 2 8M .For any &gt; 0, there exists an attention layer with embedding size O(d) and one causal attention head that can approximate the COPY operation defined above.Formally, for any considered sequence of vectors x 1 , x 2 , . . ., x n , denote the corresponding attention output as o 1 , o 2 , . . ., o n .Then, we have o i − u i ∞ ≤ for all i ∈ [n] with S i = ∅.Moreover, the ∞ norm of attention parameters is bounded by O(poly(M, 1/δ, log(n), log(1/ ))).</p>
<p>Proof.The purpose of the attention head is to focus only on the vector that needs to be copied.To achieve this, we construct the key, query, and value vectors as follows (by assigning suitable key, query, and value weight matrices in the attention head):
• Query: (λq i , µ) ∈ R d+1 • Key: (k i , r i ) ∈ R d+1 • Value: v i ∈ R d
where λ and µ are constants that will be defined later.Denote a ij as the attention score, then
a i,j = exp(λ(q i • k j ) + µr j ) j exp(λ(q i • k j ) + µr j ) = exp(λ(q i • k j )) j exp(λ(q i • k j ) + µ(r j − r j ))
.</p>
<p>Since ρ ≤ δ 2 8M and M ≥ δ, we have δ − ρ ≥
= 1 1 + (n − 1) exp(max(−λ(δ − ρ) + 2M µ, 2λρ − µδ)) ≥ 1 − n exp(max(−λ(δ − ρ) + 2M µ, 2λρ − µδ))(10)≥ 1 − n exp max − M δ ln 2nM , − ln 2nM ≥ 1 − n exp − ln 2nM (12) = 1 − 2M ,(11)
where in (10) we use Assumption C.6, which implies that whenever j = pos(i), either q i • k j ≤ −δ or (q i • k j ≤ ρ and r j − r j ≤ −δ); in (11) we use the inequality 1 1+x ≥ 1 − x for all x ≥ 0; in (12) we use the fact that M ≥ δ.We thus have
o i − u i ∞ = j a ij v j − v pos(i) ∞ ≤ M V ∞ •   1 − a i,pos(i) + j =pos(i) a i,j   = M V ∞ (2 − 2a i,pos(i) ) ≤ ,
which concludes the proof.</p>
<p>Lemma C.8. Assume Assumption C.6 holds with ρ ≤ δ 16M ln( 4M n ) .For any 0 &lt; ≤ M , there exists an attention layer with embedding size O(d) and one causal attention head that can approximate the MEAN operation defined above.Formally, for any considered sequence of vectors x 1 , x 2 , . . ., x n , denote the attention output as o 1 , o 2 , . . ., o n .Then, we have o i −u i ∞ ≤ for all i ∈ [n] with S i = ∅.Moreover, the ∞ norm of attention parameters is bounded by O(poly(M, 1/δ, log(n), log(1/ ))).</p>
<p>Proof.The purpose of the attention head is to average across all tokens that satisfy the condition q i • k j ≈ 0. To achieve this, we construct the key, query, and value vectors as follows:</p>
<p>• Query:
λq i ∈ R d • Key: k i ∈ R d • Value: v i ∈ R d
where λ is a constant which will be defined later.Denote a ij as the attention score, then
a i,j = exp(λq i • k j ) j exp(λq i • k j )
.</p>
<p>By setting λ = 1 δ ln 4M n (which is bounded by O(poly(M, 1/δ, log(n), log(1/ )))), we have:
j / ∈Si a ij ≤ (n − |S i |) exp(−λδ) (n − |S i |) exp(−λδ) + |S i | exp(−λρ) (13) = 1 1 + |Si| n−|Si| exp(−λ(ρ − δ)) &lt; n exp(λρ) exp(−λδ))(14)≤ n exp 16M exp − ln 4M n &lt; 3M ,(15)
where in (13) we use Assumption C.6, which implies that q i • k j ≤ −δ for all j / ∈ S i and q i • k j ≥ −ρ for all j ∈ S i ; in (14) we use the inequality 1 1+x &lt; 1 x for all x &gt; 0; in (15) we use that the assumption that ≤ M and the fact that exp(1/16) &lt; 4/3.</p>
<p>Similarly, for any j ∈ S i , we have
a ij − 1 |S i | ≤ max 1 |S i | − exp(−ρλ) |S i | exp(ρλ) + (n − |S i |) exp(−λδ) , exp(ρλ) |S i | exp(−ρλ) − 1 |S i | (16) ≤ 1 |S i | max 1 − 1 exp(2ρλ) + n exp(−λ(δ − ρ)) , exp(2ρλ) − 1 ≤ 1 |S i | max (exp(2ρλ) − 1 + n exp(−λ(δ − ρ)), exp(2ρλ) − 1)(17)= 1 |S i | (exp(2ρλ) − 1 + n exp(−λ(δ − ρ))) ≤ 1 |S i | exp 8M − 1 + 3M(18)≤ 2 3M |S i |(19)
where in (16) we use Assumption C.6 similarly as before; in (17) we use the inequality 1 − 1 x ≤ x − 1 for all x &gt; 0; in (18) we use the inequality previously derived in (15); in (19) we use the inequality exp(x) ≤ 1 + 2x for all 0 ≤ x ≤ 1.We thus obtain
o i − u i ∞ = j a ij v j − 1 |S i | j∈Si v j ∞ ≤ M V ∞ •   j / ∈Si a ij + j∈Si a ij − 1 |S i |   ≤ ,
which concludes the proof.</p>
<p>D Arithmetic Formula</p>
<p>In this section, we prove that the autoregressive Transformer can evaluate arithmetic expressions when equipped with CoT, whereas the it cannot solve this task without CoT.</p>
<p>D.1 Proof of Theorem 3.3</p>
<p>Before proving this theorem, there is one point that needs to be clarified: all residual connections in the attention/MLP layers can be replaced by concatenation, in the sense that both architectures have the same expressive power.Formally, consider an MLP (or an attention layer) denoted as f : R d → R d , and let y = f (x).It is easy to see that we can construct another MLP (or attention layer) denoted as g : R 2d → R 2d such that g(x, 0) + (x, 0) = (0, y) + (x, 0) = (x, y), namely, the residual connection can implement concatenation.Conversely, concatenation can implement residual connection by using a linear projection.Based on the equivalence, we can use the concatenation operation instead of residual connection in all subsequent proofs presented in Appendices D to F. Similarly, the output of multi-head attention can be replaced by the concatenation of the output of each head (instead of performing aggregation via matrices W (l,h) O defined in ( 2)).For clarity, we further omit the unnecessary parts in the concatenated outputs and only retain the outputs that are used in subsequent layers.</p>
<p>We now present the proof of Theorem 3.3.For ease of reading, we restate Theorem 3.3 below: Theorem D.1.For any prime p and integer n &gt; 0, there exists an autoregressive Transformer defined in Section 2 with hidden size d = O(poly(p)) (independent of n), depth L = 5, and 5 heads in each layer that can generate the CoT solution defined in Appendix B for all inputs in Arithmetic(n, p).Moreover, all parameter values in the Transformer are bounded by O(poly(n)).</p>
<p>Proof sketch.The intuition behind our construction is that when the CoT output proceeds to a certain position, the Transformer can read the context related to this position and determine whether it should copy a token or perform a calculation.Remarkably, the context only contains a fixed number of tokens (as discussed in Appendix B).Based on the key observation, we can construct our five-layer transformer as follows.The first layer collects important positional information.The second and third layers determine whether to perform a calculation by examining the context related to the current token, which contains five tokens.The fourth layer and the fifth layers are used to generate the output via three cases: before/at/after the position that performs a calculation.For the first and the last cases, the output simply copies a previous token with position computed by the two layers.For the middle case, the outcome is computed via a look-up table that stores the arithemtic rules (+, -, ×, ÷).</p>
<p>Proof.We construct each layer as follows.</p>
<p>Token Embeddings.Assume that we have a sequence of tokens s 1 , . . ., s i and we want to generate the next token s i+1 .For any j ∈ [n], let id(s j ) be the index of token s j in the embedding dictionary, with values ranging from 1 to the number of tokens.We can embed the token s j by x (0) j = (e id(sj ) , j, 1) ∈ R num_tokens+2 , where e j is a one-hot vector with the j-th element being 1, j ∈ N + is the positional embedding, and the constant embedding 1 is used as a bias term.</p>
<p>Layer 1.The first layer of the autoregressive Transformer uses two attention heads to perform the following tasks:</p>
<ol>
<li>Count the number of equal signs ('=') in previous tokens, denoted as n = i , i.e., n = i = |{j ≤ i :
s j = '='}|.</li>
<li>
<p>Copy the position of the last equal sign, denoted as p = i , i.e., p = i = max{j : j ≤ i, s j = '='}.If the set {j : j ≤ i, s j = '='} is empty, define
p = i = 0. 3. Compute i 2 .
Based on Appendix C.2 (Lemma C.8), we can use the first attention head to perform the MEAN operation that counts the percentage of equal signs in the preceding sentences (i.e., n = i /i).This can be achieved by setting Q = 0, K = 0, V = (e id('=') , 0, 0) (defined in Appendix C.2), so that
q i = 0, k j = 0, v j = e id('=') • e id(sj ) = I[s j = '='], S i = [i].
Similarly, we can use the second attention head to perform a COPY operation that copies the position index of the last equal sign (by Lemma C.7).This can be achieved by setting Q = (0, 0, 1) , K = (e id('=') , 0, −1) , V = (0, 1, 0) , r j = j (defined in Appendix C.2), so that
q i = 1, k j = I[s j = '='] − 1, v j = j, S i = {j ≤ i : s j = '='}.
It is easy to check that the above construction outputs u i = max{j : j ≤ i, s j = '='} when S i = ∅.Note that u i may not equal to p = i when S i = ∅.Using the residual connection to perform concatenation, the output of the attention layer has the form (e id(si) , i, 1, n = i /i, max{j : j ≤ i, s j = '='}).We can then use an MLP to multiply n = i /i and i to obtain n = i and use another MLP to compute i 2 according to Lemma C.1; Simultaneously, we can compute the value p = i using the following way:
p = i = max{j : j ≤ i, s j = '='} if n = i /i ≥ 1/n, 0 if n = i /i = 0
, which is a conditional selection operation and can be implemented by an MLP (Lemma C.4).Also note that the gap in Lemma C.4 is α = 1/2n, which can be implemented within log-precision.The final output of the first layer has the form x (1) i = (e id(si) , i, i 2 , n = i , p = i , 1).Layer 2. The second layer of the Transformer does some tricky preparation work for the next layer.</p>
</li>
<li>
<p>Compute the distance to the nearest and the last equal sign, denoted as d = i and d= i , respectively.Formally,
d = i = i − max{j : j ≤ i, s j = '='}, d= i = i − max{j : j &lt; i, s j = '='}. If the nearest/last equal sign does not exist, define d = i = i or d= i = i. The relation between d = i , d= i , and p = i can be expressed as d = i = i − p = i , d= i = i − p = i−1 . 2.
Count the number of equal signs in strictly previous tokens, denoted as n= i , i.e., n= i = |{j &lt; i : s j = '='}|.</p>
</li>
</ol>
<p>Compute (n
= i ) 2 , (n = i ) 2 , (d = i ) 2
, and ( d= i ) 2 .The first and the second tasks can be done using the COPY operation by setting
q i = Qx (1) i = ((i−1) 2 , i−1, 1), k j = Kx (1) j = (−1, 2j, −j 2 ), r j = 0, v j = (n j , j−p = j +1).
Under the above construction, we have q i • k j = −(i − j − 1) 2 , and thus S i = {i − 1}, namely, the output is (n i , d= i ).We then use an MLP to calculate (d = i ) 2 , ( d= i ) 2 , (n = i ) 2 , and (n = i ) 2 by using Lemma C.1.The output of the second layer is
x (2) i = (e id(si) , i, n = i , n= i , d = i , d= i , (n = i ) 2 , (n = i ) 2 , (d = i ) 2 , ( d= i ) 2 , 1).
Layer 3. The third Transformer layer judges whether the calculation should be performed at the current position and computes the result when needed.Based on the CoT format given in Appendix B, we need to extract five previous tokens related to this position.Formally, we need five attention heads to perform the following tasks:</p>
<ol>
<li>Copy the embedding e id(sj ) located at position j such that n= j = n = i − 1 and d= j = d = i + t for t ∈ {1, 2, 3, 4, 5}, as shown in Figure 4.</li>
</ol>
<p>Check if the copied expression can be evaluated at the current position according to the rule</p>
<p>given in Appendix B. If it can be evaluated, compute the result and determine how much sentence length will be reduced after this calculation (see Appendix B for details on how the reduced sentence length depends on brackets); otherwise, keep the token e id(sj ) with n= j = n = i − 1 and d= j = d = i + 1.We can use the multi-head attention to perform the COPY operation five times in parallel.For each t, we construct the matrices Q, K, V of the COPY operation such that (2)
q i = Qx (2) i = [(n = i ) 2 − 2n = i + 1, 1, n = i − 1, (d = i ) 2 + 2td = i + t 2 , 1, d = i − t] , k j = Kx (2) j =[ −1, −(n = j ) 2 , 2n = j , −1, −( d= j ) 2 , 2 d= j ] , v j = e id(sj ) ,i • Qx (2) j = −(n = i − n= j − 1) 2 − (d = i − d= j + t) 2 . Therefore, Kx (2) i • Qx (2) j = 0 only when n= j = n = i − 1 and d= j = d = i + t,andKx (2) i • Qx (2)
j ≤ −1 otherwise.It is easy to see that:</p>
<p>• Whenever n = i &gt; 0, for any t, the number of indices j satisfying q i • k j = 0 is at most one (i.e., unique).</p>
<p>• Whenever n = i &gt; 0, for any t, the index j satisfying q i • k j = 0 exists, unless there is a t &lt; t such that the copied token at t is an equal sign ('=').</p>
<p>In other words, based on Lemma C.7, the above property guarantees that we can copy the desired tokens until reaching an equal sign, after which the copied tokens are invalid as illustrated in Figure 4(right).The output of the attention layer can be written as (e id(si) , e j1 , e j2 , e j3 , e j4 , e j5 , i,
n = i , (n = i ) 2 , d = i , n= i , (n = i ) 2 , d= i , ( d= i ) 2 , 1)
, where we slightly abuse notation and use e jt to denote the embedding we copied by the t-th attention heads.</p>
<p>We can then use an MLP to perform the second task.Note that whether the current position can be calculated or not depends on the following six tokens (e id(si) , e j1 , e j2 , e j3 , e j4 , e j5 ).Concretely, there are several cases:</p>
<p>• e id(si) corresponds to the embedding of a number or a right bracket.In this case, the current position should simply output e j1 (which is an operator or a right bracket).</p>
<p>• e id(si) corresponds to the embedding of a left bracket, an operator, or the equal sign '='.In this case, e j1 corresponds to the embedding of a number or a left bracket.There are two subcases:</p>
<p>e j1 corresponds to the embedding of a number.In this case, whether the current position can be evaluated depends on (e id(si) , e j1 , e j2 , e j3 , e j4 ) according to Appendix B. e j1 corresponds to the embedding of a left bracket.In this case, whether the current position can be evaluated simply depends on whether e j5 corresponds to the embedding of a right bracket.</p>
<p>When all embeddings e jt are one-hot vectors, whether the expression at the current position can be calculated or not forms a look-up table.Therefore, it can be implemented by a two-layer MLP with hidden dimension O(p 6 ) according to Lemma C.5.Similarly, the computed result and how much sentence length will be reduced after this calculation can also be implemented as look-up tables.However, some of the embeddings e jt may not be one-hot vectors when reaching an equal sign (as discussed above).In this case, we can similarly implement extra look-up tables that take a fewer number of inputs, and the result of which lookup table will be used depends on the position of the equal sign.This corresponds to a multivariate conditional selection operation with multiple Boolean conditions I[e jt • e id('=') = 1] (for t ∈ {1, 2, 3, 4, 5}), which can be similarly implemented by an MLP by extending Lemma C.4.Moreover, we note that the composition of look-up tables and the multivariate conditional selection operation can be merged in just one MLP by following the construction in Lemmas C.4 and C.5 (we omit the details for clarity).</p>
<p>The final output of the third layer is represented by
x (3) i = (e j1 , n = i , (n = i ) 2 , d = i , n= i , (n = i ) 2 , d= i , ( d= i ) 2 , f i , e outcome i , n reduce i ).
Here, f i is a Boolean value recording whether the next output at position i is a computed value, e outcome i is the one-hot embedding of the outcome when f i is true, and n reduce i records the reduced length after calculation when f i is true.When f i is false, e outcome i and n reduce i are undefined.Layer 4. Note that in an arithmetic expression there can be multiple expressions that can be calculated (or handles defined in Appendix B), all of which are processed in the last layer.Therefore, the fourth layer of the Transformer should keep only the leftmost calculation and discard other calculations (according to Appendix B).Meanwhile, for subsequent positions i after the position that has been calculated, this layer finds the related token that should be copied for position i based on the reduced setence length.Formally, we need two attention heads to perform the following tasks:</p>
<ol>
<li>Check whether there is an index j ≤ i such that n = j = n = i and f j is true.Denote the answer as fi = Similar to the construction of the third layer, we can construct the matrices Q, K and V as follows.</li>
</ol>
<p>For the first task, we leverage the MEAN operation with
q i = Qx (3) i = (1, (n = i ) 2 , 2n = i ), k j = Kx (3) j = (−(n = j ) 2 , −1, n = j ), v j = f j .
We have
q i • k j = −(n = i − n = j ) 2 . Therefore, q i • k j = 0 iff n = j = n = i
, and q i • k j ≤ −1 otherwise.This attention head thus outputs
1 di+1 i j=i−d = i f j .
For the second task, we leverage the COPY operation with
q i = Qx (3) i = (1, (n = i ) 2 , 2n = i , 1, 1), k j = Kx (3) j = (−(n = j ) 2 , −1, n = j , f j , −1), v j = n reduce j .
We have
q i • k j = −(n = i − n = j ) 2 + f j − 1. Therefore, q i • k j = 0 iff n = j = n =
i and f j = 1, and q i • k j ≤ −1 otherwise.Moreover, we set r j = −j in the COPY operation, by which the attention head copies n reduce j where j = min{j : n = j = n = i , f j = 1}, as desired.The output of the attention layer has the form
e outcome i , e j1 , n = i , (n = i ) 2 , n= i , (n = i ) 2 , d = i , d= i , ( d= i ) 2 , f i , fi d = i + 1 , nreduce i .
We next use an MLP to perform the third task, which is a conditional selection operation and can be done according to Lemma C.4.We can simultaneously obtain fi by multiplying fi
d = i +1 with (d = i + 1). We also compute (d = i + nreduce i ) 2
, which will be used in the next layer.The final output of the fourth layer is represented by
x (4) i = (ẽ outcome i , f i , n = i , (n = i ) 2 , n= i , (n = i ) 2 , d= i , ( d= i ) 2 , fi , nreduce i , d = i , (d = i + nreduce i ) 2 ),
where ẽoutcome i is either e outcome i or e j1 .</p>
<p>Layer 5.The final layer of the Transformer uses one attention head to copy the corresponding token for generating the output when fi ≥ 1 and f i is false.Similar to previous layers, we can copy the embedding e id(sj ) located at position j such that n=
j = n = i − 1 and d= j = d = i + nreduce i
. The output of the attention layer is (ẽ outcome i , e id(sj ) , f i , fi ).We then use an MLP to obtain the output: if fi − f i ≥ 1, then output e id(sj ) ; otherwise output ẽoutcome</p>
<p>D.2 Proof of Theorem 3.1</p>
<p>We now prove that evaluating arithmetic expressions without CoT is extremely difficult for boundeddepth autoregressive Transformers.We will make the widely-believed assumption that TC 0 = NC 1 (see Appendix A.2 for definitions of these complexity classes).We further need to notion of uniformity: informally, this condition says that there exists an efficient algorithm to construct the circuits.For a rigorous definition, we refer readers to Arora &amp; Barak [2].</p>
<p>Theorem D.2.Assume TC 0 = NC 1 .For any prime number p, any integer L, and any polynomial Q, there exists a problem size n such that no log-precision autoregressive Transformer defined in Section 2 with depth L and hidden dimension d ≤ Q(n) can solve the problem Arithmetic(n, p).</p>
<p>Proof.Our proof is based on leveraging the NC 1 -completeness of a classic problem: Boolean Formula Evaluation.According to the Buss reduction [11], calculating whether a Boolean formula is true or false is complete for uniform NC 1 .Based on this theorem, it suffices to prove that the Boolean Formula Evaluation problem can be reduced to evaluating the arithmetic expression.This will yield the conclusion by using the result that bounded-depth log-precision Transformers with polynomial size are in TC 0 [36] as well as the assumption that TC 0 = uniform NC 1 .</p>
<p>Formally, let Σ = {0, 1, ∧, ∨, ¬, (, )} be the alphabet.A Boolean formula is a string defined on alphabet Σ by the following recursive way:</p>
<p>• 0 and 1 are Boolean formulae;</p>
<p>• If ϕ is a Boolean formula, then ¬ϕ is a Boolean formula;</p>
<p>• If ϕ 1 , ϕ 2 are two Boolean formulae, then both (ϕ 1 ∧ ϕ 2 ) and (ϕ 1 ∨ ϕ 2 ) are Boolean formulae.</p>
<p>The Boolean Formula Evaluation problem aims to compute whether a Boolean formula is true (1) or false (0).We now show that we can translate this problem into the problem of evaluating arithmetic expressions.Given a Boolean formula s, the translation function f generates the corresponding arithmetic expression f (s) that has the same result as s under evaluation.The translation is recursively defined as follows:</p>
<p>• f (0) = 0 and f (1) = 1;</p>
<p>• For any Boolean formula ϕ, f (¬ϕ) = (1 − ϕ);
• For any Boolean formulae ϕ 1 , ϕ 2 , f ((ϕ 1 ∧ ϕ 2 )) = f (ϕ 1 ) × f (ϕ 2 ); • For any Boolean formulae ϕ 1 , ϕ 2 , f ((ϕ 1 ∨ ϕ 2 )) = (1 − (1 − f (ϕ 1 )) × (1 − f (ϕ 2 ))).
It is easy to see that for any Boolean formula s, the length of f (s) is upper bounded by O(|s|).Moreover, the translation function can be efficiently implemented using a parallel algorithm within TC 0 complexity (TC 0 is required to perform bracket matching).Also note that the above construction does not depend on the modulus p.Therefore, by reduction we obtain that the problem of evaluating arithmetic expressions is NC 1 -hard.</p>
<p>E System of Linear Equations</p>
<p>In this section, we will prove that the autoregressive Transformer equipped with CoT can solve a system of linear equations, whereas the autoregressive Transformer without CoT cannot solve it.</p>
<p>E.1 Proof of Theorem 3.4</p>
<p>For ease of reading, we restate Theorem 3.3 below: Theorem E.1.For any prime p and integer m &gt; 0, there exists an autoregressive Transformer defined in Section 2 with hidden size d = O(poly(p)) (independent of m), depth L = 4, and 5 heads in each layer that can generate the CoT solution defined in Appendix B for all inputs in Equation(m, p).Moreover, all parameter values in the Transformer are bounded by O(poly(m)).</p>
<p>Proof.The proof technique is similar to that of Theorem 3.3.We recommend readers to read the proof Theorem 3.3 first as we will omit redundant details in the subsequent proof.Below, without abuse of notation, we use x (l) i to denote the output at position i after the l-th Transformer layer, and use x i to denote the i-th variable in linear equations.We also note that m is the upper bound on the number of variables, and we will construct Transformer parameters such that the Transformer can solve all linear equations with the number of variables no more than m.</p>
<p>Token Embeddings.Assume that we have a sequence of tokens s 1 , s 2 , . . ., s t and we want to generate the next token s t+1 .We can embed the token s i using the format x (0) i = (e id(si) , l i , i, 1):
1.
The vector e i represents the one-hot vector with the i-th element being 1, and id(s i ) is the index of token s i in the vocabulary.Since we hope the embedding dimension is a constant and does not depend on the number of variable tokens m, we consider representing them using a unified (single) encoding and distinguishing them via the term l i .This means that if s i and s j are two different variables, we have id(s i ) = id(s j ) and l i = l j .</p>
<ol>
<li>
<p>l i ∈ R 3 is a vector used to distinguish between different variables.Its first element, denoted as var(s i ), represents the index of the variable s i .If the token s i is not a variable, then l i = (0, 0, 0) and var(s i ) = 0.If it is the variable x j for some j ∈ [m], then var(s i ) = j and l i = j, m 2 sin( 2jπ m ), m 2 cos( 2jπ m ) . 3. i is the positional embedding, representing the position of the token in the sequence.</p>
</li>
<li>
<p>The constant embedding 1 is used as a bias term.</p>
</li>
</ol>
<p>Layer 1.The first layer of the Transformer uses three attention heads to record some basic information:</p>
<ol>
<li>Count the number of ';' (i.e., equations) in previous tokens, denoted as n eq i = |{j ≤ i : s j = ';'}|.</li>
</ol>
<p>Count the number of '=⇒' in previous tokens, denoted as
n cot i = |{j ≤ i : s j = ' =⇒ '}|.
Namely, the current position belongs to the n cot i -th CoT step.3. Determine the number of variables in the system of linear equations.This can be done by copying var(s j ) for index j such that s j is a variable and var(s j ) is the largest.Denote the result as n var i .Note that according to the input format, n var i is correct whenever n eq i ≥ 1.Similar to the proof of arithmetic expression, the first and the second tasks can be implemented by two attention heads, which perform the MEAN operation to obtain the fraction of ';' and '=⇒' tokens in all previous tokens.The last attention head perform the COPY operation with S i = {j : j ≤ i : s j is a variable}, r j = var(s j ), and v j = var(s j ).Note that while r j1 = r j2 may hold for different positions j 1 , j 2 , their values are the same (i.e., v j1 = v j2 ), so the COPY operation still works and obtains n var i (when n eq i ≥ 1).Then, we use MLPs in parallel to calculate n eq i = (n eq i /i) • i and
n cot i = (n cot i /i) • i based on Lemma C.1.
Besides, we use an MLP to compute the auxiliary term i 2 that will be used in the next layer.Therefore, the output of the first layer is
x (1) i = (e id(si) , l i , i, i 2 , 1, n var i , n eq i , n cot i ).
Layer 2. As described in Appendix B, each CoT step eliminates one variable, and thus at the current position we are eliminating variable x n cot i .By the uniqueness of the solution, there must exist an equation with nonzero coefficient for variable x n cot i .In the second Transformer layer, we can determine which equation satisfies this condition.More precisely, we record whether the current equation will be used to eliminate the variable x n cot i +1 in the next CoT step n cot i + 1.We also use additional attention heads to perform some auxiliary calculations that will be used in subsequent layers.Concretely, the second layer uses four attention heads to perform the following tasks:</p>
<ol>
<li>Copy the value n eq j with position j corresponding to the nearest '=⇒' token s j (j ≤ i).Clearly, the value is well-defined when n cot i ≥ 1, and we define the value to be 0 if n cot i = 0. 2. Compute d eq i = n eq i − n eq j + 1, which corresponds to the index of the current equation in the current CoT step.</li>
</ol>
<p>3.</p>
<p>Copy the embedding e id(sj ) with the smallest j satisfying n eq j = n eq i and s j is a number.Note that e id(sj ) is well-defined when s i = '='.4. Compute a Boolean flag (denoted as f i ), which is true only when e id(sj ) = e id(0) , d eq i &gt; n cot i , and s i = '='.The definition of f i means that in the n cot i -th CoT step, we only focus on the j-th equation when j &gt; n cot i and check whether the first number in the equation is non-zero.If it is non-zero, we set the flag to true at the specific position corresponding to token '='.</p>
<p>5.</p>
<p>Copy the embeddings (e id(si−1) , l i−1 ) and (e id(si−2) , l i−2 ) of the (i − 1)-th and (i − 2)-th token.</p>
<p>The first task can be implemented by an attention head via the COPY operation to obtain n eq j when n cot i ≥ 1.For the third task, we construct the matrices Q, K, V of the COPY operation such that
q i = Qx (1) i = (−n eq i , 1, 1, 1), k j = Kx(1)j =   1, n eq j , a∈[p] I[s j = a], −1   , v j = e id(sj )
, and r j = −j.By construction, q i • k j = (n eq j − n eq i ) + a∈[p] I[s j = a] − 1, and thus q i • k j = 0 only when n eq j = n eq i and s j is a number, and q i • k j ≤ −1 otherwise.Furthermore, the choice of r j guarantees that the leftmost position satisfies q i • k j = 0 is copied.This exactly solves the third task.For the fifth task, we use two attention heads to perform the COPY operation.We only give the construction of the first head that copies (e id(si−1) , l i−1 ).The matrices Q, K, V of the COPY operation is constructed such that
q i = Qx (1) i = ((i − 1) 2 , i − 1, −1), k j = Kx (1) j = (−1, 2j, j 2 ), v j = (e id(sj ) , l j ),andq i • k j = 0 iff j = i − 1.
We next use an MLP to correct the value of n eq j when n cot i = 0 and compute the second task, which is a linear operation.We also compute an auxiliary flag I[n cot i = d eq i ] via an MLP.Regarding the fourth task, it is a multivariate conditional selection operation and can be similarly implemented by an MLP by extending Lemma C.4.Note that we can compute the second task and the fourth task in parallel using a two-layer MLP because both tasks correspond to (multivariate) conditional selection and can be merged.We finally use multiplication to compute the auxiliary terms (n cot i ) 2 , (var(s i )) 2 and (var(s i−1 )) 2 .The output of the MLP is
x (2) i
= (e id(si) , l i , i, i 2 , 1, n var i , n cot i , (n cot i ) 2 , d eq i , f i , e id(si−1) , l i−1 , e id(si−2) , l i−2 , (var(s i−1 )) 2 , (var(s i )) 2 , I[n cot i = d eq i ]).</p>
<p>Layer 3. The third layer of the Transformer uses two attention heads to perform the following tasks:</p>
<ol>
<li>
<p>Copy the embedding d eq j with the smallest j satisfying f j = 1 and n cot j = n cot i − 1. Denote the answer as deq i .2. Determine whether the next token s i+1 is a number.Denote the result as f num i .</p>
</li>
<li>
<p>Determine the output of the next token s i+1 if s i+1 is not a number.We denote its embedding as e next i .Also, we need to determine the variable index var(s i+1 ) of the next token if the next token is a variable.4. Determine the token s i+2 if the next token s i+1 is a number.There are two cases: s i+2 is a variable, and s i+2 is the token ';'.Denote the result as e next2 i and var(s i+2 ) and compute (var(s i+2 )) 2 .</p>
</li>
<li>
<p>If the current token s i is a variable, copy the embedding e id(sj−1) (which is a number) for index j satisfying n cot j = n cot i , n cot j = d eq j , and var(s j ) = var(s i ).Denote the answer as e cot_num i .When s i is not a variable or d eq i ≤ n cot i , e cot_num i is undefined.</p>
</li>
</ol>
<p>We can use an attention head to perform the COPY operation that completes the first task.The construction is similar to the fourth layer in arithmetic expression and we omit it for clarity.The second attention head performs the fifth task, which can also be done via the COPY operation.</p>
<p>Regarding the second task, whether the next token is a number can be purely determined by d eq i , n cot i , and the current token s i .Specifically, s i+1 is a number if s i = '+', or s i = '=', or (s i = ';' and d eq i &gt; n cot i ).Whether the output of the next token is a variable can also be purely determined by the previous tokens s i−1 , s i and also d eq i and n cot i .Specifically, s i+1 is a variable if s i−1 = '+' and s i is a number, or s i−1 = ';' and s i is a number, or (s i = ';' or s i = ' =⇒ ') and d eq i ≤ n cot i .The variable index can be determined by either var(s i−2 ) or d eq i .When the next token is neither a variable nor a number (i.e., the symbols '+', '=', ';', or '=⇒', we can similarly determine the token by checking s i−1 , s i , d eq i , and n var i .When the next token is a number, s i+2 can be determined by checking the variable s i−1 via three cases: (i) if s i−1 is a variable and var(s i−1 ) &lt; n var i , then s i+2 is a variable and var(s i+2 ) = var(s i−1 ) + 1; (ii) if s i−1 is a variable and var(s i−1 ) = n var i , then s i+2 = ';'; (iii) otherwise, s i−1 is a number, then s i+2 is a variable and var(s i+2 ) = n cot i + 1.All these tasks can implemented by MLPs that performs the conditional selection or look-up table based on Lemmas C.4 and C.5.Moreover, the composition of conditional selection and lookup table can be merged into a single two-layer MLP (as shown in the construction of the third layer in arithmetic expression).We next use multiplication to compute the auxiliary terms (d eq i ) 2 , (d eq i + I[s i+2 = ';']) 2 , and ( deq i ) 2 .However, to compute (var(s i+2 )) 2 , we cannot use multiplication directly as the composition of multiplication and conditional selection will require a deeper MLP.Instead, note that (var(s i+2 )) 2 linearly depends on (var(s i−1 )) 2 and var(s i−1 ), or linearly depends on (n cot i ) 2 and n cot i , all of which is already computed.Therefore, we can compute (var(s i+2 )) 2 without multiplication.The output of this layer has the form ).
x (3) i = (e id(si) , l i , i, 1, n var i , n cot i , (n cot i ) 2 ,
Layer 4. The fourth layer of the Transformer performs the the core calculation of equation coefficients when the next token is a number.There are two equations related to the calculation: the d eq i -th equation in the last CoT step, and the deq i -th equation in the last CoT step.There are also two variables related to the calculation: the variable x var(si+2) and x n cot i .Specifically, we need to copy four coefficients a deq i ,n cot i , a deq i ,var(si+2) , a d eq i ,n cot i , a d eq i ,var(si+2) defined as follows:</p>
<p>The deq i -th equation:
• • • + a deq i ,n cot i x n cot i + • • • + a deq i ,var(si+2) x var(si+2) + • • • = b deq i
The d eq i -th equation:
• • • + a d eq i ,n cot i x n cot i + • • • + a d eq i ,var(si+2) x var(si+2) + • • • = b d eq i
For the case of s i+2 = ';', we need to copy coefficients b deq i and b d eq i .To unify the two cases, this Transformer layer uses four attention heads to perform the following tasks (note that we define var(s j ) = 0 when s j is not a variable):</p>
<ol>
<li>Copy the embedding e id(sj−1) for position j satisfying n cot j = n cot i − 1, d eq j = deq i , s j is a variable, and var(s j ) = n cot i .2. Copy the embedding e id(sj−1) for position j satisfying n cot j = n cot i − 1, d eq j = deq i + I[s i+2 = ';'], e id(sj ) = e next2 i , and var(s j ) = var(s i+2 ).</li>
</ol>
<p>3.</p>
<p>Copy the embeddings e id(sj−1) and e cot_num j for position j satisfying n cot j = n cot i −1, d eq j = d eq i , s j is a variable, and var(s j ) = n cot i .4. Copy the embedding e id(sj−1) and e cot_num j for position j satisfying n cot j = n cot i − 1, d eq j = d eq i + I[s i+2 = ';'], e id(sj ) = e next2 i , and var(s j ) = var(s i+2 ).</p>
<p>Note that for each task, there is exactly one index j satisfying the condition, and thus the copied embeddings contain the four coefficients defined above.Overall, the coefficient can be computed by a composition of look-up tables and (multivariate) conditional selection operations, which can be merged in a single two-layer MLP.</p>
<p>Now two more things remains to be done.The first is to obtain the 3-dimensional embedding l i+1 when s i+1 is a variable, while currently we have only obtained var(s i+1 ).However, we cannot compute the remaining two dimensions m 2 sin( 2var(si+1)π m</p>
<p>) and m 2 cos( 2var(si+1)π m ) since we do not assume that the MLP can approximate sin and cos functions.Nevertheless, this can be done by directly copying the embedding l j for any j such that s j is the variable x var(si+1) by using an attention head.Finally, the output is conditioned on the flag f num i : when f num i is true, this layer outputs the computed coefficient embedding; otherwise, it outputs e next i and l i+1 .We denote the output of this layer as x (4) i = (e out i , l out i ).Linear projection and softmax layer.Finally, we pass it through a softmax layer to predict the next token s i+1 .Unlike the proof of arithmetic expression, here the embedding l out i is not one-hot (which contains var(s i+1 )), so we need to additionally prove the following result: let the output logit corresponding to token t (before softmax) be z t (e, l) = w t When var(t) = var( t), we have id(t) = id( t) and thus Gap = 1.Otherwise,
Gap ≥ 1 − m 2 + m 4 (1 − cos(2π/m)) = 1 − m 2 + m 4 sin 2 (π/m) ≥ 1,
where we use the fact that sin(x) ≥ x/π whenever 0 &lt; x ≤ π/2.Now it remains to conduct an error analysis and determine the scale of parameters.Similar to the proof of arithemetic expression, we can prove that all parameter values in the Transformer are bounded by O(poly(n)).</p>
<p>E.2 Proof of Theorem 3.2</p>
<p>We will now prove that solving a system of linear equations without CoT is extremely difficult for bounded-depth autoregressive Transformers.</p>
<p>Theorem E.2.Assume TC 0 = NC 1 .For any prime number p, any integer L, and any polynomial Q, there exists a problem size m such that no log-precision autoregressive Transformer defined in Section 2 with depth L and hidden dimension d ≤ Q(m) can solve the problem Equation(m, p).</p>
<p>Proof.Our proof is based on leveraging the NC 1 -completeness of a classic problem: Unsolvable Automaton Membership Testing.According to Barrington's theorem [3,4], given a fixed unsolvable automaton, judging whether the automaton accepts an input is complete in NC 1 .Below, we will prove that solving the system of linear equations is NC 1 -hard by demonstrating that the Unsolvable Automaton Membership Testing problem is NC 0 reducible to the problem of solving a system of linear equations.This will yield the conclusion since bounded-depth log-precision Transformers with polynomial size are in TC 0 [36].</p>
<p>Let D = (Q, Σ, δ, F, q 0 ) be any automaton, where Q is a set of states, Σ is a set of symbols (alphabet), δ : Q × Σ → Q is the transition function, F ⊂ Q is a set of accept states, and q 0 is the initial state.For any input string ω 1 ω 2 • • • ω n , whether D accepts the string can be reduced into solving a system of linear equations defined as follows.The system of linear equations has (n + 1)|Q| + 1 variables, which we denote as x * and x i,q (i ∈ {0, • • • , n}, q ∈ Q).The equations are defined as follows:
    
x * = q∈F x n,q x 0,q0 = 1 x 0,q = 0 for q ∈ Q{q 0 } x i,q = δ(r,ωi)=q x i−1,r for 0 &lt; i ≤ n, q ∈ Q It is easy to see that x i,q = 1 iff the automaton arrives at state q when taking the substring ω 1 ω 2 • • • ω i as input.Therefore, x * = 1 iff the automaton accepts the input string.Note that the above solution does not depend on the modulus p, and the solution of these equations always exists and is unique.</p>
<p>Furthermore, the coefficient of each equation only depends on at most one input symbol.This implies that these equations can be efficiently constructed using a highly parallelizable algorithm within a complexity of NC 0 .Therefore, by reduction we obtain that the problem of judging whether there exists a solution such that x * = 1 is NC 1 -hard.Now consider solving linear equations using a Transformer without CoT.While the output of the Transformer contains multiple tokens, we can arrange the order of variables such that the Transformer has to output the value of x * first.The parallel complexity of outputting the first token is bounded by TC 0 according to [36].Therefore, it cannot judge whether there exists a solution satisfying x * = 1.</p>
<p>F Dynamic Programming F.1 Examples</p>
<p>Longest Increasing Subsequence (LIS).The LIS problem aims to compute the length of the longest increasing subsequence given an input sequence s ∈ N n .Formally, s is a subsequence of s if there exists indices
1 ≤ i 1 ≤ i 2 ≤ • • • ≤ i |s| ≤ n such that sk = s i k holds for all k ∈ [|s|]. A sequence s is called increasing if s1 &lt; s2 &lt; • • • &lt; s |s| .
The LIS problem aims to find an increasing subsequence of s with maximal length.A standard DP solution is to compute the length of the longest increasing subsequence that ends at each position i, which we denote as dp(i).It is easy to write the transition function as follows:
dp(i) = 1 + max j&lt;i,sj &lt;si dp(j).(20)
The final answer will be max i∈[n] dp(i).</p>
<p>However, the above DP transition function does not match the form of (5), since dp(i) may depend on (an unbounded number of) all previous dp(j) (j &lt; i).Nevertheless, this issue can be easily addressed by using a different DP formulation.Let dp(j, k) be the longest increasing subsequence that ends at position j and the second last position is no more than k (k &lt; j).In this case, it is easy to write the transition function as follows:
dp(j, k) = 1 if k = 0 max(dp(j, k − 1), dp(k, k − 1) • I[s j &gt; s k ] + 1) if k &gt; 0(21)
The final answer will be max i∈[n] dp(i, i − 1).This DP formulation fits our framework (5).</p>
<p>Edit Distance (ED).The ED problem aims to find the minimum operation cost required to convert a sequence u ∈ Σ n1 to another sequence v ∈ Σ n2 .There are three types of operations: inserting a letter into any position, deleting a letter from any position, and replacing a letter at any position by a new one.The costs of insert, delete, and replace are a, b, and c, respectively.These operations are sequentially executed and the total operation cost is the summation of all costs of individual operations.</p>
<p>A standard DP solution is to compute the minimum operation cost to convert the substring u 1 u 2 • • • u j to the substring v 1 v 2 • • • v k , which we denote as dp(j, k).It is easy to write the transition function as follows:
dp(j, k) =    ak if j = 0 bj if k = 0 min(dp(j, k−1) + a, dp(j −1, k) + b, dp(j −1, k−1) + cI[s (1) j = s (2) k ]) otherwise (22
) The final answer will be dp(n 1 , n 2 ).This DP formulation fits our framework (5).</p>
<p>CFG Membership Testing.</p>
<p>A context-free grammar (CFG) is a 4-tuple, denoted as G = (V, Σ, R, S), where • V is a finite set of non-terminal symbols.</p>
<p>• Σ is a finite set of terminal symbols, disjoint from V.</p>
<p>• R is a finite set of production rules, where each rule has the form A → β, with A ∈ V and β ∈ (V ∪ Σ) * (the asterisk represents the Kleene star operation).• S ∈ V is the start symbol.</p>
<p>The non-terminal symbols in V represent (abstract) syntactic categories, while the terminal symbols in Σ represent the actual words/tokens of the language.The production rules in R specify how a nonterminal symbol can be replaced by sequences of terminal and non-terminal symbols concatenated together.Below, we focus on a specific class of CFG known as Chomsky Normal Form (CNF) [49].</p>
<p>CNF is a canonical representation of CFG introduced by linguist Noam Chomsky.It has only three types of production rules:</p>
<p>• A → BC, where A, B, C are all non-terminals and B, C = S; • A → a, where A is a non-terminal and a is a terminal; • S → , if the empty string is in the language generated by the CFG.</p>
<p>It has been proved that any CFG can be transformed into a CNF expressing the same language.</p>
<p>The CFG Membership Testing problem is defined as follows: given CFG G, judge whether a string can be generated from G. The CYK algorithm [47] is a classic algorithm to solve the CFG Membership Testing problem when the CFG is written in CNF.The algorithm is based on DP and has a complexity of of O(n 3 ) for an input string of length n.Given a string v, n = |v|, the state space is defined as I = {(i, j, k, A) : 1 ≤ i ≤ k ≤ j ≤ n, A ∈ V}, where dp(i, j, k, A) stores whether the substring v i • • • v j can be generated by nonterminal A and there exist index k &lt; k and production rule A → BC such that the substring v i • • • v k can be generated by nonterminal B and the substring v k+1 • • • v j can be generated by nonterminal C. For the boundary setting when i = j = k, dp(i, i, i, A) simply stores whether the substring v i can be generated by the production rule A → v i .The transition function can be written as
dp(i, j, k, A) =            I[A → v i is in R] if i = j = k, 0 if i &lt; j, k = i, I   dp(i, j, k − 1, A) + A→BC is in R dp(i, k, k, B) • dp(k, j, j, C) &gt; 0    otherwise.
The final answer will be dp(1, n, n, S).This DP formulation fits our framework (5) (since the summation is finite given a fixed CFG G).</p>
<p>Regarding Remark 4. • conditional selection (Lemma C.4), for example,
f select (x) = f &gt; (x) if x ≥ 0, f &lt; (x) if x &lt; 0,
where f &gt; and f &lt; are functions that can be implemented by MLPs with ReLU activation, and x ∈ Z.</p>
<p>This implies that the MLP with ReLU activation can approximate the functions f , g, h in the transition function for the above three DP problems.According to Lemma C.2, these functions can be efficiently approximated by a perceptron of constant size with GeLU activation.Similarly, the topological ordering can also be efficiently implemented by MLPs with GeLU activation:
• LIS: (j, k) → (j, k + 1) if k &lt; j − 1 (j + 1, 0) if k = j − 1 • ED: (j, k) → (j, k + 1) if k &lt; n 2 (j + 1, 0) if k = n 2 • CFG Membership Testing: (i, j, k, A) →      (i, j, k, next(A)) if A = last(V) (i, j, k + 1, first(V)) if A = last(V) and k &lt; j (i + 1, j + 1, i + 1, first(V)) if A = last(V) and k = j &lt; n (1, j − i + 2, 1, first(V)) if A = last(V) and k = j = n
where we order the set V and denote first(V) as the first element of V, last(V) as the last element of V, and denote next(A) the successor element of A.</p>
<p>Therefore, Assumptions 4.3 to 4.5 are satisfied and all three problems can be solved by autoregressive Transformers with CoT.</p>
<p>F.2 Proof of Theorem 4.7</p>
<p>In this subsection, we will give proof of the Theorem 4. , where each part of the embedding is defined as follows:</p>
<ol>
<li>
<p>e input k is the embedding of the input token s k ∈ X .If the current position does not represent an input token, then e input k = 0.</p>
</li>
<li>
<p>e state k is the embedding of the DP state in I at position k.If the current position corresponds to an input token or the final answer, then e state k = 0. We also assume that for all i ∈ I, the embedding of state i is non-zero.</p>
</li>
</ol>
<p>e sep</p>
<p>k is the embedding of the separator | separating different input sequences.We set e sep k = e j if the current token s k is the j-th separator, where e j is the one-hot vector with the j-th element begin 1. ).We assume that the embedding of ∅ is 0.</p>
<p>• Set the flag f state Block 3. The third block of the Transformer uses K + J heads to perform the following tasks (where K and J are defined in (5)):</p>
<p>• Copy the input token embeddings corresponding to s g (n) 1 (i) , • • • , s g (n) J (i) where i corresponds to e next_state k .When g (n) t (i) = ∅, we set s g (n) t (i) to be a special token.</p>
<p>• Copy the DP value embeddings corresponding to dp(h  • Generate the output based on the flag f answer k .</p>
<p>For the first task, if the aggregation function is max or min, we use one attention head to simply copy the embedding e dp j for index j such that f answer j = 1 and e dp j is the largest/smallest, according to Lemma C.7.If the aggregation function is , we use two attention heads, where one attention head computes the mean of e dp j for index j such that f answer j = 1, and the other attention head calculates the fraction of elements in the sequence such that f answer j = 1.Finally, the second task is a conditional selection operation and thus can be implemented by an MLP (Lemma C.4).</p>
<p>F.3 Proof of the Theorem 4.8 Theorem F.2. Assume TC 0 = P.There exists a context-free language such that for any depth L and any polynomial Q, there exists a sequence length n ∈ N where no log-precision autoregressive transformer with depth L and hidden dimension d ≤ Q(n) can generate the correct answer for the CFG Membership Testing problem for all input strings of length n.</p>
<p>Proof.According to the previous work [28], the CFG Membership Testing problem is P-complete.With the assumption that TC 0 = P, the CFG Membership Testing problem is out of the capacity of the log-precision autoregressive transformer.</p>
<p>G Experimental Details</p>
<p>In this section, we present the experimental details.</p>
<p>G.1 Datasets</p>
<p>We set the number field p = 11 in the math experiments.In the LIS experiment, we set the number of different input tokens to 150; in the ED experiment, we set the number of different input tokens to 26.The vocabulary is constructed by including all symbols.For all tasks and settings (direct v.s.CoT), the size of the training and testing dataset is 1M and 0.1M respectively.The constructions of different datasets are introduced below.</p>
<p>Arithmetic Expression.All arithmetic expression problems are generated according to Algorithm 1.In Algorithm 1, we first create a number that serves as the answer to the problem.We then decompose the number using sampled operators sequentially, serving as the problem, until the maximum number of operators is met.The CoT procedure is precisely defined by reversing this problem generation process.For example, a sample in the direct dataset looks like 1 + 5 × (1 − 2) = 7 while the corresponding sample in the CoT data looks like 1 + 5 × (1 − 2) = 1 + 5 × 10 = 1 + 6 = 7</p>
<p>Linear Equation.All linear equation problems are generated according to Algorithm 2. In Algorithm 2, we consider the linear systems that only have a unique solution.Given a sampled linear system that satisfies this condition, we "translate" it to a sequence by concatenating all the equations (separated by commas), which serves as the problem.The answer to the problem is also a sequence consisting of variables and the corresponding values.The CoT solution of each problem is the calculation process of the Gaussian elimination algorithm applied to each variable sequentially.For example, a sample in the direct dataset looks like 2x 1 + 3x 2 + 3x 3 = 8, 1x 1 + 7x 2 + 0x 3 = 0, 0x 1 + 2x 2 + 1x [SEP] 4</p>
<p>G.2 Model training</p>
<p>We use the minGPT implementation3 for all the experiments, where the detailed Transformer layer are listed below.
X (0) = LayerNorm <a href="23">v 1 + p 1 , • • • , v n + p n </a>Attn (l) (X) = H h=1 softmax XW (l,h) Q (XW (l,h) K ) / √ d + M XW (l,h) V W (l,h) O(24)
FFN (l) (X) = σ(XW</p>
<p>Y (l−1) = X (l−1) + Attn (l) (LayerNorm(X (l−1) ))</p>
<p>X (l) = Y (l−1) + FFN (l) (LayerNorm(Y (l−1) ))</p>
<p>We use sinusoidal positional embedding and use Xavier initialization for all the parameters.The activation function is chosen to be GeLU.The dimension of the embedding is set to 256, and the number of heads is set to 4. The hidden size in the FFN layer is set to 1024.</p>
<p>We use the same hyperparameter configuration for all experiments, i.e., the performance comparison between the models trained on the direct and CoT datasets of Arithmetic, Equation, LIS, and ED tasks, and the additional length extrapolation experiments (which we use relative positional encodings [42] instead of absolute positional encodings).In detail, we use AdamW optimizer with β 1 , β 2 = 0.9, 0.999.The learning rate is set to 1e-4, and the weight decay is set to 0.01.We set the batch size to 512 during training with a linear learning rate decay scheduler.We use learning rate warm-up, and the warm-up stage is set to 5 epochs.The dropout rate is set to 0.1.The total number of training epochs is set to 100.</p>
<p>Figure 1 :
1
Figure 1: Illustrations of CoT on two math tasks.</p>
<p>Theorem 3 . 1 .Theorem 3 . 2 .
3132
Assume TC 0 = NC 1 .For any prime number p, any integer L, and any polynomial Q, there exists a problem size n such that no log-precision autoregressive Transformer defined in Section 2 with depth L and hidden dimension d ≤ Q(n) can solve the problem Arithmetic(n, p).Assume TC 0 = NC 1 .For any prime number p, any integer L, and any polynomial Q, there exists a problem size m such that no log-precision autoregressive Transformer defined in Section 2 with depth L and hidden dimension d ≤ Q(m) can solve the problem Equation(m, p).</p>
<p>Theorem 3 . 3 .
33
Fix any prime p.For any integer n &gt; 0, there exists an autoregressive Transformer defined in Section 2 with constant hidden size d (independent of n), depth L = 5, and 5 heads in each layer that can generate the CoT solution defined in Appendix B for all inputs in Arithmetic(n, p).Moreover, all parameter values in the Transformer are bounded by O(poly(n)).Theorem 3.4.Fix any prime p.For any integer m &gt; 0, there exists an autoregressive Transformer defined in Section 2 with constant hidden size d (independent of m), depth L = 4, and 5 heads in each layer that can generate the CoT solution defined in Appendix B for all inputs in Equation(m, p).Moreover, all parameter values in the Transformer are bounded by O(poly(m)).</p>
<p>Figure 2 :
2
Figure 2: Model performance on different tasks.For all tasks and various difficulty levels, autoregressive Transformers with CoT consistently outperform Transformers trained on direct datasets.In particular, 3-layer Transformers already succeed in these tasks with almost perfect accuracy, while deeper Transformers (L = 3, 4, 5) trained on the direct datasets typically fail.</p>
<p>Figure 3 :
3
Figure 3: Performance of length extrapolation experiment, tested on sequences that are longer than those in training.</p>
<p>Lemma C. 1 .
1
Let f : R 2 → R be a two-layer MLP with GeLU activation, and the hidden dimension is 4.Then, for any &gt; 0 and M &gt; 0, there exist MLP parameters with ∞ norm upper bounded by O(poly(M, 1/ )) such that |f (a, b) − ab| ≤ holds for all a, b ∈ [−M, M ].</p>
<p>7 8 δ.
8
By setting λ = 8M ln( 2nM ) δ 2 and µ = 3 ln( 2nM ) δ (which are bounded by O(poly(M, 1/δ, log(n), log(1/ )))), we have a i,pos(i) ≥ exp(−λρ) exp(−λρ) + (n − 1) exp(max(−λδ + 2M µ, λρ − µδ))</p>
<dl>
<dt>Figure 4 :</dt>
<dt>4</dt>
<dt>Figure 4: Illustration of the proof of Theorem 3.3.</dt>
<dd>
<p>3 .
3
i j=i−d = i f j , where fi ≥ 1 means the answer is yes, and fi = 0 otherwise.2. If the answer is yes ( fi ≥ 1), copy the value n reduce j at the leftmost position j satisfying f j is true and n = j = n = i .Denote the result as nreduce i Filter the outcome: if f i is true, then maintain e outcome i , otherwise set e outcome i to e j1 .</p>
</dd>
</dl>
<p>i.</p>
<p>This corresponds to a conditional selection operation and can be implemented by an MLP according to Lemma C.4.Finally, we pass the output through a softmax layer to generate the next token s i+1 .Now it remains to conduct an error analysis and determine the scale of parameters.Note that we can tolerate O(1) error of the final layer output in the sense that the generated token s i+1 is still correct.Based on Lemmas C.1, C.4, C.5, C.7 and C.8, we can guarantee that when all parameters of the Transformer are bounded by O(poly(n, 1/ )), all intermediate neurons will only induce an error below .(Also note that Assumption C.6 in Lemmas C.7 and C.8 is satisfied when is small enough.)Therefore, by picking a fixed small = Θ(1), all parameter values in the Transformer are bounded by O(poly(n)).</p>
<p>6 .
6
It can be easily verified that the state spaces of the three problems mentioned above are of polynomial size, satisfying Assumption 4.2.Additionally, the MLP with the ReLU activation function can implement (the composition of) the following functions: • max(a, b) and min(a, b), where a, b ∈ R; • I[a = b], I[a &lt; b], I[a &gt; b], where a, b ∈ Z; • a × b, where a ∈ R, b ∈ {0, 1}; • linear transformation;</p>
<ol>
<li>e dp k is the</li>
</ol>
<p>embedding of the DP value in Y at position k.If the current position corresponds to an input token or the final answer, then e dp k = 0. 4. e answer k is the embedding of the answer token in Z, and e answer k = 0 if the current position corresponds to an input token or an intermediate DP position.</p>
<p>6 .Block 1 . 1 k− 1 , p sep, 2 k− p sep, 1 k− 1 , 1 k− 1 • 0 .Block 2 .
61112111102
The position embedding k indicates the index of the token in the sequence.The first block of the autoregressive Transformer contains several layers.It first uses N attention heads to perform the following task: • Copy the positional embedding of the N separators p sep,1 k , • • • , p sep,N k ∈ N. Similar to the previous proofs, this can be achieved via the COPY operation with S k = {j ≤ k : e sep j = e t } for t ∈ [N ] and v j = j.Then, several MLPs follow, which perform the following tasks: • Calculate the problem size n k = (p sep,• • • , p sep,N k − p sep,N −Obtain the next state e next_state k .If the current state is already the last state, set e next_state k = The first task is a linear transformation, which can clearly be processed by an MLP Proposition C.3.According to Assumption 4.4, we can use an MLP to compute the embedding of the next state e next_state k based on the embedding of the current state e state k and the problem size n.When the required MLP in Assumption 4.4 has multiple layers (i.e., L layers), we can use L − 1 Transformer layers to implement a L-layer MLP.This can be achieved by just zero the weight matrices in the attention layers while maintaining the input using residual connections.The output of this block is x (1) k = (e input k , e state k , e next_state k , e dp k , e sep k , n k , k, 1).The second layer of the Transformer does not use attention heads.It only uses the MLP to perform the following tasks: • Calculate h (n) (e next_state k ) and g (n) (e next_state k</p>
<p>k)) 2 ,)) 2 ,
22
representing whether current state e state k is the last state.• Set the flag f answer k representing whether current state e state k is in the set A, i.e., used in the aggregation function.Similar to the first block, we stack several two-layer perceptrons to implement a multilayer perceptron.According to Assumptions 4.3 and 4.5, we can use an MLP to complete the first and the last tasks.The second task can be done by checking whether e state k = 0 and e next_state k = 0. We also compute the auxiliary quantities (h (n) (e next_state k )) 2 , (g (n) (e next_state k )) 2 , (e state k ) 2 , and k 2 , which are elementwise square operations and can be implemented by an MLP (Lemma C.1).The output of this block is x (2) k = (e input k , e state k , e next_state k , e dp k , e sep k , n k , h (n) (e next_state k ), g (n) (e next_state k ), (h (n) (e next_state k (g (n) (e next_state k (e state k ) 2 , f state k , f answer k , k, k 2 , 1).</p>
<p>)), • • • , dp(h (n) K (i)) for i corresponds to e next_state k .When h (n) t (i) = ∅, we set dp(h (n) t (i))to be a special value.•Calculate the output dp(i) for i corresponds to e next_state k , denoted as e next_dp k .The first two tasks can be done via the COPY operation.To copy DP values, the attention head attends to positions j with e state j matching h(n) t (i) for t ∈ [K].To copy input tokens, the attention head attends to positions j = g</p>
<p>tBlock 4 .
4
(i) for t ∈ [J].To handle the special token/value, it is simply a conditional selection operation and can be handled by an MLP (Lemma C.4).According to Assumption 4.3, we can calculate the function f (defined in (5)) using an MLP.The output of this layer is x(3) k = (e next_state k , e dp k , e next_dp k , n k , f state k , f answer k , k, 1).The fourth block of the autoregressive transformer contains one Transformer layer.Depending the aggregation function, it uses one attention head for the operation max or min, or two attention heads for the operation .This block performs the following tasks:• Aggregate the DP values according to the aggregation function Equation(6).</p>
<p>3 = 1 ,
31
[SEP]  x 1 = 4, x 2 = 1, x 3 = 10, while the corresponding sample in the CoT dataset looks like2x 1 + 3x 2 + 3x 3 = 8, 1x 1 + 7x 2 + 0x 3 = 0, 0x 1 + 2x 2 + 1x 3 = 1, [SEP] x 1 + 7x 2 + 7x 3 = 4, 0x 2 + 4x 3 = 7, 2x 2 + 1x 3 = 1, [SEP] x 1 + 9x 3 = 6, x 2 + 6x 3 = 6, 4x 3 = 7, [SEP] x 1 = 4, x 2 = 1, x 3 =10, model input.For the calculation of edit distance, we assign different costs to different operators.The costs for the ADD and DELETE operators are set to 2, while the REPLACE operator is assigned a cost of 3, since REPLACE should be more costly than ADD/DELETE while less costly than their summation.The CoT procedure is also the DP array, defined in Section 4.1.For example, a sample in the direct dataset looks like a s | p a s s [SEP] 4 while the corresponding sample in the CoT dataset looks like a s | p a s s [SEP] 3 2 4 6 [SEP] 5 4 2 4</p>
<p>All assumptions above are mild.Assumption 4.2 is necessary to ensure that the state vectors can be represented using log-precision, and Assumptions 4.3 to 4.5 guarantee that all basic functions that determine the DP process can be well-approximated by a composition of finite log-precision Transformer layers of constant size.In Appendix F.1, we show these assumptions are satisfied for LIS and ED problems described above as well as the problem in Theorem 4.8.We are now ready to present our main result, which shows that LLMs with CoT can solve all DP problems satisfying the above assumptions.We give a proof in Appendix F.2.
and all δ ∞ &lt; ρ; (ii) all Assumption 4.2. The size of the state space can be polynomially upper bounded by the length of the elements of parameter θ are bounded by O(poly(1/ )). input sequence, i.e., |I| = O(poly(|s|)). Assumption 4.3. Each function f , g, h and u in (5) and (6) can be approximated with polynomial efficiency by a perceptron of constant size (with GeLU activation). Assumption 4.4. Denote (i 1 , • • • , i |I| ) as a feasible topological ordering of the state space I. Then, the function F : N N × I → I defined as F (n, i k ) = i k+1 , n ∈ N N , k ∈ [|I| − 1] can be approximated with polynomial efficiency by a perceptron of constant size (with GeLU activation). Assumption 4.5. The function F : N N × I → {0, 1} defined as F (n, i) = I[i ∈ A] (see (6)) can be approximated with polynomial efficiency by a perceptron of constant size (with GeLU activation). there exists an autoregressive Transformer with constant depth L, hidden dimension d and attention heads H (independent of n), such that the answer generated by the Transformer is correct for all input sequences s of length no more than n. Moreover, all parameter values are bounded by O(poly(n)). To complete the analysis, we next explore whether Transformers can directly predict the answer of DP problems without generating intermediate CoT sequences. We show generally the answer is no: many DP problems are intrinsically hard to be solved by a bounded-depth Transformer without CoT. One celebrate example is the Context-Free Grammar (CFG) Membership Testing, which tests whether an input string belongs to a pre-defined context-free language. A formal definition of this problem and a standard DP solution are given in Appendix F.1. We have the following impossibility result: Theorem 4.8. Assume TC 0 = P. There exists a context-free language such that for any depth L and any polynomial Q, there exists a sequence length n ∈ N where no log-precision autoregressive transformer with depth L and hidden dimension d ≤ Q(n) can generate the correct answer for the CFG Membership Testing problem for all input strings of length n. We give a proof in Appendix F.3. The reason why Theorem 4.8 holds is the same as in Theorems 3.1 and 3.2: the CFG Membership Testing is a P-complete problem [28], which is intrinsically hard to be solved by a well-parallelized computation model. Combined with the above theoretical results, we Remark 4.6. Theorem 4.7. Consider any DP problem satisfying Assumptions 4.2 to 4.5. For any integer n ∈ N, conclude that CoT plays a critical role in tackling tasks that are inherently difficult.</p>
<p>where 1 d is the all-one vector of d dimension.It is easy to check that, for allx ∈ [−M, M ] d1 ,y ∈ [−M, M ] d2 , and t ∈ [−∞, −α] ∪ [α, +∞], we have f (x, y, t) = g(x,y, t).Moreover, all parameters are bounded by O(M/α).Therefore, by using Lemma C.2, we can also implement g(x) by a two-layer MLP with GeLU activation and all parameters are bounded by O(poly(M, 1/α, 1/ )).final show that a two-layer MLP can efficiently represent a look-up table.Consider a kdimensional table of size d k , where each element in the table is an integer ranging from 1 to d. Denote the set D = {e
We
i : i ∈ [d]}, where e i is a d-dimensional one-hot vector with the i-th element being 1.The above look-up table can thus be represented as a discrete function g : D k → D. The following lemma shows that g can be implemented by a two-layer MLP with GeLU activation.Lemma C.5.Let g : D k → D be any function defined above, and let f : R k×d → R d be a two-layer MLP with GeLU activation and bias, and the hidden dimension is d k .Then, for any &gt; 0, there exist MLP parameters with ∞ norm bounded by O(poly(k, 1/ )), such that for all x ∈ D k ⊂ R k×d and all perturbation</p>
<p>, var(s i ), var(s i+1 ), var(s i+2 ), (var(s i )) 2 , (var(s i+2 )) 2 , e id(si−1) , e cot_num i
d eq i , (d eq i ) 2 , (d eq i + I[s i+2 = ';']) 2 , deq i , ( deq i ) 2 , f num i,e next i , e next2 i</p>
<p>• [e , l ] + b t , where w t and b t are parameters of the linear projection for logit t.Then, there exist parameters {w t , b t } t such that for any two tokens t and t with t = t To prove the above result, simply set w t = e id(t) , var(t), m 2 sin 2var(t)π
Gap :=z t e id(t) , var(t), m 2 sin2var(t)π m, m 2 cos2var(t)π m−z t e id( t) , var( t), m 2 sin2var( t)π m, m 2 cos2var( t)π m≥ Θ(1).m, m 2 cos 2var(t)π m.We haveGap =1 + (var(t)) 2 + m 4 − I[id(t) = id( t)] − var(t)var( t)− m 4 sin2var(t)π msin2var( t)π m+ cos2var(t)π mcos2var( t)π m=(1 − I[id(t) = id( t)]) + var(t)(var(t) − var( t)) + m 4 1 − cos2(var(t) − var( t))π m
https://github.com/karpathy/minGPT
Longest Increasing Subsequence.All input sequences (i.e., problems) are generated according to Algorithm 3. To make the task challenging enough, we first concatenate several increasing subsequences of given length, and then randomly insert numbers into the whole sequence.The inputs has 150 different tokens, ranging from 101 to 250 to avoid token overlap with DP array.The CoT solution to the problem is the DP array plus the final answer, which is defined in(20).Here, we consider the DP formulation(20)because the CoT output length is much shorter than the one corresponding to formulation(21).This allows us to consider more challenging input sequences with longer length.While this DP formulation does not precisely obey the theoretical assumption given in Assumption 4.3, we found that the Transformer can still learn it easily.Edit Distance.All input sequences (i.e., problems) are generated according to Algorithm 4. In Algorithm 4, we generate the first string randomly.For the generation of the second string, we use two methods.In the first method, we generate the second string randomly, corresponding to a large edit distance.In the second method, we copy the first string with random corruption, corresponding to a small edit distance.The two strings are concatenated by "|", and the concatenation is used as the
What learning algorithm is in-context learning? investigations with linear models. Ekin Akyürek, Dale Schuurmans, Jacob Andreas, Tengyu Ma, Denny Zhou, The Eleventh International Conference on Learning Representations. 2023</p>
<p>Computational complexity: a modern approach. Sanjeev Arora, Boaz Barak, 2009Cambridge University Press</p>
<p>Bounded-width polynomial-size branching programs recognize exactly those languages in nc. David A Barrington, Proceedings of the eighteenth annual ACM symposium on Theory of computing. the eighteenth annual ACM symposium on Theory of computing1986</p>
<p>Finite monoids and the fine structure of nc. David A , Mix Barrington, Denis Therien, Journal of the ACM (JACM). 3541988</p>
<p>The theory of dynamic programming. Richard Bellman, Bulletin of the American Mathematical Society. 6061954</p>
<p>On the ability and limitations of transformers to recognize formal languages. Satwik Bhattamishra, Kabir Ahuja, Navin Goyal, Proceedings of the 2020 Conference on Empirical Methods in Natural Language Processing (EMNLP). the 2020 Conference on Empirical Methods in Natural Language Processing (EMNLP)2020</p>
<p>On the computational power of transformers and its implications in sequence modeling. Satwik Bhattamishra, Arkil Patel, Navin Goyal, Proceedings of the 24th Conference on Computational Natural Language Learning. the 24th Conference on Computational Natural Language Learning2020</p>
<p>Language models are few-shot learners. Tom Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared D Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, Advances in neural information processing systems. 202033</p>
<p>Sébastien Bubeck, Varun Chandrasekaran, Ronen Eldan, Johannes Gehrke, Eric Horvitz, Ece Kamar, Peter Lee, Yin Tat Lee, Yuanzhi Li, Scott Lundberg, arXiv:2303.12712Sparks of artificial general intelligence: Early experiments with GPT-4. 2023arXiv preprint</p>
<p>Discovering latent knowledge in language models without supervision. Collin Burns, Haotian Ye, Dan Klein, Jacob Steinhardt, arXiv:2212.038272022arXiv preprint</p>
<p>The boolean formula value problem is in alogtime. Samuel R Buss, Proceedings of the nineteenth annual ACM symposium on Theory of computing. the nineteenth annual ACM symposium on Theory of computing1987</p>
<p>Data distributional properties drive emergent in-context learning in transformers. C Y Stephanie, Adam Chan, Andrew Santoro, Jane X Kyle Lampinen, Aaditya K Wang, Pierre Singh, James Harvey Richemond, Felix Mcclelland, Hill, Advances in Neural Information Processing Systems. 2022</p>
<p>Aakanksha Chowdhery, Sharan Narang, Jacob Devlin, Maarten Bosma, Gaurav Mishra, Adam Roberts, Paul Barham, Hyung Won Chung, Charles Sutton, Sebastian Gehrmann, arXiv:2204.02311Scaling language modeling with pathways. 2022arXiv preprint</p>
<p>Introduction to algorithms. Charles E Thomas H Cormen, Ronald L Leiserson, Clifford Rivest, Stein, 2022MIT press</p>
<p>Approximation by superpositions of a sigmoidal function. George Cybenko, Mathematics of control, signals and systems. 19892</p>
<p>Why can gpt learn in-context? language models secretly perform gradient descent as meta optimizers. Damai Dai, Yutao Sun, Li Dong, Yaru Hao, Zhifang Sui, Furu Wei, arXiv:2212.105592022arXiv preprint</p>
<p>Universal transformers. Mostafa Dehghani, Stephan Gouws, Oriol Vinyals, Jakob Uszkoreit, Lukasz Kaiser, International Conference on Learning Representations. 2019</p>
<p>BERT: Pre-training of deep bidirectional transformers for language understanding. Jacob Devlin, Ming-Wei Chang, Kenton Lee, Kristina Toutanova, Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies. Long and Short Papers. the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language TechnologiesAssociation for Computational Linguistics20191</p>
<p>Inductive biases and variable creation in self-attention mechanisms. Surbhi Benjamin L Edelman, Sham Goel, Cyril Kakade, Zhang, International Conference on Machine Learning. PMLR2022</p>
<p>A mathematical framework for transformer circuits. Nelson Elhage, Neel Nanda, Catherine Olsson, Tom Henighan, Nicholas Joseph, Ben Mann, Amanda Askell, Yuntao Bai, Anna Chen, Tom Conerly, Nova Dassarma, Dawn Drain, Deep Ganguli, Zac Hatfield-Dodds, Danny Hernandez, Andy Jones, Jackson Kernion, Liane Lovitt, Kamal Ndousse, Dario Amodei, Tom Brown, Jack Clark, Jared Kaplan, Sam Mccandlish, Chris Olah, 2021Transformer Circuits Thread</p>
<p>What can transformers learn in-context? a case study of simple function classes. Shivam Garg, Dimitris Tsipras, Percy Liang, Gregory Valiant, Advances in Neural Information Processing Systems. 2022</p>
<p>. Angeliki Giannou, Shashank Rajput, Jy-Yong Sohn, Kangwook Lee, Jason D Lee, Dimitris Papailiopoulos, arXiv:2301.131962023arXiv preprintLooped transformers as programmable computers</p>
<p>Theoretical limitations of self-attention in neural sequence models. Michael Hahn, Transactions of the Association for Computational Linguistics. 82020</p>
<p>Formal language recognition by hard attention transformers: Perspectives from circuit complexity. Yiding Hao, Dana Angluin, Robert Frank, Transactions of the Association for Computational Linguistics. 102022</p>
<p>Dan Hendrycks, Kevin Gimpel, arXiv:1606.08415Gaussian error linear units (gelus). 2016arXiv preprint</p>
<p>Ieee standard for floating-point arithmetic. IEEE Std. 2019IEEE Computer Society</p>
<p>How can we know what language models know? Transactions of the. Zhengbao Jiang, Frank F Xu, Jun Araki, Graham Neubig, 2020Association for Computational Linguistics8</p>
<p>Complete problems for deterministic polynomial time. D Neil, William T Jones, Laaser, Proceedings of the sixth annual ACM symposium on Theory of computing. the sixth annual ACM symposium on Theory of computing1974</p>
<p>Large language models are zero-shot reasoners. Takeshi Kojima, Shane Shixiang, Machel Gu, Yutaka Reid, Yusuke Matsuo, Iwasawa, Advances in Neural Information Processing Systems. 2022</p>
<p>Multilayer feedforward networks with a nonpolynomial activation function can approximate any function. Moshe Leshno, Vladimir Ya Lin, Allan Pinkus, Shimon Schocken, Neural networks. 661993</p>
<p>Transformers learn shortcuts to automata. Bingbin Liu, Jordan T Ash, Surbhi Goel, Akshay Krishnamurthy, Cyril Zhang, The Eleventh International Conference on Learning Representations. 2023</p>
<p>Pre-train, prompt, and predict: A systematic survey of prompting methods in natural language processing. Pengfei Liu, Weizhe Yuan, Jinlan Fu, Zhengbao Jiang, Hiroaki Hayashi, Graham Neubig, ACM Computing Surveys. 5592023</p>
<p>Fixing weight decay regularization in adam. Ilya Loshchilov, Frank Hutter, 2017</p>
<p>The expressive power of neural networks: A view from the width. Zhou Lu, Hongming Pu, Feicheng Wang, Zhiqiang Hu, Liwei Wang, 201730Advances in neural information processing systems</p>
<p>Your transformer may not be as powerful as you expect. Shengjie Luo, Shanda Li, Shuxin Zheng, Tie-Yan Liu, Liwei Wang, Di He, Advances in Neural Information Processing Systems. 2022</p>
<p>The parallelism tradeoff: Limitations of log-precision transformers. William Merrill, Ashish Sabharwal, 2023Transactions of the Association for Computational Linguistics</p>
<p>Saturated transformers are constantdepth threshold circuits. William Merrill, Ashish Sabharwal, Noah A Smith, Transactions of the Association for Computational Linguistics. 102022</p>
<p>Show your work: Scratchpads for intermediate computation with language models. Maxwell Nye, Anders Johan Andreassen, Guy Gur-Ari, Henryk Michalewski, Jacob Austin, David Bieber, David Dohan, Aitor Lewkowycz, Maarten Bosma, David Luan, Charles Sutton, Augustus Odena, Deep Learning for Code Workshop. 2022</p>
<p>In-context learning and induction heads. Catherine Olsson, Nelson Elhage, Neel Nanda, Nicholas Joseph, Nova Dassarma, Tom Henighan, Ben Mann, Amanda Askell, Yuntao Bai, Anna Chen, Tom Conerly, Dawn Drain, Deep Ganguli, Zac Hatfield-Dodds, Danny Hernandez, Scott Johnston, Andy Jones, Jackson Kernion, Liane Lovitt, Kamal Ndousse, Dario Amodei, Tom Brown, Jack Clark, Jared Kaplan, Sam Mccandlish, Chris Olah, 2022Transformer Circuits Thread</p>
<p>arXiv:2303.08774OpenAI. Gpt-4 technical report. 2023arXiv preprint</p>
<p>Attention is turing complete. Jorge Pérez, Pablo Barceló, Javier Marinkovic, The Journal of Machine Learning Research. 2212021</p>
<p>Train short, test long: Attention with linear biases enables input length extrapolation. Ofir Press, Noah Smith, Mike Lewis, International Conference on Learning Representations. 2022</p>
<p>On the turing completeness of modern neural network architectures. Jorge Pérez, Javier Marinković, Pablo Barceló, International Conference on Learning Representations. 2019</p>
<p>Improving language understanding by generative pre-training. Alec Radford, Karthik Narasimhan, Tim Salimans, Ilya Sutskever, 2018</p>
<p>Language models are unsupervised multitask learners. Alec Radford, Jeffrey Wu, Rewon Child, David Luan, Dario Amodei, Ilya Sutskever, OpenAI blog. 1892019</p>
<p>Scaling language models: Methods, analysis &amp; insights from training gopher. Sebastian Jack W Rae, Trevor Borgeaud, Katie Cai, Jordan Millican, Francis Hoffmann, John Song, Sarah Aslanides, Roman Henderson, Susannah Ring, Young, arXiv:2112.114462021arXiv preprint</p>
<p>Syntax in universal translation. Itiroo Sakai, Proceedings of the International Conference on Machine Translation and Applied Language Analysis. the International Conference on Machine Translation and Applied Language Analysis1961</p>
<p>Teven Le Scao, Angela Fan, Christopher Akiki, Ellie Pavlick, Suzana Ilić, Daniel Hesslow, Roman Castagné, Alexandra Sasha Luccioni, François Yvon, Matthias Gallé, arXiv:2211.05100A 176b-parameter open-access multilingual language model. 2022arXiv preprint</p>
<p>Introduction to the theory of computation. Michael Sipser, ACM Sigact News. 2711996</p>
<p>Reinforcement learning: An introduction. S Richard, Andrew G Sutton, Barto, 2018MIT press</p>
<p>Challenging bigbench tasks and whether chain-of-thought can solve them. Mirac Suzgun, Nathan Scales, Nathanael Schärli, Sebastian Gehrmann, Yi Tay, Hyung Won Chung, Aakanksha Chowdhery, Ed H Quoc V Le, Denny Chi, Zhou, arXiv:2210.092612022arXiv preprint</p>
<p>Thibaut Hugo Touvron, Gautier Lavril, Xavier Izacard, Marie-Anne Martinet, Timothée Lachaux, Baptiste Lacroix, Naman Rozière, Eric Goyal, Hambro, arXiv:2302.13971Faisal Azhar, et al. Llama: Open and efficient foundation language models. 2023arXiv preprint</p>
<p>Attention is all you need. Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Łukasz Kaiser, Illia Polosukhin, Advances in neural information processing systems. 201730</p>
<p>Eyvind Johannes Von Oswald, Ettore Niklasson, João Randazzo, Alexander Sacramento, Andrey Mordvintsev, Max Zhmoginov, Vladymyrov, arXiv:2212.07677Transformers learn in-context by gradient descent. 2022arXiv preprint</p>
<p>Statistically meaningful approximation: a case study on approximating turing machines with transformers. Colin Wei, Yining Chen, Tengyu Ma, Advances in Neural Information Processing Systems. 202235</p>
<p>Chain of thought prompting elicits reasoning in large language models. Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Fei Xia, Ed H Chi, Denny Quoc V Le, Zhou, Advances in Neural Information Processing Systems. 2022</p>
<p>Thinking like transformers. Gail Weiss, Yoav Goldberg, Eran Yahav, International Conference on Machine Learning. PMLR2021</p>
<p>Sub-task decomposition enables learning in sequence to sequence tasks. Noam Wies, Yoav Levine, Amnon Shashua, The Eleventh International Conference on Learning Representations. 2023</p>
<p>An explanation of in-context learning as implicit bayesian inference. Sang Michael Xie, Aditi Raghunathan, Percy Liang, Tengyu Ma, International Conference on Learning Representations. 2022</p>
<p>Are transformers universal approximators of sequence-to-sequence functions. Chulhee Yun, Srinadh Bhojanapalli, Ankit Singh Rawat, Sashank Reddi, Sanjiv Kumar, International Conference on Learning Representations. 2020</p>
<p>O (n) connections are expressive enough: Universal approximability of sparse transformers. Chulhee Yun, Yin-Wen Chang, Srinadh Bhojanapalli, Ankit Singh Rawat, Sashank Reddi, Sanjiv Kumar, Advances in Neural Information Processing Systems. 202033</p>
<p>Opt: Open pre-trained transformer language models. Susan Zhang, Stephen Roller, Naman Goyal, Mikel Artetxe, Moya Chen, Shuohui Chen, Christopher Dewan, Mona Diab, Xian Li, Xi Victoria Lin, arXiv:2205.010682022arXiv preprint</p>
<p>Automatic chain of thought prompting in large language models. Zhuosheng Zhang, Aston Zhang, Mu Li, Alex Smola, The Eleventh International Conference on Learning Representations. 2023</p>            </div>
        </div>

    </div>
</body>
</html>