<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-8611 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-8611</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-8611</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-154.html">extraction-schema-154</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models being evaluated on strict logical reasoning tasks, including details about the models, the logical reasoning tasks or benchmarks, the methods or approaches used to improve logical reasoning, the performance or results, comparisons to baselines or ablations, and any reported limitations or failure cases.</div>
                <p><strong>Paper ID:</strong> paper-9e9e4df2996bac794c4f04cb887df3e553bae4fd</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/9e9e4df2996bac794c4f04cb887df3e553bae4fd" target="_blank">Logic-LM: Empowering Large Language Models with Symbolic Solvers for Faithful Logical Reasoning</a></p>
                <p><strong>Paper Venue:</strong> Conference on Empirical Methods in Natural Language Processing</p>
                <p><strong>Paper TL;DR:</strong> This paper introduces a novel framework, Logic-LM, which integrates LLMs with symbolic solvers to improve logical problem-solving and suggests that it offers a promising avenue for faithful logical reasoning.</p>
                <p><strong>Paper Abstract:</strong> Large Language Models (LLMs) have shown human-like reasoning abilities but still struggle with complex logical problems. This paper introduces a novel framework, Logic-LM, which integrates LLMs with symbolic solvers to improve logical problem-solving. Our method first utilizes LLMs to translate a natural language problem into a symbolic formulation. Afterward, a deterministic symbolic solver performs inference on the formulated problem. We also introduce a self-refinement module, which utilizes the symbolic solver's error messages to revise symbolic formalizations. We demonstrate Logic-LM's effectiveness on five logical reasoning datasets: ProofWriter, PrOntoQA, FOLIO, LogicalDeduction, and AR-LSAT. On average, Logic-LM achieves a significant performance boost of 39.2% over using LLM alone with standard prompting and 18.4% over LLM with chain-of-thought prompting. Our findings suggest that Logic-LM, by combining LLMs with symbolic logic, offers a promising avenue for faithful logical reasoning. Code and data are publicly available at https://github.com/teacherpeterpan/Logic-LLM.</p>
                <p><strong>Cost:</strong> 0.017</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e8611.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e8611.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models being evaluated on strict logical reasoning tasks, including details about the models, the logical reasoning tasks or benchmarks, the methods or approaches used to improve logical reasoning, the performance or results, comparisons to baselines or ablations, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>GPT-4</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>GPT-4 (gpt-4)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>OpenAI's gpt-4 model used as a black-box large language model for in-context evaluation; in this paper it served as the strongest baseline LLM for various logical reasoning tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>GPT-4 (gpt-4)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Used as a black-box, instruction-following transformer LLM via API for standard in-context prompting and chain-of-thought prompting; responses sampled with temperature 0 to ensure deterministic outputs.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_name</strong></td>
                            <td>ProofWriter; PrOntoQA; FOLIO; LogicalDeduction; AR-LSAT</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_description</strong></td>
                            <td>Five strict logical reasoning benchmarks covering deductive reasoning (ProofWriter, PrOntoQA), first-order logic (FOLIO), constraint-satisfaction/ordering (LogicalDeduction), and analytical-logic multiple-choice (AR-LSAT). Tasks require formal logical entailment, multi-hop deduction, CSP encoding, or SAT/SMT-style analytical reasoning.</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_approach</strong></td>
                            <td>Evaluated under: (1) Standard in-context prompting, (2) Chain-of-Thought (CoT) prompting, and (3) LOGIC-LM: a neuro-symbolic approach where the LLM formulates problems into symbolic representations which are solved by deterministic symbolic solvers (Pyke for LP, Prover9 for FOL, python-constraint for CSP, Z3 for SAT/SMT), optionally with iterative self-refinement using solver error messages.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>Per-dataset accuracies (Standard | CoT | LOGIC-LM): PrOntoQA: 77.40% | 98.79% | 83.20%; ProofWriter (depth-5 subset sample): 52.67% | 68.11% | 79.66%; FOLIO: 69.11% | 70.58% | 78.92%; LogicalDeduction: 71.33% | 75.25% | 87.63%; AR-LSAT: 33.33% | 35.06% | 43.04%. (All accuracies reported in paper Table 2.)</td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td>LOGIC-LM (delegating inference to symbolic solvers) improves over GPT-4 standard prompting on average (reported) by ~24.98% and over GPT-4 CoT by ~10.44% (paper's aggregated numbers). Per-dataset improvements are shown above (e.g., LogicalDeduction +16.30 pp over CoT, ProofWriter +11.55 pp over CoT).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failures</strong></td>
                            <td>Failures stem from incorrect or unexecutable symbolic formalizations (grammar/predicate naming mistakes), imperfect mapping from NL to symbols, and domain-specific FOL encoding errors; on harder real-world datasets (FOLIO, AR-LSAT) GPT-4 produced lower executable-rate for generated symbolic forms (Exe_Rate 79.9% on FOLIO, 32.6% on AR-LSAT). Self-refinement increases executability but does not always fix semantic mis-formulations. CoT can be less effective or even harmful on 'nonlinear' reasoning tasks (FOL/CSP/AR-LSAT). Specific observed failures include wrong predicate vs constant choices, confusion of spatial relations (above/below), and generating syntactically valid but semantically incorrect formulas.</td>
                        </tr>
                        <tr>
                            <td><strong>insights_or_conclusions</strong></td>
                            <td>Authors conclude that even a strong LLM like GPT-4 benefits from offloading deterministic logical inference to symbolic solvers: LOGIC-LM yields more faithful reasoning and better robustness as reasoning depth grows. The main bottleneck becomes accurate auto-formalization (NL→symbolic), which can be improved by self-refinement but remains imperfect; ultimate applicability is bounded by the expressiveness of the chosen symbolic solvers.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Logic-LM: Empowering Large Language Models with Symbolic Solvers for Faithful Logical Reasoning', 'publication_date_yy_mm': '2023-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8611.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e8611.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models being evaluated on strict logical reasoning tasks, including details about the models, the logical reasoning tasks or benchmarks, the methods or approaches used to improve logical reasoning, the performance or results, comparisons to baselines or ablations, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>GPT-3.5</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>GPT-3.5 (text-davinci-003)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>OpenAI's text-davinci-003 model (a GPT-3.5-class instruction-tuned transformer) used as a baseline LLM for in-context and chain-of-thought reasoning comparisons.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>GPT-3.5 (text-davinci-003)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Instruction-tuned transformer LLM (text-davinci-003) used via API for standard prompting and chain-of-thought baselines; temperature set to 0 in evaluations.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_name</strong></td>
                            <td>ProofWriter; PrOntoQA; FOLIO; LogicalDeduction; AR-LSAT</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_description</strong></td>
                            <td>Same five strict logical reasoning benchmarks (deductive, FOL, CSP, analytical reasoning) requiring formal logical inference and multi-hop deduction.</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_approach</strong></td>
                            <td>Compared under: (1) Standard prompting, (2) Chain-of-Thought prompting, and (3) LOGIC-LM where the LLM is used to auto-formalize problems then symbolic solvers perform deterministic inference; optionally self-refinement is used to repair solver errors.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>Per-dataset accuracies (Standard | CoT | LOGIC-LM): PrOntoQA: 51.80% | 83.00% | 85.00%; ProofWriter: 36.16% | 48.33% | 71.45%; FOLIO: 54.60% | 57.84% | 61.27%; LogicalDeduction: 41.33% | 48.33% | 62.00%; AR-LSAT: 22.51% | 22.51% | 25.54%. (Table 2 values.)</td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td>LOGIC-LM substantially outperforms both standard and CoT baselines for GPT-3.5 across all datasets (paper reports average improvement of 39.2% over standard prompting and 18.4% over CoT when aggregating results; numbers in table reflect per-dataset gains, e.g., ProofWriter +23.12 pp vs CoT).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failures</strong></td>
                            <td>Same categories of failures: incorrect symbolic grammar, mis-specified predicates, and semantic mismatch between generated symbolic forms and intended NL meaning. Executability rates are dataset-dependent: near-100% executability for synthetic deductive datasets (PrOntoQA, ProofWriter) but lower on FOLIO and AR-LSAT. Self-refinement increases executability (e.g., ProofWriter Exe_Rate improved from 87.3% to 95.6% after refinement for GPT-3.5) but semantic correctness gains were modest.</td>
                        </tr>
                        <tr>
                            <td><strong>insights_or_conclusions</strong></td>
                            <td>For smaller/earlier instruction-tuned LLMs, combining auto-formalization with symbolic solvers yields large relative gains; much of the remaining error source is incorrect NL→symbolic translation rather than solver inference. Authors recommend focusing improvements on formulator robustness (e.g., richer demonstrations, specialized modules, fine-tuning) and expanding solver expressiveness.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Logic-LM: Empowering Large Language Models with Symbolic Solvers for Faithful Logical Reasoning', 'publication_date_yy_mm': '2023-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8611.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e8611.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models being evaluated on strict logical reasoning tasks, including details about the models, the logical reasoning tasks or benchmarks, the methods or approaches used to improve logical reasoning, the performance or results, comparisons to baselines or ablations, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>ChatGPT</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>ChatGPT (gpt-3.5-turbo)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>OpenAI's chat-oriented gpt-3.5-turbo model, used as a conversational LLM baseline for standard, CoT, and LOGIC-LM experiments in the paper.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>ChatGPT (gpt-3.5-turbo)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Chat-oriented GPT-3.5 model (gpt-3.5-turbo) used as a black-box LLM in in-context learning, chain-of-thought prompting, and to produce symbolic formalizations for LOGIC-LM; evaluation used temperature 0.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_name</strong></td>
                            <td>ProofWriter; PrOntoQA; FOLIO; LogicalDeduction; AR-LSAT</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_description</strong></td>
                            <td>Same suite of strict logical reasoning benchmarks spanning deductive, first-order, CSP, and analytical reasoning problems.</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_approach</strong></td>
                            <td>Evaluated with (1) Standard prompting, (2) Chain-of-Thought prompting, and (3) LOGIC-LM (LLM produces symbolic forms; external symbolic solvers execute inference). Self-refinement module optionally iteratively repairs solver error messages.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>Per-dataset accuracies (Standard | CoT | LOGIC-LM): PrOntoQA: 47.40% | 67.80% | 61.00%; ProofWriter: 35.50% | 49.17% | 58.33%; FOLIO: 45.09% | 57.35% | 62.74%; LogicalDeduction: 40.00% | 42.33% | 65.67%; AR-LSAT: 20.34% | 17.31% | 26.41%.</td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td>LOGIC-LM improves over both standard and CoT baselines for ChatGPT on all five datasets; especially large gains on datasets requiring CSP/analytical reasoning (LogicalDeduction +23.34 pp vs CoT).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failures</strong></td>
                            <td>Near-perfect executability on synthetic deductive datasets but struggles more on expert-authored or real-world problems; specific failure modes include incorrect predicate/entity naming, confusion in constraint direction (e.g., above vs below), and syntactically valid but semantically incorrect FOL formulas. Self-refinement helped convert invalid symbolic programs to valid ones but semantic errors persisted in some cases.</td>
                        </tr>
                        <tr>
                            <td><strong>insights_or_conclusions</strong></td>
                            <td>Even mid-tier LLMs benefit materially from symbolic-solver integration; improvements mainly hinge on correctness of NL→symbolic translation and handling of complex grammatical constructs in formal languages.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Logic-LM: Empowering Large Language Models with Symbolic Solvers for Faithful Logical Reasoning', 'publication_date_yy_mm': '2023-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8611.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e8611.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models being evaluated on strict logical reasoning tasks, including details about the models, the logical reasoning tasks or benchmarks, the methods or approaches used to improve logical reasoning, the performance or results, comparisons to baselines or ablations, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>LOGIC-LM</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>LOGIC-LM (LLM + Symbolic Solvers)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A neuro-symbolic framework that uses LLMs to auto-formalize natural language logical reasoning problems into symbolic representations and delegates deterministic inference to external symbolic solvers, with optional iterative self-refinement using solver error messages.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>LOGIC-LM</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Three-stage pipeline: (1) Problem Formulator: LLM (few-shot in-context) translates NL to symbolic programs in task-specific grammars (LP/Prolog-style, FOL, CSP, SAT); (2) Symbolic Reasoner: deterministic solvers perform inference (Pyke, Prover9, python-constraint, Z3); (3) Result Interpreter: maps solver outputs back to NL. A self-refinement loop uses solver error messages to iteratively fix un-executable formalizations.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_name</strong></td>
                            <td>ProofWriter; PrOntoQA; FOLIO; LogicalDeduction; AR-LSAT</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_description</strong></td>
                            <td>Evaluated on the same five strict logical reasoning datasets covering multi-hop deductive reasoning, first-order logic proofs, constraint satisfaction/order deduction, and analytical LSAT-style problems.</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_approach</strong></td>
                            <td>Neuro-symbolic: use LLMs for auto-formalization (few-shot prompts + in-context examples), call specialized symbolic solvers for exact inference, and apply self-refinement using solver error outputs to correct generated symbolic forms. Compared against pure LLM baselines using standard prompting and chain-of-thought prompting.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>Aggregate results (Table 2): LOGIC-LM (without self-refinement) yields large accuracy gains over pure LLM baselines across datasets. Example per-LLM aggregated observations: average improvement over standard prompting reported as +39.2% (for GPT-3.5 aggregate) and +18.4% over CoT on average; paper-level per-dataset LOGIC-LM accuracies when using GPT-4 as formulator are reported above in the GPT-4 entry.</td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td>Compared to Standard and CoT LLM-only approaches, LOGIC-LM often produces higher and more robust accuracy, especially as reasoning depth increases (Figure 3). For difficult datasets (FOLIO, LogicalDeduction, AR-LSAT) LOGIC-LM's gains are larger than for synthetic deductive datasets where CoT already helps.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failures</strong></td>
                            <td>Two main limitations reported: (1) dependency on the expressiveness of external symbolic solvers (not all problems map easily to FOL or solver-supported theories); (2) reliance on in-context learning for auto-formalization, which can fail on complex grammar and large variability in NL phrasing. Self-refinement increases executability rates but does not guarantee semantic correctness of the formalization. Some problems fall back to CoT when symbolic formalization is un-executable.</td>
                        </tr>
                        <tr>
                            <td><strong>insights_or_conclusions</strong></td>
                            <td>Delegating inference to deterministic symbolic solvers increases faithfulness and robustness of logical reasoning; the primary bottleneck becomes reliable NL→symbolic translation. Self-refinement using solver feedback is effective for fixing syntactic/formal errors, but future work should target semantic validation of formalizations and integrating more expressive/probabilistic logic solvers.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Logic-LM: Empowering Large Language Models with Symbolic Solvers for Faithful Logical Reasoning', 'publication_date_yy_mm': '2023-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>PrOntoQA <em>(Rating: 2)</em></li>
                <li>ProofWriter: Generating implications, proofs, and abductive statements over natural language <em>(Rating: 2)</em></li>
                <li>FOLIO: natural language reasoning with first-order logic <em>(Rating: 2)</em></li>
                <li>Analytical reasoning of text <em>(Rating: 2)</em></li>
                <li>Satisfiability-aided language models using declarative prompting <em>(Rating: 2)</em></li>
                <li>Chain of thought prompting elicits reasoning in large language models <em>(Rating: 2)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-8611",
    "paper_id": "paper-9e9e4df2996bac794c4f04cb887df3e553bae4fd",
    "extraction_schema_id": "extraction-schema-154",
    "extracted_data": [
        {
            "name_short": "GPT-4",
            "name_full": "GPT-4 (gpt-4)",
            "brief_description": "OpenAI's gpt-4 model used as a black-box large language model for in-context evaluation; in this paper it served as the strongest baseline LLM for various logical reasoning tasks.",
            "citation_title": "",
            "mention_or_use": "use",
            "model_name": "GPT-4 (gpt-4)",
            "model_description": "Used as a black-box, instruction-following transformer LLM via API for standard in-context prompting and chain-of-thought prompting; responses sampled with temperature 0 to ensure deterministic outputs.",
            "model_size": null,
            "reasoning_task_name": "ProofWriter; PrOntoQA; FOLIO; LogicalDeduction; AR-LSAT",
            "reasoning_task_description": "Five strict logical reasoning benchmarks covering deductive reasoning (ProofWriter, PrOntoQA), first-order logic (FOLIO), constraint-satisfaction/ordering (LogicalDeduction), and analytical-logic multiple-choice (AR-LSAT). Tasks require formal logical entailment, multi-hop deduction, CSP encoding, or SAT/SMT-style analytical reasoning.",
            "method_or_approach": "Evaluated under: (1) Standard in-context prompting, (2) Chain-of-Thought (CoT) prompting, and (3) LOGIC-LM: a neuro-symbolic approach where the LLM formulates problems into symbolic representations which are solved by deterministic symbolic solvers (Pyke for LP, Prover9 for FOL, python-constraint for CSP, Z3 for SAT/SMT), optionally with iterative self-refinement using solver error messages.",
            "performance": "Per-dataset accuracies (Standard | CoT | LOGIC-LM): PrOntoQA: 77.40% | 98.79% | 83.20%; ProofWriter (depth-5 subset sample): 52.67% | 68.11% | 79.66%; FOLIO: 69.11% | 70.58% | 78.92%; LogicalDeduction: 71.33% | 75.25% | 87.63%; AR-LSAT: 33.33% | 35.06% | 43.04%. (All accuracies reported in paper Table 2.)",
            "baseline_comparison": "LOGIC-LM (delegating inference to symbolic solvers) improves over GPT-4 standard prompting on average (reported) by ~24.98% and over GPT-4 CoT by ~10.44% (paper's aggregated numbers). Per-dataset improvements are shown above (e.g., LogicalDeduction +16.30 pp over CoT, ProofWriter +11.55 pp over CoT).",
            "limitations_or_failures": "Failures stem from incorrect or unexecutable symbolic formalizations (grammar/predicate naming mistakes), imperfect mapping from NL to symbols, and domain-specific FOL encoding errors; on harder real-world datasets (FOLIO, AR-LSAT) GPT-4 produced lower executable-rate for generated symbolic forms (Exe_Rate 79.9% on FOLIO, 32.6% on AR-LSAT). Self-refinement increases executability but does not always fix semantic mis-formulations. CoT can be less effective or even harmful on 'nonlinear' reasoning tasks (FOL/CSP/AR-LSAT). Specific observed failures include wrong predicate vs constant choices, confusion of spatial relations (above/below), and generating syntactically valid but semantically incorrect formulas.",
            "insights_or_conclusions": "Authors conclude that even a strong LLM like GPT-4 benefits from offloading deterministic logical inference to symbolic solvers: LOGIC-LM yields more faithful reasoning and better robustness as reasoning depth grows. The main bottleneck becomes accurate auto-formalization (NL→symbolic), which can be improved by self-refinement but remains imperfect; ultimate applicability is bounded by the expressiveness of the chosen symbolic solvers.",
            "uuid": "e8611.0",
            "source_info": {
                "paper_title": "Logic-LM: Empowering Large Language Models with Symbolic Solvers for Faithful Logical Reasoning",
                "publication_date_yy_mm": "2023-05"
            }
        },
        {
            "name_short": "GPT-3.5",
            "name_full": "GPT-3.5 (text-davinci-003)",
            "brief_description": "OpenAI's text-davinci-003 model (a GPT-3.5-class instruction-tuned transformer) used as a baseline LLM for in-context and chain-of-thought reasoning comparisons.",
            "citation_title": "",
            "mention_or_use": "use",
            "model_name": "GPT-3.5 (text-davinci-003)",
            "model_description": "Instruction-tuned transformer LLM (text-davinci-003) used via API for standard prompting and chain-of-thought baselines; temperature set to 0 in evaluations.",
            "model_size": null,
            "reasoning_task_name": "ProofWriter; PrOntoQA; FOLIO; LogicalDeduction; AR-LSAT",
            "reasoning_task_description": "Same five strict logical reasoning benchmarks (deductive, FOL, CSP, analytical reasoning) requiring formal logical inference and multi-hop deduction.",
            "method_or_approach": "Compared under: (1) Standard prompting, (2) Chain-of-Thought prompting, and (3) LOGIC-LM where the LLM is used to auto-formalize problems then symbolic solvers perform deterministic inference; optionally self-refinement is used to repair solver errors.",
            "performance": "Per-dataset accuracies (Standard | CoT | LOGIC-LM): PrOntoQA: 51.80% | 83.00% | 85.00%; ProofWriter: 36.16% | 48.33% | 71.45%; FOLIO: 54.60% | 57.84% | 61.27%; LogicalDeduction: 41.33% | 48.33% | 62.00%; AR-LSAT: 22.51% | 22.51% | 25.54%. (Table 2 values.)",
            "baseline_comparison": "LOGIC-LM substantially outperforms both standard and CoT baselines for GPT-3.5 across all datasets (paper reports average improvement of 39.2% over standard prompting and 18.4% over CoT when aggregating results; numbers in table reflect per-dataset gains, e.g., ProofWriter +23.12 pp vs CoT).",
            "limitations_or_failures": "Same categories of failures: incorrect symbolic grammar, mis-specified predicates, and semantic mismatch between generated symbolic forms and intended NL meaning. Executability rates are dataset-dependent: near-100% executability for synthetic deductive datasets (PrOntoQA, ProofWriter) but lower on FOLIO and AR-LSAT. Self-refinement increases executability (e.g., ProofWriter Exe_Rate improved from 87.3% to 95.6% after refinement for GPT-3.5) but semantic correctness gains were modest.",
            "insights_or_conclusions": "For smaller/earlier instruction-tuned LLMs, combining auto-formalization with symbolic solvers yields large relative gains; much of the remaining error source is incorrect NL→symbolic translation rather than solver inference. Authors recommend focusing improvements on formulator robustness (e.g., richer demonstrations, specialized modules, fine-tuning) and expanding solver expressiveness.",
            "uuid": "e8611.1",
            "source_info": {
                "paper_title": "Logic-LM: Empowering Large Language Models with Symbolic Solvers for Faithful Logical Reasoning",
                "publication_date_yy_mm": "2023-05"
            }
        },
        {
            "name_short": "ChatGPT",
            "name_full": "ChatGPT (gpt-3.5-turbo)",
            "brief_description": "OpenAI's chat-oriented gpt-3.5-turbo model, used as a conversational LLM baseline for standard, CoT, and LOGIC-LM experiments in the paper.",
            "citation_title": "",
            "mention_or_use": "use",
            "model_name": "ChatGPT (gpt-3.5-turbo)",
            "model_description": "Chat-oriented GPT-3.5 model (gpt-3.5-turbo) used as a black-box LLM in in-context learning, chain-of-thought prompting, and to produce symbolic formalizations for LOGIC-LM; evaluation used temperature 0.",
            "model_size": null,
            "reasoning_task_name": "ProofWriter; PrOntoQA; FOLIO; LogicalDeduction; AR-LSAT",
            "reasoning_task_description": "Same suite of strict logical reasoning benchmarks spanning deductive, first-order, CSP, and analytical reasoning problems.",
            "method_or_approach": "Evaluated with (1) Standard prompting, (2) Chain-of-Thought prompting, and (3) LOGIC-LM (LLM produces symbolic forms; external symbolic solvers execute inference). Self-refinement module optionally iteratively repairs solver error messages.",
            "performance": "Per-dataset accuracies (Standard | CoT | LOGIC-LM): PrOntoQA: 47.40% | 67.80% | 61.00%; ProofWriter: 35.50% | 49.17% | 58.33%; FOLIO: 45.09% | 57.35% | 62.74%; LogicalDeduction: 40.00% | 42.33% | 65.67%; AR-LSAT: 20.34% | 17.31% | 26.41%.",
            "baseline_comparison": "LOGIC-LM improves over both standard and CoT baselines for ChatGPT on all five datasets; especially large gains on datasets requiring CSP/analytical reasoning (LogicalDeduction +23.34 pp vs CoT).",
            "limitations_or_failures": "Near-perfect executability on synthetic deductive datasets but struggles more on expert-authored or real-world problems; specific failure modes include incorrect predicate/entity naming, confusion in constraint direction (e.g., above vs below), and syntactically valid but semantically incorrect FOL formulas. Self-refinement helped convert invalid symbolic programs to valid ones but semantic errors persisted in some cases.",
            "insights_or_conclusions": "Even mid-tier LLMs benefit materially from symbolic-solver integration; improvements mainly hinge on correctness of NL→symbolic translation and handling of complex grammatical constructs in formal languages.",
            "uuid": "e8611.2",
            "source_info": {
                "paper_title": "Logic-LM: Empowering Large Language Models with Symbolic Solvers for Faithful Logical Reasoning",
                "publication_date_yy_mm": "2023-05"
            }
        },
        {
            "name_short": "LOGIC-LM",
            "name_full": "LOGIC-LM (LLM + Symbolic Solvers)",
            "brief_description": "A neuro-symbolic framework that uses LLMs to auto-formalize natural language logical reasoning problems into symbolic representations and delegates deterministic inference to external symbolic solvers, with optional iterative self-refinement using solver error messages.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "LOGIC-LM",
            "model_description": "Three-stage pipeline: (1) Problem Formulator: LLM (few-shot in-context) translates NL to symbolic programs in task-specific grammars (LP/Prolog-style, FOL, CSP, SAT); (2) Symbolic Reasoner: deterministic solvers perform inference (Pyke, Prover9, python-constraint, Z3); (3) Result Interpreter: maps solver outputs back to NL. A self-refinement loop uses solver error messages to iteratively fix un-executable formalizations.",
            "model_size": null,
            "reasoning_task_name": "ProofWriter; PrOntoQA; FOLIO; LogicalDeduction; AR-LSAT",
            "reasoning_task_description": "Evaluated on the same five strict logical reasoning datasets covering multi-hop deductive reasoning, first-order logic proofs, constraint satisfaction/order deduction, and analytical LSAT-style problems.",
            "method_or_approach": "Neuro-symbolic: use LLMs for auto-formalization (few-shot prompts + in-context examples), call specialized symbolic solvers for exact inference, and apply self-refinement using solver error outputs to correct generated symbolic forms. Compared against pure LLM baselines using standard prompting and chain-of-thought prompting.",
            "performance": "Aggregate results (Table 2): LOGIC-LM (without self-refinement) yields large accuracy gains over pure LLM baselines across datasets. Example per-LLM aggregated observations: average improvement over standard prompting reported as +39.2% (for GPT-3.5 aggregate) and +18.4% over CoT on average; paper-level per-dataset LOGIC-LM accuracies when using GPT-4 as formulator are reported above in the GPT-4 entry.",
            "baseline_comparison": "Compared to Standard and CoT LLM-only approaches, LOGIC-LM often produces higher and more robust accuracy, especially as reasoning depth increases (Figure 3). For difficult datasets (FOLIO, LogicalDeduction, AR-LSAT) LOGIC-LM's gains are larger than for synthetic deductive datasets where CoT already helps.",
            "limitations_or_failures": "Two main limitations reported: (1) dependency on the expressiveness of external symbolic solvers (not all problems map easily to FOL or solver-supported theories); (2) reliance on in-context learning for auto-formalization, which can fail on complex grammar and large variability in NL phrasing. Self-refinement increases executability rates but does not guarantee semantic correctness of the formalization. Some problems fall back to CoT when symbolic formalization is un-executable.",
            "insights_or_conclusions": "Delegating inference to deterministic symbolic solvers increases faithfulness and robustness of logical reasoning; the primary bottleneck becomes reliable NL→symbolic translation. Self-refinement using solver feedback is effective for fixing syntactic/formal errors, but future work should target semantic validation of formalizations and integrating more expressive/probabilistic logic solvers.",
            "uuid": "e8611.3",
            "source_info": {
                "paper_title": "Logic-LM: Empowering Large Language Models with Symbolic Solvers for Faithful Logical Reasoning",
                "publication_date_yy_mm": "2023-05"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "PrOntoQA",
            "rating": 2
        },
        {
            "paper_title": "ProofWriter: Generating implications, proofs, and abductive statements over natural language",
            "rating": 2,
            "sanitized_title": "proofwriter_generating_implications_proofs_and_abductive_statements_over_natural_language"
        },
        {
            "paper_title": "FOLIO: natural language reasoning with first-order logic",
            "rating": 2,
            "sanitized_title": "folio_natural_language_reasoning_with_firstorder_logic"
        },
        {
            "paper_title": "Analytical reasoning of text",
            "rating": 2,
            "sanitized_title": "analytical_reasoning_of_text"
        },
        {
            "paper_title": "Satisfiability-aided language models using declarative prompting",
            "rating": 2,
            "sanitized_title": "satisfiabilityaided_language_models_using_declarative_prompting"
        },
        {
            "paper_title": "Chain of thought prompting elicits reasoning in large language models",
            "rating": 2,
            "sanitized_title": "chain_of_thought_prompting_elicits_reasoning_in_large_language_models"
        }
    ],
    "cost": 0.016864999999999998,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Logic-LM: Empowering Large Language Models with Symbolic Solvers for Faithful Logical Reasoning</h1>
<p>Liangming Pan Alon Albalak Xinyi Wang William Yang Wang<br>University of California, Santa Barbara<br>{liangmingpan, alon_albalak, xinyi_wang, wangwilliamyang}@ucsb.edu</p>
<h4>Abstract</h4>
<p>Large Language Models (LLMs) have shown human-like reasoning abilities but still struggle with complex logical problems. This paper introduces a novel framework, LOGICLM, which integrates LLMs with symbolic solvers to improve logical problem-solving. Our method first utilizes LLMs to translate a natural language problem into a symbolic formulation. Afterward, a deterministic symbolic solver performs inference on the formulated problem. We also introduce a selfrefinement module, which utilizes the symbolic solver's error messages to revise symbolic formalizations. We demonstrate LOGIC-LM's effectiveness on five logical reasoning datasets: ProofWriter, PrOntoQA, FOLIO, LogicalDeduction, and AR-LSAT. On average, LOGICLM achieves a significant performance boost of $39.2 \%$ over using LLM alone with standard prompting and $18.4 \%$ over LLM with chain-ofthought prompting. Our findings suggest that LOGIC-LM, by combining LLMs with symbolic logic, offers a promising avenue for faithful logical reasoning. ${ }^{1}$</p>
<h2>1 Introduction</h2>
<p>Logical reasoning is a cognitive process that involves using evidence, arguments, and logic to arrive at conclusions or make judgments (Huang and Chang, 2023). It plays a central role in intelligent systems for problem-solving, decision-making, and critical thinking. Recently, large language models (LLMs) (Brown et al., 2020; Ouyang et al., 2022a; OpenAI, 2023) have exhibited emergent ability to "reason" like human (Wei et al., 2022a). When prompted with step-wise explanations of reasoning ("chain of thoughts"), or a simple prompt "Let's think step by step.", these models are able to answer questions with explicit reasoning steps (Wei et al., 2022b; Kojima et al., 2022).</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Overview of our LOGIC-LM framework.
Despite the advances of LLMs, they still struggle with complex logical reasoning problems (Liu et al., 2023b). Recent studies (Golovneva et al., 2023; Ribeiro et al., 2023b; Lyu et al., 2023) found that LLMs occasionally make unfaithful reasoning, i.e., the derived conclusion does not follow the previously generated reasoning chain. While chain-of-thought may imitate human reasoning processes, the fundamental nature of LLMs remains that of black-box probabilistic models, lacking a mechanism to guarantee the faithfulness of reasoning (Shanahan, 2022). In contrast, symbolic inference engines, such as expert systems (Metaxiotis et al., 2002), are faithful and transparent because the reasoning is based on symbolic-represented knowledge and follows well-defined inference rules that adhere to logical principles. The main obstacle is how to accurately translate a problem into symbolic representations, considering the inherent ambiguity and flexibility of natural language. This is precisely where LLMs excel, making LLMs a promising complement to symbolic solvers.</p>
<p>This drives our exploration of neuro-symbolic methods that integrate LLMs with symbolic reasoning. As illustrated in Figure 1, we present LOGIC-</p>
<p>LM, a novel framework that decomposes a logical reasoning problem into three stages: Problem Formulation, Symbolic Reasoning, and Result Interpretation. During problem formulation, an LLM converts the natural language description of the problem into an appropriate symbolic formulation, identifying key entities, facts, and rules present in the problem statement. Subsequently, at the symbolic reasoning stage, a deterministic symbolic solver performs inference on the symbolic formulation. Lastly, a result interpreter explains the output and maps it to the correct answer. By incorporating LLMs with symbolic solvers, we can exploit the robust natural language understanding capabilities of LLMs to precisely represent the problem using symbolic representations, while also taking advantage of the logical faithfulness and transparency offered by symbolic solvers. To improve the accuracy of the symbolic parsing, we also incorporate the idea of self-refinement to iteratively revise the generated logical form using the error messages from the symbolic solver as feedback.</p>
<p>We showcase the adaptability and effectiveness of Logic-LM on five logical reasoning datasets: ProofWriter (Tafjord et al., 2021), PrOntoQA (Saparov and He, 2023), FOLIO (Han et al., 2022), AR-LSAT (Zhong et al., 2022), and the LogicalDeduction dataset from BigBench (Srivastava et al., 2022). These datasets cover a wide range of logical reasoning problems, including:</p>
<ul>
<li>Deductive Reasoning problems</li>
<li>First-Order Logic (FOL) reasoning problems</li>
<li>Constraint Satisfaction Problems (CSP)</li>
<li>Analytical Reasoning (AR) problems</li>
</ul>
<p>We integrate four types of symbolic inference tools tailored to these problems: 1) logic programming engine that supports deductive reasoning through forward/backward chaining; 2) FOL inference engine that derives new conclusions based on FOL rules and facts, 3) constraint optimization engine that provides solvers for CSP over finite domains, and 4) boolean satisfiability problem (SAT) solver that solves analytical reasoning problems.</p>
<p>Our evaluations show that the strategy of integrating LLMs with symbolic solvers performs significantly better than purely relying on LLMs for logical reasoning, with an average improvement of $39.2 \%$ over the standard prompting and $18.4 \%$ over the chain-of-thought prompting (§ 4.1). We also find that LOGIC-LM becomes increasingly effective as the required reasoning depth increases (§ 4.3). Finally, by analyzing the impact of selfrefinement, we highlight the effectiveness of incrementally revising symbolic formalizations when interacting with the symbolic solver (§ 4.4).</p>
<h2>2 Related Work</h2>
<p>Language Models for Logical Reasoning. Recent works in adapting LLMs for logical reasoning tasks can be broadly categorized into two groups: 1) fine-tuning approaches that optimize LLMs' reasoning ability through fine-tuning or training specialized modules (Clark et al., 2020; Tafjord et al., 2022; Yang et al., 2022), and 2) in-context learning approaches that design special prompts to elicit LLMs' step-by-step reasoning capabilities. Typical methods include chain-of-thought prompting (Wei et al., 2022b; Wang et al., 2023) that generates explanations before the final answer and the least-tomost prompting (Zhou et al., 2023) that breaks the problem down into simpler components that can be solved individually. Both the above approaches perform reasoning directly over natural language (NL), providing greater flexibility than symbolicbased reasoning. However, the intrinsic complexity and ambiguity of NL also bring undesired issues such as unfaithful reasoning and hallucinations.</p>
<p>Different from prior works, we use symbolic language as the basic unit of reasoning. This effectively transfers the burden of executing complex, precise reasoning from LLMs to more reliable, interpretable external symbolic solvers. Simultaneously, we leverage the strong in-context learning ability of LLMs to formulate the NL-based problem into suitable symbolic representations, thus maintaining the benefit of flexibility.</p>
<p>Although prior works (Mao et al., 2019; Gupta et al., 2020; Manhaeve et al., 2021; Cai et al., 2021; Tian et al., 2022; Pryor et al., 2023) also propose neuro-symbolic methods to combine neural networks with symbolic reasoning, these methods suffer from limitations such as hand-crafted or specialized module designs that are not easily generalizable, or brittleness due to the difficulty of optimization. In contrast, we propose a more generalizable framework that integrates modern LLMs with symbolic logic without the need for training or designing complex problem-specific modules.</p>
<p>Tool-augmented Language Models. Language models have inherent limitations such as the inability to access up-to-date information, take actions, or perform precise mathematical reasoning. To</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: Overview of our LOGIC-LM model, which consists of three modules: (1) <em>Problem Formulator</em> generates a symbolic representation for the input problem with LLMs via in-context learning (2) <em>Symbolic Reasoner</em> performs logical inference on the formulated problem, and (3) <em>Result Interpreter</em> interprets the symbolic answer.</p>
<p>address this, recent work has begun to augment language models with access to external tools and resources, such as the information retriever <em>Nakano et al. (2021); Shi et al. (2023); Lazaridou et al. (2022)</em>, calculator <em>Cobbe et al. (2021)</em>, code interpreter <em>Wang et al. (2022)</em>, planner <em>Liu et al. (2023a)</em>, and other pre-trained models <em>Shen et al. (2023)</em>. Recent works <em>Gao et al. (2023); Chen et al. (2022)</em> have achieved improved performance on arithmetic reasoning tasks by generating Python programs that specify the reasoning procedure as chained commands in the order of execution. However, this idea has not been extended to logical reasoning problems, primarily due to the challenge of representing their highly "non-linear" reasoning procedure (<em>e.g.</em>, hypothesizing, case-by-case analysis, and the process of elimination) with functional programming. Our work provides a novel way to solve this within the framework of augmented LLMs. Instead of parsing the problem-solving procedure as programs, we only describe the problem with symbolic language using LLMs and then offload the reasoning to external symbolic solvers.</p>
<p>Auto-Formalization. The concept of converting natural language into symbolic representations has been widely adopted in auto-formalization for mathematical reasoning <em>Wu et al. (2022); Drori et al. (2022); He-Yueya et al. (2023); Jiang et al. (2023)</em>. These works demonstrate the proficiency of LLMs in translating a considerable fraction of mathematical problems into formal specifications defined in tools like SymPy <em>Meurer et al. (2017)</em>, Isabelle/HOL <em>Paulson (1994)</em>, and Lean <em>de Moura et al. (2015)</em>. Mathematical reasoning can be considered a specialized subset of logical reasoning, primarily focused on numeric deductions. Due to this numeric specificity, mathematical problems are often more readily translatable to symbolic forms. In contrast, logical reasoning covers a wider array of problem types, often requiring a deeper understanding of world knowledge and commonsense for effective parsing into symbolic forms. Despite plenty of works studying mathematical reasoning, our work pioneers in extending the concept of auto-formalization to a broader range of logical reasoning tasks with modern LLMs.</p>
<h2>3 LOGIC-LM</h2>
<p>As shown in Figure 2, the inputs of our model are a logical reasoning problem <em>P</em> described in natural language, along with a goal <em>G</em> in the form of a multiple-choice or free-form question. LOGIC-LM then follows a <em>problem formulation-and-reasoning</em> paradigm to solve the problem.</p>
<p>In the Problem Formulation stage, we prompt an LLM to translate the problem and the goal into a task-specific symbolic language. In the Symbolic Reasoning stage, we call a deterministic symbolic solver, e.g., a logic programming engine, to obtain a symbolic-represented answer. Finally, an LLM- or rule-based Result Interpreter is responsible for translating the answer back to natural language. Using this approach, the reasoning is guaranteed to be faithful as long as the problem formulation is correct since the answer $A$ is the result of executing deterministic algorithms (e.g., forward/backward-chaining) embedded within the symbolic reasoner. Compared to previous methods based on chain-of-thought, our framework reduces the burden of LLMs by shifting their focus from "solving the problem by reasoning step-by-step" to "representing the problem in symbolic language".</p>
<h3>3.1 Problem Formulator</h3>
<p>Intuitively, LLMs may struggle with directly solving complex reasoning problems. However, they have demonstrated a notable ability to comprehend textual inputs and translate them into formal programs, such as mathematical equations (He-Yueya et al., 2023) or Python codes (Gao et al., 2023). We posit that this capability to formulate problems into different languages can be extended to symbolic languages as well. We leverage the few-shot generalization ability of LLMs to achieve this. By providing the LLM with detailed instructions about the grammar of the symbolic language, alongside a few demonstrations as in-context examples, we observe that LLMs, like InstructGPT (Ouyang et al., 2022b) and GPT-4 (OpenAI, 2023), can effectively follow the instructions to identify key entities, facts, and rules present in the problem statement, and then translate these elements into symbolic language following our defined grammar.</p>
<p>Specifically, we use four different symbolic formulations to cover four common types of logical reasoning problems: deductive reasoning, firstorder logic reasoning, constraint satisfaction problem, and analytical reasoning. These formulations provide a foundation for translating natural language-based problem statements. By defining additional problem-specific formulations, our framework retains the flexibility to accommodate a wider range of reasoning tasks. Next, we will delve into the grammar of each symbolic formulation. Examples of each problem type are in Figure 2.</p>
<p>Logic Programming (LP) Language. Deductive reasoning typically starts from known facts and rules, and iteratively makes new inferences until the goal statement can be proved or disproved (Poole and Mackworth, 2010). The Prolog logic programming language (Clocksin and Mellish, 2003; Körner et al., 2022) is arguably the most prominent symbolic language to describe deductive reasoning problems. We adopt its grammar to represent a problem as facts, rules, and queries.</p>
<ul>
<li>Facts: a fact $F$ is a simple statement with a predicate and a set of arguments, formulated as $P\left(a_{1}, \cdots, a_{n}\right)$, where $P$ is the predicate name and each argument $a_{i}$ can be a variable, entity, number, or bool. For example, Age(Peter, 31) means "Peter's age is 31", and MadeOfIron(Nails, True) represents the fact "Nails are made of iron".</li>
<li>Rules: rules are written in the form of clauses: $F_{1} \wedge \cdots \wedge F_{m} \rightarrow F_{m+1} \wedge \cdots \wedge F_{n}$, where each $F_{i}$ is a fact and the rule means "if the facts $F_{1}, \cdots, F_{m}$ are true, then the facts $F_{m+1} \cdots F_{n}$ are also true."</li>
<li>Queries: a query $Q$ is simply another fact required to be proved based on known facts and rules.</li>
</ul>
<p>First-Order Logic (FOL). While the logic programming language efficiently represents common deductive reasoning problems, it may fail to represent more complex first-order logic (FOL) problems. To address this, we also include the FOL grammar (Enderton, 2001) in Appendix A. A problem is then parsed into a list of FOL formulas, which are divided into Premises (the known information from the problem) and Conclusion (the unknown formula to be proved). An example sentence and its FOL formula are given in Table 1.</p>
<p>Constraint Satisfaction (CSP). Constraint satisfaction problems (CSPs) (Kumar, 1992) aims to find the value assignment of a set of objects that satisfy a number of constraints. A CSP is often defined as a triple $(X, D, C)$, where $X=\left{x_{1}, \cdots, x_{n}\right}$ is a set of variables, $D=$ $\left{D_{1}, \cdots, D_{n}\right}$ is a set of their respective domains of values, and $C=\left{C_{1}, \cdots, C_{m}\right}$ is a set of constraints. Each variable $x_{i}$ can take on the values in the nonempty domain $D_{i}$. Every constraint $C_{j}$ is a pair $\left\langle t_{j}, R_{j}\right\rangle$, where $t_{j} \subset X$ is a subset of $k$ variables and $R_{j}$ is a $k$-ary relation on the corresponding subset of domains $D_{j}$. We use the above syntax to define a CSP problem as variables, domains, and constraints. An example is given in both Figure 2 and Table 1.</p>
<table>
<thead>
<tr>
<th>Problem</th>
<th>Formulation</th>
<th>Example</th>
<th></th>
<th>Solver</th>
<th>Dataset</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>NL Sentence</td>
<td>Symbolic Formulation</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Deductive Reasoning</td>
<td>LP</td>
<td>If the circuit is complete and the circuit has the light bulb then the light bulb is glowing.</td>
<td>Complete(Circuit, True) $\wedge$ Has(Circuit, LightBulb) $\rightarrow$ Glowing(LightBulb, True)</td>
<td>Pyke</td>
<td>ProntoQA, ProofWriter</td>
</tr>
<tr>
<td>First-Order Logic</td>
<td>FOL</td>
<td>A Czech person wrote a book in 1946.</td>
<td>$\exists x_{2} \exists x_{1}\left(\operatorname{Czech}\left(x_{1}\right) \wedge\right.$ Author $\left.\left(x_{2}, x_{1}\right)\right.$ $\wedge$ Book $\left.\left(x_{2}\right) \wedge\right.$ Publish $\left.\left(x_{2}, 1946\right)\right)$</td>
<td>Prover9</td>
<td>FOLIO</td>
</tr>
<tr>
<td>Constraint Satisfaction</td>
<td>CSP</td>
<td>On a shelf, there are five books. The blue book is to the right of the yellow book.</td>
<td>blue_book $\in{1,2,3,4,5}$ yellow_book $\in{1,2,3,4,5}$ blue_book $&gt;$ yellow_book</td>
<td>python- constraint</td>
<td>LogicalDeduction</td>
</tr>
<tr>
<td>Analytical Reasoning</td>
<td>SAT</td>
<td>Xena and exactly three other technicians repair radios</td>
<td>repairs(Xena, radios) $\wedge$ Count([t:technicians], t $\neq$ Xena $\wedge$ repairs(t, radios))) == 3)</td>
<td>Z3</td>
<td>AR-LSAT</td>
</tr>
</tbody>
</table>
<p>Table 1: A summary of the symbolic formulations (with examples) and symbolic solvers we use for the five datasets in our study, representing four different types of logical reasoning problems.</p>
<p>Boolean Satisfiability (SAT) Formulation. SAT is the problem of deciding if there is an assignment to the variables of a Boolean formula such that the formula is satisfied. Many analytical reasoning problems can be formulated as SAT problems. We adopt the grammar defined in Ye et al. (2023) to formulate an SAT problem $\mathcal{P}$ as $(\Phi, \mathcal{T}, \mathcal{Q})$, where $\Phi$ is a set of constraints defined under the theory $\mathcal{T}$, and $\mathcal{Q}$ is the query of interest.</p>
<p>Table 1 summarizes the four types of logical reasoning problems, their typical datasets, and the symbolic formulation used to represent each type of problem. We also give an example of a natural language statement with its corresponding symbolic formulation for each type. Appendix C shows the full prompts we use for the problem formulator. To teach LLMs to better align each statement with its corresponding symbolic form, we use the format SYMBOLIC_FORMULA ::: NL_STATEMENT in in-context examples to enable better grounding.</p>
<h3>3.2 Symbolic Reasoner</h3>
<p>After the problem formulator parses the problem $P$ and the goal $G$ into symbolic representations $\hat{P}$ and $\hat{G}$, we call a deterministic external solver depending on the task, to obtain the answer $A$. Table 1 summarizes the symbolic solvers we use for each type of logical reasoning problem.</p>
<p>LP System. For deductive reasoning, we incorporate the Pyke expert system (Frederiksen, 2008), which makes inferences based on the logic programming language. In response to a query, Pyke first creates a knowledge base, populating it with known facts and rules. Subsequently, it applies forward- and backward-chaining algorithms to infer new facts and substantiate the goal.</p>
<p>FOL Prover. We use Prover $9^{2}$ as the FOL inference engine. Prover 9 is an automated theorem prover that supports first-order logic and equational logic. It initially converts FOL statements to conjunctive normal form (CNF) and then performs resolution (Robinson, 1965) on the CNF to deduce whether a conclusion is true, false, or unknown.</p>
<p>CSP Solver. Solving a CSP is to find value assignments for all variables that satisfy all given constraints. Commonly used algorithms for this task include backtracking, constraint propagation, and local search variants. To this end, we incorporate the python-constraint package which offers solvers for CSPs over finite domains.</p>
<p>SAT Solver. For solving SAT problems, we use the Z3 theorem prover (de Moura and Bjørner, 2008), a satisfiability modulo theories (SMT) solver developed by Microsoft ${ }^{4}$. The SMT solver provides algorithms to determine whether a set of mathematical formulas is satisfiable. It generalizes the SAT problems to more complex formulas involving real numbers, integers, and various data structures such as lists, arrays, bit vectors, and strings. A lot of real-world analytical reasoning problems can be represented as problems of solving a system of equations.</p>
<h3>3.3 Self-Refiner</h3>
<p>For complex problems, generating the correct logical form may become challenging for LLMs. To address this, we introduce a self-refinement module that learns to modify inaccurate logical for-</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>mulations using the error messages from the symbolic reasoner as feedback. Recent works (Chen et al., 2023; Madaan et al., 2023) have adopted similar ideas to improve code generation, by teaching LLMs to debug their predicted programs via fewshot demonstrations. Here we extend this idea to refine generated logic representations. If the symbolic solver returns an execution error, we instruct the LLM to refine the incorrect logical form, by prompting it with the erroneous logic form, the solver's error message, and a set of demonstrations showing common error cases (e.g., a free variable is not bounded to any quantifier in FOL) and their remedies. We run this process iteratively until either no error messages are returned, or the maximum number of allowable revisions is reached.</p>
<h3>3.4 Result Interpreter</h3>
<p>Finally, the result interpreter translates the results returned from the symbolic solver back to a natural language answer. For certain problems, this can be achieved through predefined rules; for example, mapping Entailment to true. However, this process can be more complex for CSPs, e.g., translating {convertible: 1, tractor: 2, minivan: 3} to "the convertible is the oldest.". To handle these varying levels of complexity, we designed both rule-based and LLM-based result interpreters. Details of the result interpreter are given in Appendix D.</p>
<h2>4 Experiments</h2>
<p>Datasets. We evaluate Logic-LM on five common logical reasoning datasets, as follows.</p>
<p>PrOntoQA (Saparov and He, 2023) is a recent synthetic dataset created to analyze the capacity of LLMs for deductive reasoning. We use the hardest fictional characters version of the dataset, based on the results in Saparov and He (2023). Each version is divided into different subsets depending on the number of reasoning hops required. We use the hardest 5-hop subset for evaluation. Each question in PrOntoQA aims to validate a new fact's veracity, such as "True or false: Alex is not shy.".</p>
<p>ProofWriter (Tafjord et al., 2021) is another commonly used dataset for deductive logical reasoning. Compared with PrOntoQA, the problems are expressed in a more naturalistic language form. We use the open-world assumption (OWA) subset in which each example is a (problem, goal) pair and the label is one of ${$ PROVED, DISPROVED, UNKNOWN $}$. The dataset is divided into five parts, each part requiring $0, \leq 1, \leq 2, \leq 3$, and $\leq 5$ hops of reasoning, respectively. We evaluate the hardest depth-5 subset. To reduce overall experimentation costs, we randomly sample 600 examples in the test set and ensure a balanced label distribution.</p>
<p>FOLIO (Han et al., 2022) is a challenging expert-written dataset for logical reasoning. The problems are mostly aligned with real-world knowledge and use highly natural wordings, and the questions require complex first-order logic reasoning to solve. We use the entire FOLIO test set for evaluation, consisting of 204 examples.</p>
<p>LogicalDeduction is a challenging logical reasoning task from the BigBench (Srivastava et al., 2022) collaborative benchmark. The problems are mostly about deducing the order of a sequence of objects from a minimal set of conditions. We use the full test set consisting of 300 examples.</p>
<p>AR-LSAT (Zhong et al., 2022) is a dataset that collects all analytical logic reasoning questions from the Law School Admission Test from 1991 to 2016. We use the test set which has 231 multiplechoice questions. AR-LSAT is particularly challenging, with state-of-the-art models only achieving performance slightly better than random guessing (Liang et al., 2022; Ribeiro et al., 2023a).</p>
<p>We convert all examples into a standard multiplechoice format, comprising a problem statement, a question, and potential answers, as shown in Figure 2. We also select 1-5 examples from the training set of each dataset as in-context examples. Detailed data statistics are in Appendix B.</p>
<p>Baselines. We compare our model against two baselines that depend solely on LLMs for logical reasoning: 1) Standard LLMs, which leverage incontext learning to directly answer the question; and 2) Chain-of-Thought (CoT) (Wei et al., 2022b), which adopts a step-by-step problem-solving approach, generating explanations before providing the final answer. We separately evaluate the settings that ChatGPT (gpt-3.5-turbo), GPT-3.5 (text-davinci-003) (Ouyang et al., 2022a) and GPT-4 (gpt-4) (OpenAI, 2023) serve as the underlying LLMs for all models. To ensure fair comparisons, we use the same in-context examples for all models. For reproducible results, we set the temperature to 0 and select the response with the highest probability from LLMs. Since all examples are formed as multiple-choice questions, we evaluate model performance based on the accuracy of selecting the correct answer.</p>
<table>
<thead>
<tr>
<th>Dataset</th>
<th>ChatGPT (gpt-3.5-turbo)</th>
<th></th>
<th></th>
<th>GPT-3.5 (text-davinci-003)</th>
<th></th>
<th></th>
<th>GPT-4 (gpt-4)</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Standard</td>
<td>CoT</td>
<td>Logic-LM</td>
<td>Standard</td>
<td>CoT</td>
<td>Logic-LM</td>
<td>Standard</td>
<td>CoT</td>
<td>Logic-LM</td>
</tr>
<tr>
<td>PrOntoQA</td>
<td>47.40</td>
<td>$\underline{67.80}$</td>
<td>61.00</td>
<td>51.80</td>
<td>83.00</td>
<td>$\underline{85.00}$</td>
<td>77.40</td>
<td>$\underline{98.79}$</td>
<td>83.20</td>
</tr>
<tr>
<td>ProofWriter</td>
<td>35.50</td>
<td>49.17</td>
<td>$\underline{58.33}$</td>
<td>36.16</td>
<td>48.33</td>
<td>$\underline{71.45}$</td>
<td>52.67</td>
<td>68.11</td>
<td>$\underline{79.66}$</td>
</tr>
<tr>
<td>FOLIO</td>
<td>45.09</td>
<td>57.35</td>
<td>$\underline{62.74}$</td>
<td>54.60</td>
<td>57.84</td>
<td>$\underline{61.27}$</td>
<td>69.11</td>
<td>70.58</td>
<td>$\underline{78.92}$</td>
</tr>
<tr>
<td>LogicalDeduction</td>
<td>40.00</td>
<td>42.33</td>
<td>$\underline{65.67}$</td>
<td>41.33</td>
<td>48.33</td>
<td>$\underline{62.00}$</td>
<td>71.33</td>
<td>75.25</td>
<td>$\underline{87.63}$</td>
</tr>
<tr>
<td>AR-LSAT</td>
<td>20.34</td>
<td>17.31</td>
<td>$\underline{26.41}$</td>
<td>22.51</td>
<td>22.51</td>
<td>$\underline{25.54}$</td>
<td>33.33</td>
<td>35.06</td>
<td>$\underline{43.04}$</td>
</tr>
</tbody>
</table>
<p>Table 2: Accuracy of standard promoting (Standard), chain-of-thought promoting (CoT), and our method (LOGICLM, without self-refinement) on five reasoning datasets. The best results within each base LLM are highlighted.</p>
<h3>4.1 Main Results</h3>
<p>We report the results of LOGIC-LM (without selfrefinement) and baselines in Table 2. For LOGICLM, a symbolic solver does not return an answer when there are grammar errors in the symbolic formulation. For these un-executable cases, we fall back on using chain-of-thought to predict the answer. We have three major observations.</p>
<ol>
<li>Logic-LM significantly outperforms standard LLMs and CoT across all datasets. With GPT-3.5, our method outperforms standard LLM on all datasets, with an average improvement of 39.2%. This highlights the benefit of combining LLMs with external symbolic solvers for logical reasoning. LOGIC-LM also improves CoT by a large margin of 18.4% on average, showing that offloading the reasoning to symbolic solvers greatly improves faithfulness compared with pure language-based reasoning with CoT.</li>
<li>GPT-4 outperforms GPT-3.5 by a large margin of 48.46% on average for the standard prompting. This aligns with the assertion that the main enhancement of GPT-4 lies in its ability to carry out complex reasoning <em>OpenAI (2023)</em>. Although this may indicate that the logical reasoning capability can be boosted by scaling up the LLM, we observe that GPT-4 still makes numerous unfaithful reasoning errors. By delegating the reasoning to symbolic solvers, our method can further improve GPT-4 by an average of 24.98% and 10.44% for standard prompting and CoT prompting, respectively.</li>
<li>While integrating CoT generally enhances LLM performance, we find its benefits comparatively less substantial or even negative on FOLIO, LogicalDeduction, and AR-LSAT, with a modest improvement of 11.75%, 9.41%, and -3.2%, respectively. On the contrary, the benefits of CoT on ProntoQA and ProofWriter are 51.59% and 33.82%, respectively. A plausible explanation is</li>
</ol>
<table>
<thead>
<tr>
<th>Dataset</th>
<th>SR</th>
<th>GPT-3.5</th>
<th></th>
<th></th>
<th>GPT-4</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>Exe_Rate</td>
<td>Exe_Acc</td>
<td>Exe_Rate</td>
<td>Exe_Acc</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ProntoQA</td>
<td>-</td>
<td>99.4%</td>
<td>84.9</td>
<td>100.0%</td>
<td>83.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>+</td>
<td>100.0% $\uparrow$ 0.6</td>
<td>85.0 $\uparrow$ 0.1</td>
<td>100.0%</td>
<td>83.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ProofWriter</td>
<td>-</td>
<td>87.3%</td>
<td>73.6</td>
<td>99.0%</td>
<td>79.6</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>+</td>
<td>95.6% $\uparrow$ 8.3</td>
<td>74.1 $\uparrow$ 0.5</td>
<td>99.0%</td>
<td>79.6</td>
<td></td>
<td></td>
</tr>
<tr>
<td>FOLIO</td>
<td>-</td>
<td>66.7%</td>
<td>61.8</td>
<td>79.9%</td>
<td>80.4</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>+</td>
<td>84.3% $\uparrow$ 17.6</td>
<td>64.3 $\uparrow$ 2.5</td>
<td>85.8% $\uparrow$ 5.9</td>
<td>79.9 $\downarrow$ 0.5</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Logical</td>
<td>-</td>
<td>100.0%</td>
<td>62.0</td>
<td>100.0%</td>
<td>87.6</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Deduction</td>
<td>+</td>
<td>100.0%</td>
<td>62.0</td>
<td>100.0%</td>
<td>87.6</td>
<td></td>
<td></td>
</tr>
<tr>
<td>AR-LSAT</td>
<td>-</td>
<td>11.3%</td>
<td>57.7</td>
<td>32.6%</td>
<td>60.0</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>+</td>
<td>21.8% $\uparrow$ 10.5</td>
<td>60.3 $\uparrow$ 2.6</td>
<td>39.8% $\uparrow$ 7.2</td>
<td>58.8 $\downarrow$ 1.2</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Table 3: Analysis of accuracy and execution status of LOGIC-LM. We present the percentage of executable logical formulations (Exe_Rate) together with the accuracy of the execution (Exe_Acc). SR represents before $(-)$ and after $(+)$ self-refinement.
that CoT emulates human forward-chain reasoning: beginning with known facts and sequentially deriving new conclusions until the goal is met. This reasoning style aligns well with problems in the PrOntoQA and ProofWriter datasets. However, FOL and CSP problems often necessitate more sophisticated reasoning strategies that are "nonlinear" compared to standard forward-chain reasoning. These include hypothesizing, conditioning, recursive inference, and the process of elimination. Compared to CoT, the integration of symbolic solvers is better suited to these reasoning styles, hence yielding a more marked improvement on FOLIO (+21.85%), LogicalDeduction (+45.67%), and AR-LSAT (+24.14%).</p>
<h3>4.2 Effectiveness of Problem Formulator</h3>
<p>We then evaluate how well LLM can translate a given problem into the symbolic formulation used by each symbolic solver. In Table 3, we report the percentage of symbolic formulations that are executable by the corresponding symbolic solver for</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: Accuracy of different models for increasing size of reasoning depth on the ProofWriter dataset.</p>
<p>Each dataset (Exe_Rate). Generally, LLM demonstrates high proficiency in transcribing problems into symbolic formats, evidenced by its near 100% Exe_Rate on ProntoQA, ProofWriter, and LogicalDeduction. However, the high performance on these datasets is somewhat anticipated, given that their problems are mostly synthetically generated, limiting language variability. When it comes to datasets comprising real-world, expertly crafted problems, such as FOLIO and AR-LSAT, GPT-4's performance is notably less promising, with Exe_Rate scores of 79.9% and 32.6% respectively. This discrepancy underscores the inherent challenges associated with converting real-world problems into their logical equivalents.</p>
<p>Exe_Rate only reflects the <em>grammar</em> correctness of the logical form. We also report the accuracy of the executable samples (Exe_Acc) to measure the <em>semantic</em> correctness. We find that logical forms generated by GPT-4 generally achieve high Exe_Acc, even for the most challenging AR-LSAT dataset. Such performance accentuates the potential of symbolic solvers in bolstering the model's logical reasoning prowess, contingent on the precise translation of problems into symbolic forms.</p>
<h3>4.3 Robustness of Reasoning</h3>
<p>Incorporating symbolic solvers also leads to more <em>robust</em> reasoning. To illustrate this, we report the performance of LOGIC-LM and baselines for questions of varying complexity levels. We randomly selected 300 examples from each subset of ProofWriter, ensuring a balanced label distribution. The problems in these subsets require 0, &lt;=1, &lt;=2, &lt;=3, and &lt;=5 hops of reasoning, respectively. The results, shown in Figure 3, indicate that LOGIC-LM becomes increasingly effective as the required reasoning depth increases. For exam-</p>
<p><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 4: The accuracy for different rounds of self-refinement, with the corresponding executable rates.</p>
<p>ple, LOGIC-LM outperforms CoT by 7.1%, 5.0%, 12.7%, 20.0%, and 39.4% on depth-0, depth-1, depth-2, depth-4, and depth-5 problems, respectively. In LOGIC-LM, multi-step logical reasoning is delegated to external symbolic solvers, thereby transitioning the challenge of LLM from <em>problemsolving</em> to <em>problem representation</em>. Ideally, the complexity of formally representing a problem statement in logical form should remain relatively constant, regardless of whether the questions require simple or complex reasoning. The trends in Figure 3 validate this assumption. The performance of <em>Standard</em> and <em>CoT</em> declines precipitously with the escalation of problem complexity. However, this trend is less prominent for LOGIC-LM, indicating that the robust reasoning capabilities provided by external solvers substantially mitigate performance degradation for complex reasoning problems.</p>
<h3>4.4 Impact of Self-Refinement</h3>
<p>In Table 3, we find that self-refinement is effective in fixing the inexecutable symbolic formulations, increasing the Exe_Rate by 5.01 on average. For an in-depth analysis, we then evaluate the accuracy and Exe_Rate across different rounds of self-refinement on FOLIO, namely, 0 (no refinement), 1, 2, and 3 rounds. The results are in Figure 4.</p>
<p>We find that as the rounds of self-refinement increase, the percentage of executable formulations consistently increases, leading to an enhancement in the final performance. This suggests that self-refinement serves as an effective tool in aiding the LLM to accurately frame the problem. However, the accuracy tends to stagnate in subsequent rounds, even though the Exe_Rate continues to increase. This can be attributed to the type of feedback received by the self-refiner, which is the error mes-</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Problem: "Stranger Things" is a popular Netflix show. If a Netflix show is popular, Karen will binge-watch it.</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">If and only if Karen binge-watches a Netflix show, she will download it. Karen does not download "Black Mirror".</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">"Black Mirror" is a Netflix show. If Karen binge-watches a Netflix show, she will share it to Lisa.</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Question: Is the following statement true, false, or uncertain? "Black Mirror" is popular.</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">(A) True</td>
<td style="text-align: center;">(B) False (C) Uncertain</td>
</tr>
<tr>
<td style="text-align: center;">Generated symbolic formulations:</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Predicates:</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">NetflixShow $(x) # x$ is a Netflix show.</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Popular $(x) # x$ is popular.</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">BingeWatch $(x, y) # x$ binge-watches $y$.</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Download $(x, y) # x$ downloads $y$.</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Share $(x, y, z) # x$ shares $y$ to $z$.</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Premises:</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">NetflixShow(strangerThings) $\wedge$ Popular(strangerThings) # "Stranger Things" is a popular Netflix show.</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Vx (NetflixShow $(x)$ ^ Popular $(x)$ = BingeWatch(karen, x)) # If a Netflix show is popular, Karen will binge-watch it.</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Vx (NetflixShow $(x)$ ^ BingeWatch(karen, x) == Download(karen, x)) # If and only if Karen ... she will download it.</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">NetflixShow(blackMirror) $\wedge$ -Download(karen, blackMirror) # Karen does not ... "Black Mirror" is a Netflix show.</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Vx (NetflixShow $(x)$ ^ BingeWatch(karen, x) + Share(karen, x, lisa)) # If Karen ... she will share it to Lisa.</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Conclusion:</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Popular(blackMirror) # "Black Mirror" is popular.</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Predicted answer: B</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>Figure 5: An example of the generated symbolic representation and the predicted answer by LOGIC-LM.
sage from the symbolic solver. This feedback aids in converting "invalid" symbolic representations into valid ones. However, a valid symbolic representation does not necessarily equate to a "correct" problem formulation that accurately represents the problem. This issue could be tackled by enhancing the self-refiner to incorporate feedback beyond the error message, e.g., a reward signal from an additional module evaluating the accuracy of a generated symbolic form. We leave this as a promising direction for future exploration.</p>
<h3>4.5 Case Study</h3>
<p>In Figure 5, we show an example of the symbolic representations generated by GPT-4, together with the predicted answer. In general, LOGIC-LM has demonstrated a potent capacity to interpret complex problems into symbolic forms. Nonetheless, there remain certain difficulties in accurately understanding the semantics of the problem.</p>
<p>We further analyze some error cases in Figure 6 of Appendix E. Example 1 shows a case where GPT-4 generates an incorrect FOL representation, stemming from its inability to define appropriate predicates. Here, instead of creating the predicate EasternWildTurkey, the model generates a constant, WildTurkey(eastern), in which WildTurkey is the predicate and eastern is the constant. While this representation is valid in isolation, it does not interact well with subsequent constants. This inconsistency is a recurring issue in GPT-4's symbolic form generation, illustrating that the model sometimes struggles to maintain an overarching understanding of the problem when forming logical symbols. Example 3 highlights a case where GPT-4 struggles to interpret specific
expressions accurately. In this case, the model fails to distinguish between the meanings of "below" and "above", resulting in an incorrect constraint Dan &gt; Eve. Example 4 exemplifies GPT-4's challenge with fully grasping the rules of FOL grammar, evidenced by the invalid generated formula: Rating(subway, y) $\wedge y&gt;9$. These error cases underscore that transforming problems into logical forms remains a challenging task for modern LLMs, due to the intricacies of FOL formulation, the innate flexibility of natural language, and the complexity of global problem comprehension.</p>
<h2>5 Conclusion and Future Work</h2>
<p>In this work, we propose a novel approach to address logical reasoning problems by combining large language models with symbolic solvers. We introduce Logic-LM, one instantiation of such a framework, and demonstrate how it significantly improves performance over pure LLMs and chain-of-thought prompting techniques.</p>
<p>While Logic-LM has proven to be a capable system, it can be further improved with extension to more flexible and powerful logic systems. For example, statistical relational learning (SRL) systems such as Markov logic networks (Richardson and Domingos, 2006) and probabilistic soft logic (Bach et al., 2017) have demonstrated great promise in reasoning under uncertainty and integration with our framework would enable even more adaptive problem-solving capabilities. Additionally, our method can be extended to reasoning problems requiring commonsense, which remains a significant challenge as they often require reasoning over complex and ambiguous rules.</p>
<h2>Limitations</h2>
<p>We identify two main limitations of LOGIC-LM. First, LOGIC-LM relies on translating reasoning problems into logical formats that can be tackled by symbolic solvers. As a consequence, the model's applicability is inherently bounded by the expressiveness of the symbolic solver, for example, not all problems can be easily encoded in first-order logic. Nevertheless, this limitation can be mitigated by integrating a more diverse set of symbolic solvers. The flexible design of LOGIC-LM facilitates this integration. The wide range of reasoning tasks that we can instantiate our LOGIC-LM framework on shows its general applicability.</p>
<p>Second, LOGIC-LM depends on in-context learning coupled with self-refinement to convert a natural language (NL) problem into the symbolic representation. While this method has proven to be effective, it may face difficulties when dealing with logical representations with intricate grammar structures, such as probabilistic soft logic. This arises from the difficulty in conveying complex grammatical rules to the language model through a limited number of demonstrations within a constrained context size. As a potential solution, future works could explore the development of specialized modules to enhance the mapping between NL and symbolic language, e.g., fine-tuning LLMs with synthetic data generated via symbolic solvers.</p>
<h2>Ethics Statement</h2>
<p>The use of large language models requires a significant amount of energy for computation for training, which contributes to global warming (Strubell et al., 2019). Our work performs few-shot in-context learning instead of training models from scratch, so the energy footprint of our work is less. The large language models whose API we use for inference, especially GPT-4, consume significant energy.</p>
<h2>Acknowledgements</h2>
<p>This work was supported by the National Science Foundation Award #2048122. The views expressed are those of the authors and do not reflect the official policy or position of the US government.</p>
<h2>References</h2>
<p>Stephen Bach, Matthias Broecheler, Bert Huang, and Lise Getoor. 2017. Hinge-loss markov random fields
and probabilistic soft logic. Journal of Machine Learning Research (JMLR), 18(1):1-67.</p>
<p>Tom B. Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, Sandhini Agarwal, Ariel Herbert-Voss, Gretchen Krueger, Tom Henighan, Rewon Child, Aditya Ramesh, Daniel M. Ziegler, Jeffrey Wu, Clemens Winter, Christopher Hesse, Mark Chen, Eric Sigler, Mateusz Litwin, Scott Gray, Benjamin Chess, Jack Clark, Christopher Berner, Sam McCandlish, Alec Radford, Ilya Sutskever, and Dario Amodei. 2020. Language models are few-shot learners. In Proceedings of the Annual Conference on Neural Information Processing Systems (NeurIPS).</p>
<p>Le-Wen Cai, Wang-Zhou Dai, Yu-Xuan Huang, YuFeng Li, Stephen H. Muggleton, and Yuan Jiang. 2021. Abductive learning with ground knowledge base. In Proceedings of the 30th International Joint Conference on Artificial Intelligence (IJCAI), pages $1815-1821$.</p>
<p>Wenhu Chen, Xueguang Ma, Xinyi Wang, and William W. Cohen. 2022. Program of thoughts prompting: Disentangling computation from reasoning for numerical reasoning tasks. CoRR, abs/2211.12588.</p>
<p>Xinyun Chen, Maxwell Lin, Nathanael Schärli, and Denny Zhou. 2023. Teaching large language models to self-debug. CoRR, abs/2304.05128.</p>
<p>Peter Clark, Oyvind Tafjord, and Kyle Richardson. 2020. Transformers as soft reasoners over language. In Proceedings of the 29th International Joint Conference on Artificial Intelligence (IJCAI), pages 3882-3890.</p>
<p>William F Clocksin and Christopher S Mellish. 2003. Programming in PROLOG. Springer Science \&amp; Business Media.</p>
<p>Karl Cobbe, Vineet Kosaraju, Mohammad Bavarian, Jacob Hilton, Reiichiro Nakano, Christopher Hesse, and John Schulman. 2021. Training verifiers to solve math word problems. CoRR, abs/2110.14168.</p>
<p>Leonardo Mendonça de Moura and Nikolaj S. Bjørner. 2008. Z3: an efficient SMT solver. In Proceedings of the 14th International Conference of Tools and Algorithms for the Construction and Analysis of Systems (TACAS), volume 4963 of Lecture Notes in Computer Science, pages 337-340.</p>
<p>Leonardo Mendonça de Moura, Soonho Kong, Jeremy Avigad, Floris van Doorn, and Jakob von Raumer. 2015. The lean theorem prover (system description). In Proceedings of the 25th International Conference on Automated Deduction (ICAD), volume 9195 of Lecture Notes in Computer Science, pages 378-388.</p>
<p>Iddo Drori, Sarah Zhang, Reece Shuttleworth, Leonard Tang, Albert Lu, Elizabeth Ke, Kevin Liu, Linda Chen, Sunny Tran, Newman Cheng, et al. 2022. A</p>
<p>neural network solves, explains, and generates university math problems by program synthesis and fewshot learning at human level. Proceedings of the National Academy of Sciences, 119(32):e2123433119.</p>
<p>Herbert B Enderton. 2001. A mathematical introduction to logic. Elsevier.</p>
<p>Bruce Frederiksen. 2008. Applying expert system technology to code reuse with pyke. PyCon: Chicago.</p>
<p>Luyu Gao, Aman Madaan, Shuyan Zhou, Uri Alon, Pengfei Liu, Yiming Yang, Jamie Callan, and Graham Neubig. 2023. PAL: program-aided language models. In Proceedings of the International Conference on Machine Learning (ICML), volume 202, pages 10764-10799.</p>
<p>Olga Golovneva, Moya Chen, Spencer Poff, Martin Corredor, Luke Zettlemoyer, Maryam Fazel-Zarandi, and Asli Celikyilmaz. 2023. ROSCOE: A suite of metrics for scoring step-by-step reasoning. In Proceedings of the 11th International Conference on Learning Representations (ICLR).</p>
<p>Nitish Gupta, Kevin Lin, Dan Roth, Sameer Singh, and Matt Gardner. 2020. Neural module networks for reasoning over text. In Proceedings of the 8th International Conference on Learning Representations (ICLR).</p>
<p>Simeng Han, Hailey Schoelkopf, Yilun Zhao, Zhenting Qi, Martin Riddell, Luke Benson, Lucy Sun, Ekaterina Zubova, Yujie Qiao, Matthew Burtell, David Peng, Jonathan Fan, Yixin Liu, Brian Wong, Malcolm Sailor, Ansong Ni, Linyong Nan, Jungo Kasai, Tao Yu, Rui Zhang, Shafiq R. Joty, Alexander R. Fabbri, Wojciech Kryscinski, Xi Victoria Lin, Caiming Xiong, and Dragomir Radev. 2022. FOLIO: natural language reasoning with first-order logic. CoRR, abs/2209.00840.</p>
<p>Joy He-Yueya, Gabriel Poesia, Rose E Wang, and Noah D Goodman. 2023. Solving math word problems by combining language models with symbolic solvers. CoRR, abs/2304.09102.</p>
<p>Jie Huang and Kevin Chen-Chuan Chang. 2023. Towards reasoning in large language models: A survey. In Findings of the 61st Annual Meeting of the Association for Computational Linguistics (ACL), pages 1049-1065.</p>
<p>Albert Qiaochu Jiang, Sean Welleck, Jin Peng Zhou, Timothée Lacroix, Jiacheng Liu, Wenda Li, Mateja Jamnik, Guillaume Lample, and Yuhuai Wu. 2023. Draft, sketch, and prove: Guiding formal theorem provers with informal proofs. In Proceedings of the 11th International Conference on Learning Representations (ICLR).</p>
<p>Takeshi Kojima, Shixiang Shane Gu, Machel Reid, Yutaka Matsuo, and Yusuke Iwasawa. 2022. Large language models are zero-shot reasoners. In Proceedings of the Annual Conference on Neural Information Processing Systems (NeurIPS).</p>
<p>Philipp Körner, Michael Leuschel, João Barbosa, Vítor Santos Costa, Verónica Dahl, Manuel V. Hermenegildo, José F. Morales, Jan Wielemaker, Daniel Diaz, and Salvador Abreu. 2022. Fifty years of prolog and beyond. Theory Pract. Log. Program., 22(6):776-858.</p>
<p>Vipin Kumar. 1992. Algorithms for constraintsatisfaction problems: A survey. AI Mag., 13(1):3244.</p>
<p>Angeliki Lazaridou, Elena Gribovskaya, Wojciech Stokowiec, and Nikolai Grigorev. 2022. Internetaugmented language models through few-shot prompting for open-domain question answering. CoRR, abs/2203.05115.</p>
<p>Percy Liang, Rishi Bommasani, Tony Lee, Dimitris Tsipras, Dilara Soylu, Michihiro Yasunaga, Yian Zhang, Deepak Narayanan, Yuhuai Wu, Ananya Kumar, Benjamin Newman, Binhang Yuan, Bobby Yan, Ce Zhang, Christian Cosgrove, Christopher D. Manning, Christopher Ré, Diana Acosta-Navas, Drew A. Hudson, Eric Zelikman, Esin Durmus, Faisal Ladhak, Frieda Rong, Hongyu Ren, Huaxiu Yao, Jue Wang, Keshav Santhanam, Laurel J. Orr, Lucia Zheng, Mert Yüksekgönül, Mirac Suzgun, Nathan Kim, Neel Guha, Niladri S. Chatterji, Omar Khattab, Peter Henderson, Qian Huang, Ryan Chi, Sang Michael Xie, Shibani Santurkar, Surya Ganguli, Tatsunori Hashimoto, Thomas Icard, Tianyi Zhang, Vishrav Chaudhary, William Wang, Xuechen Li, Yifan Mai, Yuhui Zhang, and Yuta Koreeda. 2022. Holistic evaluation of language models. CoRR, abs/2211.09110.</p>
<p>Bo Liu, Yuqian Jiang, Xiaohan Zhang, Qiang Liu, Shiqi Zhang, Joydeep Biswas, and Peter Stone. 2023a. LLM+P: empowering large language models with optimal planning proficiency. CoRR, abs/2304.11477.</p>
<p>Hanmeng Liu, Ruoxi Ning, Zhiyang Teng, Jian Liu, Qiji Zhou, and Yue Zhang. 2023b. Evaluating the logical reasoning ability of chatgpt and GPT-4. CoRR, abs/2304.03439.</p>
<p>Qing Lyu, Shreya Havaldar, Adam Stein, Li Zhang, Delip Rao, Eric Wong, Marianna Apidianaki, and Chris Callison-Burch. 2023. Faithful chain-ofthought reasoning. CoRR, abs/2301.13379.</p>
<p>Aman Madaan, Niket Tandon, Prakhar Gupta, Skyler Hallinan, Luyu Gao, Sarah Wiegreffe, Uri Alon, Nouha Dziri, Shrimai Prabhumoye, Yiming Yang, Sean Welleck, Bodhisattwa Prasad Majumder, Shashank Gupta, Amir Yazdanbakhsh, and Peter Clark. 2023. Self-refine: Iterative refinement with self-feedback. CoRR, abs/2303.17651.</p>
<p>Robin Manhaeve, Sebastijan Dumancic, Angelika Kimmig, Thomas Demeester, and Luc De Raedt. 2021. Neural probabilistic logic programming in deepproblog. The Journal of Artificial Intelligence (AIJ), 298:103504.</p>
<p>Jiayuan Mao, Chuang Gan, Pushmeet Kohli, Joshua B. Tenenbaum, and Jiajun Wu. 2019. The neurosymbolic concept learner: Interpreting scenes, words, and sentences from natural supervision. In Proceedings of the 7th International Conference on Learning Representations (ICLR).</p>
<p>Kostas S. Metaxiotis, Dimitris Askounis, and John E. Psarras. 2002. Expert systems in production planning and scheduling: A state-of-the-art survey. Journal of Intelligent Manufacturing, 13(4):253-260.</p>
<p>Aaron Meurer, Christopher P. Smith, Mateusz Paprocki, Ondrej Certík, Sergey B. Kirpichev, Matthew Rocklin, Amit Kumar, Sergiu Ivanov, Jason Keith Moore, Sartaj Singh, Thilina Rathnayake, Sean Vig, Brian E. Granger, Richard P. Muller, Francesco Bonazzi, Harsh Gupta, Shivam Vats, Fredrik Johansson, Fabian Pedregosa, Matthew J. Curry, Andy R. Terrel, Stepán Roucka, Ashutosh Saboo, Isuru Fernando, Sumith Kulal, Robert Cimrman, and Anthony M. Scopatz. 2017. Sympy: symbolic computing in python. PeerJ Computer Science, 3:e103.</p>
<p>Reiichiro Nakano, Jacob Hilton, Suchir Balaji, Jeff Wu, Long Ouyang, Christina Kim, Christopher Hesse, Shantanu Jain, Vineet Kosaraju, William Saunders, Xu Jiang, Karl Cobbe, Tyna Eloundou, Gretchen Krueger, Kevin Button, Matthew Knight, Benjamin Chess, and John Schulman. 2021. Webgpt: Browserassisted question-answering with human feedback. CoRR, abs/2112.09332.</p>
<p>OpenAI. 2023. GPT-4 technical report. CoRR, abs/2303.08774.</p>
<p>Long Ouyang, Jeffrey Wu, Xu Jiang, Diogo Almeida, Carroll L. Wainwright, Pamela Mishkin, Chong Zhang, Sandhini Agarwal, Katarina Slama, Alex Ray, John Schulman, Jacob Hilton, Fraser Kelton, Luke Miller, Maddie Simens, Amanda Askell, Peter Welinder, Paul F. Christiano, Jan Leike, and Ryan Lowe. 2022a. Training language models to follow instructions with human feedback. In Proceedings of the Annual Conference on Neural Information Processing Systems (NeurIPS).</p>
<p>Long Ouyang, Jeffrey Wu, Xu Jiang, Diogo Almeida, Carroll L. Wainwright, Pamela Mishkin, Chong Zhang, Sandhini Agarwal, Katarina Slama, Alex Ray, John Schulman, Jacob Hilton, Fraser Kelton, Luke Miller, Maddie Simens, Amanda Askell, Peter Welinder, Paul F. Christiano, Jan Leike, and Ryan Lowe. 2022b. Training language models to follow instructions with human feedback. In Proceedings of the Annual Conference on Neural Information Processing Systems (NeurIPS.</p>
<p>Lawrence C. Paulson. 1994. Isabelle - A Generic Theorem Prover (with a contribution by T. Nipkow), volume 828 of Lecture Notes in Computer Science. Springer.</p>
<p>David Poole and Alan K. Mackworth. 2010. Artificial Intelligence - Foundations of Computational Agents. Cambridge University Press.</p>
<p>Connor Pryor, Charles Dickens, Eriq Augustine, Alon Albalak, William Yang Wang, and Lise Getoor. 2023. Neupsl: Neural probabilistic soft logic. In Proceedings of the 32nd International Joint Conference on Artificial Intelligence (IJCAI), pages 4145-4153.</p>
<p>Danilo Neves Ribeiro, Shen Wang, Xiaofei Ma, Henghui Zhu, Rui Dong, Deguang Kong, Juliette Burger, Anjelica Ramos, Zhiheng Huang, William Yang Wang, George Karypis, Bing Xiang, and Dan Roth. 2023a. STREET: A multi-task structured reasoning and explanation benchmark. In Proceedings of the Eleventh International Conference on Learning Representations (ICLR).</p>
<p>Danilo Neves Ribeiro, Shen Wang, Xiaofei Ma, Henry Zhu, Rui Dong, Deguang Kong, Juliette Burger, Anjelica Ramos, William Yang Wang, Zhiheng Huang, George Karypis, Bing Xiang, and Dan Roth. 2023b. STREET: A multi-task structured reasoning and explanation benchmark. In Proceedings of the 11th International Conference on Learning Representations (ICLR).</p>
<p>Matthew Richardson and Pedro M. Domingos. 2006. Markov logic networks. Machine Learning, 62(12):107-136.</p>
<p>John Alan Robinson. 1965. A machine-oriented logic based on the resolution principle. The Journal of the ACM (JACM), 12(1):23-41.</p>
<p>Abulhair Saparov and He He. 2023. Language models are greedy reasoners: A systematic formal analysis of chain-of-thought. In Proceedings of the 11th International Conference on Learning Representations (ICLR).</p>
<p>Murray Shanahan. 2022. Talking about large language models. CoRR, abs/2212.03551.</p>
<p>Yongliang Shen, Kaitao Song, Xu Tan, Dongsheng Li, Weiming Lu, and Yueting Zhuang. 2023. Hugginggpt: Solving AI tasks with chatgpt and its friends in huggingface. CoRR, abs/2303.17580.</p>
<p>Weijia Shi, Sewon Min, Michihiro Yasunaga, Minjoon Seo, Rich James, Mike Lewis, Luke Zettlemoyer, and Wen-tau Yih. 2023. REPLUG: retrieval-augmented black-box language models. CoRR, abs/2301.12652.</p>
<p>Aarohi Srivastava, Abhinav Rastogi, Abhishek Rao, Abu Awal Md Shoeb, Abubakar Abid, Adam Fisch, Adam R. Brown, Adam Santoro, Aditya Gupta, Adrià Garriga-Alonso, Agnieszka Kluska, Aitor Lewkowycz, Akshat Agarwal, Alethea Power, Alex Ray, Alex Warstadt, Alexander W. Kocurek, Ali Safaya, Ali Tazarv, Alice Xiang, Alicia Parrish, Allen Nie, Aman Hussain, Amanda Askell, Amanda Dsouza, Ameet Rahane, Anantharaman S. Iyer, Anders Andreassen, Andrea Santilli, Andreas Stuhlmüller, Andrew M. Dai, Andrew La, Andrew K. Lampinen, Andy Zou, Angela Jiang, Angelica Chen, Anh Vuong, Animesh Gupta, Anna Gottardi, Antonio Norelli, Anu Venkatesh, Arash Gholamidavoodi,</p>
<p>Arfa Tabassum, Arul Menezes, Arun Kirubarajan, Asher Mullokandov, Ashish Sabharwal, Austin Herrick, Avia Efrat, Aykut Erdem, Ayla Karakas, and et al. 2022. Beyond the imitation game: Quantifying and extrapolating the capabilities of language models. CoRR, abs/2206.04615.</p>
<p>Emma Strubell, Ananya Ganesh, and Andrew McCallum. 2019. Energy and policy considerations for deep learning in NLP. In Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics (ACL), pages 3645-3650.</p>
<p>Oyvind Tafjord, Bhavana Dalvi, and Peter Clark. 2021. Proofwriter: Generating implications, proofs, and abductive statements over natural language. In Findings of the 59th Annual Meeting of the Association for Computational Linguistics (ACL), pages 3621-3634.</p>
<p>Oyvind Tafjord, Bhavana Dalvi Mishra, and Peter Clark. 2022. Entailer: Answering questions with faithful and truthful chains of reasoning. In Proceedings of the 2022 Conference on Empirical Methods in Natural Language Processing (EMNLP), pages 20782093.</p>
<p>Jidong Tian, Yitian Li, Wenqing Chen, Liqiang Xiao, Hao He, and Yaohui Jin. 2022. Weakly supervised neural symbolic learning for cognitive tasks. In Proceedings of 36th Conference on Artificial Intelligence (AAAI), pages 5888-5896.</p>
<p>Xingyao Wang, Sha Li, and Heng Ji. 2022. Code4struct: Code generation for few-shot structured prediction from natural language. CoRR, abs/2210.12810.</p>
<p>Xuezhi Wang, Jason Wei, Dale Schuurmans, Quoc V. Le, Ed H. Chi, Sharan Narang, Aakanksha Chowdhery, and Denny Zhou. 2023. Self-consistency improves chain of thought reasoning in language models. In Proceedings of the 11th International Conference on Learning Representations (ICLR).</p>
<p>Jason Wei, Yi Tay, Rishi Bommasani, Colin Raffel, Barret Zoph, Sebastian Borgeaud, Dani Yogatama, Maarten Bosma, Denny Zhou, Donald Metzler, Ed H. Chi, Tatsunori Hashimoto, Oriol Vinyals, Percy Liang, Jeff Dean, and William Fedus. 2022a. Emergent abilities of large language models. Transactions on Machine Learning Research, 2022.</p>
<p>Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Ed H. Chi, Quoc Le, and Denny Zhou. 2022b. Chain of thought prompting elicits reasoning in large language models. CoRR, abs/2201.11903.</p>
<p>Yuhuai Wu, Albert Qiaochu Jiang, Wenda Li, Markus N. Rabe, Charles Staats, Mateja Jamnik, and Christian Szegedy. 2022. Autoformalization with large language models. In Proceedings of the Annual Conference on Neural Information Processing Systems (NeurIPS).</p>
<p>Kaiyu Yang, Jia Deng, and Danqi Chen. 2022. Generating natural language proofs with verifier-guided search. In Proceedings of the 2022 Conference on</p>
<p>Empirical Methods in Natural Language Processing (EMNLP), pages 89-105.</p>
<p>Xi Ye, Qiaochu Chen, Isil Dillig, and Greg Durrett. 2023. Satisfiability-aided language models using declarative prompting. In Proceedings of the Annual Conference on Neural Information Processing Systems (NeurIPS).</p>
<p>Wanjun Zhong, Siyuan Wang, Duyu Tang, Zenan Xu, Daya Guo, Yining Chen, Jiahai Wang, Jian Yin, Ming Zhou, and Nan Duan. 2022. Analytical reasoning of text. In Findings of the 2022 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies (NAACL-HLT), pages 2306-2319.</p>
<p>Denny Zhou, Nathanael Schärli, Le Hou, Jason Wei, Nathan Scales, Xuezhi Wang, Dale Schuurmans, Claire Cui, Olivier Bousquet, Quoc V. Le, and Ed H. Chi. 2023. Least-to-most prompting enables complex reasoning in large language models. In Proceedings of the 11th International Conference on Learning Representations (ICLR).</p>
<h2>A Syntax for First-order Logic (FOL)</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">FOL Notation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Constant</td>
<td style="text-align: left;">lowercase letters</td>
</tr>
<tr>
<td style="text-align: left;">Variable</td>
<td style="text-align: left;">$x, y, z, \cdots$</td>
</tr>
<tr>
<td style="text-align: left;">Atom</td>
<td style="text-align: left;">$P\left(a_{1}, \cdots, a_{n}\right)$</td>
</tr>
<tr>
<td style="text-align: left;">Negation</td>
<td style="text-align: left;">$\neg P$</td>
</tr>
<tr>
<td style="text-align: left;">Conjunction</td>
<td style="text-align: left;">$P_{1} \wedge P_{2}$</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">$P_{1} \wedge, \cdots, \wedge P_{n}$</td>
</tr>
<tr>
<td style="text-align: left;">Disjunction</td>
<td style="text-align: left;">$P_{1} \vee P_{2}$</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">$P_{1} \vee, \cdots, \vee P_{n}$</td>
</tr>
<tr>
<td style="text-align: left;">Implication</td>
<td style="text-align: left;">$P_{1} \rightarrow P_{2}$</td>
</tr>
<tr>
<td style="text-align: left;">Equivalence</td>
<td style="text-align: left;">$P_{1} \leftrightarrow P_{2}$</td>
</tr>
<tr>
<td style="text-align: left;">Existential Quantifier</td>
<td style="text-align: left;">$\exists x P(x, \cdots)$</td>
</tr>
<tr>
<td style="text-align: left;">Universal Quantifier</td>
<td style="text-align: left;">$\forall x P(x, \cdots)$</td>
</tr>
</tbody>
</table>
<p>Table 4: First-Order Logic Grammar.</p>
<h2>B Dataset Statistics</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">Dataset</th>
<th style="text-align: center;">Reasoning</th>
<th style="text-align: center;">Test Size</th>
<th style="text-align: center;">#Opts</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">PrOntoQA</td>
<td style="text-align: center;">Deductive</td>
<td style="text-align: center;">500</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: left;">ProofWriter</td>
<td style="text-align: center;">Deductive</td>
<td style="text-align: center;">600</td>
<td style="text-align: center;">3</td>
</tr>
<tr>
<td style="text-align: left;">FOLIO</td>
<td style="text-align: center;">FOL</td>
<td style="text-align: center;">204</td>
<td style="text-align: center;">3</td>
</tr>
<tr>
<td style="text-align: left;">LogicalDeduction</td>
<td style="text-align: center;">CSP</td>
<td style="text-align: center;">300</td>
<td style="text-align: center;">$3,5,7$</td>
</tr>
<tr>
<td style="text-align: left;">AR-LSAT</td>
<td style="text-align: center;">AR</td>
<td style="text-align: center;">230</td>
<td style="text-align: center;">5</td>
</tr>
</tbody>
</table>
<p>Table 5: Statistics of the logical reasoning datasets.</p>
<h2>C Prompt Examples</h2>
<p>In this section we provide examples of the prompts used for each dataset and method. Prompts for standard in-context learning contain 2 demonstrations consisting of 3 parts each: a context, a question, and options. Prompts for chain-of-thought prompting contain 2 demonstrations consisting of 5 parts each: a task description, a context, a question, options, and a chain of reasoning. Prompts for LogicLM contain 2 demonstrations with 5 parts each: a task description, a context, a question, options, and a domain-specific symbolic program. For brevity, we show only a single demonstration for each setting in the following sections.</p>
<h2>C. 1 PrOntoQA Prompts</h2>
<h2>Standard In-Context Learning</h2>
<div class="codehilite"><pre><span></span><code><span class="n">Context</span><span class="o">:</span><span class="w"> </span><span class="n">Jompuses</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">shy</span><span class="o">.</span><span class="w"> </span><span class="n">Jompuses</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">yumpuses</span><span class="o">.</span>
<span class="o">(</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="n">here</span><span class="w"> </span><span class="o">...)</span>
<span class="n">Jumpuses</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">rompuses</span><span class="o">.</span><span class="w"> </span><span class="n">Max</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">yumpus</span><span class="o">.</span>
<span class="n">Question</span><span class="o">:</span><span class="w"> </span><span class="n">Is</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">following</span><span class="w"> </span><span class="n">statement</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="kc">false</span><span class="o">?</span>
<span class="n">Max</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">sour</span><span class="o">.</span>
<span class="n">Options</span><span class="o">:</span>
<span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">True</span>
<span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="n">False</span>
</code></pre></div>

<p>The correct option is: B</p>
<h2>Chain-of-Thought Prompting</h2>
<div class="codehilite"><pre><span></span><code>Task Description: Given a problem statement as
contexts, the task is to answer a logical reasoning
question.
Context: Jompuses are not shy. Jompuses are yumpuses.
( more context here ...)
Jumpuses are rompuses. Max is a yumpus.
Question: Is the following statement true or false?
Max is sour.
Options:
A) True
B) False
Reasoning: Max is a yumpus. Each yumpus is a dumpus.
( more reasoning here ...)
Tumpuses are not sour. So Max is not sour.
The correct option is: B
</code></pre></div>

<h2>Logic-LM</h2>
<div class="codehilite"><pre><span></span><code>Task Description: You are given a problem description
and a question. The task is to:
1) define all the predicates in the problem
2) parse the problem into logic rules based on
the defined predicates
3) write all the facts mentioned in the problem
4) parse the question into the logic form
Context: Each jompus is fruity.
( more context here ...)
Rompuses are zumpuses. Alex is a tumpus.
Question: True or false: Alex is not shy.
Predicates:
Jompus(\$x, bool) ::: Does x belong to Jompus?
( more predicates here ...)
Jumpus(\$x, bool) ::: Does x belong to Zumpus?
Facts:
Tumpuses(Alex, True)
Rules:
Jompus(\$x, True) &gt;&gt;&gt; Fruity(\$x, True)
( more rules here ...)
Dumpus(\$x, True) &gt;&gt;&gt; Rompus(\$x, True)
Query:
Shy(Alex, False)
</code></pre></div>

<h2>C. 2 ProofWriter Prompts</h2>
<h2>Standard In-Context Learning</h2>
<div class="codehilite"><pre><span></span><code><span class="n">Context</span><span class="o">:</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">cow</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">blue</span><span class="o">.</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">cow</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">round</span><span class="o">.</span>
<span class="o">[--</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="n">here</span><span class="w"> </span><span class="o">...]</span>
<span class="n">If</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">cow</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">cold</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">cow</span><span class="w"> </span><span class="n">visits</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">lion</span><span class="w"> </span><span class="n">then</span>
<span class="n">the</span><span class="w"> </span><span class="n">lion</span><span class="w"> </span><span class="n">sees</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">squirrel</span><span class="o">.</span>
</code></pre></div>

<p>Question: Based on the above information, is the following statement true, false, or unknown? The tiger is not young.</p>
<div class="codehilite"><pre><span></span><code><span class="n">Options</span><span class="o">:</span>
<span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">True</span>
<span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="n">False</span>
<span class="n">C</span><span class="o">)</span><span class="w"> </span><span class="n">Unknown</span>
</code></pre></div>

<p>The correct option is: B</p>
<h2>Chain-of-Thought Prompting</h2>
<p>Task Description: Given a problem statement as contexts, the task is to answer a logical reasoning question.</p>
<div class="codehilite"><pre><span></span><code><span class="n">Context</span><span class="o">:</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">cow</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">blue</span><span class="o">.</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">cow</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">round</span><span class="o">.</span>
<span class="o">[--</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="n">here</span><span class="w"> </span><span class="o">...]</span>
<span class="n">If</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">cow</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">cold</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">cow</span><span class="w"> </span><span class="n">visits</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">lion</span><span class="w"> </span><span class="n">then</span>
<span class="n">the</span><span class="w"> </span><span class="n">lion</span><span class="w"> </span><span class="n">sees</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">squirrel</span><span class="o">.</span>
</code></pre></div>

<p>Question: Based on the above information, is the following statement true, false, or unknown? The tiger is not young.</p>
<div class="codehilite"><pre><span></span><code><span class="n">Options</span><span class="o">:</span>
<span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">True</span>
<span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="n">False</span>
<span class="n">C</span><span class="o">)</span><span class="w"> </span><span class="n">Unknown</span>
</code></pre></div>

<p>Reasoning: The tiger likes the cow.
The tiger likes the squirrel.
[-- more reasoning here ...]
If something is nice and it sees the tiger then
it is young. So the tiger is young.
The correct option is: B</p>
<h2>Logic-LM</h2>
<p>Task Description: You are given a problem description and a question. The task is to:</p>
<p>1) define all the predicates in the problem
2) parse the problem into logic rules based on the defined predicates
3) write all the facts mentioned in the problem
4) parse the question into the logic form</p>
<div class="codehilite"><pre><span></span><code><span class="n">Context</span><span class="o">:</span><span class="w"> </span><span class="n">Anne</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">quiet</span><span class="o">.</span><span class="w"> </span><span class="n">Erin</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">furry</span><span class="o">.</span>
<span class="o">[--</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="n">here</span><span class="w"> </span><span class="o">...]</span>
<span class="n">All</span><span class="w"> </span><span class="n">red</span><span class="w"> </span><span class="n">people</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">young</span><span class="o">.</span>
</code></pre></div>

<p>Question: Based on the above information, is the following statement true, false, or unknown? Anne is white.</p>
<h2>Predicates:</h2>
<p>Quiet(\$x, bool) : : : Is x quiet?
Furry(\$x, bool) : : : Is x furry?
[-- more predicates here ...]
White(\$x, bool) : : : Is x white?
Young(\$x, bool) : : : Is x young?</p>
<h2>Facts:</h2>
<p>Quite(Anne, True) : : : Anne is quiet.
[-- more facts here ...]
White(Harry, True) : : : Harry is white.</p>
<h2>Rules:</h2>
<p>Young(\$x, True) &gt;&gt;&gt; Furry(\$x, True) : : : Young people are furry.
[-- more rules here ...]
Red(\$x, True) &gt;&gt;&gt; Young(\$x, True) : : : All red people are young.</p>
<p>Query:
White(Anne, True) : : : Anne is white</p>
<h2>C. 3 FOLIO Prompts</h2>
<h2>Standard In-Context Learning</h2>
<div class="codehilite"><pre><span></span><code><span class="n">Context</span><span class="o">:</span><span class="w"> </span><span class="n">All</span><span class="w"> </span><span class="n">people</span><span class="w"> </span><span class="n">who</span><span class="w"> </span><span class="n">regularly</span><span class="w"> </span><span class="n">drink</span><span class="w"> </span><span class="n">coffee</span><span class="w"> </span><span class="n">are</span>
<span class="n">dependent</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">caffeine</span><span class="o">.</span>
<span class="o">(..</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="n">here</span><span class="w"> </span><span class="o">...)</span>
<span class="n">If</span><span class="w"> </span><span class="n">Rina</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">person</span><span class="w"> </span><span class="n">dependent</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">caffeine</span><span class="w"> </span><span class="n">and</span>
<span class="n">a</span><span class="w"> </span><span class="n">student</span><span class="o">,</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">Rina</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">either</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">person</span><span class="w"> </span><span class="n">dependent</span>
<span class="n">on</span><span class="w"> </span><span class="n">caffeine</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">student</span><span class="o">,</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">neither</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">person</span>
<span class="n">dependent</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">caffeine</span><span class="w"> </span><span class="n">nor</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">student</span><span class="o">.</span>
</code></pre></div>

<p>Question: Based on the above information, is the following statement true, false, or uncertain? Rina is a person who jokes about being addicted to caffeine or unaware that caffeine is a drug.</p>
<h2>Options:</h2>
<p>A) True
B) False
C) Uncertain</p>
<p>The correct option is: A</p>
<h2>Chain-of-Thought Prompting</h2>
<p>Task Description: Given a problem statement as contexts, the task is to answer a logical reasoning question.</p>
<p>Context: The Blake McFall Company Building is a commercial warehouse listed on the National Register of Historic Places.
(.. more context here ...)
John works at the Emmet Building.
Question: Based on the above information, is the following statement true, false, or uncertain? The Blake McFall Company Building is located in Portland, Oregon.</p>
<h2>Options:</h2>
<p>A) True
B) False
C) Uncertain</p>
<p>Reasoning: The Blake McFall Company Building is another name for the Emmet Building.
(.. more reasoning here ...)
Therefore, the Blake McFall Company Building is located in Portland, Oregon.</p>
<p>The correct option is: A</p>
<h2>Logic-LM</h2>
<p>Task Description: Given a problem description and a question. The task is to parse the problem and the question into first-order logic formulas. The grammar of the first-order logic formula is defined as follows:</p>
<p>1) logical conjunction: expr1 $\wedge$ expr2
2) logical disjunction: expr1 $\vee$ expr2
3) logical exclusive disjunction: expr1 $\oplus$ expr2
4) logical negation: $\neg$ expr1
5) expr1 implies expr2: expr1 $\rightarrow$ expr2
6) expr1 if and only if expr2: expr1 $\leftrightarrow$ expr2
7) logical universal quantification: $V x$
8) logical existential quantification: $\exists x$</p>
<p>Output format: logic form : : : description
Context: All people who regularly drink coffee are dependent on caffeine.
(.. more context here ...)
If Rina is not a person dependent on caffeine and a student, then Rina is either a person dependent on caffeine and a student, or neither a person dependent on caffeine nor a student.</p>
<p>Question: Based on the above information, is the following statement true, false, or uncertain? Rina is either a person who jokes about being addicted to caffeine or is unaware that caffeine is a drug.</p>
<h2>Predicates:</h2>
<p>Dependent(x) : : : x is a person dependent on caffeine (.. more predicates here ...)
Student $(x)$ : : : x is a student</p>
<h2>Premises:</h2>
<p>Vx (Drinks(x) $\rightarrow$ Dependent(x)) : : : All people who regularly drink coffee are dependent on caffeine.
(.. more premises here ...)
Vx (Jokes(x) $\rightarrow \neg$ Unaware $(x)$ ) : : : No one who jokes about being addicted to caffeine is unaware that caffeine is a drug.</p>
<h2>Conclusion:</h2>
<p>Jokes(rina) $\oplus$ Unaware(rina) : : : Rina is either a person who jokes about being addicted to caffeine or is unaware that caffeine is a drug.</p>
<h2>C. 4 LogicalDeduction Prompts</h2>
<h2>Standard In-Context Learning</h2>
<div class="codehilite"><pre><span></span><code><span class="n">Context</span><span class="o">:</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">following</span><span class="w"> </span><span class="n">paragraphs</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="n">describe</span><span class="w"> </span><span class="n">a</span>
<span class="kd">set</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">seven</span><span class="w"> </span><span class="n">objects</span><span class="w"> </span><span class="n">arranged</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">fixed</span><span class="w"> </span><span class="n">order</span><span class="o">.</span>
<span class="o">(--</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="n">here</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">)</span>
<span class="n">Eve</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="n">below</span><span class="w"> </span><span class="n">Ada</span><span class="o">.</span><span class="w"> </span><span class="n">Rob</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="n">below</span><span class="w"> </span><span class="n">Joe</span><span class="o">.</span>
<span class="n">Question</span><span class="o">:</span><span class="w"> </span><span class="n">Which</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">following</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="kc">true</span><span class="o">?</span>
<span class="n">Options</span><span class="o">:</span>
<span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">Ana</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="n">third</span><span class="o">.</span>
<span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="n">Eve</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="n">third</span><span class="o">.</span>
<span class="n">C</span><span class="o">)</span><span class="w"> </span><span class="n">Ada</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="n">third</span><span class="o">.</span>
<span class="n">D</span><span class="o">)</span><span class="w"> </span><span class="n">Dan</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="n">third</span><span class="o">.</span>
<span class="n">E</span><span class="o">)</span><span class="w"> </span><span class="n">Rob</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="n">third</span><span class="o">.</span>
<span class="n">F</span><span class="o">)</span><span class="w"> </span><span class="n">Amy</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="n">third</span><span class="o">.</span>
<span class="n">G</span><span class="o">)</span><span class="w"> </span><span class="n">Joe</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="n">third</span><span class="o">.</span>
<span class="n">The</span><span class="w"> </span><span class="n">correct</span><span class="w"> </span><span class="n">option</span><span class="w"> </span><span class="k">is</span><span class="o">:</span><span class="w"> </span><span class="n">A</span>
</code></pre></div>

<h2>Chain-of-Thought Prompting</h2>
<p>Task Description: Given a problem statement as contexts, the task is to answer a logical reasoning question.</p>
<p>Context: The following paragraphs each describe a set of five objects arranged in a fixed order. (-- more context here - )
The raven is the third from the left.
Question: Which of the following is true?
Options:
A) The quail is the rightmost.
B) The owl is the rightmost.
C) The raven is the rightmost.
D) The falcon is the rightmost.
E) The robin is the rightmost.</p>
<p>Reasoning: The owl is the leftmost. This means owl is not the rightmost.
(-- more reasoning here - )
This means raven is also not the rightmost. So, the answer is: A) The quail is the rightmost.</p>
<p>The correct option is: A</p>
<h2>Logic-LM</h2>
<p>Task Description: You are given a problem description. The task is to parse the problem as a constraint satisfaction problem, defining the domain, variables, and contraints.</p>
<p>Context: The following paragraphs each describe a set of three objects arranged in a fixed order. (-- more context here - )
The minivan is newer than the convertible.
Question: Which of the following is true?</p>
<h2>Options:</h2>
<p>A) The station wagon is the second-newest.
B) The convertible is the second-newest.
C) The minivan is the second-newest.</p>
<h2>Domain:</h2>
<p>1: oldest
2: newest</p>
<h2>Variables:</h2>
<p>station\wagon [IN] [1, 2, 3]
convertible [IN] [1, 2, 3]
minivan [IN] [1, 2, 3]</p>
<h2>Constraints:</h2>
<p>station\wagon == 1 : : : The station wagon is the oldest.
minivan &gt; convertible : : : The minivan is newer than the convertible.
AllDifferentConstraint([station\wagon, convertible, minivan]) ::: All vehicles have different values.</p>
<p>Query:
A) station\wagon == 2 : : : The station wagon is the second-newest.
B) convertible == 2 : : : The convertible is the second-newest.
C) minivan == 2 : : : The minivan is the second-newest</p>
<h2>C. 5 AR-LSAT Prompts</h2>
<h2>Standard In-Context Learning</h2>
<div class="codehilite"><pre><span></span><code><span class="n">Context</span><span class="o">:</span><span class="w"> </span><span class="n">During</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">single</span><span class="w"> </span><span class="n">week</span><span class="o">,</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">Monday</span><span class="w"> </span><span class="n">through</span>
<span class="w">    </span><span class="n">Friday</span><span class="o">,</span><span class="w"> </span><span class="n">tours</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">conducted</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">company</span><span class="err">&#39;</span><span class="n">s</span>
<span class="w">    </span><span class="n">three</span><span class="w"> </span><span class="n">divisions</span><span class="o">:</span><span class="w"> </span><span class="n">Operations</span><span class="o">,</span><span class="w"> </span><span class="n">Production</span><span class="o">,</span><span class="w"> </span><span class="n">and</span>
<span class="w">    </span><span class="n">Sales</span><span class="o">.</span><span class="w"> </span><span class="n">Exactly</span><span class="w"> </span><span class="n">five</span><span class="w"> </span><span class="n">tours</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">conducted</span>
<span class="w">    </span><span class="n">that</span><span class="w"> </span><span class="n">week</span><span class="o">,</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="n">day</span><span class="o">.</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="n">here</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">If</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">Operations</span><span class="w"> </span><span class="n">division</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">toured</span><span class="w"> </span><span class="n">on</span>
<span class="w">        </span><span class="n">Thursday</span><span class="o">,</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">Production</span><span class="w"> </span><span class="n">division</span><span class="w"> </span><span class="k">is</span>
<span class="w">        </span><span class="n">toured</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">Friday</span><span class="o">.</span>
</code></pre></div>

<p>Question: Which one of the following CANNOT be true of the week's tour schedule?</p>
<h2>Options:</h2>
<p>A) The division that is toured on Monday is also toured on Tuesday.
B) The division that is toured on Monday is also toured on Friday.
C) The division that is toured on Tuesday is also toured on Thursday.
D) The division that is toured on Wednesday is also toured on Friday.
E) The division that is toured on Thursday is also toured on Friday.</p>
<p>The correct option is: C</p>
<h2>Chain-of-Thought Prompting</h2>
<div class="codehilite"><pre><span></span><code><span class="nv">Task</span><span class="w"> </span><span class="nv">Description</span>:<span class="w"> </span><span class="nv">Given</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">problem</span><span class="w"> </span><span class="nv">statement</span><span class="w"> </span><span class="nv">as</span>
<span class="nv">contexts</span>,<span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">task</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">answer</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">logical</span><span class="w"> </span><span class="nv">reasoning</span>
<span class="nv">question</span>.
<span class="nv">Context</span>:<span class="w"> </span><span class="nv">During</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">single</span><span class="w"> </span><span class="nv">week</span>,<span class="w"> </span><span class="nv">from</span><span class="w"> </span><span class="nv">Monday</span><span class="w"> </span><span class="nv">through</span>
<span class="w">    </span><span class="nv">Friday</span>,<span class="w"> </span><span class="nv">tours</span><span class="w"> </span><span class="nv">will</span><span class="w"> </span><span class="nv">be</span><span class="w"> </span><span class="nv">conducted</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">company</span><span class="err">&#39;s</span>
<span class="err">    three divisions: Operations, Production, and</span>
<span class="err">    Sales. Exactly five tours will be conducted</span>
<span class="err">    that week, one each day. ( more context here</span>
<span class="err">        : If the Operations division is toured on</span>
<span class="err">        Thursday, then the Production division is</span>
<span class="err">        toured on Friday.</span>
</code></pre></div>

<p>Question: Which one of the following CANNOT be true of the week's tour schedule?</p>
<h2>Options:</h2>
<p>A) The division that is toured on Monday is also toured on Tuesday.
B) The division that is toured on Monday is also toured on Friday.
C) The division that is toured on Tuesday is also toured on Thursday.
D) The division that is toured on Wednesday is also toured on Friday.
E) The division that is toured on Thursday is also toured on Friday.</p>
<p>Reasoning: Since Thursday and Friday already have tours planned, only Monday, Tuesday and Wednesday tours need to be determined.
( more reasoning here )
A different division is toured on Thursday.
Therefore, the final answer is C.
The correct option is: C</p>
<h2>Logic-LM</h2>
<p>Task Description: You are given a problem description. The task is to parse the problem as a constraint satisfaction problem, defining the domain, variables, and contraints.</p>
<div class="codehilite"><pre><span></span><code><span class="n">Context</span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">travel</span><span class="w"> </span><span class="n">magazine</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">hired</span><span class="w"> </span><span class="n">six</span><span class="w"> </span><span class="n">interns</span><span class="w"> </span><span class="o">-</span>
<span class="w">    </span><span class="n">Farber</span><span class="o">,</span><span class="w"> </span><span class="n">Gombarick</span><span class="o">,</span><span class="w"> </span><span class="n">Hall</span><span class="o">,</span><span class="w"> </span><span class="n">Jackson</span><span class="o">,</span><span class="w"> </span><span class="n">Kanze</span><span class="o">,</span><span class="w"> </span><span class="n">and</span>
<span class="w">    </span><span class="n">Lha</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">assist</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">covering</span><span class="w"> </span><span class="n">three</span><span class="w"> </span><span class="n">stories</span><span class="o">:</span>
<span class="w">    </span><span class="n">Romania</span><span class="o">,</span><span class="w"> </span><span class="n">Spain</span><span class="o">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">Tuscany</span><span class="o">.</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="n">here</span>
<span class="w">        </span><span class="o">)</span><span class="w"> </span><span class="n">Jackson</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">assigned</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">Tuscany</span><span class="o">.</span><span class="w"> </span><span class="n">Kanze</span><span class="w"> </span><span class="k">is</span>
<span class="w">        </span><span class="n">not</span><span class="w"> </span><span class="n">assigned</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">Spain</span><span class="o">.</span>
</code></pre></div>

<p>Question: Which one of the following interns CANNOT be assigned to Tuscany?</p>
<div class="codehilite"><pre><span></span><code>Options:
(A) Farber
(B) Gombarick
(C) Hall
(D) Kanze
(E) Lha
</code></pre></div>

<h2>Declarations:</h2>
<p>stories = EnumSort([Romania, Spain, Tuscany]) assistants = EnumSort([photographer, writer]) ( more declarations here
trained = Function([interns] -&gt; [assistants])</p>
<h2>Constraints:</h2>
<p>trained(Gombarick) == trained(Lha) : : : Gombarick and Lha will be trained in the same field trained(Farber) != trained(Kanze) : : : Farber and Kanze will be trained in different fields ( more contraints here
assigned(Jackson) == Tuscany : : : Jackson is assigned to Tuscany
assigned(Kanze) != Spain : : : Kanze is not assigned to Spain</p>
<h2>Options:</h2>
<p>is_unsat(assigned(farber) == Tuscany) : : : (A)
is_unsat(assigned(Gombarick) == Tuscany) : : : (B)
is_unsat(assigned(Hall) == Tuscany) : : : (C)
is_unsat(assigned(Kanze) == Tuscany) : : : (D)
is_unsat(assigned(Lha) == Tuscany) : : : (E)</p>
<h2>D Result Interpreter Implementation</h2>
<p>For PrOntoQA and ProofWriter, the Pyke logic programming engine returns the inferred value of the variable in the query or Unknown if the variable cannot be determined. For example, for the query ConductElectricity(Nail, $x$ ), Pyke may return $x=$ True. By comparing with the goal statement ConductElectricity(Nail, False), we can know that goal to be proved is False. For FOLIO, the FOL inference engine directly returns the veracity label of the goal as ENTAILMENT, CONTRADICTION, and CONTINGENT, which can be mapped to True, False, and Unknown, respectively. For LogicalDeduction, the solver returns all the possible value assignments in an array. We write rules to parse each option into the corresponding value and check it is in the generated array. For ARLSAT, we attempt to separately prove each option to find the correct answer.</p>
<h2>E Example Generations of LOGIC-LM</h2>
<h1>Example 1</h1>
<div class="codehilite"><pre><span></span><code><span class="n">Problem</span><span class="o">:</span><span class="w"> </span><span class="n">There</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">six</span><span class="w"> </span><span class="n">types</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">wild</span><span class="w"> </span><span class="n">turkeys</span><span class="o">:</span><span class="w"> </span><span class="n">Eastern</span><span class="w"> </span><span class="n">wild</span><span class="w"> </span><span class="n">turkey</span><span class="o">,</span><span class="w"> </span><span class="n">Osceola</span><span class="w"> </span><span class="n">wild</span><span class="w"> </span><span class="n">turkey</span><span class="o">,</span><span class="w"> </span><span class="n">Gould</span><span class="s1">&#39;s wild turkey, Merriam&#39;</span><span class="n">s</span><span class="w"> </span><span class="n">wild</span><span class="w"> </span><span class="n">turkey</span><span class="o">,</span><span class="w"> </span><span class="n">Rio</span><span class="w"> </span><span class="n">Grande</span>
<span class="n">wild</span><span class="w"> </span><span class="n">turkey</span><span class="o">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">Ocellated</span><span class="w"> </span><span class="n">wild</span><span class="w"> </span><span class="n">turkey</span><span class="o">.</span><span class="w"> </span><span class="n">Tom</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">Eastern</span><span class="w"> </span><span class="n">wild</span><span class="w"> </span><span class="n">turkey</span><span class="o">.</span><span class="w"> </span><span class="n">Tom</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">Osceola</span><span class="w"> </span><span class="n">wild</span><span class="w"> </span><span class="n">turkey</span><span class="o">.</span><span class="w"> </span><span class="n">Tom</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">also</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">Gould</span><span class="s1">&#39;s wild</span>
<span class="s1">turkey, or a Merriam&#39;</span><span class="n">s</span><span class="w"> </span><span class="n">wild</span><span class="w"> </span><span class="n">turkey</span><span class="o">,</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">Rio</span><span class="w"> </span><span class="n">Grande</span><span class="w"> </span><span class="n">wild</span><span class="w"> </span><span class="n">turkey</span><span class="o">.</span><span class="w"> </span><span class="n">Tom</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">wild</span><span class="w"> </span><span class="n">turkey</span><span class="o">.</span>
<span class="n">Question</span><span class="o">:</span><span class="w"> </span><span class="n">Based</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">above</span><span class="w"> </span><span class="n">information</span><span class="o">,</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">following</span><span class="w"> </span><span class="n">statement</span><span class="w"> </span><span class="kc">true</span><span class="o">,</span><span class="w"> </span><span class="kc">false</span><span class="o">,</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">uncertain</span><span class="o">?</span><span class="w"> </span><span class="n">Tom</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">Ocellated</span><span class="w"> </span><span class="n">wild</span><span class="w"> </span><span class="n">turkey</span><span class="o">.</span>
<span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">True</span>
<span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="n">False</span>
<span class="o">(</span><span class="n">C</span><span class="o">)</span><span class="w"> </span><span class="n">Uncertain</span>
<span class="n">Predicted</span><span class="w"> </span><span class="n">logic</span><span class="w"> </span><span class="n">programs</span><span class="o">:</span>
<span class="w">    </span><span class="n">Premises</span><span class="o">:</span>
<span class="w">    </span><span class="n">wildturkey</span><span class="o">(</span><span class="n">eastern</span><span class="o">)</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">wildturkey</span><span class="o">(</span><span class="n">osceola</span><span class="o">)</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">wildturkey</span><span class="o">(</span><span class="n">gauld</span><span class="o">)</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">wildturkey</span><span class="o">(</span><span class="n">merriams</span><span class="o">)</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">wildturkey</span><span class="o">(</span><span class="n">rio_grande</span><span class="o">)</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">wildturkey</span><span class="o">(</span><span class="n">ocellated</span><span class="o">)</span>
<span class="w">    </span><span class="o">~</span><span class="w"> </span><span class="n">Vx</span><span class="w"> </span><span class="o">(</span><span class="n">Wildturkey</span><span class="o">(</span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="n">OcellatedWildturkey</span><span class="o">(</span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">EasternWildturkey</span><span class="o">(</span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">OsceolaWildturkey</span><span class="o">(</span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">Gauldswildturkey</span><span class="o">(</span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">MerriamsWildturkey</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="w">    </span><span class="o">\</span><span class="w"> </span><span class="n">RisGrandsWildturkey</span><span class="o">(</span><span class="n">x</span><span class="o">)))</span>
<span class="w">    </span><span class="n">wildturkey</span><span class="o">(</span><span class="n">tom</span><span class="o">)</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">-</span><span class="n">EasternWildturkey</span><span class="o">(</span><span class="n">tom</span><span class="o">)</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">-</span><span class="n">OsceolaWildturkey</span><span class="o">(</span><span class="n">tom</span><span class="o">)</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">-</span><span class="n">Gauldswildturkey</span><span class="o">(</span><span class="n">tom</span><span class="o">)</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">-</span><span class="n">MerriamsWildturkey</span><span class="o">(</span><span class="n">tom</span><span class="o">)</span><span class="w"> </span><span class="n">A</span>
<span class="w">    </span><span class="o">-</span><span class="n">RioGrandsWildturkey</span><span class="o">(</span><span class="n">tom</span><span class="o">)</span>
<span class="w">    </span><span class="n">Conclusion</span><span class="o">:</span>
<span class="w">    </span><span class="n">OcellatedWildturkey</span><span class="o">(</span><span class="n">tom</span><span class="o">)</span>
<span class="n">Predicted</span><span class="w"> </span><span class="n">answer</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">C</span><span class="o">-</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">A</span>
</code></pre></div>

<h2>Example 2</h2>
<div class="codehilite"><pre><span></span><code><span class="n">Problem</span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">Japanese</span><span class="w"> </span><span class="n">game</span><span class="w"> </span><span class="n">company</span><span class="w"> </span><span class="n">created</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">game</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">Legend</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">Zelda</span><span class="o">.</span><span class="w"> </span><span class="n">All</span><span class="w"> </span><span class="n">games</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">Top</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">made</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">Japanese</span><span class="w"> </span><span class="n">game</span><span class="w"> </span><span class="n">companies</span><span class="o">.</span><span class="w"> </span><span class="n">If</span><span class="w"> </span><span class="n">a</span>
<span class="n">game</span><span class="w"> </span><span class="n">sells</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">than</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">million</span><span class="w"> </span><span class="n">copies</span><span class="o">,</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">selected</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">Top</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="n">list</span><span class="o">.</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">Legend</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">Zelda</span><span class="w"> </span><span class="n">sold</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">than</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">million</span><span class="w"> </span><span class="n">copies</span><span class="o">.</span>
<span class="n">Question</span><span class="o">:</span><span class="w"> </span><span class="n">Based</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">above</span><span class="w"> </span><span class="n">information</span><span class="o">,</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">following</span><span class="w"> </span><span class="n">statement</span><span class="w"> </span><span class="kc">true</span><span class="o">,</span><span class="w"> </span><span class="kc">false</span><span class="o">,</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">uncertain</span><span class="o">?</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">Legend</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">Zelda</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">Top</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="n">list</span><span class="o">.</span>
<span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">True</span>
<span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="n">False</span>
<span class="o">(</span><span class="n">C</span><span class="o">)</span><span class="w"> </span><span class="n">Uncertain</span>
<span class="n">Predicted</span><span class="w"> </span><span class="n">logic</span><span class="w"> </span><span class="n">programs</span><span class="o">:</span>
<span class="w">    </span><span class="n">Premises</span><span class="o">:</span>
<span class="w">    </span><span class="n">JapaneseGameCompany</span><span class="o">(</span><span class="n">legend_of_zelda</span><span class="o">)</span>
<span class="w">    </span><span class="n">Vx</span><span class="w"> </span><span class="o">(</span><span class="n">Top10List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JapaneseGameCompany</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
<span class="w">    </span><span class="n">Vx</span><span class="w"> </span><span class="o">(</span><span class="n">SellMoreThanOneMillionCopies</span><span class="o">(</span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Top10List</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
<span class="w">    </span><span class="n">SellMoreThanOneMillionCopies</span><span class="o">(</span><span class="n">legend_of_zelda</span><span class="o">)</span>
<span class="w">    </span><span class="n">Conclusion</span><span class="o">:</span>
<span class="w">    </span><span class="n">Top10List</span><span class="o">(</span><span class="n">legend_of_zelda</span><span class="o">)</span>
<span class="n">Predicted</span><span class="w"> </span><span class="n">answer</span><span class="o">:</span><span class="w"> </span><span class="n">A</span>
</code></pre></div>

<h2>Example 3</h2>
<div class="codehilite"><pre><span></span><code><span class="n">Problem</span><span class="o">:</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">following</span><span class="w"> </span><span class="n">paragraphs</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="n">describe</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kd">set</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">five</span><span class="w"> </span><span class="n">objects</span><span class="w"> </span><span class="n">arranged</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">fixed</span><span class="w"> </span><span class="n">order</span><span class="o">.</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">statements</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">logically</span><span class="w"> </span><span class="n">consistent</span><span class="w"> </span><span class="n">within</span>
<span class="k">each</span><span class="w"> </span><span class="n">paragraph</span><span class="o">.</span><span class="w"> </span><span class="n">In</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">golf</span><span class="w"> </span><span class="n">tournament</span><span class="o">,</span><span class="w"> </span><span class="n">there</span><span class="w"> </span><span class="n">were</span><span class="w"> </span><span class="n">five</span><span class="w"> </span><span class="n">golfers</span><span class="o">:</span><span class="w"> </span><span class="n">Rob</span><span class="o">,</span><span class="w"> </span><span class="n">Eve</span><span class="o">,</span><span class="w"> </span><span class="n">Eli</span><span class="o">,</span><span class="w"> </span><span class="n">Amy</span><span class="o">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">Dan</span><span class="o">.</span><span class="w"> </span><span class="n">Dan</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="n">second</span><span class="o">.</span><span class="w"> </span><span class="n">Amy</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="n">below</span><span class="w"> </span><span class="n">Eve</span><span class="o">.</span><span class="w"> </span><span class="n">Dan</span>
<span class="n">finished</span><span class="w"> </span><span class="n">above</span><span class="w"> </span><span class="n">Eve</span><span class="o">.</span><span class="w"> </span><span class="n">Amy</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="n">above</span><span class="w"> </span><span class="n">Eli</span><span class="o">.</span>
<span class="n">Question</span><span class="o">:</span><span class="w"> </span><span class="n">Which</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">following</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="kc">true</span><span class="o">?</span>
<span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">Rob</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="n">third</span>
<span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="n">Eve</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="n">third</span>
<span class="o">(</span><span class="n">C</span><span class="o">)</span><span class="w"> </span><span class="n">Eli</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="n">third</span>
<span class="o">(</span><span class="n">D</span><span class="o">)</span><span class="w"> </span><span class="n">Amy</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="n">third</span>
<span class="o">(</span><span class="n">E</span><span class="o">)</span><span class="w"> </span><span class="n">Dan</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="n">third</span>
<span class="n">Predicted</span><span class="w"> </span><span class="n">logic</span><span class="w"> </span><span class="n">programs</span><span class="o">:</span>
<span class="w">    </span><span class="n">Domain</span><span class="o">:</span>
<span class="w">    </span><span class="mi">1</span><span class="o">:</span><span class="w"> </span><span class="n">first</span>
<span class="w">    </span><span class="mi">5</span><span class="o">:</span><span class="w"> </span><span class="n">last</span>
<span class="w">    </span><span class="mi">1</span><span class="o">:</span><span class="w"> </span><span class="n">first</span>
<span class="w">    </span><span class="mi">5</span><span class="o">:</span><span class="w"> </span><span class="n">last</span>
<span class="w">    </span><span class="n">Variable</span>
<span class="w">    </span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">Rob</span><span class="w"> </span><span class="err">↔</span><span class="w"> </span><span class="mi">3</span>
<span class="w">    </span><span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="n">Eve</span><span class="w"> </span><span class="err">↔</span><span class="w"> </span><span class="mi">3</span>
<span class="w">    </span><span class="o">(</span><span class="n">C</span><span class="o">)</span><span class="w"> </span><span class="n">Eli</span><span class="w"> </span><span class="err">↔</span><span class="w"> </span><span class="mi">3</span>
<span class="w">    </span><span class="o">(</span><span class="n">D</span><span class="o">)</span><span class="w"> </span><span class="n">Amy</span><span class="w"> </span><span class="err">↔</span><span class="w"> </span><span class="mi">3</span>
<span class="w">    </span><span class="o">(</span><span class="n">E</span><span class="o">)</span><span class="w"> </span><span class="n">Dan</span><span class="w"> </span><span class="err">↔</span><span class="w"> </span><span class="mi">3</span>
</code></pre></div>

<p><img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<h2>Example 4</h2>
<div class="codehilite"><pre><span></span><code><span class="n">Problem</span><span class="o">:</span><span class="w"> </span><span class="n">If</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">restaurant</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">listed</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">Velp</span><span class="s1">&#39;s recommendations, then the restaurant does not receive many negative reviews. All restaurants with</span>
<span class="s1">a rating greater than 0 are listed in Velp&#39;</span><span class="n">s</span><span class="w"> </span><span class="n">recommendations</span><span class="o">.</span><span class="w"> </span><span class="n">Some</span><span class="w"> </span><span class="n">restaurants</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">provide</span><span class="w"> </span><span class="n">take</span><span class="o">-</span><span class="n">out</span><span class="w"> </span><span class="n">service</span><span class="w"> </span><span class="n">receive</span><span class="w"> </span><span class="n">many</span><span class="w"> </span><span class="n">negative</span>
<span class="n">reviews</span><span class="o">.</span><span class="w"> </span><span class="n">All</span><span class="w"> </span><span class="n">restaurants</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">popular</span><span class="w"> </span><span class="n">among</span><span class="w"> </span><span class="n">local</span><span class="w"> </span><span class="n">residents</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">ratings</span><span class="w"> </span><span class="n">greater</span><span class="w"> </span><span class="n">than</span><span class="w"> </span><span class="mi">0</span><span class="o">.</span><span class="w"> </span><span class="n">Subway</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">rating</span><span class="w"> </span><span class="n">greater</span><span class="w"> </span><span class="n">than</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">popular</span>
<span class="n">among</span><span class="w"> </span><span class="n">local</span><span class="w"> </span><span class="n">residents</span><span class="o">.</span>
<span class="n">Question</span><span class="o">:</span><span class="w"> </span><span class="n">Based</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">above</span><span class="w"> </span><span class="n">information</span><span class="o">,</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">following</span><span class="w"> </span><span class="n">statement</span><span class="w"> </span><span class="kc">true</span><span class="o">,</span><span class="w"> </span><span class="kc">false</span><span class="o">,</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">uncertain</span><span class="o">?</span><span class="w"> </span><span class="n">Subway</span><span class="w"> </span><span class="n">provides</span><span class="w"> </span><span class="n">take</span><span class="o">-</span><span class="n">out</span><span class="w"> </span><span class="n">service</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">does</span><span class="w"> </span><span class="n">not</span>
<span class="n">receive</span><span class="w"> </span><span class="n">many</span><span class="w"> </span><span class="n">negative</span><span class="w"> </span><span class="n">reviews</span><span class="o">.</span>
<span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">True</span>
<span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="n">False</span>
<span class="o">(</span><span class="n">C</span><span class="o">)</span><span class="w"> </span><span class="n">Uncertain</span>
<span class="n">Predicted</span><span class="w"> </span><span class="n">logic</span><span class="w"> </span><span class="n">programs</span><span class="o">:</span>
<span class="w">    </span><span class="n">Premises</span><span class="o">:</span>
<span class="w">    </span><span class="n">Vx</span><span class="w"> </span><span class="o">(</span><span class="n">Listed</span><span class="o">(</span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">NegativeReviews</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
<span class="w">    </span><span class="n">Vx</span><span class="w"> </span><span class="o">(</span><span class="n">Rating</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">y</span><span class="o">)</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Listed</span><span class="o">(</span><span class="n">x</span><span class="o">))</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">Vx</span><span class="w"> </span><span class="o">(</span><span class="n">GreaterThanNine</span><span class="o">(</span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Listed</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
<span class="w">    </span><span class="n">Dx</span><span class="w"> </span><span class="o">(-</span><span class="n">TakeOut</span><span class="o">(</span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">NegativeReviews</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
<span class="w">    </span><span class="n">Vx</span><span class="w"> </span><span class="o">(</span><span class="n">Popular</span><span class="o">(</span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="n">Rating</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">y</span><span class="o">)</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="o">))</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">Vx</span><span class="w"> </span><span class="o">(</span><span class="n">Popular</span><span class="o">(</span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GreaterThanNine</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
<span class="w">    </span><span class="n">Rating</span><span class="o">(</span><span class="n">subway</span><span class="o">,</span><span class="w"> </span><span class="n">y</span><span class="o">)</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Popular</span><span class="o">(</span><span class="n">subway</span><span class="o">)</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">GreaterThanNine</span><span class="o">(</span><span class="n">subway</span><span class="o">)</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">Popular</span><span class="o">(</span><span class="n">subway</span><span class="o">)</span>
<span class="w">    </span><span class="n">Conclusion</span><span class="o">:</span>
<span class="w">    </span><span class="n">TakeOut</span><span class="o">(</span><span class="n">subway</span><span class="o">)</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">-</span><span class="n">NegativeReviews</span><span class="o">(</span><span class="n">subway</span><span class="o">)</span>
<span class="n">Predicted</span><span class="w"> </span><span class="n">answer</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">C</span><span class="o">-</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">A</span>
</code></pre></div>

<p>Figure 6: Examples of generated symbolic representations and predicted answers. The incorrect segment(s) and their correspondence in the problem are marked in red, and the correct revisions are marked in green.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{2}$ https://www.cs.unm.edu/ mccune/prover9/
${ }^{3}$ https://github.com/python-constraint/
python-constraint
${ }^{4}$ https://github.com/Z3Prover/z3&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>