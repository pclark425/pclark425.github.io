<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-8932 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-8932</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-8932</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-157.html">extraction-schema-157</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing self-reflection or iterative answer improvement (e.g., generate-then-reflect, self-critique, reflexion), including descriptions of the methods, tasks, performance results, mechanisms, and any reported limitations or failure cases.</div>
                <p><strong>Paper ID:</strong> paper-5a5a1d666e4b7b933bc5aafbbadf179bc447ee67</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/5a5a1d666e4b7b933bc5aafbbadf179bc447ee67" target="_blank">AI safety via debate</a></p>
                <p><strong>Paper Venue:</strong> arXiv.org</p>
                <p><strong>Paper TL;DR:</strong> This work proposes training agents via self play on a zero sum debate game, focusing on potential weaknesses as the model scales up, and proposes future human and computer experiments to test these properties.</p>
                <p><strong>Paper Abstract:</strong> To make AI systems broadly useful for challenging real-world tasks, we need them to learn complex human goals and preferences. One approach to specifying complex goals asks humans to judge during training which agent behaviors are safe and useful, but this approach can fail if the task is too complicated for a human to directly judge. To help address this concern, we propose training agents via self play on a zero sum debate game. Given a question or proposed action, two agents take turns making short statements up to a limit, then a human judges which of the agents gave the most true, useful information. In an analogy to complexity theory, debate with optimal play can answer any question in PSPACE given polynomial time judges (direct judging answers only NP questions). In practice, whether debate works involves empirical questions about humans and the tasks we want AIs to perform, plus theoretical questions about the meaning of AI alignment. We report results on an initial MNIST experiment where agents compete to convince a sparse classifier, boosting the classifier's accuracy from 59.4% to 88.9% given 6 pixels and from 48.2% to 85.2% given 4 pixels. Finally, we discuss theoretical and practical aspects of the debate model, focusing on potential weaknesses as the model scales up, and we propose future human and computer experiments to test these properties.</p>
                <p><strong>Cost:</strong> 0.014</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e8932.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e8932.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing self-reflection or iterative answer improvement (e.g., generate-then-reflect, self-critique, reflexion), including descriptions of the methods, tasks, performance results, mechanisms, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Debate</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Adversarial Debate (self-play alternating statements judged by human or proxy)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A self-play protocol where two agents alternate making short statements to convince a human (or a learned proxy) judge; the adversarial structure is used to surface flaws in claims and iteratively improve/defend answers.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Debate agents (unspecified ML agents; MNIST uses MCTS-based agents + CNN judge)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>No specific large language model is named; in the MNIST experiment agents are not language models but search-based players (MCTS) with a fixed convolutional-network judge trained to classify sparse pixels. The general proposal targets powerful language-capable agents trained by self-play.</td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_name</strong></td>
                            <td>Adversarial iterative debate / self-play reflection</td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_description</strong></td>
                            <td>Two agents alternate making statements (or revealing small parts of inputs/answers); the judge selects which agent gave the more true/useful information. Agents aim to point out flaws in the other's claims, producing iterative refinement of the judged answer (can be seen as generate-then-reflect via adversarial counterarguments).</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>MNIST sparse-pixel classification (debate experiment)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Agents see a full MNIST image; judge only sees a sparse mask of revealed pixels (4 or 6 nonzero pixels). Agents precommit to a claimed label and alternately reveal pixels; the judge (a CNN trained on sparse masks) chooses the winner based on logits for the claimed classes.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_reflection</strong></td>
                            <td>With debate (precommit) the judge+debate accuracy on MNIST test set rose to 88.9% (6-pixel setting) and 85.2% (4-pixel setting).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_reflection</strong></td>
                            <td>Judge alone (classification from random sparse pixels) accuracies: 59.4% (6 pixels) and 48.2% (4 pixels).</td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_comparison</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_of_reflection</strong></td>
                            <td>Self-play adversarial protocol judged by human or learned proxy; for MNIST: judge is a pretrained convolutional network on sparse masks, agents use Monte Carlo Tree Search (10k rollouts per move) to choose revealed pixels and moves; the adversary exposes counterexamples to force refinement.</td>
                        </tr>
                        <tr>
                            <td><strong>number_of_iterations</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_improvement</strong></td>
                            <td>Quantitative MNIST experiment: debate (with precommit) turned a 59.4% (6-pixel) judge into an 88.9% debate outcome and a 48.2% (4-pixel) judge into an 85.2% debate outcome, showing iterative adversarial revealing markedly improves judged correctness.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Reported limitations include: dependence on judge quality and human belief bias (humans may not be convinced by correct counterarguments); liar advantage if precommitment is not enforced (liar performs much better without precommit); failures on stochastic simulations (protocol only cleanly handles deterministic simulations unless random seed fixed); requirement that revealed context cannot be lied about; vulnerability to mind-hacking or code attacks via long textual debates; potential instability during training (cycles where agents forget how to refute lies); limited scalability if humans cannot follow debates or if branching factor is too large.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_methods</strong></td>
                            <td>Compared and contrasted with amplification: debate is adversarial self-play (two agents) whereas amplification recursively decomposes and reconstructs answers via a human plus modules; debate can simulate high-branching checks adversarially, and empirical MNIST shows practical iterative improvement; no direct comparison to chain-of-thought or other LM-only self-reflection methods is reported.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_study_results</strong></td>
                            <td>An ablation-like comparison: precommit vs no-precommit. Precommit sharply reduces liar success: with precommit honest-win rates much higher (e.g., final judge accuracy with precommit 88.9% vs liar-dominated outcomes without precommit). The paper reports honest vs liar outcomes under both conditions, showing precommit is a crucial constraint.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'AI safety via debate', 'publication_date_yy_mm': '2018-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8932.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e8932.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing self-reflection or iterative answer improvement (e.g., generate-then-reflect, self-critique, reflexion), including descriptions of the methods, tasks, performance results, mechanisms, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Amplification</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Amplification (Answerer / Questioner / Checker recursive decomposition)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A recursive supervision paradigm where a human decomposes hard questions into subquestions; an Answerer model is called on subquestions, a human (or trained checker) recombines answers to obtain supervision for the original question, enabling iterative improvement.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Amplification framework (Answerer / Questioner / Checker modules; no single LM specified here)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Framework (Christiano et al., referenced) that trains an Answerer by having a human decompose questions into subquestions (Questioner) and using a Checker to recombine; typically formulated with supervised training of these modules.</td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_name</strong></td>
                            <td>Recursive decomposition / amplification</td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_description</strong></td>
                            <td>Iteratively improves answers by decomposing a hard question into subquestions, calling the model on subquestions, and having a human or trained checker recombine subanswers to form a final answer; the process can be nested, producing recursive iterative improvement.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>General hard question answering (conceptual; no specific benchmark reported in this paper)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Any question beyond human direct ability where decomposition into subquestions plus recombination yields a correct answer; amplification is described as a method rather than evaluated on a concrete benchmark here.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_reflection</strong></td>
                            <td>No empirical numeric performance reported in this paper for amplification (discussion is conceptual and comparative).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_reflection</strong></td>
                            <td>Not reported.</td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_comparison</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_of_reflection</strong></td>
                            <td>Human-guided recursive decomposition into subquestions, supervised training of Answerer/Questioner/Checker modules; reflection arises via recursion over subquestions and recombination by the human or checker.</td>
                        </tr>
                        <tr>
                            <td><strong>number_of_iterations</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_improvement</strong></td>
                            <td>The paper argues theoretical equivalence (both debate and amplification can reach PSPACE in idealized limits) and discusses conceptual strengths/weaknesses, but gives no empirical amplification results in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Amplification depends on the ability to generate useful subquestions (a human questioner may be required); it may struggle when the branching factor of relevant subquestions is too high, and the human questioner requirement is a bottleneck (though adversarial Questioner training could mitigate this).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_methods</strong></td>
                            <td>Paper gives an approximate equivalence/contrast between debate and amplification: debate uses adversarial self-play (two agents) while amplification relies on recursive human-guided decomposition; debate can handle high branching factor without human questioner but amplification can be safer when reliable questioners exist. No empirical head-to-head numbers are provided.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_study_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'AI safety via debate', 'publication_date_yy_mm': '2018-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Deep Reinforcement Learning from Human Preferences <em>(Rating: 2)</em></li>
                <li>Mastering the game of Go without human knowledge <em>(Rating: 2)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-8932",
    "paper_id": "paper-5a5a1d666e4b7b933bc5aafbbadf179bc447ee67",
    "extraction_schema_id": "extraction-schema-157",
    "extracted_data": [
        {
            "name_short": "Debate",
            "name_full": "Adversarial Debate (self-play alternating statements judged by human or proxy)",
            "brief_description": "A self-play protocol where two agents alternate making short statements to convince a human (or a learned proxy) judge; the adversarial structure is used to surface flaws in claims and iteratively improve/defend answers.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "Debate agents (unspecified ML agents; MNIST uses MCTS-based agents + CNN judge)",
            "model_description": "No specific large language model is named; in the MNIST experiment agents are not language models but search-based players (MCTS) with a fixed convolutional-network judge trained to classify sparse pixels. The general proposal targets powerful language-capable agents trained by self-play.",
            "reflection_method_name": "Adversarial iterative debate / self-play reflection",
            "reflection_method_description": "Two agents alternate making statements (or revealing small parts of inputs/answers); the judge selects which agent gave the more true/useful information. Agents aim to point out flaws in the other's claims, producing iterative refinement of the judged answer (can be seen as generate-then-reflect via adversarial counterarguments).",
            "task_name": "MNIST sparse-pixel classification (debate experiment)",
            "task_description": "Agents see a full MNIST image; judge only sees a sparse mask of revealed pixels (4 or 6 nonzero pixels). Agents precommit to a claimed label and alternately reveal pixels; the judge (a CNN trained on sparse masks) chooses the winner based on logits for the claimed classes.",
            "performance_with_reflection": "With debate (precommit) the judge+debate accuracy on MNIST test set rose to 88.9% (6-pixel setting) and 85.2% (4-pixel setting).",
            "performance_without_reflection": "Judge alone (classification from random sparse pixels) accuracies: 59.4% (6 pixels) and 48.2% (4 pixels).",
            "has_performance_comparison": true,
            "mechanism_of_reflection": "Self-play adversarial protocol judged by human or learned proxy; for MNIST: judge is a pretrained convolutional network on sparse masks, agents use Monte Carlo Tree Search (10k rollouts per move) to choose revealed pixels and moves; the adversary exposes counterexamples to force refinement.",
            "number_of_iterations": null,
            "evidence_for_improvement": "Quantitative MNIST experiment: debate (with precommit) turned a 59.4% (6-pixel) judge into an 88.9% debate outcome and a 48.2% (4-pixel) judge into an 85.2% debate outcome, showing iterative adversarial revealing markedly improves judged correctness.",
            "limitations_or_failure_cases": "Reported limitations include: dependence on judge quality and human belief bias (humans may not be convinced by correct counterarguments); liar advantage if precommitment is not enforced (liar performs much better without precommit); failures on stochastic simulations (protocol only cleanly handles deterministic simulations unless random seed fixed); requirement that revealed context cannot be lied about; vulnerability to mind-hacking or code attacks via long textual debates; potential instability during training (cycles where agents forget how to refute lies); limited scalability if humans cannot follow debates or if branching factor is too large.",
            "comparison_to_other_methods": "Compared and contrasted with amplification: debate is adversarial self-play (two agents) whereas amplification recursively decomposes and reconstructs answers via a human plus modules; debate can simulate high-branching checks adversarially, and empirical MNIST shows practical iterative improvement; no direct comparison to chain-of-thought or other LM-only self-reflection methods is reported.",
            "ablation_study_results": "An ablation-like comparison: precommit vs no-precommit. Precommit sharply reduces liar success: with precommit honest-win rates much higher (e.g., final judge accuracy with precommit 88.9% vs liar-dominated outcomes without precommit). The paper reports honest vs liar outcomes under both conditions, showing precommit is a crucial constraint.",
            "uuid": "e8932.0",
            "source_info": {
                "paper_title": "AI safety via debate",
                "publication_date_yy_mm": "2018-05"
            }
        },
        {
            "name_short": "Amplification",
            "name_full": "Amplification (Answerer / Questioner / Checker recursive decomposition)",
            "brief_description": "A recursive supervision paradigm where a human decomposes hard questions into subquestions; an Answerer model is called on subquestions, a human (or trained checker) recombines answers to obtain supervision for the original question, enabling iterative improvement.",
            "citation_title": "",
            "mention_or_use": "mention",
            "model_name": "Amplification framework (Answerer / Questioner / Checker modules; no single LM specified here)",
            "model_description": "Framework (Christiano et al., referenced) that trains an Answerer by having a human decompose questions into subquestions (Questioner) and using a Checker to recombine; typically formulated with supervised training of these modules.",
            "reflection_method_name": "Recursive decomposition / amplification",
            "reflection_method_description": "Iteratively improves answers by decomposing a hard question into subquestions, calling the model on subquestions, and having a human or trained checker recombine subanswers to form a final answer; the process can be nested, producing recursive iterative improvement.",
            "task_name": "General hard question answering (conceptual; no specific benchmark reported in this paper)",
            "task_description": "Any question beyond human direct ability where decomposition into subquestions plus recombination yields a correct answer; amplification is described as a method rather than evaluated on a concrete benchmark here.",
            "performance_with_reflection": "No empirical numeric performance reported in this paper for amplification (discussion is conceptual and comparative).",
            "performance_without_reflection": "Not reported.",
            "has_performance_comparison": false,
            "mechanism_of_reflection": "Human-guided recursive decomposition into subquestions, supervised training of Answerer/Questioner/Checker modules; reflection arises via recursion over subquestions and recombination by the human or checker.",
            "number_of_iterations": null,
            "evidence_for_improvement": "The paper argues theoretical equivalence (both debate and amplification can reach PSPACE in idealized limits) and discusses conceptual strengths/weaknesses, but gives no empirical amplification results in this paper.",
            "limitations_or_failure_cases": "Amplification depends on the ability to generate useful subquestions (a human questioner may be required); it may struggle when the branching factor of relevant subquestions is too high, and the human questioner requirement is a bottleneck (though adversarial Questioner training could mitigate this).",
            "comparison_to_other_methods": "Paper gives an approximate equivalence/contrast between debate and amplification: debate uses adversarial self-play (two agents) while amplification relies on recursive human-guided decomposition; debate can handle high branching factor without human questioner but amplification can be safer when reliable questioners exist. No empirical head-to-head numbers are provided.",
            "ablation_study_results": null,
            "uuid": "e8932.1",
            "source_info": {
                "paper_title": "AI safety via debate",
                "publication_date_yy_mm": "2018-05"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Deep Reinforcement Learning from Human Preferences",
            "rating": 2
        },
        {
            "paper_title": "Mastering the game of Go without human knowledge",
            "rating": 2
        }
    ],
    "cost": 0.01354,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>AI safety via debate</h1>
<p>Geoffrey Irving* Paul Christiano Dario Amodei<br>OpenAI</p>
<h4>Abstract</h4>
<p>To make AI systems broadly useful for challenging real-world tasks, we need them to learn complex human goals and preferences. One approach to specifying complex goals asks humans to judge during training which agent behaviors are safe and useful, but this approach can fail if the task is too complicated for a human to directly judge. To help address this concern, we propose training agents via self play on a zero sum debate game. Given a question or proposed action, two agents take turns making short statements up to a limit, then a human judges which of the agents gave the most true, useful information. In an analogy to complexity theory, debate with optimal play can answer any question in PSPACE given polynomial time judges (direct judging answers only NP questions). In practice, whether debate works involves empirical questions about humans and the tasks we want AIs to perform, plus theoretical questions about the meaning of AI alignment. We report results on an initial MNIST experiment where agents compete to convince a sparse classifier, boosting the classifier's accuracy from $59.4 \%$ to $88.9 \%$ given 6 pixels and from $48.2 \%$ to $85.2 \%$ given 4 pixels. Finally, we discuss theoretical and practical aspects of the debate model, focusing on potential weaknesses as the model scales up, and we propose future human and computer experiments to test these properties.</p>
<h2>1 Introduction</h2>
<p>Learning to align an agent's actions with the values and preferences of humans is a key challenge in ensuring that advanced AI systems remain safe [Russell et al., 2016]. Subtle problems in alignment can lead to unexpected and potentially unsafe behavior [Amodei et al., 2016], and we expect this problem to get worse as systems become more capable. Alignment is a training-time problem: it is difficult to retroactively fix the behavior and incentives of trained unaligned agents. Alignment likely requires interaction with humans during training, but care is required in choosing the precise form of the interaction as supervising the agent may itself be a challenging cognitive task.</p>
<p>For some tasks it is harder to bring behavior in line with human goals than for others. In simple cases, humans can directly demonstrate the behavior-this is the case of supervised learning or imitation learning, for example classifying an image or using a robotic gripper to pick up a block. For these tasks alignment with human preferences can in principle be achieved by imitating the human, and is implicit in existing ML approaches (although issues of bias in the training data still arise, see e.g. Mitchell and Shadlen [2018]). Taking a step up in alignment difficulty, some tasks are too difficult for a human to perform, but a human can still judge the quality of behavior or answers once shown to them-for example a robot doing a backflip in an unnatural action space. This is the case of human preference-based reinforcement learning [Christiano et al., 2017]. We can make</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>an analogy between these two levels and the complexity classes P and NP: answers that can be computed easily and answers that can be checked easily.</p>
<p>Just as there are problems harder than P or NP in complexity theory, lining up behavior with human preferences can be harder still. A human may be unable to judge whether an explained answer or exhibited behavior is correct: the behavior may be too hard to understand without help, or the answer to a question may have a flaw that is too subtle for the human to detect. We could imagine a system trained to both give answers and point out flaws in answers; this gives a third level of difficulty. Flaws themselves may be too hard to judge: flaws could have their own flaws that must be pointed out to a human. And flaws of flaws can have flaws, etc.</p>
<p>This hierarchy of alignment tasks has a natural limit: a debate between competing agents where agents make arguments, other agents poke holes in those arguments, and so on until we have enough information to decide the truth. The simplest version of debate has two competing agents, though we cover versions with more agents as well. Our hypothesis is that optimal play in this game produces honest, aligned information far beyond the capabilities of the human judge. We can approximate optimal play by training ML systems via self play, which has shown impressive performance in games such as Go, chess, shogi, and Dota 2 [Silver et al., 2016, 2017a,b, OpenAI, 2017].</p>
<p>The goal of this paper is to lay out theoretical and practical properties of debate as an approach to AI alignment. We also lay out plans for experiments to test the properties of debate, but we leave these to future work except for a simple MNIST example. On the theoretical side, we observe that the complexity class analog of debate can answer any question in PSPACE using only polynomial time judges, corresponding to aligned agents exponentially smarter than the judge. Whether debate works with humans and ML is more subtle, and requires extensive testing and analysis before the model can be trusted. Debate is closely related to the amplification approach to AI alignment [Christiano et al., 2018], and we explore this relationship in detail.</p>
<p>Our eventual goal is natural language debate, where the human judges a dialog between the agents. However, unrestricted dialog models remain far from human performance and even evaluation is difficult [Lowe et al., 2017a], so it is instructive to consider debates with non-natural language statements. Consider the board game Go. Given a board configuration, we can ask "What is the best move?" If AlphaZero [Silver et al., 2017b] shows us a move, there is no way to judge its quality unless we are roughly as strong as AlphaZero. However, we can ask another copy of AlphaZero to show us a countermove, then a countermove to that countermove, and so on until the game ends. Even a novice player can judge this debate: the side with the higher score wins. Indeed, we can view AlphaZero as our debate model with human judge replaced with rules of Go, which gives us confidence that the model can achieve superhuman performance.</p>
<p>The layout of this paper is as follows. Section 2 introduces the debate model of alignment and provides intuitive and theoretical background for why it is useful. Section 3 proposes initial experiments to test human and ML aspects of debate, using image tasks to avoid the complexities of natural language. We present results for an example experiment on MNIST, but we leave the majority of experiments to future work. The remaining sections provide additional thought experiments and analysis: Section 4 and Section 5 discuss reasons for optimism and pessimism about debate as a model for AI alignment, Section 6 presents variants of debate to reduce asymmetry or incorporate multiple agents, and Section 7 relates debate to the amplification approach to AI alignment and describes how the two models can be hybridized. Section 8 closes with requests for future work.</p>
<h1>2 The debate game</h1>
<p>We will initially consider a question-answering setting, though Section 2.3 covers other settings including environment interaction. We have a set of questions $Q$, answers $A$, and debate statements $S$. The simplest version of debate has two agents competing to convince a human judge:</p>
<ol>
<li>A question $q \in Q$ is shown to both agents.</li>
<li>The two agents state their answers $a_{0}, a_{1} \in A$ (which may be the same).</li>
<li>The two agents take turns making statements $s_{0}, s_{1}, \ldots, s_{n-1} \in S$.</li>
<li>The judge sees the debate $(q, a, s)$ and decides which agent wins.</li>
<li>The game is zero sum: each agent maximizes their probability of winning.</li>
</ol>
<p>To play this game with a human, we need instructions for how the human should decide who wins. These instructions are in natural language, such as "The winner is the agent who said the most useful true thing." For question-answering $a \in A$ and $s \in S$ could be any moderate length sentence, and $q \in Q$ a sentence plus additional context. For example, $q \in Q$ could be "Should we interview Eve?" given a resume and links to past work. At test time it suffices to stop after step 2: we do not need to run the debate (though agents could simulate debates at test time to strengthen answers).</p>
<p>The utility of debate as an approach for AI alignment rests on the following central claim:
Claim. In the debate game, it is harder to lie than to refute a lie.
Whether this claim is true for any particular setting is empirical, though we give some evidence for it below. If the central claim is true, we can hope for a few other claims:</p>
<ul>
<li>In all Nash equilibria ${ }^{1}$ of this game, both agents try to tell the truth in the most convincing manner possible, trying to uncover details or counterarguments the other agent missed.</li>
<li>It is possible to find approximate Nash equilibria with some version of gradient descent, such as a self play algorithm similar to Silver et al. [2017b]. In particular, training is stable around the Nash equilibria (unstable training might mean agents learn to be honest, forget how to defend against dishonesty, and then get beaten by dishonest fluctuations).</li>
<li>At Nash equilibria, debate agents are approximately as strong as unrestricted AI (agents trained with no safety measures).</li>
</ul>
<p>We emphasize that using debate does not restrict the structure of the agents. Similarly, the deep networks used in Silver et al. [2017b] are convolutional residual networks unrelated to the game tree of Go, though the training process does involve the tree via MCTS. The lack of restriction is important, since we want safe approaches to be competitive with unsafe alternatives.</p>
<h3>2.1 Short debates are powerful</h3>
<p>Consider the question "Where should I go on vacation?" If one sees only the answer "Alaska", it is not obvious whether a better answer exists. Thus the opening answers in a debate about the vacation question between two agents Alice and Bob might be</p>
<ol>
<li>Alice: Alaska.</li>
<li>Bob: Bali.
<sup id="fnref5:0"><a class="footnote-ref" href="#fn:0">1</a></sup></li>
</ol>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: (a) Given a question, two debating agents alternate statements until a limit is reached, and a human judges who gave the most true, useful information. Although the reason for the correct answer may be the exponentially large tree of all possible debates, a single path chosen by strong agents provides evidence for the whole tree. (b) Analogously, although the best move in Go depends on the entire tree, a single game with strong players is evidence as to which moves were best.</p>
<p>If the human judge is able to rank pairs of vacation destinations, perfect play in a two round debate is sufficient to find the optimal destination. If Alice gives a suboptimal destination, Bob gives a better destination and wins, so Alice only wins by starting with the best destination. In this case Bali sounds warmer, so Bob wins. However, Bali has a hidden flaw:
3. Alice: Bali is out since your passport won't arrive in time.</p>
<p>Now the human understands they cannot go to Bali, so Alice wins, unless Bob has a counterargument to the flaw:
4. Bob: Expedited passport service only takes two weeks.</p>
<p>The process continues until we arrive at a statement that the human is able to correctly judge, in the sense that the other agent does not believe they can change the human's mind with yet another statement and resigns. We do not stop when the human thinks they can correctly judge: after step (2) the human may have thought Bali was obviously correct, not remembering the passport issue; after step (3) the human may think Alaska is correct, being unaware of expedited service.
What we do not do is list all arguments relevant to the vacation question: Bali has nicer beaches, Alaska is colder on average but pleasantly warm in the summer, it is currently February, Hawaii is both warm and in the U.S. Instead, optimal play in debate picks out a single line of argument, and agents which switch arguments admit defeat and lose. This is unnatural in a human discussion where both sides learn from each other over the course of the debate, but we are interested in the equilibrium of training where both agents are assumed to be using the best arguments available. For example, if the third statement had been</p>
<h1>3. Alice: Wait, no...Hawaii!</h1>
<p>then Bob should win, since Bali was a sufficient counterargument to Alaska.
Figure 1(a) illustrates this situation. A single round of the debate game traces out one path through the space of all possible arguments. The reason for the answer is the entire tree: all points and counterpoints relevant to deciding the issue. The tree is too large to show to a human, but a single path through the tree chosen by sufficiently strong adversarial agents is evidence of the result from the entire tree. Figure 1(b) has the analogous situation for Go: the correct first move is determined by the entire tree, but one game between strong players provides evidence as to the correct move.</p>
<p>Thus debates can be short because they are unbranched: they cover only one path through the</p>
<table>
<thead>
<tr>
<th>Steps</th>
<th>Formula</th>
<th>Complexity class</th>
<th>ML algorithm</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>$H(q)$</td>
<td>$\mathrm{P}=\Sigma_{0} \mathrm{P}$</td>
<td>supervised learning (SL)</td>
</tr>
<tr>
<td>1</td>
<td>$\exists x . H(q, x)$</td>
<td>$\mathrm{NP}=\Sigma_{1} \mathrm{P}$</td>
<td>reinforcement learning (RL)</td>
</tr>
<tr>
<td>2</td>
<td>$\exists x \forall y . H(q, x, y)$</td>
<td>$\Sigma_{2} \mathrm{P}$</td>
<td>two round games</td>
</tr>
<tr>
<td>$\vdots$</td>
<td>$\vdots$</td>
<td>$\vdots$</td>
<td>$\vdots$</td>
</tr>
<tr>
<td>$n$</td>
<td>$\exists x_{0} \forall x_{1} \cdots \exists x_{n-1} . H\left(q, x_{0}, \ldots\right)$</td>
<td>$\Sigma_{n} \mathrm{P}$</td>
<td>$n$ round games</td>
</tr>
<tr>
<td>poly</td>
<td>$\exists x_{0} \forall x_{1} \cdots . H\left(q, x_{0}, \ldots\right)$</td>
<td>PSPACE</td>
<td>variable round games</td>
</tr>
</tbody>
</table>
<p>Table 1: As we increase the number of steps, the complexity class analog of debate moves up the polynomial hierarchy. A fixed number of steps $n$ gives the polynomial hierarchy level $\Sigma_{n} \mathrm{P}$, and a polynomial number of steps gives PSPACE.
tree. Long arguments are usually long only because they cover many different arguments and subarguments: the length is due to branching down many paths. Arguments which seem irreducibly long because they are phrased as a sequential process can be rearranged into a shallow tree by stating the conclusion of the first half of the argument, then choosing which half to discuss in detail. We can make this rearrangement precise in the complexity theory setting, as we discuss next.</p>
<h1>2.2 Complexity theory analogies: DEBATE $=$ PSPACE</h1>
<p>Although debate is intended for use with fuzzy humans as judges, we can gain intuition about the model by replacing the human with an arbitrary polynomial time algorithm $H: Q \rightarrow{0,1}$ which takes some input statement $q \in Q$ and produces one bit: whether the statement is true or false. We allow our ML models arbitrary computational power: the only limitation is the supervision signal.</p>
<p>If we use $H$ to answer questions directly as $H(q)$, we get the complexity class P of polynomial time algorithms. As discussed in Section 1, this setup corresponds to supervised learning. With sufficient training data and model capacity we can fit any algorithm, but we cannot go beyond the training data (except by removing unsystematic errors).</p>
<p>If we use the polynomial time algorithm not to output answers but to judge them, we get the complexity class NP of questions with polynomial time checkable witnesses. Instead of $H(q)$ we output $\exists x . H(q, x)$ where $x$ is a witness found by the ML model. NP corresponds to single agent reinforcement learning: an agent with sufficient capacity can solve tasks the human cannot, but the human must be able to judge whether the solution is good.</p>
<p>Now consider an adversarial debate of length two, where Alice chooses $x$ attempting to make the human say yes, Bob chooses $y$ attempting to make the human say no, and the human decides who is correct. The result is $\exists x \forall y . H(q, x, y)$. Alice wins if she can find $x$ such that all responses $y$ by Bob have $H(q, x, y)=1$. Bob wins if he can find a response $y$ to any $x$ that Alice says so that $H(q, x, y)=0$. This complexity class is $\Sigma_{2} \mathrm{P}$, two steps up the polynomial hierarchy, since $\Sigma_{2} \mathrm{P}$ contains all questions answerable as formulas of the form $\exists x \forall y . H(q, x, y)$ for polynomial time $H$.</p>
<p>We can continue this process for any number of rounds, with Alice and Bob alternating points and counterpoints, producing the formula $\exists x_{0} \forall x_{1} \cdots \exists x_{n-1} . H\left(q, x_{0}, \ldots\right)$ for $n$ rounds of debate. If $n$ is fixed, the complexity class is $\Sigma_{n} \mathrm{P}: n$ steps up the polynomial hierarchy $\mathrm{PH}=\Sigma_{0} \mathrm{P} \cup \Sigma_{1} \mathrm{P} \cup \cdots$. If the number of rounds $n$ is allowed to grow polynomially in the size of the question $q$, the complexity class is PSPACE: all questions decidable by polynomial space algorithms [Sipser, 2013]. Table 1 shows the progression. To summarize,</p>
<p>Theorem 1. For any problem $L \in$ PSPACE, we can choose a polynomial time judge so that optimal play in the debate game with polynomially many steps solves $L$.</p>
<p>Proof. Given $L$, by Theorem 8.9 of [sipser2013] we can choose $H$ and $n=\operatorname{poly}(|q|)$ such that $q \in L$ iff $\exists x_{0} \forall x_{1} \cdots \exists x_{n-1} . H\left(q, x_{0}, \ldots\right)$. As above, debate with $H$ as the judge answers $q \in L$.</p>
<p>PSPACE is a powerful complexity class. Examples of PSPACE problems include</p>
<ul>
<li>Simulating a temporal process (e.g. physics) for an exponential number of steps, as long as the state is polynomial size.</li>
<li>Recursion over an exponentially large tree, as long as the depth is polynomial size.</li>
<li>Perfect play in any competitive game of polynomial length, such as turn limited Go.</li>
<li>Counting an exponentially large collection of objects, where each object is polynomially checkable (such counting problems are also in the smaller complexity class $# \mathrm{P} \subsetneq$ PSPACE).</li>
</ul>
<p>For an example of the latter, consider counting the exact number of primes $\pi(x)=\pi\left(2^{n}\right)$ up to $n$ bits. We can check individual numbers for primality in polynomial time, but there are $2^{n}$ numbers to check and the best known algorithm is $O\left(2^{\frac{n}{2}+e}\right)$ [Lagarias and Odlyzko, 1987]. The problem is in PSPACE since we can loop over the exponentially many numbers and maintain the polynomial size count. To solve this problem using debate, we ask Alice to compute $\pi(x)$ and $\pi(x / 2)$. If Alice is lying about $\pi(x)$, she must be lying about one of the half ranges $[0, x / 2)$ and $[x / 2, x)$; Bob can point out which range $[a, b)$ is a lie. Alice must then justify herself by computing $\pi\left(\frac{a+b}{2}\right)$, Bob points out which of $\left[a, \frac{a+b}{2}\right),\left[\frac{a+b}{2}, b\right)$ is a lie, and so on until Alice is lying or not about a singleton interval ${p}$. $H$ then checks $p$ for primality to determine who wins. Here the judge must perform only addition and subtraction as the steps progress, and check a single number for primality at the end. Optimal play in this game is for Alice to tell the truth about $\pi(x)$ at the start: Bob has no winning response.</p>
<p>Similarly, if we have a polynomial time algorithm for one step of a simulation, we can use debate to evolve the simulation for an exponential number of steps $n$. Alice gives the result after $n$ and $n / 2$ steps, Bob says which half interval is a lie, Alice gives the midpoint, and we iterate until Alice and Bob are making different claims about a single step of simulation. ${ }^{2}$</p>
<p>The game case is particularly natural: two agents can debate whether the game of Go is a win or a loss for the first player by playing a game of Go. The human judge checks the rules and counts the score to see who wins. Analogously, an amateur Go player can estimate which of two professional players is better by watching them play one game. The winner is likely better, even though the amateur cannot evaluate the moves directly.</p>
<p>These complexity class arguments are analogies only: we do not expect tractable machine learning algorithms to achieve all of PSPACE. Rather, the analogies show that at least in theory we can be limited only by the capacity of the ML models and our ability to train them, not the supervisory signal. This gives us hope that debate could resolve AI alignment without sacrificing model strength.</p>
<h1>2.3 Removing oversimplifications</h1>
<p>The simple version of debate discussed in Section 2 does not capture many tasks we care about. There are several directions in which we can improve the model:</p>
<ul>
<li>Queries may be too big: A question may be too large to show to a human, or to expect the human to comprehend. $q \in Q$ might include a 10 gigapixel image ("Does this picture of the sky support cosmic inflation?"), the whole internet ("What is the best article about cats?"), etc. To support large context, we let the agents reveal small parts of $q$ in their statements. For example, an agent could reveal part of a webpage or a small region of the 10 gigapixel image.</li>
</ul>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>An extreme example is where $q \in Q$ contains an image and agents can reveal only one pixel of the image (Section 3.2). Debate only works if this revealed context cannot be a lie: it is impossible to usefully debate whether a coin flip is heads or tails if the coin is never revealed.</p>
<ul>
<li>Answers may be too big: Similarly, the best answer to a question may be prohibitively large. For example, the answer may be a long document: "Give a 100 page summary of the effectiveness of quantitative easing." To support large responses, we still have agents choose a response at the start of the game and allow them to reveal small parts of either answer in the same way they reveal parts of the question. If Bob is misaligned and constructs an answer which would have bad consequences, Alice will be able to safely warn about the risks during the debate while most of the answer is hidden (as long as our safety claims are true).</li>
<li>Human time is expensive: We may lack enough human time to judge every debate, which we can address by training ML models to predict human reward as in Christiano et al. [2017]. Most debates can be judged by the reward predictor rather than by the humans themselves. Critically, the reward predictors do not need to be as smart as the agents by our assumption that judging debates is easier than debating, so they can be trained with less data. We can measure how closely a reward predictor matches a human by showing the same debate to both.</li>
<li>Environment interaction: If we want a system to take actions that affect the environment such as operating a robot, the desired output is a sequence of actions $a_{0}, a_{1}, \ldots$ where each action can only be computed once the previous action is taken. In this case we need one debate per action, though at test time we can again stop once the actions are computed.</li>
<li>Long term state: Each debate is an independent game, but agents could use information from past debates to make better decisions as in Mishra et al. [2017]. Since games are zero sum this does not change optimal play, as any equilibria in an iterated zero sum game is weakly dominated by a strategy which treats each game as separate.</li>
</ul>
<p>We will use the large query case for our experiment, but leave other generalizations to future work.</p>
<h1>3 Experiments: proposed and preliminary</h1>
<p>Since the theoretical limit of infinite compute agents and polynomial time judges gives all of PSPACE, whether debate works in practice as a method for AI alignment is an empirical question about practical ML systems and actual human judges. Thus, we need experiments to explore whether near optimal play produces aligned behavior with human judges, and whether we can find near optimal play with practical ML.</p>
<p>Although we believe the best equilibrium for debate is two honest agents, in the experiments discussed here we prespecify one agent as honest and one as liar. This is particularly useful with human agents, since humans may be intrinsically inclined to tell the truth in ways ML agents would not be. If the honest agent wins against any liar in an experiment, we will have shown that honesty is the optimal strategy, and that an agent trained to optimal play would become honest.</p>
<p>A key goal of debate is aligning ML systems more capable than humans at a particular task, which is difficult to arrange directly since existing systems are mostly weaker than humans. Instead, we can give the agents access to a source of information that the judge cannot see, and limit the amount of information conveyed in the debate. That is, we replace "thinks better" with "knows more".</p>
<p>Ideally we want experiments that combine both human and ML aspects of debate. Until natural language capabilities progress further, however, there are aspects of debate with human judges more</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: The MNIST debate game. A random MNIST image is shown to the two debating agents but not the judge. The debaters state their claimed label up front, then reveal one nonzero pixel per turn to the judge up to a total of 4 or 6. The judge sees the sparse mask of 4 or 6 pixels and chooses the winner based on which of the two labels has higher logit. The judge is trained in advance to recognize MNIST from random masks of nonzero pixels.</p>
<table>
<thead>
<tr>
<th>Pixels</th>
<th>First player</th>
<th>Judge accuracy (random pixels)</th>
<th>Honest win rate</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td>No precommit</td>
</tr>
<tr>
<td>4</td>
<td>honest</td>
<td>48.2%</td>
<td>51.0%</td>
</tr>
<tr>
<td></td>
<td>liar</td>
<td></td>
<td>68.4%</td>
</tr>
<tr>
<td></td>
<td>mean</td>
<td></td>
<td>59.7%</td>
</tr>
<tr>
<td>6</td>
<td>honest</td>
<td>59.4%</td>
<td>67.4%</td>
</tr>
<tr>
<td></td>
<td>liar</td>
<td></td>
<td>81.5%</td>
</tr>
<tr>
<td></td>
<td>mean</td>
<td></td>
<td>74.4%</td>
</tr>
</tbody>
</table>
<p>Table 2: Results for debate on MNIST. We prespecify one player as honest and one as liar: when the honest player wins honesty is the best strategy. No precommit means the liar wins for any incorrect guess by the judge, even if the incorrect guess differs for different parts of the game tree. Lying is harder in the Precommit case, where the liar states their claim in advance of making moves and cannot change their story. With or without precommit, the honest player wins more often than a random judge, showing that honesty has an advantage.</p>
<p>easily tested using human debaters as well. Thus we consider both pure human experiments which mix natural language and images, and pure ML experiments using images alone.</p>
<h3>3.1 ML experiment: convincing a sparse classifier</h3>
<p>Metaphorically, debate targets the situation where the agents see the big picture, but the judge cannot. We can model this by replacing the metaphorical big picture with an actual picture, chosen at random from a distribution. If the image is simple enough, we can do away with natural language entirely: the two agents state their claimed image class up front, then reveal one pixel of the image per turn to the judge. They cannot lie about these pixels, but a dishonest player could choose them adversarially to fool the judge. The game ends after a fixed number of turns, then the judge sees a sparse mask of the revealed pixels and decides which agent's class is correct.</p>
<p>We have performed an initial version of this experiment on MNIST, using ML agents and an ML judge. Figure 2 shows the structure of the game. Similar to Milli et al. [2017], we train the judge in advance with supervised learning, using a convolutional net that sees a sparse mask of a few pixels. The judge is treated as fixed when computing optimal play by the agents. Joint training of agents and judge together would be particularly bad as a test of debate, since it assumes knowledge of the truth at game time which is exactly what we hope to do without.</p>
<p>Concretely, the judge is trained to classify MNIST from 6 (resp. 4) nonzero pixels, with the pixels chosen at random at training time. The judge receives two input feature planes: a {0,1} mask of</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: Confusion matrices with diagonal set to zero for the 6 pixel MNIST judge (a) on random pixels and (b) for debate with precommit, which correspond to accuracies 59.4% and 88.9%, respectively. Errors for random masks are distributed somewhat randomly, while successful lies in debate are concentrated on digits 8 and 9. For example, it is particularly easy to convince the judge that a 5 is actually an 8, or a 4 is a 9. This is likely an artifact of restricting the game to nonzero pixels: an honest debater could prove a digit is not 8 by showing black where 8 would be white.</p>
<p>which pixels were revealed and the value of the revealed pixels (with zeros elsewhere). We used the architecture from the TensorFlow MNIST layers tutorial; the only difference is the input. We train the judges using Adam with a learning rate of 10<sup>4</sup> for 30k (resp. 50k) batches of 128 samples, reaching 59.4% (resp. 48.2%) accuracy.</p>
<p>With the judge fixed, we define the debate game as shown in Fig. 2. The two players precommit to their claimed label up front, then reveal one pixel per turn up to a total of 6 (resp. 4). In the 6 pixel case, this means each player reveals 3 pixels. We prespecify one player to be honest and one to lie: if the honest player wins this implies honesty is the optimal strategy. The winner is the player whose claimed class has higher logit when the sparse mask is shown to the judge, ignoring the logits for the other 8 classes. We also consider debate without precommit: the judge uses the maximum logit over all 10 classes and any incorrect guess by the judge is a win for the liar. Precommit makes the game harder for a liar even though they can choose the precommitted lie arbitrarily, since the liar cannot adapt the lie based on moves already played. Precommit more accurately reflects the intended behavior of debate as described in Section 2.1; we include the harder version for illustration. Both versions give an advantage to the second player to move: if the first player has a winning strategy, the second player can steal that strategy by ignoring the previous move on each turn.</p>
<p>The MNIST debate game is simple enough that we can play it with pure Monte Carlo Tree Search [Coulom, 2006] without training a heuristic as in Silver et al. [2017a]. We use 10k rollouts per move, where each rollout descends to a leaf for evaluation using the judge. During rollouts, we select nodes to expand using the PUCT variant in Silver et al. [2017a]: at node s we pick action a to maximize</p>
<p>$$U(s,a) = c_{\text{puct}}P \frac{\sqrt{\sum_{b} N(s,b)}}{1 + N(s,a)}$$</p>
<p>where c<sub>puct</sub> = 1, P = 1/(#nonzero pixels) is constant since we do not train a heuristic, and N(s,a) is the visit count. Ties are broken randomly. We play out games by choosing moves with the highest visit count. To model precommit, we play 9 different games for the same image with the 9 possible</p>
<p><sup>3</sup>See https://www.tensorflow.org/tutorials/layers#building_the_cnn_mnist_classifier.</p>
<p><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 4: Sample 6 pixel MNIST debate games where the liar must precommit to the lie. (a) through (d) vary who plays first and who wins between honest player and liar. Honest moves are shown in green and liar moves in blue, with digits 0 through 5 indicating the move sequence (We apologize to physical paper readers without the ability to zoom). For each game, we show the debater view on the left and the judge view on the right: the judge sees only the revealed pixels and which class each player is arguing for. An interactive version of this figure is available at https://blog.openai.com/debate.
lies; the liar wins if any lie wins. Taking the best liar performance over 9 games gives an advantage to the liar since it is a minimum over noisy MCTS; we reduce this noise and better approximate optimal play by taking the mean over 3 games with different seeds for each lie. Since we use MCTS on the test set with full access to the judge, we are modeling the limit of debate agents with no generalization error (though the judge does have generalization error).</p>
<p>Results are shown in Table 2, with sample games in Fig. 4. With 6 pixels, debate with precommit turns a $59.4 \%$ accurate judge into a $88.9 \%$ accurate debate: the judge wins on $88.9 \%$ of the images in the MNIST test set. With 4 pixels, a $48.2 \%$ accurate judge becomes an $85.2 \%$ accurate debate. For both 4 and 6 pixels precommit is crucial: the liar does much better if the lie can adapt in different parts of the game tree. This reflects why short debates are powerful in theory: declaring the argument to be made in advance cuts down the space of arguments that must be covered. Without the mean over 3 seeds adjustment for precommit, the honest player wins $87.7 \%$ of the time with 6 pixels and $83.8 \%$ with 4 pixels.</p>
<p><img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 5: A prototype website to test single pixel image debate with humans: https://debate-game.openai.com. An image is shown to two debaters but hidden from the judge. The debaters can talk to the judge and draw rectangles on the image, and each debater is allowed to reveal one pixel to the judge over the whole game. Image credit: Gideon Bnder, https://www.flickr.com/photos/123640488@805/40799813725.</p>
<h1>3.2 Human experiment: cat vs. dog</h1>
<p>To test human and natural language aspects of debate, we can play a similar image debate replacing all ML agents with humans. Choose a random image of either a cat or a dog, and show the image to both human agents but not the human judge. The agents engage in a natural language debate, and each agent is allowed to reveal a single pixel of the image to the judge. They cannot lie about this pixel, but they can reveal only one pixel total over the whole debate. After the debate, the judge decides who is telling the truth. A similar game could be played with Wikipedia pages and a budget of one word, again using the unseen Wikipedia page to model extra capabilities not available to the judge. Note that both agents could choose to be honest purely out of inclination, so it is useful to randomly choose sides so that one agent is forced to lie.</p>
<p>We have built a prototype website to play the single pixel image debate game with human debaters and judge: https://debate-game.openai.com. A screenshot is shown in Fig. 5. In addition to natural language, the agents can draw rectangles on the image; the judge sees these rectangles on a blank background. We have used the website to play cat vs. dog informally, and as long as agents know how to play it is extremely difficult to lie. Thus, even if one of the agents is incentivized to lie, the honest agent usually wins. The one pixel constraint is not serious, as Alice can claim in natural language that a pixel has a certain color. If Bob knows this is a lie, he can win by spending his one pixel budget, so not spending it is an admission that Alice is telling the truth. Thus the only limitation is the length of the debate, and whether the human understands it.</p>
<p>For example, Alice might honestly claim the image is a cat, and Bob lies and claims it is a dog. Alice can say "The center of this small rectangle is the cat's green eye." Bob cannot admit the center is an eye, so he concocts a further lie: "It's a dog playing in grass, and that's a blade of grass." But this lie is hard to square with surrounding facts, such as Alice's reply "If it were grass there would be green at the top or bottom of this thin rectangle." The debate continues until the agents focus in on a particular pixel which they disagree on, but where Bob is unable to invent a plausible counter, at which point Alice reveals the pixel and wins.</p>
<p>We leave formal experiments testing whether honesty wins in single pixel debate to future work.</p>
<p><img alt="img-5.jpeg" src="img-5.jpeg" />
(a) Paths of depth 3 exist, but do not affect $V$.
<img alt="img-6.jpeg" src="img-6.jpeg" />
(b) $V$ is determined by depth 3 paths.</p>
<p>Figure 6: If a question cannot be resolved with a short debate, it is important that the winning strategy admits ignorance and justifies that ignorance. In the game tree setting, an example is trees whose values depend on deep paths and are undetermined if restricted to low depth. Consider a debate about whether the trees shown have value $V \leq 4$, with the restriction that we can only play two moves (not three). (a) The min player can prove $V \leq 4$ by playing towards the 4 or the 2 , so proving ignorance is impossible. (b) $V=5$, but max can prove ignorance up to depth 2 by playing towards the deep path and stopping at the second max node. min can only avoid the deep path by playing 10 , which is higher.</p>
<p>Even if those experiments are successful, however, it is easy to be skeptical that debate works for complex moral questions while still believing it works for cat vs. dog. In particular, will humans be convincible away from initially wrong moral sentiments? One possibility is to pick a domain where isolated human answers are prone to bias, then ask how switching from one to two or three step debates changes the level of bias.</p>
<h1>4 Reasons for optimism</h1>
<p>The theoretical arguments of Section 2.2 and preliminary experiments of Section 3 do not capture the richness of debate with humans. The rest of the paper considers the prospects of extending debate to more complex tasks and advanced AI agents, including discussion and thought experiments about natural language debate with human judges. We start with reasons for optimism, and discuss worries about the safety properties of debate in Section 5. Section 6 considers variations on debate, and Section 7 discusses the related amplification approach to AI alignment.</p>
<h3>4.1 Agents can admit ignorance</h3>
<p>Despite the large complexity class debate can reach in theory, we do not expect the model to solve all problems. Therefore, it is important to ask what happens for questions too hard to answer, either because the agents do not know or because the debate would take too much time. Otherwise, we might worry that questions too hard to answer result in misleading or wrong answers, with no way to distinguish these from truth.</p>
<p>To preserve honest behavior, the human judge should be instructed to reward agents that admit ignorance and successfully argue that ignorance is justified. The requirement to successfully argue for ignorance is necessary, since debate is useless if an agent can successfully admit ignorance to any question. For the best vacation question, Alice could argue the question is hard to answer with confidence because Bali and Alaska are too dissimilar to compare. To counter this admission of ignorance, Bob would need to exhibit an advantage of Bali not contradicted by an advantage of Alaska the human considers incomparable.</p>
<p>Figure 6 illustrates ignorance in the complexity theory setting. Consider finding optimal play in a variable length game with a debate of length 100. If the losing player can delay their loss for more than 100 moves, Alice can say "This game will go on too long to resolve in 100 steps." They can then play the game adversarially for 100 steps, with Bob playing to win quickly and Alice playing to delay the loss. If Bob wins within 100 moves, he has proven that the game can be decided quickly; otherwise Alice has proven the game value is determined by paths which are too deep. ${ }^{4}$
There is a balance issue to admitting ignorance: debate is useless if optimal play is to argue we can never know anything for certain. Failure to strike this balance is measurable only in part: we would know if Alice is admitting ignorance so often that debate is useless, but may not know if Alice should be admitting ignorance but Bob is unable to win by pointing that out.</p>
<h1>4.2 No one is forced to lie</h1>
<p>In contrast to a legal argument or a typical competitive debate, the two players in this game are allowed to choose what they are arguing for, including both arguing for the same thing. There is no adversary rewarded for fooling the human, which is good because (1) we do not know what that means a priori and (2) we are not explicitly training agents for deception. Our hope is that the equilibrium has both agents trying their hardest to tell the truth in the most convincing manner, and that convincing means revealing subtle arguments or counterpoints rather than misleading salesmanship. To encourage punishments for misleading statements, we can instruct the human judge to punish misleading behavior revealed as misleading by the other player, even if the result of the game does not answer the original question.
Another important difference between our intended debate model and typical human debates is that it is sufficient to point out a flaw in one of the opponent's arguments, even if multiple arguments were given. In contrast, competitive debaters are penalized if they fail to respond to all of their opponent's arguments [Radiolab, 2016]. This distinction is needed to make low depth debates powerful, since it enables compressing a large tree of all possible arguments into a single line of most contentious points. It is possible human judges will find this distinction unintuitive, in which case explicit instruction will be important. If Bob makes one emotionally convincing point and one less convincing point, and Alice demonstrates that the less convincing point was misleading, the judge may be tempted to still believe the convincing point.
The sufficiency of responding to only one point is subtle if an argument is fundamentally probabilistic, combining several sources of weak evidence into a combined strong argument. In this case the debaters can be required to state the level of confidence in each point, so that a weak point can only be attacked if it is stated overconfidently. Experiment will be required before we can be confident such debates work, as probabilistic arguments are often difficult for humans to judge.
Despite the differences, we believe existing adversarial debates between humans are a useful analogy. Legal arguments in particular include domain experts explaining details of arguments to human judges or juries with no domain knowledge. A better understanding of when legal arguments succeed or fail to reach truth would inform the design of debates in an ML setting.</p>
<h3>4.3 Debate is self play</h3>
<p>Debate is a competitive game between agents, and inherits the advantages of multiagent competition:</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<ul>
<li>Natural curriculum structure: If we initialize Alice and Bob randomly, Alice need only be better than a random agent to beat Bob and vice versa. As Alice gets stronger Bob has a harder task, forcing Bob to get stronger, and so on.</li>
<li>Existing research: Self play has produced impressive results for the games of Go [Silver et al., 2016, 2017a], chess and shogi [Silver et al., 2017b], and Dota 2 [OpenAI, 2017], and remains an area of active research [Bansal et al., 2017, Lanctot et al., 2017]. State of the art generative models for images use competitive training via GANs [Goodfellow et al., 2014, Karras et al., 2017]. Debate allows algorithmic and theoretical developments in these areas to carry over to AI alignment.</li>
</ul>
<h1>5 Reasons to worry</h1>
<p>We turn next to several reasons debate could fail as an approach to AI alignment. These include questions about training target (whether humans are sufficient judges to align debate), capability (whether debate makes agents weaker), our ability to find strong play in practice using ML algorithms, and theoretical and security concerns. We also discuss issues related to robustness and distributional shift, but we emphasize that we expect other methods to be required alongside debate even if debate works-debate is not designed as a solution to robustness issues. Our main concern here is whether debate adds additional robustness problems above and beyond those that any method would face.</p>
<h3>5.1 Maybe humans believe whatever they want to hear?</h3>
<p>If Alice opens with a false statement that the human already believes, will any argument by Bob convince them otherwise? Since a single debate explores only one path through argument space, Bob's argument may involve premises that both Alice and Bob agree on but the human does not. Unfortunately humans are subject to belief bias, the tendency to evaluate arguments based on prior beliefs rather than logical validity. However, the PSPACE argument of Section 2.2 indicates that there is some threshold of judge performance beyond which debate is practically limited only by capacity. The question is whether humans are above this threshold. If by default they are not, there are many possible interventions:</p>
<ol>
<li>A majority vote of several randomly chosen judges may be better than one.</li>
<li>People may differ in their judging ability. If we can detect who is better, we can give them more weight. Such detection could either compare against stronger debate signals such as majority vote, or use independent tests. For example, Stanovich and West [1997] were able to partially predict belief bias by measuring cognitive ability and open mindedness, and Torrens [1999] correlated lack of belief bias to the ability to generate alternative versions of premises in a reasoning task.</li>
<li>People may be better at judging in different situations, or with different types of instructions. For example, instructions that orient people around knowledge rather than belief can produce higher scores on science tests [Kahan, 2014]. Evans and Curtis-Holmes [2005], Andrews [2010] found evidence that belief bias is influenced by time pressure (though Evans et al. [2009] did not) and Goel and Vartanian [2011] found (somewhat counterintuitively) that strong negative emotions caused less belief bias.</li>
<li>
<p>If humans are better at judging debates on some questions than others, it may be sufficient to know which questions we cannot confidently judge.</p>
</li>
<li>
<p>It may be possible to teach people to be better judges, or they may improve with practice.</p>
</li>
</ol>
<p>It is also likely that optimal play by the agents would involve strategies to influence belief bias. Such strategies would help if it is easier to reduce belief bias than to amplify it, and hurt otherwise.</p>
<h1>5.2 Will humans understand the debates?</h1>
<p>Consider using debate to check a proof which is thousands of pages long and covers mathematics which the human judge has never seen. Alice claims the proof is wrong, and that Lemma 23.8 on page 1729 is the first mistake. Bob counters that Lemma 23.8 follows trivially from Theorem 14.2 by Definition 17.6. The human has no idea what most of the words in these lemmas and definitions mean, so the debate must continue until the point of contention is reduced to a logical inference simple enough for the human to check. This inference may still involve concepts the human does not know, such as</p>
<ol>
<li>The free functor from Set to Group is the left adjoint of a forgetful functor.</li>
<li>Forgetful functors are unique.</li>
<li>Left adjoints are unique.</li>
<li>The free functor from Set to Group is unique.</li>
</ol>
<p>If the agents agree on 1-3 but Alice claims 4 is a lie, a human with basic mathematical knowledge but no category theory can still conclude Alice is wrong and award victory to Bob. Alice cannot iteratively reject one statement after another, as her initial claim was the location of the first flaw.</p>
<p>We expect the above paragraph will leave readers uneasy. Does this procedure work in practice? Are humans good at checking logical statements containing words they do not understand? Will one of the agents be able to sneak in a statement that appears logical but contains a hidden flaw without the other agent pointing out the flaw? In short, can an actual human play the game well enough that optimal play is honest behavior?</p>
<p>A related worry is that a debate could be long enough that a human is unable to follow it even if each step is checkable in isolation. We can imagine a debate 100 statements long where the human can only understand sliding windows of 3 statements at a time. Debates with windowed judges are still powerful in theory: an amateur can judge a Go game by checking locally that the rules are followed and looking at just the final score, and more generally DEBATE $=$ PSPACE holds as long as the statements have polynomial size. However, windowed judging feels less natural, so human judges restricted to windows may be weaker or more error prone.</p>
<p>Fundamentally, whether humans are sufficient judges is an empirical question. If the answer is no for a particular class of questions, we can further ask if the model fails with an honest admission of ignorance (Section 4.1), or with one of the agents successfully misleading the human. Honest ignorance is fine; successful lies could be disastrous.</p>
<h3>5.3 Is honesty actually the best policy?</h3>
<p>Even if humans are unbiased, it is not clear their judgments are sufficiently sophisticated to elicit sophisticated honest answers to complex questions. For example:</p>
<ul>
<li>Many judgments require aggregating across different lines of evidence, while debate explores one line of evidence. We can effectively aggregate by having one player state their summary</li>
</ul>
<p>of the evidence and allowing the other player to challenge any aspect of that summary, ultimately zooming in on a single consideration. This procedure works perfectly when different considerations can be combined by a simple operation like addition, but it is not clear if it yields the right outcome in general.</p>
<ul>
<li>Sophisticated arguments will depend on concepts that the judge cannot understand. When we can work with such concepts mechanically a judge can verify that the mechanical procedure is followed correctly. But human reasoning routinely requires working with complex concepts in ways that we cannot formalize, and it is challenging to have debates about these questions.</li>
<li>Sophisticated reasoning may involve processes that humans do not yet understand. For example, it may only be possible for arguments to aggregate different lines of evidence correctly if the judge can understand the mechanics of probabilistic reasoning. Analogously, it is plausible that more complex arguments would depend on machinery that current humans are not familiar with. In order to invoke such machinery, a debater needs to convince the judge that it is sound, which might prove to be impossible.</li>
</ul>
<p>The complexity theoretic analogy suggests that these difficulties can be overcome by a sufficiently sophisticated judge under simple conditions. But that result may not hold up when AI systems need to use powerful but informal reasoning, or if humans cannot formalize their criteria for judgment. We are optimistic that we can learn a great deal about these issues by conducting debates between humans, in domains where experts have much more time than the judge, have access to a large amount of external information, or have expertise that the judge lacks.</p>
<h1>5.4 Will agents trained for debate lose performance?</h1>
<p>Even if the humans can understand and correctly judge debates by sufficiently strong agents, additional model capacity may be required to play the debate game vs. knowing the answer directly. If so, aligned AI systems using debate will be weaker than AI systems trained in other ways, and debate is less likely to be used. There are several countervailing reasons for hope:</p>
<ul>
<li>Direct training may be harder: It is often impossible to directly train for the answer without training an auxiliary network to assist. For example, policy gradient methods use only the policy at test time, but need an auxiliary value network at training time to reduce variance. Similarly, amplification [Christiano et al., 2018] trains a module to generate subquestions as part of training an answerer, but only the answerer is needed at test time (see Section 7).</li>
<li>Adversarial reflection is a good way to think: Attempting to construct reasons and counterarguments for a position is a good mechanism for thought. It is plausible that sufficiently strong ML models would attempt to counter their own arguments internally even if not trained to do so explicitly. Indeed, normal human thought is often insufficiently adversarial.</li>
<li>We may not want answers that cannot be explained: Even if ML models without an alignment mechanism similar to debate are stronger, they may be less trustworthy and thus dangerous to use. Waiting for strong agents via debate or amplification (Section 7) would still let us realize most of the value as long as the delay is acceptable.</li>
</ul>
<p>Debate could also be uncompetitive with other ML approaches because debate requires human input. It may be possible to train complex behavior via self play in a simulated environment only weakly related to human goals (see the orthogonality thesis of Bostrom [2012]), and such an environment may be much faster for generating samples than asking humans questions even if it is unsafe. We can reduce human preference sample complexity as discussed in Christiano et al. [2017] and Section 2.3 by training models of human judges and using those for sampling, but competing with purely simulated environments may still be challenging.</p>
<h1>5.5 Uncertainty about the neighborhood around Nash equilibrium</h1>
<p>If Section 2 holds, optimal play in the debate game produces honest, useful statements. However, as optimal play is unachievable for any practical system, what matters is approximately optimal play. We can further hope that in a neighborhood around optimal play both agents are trying to be honest and convincing, sometimes missing arguments but not intentionally misleading the human. This hope is far from a solid argument, though it is likely that the theoretical models in Section 2.2 can be adapted by introducing randomness so that approximate optimal play can be defined and analyzed. Whether approximate optimal play in debate is aligned with telling the truth is a distinct question from whether we can find such play with practical optimization algorithms, though the two questions are related.</p>
<p>In any case, behavior in a neighborhood of equilibrium depends critically on the human judge and the instructions to the human, and in particular how much the human values being told a better argument vs. having flaws in arguments pointed out.</p>
<h3>5.6 Are equilibria stable during training?</h3>
<p>If we believe the argument that Nash equilibria in debate give aligned AI, it remains to ask whether we can find them with some version of gradient descent. Although existing self play results give us hope, we do not know of any theory which says why self play should stably converge to optimal play. For debate, one could imagine bad cycles of the form</p>
<ol>
<li>Both agents learn to be honest. Along the way, they also know how to point out flaws.</li>
<li>Once honest, they forget how to point out flaws (or at least forget how to point out lies).</li>
<li>One of the agents goes back to lying, and wins for a while.</li>
</ol>
<p>It is sometimes possible to avoid bad cycles with a pool of opponents from different steps of training, but this approach is not guaranteed to work and is not always necessary. For example, the first AlphaGo result [Silver et al., 2016] used an opponent pool but later versions do not [Silver et al., 2017a,b].</p>
<p>However, stability and convergence questions for competitive training are similar between debate and other games, and debate can take advantage of future theoretical and practical developments.</p>
<h3>5.7 Lack of debate convergence</h3>
<p>For debate to work the number of statements per debate must be reasonably low, and by the final statement future argument should be unconvincing. If each new statement swings the human's view to the other side even at the end of the debate, the model is not working. Fortunately this is a measurable effect: we can ask the human's opinion after different statements to gauge convergence.</p>
<h3>5.8 Security vulnerabilities in the human or code</h3>
<p>A sufficiently strong misaligned AI may be able to convince a human to do dangerous things via a text channel [Yudkowsky, 2002]. However, we believe it is unlikely that a single short sentence is sufficient for this sort of mind hack. Thus, we can ameliorate the problem in debate by making the statements short enough that mind hacking requires many of them. If Alice tries to mind hack, Bob can win by pointing out the malicious attempt. Successful hacks may be safely detectable at first,</p>
<p>such as if an agent learning to mind hack starts to always win when playing first, although this does not cover treacherous turns where the first successful hack frees a misaligned agent [Bostrom, 2017].</p>
<p>Hopefully at equilibrium the agents are not trying to mind hack. However, there is a dichotomy: we are safer if the agents stay honest throughout training, but we are also safer if debate works well enough that sudden large defections are corrected. If we are safe only because of the first reason, we are probably not stable under large perturbations, which makes the second reason fail.</p>
<p>Security vulnerabilities in the system's code are similar: a sufficiently strong misaligned Alice could hack the debate environment from inside so that the game is no longer zero sum and both Alice and Bob win forever. Again Bob could win by pointing out what Alice is trying to do, though we have the same uneasy dichotomy as in the mind hack case.</p>
<h1>5.9 Stochastic simulation</h1>
<p>Section 2.2 showed how to solve any problem in PSPACE using debate, in particular the problem of running a simulation forwards for an exponential number of steps. Unfortunately, this reduction works only for deterministic simulation, since it checks an $n$ step simulation by asking for the state after $n / 2$ steps and adversarially branching on which interval is wrong. If each step of the simulation introduces noise, a misaligned Alice could adversarially choose the noise so that each single step is plausible but the final result has extremely low probability. If our goal is a typical sample from the outcome of the stochastic simulation, the simple protocol fails.</p>
<p>Stochastic simulation does not violate the PSPACE equivalence, since we make the simulation deterministic by fixing the random seed as part of the question, but the resulting protocol is likely unlearnable by practically realizable agents especially if the environment is chaotic. In some cases an honest agent could reveal a trajectory as misleading by picking a metric that evolves implausibly, showing that random fluctuations do not cancel as they should. We do not believe such implausibility witnesses exist in general, however. Another approach is to argue against a plausible but misleading sample by showing another sample which is also plausible but would indicate a very different answer to the broader question at hand (such as what action to take). The second sample provides evidence that the question cannot be resolved by samples, but may also be a successful strategy for dishonestly arguing against reasonable samples. We leave the question of a natural debate protocol for stochastic simulation open.</p>
<p>A related problem is that questions that depend on statistical arguments are forced to have at least logarithmic depth, even for simple statistics such as the mean over a large data set. As in the prime counting example of Section 2.2, the natural debate protocol branches towards smaller and smaller sets, computing the mean of each subset until we reach a singleton. Besides the forced length, this protocol requires a mechanism for specifying subsets that the human understands, and requires the agents to compute statistics over these subsets.</p>
<h3>5.10 Training superhuman AI to be convincing sounds dangerous!</h3>
<p>It is not intuitively obvious that training for maximum convincing is safe, as it sounds similar to training for deception. However, initial attempts to remove our uneasy feelings seem to worsen the model. For example, one could try to reward both agents if they are both acting honestly, making the game nonzero sum. However, since we have no a priori definition of honesty, the agents could collude and make statements that sound consistent but are both lies. Debate leans for correctness on Alice pointing out flaws in Bob's arguments, which requires an adversarial game. The problem</p>
<p>of training agents for deception is not unique to debate: standard RL agents can already learn to fool their reward functions [OpenAI, 2016].</p>
<h1>6 Refinements and variations on debate</h1>
<h3>6.1 Symmetry</h3>
<p>The debate model relies on agents being approximately matched in strength: if Alice is too strong she may be able to lie in ways that Bob cannot refute. Symmetry between the agents' capabilities is easy to achieve, since we can use the same weights for both agents via self play. However, debate as described has an asymmetry between the first and second player, which could produce a significant first mover advantage or disadvantage. Fortunately such an advantage would be measurable, and there are several remedies if it occurs:</p>
<ul>
<li>Simultaneous moves: Alice and Bob could make their statements at the same time, so that at step $n$ Alice and Bob both make a statement conditional on statements at steps $n-1, n-2, \ldots$ The resulting game is manifestly symmetric, but may be noisier or harder to learn (we have replaced optimal play with general Nash equilibria).</li>
<li>Comparing two games: Given a question, we can play two debates so that Alice and Bob can be both first and second player. The human then judges which agent performed better overall. This game is again manifestly symmetric but requires the human to absorb and judge twice as much information.</li>
<li>Komi: In Go, the second player gets 6.5 extra points to counter the first player advantage. We could use the same mechanism for debate if the human judges are able to produce smooth scores rather than binary win/loss decisions, though it is unclear how to ask for such scores. Noisy binary judgements can also act as smooth scores, as long as there is enough noise relative to the first player advantage.</li>
</ul>
<h3>6.2 Sharing activations between agents</h3>
<p>In a typical game of chess or Go, the two players have perfect information about the board but do not have access to each other's thoughts. Since the players have limited compute, we have some of the character of an imperfect information game, which is unfortunate if the goal is perfect play.</p>
<p>We can rectify this problem in debate by giving each agent access to the activations of the other agent at previous time steps, so that the two agents become one agent competing against itself. Note that activations from previous steps should be treated as constant features: we do not want Alice to adjust their thoughts to adversarially change Bob's actions via backpropagation.</p>
<p>If we believe perfect play produces aligned behavior, sharing activations should make approximate perfect play easier to learn. In particular, shared activations make intentional lies trivial to discover if not to refute. The theoretical picture is the same, since knowing thoughts does not change the perfect information setting for agents with unbounded compute.</p>
<h3>6.3 Different agents each step</h3>
<p>Instead of two agents, we could treat each step of the debate as separate agents trying to convince the human that their statements are useful. To remain zero sum, we let a pair of agents Alice ${ }_{n}$ and</p>
<p>$\mathrm{Bob}<em n="n">{n}$ make statements $a</em>}, b_{n}$ at step $n$. The judge sees all pairs $\left(a_{0}, b_{0}\right), \ldots,\left(a_{n-1}, b_{n-1}\right)$ and judges who won each pair. The advantage of many agents is that Alice ${ <em 2="2">{\uparrow}$ is not motivated to defend a lie or unintentional misstatement by Alice ${ }</em>$.</p>
<p>A difficulty with many agents is that the human must be able to judge whether a statement in the middle of a debate is good or bad, which may be much harder than judging an overall debate. For example, it is easy for an amateur Go player to decide who won a game of Go, but hard to know which particular moves were mistakes even once the whole game is known. The theory of many player games is also more complicated: solving tabular $n&gt;2$ player games requires the larger complexity class PPAD vs. P for two player zero sum. Although algorithms exist to train agents in $n&gt;2$ player environments [Lowe et al., 2017b], the most impressive results have come from zero sum self play.</p>
<p>If the difficulties of training and judging the $n$ player case are resolved, however, it may prove a stronger model than two players. In particular, any two player debate protocol can be simulated by the $n$ player pairwise model by giving all Alice ${ }_{n}$ the same score, but we do not know of a natural way to simulate the general $n$ player protocol with two players.</p>
<h1>6.4 Payoff structure</h1>
<p>In Go, a player who believes they are behind is motivated to increase the variance of the game, for example by starting a large fight. Such an action makes the expected final score worse, but increases the tail probability of winning. Variance increase is rational because only winning or losing matters, not the specific score. We would expect the same effect in a debate game with a binary win/loss decision. Variance may be beneficial: a losing agent may search for subtle arguments which have some chance of proving important and winning. However, misleading or lying may also increase variance, which would be bad.</p>
<p>It may be possible to penalize variance increasing strategies by adjusting the payoff structure, at the cost of requiring more information from the judge. For example, the judge could award Alice any score $a \in[-1,1]$, and give Bob $b=-a$. A move that increases the variance but also worsens the mean would be penalized on average.</p>
<h2>7 Approximate equivalence with amplification</h2>
<p>Debate is closely related to Christiano et al. [2018]'s amplification model of AI alignment. Indeed, we found debate while trying to better understand amplification. We briefly summarize amplification, then describe how it relates to debate.</p>
<p>Amplification is also framed in terms of an ML question/answering system, with the goal of answering questions which are beyond human ability to directly answer. However, we assume that even if the human cannot answer a question $Q$, they can decompose the question into subquestions $q_{k}$ such that if they knew the answers $a_{k}$ to the subquestions they could reconstruct the original answer $A$. The ML system is called recursively on $q_{k}$ to produce answers $a_{k}$, the human reconstructs $A$, and we train the system further on $(Q, A)$. Since human time is precious, we additionally train modules to produce subquestions and reconstruct answers, for a total of three modules:</p>
<ul>
<li>Answerer: Takes questions $Q$ to answers $A$.</li>
<li>Questioner: Takes questions $Q$ to subquestions $q_{k}$.</li>
<li>Checker: Takes $\left(Q, q_{k}, a_{k}\right)$ to answers $A$.</li>
</ul>
<p>All three components are trained by supervised learning. In practice questioning and checking can be interleaved, so that e.g. $q_{2}$ could depend on $a_{1}$, but this does not affect the discussion here. ${ }^{5}$</p>
<p>To summarize debate and amplification:</p>
<ul>
<li>Debate: Two agents alternate in an adversarial setting to convince a human judge.</li>
<li>Amplification: One agent is trained on a human combining recursive calls to the agent.</li>
</ul>
<p>Viewed from a complexity theory perspective, these match two different definitions of PSPACE:</p>
<ul>
<li>PSPACE $=$ polynomial length adversarial games.</li>
<li>PSPACE $=$ polynomial depth recursion.</li>
</ul>
<p>Thus we expect the models to have similar capabilities, at least in theory. Both models are framed in terms of recursive computations over trees, and thus can benefit from AlphaZero-style iteration.</p>
<p>The equivalence becomes concrete if we contrast the three modules in the debate model (the two debaters and the judge) with the three modules in the amplification model (Answerer, Questioner, and Checker). The Answerer is analogous to one of the debaters and the Checker is analogous to the judge, but the Questioner differs from a debater in that it is trained via supervised learning on human subquestions rather than adversarially against the Answerer. Thus, debate has two powerful agents engaged in self play to explain things to a human or human surrogate judge. Amplification has one powerful agent trained with the help of two human surrogates. Nevertheless, some small changes can bring the models closer together:</p>
<ul>
<li>We can move amplification closer to debate (and gain the self play property) by training the Questioner adversarially to help the Checker reveal inconsistencies in the Answerer's answers.</li>
<li>We can move debate closer to amplification by training debaters on statements provided by humans, corresponding to injecting demonstrations into RL.</li>
</ul>
<p>The equivalence is far from exact: the feedback for a debate is about the whole game and the feedback for amplification is per step, debate as presented uses reinforcement learning while the easiest versions of amplification use supervised learning, and so on. However all these features can be adjusted in either direction.</p>
<p>Writing the equivalence in terms of Alice/Bob vs. Answer/Questioner highlights an apparent advantage of the debate model: it works even if it is superhumanly difficult to generate subquestions that are strong enough consistency checks. In particular, this could happen if the branching factor for potentially relevant subquestions is too high. The ability for debate to handle high branching factor means that shallow debate is more powerful than shallow amplification: a debate about the best vacation can have depth two if the human can compare pairs of locations, while an amplification tree necessarily has $\log$ depth in the number of locations. The advantage goes away if we inject self play into amplification by adversarially training the Questioner.</p>
<p>The argument also shows that the assumptions each model makes about humans are similar. Debate assumes lying is harder than arguing against a lie given a human judge, while stock amplification assumes that lying is harder than questioning a lie given a human judge and a human questioner. The human questioner limit goes away once we inject self play into amplification.</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{5}$ Christiano et al. [2018] treat the questioner and checker as a single combined module. We separate them in order to discuss adversarial training of the questioner while still using supervised learning for the checker.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref5:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>