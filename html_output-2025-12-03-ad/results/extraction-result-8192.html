<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-8192 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-8192</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-8192</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-150.html">extraction-schema-150</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the memory mechanism, tasks, comparative results, ablations, and key findings.</div>
                <p><strong>Paper ID:</strong> paper-272367206</p>
                <p><strong>Paper Title:</strong> <a href="https://export.arxiv.org/pdf/2409.00872v2.pdf" target="_blank">Self-evolving Agents with reflective and memory-augmented abilities</a></p>
                <p><strong>Paper Abstract:</strong> Large language models (LLMs) have made significant advances in the field of natural language processing, but they still face challenges such as continuous decision-making. In this research, we propose a novel framework by integrating iterative feedback, reflective mechanisms, and a memory optimization mechanism based on the Ebbinghaus forgetting curve, it significantly enhances the agents' capabilities in handling multi-tasking and long-span information.</p>
                <p><strong>Cost:</strong> 0.02</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e8192.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e8192.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the memory mechanism, tasks, comparative results, ablations, and key findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>SAGE</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Self-evolving Agents with Reflective and Memory-augmented Abilities</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A three-agent framework (User, Assistant, Checker) that augments LLM agents with iterative feedback, a reflection mechanism, and a dual-memory system controlled by a MemorySyntax method based on the Ebbinghaus forgetting curve to optimize information retention and transmission.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>SAGE Assistant (three-agent system)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Three-agent architecture (User proposes task, Assistant generates actions/outputs, Checker provides iterative feedback). Assistant integrates reflection and a dual-memory (STM/LTM) managed by MemorySyntax to update policies iteratively without additional training.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Evaluated across multiple LLMs (GPT-3.5, GPT-4, Llama2-7B, CodeLlama-7B, Qwen-1.8B, Mistral-7B, etc.)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Various commercial and open-source LLMs of differing sizes; the paper reports results showing stronger relative gains on smaller open-source models.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>AgentBench suite (OS, DB, KG, ALF, WS, M2W), long-form QA (HotpotQA), TriviaQA, LCC code completion, multi-turn dialog (MultiWOZ), ALFWorld sequential tasks</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Multi-turn agent tasks including web navigation, database interaction, knowledge-graph construction, code completion, multi-hop QA and long-context reasoning; tasks require sustained interaction, memory of past steps, and multi-document integration.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>multi-agent decision making; question answering; web navigation; code completion; multi-step sequential tasks; long-context reasoning</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>dual-memory (Short-Term Memory STM + Long-Term Memory LTM) controlled by MemorySyntax (Ebbinghaus-inspired retention strength thresholds)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism</strong></td>
                            <td>MemorySyntax computes retention strength S(I_t) (information-entropy * forgetting-curve factor), applies linguistic optimization to information I_t to create I*_t (increasing strength), and uses two thresholds to place items into STM, transfer to LTM, or discard; reflection produces self-reflections r_t stored in LTM; iterative inclusion of memory into policy updates and prompt context.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Self-reflections (r_t), recent trajectory history (observations O_t, actions a_t), optimized information units I*_t (textual summaries/optimized language), and past outputs and rewards.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>Retention-strength-based prioritization (thresholding), recency/STM for immediate context, transfer rules for LTM; memory content is concatenated/integrated into assistant context prompts (implicit prompt concatenation) and used during iterative refinement.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>Multiple reported improvements: overall up to 2.26x improvement on closed-source models in AgentBench (aggregate claim); open-source improvements reported between 57.7% and 100% in some settings. Specific: HotpotQA GPT-3.5 baseline 54.1% -> SAGE 74.9% (+20.8% absolute); GPT-4 61.2% -> 78.4% (+17.2%); Code completion LCC F1 SAGE 79.29 (slight improvement vs baselines). RAG comparison: ChatGPT-4 + SAGE HotpotQA 74.8% (+4.7 vs best FiD), with memory usage reduced ~50% on some tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td>Baselines and ablations reported as comparison: e.g., HotpotQA GPT-3.5 baseline 54.1% (no SAGE memory/reflect loop), GPT-4 baseline 61.2%; more detailed per-model baselines listed in Tables 1-4 of paper.</td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_with_without_memory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_comparison</strong></td>
                            <td>Paper compares SAGE to Beam Search and Reflexion baselines (self-refinement). SAGE outperforms both on HotpotQA and TriviaQA (SAGE F1 22.06/22.76 vs Reflexion 11.26/11.23 and Beam search 10.26/12.13). RAG retrieval baselines (BM25, DPR, OpenAI Retrieval, TART, FiD) are compared; ChatGPT-4 with SAGE improves accuracy by 3.6–4.7 points and halves memory usage in some retrieval tasks. Ablation (Table 5) shows memory optimization ON vs OFF dramatically improves open-source models (see separate ablation entity).</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Integrating reflection and a principled memory optimization (MemorySyntax with Ebbinghaus forgetting-inspired retention) improves multi-turn, long-context, and multi-document tasks; gains are especially large for smaller open-source models; reflection reduces logical/format errors; MemorySyntax can reduce memory consumption while improving accuracy in retrieval-augmented QA.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Some tasks (e.g., simple code completion) only show modest gains; framework relies on heuristic thresholds and information-strength estimates (S(I_t)); potential risk of discarding relevant info if thresholds/method poorly tuned; memory/management still constrained by context windows and system design choices; paper does not report full latency/memory tradeoffs across all models (claims no latency increase for some cases).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Self-evolving Agents with reflective and memory-augmented abilities', 'publication_date_yy_mm': '2024-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8192.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e8192.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the memory mechanism, tasks, comparative results, ablations, and key findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>MemorySyntax</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>MemorySyntax (Ebbinghaus forgetting curve + linguistic optimization)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A memory optimization method that combines the Ebbinghaus forgetting curve with linguistic optimization of stored information to increase retention strength, using threshold rules to decide STM retention, transfer to LTM, or discard.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>SAGE Assistant (Memory management module)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Language model assistant component that uses MemorySyntax to decide which pieces of textual information to keep in short-term memory, transfer to long-term memory, or discard, thereby managing prompt context size and prioritizing high-utility items.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Applied across evaluated LLMs (GPT-3.5, GPT-4, Llama2, CodeLlama, Qwen, etc.)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>No single model; MemorySyntax is model-agnostic and applied as a prompt-and-memory-management layer on top of different LLMs.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Memory management across AgentBench tasks, HotpotQA, TriviaQA, long-context/code tasks</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Reduces cognitive load and context usage for multi-turn, multi-document tasks by prioritizing high-entropy/high-strength information and discarding low-utility items.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>memory management for multi-turn/multi-document QA and agent tasks</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>algorithmic retention-strength memory manager (controls STM and LTM)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism</strong></td>
                            <td>Retention rate R(I_t, τ) = exp(-τ / S) where S is information strength; linguistic optimization produces I*_t with higher S*; thresholds θ1, θ2 determine whether I*_t stays in STM, moves to LTM, or is discarded.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Optimized textual information units I*_t and computed retention strengths S(I_t); stored self-reflections and trajectory summaries in LTM.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>Thresholding + selective inclusion into generation context (priority-based prompt inclusion), transfer rules between STM and LTM.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>Reported to enable substantial performance gains when used in SAGE: contributes to agent improvements in AgentBench and retrieval QA, and to ~50% reduction in memory usage in some RAG comparisons (Table 4) while improving accuracy (+3.6 to +4.7 points on HotpotQA/Natural Questions/TriviaQA for ChatGPT-4 with SAGE).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td>Baseline (no MemorySyntax) results are the non-SAGE baselines (see SAGE vs baselines). Specific ablations (Table 5) show that disabling memory optimization causes large drops (see ablation entry).</td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_with_without_memory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_comparison</strong></td>
                            <td>Ablation on memory optimization (Table 5) shows dramatic drops when memory optimization is removed for open-source models (e.g., Qwen-1.8B KG 6.8 -> 45.3 with memory optimization; CodeLlama-7B DB 2.7 -> 41.3 with memory optimization). Compared to classical RAG methods, MemorySyntax in SAGE gives modest accuracy gains while reducing memory usage.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>A principled, entropy-informed retention scheme combined with linguistic optimization can prioritize high-utility memory items and substantially improve downstream agent performance while reducing memory footprint.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Thresholds θ1/θ2 and the strength estimation S(I_t) require design choices; poor estimation can cause useful items to be discarded; theoretical optimality is argued but practical hyperparameter tuning is necessary.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Self-evolving Agents with reflective and memory-augmented abilities', 'publication_date_yy_mm': '2024-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8192.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e8192.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the memory mechanism, tasks, comparative results, ablations, and key findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Reflection mechanism</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Reflection (self-reflection r_t stored in LTM)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A mechanism by which the assistant processes its outputs, rewards, and trajectories to produce richer self-reflections r_t that are stored in long-term memory and used to improve future decision-making.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>SAGE Assistant (reflection component)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Generates self-reflections r_t = ref(o_1:t, R_1:t) from sequences of outputs and rewards; stores these reflections in LTM to inform subsequent planning and reduce repeated logical/format errors.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Applied within SAGE across evaluated LLMs</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Model-agnostic reflective process that augments LLM reasoning by storing derived textual reflections.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>HotpotQA example and general multi-turn tasks (AgentBench tasks)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Used to improve multi-hop reasoning and multi-step decision tasks by using richer textual reflections rather than only scalar reward signals.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>multi-hop question answering; sequential decision-making</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>long-term memory entries (self-reflections)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism</strong></td>
                            <td>Compute r_t from outputs and rewards and append to M_L; future policy conditioned on stored reflections to improve decisions.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Textual self-reflections summarizing mistakes, strategies, and insights derived from past trajectories and rewards.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>Inclusion of relevant reflections into assistant context during subsequent iterations (prompt concatenation / prioritized by retention strength).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>Contributes to large improvements on multi-document reasoning tasks (e.g., HotpotQA: SAGE-GPT-3.5 +20.8% absolute accuracy over baseline); specific reflection-only contribution not isolated but paper attributes reduced invalid-format and logic errors to reflection.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_with_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_comparison</strong></td>
                            <td>Paper attributes error reductions (Context Limit Exceeded, invalid format) and improved logical correctness to the reflection mechanism, but does not present a single ablation isolating reflection from MemorySyntax in all tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Reflections (textual, richer than scalar rewards) stored in LTM help the agent learn from past failures, reducing repeated logical mistakes and improving multi-document reasoning.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Effect size of reflection is reported qualitatively and via aggregate task improvements; the paper does not always isolate reflection from memory-optimization effects in every experiment.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Self-evolving Agents with reflective and memory-augmented abilities', 'publication_date_yy_mm': '2024-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8192.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e8192.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the memory mechanism, tasks, comparative results, ablations, and key findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Memory optimization ablation (Table 5)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Ablation study of memory optimization on Qwen-1.8B and CodeLlama-7B</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Quantitative ablation comparing agents with and without SAGE memory optimization, showing large performance gains from enabling memory optimization for smaller open-source models.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>Qwen-1.8B and CodeLlama-7B (as SAGE-assisted agents)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Open-source LLMs evaluated both with and without SAGE's memory optimization module to measure the impact of MemorySyntax and reflection.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Qwen-1.8B; CodeLlama-7B (Instruct)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Small-to-medium open-source LLMs; CodeLlama-7B is code-focused, Qwen-1.8B is general-purpose ~1.8B parameter model.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>AgentBench tasks (OS, DB, KG, ALF, WS, M2W)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>AgentBench multidimensional tasks spanning operating systems control, database SQL tasks, knowledge graph usage, ALFWorld sequential tasks, WebShop web navigation, and Mind2Web navigation.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>web navigation; database QA; knowledge graph construction; embodied/text-world sequential tasks</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>MemorySyntax-managed STM/LTM</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism</strong></td>
                            <td>Memory optimization ON: MemorySyntax active (retention strength + linguistic optimization) storing reflections and prioritized items; OFF: no memory optimization (baseline SAGE without memory module).</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Textual memory units and reflections when ON; none when OFF (baseline behavior).</td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>When ON: prioritized inclusion into prompts; when OFF: no systematic memory retention beyond immediate context.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>Qwen-1.8B (with memory): OS 18.7, DB 28.3, KG 45.3, ALF 10.5, WS 31.4, M2W 25.1 (Table 5, percentages/metrics as in paper). CodeLlama-7B (with memory): OS 23.4, DB 41.3, KG 48.0, ALF 12.5, WS 58.7, M2W 15.0.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td>Qwen-1.8B (w/o memo): OS 10.4, DB 22.6, KG 6.8, ALF 0.0, WS 26.6, M2W 5.0. CodeLlama-7B (w/o memo): OS 9.7, DB 2.7, KG 0.0, ALF 0.0, WS 14.3, M2W 5.0.</td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_with_without_memory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_comparison</strong></td>
                            <td>Direct ablation (memory optimization ON vs OFF) shows dramatic improvements for both models, especially CodeLlama-7B: DB 2.7 -> 41.3, KG 0.0 -> 48.0, WS 14.3 -> 58.7; Qwen-1.8B: KG 6.8 -> 45.3, ALF 0.0 -> 10.5, M2W 5.0 -> 25.1.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Memory optimization is crucial for enabling smaller/open-source LMs to handle complex agent tasks; enabling MemorySyntax and reflection yields order-of-magnitude improvements on some tasks for these models.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Ablation isolates memory optimization as a module but other SAGE components (iterative feedback, checker templates) also contribute; absolute performance still lags top commercial models in some tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Self-evolving Agents with reflective and memory-augmented abilities', 'publication_date_yy_mm': '2024-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8192.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e8192.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the memory mechanism, tasks, comparative results, ablations, and key findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Reflexion (baseline)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Reflexion (language agents with verbal reinforcement learning) - baseline</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A prior self-refinement agent that uses verbalized past trial experiences as memory for improving future trials; used as a baseline in the paper's long-context reasoning comparisons.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>Reflexion (baseline comparison)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Agent that records past trials and uses natural-language 'verbal' experiences to inform future planning and corrections (verbal reinforcement learning). Used in experiments as a competing refinement/memory strategy.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Applied to same underlying LLMs for baseline comparisons (not specifically trained here)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Prior published method (Shinn et al.) that stores and uses textual trial experiences as memory.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>HotpotQA, TriviaQA, long-context reasoning tasks and LCC code tasks (as evaluated in Table 3)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Multi-hop QA and long-context reasoning tasks where prior trial experience helps refinement over runs.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>multi-hop question answering; iterative self-refinement</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>verbalized past-trial memory (trial transcripts stored as text)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism</strong></td>
                            <td>Stores past trial attempts and uses them as textual context to inform subsequent attempts (verbal memory).</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Past trial outputs and commentary (text).</td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>Prompting with previous trial transcripts; no explicit retention-strength gating described in this paper's comparison (baseline behavior per original Reflexion method).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>Reported as baseline in Table 3: Reflexion LCC F1 ~79.28 (precision/recall numbers reported per table), HotpotQA F1 11.26, TriviaQA F1 11.23 (substantially lower than SAGE on reasoning tasks).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_with_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_comparison</strong></td>
                            <td>Compared directly to SAGE and Beam search; SAGE substantially outperforms Reflexion on multi-document reasoning tasks (e.g., HotpotQA/TriviaQA F1 roughly doubled).</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Verbal trial-memory approaches like Reflexion provide some benefits but were outperformed by SAGE's combination of reflection + optimized memory management in multi-document reasoning tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>As used here, Reflexion's naive storage of trials without principled retention/optimization appears insufficient for complex multi-document reasoning compared to MemorySyntax-based management.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Self-evolving Agents with reflective and memory-augmented abilities', 'publication_date_yy_mm': '2024-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8192.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e8192.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the memory mechanism, tasks, comparative results, ablations, and key findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>RAG baselines</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Retrieval-Augmented Generation baselines (BM25, DPR, OpenAI Retrieval, TART, FiD)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Classical and recent retrieval-augmented generation retrieval methods used as baselines for multi-document QA; compared to ChatGPT-4+SAGE for QA accuracy, latency, and memory usage.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>RAG-style agents (BM25 / DPR / OpenAI Retrieval / TART / FiD)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Pipeline retrieval-augmented QA agents that retrieve candidate passages (lexical or dense) and fuse them with generative models (FiD) or use retrieval APIs; serve as baselines for multi-document QA.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Various retrieval+generator stacks (BM25, DPR, OpenAI Retrieval, TART, FiD) often combined with encoder-decoder fusion or LLM generator.</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Standard retrieval methods: BM25 (lexical), DPR (dense), TART (transformer retrieval), FiD (fusion-in-decoder).</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Multi-document QA (HotpotQA, Natural Questions, TriviaQA)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Open-domain/multi-document question answering requiring retrieval of relevant contexts and fusion for answer generation.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>retrieval-augmented question answering</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>external retrieval index / passage store (document memory)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism</strong></td>
                            <td>Retrieve top passages with BM25 or DPR or other retrievers and provide them as context to the generator; FiD encodes multiple passages and fuses them in decoder.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>External document passages stored in retrieval index (lexical or vector embeddings).</td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>BM25 lexical matching or DPR dense embedding search; OpenAI Retrieval API or transformer-based retriever (TART).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>Per Table 4: RAG (BM25) HotpotQA 60.8% accuracy; RAG (DPR) 66.3%; RAG (OpenAI Retrieval) 67.4%; FiD 70.1%; ChatGPT-4 + SAGE 74.8% (+4.7 over FiD) with ~50% lower memory usage in some tests.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_with_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_comparison</strong></td>
                            <td>SAGE (with MemorySyntax) compared favorably against RAG variants: SAGE provided 3.6–4.7 absolute points improvement across HotpotQA/Natural Questions/TriviaQA and substantially reduced memory footprint (~47–50% reported) in some cases.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Structured agent workflows with optimized memory management (SAGE) can outperform traditional retrieval-augmented pipelines in QA accuracy while reducing memory consumption.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>RAG systems still strong baselines; gains from SAGE are moderate in absolute terms for large models but SAGE shows better efficiency (memory) tradeoffs.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Self-evolving Agents with reflective and memory-augmented abilities', 'publication_date_yy_mm': '2024-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Reflexion: Language agents with verbal reinforcement learning <em>(Rating: 2)</em></li>
                <li>MemGPT: Towards LLMs as operating systems <em>(Rating: 2)</em></li>
                <li>Hybrid computing using a neural network with dynamic external memory <em>(Rating: 2)</em></li>
                <li>Leveraging passage retrieval with generative models for open domain question answering <em>(Rating: 1)</em></li>
                <li>Über das Gedächtnis: Untersuchungen zur experimentellen Psychologie <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-8192",
    "paper_id": "paper-272367206",
    "extraction_schema_id": "extraction-schema-150",
    "extracted_data": [
        {
            "name_short": "SAGE",
            "name_full": "Self-evolving Agents with Reflective and Memory-augmented Abilities",
            "brief_description": "A three-agent framework (User, Assistant, Checker) that augments LLM agents with iterative feedback, a reflection mechanism, and a dual-memory system controlled by a MemorySyntax method based on the Ebbinghaus forgetting curve to optimize information retention and transmission.",
            "citation_title": "here",
            "mention_or_use": "use",
            "agent_name": "SAGE Assistant (three-agent system)",
            "agent_description": "Three-agent architecture (User proposes task, Assistant generates actions/outputs, Checker provides iterative feedback). Assistant integrates reflection and a dual-memory (STM/LTM) managed by MemorySyntax to update policies iteratively without additional training.",
            "model_name": "Evaluated across multiple LLMs (GPT-3.5, GPT-4, Llama2-7B, CodeLlama-7B, Qwen-1.8B, Mistral-7B, etc.)",
            "model_description": "Various commercial and open-source LLMs of differing sizes; the paper reports results showing stronger relative gains on smaller open-source models.",
            "task_name": "AgentBench suite (OS, DB, KG, ALF, WS, M2W), long-form QA (HotpotQA), TriviaQA, LCC code completion, multi-turn dialog (MultiWOZ), ALFWorld sequential tasks",
            "task_description": "Multi-turn agent tasks including web navigation, database interaction, knowledge-graph construction, code completion, multi-hop QA and long-context reasoning; tasks require sustained interaction, memory of past steps, and multi-document integration.",
            "task_type": "multi-agent decision making; question answering; web navigation; code completion; multi-step sequential tasks; long-context reasoning",
            "memory_used": true,
            "memory_type": "dual-memory (Short-Term Memory STM + Long-Term Memory LTM) controlled by MemorySyntax (Ebbinghaus-inspired retention strength thresholds)",
            "memory_mechanism": "MemorySyntax computes retention strength S(I_t) (information-entropy * forgetting-curve factor), applies linguistic optimization to information I_t to create I*_t (increasing strength), and uses two thresholds to place items into STM, transfer to LTM, or discard; reflection produces self-reflections r_t stored in LTM; iterative inclusion of memory into policy updates and prompt context.",
            "memory_representation": "Self-reflections (r_t), recent trajectory history (observations O_t, actions a_t), optimized information units I*_t (textual summaries/optimized language), and past outputs and rewards.",
            "memory_retrieval_method": "Retention-strength-based prioritization (thresholding), recency/STM for immediate context, transfer rules for LTM; memory content is concatenated/integrated into assistant context prompts (implicit prompt concatenation) and used during iterative refinement.",
            "performance_with_memory": "Multiple reported improvements: overall up to 2.26x improvement on closed-source models in AgentBench (aggregate claim); open-source improvements reported between 57.7% and 100% in some settings. Specific: HotpotQA GPT-3.5 baseline 54.1% -&gt; SAGE 74.9% (+20.8% absolute); GPT-4 61.2% -&gt; 78.4% (+17.2%); Code completion LCC F1 SAGE 79.29 (slight improvement vs baselines). RAG comparison: ChatGPT-4 + SAGE HotpotQA 74.8% (+4.7 vs best FiD), with memory usage reduced ~50% on some tasks.",
            "performance_without_memory": "Baselines and ablations reported as comparison: e.g., HotpotQA GPT-3.5 baseline 54.1% (no SAGE memory/reflect loop), GPT-4 baseline 61.2%; more detailed per-model baselines listed in Tables 1-4 of paper.",
            "has_performance_with_without_memory": true,
            "ablation_or_comparison": "Paper compares SAGE to Beam Search and Reflexion baselines (self-refinement). SAGE outperforms both on HotpotQA and TriviaQA (SAGE F1 22.06/22.76 vs Reflexion 11.26/11.23 and Beam search 10.26/12.13). RAG retrieval baselines (BM25, DPR, OpenAI Retrieval, TART, FiD) are compared; ChatGPT-4 with SAGE improves accuracy by 3.6–4.7 points and halves memory usage in some retrieval tasks. Ablation (Table 5) shows memory optimization ON vs OFF dramatically improves open-source models (see separate ablation entity).",
            "key_findings": "Integrating reflection and a principled memory optimization (MemorySyntax with Ebbinghaus forgetting-inspired retention) improves multi-turn, long-context, and multi-document tasks; gains are especially large for smaller open-source models; reflection reduces logical/format errors; MemorySyntax can reduce memory consumption while improving accuracy in retrieval-augmented QA.",
            "limitations_or_challenges": "Some tasks (e.g., simple code completion) only show modest gains; framework relies on heuristic thresholds and information-strength estimates (S(I_t)); potential risk of discarding relevant info if thresholds/method poorly tuned; memory/management still constrained by context windows and system design choices; paper does not report full latency/memory tradeoffs across all models (claims no latency increase for some cases).",
            "uuid": "e8192.0",
            "source_info": {
                "paper_title": "Self-evolving Agents with reflective and memory-augmented abilities",
                "publication_date_yy_mm": "2024-09"
            }
        },
        {
            "name_short": "MemorySyntax",
            "name_full": "MemorySyntax (Ebbinghaus forgetting curve + linguistic optimization)",
            "brief_description": "A memory optimization method that combines the Ebbinghaus forgetting curve with linguistic optimization of stored information to increase retention strength, using threshold rules to decide STM retention, transfer to LTM, or discard.",
            "citation_title": "here",
            "mention_or_use": "use",
            "agent_name": "SAGE Assistant (Memory management module)",
            "agent_description": "Language model assistant component that uses MemorySyntax to decide which pieces of textual information to keep in short-term memory, transfer to long-term memory, or discard, thereby managing prompt context size and prioritizing high-utility items.",
            "model_name": "Applied across evaluated LLMs (GPT-3.5, GPT-4, Llama2, CodeLlama, Qwen, etc.)",
            "model_description": "No single model; MemorySyntax is model-agnostic and applied as a prompt-and-memory-management layer on top of different LLMs.",
            "task_name": "Memory management across AgentBench tasks, HotpotQA, TriviaQA, long-context/code tasks",
            "task_description": "Reduces cognitive load and context usage for multi-turn, multi-document tasks by prioritizing high-entropy/high-strength information and discarding low-utility items.",
            "task_type": "memory management for multi-turn/multi-document QA and agent tasks",
            "memory_used": true,
            "memory_type": "algorithmic retention-strength memory manager (controls STM and LTM)",
            "memory_mechanism": "Retention rate R(I_t, τ) = exp(-τ / S) where S is information strength; linguistic optimization produces I*_t with higher S*; thresholds θ1, θ2 determine whether I*_t stays in STM, moves to LTM, or is discarded.",
            "memory_representation": "Optimized textual information units I*_t and computed retention strengths S(I_t); stored self-reflections and trajectory summaries in LTM.",
            "memory_retrieval_method": "Thresholding + selective inclusion into generation context (priority-based prompt inclusion), transfer rules between STM and LTM.",
            "performance_with_memory": "Reported to enable substantial performance gains when used in SAGE: contributes to agent improvements in AgentBench and retrieval QA, and to ~50% reduction in memory usage in some RAG comparisons (Table 4) while improving accuracy (+3.6 to +4.7 points on HotpotQA/Natural Questions/TriviaQA for ChatGPT-4 with SAGE).",
            "performance_without_memory": "Baseline (no MemorySyntax) results are the non-SAGE baselines (see SAGE vs baselines). Specific ablations (Table 5) show that disabling memory optimization causes large drops (see ablation entry).",
            "has_performance_with_without_memory": true,
            "ablation_or_comparison": "Ablation on memory optimization (Table 5) shows dramatic drops when memory optimization is removed for open-source models (e.g., Qwen-1.8B KG 6.8 -&gt; 45.3 with memory optimization; CodeLlama-7B DB 2.7 -&gt; 41.3 with memory optimization). Compared to classical RAG methods, MemorySyntax in SAGE gives modest accuracy gains while reducing memory usage.",
            "key_findings": "A principled, entropy-informed retention scheme combined with linguistic optimization can prioritize high-utility memory items and substantially improve downstream agent performance while reducing memory footprint.",
            "limitations_or_challenges": "Thresholds θ1/θ2 and the strength estimation S(I_t) require design choices; poor estimation can cause useful items to be discarded; theoretical optimality is argued but practical hyperparameter tuning is necessary.",
            "uuid": "e8192.1",
            "source_info": {
                "paper_title": "Self-evolving Agents with reflective and memory-augmented abilities",
                "publication_date_yy_mm": "2024-09"
            }
        },
        {
            "name_short": "Reflection mechanism",
            "name_full": "Reflection (self-reflection r_t stored in LTM)",
            "brief_description": "A mechanism by which the assistant processes its outputs, rewards, and trajectories to produce richer self-reflections r_t that are stored in long-term memory and used to improve future decision-making.",
            "citation_title": "here",
            "mention_or_use": "use",
            "agent_name": "SAGE Assistant (reflection component)",
            "agent_description": "Generates self-reflections r_t = ref(o_1:t, R_1:t) from sequences of outputs and rewards; stores these reflections in LTM to inform subsequent planning and reduce repeated logical/format errors.",
            "model_name": "Applied within SAGE across evaluated LLMs",
            "model_description": "Model-agnostic reflective process that augments LLM reasoning by storing derived textual reflections.",
            "task_name": "HotpotQA example and general multi-turn tasks (AgentBench tasks)",
            "task_description": "Used to improve multi-hop reasoning and multi-step decision tasks by using richer textual reflections rather than only scalar reward signals.",
            "task_type": "multi-hop question answering; sequential decision-making",
            "memory_used": true,
            "memory_type": "long-term memory entries (self-reflections)",
            "memory_mechanism": "Compute r_t from outputs and rewards and append to M_L; future policy conditioned on stored reflections to improve decisions.",
            "memory_representation": "Textual self-reflections summarizing mistakes, strategies, and insights derived from past trajectories and rewards.",
            "memory_retrieval_method": "Inclusion of relevant reflections into assistant context during subsequent iterations (prompt concatenation / prioritized by retention strength).",
            "performance_with_memory": "Contributes to large improvements on multi-document reasoning tasks (e.g., HotpotQA: SAGE-GPT-3.5 +20.8% absolute accuracy over baseline); specific reflection-only contribution not isolated but paper attributes reduced invalid-format and logic errors to reflection.",
            "performance_without_memory": null,
            "has_performance_with_without_memory": null,
            "ablation_or_comparison": "Paper attributes error reductions (Context Limit Exceeded, invalid format) and improved logical correctness to the reflection mechanism, but does not present a single ablation isolating reflection from MemorySyntax in all tasks.",
            "key_findings": "Reflections (textual, richer than scalar rewards) stored in LTM help the agent learn from past failures, reducing repeated logical mistakes and improving multi-document reasoning.",
            "limitations_or_challenges": "Effect size of reflection is reported qualitatively and via aggregate task improvements; the paper does not always isolate reflection from memory-optimization effects in every experiment.",
            "uuid": "e8192.2",
            "source_info": {
                "paper_title": "Self-evolving Agents with reflective and memory-augmented abilities",
                "publication_date_yy_mm": "2024-09"
            }
        },
        {
            "name_short": "Memory optimization ablation (Table 5)",
            "name_full": "Ablation study of memory optimization on Qwen-1.8B and CodeLlama-7B",
            "brief_description": "Quantitative ablation comparing agents with and without SAGE memory optimization, showing large performance gains from enabling memory optimization for smaller open-source models.",
            "citation_title": "here",
            "mention_or_use": "use",
            "agent_name": "Qwen-1.8B and CodeLlama-7B (as SAGE-assisted agents)",
            "agent_description": "Open-source LLMs evaluated both with and without SAGE's memory optimization module to measure the impact of MemorySyntax and reflection.",
            "model_name": "Qwen-1.8B; CodeLlama-7B (Instruct)",
            "model_description": "Small-to-medium open-source LLMs; CodeLlama-7B is code-focused, Qwen-1.8B is general-purpose ~1.8B parameter model.",
            "task_name": "AgentBench tasks (OS, DB, KG, ALF, WS, M2W)",
            "task_description": "AgentBench multidimensional tasks spanning operating systems control, database SQL tasks, knowledge graph usage, ALFWorld sequential tasks, WebShop web navigation, and Mind2Web navigation.",
            "task_type": "web navigation; database QA; knowledge graph construction; embodied/text-world sequential tasks",
            "memory_used": true,
            "memory_type": "MemorySyntax-managed STM/LTM",
            "memory_mechanism": "Memory optimization ON: MemorySyntax active (retention strength + linguistic optimization) storing reflections and prioritized items; OFF: no memory optimization (baseline SAGE without memory module).",
            "memory_representation": "Textual memory units and reflections when ON; none when OFF (baseline behavior).",
            "memory_retrieval_method": "When ON: prioritized inclusion into prompts; when OFF: no systematic memory retention beyond immediate context.",
            "performance_with_memory": "Qwen-1.8B (with memory): OS 18.7, DB 28.3, KG 45.3, ALF 10.5, WS 31.4, M2W 25.1 (Table 5, percentages/metrics as in paper). CodeLlama-7B (with memory): OS 23.4, DB 41.3, KG 48.0, ALF 12.5, WS 58.7, M2W 15.0.",
            "performance_without_memory": "Qwen-1.8B (w/o memo): OS 10.4, DB 22.6, KG 6.8, ALF 0.0, WS 26.6, M2W 5.0. CodeLlama-7B (w/o memo): OS 9.7, DB 2.7, KG 0.0, ALF 0.0, WS 14.3, M2W 5.0.",
            "has_performance_with_without_memory": true,
            "ablation_or_comparison": "Direct ablation (memory optimization ON vs OFF) shows dramatic improvements for both models, especially CodeLlama-7B: DB 2.7 -&gt; 41.3, KG 0.0 -&gt; 48.0, WS 14.3 -&gt; 58.7; Qwen-1.8B: KG 6.8 -&gt; 45.3, ALF 0.0 -&gt; 10.5, M2W 5.0 -&gt; 25.1.",
            "key_findings": "Memory optimization is crucial for enabling smaller/open-source LMs to handle complex agent tasks; enabling MemorySyntax and reflection yields order-of-magnitude improvements on some tasks for these models.",
            "limitations_or_challenges": "Ablation isolates memory optimization as a module but other SAGE components (iterative feedback, checker templates) also contribute; absolute performance still lags top commercial models in some tasks.",
            "uuid": "e8192.3",
            "source_info": {
                "paper_title": "Self-evolving Agents with reflective and memory-augmented abilities",
                "publication_date_yy_mm": "2024-09"
            }
        },
        {
            "name_short": "Reflexion (baseline)",
            "name_full": "Reflexion (language agents with verbal reinforcement learning) - baseline",
            "brief_description": "A prior self-refinement agent that uses verbalized past trial experiences as memory for improving future trials; used as a baseline in the paper's long-context reasoning comparisons.",
            "citation_title": "",
            "mention_or_use": "use",
            "agent_name": "Reflexion (baseline comparison)",
            "agent_description": "Agent that records past trials and uses natural-language 'verbal' experiences to inform future planning and corrections (verbal reinforcement learning). Used in experiments as a competing refinement/memory strategy.",
            "model_name": "Applied to same underlying LLMs for baseline comparisons (not specifically trained here)",
            "model_description": "Prior published method (Shinn et al.) that stores and uses textual trial experiences as memory.",
            "task_name": "HotpotQA, TriviaQA, long-context reasoning tasks and LCC code tasks (as evaluated in Table 3)",
            "task_description": "Multi-hop QA and long-context reasoning tasks where prior trial experience helps refinement over runs.",
            "task_type": "multi-hop question answering; iterative self-refinement",
            "memory_used": true,
            "memory_type": "verbalized past-trial memory (trial transcripts stored as text)",
            "memory_mechanism": "Stores past trial attempts and uses them as textual context to inform subsequent attempts (verbal memory).",
            "memory_representation": "Past trial outputs and commentary (text).",
            "memory_retrieval_method": "Prompting with previous trial transcripts; no explicit retention-strength gating described in this paper's comparison (baseline behavior per original Reflexion method).",
            "performance_with_memory": "Reported as baseline in Table 3: Reflexion LCC F1 ~79.28 (precision/recall numbers reported per table), HotpotQA F1 11.26, TriviaQA F1 11.23 (substantially lower than SAGE on reasoning tasks).",
            "performance_without_memory": null,
            "has_performance_with_without_memory": null,
            "ablation_or_comparison": "Compared directly to SAGE and Beam search; SAGE substantially outperforms Reflexion on multi-document reasoning tasks (e.g., HotpotQA/TriviaQA F1 roughly doubled).",
            "key_findings": "Verbal trial-memory approaches like Reflexion provide some benefits but were outperformed by SAGE's combination of reflection + optimized memory management in multi-document reasoning tasks.",
            "limitations_or_challenges": "As used here, Reflexion's naive storage of trials without principled retention/optimization appears insufficient for complex multi-document reasoning compared to MemorySyntax-based management.",
            "uuid": "e8192.4",
            "source_info": {
                "paper_title": "Self-evolving Agents with reflective and memory-augmented abilities",
                "publication_date_yy_mm": "2024-09"
            }
        },
        {
            "name_short": "RAG baselines",
            "name_full": "Retrieval-Augmented Generation baselines (BM25, DPR, OpenAI Retrieval, TART, FiD)",
            "brief_description": "Classical and recent retrieval-augmented generation retrieval methods used as baselines for multi-document QA; compared to ChatGPT-4+SAGE for QA accuracy, latency, and memory usage.",
            "citation_title": "",
            "mention_or_use": "use",
            "agent_name": "RAG-style agents (BM25 / DPR / OpenAI Retrieval / TART / FiD)",
            "agent_description": "Pipeline retrieval-augmented QA agents that retrieve candidate passages (lexical or dense) and fuse them with generative models (FiD) or use retrieval APIs; serve as baselines for multi-document QA.",
            "model_name": "Various retrieval+generator stacks (BM25, DPR, OpenAI Retrieval, TART, FiD) often combined with encoder-decoder fusion or LLM generator.",
            "model_description": "Standard retrieval methods: BM25 (lexical), DPR (dense), TART (transformer retrieval), FiD (fusion-in-decoder).",
            "task_name": "Multi-document QA (HotpotQA, Natural Questions, TriviaQA)",
            "task_description": "Open-domain/multi-document question answering requiring retrieval of relevant contexts and fusion for answer generation.",
            "task_type": "retrieval-augmented question answering",
            "memory_used": true,
            "memory_type": "external retrieval index / passage store (document memory)",
            "memory_mechanism": "Retrieve top passages with BM25 or DPR or other retrievers and provide them as context to the generator; FiD encodes multiple passages and fuses them in decoder.",
            "memory_representation": "External document passages stored in retrieval index (lexical or vector embeddings).",
            "memory_retrieval_method": "BM25 lexical matching or DPR dense embedding search; OpenAI Retrieval API or transformer-based retriever (TART).",
            "performance_with_memory": "Per Table 4: RAG (BM25) HotpotQA 60.8% accuracy; RAG (DPR) 66.3%; RAG (OpenAI Retrieval) 67.4%; FiD 70.1%; ChatGPT-4 + SAGE 74.8% (+4.7 over FiD) with ~50% lower memory usage in some tests.",
            "performance_without_memory": null,
            "has_performance_with_without_memory": null,
            "ablation_or_comparison": "SAGE (with MemorySyntax) compared favorably against RAG variants: SAGE provided 3.6–4.7 absolute points improvement across HotpotQA/Natural Questions/TriviaQA and substantially reduced memory footprint (~47–50% reported) in some cases.",
            "key_findings": "Structured agent workflows with optimized memory management (SAGE) can outperform traditional retrieval-augmented pipelines in QA accuracy while reducing memory consumption.",
            "limitations_or_challenges": "RAG systems still strong baselines; gains from SAGE are moderate in absolute terms for large models but SAGE shows better efficiency (memory) tradeoffs.",
            "uuid": "e8192.5",
            "source_info": {
                "paper_title": "Self-evolving Agents with reflective and memory-augmented abilities",
                "publication_date_yy_mm": "2024-09"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Reflexion: Language agents with verbal reinforcement learning",
            "rating": 2,
            "sanitized_title": "reflexion_language_agents_with_verbal_reinforcement_learning"
        },
        {
            "paper_title": "MemGPT: Towards LLMs as operating systems",
            "rating": 2,
            "sanitized_title": "memgpt_towards_llms_as_operating_systems"
        },
        {
            "paper_title": "Hybrid computing using a neural network with dynamic external memory",
            "rating": 2,
            "sanitized_title": "hybrid_computing_using_a_neural_network_with_dynamic_external_memory"
        },
        {
            "paper_title": "Leveraging passage retrieval with generative models for open domain question answering",
            "rating": 1,
            "sanitized_title": "leveraging_passage_retrieval_with_generative_models_for_open_domain_question_answering"
        },
        {
            "paper_title": "Über das Gedächtnis: Untersuchungen zur experimentellen Psychologie",
            "rating": 1,
            "sanitized_title": "über_das_gedächtnis_untersuchungen_zur_experimentellen_psychologie"
        }
    ],
    "cost": 0.01956425,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>SAGE: Self-evolving Agents with Reflective and Memoryaugmented Abilities
20 Apr 2025</p>
<p>Xuechen Liang 
East China Jiao Tong University</p>
<p>Yangfan He 
University of Minnesota -Twin Cities
3 AutoAgents.ai</p>
<p>Yinghui Xia 
Xinyuan Song 
Emory University</p>
<p>Jianhui Wang 
University of Electronic Science and Technology of China</p>
<p>Meiling Tao 
Guangdong University of Technology
7 Amazon</p>
<p>Li Sun 
Xinhang Yuan 
Washington University</p>
<p>Jiayi Su 
Xiamen University
10 Independent Researcher</p>
<p>Keqin Li 
Jiaqi Chen 
Jinsong Yang 
Siyuan Chen 
Tianyu Shi ty.shi@mail.utoronto.ca 
University of Bristol</p>
<p>University of Toronto Project</p>
<p>SAGE: Self-evolving Agents with Reflective and Memoryaugmented Abilities
20 Apr 20259EC60CBBAA33262EA66EEC458DED68A3arXiv:2409.00872v2[cs.CL]
Large language models (LLMs) have made significant advances in the field of natural language processing, but they still face challenges such as continuous decision-making, lack of long-term memory, and limited context windows in dynamic environments.To address these issues, this paper proposes an innovative framework-Self-evolving Agents with Reflective and Memory-augmented Abilities (SAGE).The SAGE framework comprises three agents: the User, the Assistant, and the Checker.By integrating iterative feedback, reflective mechanisms, and a memory optimization mechanism based on the Ebbinghaus forgetting curve, it significantly enhances the agents' capabilities in handling multi-tasking and long-span information.The agents, through self-evolution, can adaptively adjust strategies, optimize information storage and transmission, and effectively reduce cognitive load.We evaluate the performance of the SAGE framework on multiple benchmarks and long text tasks.Experimental results show that SAGE significantly improves model performance, achieving a 2.26X improvement on closed-source models and an improvement ranging from 57.7% to 100% on open-source models, with particularly notable effects on smaller models.</p>
<p>Introduction</p>
<p>In recent years, large language models (LLMs) have made significant progress in the field of natural language processing, demonstrating powerful performance in tasks such as dialogue and text generation Brown et al. (2020); He et al. (2025;2024).Recently, there has been growing interest in applying LLMs as autonomous agents (LLM agents), which use language not only for understanding and generation, but also for planning and acting in interactive environments Yao et al. (2023b); Shinn et al. (2023); Liang et al. (2024); Li et al. (2024); Zhou et al. (2024).However, these models still face several challenges: (1) LLM Agents need to continuously make decisions in changing environments and adapt to new situations and tasks.(2) LLM Agents lack long-term memory mechanisms, which is increasingly evident in situations requiring sustained interaction with the environment Graves et al. (2016).The limited context window also hinders the model's ability to handle information over long time spans Rae et al. (2019).</p>
<p>To tackle these challenges, researchers have proposed meta-learning and multi-task learning to enhance the transferability and adaptability of LLM agents.For memory limitations, prior works like MemGPT Packer et al. (2024) use a FIFO queue to manage forgetting, while MemoryBank employs a forgetting curve based on insertion time.However, these approaches are often task-specific, lacking a general framework to systematically improve LLM agents in complex environments.Recent innovations, such as AutoGPT Yang et al. (2023) and BabyAGI Nakajima (2024), leverage LLMs as core controllers, aiming to solve real-world challenges.Yet, multi-agent frameworks still face issues like communication overload, heavily relying on memory to maintain context.As interaction history grows, resource demands and latency increase, limiting efficient deployment in practical scenarios.</p>
<p>In this paper, we propose an innovative framework, Self-evolving Agents with reflective and memory-augmented abilities (SAGE).By enhancing agents' self-adjustment capabilities through reflection, they can more effectively utilize historical information and make efficient decisions when faced with complex and dynamic tasks.From the perspective of self-evolution, we introduce a memory optimization mechanism based on the Ebbinghaus forgetting curv Ebbinghaus (1885).This mechanism helps agents selectively retain key information, optimize information storage and transmission, reduce unnecessary cognitive load, and enhance agents' capabilities in interaction tasks with the environment.Experimental results demonstrate that our approach consistently enhances the performance of both proprietary and open-source LLMs across a wide range of benchmarks.The improvements are especially notable in smaller models, where the gains are more pronounced.On tasks such as multi-source question answering and code generation, our method sets a new standard, outperforming existing techniques and achieving leading benchmarks Etezadi &amp; Shamsfard (2023), including AgentBench Liu et al. (2023b).</p>
<p>The main contributions of our work are as follows:</p>
<p>• We propose a novel framework, SAGE, which introduces a reflection mechanism to enhance agents' self-adjustment capabilities.Without any additional training, this enables agents to utilize historical information more effectively and make better decisions when faced with complex and dynamic tasks.• We introduce a memory optimization mechanism based on the Ebbinghaus forgetting curve.This helps agents selectively retain key information, reducing the issue of information overload in multi-agent systems.• SAGE achieves improvements over strong baselines in multiple challenging real-world tasks and attains state-of-the-art results on benchmarks.This framework can be applied to other LLMs, with particularly strong improvements in smaller models.</p>
<p>Related work</p>
<p>Self-Improvement of Reasoning and Decision-Making</p>
<p>Deep learning has transformed multiple domains including NLP, time series analysis and computer vision Qiu et al. (2025a;b;2024).A lot of research is focused on making large language models (LLMs) better at improving themselves.Some researchers are working on using carefully crafted prompts to help models learn how to get better, although this usually only works for one-off tasks.Others are tweaking how models get feedback during tasks, which helps them get better at thinking things through Huang et al. (2022).There's also work on using strategies like random beam searches to help models make smarter decisions and assess their own work.Most current methods rely on quick, one-off tweaks and learning strategies that need lots of resources and hands-on tech help Tian et al. (2024).This paper introduces a self-reflection mechanism, showing that LLMs can keep getting better and produce higher quality work across different tasks, all without needing extra training.</p>
<p>Memory Mechanism for LLM-based Agents</p>
<p>In LLM-based agents, the memory module stores, processes, and retrieves task-related information, supporting knowledge accumulation, experience handling, and decision-making.</p>
<p>To enhance the self-evolution capabilities of these agents, researchers are focused on designing and optimizing these memory modules Raffel et al. (2020).Past research has covered various designs and implementations of memory modules.This includes integrating information from different trials to boost reasoning abilities or storing information in natural language to enhance the module's interpretability and user-friendliness Wada et al. (2019).Despite progress, self-adjustment and memory management still need improvement to handle complex real-world problems more effectively.</p>
<p>Figure 1: An illustration of the SAGE: a user provides a description and instance to the assistant with short-term (STM) and long-term (LTM) memory.The assistant performs observation, action, reflection, and output, which the checker reviews.The retention rate curve on the right illustrates memory decay over time, with a self-evolving loop guiding continued updates.</p>
<p>Method</p>
<p>In this section, we present the SAGE framework, designed to improve agent performance by leveraging three core mechanisms: iterative feedback, reflection, and MemorySyntax (as shown in Figure 1).The assistant agent A iteratively updates its policy π θ based on feedback f t provided by the checker agent C, optimizing over successive iterations to maximize the expected reward R. The reflection mechanism allows A to incorporate historical observations O t and actions a t , forming a self-reflection r t , which is stored in the memory M L for future decision-making.Finally, MemorySyntax combines the Ebbinghaus forgetting curve with linguistic principles to manage memory decay, dynamically updating the agent's short-term memory M S and long-term memory M L by prioritizing information based on its retention strength S(I t ), thus improving the agent's ability to retain crucial information while discarding less relevant data.The subsequent subsections detail these components.</p>
<p>Iterative Feedback</p>
<p>The iterative feedback mechanism in the SAGE framework enables the assistant agent A to refine its policy π θ through repeated interactions with the checker agent C. At each iteration t, the assistant receives feedback f t based on its current output o t , and adjusts its policy accordingly.This process continues until the checker validates the output or the iteration cap N is reached, ensuring that A incrementally optimizes its decisions to improve task performance over successive iterations.</p>
<p>Initialization Phase</p>
<p>Role Assignment.In the SAGE framework, three agents are introduced: the user U, the assistant A, and the checker C. The user, upon receiving prompt P U , assumes the role of task proposer by specifying a task T U and related constraints C U .The assistant, upon receiving prompt P A , generates a sequence of actions a t based on the observations O t and environment E .The checker C evaluates the output o A produced by the assistant, providing feedback f C based on the discrepancy between o A and the expected result, updating its policy π θ iteratively to minimize this gap.Task Assignment.The task T U provided by the user includes an initial task description d U and an instance i U that serves as the reference for correct output.This forms the input set I A = (d U , i U ) for the assistant to initiate its generative process.The assistant then proceeds by selecting an action a t at each time step t, guided by π θ , with the goal of maximizing the reward R t for completing T U . Figure 2: An example of the assistant's iterative workflow, including checker evaluation, prompt templates for feedback, and reflection processes integrating short-term and longterm memory.</p>
<p>Actual Interaction Phase</p>
<p>Following the role assignment and task definition in the initialization phase, the assistant A transitions into the actual interaction phase to generate outputs aimed at accomplishing the task T U .In this phase, A iteratively produces outputs o t at each time step t based on the task description d U and instance i U provided in the input set I A = (d U , i U ).At each time step t, the assistant selects an action a t by following its policy π θ , which is conditioned on the current state s t , the reward signal R t (the reward score for task performance), and feedback f i t from the checker C.This decision-making process is formalized as:
o t ∼ π θ (o t | s t , R t , f i t ),(1)
where π θ represents the assistant's policy, R t reflects the reward signal based on task performance at time t, and f i t is the feedback provided by the checker during the i-th iteration.</p>
<p>As the interaction progresses, the checker C evaluates each output o t generated by A, comparing it against the expected outcome derived from i U .Based on this comparison, the checker provides iterative feedback f i t to guide A in refining its actions a t and outputs o t .The iterative refinement continues until either the checker validates the output as correct or the iteration limit N is reached.</p>
<p>Theoretical optimality of iterative feedback mechanism.In the SAGE framework, the assistant repeatedly updates its policy through this checker feedback, enabling the outputs to be incrementally refined until either the result is validated or a specified iteration limit is reached.The assistant's utility R A reflects task performance, and the checker's utility R C depends on its feedback.The following theorem indicates that this iterative feedback mechanism leads to strategy stability in the sense of a Nash equilibrium Fudenberg &amp; Tirole (1991).</p>
<p>Theorem 3.1 (Theory for the multi-agent iterative feedback system).Let U , A, C denote the compact, convex strategy spaces of the user (U), assistant (A), and checker (C), respectively.Assume that the utility functions
R U : U × A × C → R, R A : U × A × C → R, and R C : U × A × C → R (2)
are continuous in each player's strategy.Then, by the Debreu-Glicksberg-Fan fixed-point theorem, there exists a Nash equilibrium
(s * U , s * A , s * C ) ∈ U × A × C. (3)
Furthermore, suppose that the assistant's policy π θ is updated via policy gradient methods and that the checker's strategy is refined through convex optimization.Then, the iterative update procedures yield sequences
{π (k) θ } k≥0 and { f (k) } k≥0 ,(4)
which converge to a stable strategy profile (π * θ , f * ), and has:
R A (π * θ , f * ) ≥ R A (π θ , f * ), R C (π * θ , f * ) ≥ R C (π * θ , f ). (5)
This result demonstrates that the iterative feedback mechanism enhances the model's strategy stability by converging to a Nash equilibrium in the three-player game.It provides a stronger justification for the three-agent system versus simpler alternatives (such as two-agent systems).For the detailed theoretical explanation and proof, see A.2.</p>
<p>Evolutionary Goals and Directions</p>
<p>Leveraging the feedback f i t obtained at each iteration t, the assistant A formulates new evolutionary objectives:
G t+1 = (A t+1 , D t+1 ), D t+1 = arg min D t ∈∆ ∑ i∈I t L D D t ; f i t , π t θ ,(6)
where A t+1 represents the updated memory optimization mechanisms, and D t+1 ∈ ∆ refers to the model's self-adjustments to make the RL algorithm converge.These evolutionary objectives guide the assistant in updating its policy π θ for the subsequent iteration.The policy update is governed by the function ψ, which integrates the current policy π t θ with the new evolutionary objectives G t+1 :
θ t+1 = ϕ θ t , G t+1 = θ t + α∇ θ λ A L A θ t , A t+1 + λ D L D θ t , D t+1 . (7)
Here L A (θ, A) and L D (θ, D) are MSE loss functions corresponding to the memoryoptimization and self-adjustment aspects, respectively, and λ A , λ D ≥ 0 are weighting coefficients.The iterative policy refinement enables the assistant A to continuously adapt its strategies based on cumulative feedback and evolving task requirements, thereby improving its overall performance in dynamic environments.</p>
<p>Memory Management</p>
<p>The SAGE framework implements a dual-memory system, consisting of Short-Term Memory (STM) and Long-Term Memory (LTM), to manage task-relevant information and enhance the agent's reasoning and decision-making capabilities (see Figure 2 for a visual representation of this process).</p>
<p>Short-Term Memory (STM).</p>
<p>STM is responsible for storing immediate, task-specific data with limited capacity.It updates rapidly with new observations (O t ) and actions (a t ), maintaining a recent trajectory history T t = (O t , a t ).This allows the agent to make real-time decisions and respond quickly to dynamic changes in the environment Mnih et al. (2015).</p>
<p>Long-Term Memory (LTM).</p>
<p>LTM retains critical information and self-reflections (r t ) over extended periods, enabling the agent to accumulate knowledge from past interactions and apply it to future tasks.Stored as M L = {r t | t ∈ T}, this memory mechanism allows the agent to use prior experiences to improve task performance, particularly in complex environments that require long-span information Graves et al. (2016).</p>
<p>By integrating STM and LTM, the SAGE framework allows the agent to balance immediate task demands with the ability to draw from accumulated knowledge, thereby enhancing its overall decision-making efficiency.</p>
<p>Reflection</p>
<p>Figure 4 illustrates an example of the reflection mechanism applied to a HotpotQA task Yang et al. (2018b).The reflection mechanism equips the assistant A with sparse reward signals, such as binary success/failure states, trajectory T t , and its stored memory M L .The assistant processes these inputs, deriving insights from past performance and storing self-reflections r t for future decision-making.These self-reflections, richer than scalar rewards, enhance the assistant's learning capacity and are incorporated into long-term memory:
r t = ref(o 1:t , R 1:t ),(8)
where ref(•) denotes the reflection function based on the output sequence o 1:t and rewards R 1:t .The derived reflection r t is then added to M L :
M L ← M L ∪ {r t }. (9)
The process gradually enhances the agent's decision-making, allowing it to adapt effectively through accumulated experience.</p>
<p>MemorySyntax</p>
<p>Building upon the reflection mechanism, the MemorySyntax method integrates the Ebbinghaus forgetting curve with linguistic principles to emulate human-like memory processes within the agent's memory management system.Let I t denote the information received at time t, and let R(I t , τ) represent its retention rate after a time interval τ.According to the Ebbinghaus forgetting curve, the retention rate is modeled as:
R(I t , τ) = e − τ S , (10)
where S is the strength of the information, reflecting its importance and complexity.</p>
<p>To enhance retention, MemorySyntax applies linguistic optimization to I t , producing an optimized version I * t with increased strength S * &gt; S. The retention rate for I * t is defined as:
R(I * t , τ) = e − τ S * , if I * t ∈ M S , e − τ S , if I * t ∈ M L ,(11)
where M S and M L represent short-term memory and long-term memory, respectively.The agent updates its memory state M t based on the retention rate of I * t using predefined thresholds θ 1 and θ 2 , with θ 1 &gt; θ 2 .The memory update rule is formalized as:
M t+1 =    M t ∪ {I * t }, if R(I * t , τ) ≥ θ 1 , M t \ {I * t }, if R(I * t , τ) &lt; θ 2 , M t , otherwise.(12)
This update rule operates under the following conditions:
• Retention in Short-Term Memory (M S ): If R(I * t , τ) ≥ θ 1 , the information I * t is retained in short-term memory M S . • Discarding Information: If R(I * t , τ) &lt; θ 2 , the information I * t is considered insignificant and is discarded. • Transfer to Long-Term Memory (M L ): If θ 2 ≤ R(I * t , τ) &lt; θ 1 , the information I * t is transferred to long-term memory M L .
The above MemorySyntax method is optimal and ensures maximal information utility.For theoretical background and detailed proof, see Appendix A.1.</p>
<p>By simulating human memory dynamics, MemorySyntax enables the agent to prioritize essential information, retain critical data in short-term memory M S , store important but less frequently used information in long-term memory M L , and discard irrelevant data.The mechanism addresses memory capacity limitations and enhances the agent's ability to perform complex tasks requiring efficient memory management.</p>
<p>Experiment</p>
<p>To demonstrate the capabilities and performance of SAGE in coordinating autonomous agent groups to work together on tasks, we conduct extensive quantitative experiments on benchmark tasks.We use a public benchmark, AgentBench Liu et al. (2023b), which is a multidimensional evolutionary benchmark from which we select six tasks.These tasks test the reasoning and decision-making abilities of LLMs acting as agents in multi-turn open-ended generation settings.To further assess the agents' long-context understanding, we select four widely adopted tasks related to long-text processing.These tasks reflect the agents' programming abilities(LCCGuo et al. ( 2023 2024), Qwen Bai et al. (2023), andChatGLM2 GLM et al. (2024).Dialogue history exceeding the model length limit is truncated, using greedy decoding.</p>
<p>Results</p>
<p>As shown in Table 1, our method significantly improves model performance on AgentBench, especially for smaller models.GPT-3.5 and GPT-4, despite already high scores, also show notable improvements with SAGE, up to 2.26x in the Database task.Llama2-7b is notably enhanced, showing the method's impact on weaker models.CodeLlama-7b and Qwen-1.8Balso see substantial gains.Qwen-1.8B,after applying our method, performs close to GPT-3.5, highlighting its potential as a general agent.Llama2, previously error-prone, shows a significant reduction in basic errors through feedback and memory optimization, proving that our method not only enhances agent capabilities but also reduces fundamental errors in complex tasks.4.9 14.9 14.9 14.9</p>
<p>Complex Problem-Solving Tasks Evaluation</p>
<p>We evaluated SAGE against baseline models on three tasks: long-form QA Akash et al.</p>
<p>(2023), multi-turn dialog Cui et al. (2020), and sequential task completion Stephens et al. (2012).As shown in Table 2, SAGE outperforms all baselines with significant gains, such as a 20.8% increase in answer accuracy for GPT-3.5 on HotpotQA Yang et al. (2018b) and a 17.3% improvement in task completion for Mistral-7b on ALFWorld Shridhar et al. (2021).Across all tasks, SAGE notably enhances answer accuracy, dialog coherence, and step completion.</p>
<p>Evaluation of Long-Context Tasks</p>
<p>We evaluated the agent's code generation and reasoning on four long-text tasks: LCC Dataset Mohler et al. (2016) 2017a) is a reading comprehension dataset with question-answer pairs and evidence paragraphs (filtered to over 1,000 words), also using answer F1 for evaluation.</p>
<p>We compared two self-refinement methods: Beam Search Kool et al. (2019), which integrates self-assessment through stochastic beam search, and Reflexion Shinn et al. ( 2023), which uses past trial experience in a verbal form.</p>
<p>Evaluation Results:</p>
<p>Code Completion Task: On the LCC dataset (Table 3), SAGE shows a slight improvement in F1 score (79.29) compared to Beam Search and Reflexion.Its memory mechanisms help refine code predictions, but the performance difference is not substantial in simpler tasks like code completion.</p>
<p>Reasoning Tasks: SAGE significantly outperforms Reflexion and Beam Search on HotPotQA and TriviaQA, with F1 scores of 22.06 and 22.76 (Table 3).SAGE's ability to effectively integrate multi-document information through reflection leads to better reasoning accuracy, while Reflexion and Beam Search face challenges in handling complex reasoning tasks.2019), and TriviaQA).RAG with BM25 relies on term-based matching, while RAG with DPR uses learned dense embeddings.TART adopts a transformer-based approach to produce relevant contexts, and FiD fuses multiple retrieved passages through an encoder-decoder design.In contrast, ChatGPT-4 (SAGE) employs a structured reasoning workflow for retrieval and generation, which leads to steady accuracy improvements of 3.6% to 4.7% and cuts memory consumption nearly 50% on some tasks, all without increasing latency.</p>
<p>Evaluation of RAG Agents</p>
<p>Error analysis</p>
<p>As shown in Figure 3, the SAGE framework significantly enhances agent performance across tasks, especially in the WS task for AgentBench, due to its iterative feedback mechanism, which refines outputs through continuous assistant-checker interaction.In OS and DB tasks, Context Limit Exceeded and invalid format errors are nearly eliminated, with a notable reduction in invalid action errors, attributed to the reflection mechanism that helps the assistant learn and reduce logical mistakes.</p>
<p>Ablation Study</p>
<p>We conducted ablation experiments on Qwen-1.8B and CodeLlama-7B to evaluate memory optimization (Table 5).Without memory optimization, both models perform weakly, especially Qwen-1.8B,which improves from 6.8 to 48.0 in KG and from 0.0 to 10.5 in ALF after optimization.Similarly, CodeLlama-7B shows substantial gains, particularly in DB (2.7 to 41.3) and WS (14.3 to 58.7).Overall, CodeLlama-7B performs better than Qwen-1.8B,highlighting the stronger adaptability of models with more parameters in handling complex tasks.</p>
<p>Conclusion</p>
<p>In this paper, we propose the SAGE framework, which enhances agents' self-adjustment and memory management in complex tasks through reflective mechanisms and memory optimization.Experimental results show significant performance improvements across benchmarks, especially in smaller models.In the AgentBench test, SAGE boosts the performance of strong baselines like GPT-3.5 and GPT-4, while also significantly improving open-source models.It effectively reduces basic errors and logical mistakes, particularly enabling smaller models to handle complex tasks.</p>
<p>Ziqi Zhou, Jingyue Zhang, Jingyuan Zhang, Yangfan He, Boyue Wang, Tianyu Shi, and Alaa Khamis.Human-centric reward optimization for reinforcement learning-based automated driving using large language models.arXiv preprint arXiv:2405.04135,2024.</p>
<p>Figure 4: The illustration of an example HotpotQA with SAGE.</p>
<p>A Theoretical Analysis</p>
<p>A.1 An Information-Theoretic Perspective on Memory Optimization Based on the Ebbinghaus Forgetting Curve</p>
<p>The memory optimization mechanism proposed in this work is grounded in the Ebbinghaus forgetting curve.It dynamically manages short-term memory (STM) and long-term memory (LTM) by prioritizing the retention of essential information while discarding irrelevant data.This mechanism can be viewed as computing the retention strength S(I t ) of each information unit based on its information entropy.Theoretically, one can interpret this as maximizing information entropy to show that the mechanism effectively mitigates the issue of information overload Cover &amp; Thomas (2006).That is, by preferentially retaining highentropy (i.e., high-uncertainty) information, the model improves its information processing efficiency.</p>
<p>First, the retention strength of information is defined as:
S(I t ) = H(I t ) f (t) (13)
where the numerator H(I t ) represents the information entropy of the content at time t, and f (t) models the forgetting curve.</p>
<p>The objective of memory optimization is to maximize the utility of retained information under a memory capacity constraint:
max ∑ t M t • S(I t ), s.t. ∑ t M t ≤ C (14)
Here, C represents the total memory capacity, and M t ∈ {0, 1} denotes whether the information at time t is retained (1) or discarded (0).</p>
<p>Using the method of Lagrange multipliers, we construct the Lagrangian function:
L(M t , λ) = ∑ t M t • S(I t ) − λ ∑ t M t − C (15)
Taking the derivative of L, which is the optimal memory retnetion, with respect to M t and setting it to zero yields the optimality condition:
∂L ∂M t = S(I t ) − λ = 0 ⇒ Retain I t if S(I t ) ≥ λ Discard I t if S(I t ) &lt; λ (16)
This rule is consistent with the threshold-based memory retention strategy used in the SAGE framework.</p>
<p>A.2 Iterative Feedback and Game-Theoretic Model</p>
<p>Multi-agent systems often depend on reinforcement learning (RL) methods, making their theoretical basis essential for ensuring that algorithms converge to stable solutions, such as Nash equilibria Fudenberg &amp; Tirole (1991).The subsequent theory provides a formal guarantee of convergence, showing that our proposed algorithm is not randomly designed.Instead, it surpasses standard approaches by establishing robust criteria that confirm both its stability and performance advantages.</p>
<p>A.2.1 Players and Their Strategy Spaces Settings</p>
<p>User (U) : Provides a task description T U and constraints C U .Assistant (A) : Chooses actions a t ∼ π θ (• | s t ), where π θ is the policy.Checker (C) : Generates feedback f t aimed at reducing the error ∥o
t − o * ∥ F ,(17)
where o t is the output of the assistant and o * is the expected (ground-truth) output, ∥ • ∥ F denotes the Frobenius norm.</p>
<p>For the Utility Functions, we have: Assistant's Utility, R A : Measures task performance (e.g., BLEU score, accuracy):</p>
<p>R A = Task Performance Metric of a t .Checker's Utility, R C : Measures feedback accuracy by reduction of error:
R C ∝ ∆∥o t − o * ∥ F .(18)
The overall interaction can be viewed as a three-player game in which: The assistant (A) optimizes its policy π θ to maximize R A , while the checker (C) aims to minimize ∥o t − o * ∥ (i.e., maximize R C ) The user U sets the task and constraints that guide both the assistant and checker's performances.Next we want to show that it can be shown that under a finite strategy space and continuous utility functions, a Nash equilibrium exists in this multi-agent game.</p>
<p>A.2.2 Setup for the proof of theorem 3.1</p>
<p>First, we want to write a road map for this proof.</p>
<p>• It can be shown that under a finite strategy space and continuous utility functions, a Nash equilibrium exists in this multi-agent game.</p>
<p>• According to the Debreu-Glicksberg-Fan Theorem (a generalization of Nash's existence theorem), if each player's strategy space is a compact convex set and the utility functions are continuous and quasi-concave (or concave) in their own strategies, then at least one Nash equilibrium exists.</p>
<p>• Then, the assistant's policy π θ is updated using policy gradient methods.Since R A is a continuous function of π θ , the assistant's utility is continuous.</p>
<p>• After that, the checker's feedback strategy can be obtained via convex optimization (e.g., least-squares regression), and thus R C is a convex function.• Therefore, a Nash equilibrium (π * θ , f * ) exists, at which both the assistant and checker's strategies are stable with respect to each other:
π * θ = arg max π R A (π, f * ), f * = arg max f R C (π * θ , f )(19)
Let's start the proof.Lemma A.1.Let S 1 , S 2 , . . ., S N be finite strategy sets for each of N players, and let u i : S 1 × • • • × S N → R be continuous for each i.Then, there exists a Nash equilibrium in the multi-agent game.</p>
<p>Proof.For each player i, define the set of mixed strategies as
∆(S i ) = x i ∈ R |S i | x i (s) ≥ 0 for all s ∈ S i , ∑ s∈S i x i (s) = 1 . (20) Each set ∆(S i ) is a simplex in R |S i |
, and hence is nonempty, compact, and convex.Define the expected utility function for player i:
U i (x 1 , . . . , x N ) = ∑ (s 1 ,...,s N )∈S 1 ×•••×S N N ∏ j=1 x j (s j ) u i (s 1 , . . . , s N ).(21)
Since the strategy spaces are finite and u i is continuous (and hence bounded on the finite set), the function U i is continuous on the product space ∏ N j=1 ∆(S j ).For each player i, define the best response correspondence as:
BR i (x −i ) = arg max x i ∈∆(S i ) U i (x i , x −i ),(22)
where x −i denotes the mixed strategies of all players other than i.Because ∆(S i ) is compact and U i is continuous and linear in x i (hence concave), the maximum exists and BR i (x −i ) is nonempty, convex, and compact.Now we define the overall best-response correspondence:
BR(x) = BR 1 (x −1 ) × BR 2 (x −2 ) × • • • × BR N (x −N ),(23)
where x = (x 1 , x 2 , . . ., x N ).The product space ∏ N i=1 ∆(S i ) is compact and convex, and the correspondence BR has nonempty, convex, and compact values and is upper hemicontinuous (due to the continuity and linearity of the expected utilities).Hence, by Kakutani's fixed point theorem, there exists a fixed point
x * = (x * 1 , x * 2 , . . . , x * N ) ∈ N ∏ i=1 ∆(S i )(24)
such that x * ∈ BR(x * ).</p>
<p>(25) This fixed point is a Nash equilibrium in mixed strategies.Thus, under a finite strategy space and continuous utility functions, a Nash equilibrium exists.According to the Debreu-Glicksberg-Fan Theorem (a generalization of Nash's existence theorem), if each player's strategy space is a compact convex set and the utility functions are continuous and quasi-concave (or concave) in their own strategies, then at least one Nash equilibrium exists.</p>
<p>Lemma A.2.By Lemma A.1, Let I = {1, 2, . . ., n} be the set of players.For each player i, let X i ⊂ R d i be a compact, convex strategy set, and define X = ∏ n i=1 X i .Suppose each player's utility function u i : X → R is continuous on X and quasi-concave (or concave) in the coordinate x i for fixed x −i .Then, by the Debreu-Glicksberg-Fan theorem, there exists at least one Nash equilibrium
x * = (x * 1 , x * 2 , . . . , x * n ) ∈ X.
differentiable with continuous gradient), the gradient ∇ θ F is well-defined.The policy gradient update is thus a continuous map from θ k to θ k+1 .</p>
<p>Because the update at each iteration is based on the gradient (which is continuous) of the assistant's utility F(θ), any small perturbation in θ results in only a small variation in both the gradient and the updated parameter.This demonstrates that the update procedure is stable in the sense that the assistant's utility, R A (π θ ) = F(θ), continuously varies under the sequence of policy gradient updates Sutton &amp; Barto (2018).</p>
<p>Thus, since R A is a continuous function of π θ and π θ depends continuously on θ, the assistant's utility is continuous, and the policy gradient update is well-defined.</p>
<p>Then we want to prove that, the checker's feedback strategy can be obtained via convex optimization (e.g., least-squares regression), and thus R C is a convex function.</p>
<p>Lemma A.4.Let F be a convex subset of a vector space, and suppose the checker's feedback strategy is given by a function f ∈ F obtained as a solution to the convex optimization problem
min f ∈F J( f ) = n ∑ i=1 y i − f (x i ) 2 , (34)
where x i are given inputs and y i are target outputs.Define the checker's utility function
R C ( f ) = J( f ). (35)
Then R C is a convex function on F ; that is, for any f 1 , f 2 ∈ F and any λ ∈ [0, 1] it holds that
R C λ f 1 + (1 − λ) f 2 ≤ λR C ( f 1 ) + (1 − λ)R C ( f 2 ).(36)
Proof.We prove the convexity of R C by verifying that the squared-error loss is a convex function and that convex combinations preserve convexity.</p>
<p>For each data point i, consider the function
ℓ i ( f ) = y i − f (x i ) 2 . (37)
Since for any real number t, the function t 2 is convex, and the mapping f → y i − f (x i ) is affine (and hence convex), the composition f → y i − f (x i ) 2 is convex.In particular, for any f 1 , f 2 ∈ F and λ ∈ [0, 1],
ℓ i λ f 1 + (1 − λ) f 2 ≤ λℓ i ( f 1 ) + (1 − λ)ℓ i ( f 2 ).(38)
Since the checker's overall loss (and hence utility function)
R C ( f ) = n ∑ i=1 ℓ i ( f )(39)
is a finite sum of convex functions, it follows that R C is convex on F ; that is, for any
f 1 , f 2 ∈ F and λ ∈ [0, 1], R C λ f 1 + (1 − λ) f 2 = n ∑ i=1 ℓ i λ f 1 + (1 − λ) f 2 ≤ λ n ∑ i=1 ℓ i ( f 1 ) + (1 − λ) n ∑ i=1 ℓ i ( f 2 ) = λR C ( f 1 ) + (1 − λ)R C ( f 2 ).(40)
Thus:
R C ( f ) = n ∑ i=1 y i − f (x i ) 2 is convex on F .(41)
Thus, the checker's feedback strategy derived via convex optimization (e.g., least-squares regression) ensures that the corresponding utility function R C is convex.</p>
<p>A.2.3 The formal proof of theorem 3.1</p>
<dl>
<dt>We want to rewrite the theorem 3.1 into the following lemma based on the former lemmas: Lemma A.5 (theorem 3.1).Suppose the assistant's strategy space Π and the checker's strategy space F are nonempty, compact, and convex sets.Assume that: R A</dt>
<dd>Π × F → R is continuous in π for fixed f , R C : Π × F → R is convex in f for fixed π. Then there exists a Nash equilibrium π * θ , f * defined by π * θ = arg max π∈Π R A (π, f * ) and f * = arg max f ∈F R C (π * θ , f ).(42)
Proof.For each fixed f ∈ F define the assistant's best-response set:
BR A ( f ) = {π ∈ Π : R A (π, f ) = max π ′ ∈Π R A (π ′ , f )}. (43)
By hypothesis (i) and the compactness of Π, the maximum is attained and BR A ( f ) is nonempty.(Continuity of R A assures that small changes in f lead to small changes in R A (•, f ).)</dd>
</dl>
<p>Similarly, for each fixed π ∈ Π define the checker's best-response set:
BR C (π) = { f ∈ F : R C (π, f ) = max f ′ ∈F R C (π, f ′ )}. (44)
Since hypothesis (ii) implies that R C is convex in f and F is convex and compact, we conclude that BR C (π) is nonempty, convex, and closed.</p>
<p>Consider the correspondence
H : Π × F → Π × F , H(π, f ) = BR A ( f ) × BR C (π).(45)(π * , f * ) ∈ Π × F such that (π * , f * ) ∈ H(π * , f * ).(46)
By the definition of H, the fixed point satisfies
π * ∈ BR A ( f * ) and f * ∈ BR C (π * ),(47)
which is equivalent to
π * = arg max π∈Π R A (π, f * ) and f * = arg max f ∈F R C (π * , f ).(48)
Thus, no unilateral deviation by either the assistant or the checker increases the respective utility; in other words, the strategy pair (π * , f * ) is a Nash equilibrium.</p>
<p>B Detailed Dataset Information</p>
<p>(1) Operating systems (OS) Integrating LLMs into operating systems has immense potential for automating and optimizing tasks.This integration requires a secure, user-friendly interface to ensure effective LLM-OS interaction.LLMs must accurately understand the OS context for informed operations, prioritizing safety to prevent misuse.Additionally, the system should effectively handle errors and provide clear feedback to users, enhancing overall interaction and control.Addressing these aspects can transform computer interaction and efficiency across various industries.</p>
<p>(2) Database (DB) The ability of LLMs to operate on real databases via SQL is critical due to the importance and complexity of database analysis in everyday activities.</p>
<p>Previous research has highlighted the effectiveness of LLMs in automating database access, such as with T5QL, a new SQL generation method.Furthermore, fine-tuned LLMs (like GPT-3.5)have demonstrated the ability to extract and link complex scientific information from texts, obtaining structured knowledge from unstructured text and building extensive databases.</p>
<p>(3) WebShop (WS) WebShop is an innovative simulation of an e-commerce website environment, featuring 1.18 million real-world products and 12,087 crowd-sourced text instructions.It challenges agents to navigate various types of webpages and perform diverse actions to find, customize, and purchase products based on given instructions.WebShop's challenges include understanding compositional instructions, query (re-)formulation, dealing with noisy text on webpages, and strategic exploration.</p>
<p>(4) Knowledge Graphs (KG) LLMs' utilization in constructing and interacting with knowledge graphs (KG) presents a promising opportunity to enhance semantic understanding and information retrieval.This involves assessing the models' ability to generate and interpret complex interrelations within data, facilitating more intuitive and context-aware responses.Effective LLM performance in this domain could significantly improve AI's reasoning and decision-making capabilities based on structured knowledge.</p>
<p>(5) Mind2Web (M2W) Mind2Web (M2W) is a dataset designed for developing web agents capable of performing complex tasks on real websites via language instructions.It features over 2,000 tasks across 137 sites from 31 domains.M2W's real web environments and diverse user interactions make it a crucial platform for advancing AI navigation capabilities.</p>
<p>(6) ALFWorld (ALF) ALFWorld bridges interactive TextWorld environments with embodied tasks from the ALFRED dataset, enabling agents to learn abstract strategies and apply them to real-world tasks.It supports abstract reasoning and concrete execution, allowing agents to plan actions in a text-based simulator and execute these tasks in a visual environment.This approach enhances agent generalization and problem-solving skills across various domains, such as language understanding and visual navigation, by leveraging a modular design that simplifies research improvements.</p>
<p>C Comparison with Task-Splitting Agents</p>
<p>To compare the SAGE framework with existing agents across various task types and datasets, we conducted a comprehensive evaluation.The results are detailed in Table 6.SAGE demonstrates superior performance in task completion time, answer accuracy, dialog coherence, and step completion accuracy, highlighting its effectiveness in managing complex, multifaceted tasks.</p>
<p>), RepoBench-PLiu et al. (2023a)) and reasoning abilities(HotpotQA Yang et al. (2018b), TriviaQA Joshi et al. (2017b)).4.1 Evaluation onAgentBench Task Description AgentBench includes scenarios from CODE (Knowledge Graph, OS, DB), GAME (ALFWorld) Shridhar et al. (2021), and WEB (WebShop Yao et al. (2023a), Mind2Web Deng et al. (2023)).For more details for the datasets and benchmarks, see Appendix B. Baselines We evaluate commercial models GPT-3.5 Brown et al. (2020) and GPT-4 OpenAI et al. (2024), and open-source models Llama2 Touvron et al. (2023), Codellama Rozière et al. (</p>
<p>Figure 3 :
3
Figure 3: Execution results across six tasks (CLE: Context Limit Exceeded, TLE: Task Limit Exceeded).Task limits are the main cause of incomplete tasks, highlighting LLM agents' limitations under time constraints.</p>
<p>Table 1 :
1
Baseline and SAGE Framework Performance on AgentBench
LLM TypeModelVEROSDBKGALFWSM2WBaseSAGEBaseSAGEBaseSAGEBaseSAGEBaseSAGEBaseSAGEBaseSAGEAPIGPT-4 GPT-3.542.4 31.649.7 38.332.0 15.739.8 35.657.4 25.963.1 37.678.0 17.082.0 23.067.1 64.167.8 72.127.0 16.032.0 28.027.0 16.032.0 28.0Llama2-7B Chat0.08.40.010.20.025.00.05.04.410.40.015.00.015.0CodeLlama-7B Instruct5.718.42.619.20.027.00.012.516.340.20.015.015.015.0OSSQwen1.8B Chat2.718.71.415.16.845.30.010.56.611.40.613.613.613.6Qwen-7B Chat5.622.24.818.00.048.034.038.50.013.60.015.015.015.0ChatGLM2-6B v1.10.015.20.016.30.017.00.05.00.310.3</p>
<p>Table 2 :
2
Evaluation of SAGE and Baseline Models on Three Different Tasks
AgentTask Completion Time (min)Answer Accuracy Dialog Coherence Step Completion (QA)(%) (%) Accuracy (%)GPT-3.5 (Baseline)Long-form QA (HotpotQA)54.1%48.5%62.7%GPT-4 (Baseline)Long-form QA (HotpotQA)61.2%53.8%68.2%Llama2-7b (Baseline)Multi-turn Dialog (MultiWOZ)55.9%50.1%64.8%Codellama-13b (Baseline) Multi-turn Dialog (MultiWOZ)58.4%52.3%66.7%Mistral-7b (Baseline)Sequential Task (ALFWorld)56.5%51.5%65.1%SAGE-GPT-3.5Long-form QA (HotpotQA)74.9% (+20.8%)68.3% (+19.8%)80.6% (+17.9%)SAGE-GPT-4Long-form QA (HotpotQA)78.4% (+17.2%)73.4% (+19.6%)83.9% (+15.7%)SAGE-Llama2-7bMulti-turn Dialog (MultiWOZ) 72.2% (+16.1%)67.9% (+17.8%)78.5% (+13.7%)SAGE-Codellama-13bMulti-turn Dialog (MultiWOZ) 74.7% (+16.3%)71.2% (+18.9%)81.2% (+14.5%)SAGE-Mistral-7bSequential Task (ALFWorld)73.8% (+17.3%)70.5% (+19.0%)79.9% (+14.8%)
Yang et al. (2018a)ng the next line of code from a few initial lines, with Precision, Recall, and F1 as metrics.RepoBench-PLiu et al. (2024)tests retrieval of relevant code snippets from cross-file and within-file contexts to predict the next line, also evaluated with Precision, Recall, and F1.HotPotQAYang et al. (2018a), a Wikipedia-based dataset with 113k question-answer pairs, challenges the agent to reason across multiple documents, evaluated by answer F1.TriviaQAJoshi et al. (</p>
<p>Table 3 :
3
Comparison of Performance Across Different Methods
ModelsLCCRepoBench-PHotpotQA TriviaQAPrecision RecallF1Precision RecallF1F1F1Reflexion77.7281.00 79.2878.7381.86 80.2511.2611.23Beam search78.9879.32 79.1278.7581.02 79.8710.2612.13SAGE78.7679.88 79.2979.2783.28 81.2222.0622.76</p>
<p>Table 4
4compares classical lexical retrieval (RAG with BM25) Robertson &amp; Zaragoza (2009),dense passage retrieval (RAG with DPR) Reichman &amp; Heck (2024), a commercial retrievalsolution (RAG with OpenAI Retrieval) OpenAI (2023), the TART Eisenschlos et al. (2022)sequence-to-sequence retrieval model, and the FiD (Fusion-in-Decoder) method Izacard&amp; Grave (2021), all tested on multi-document and open-domain QA tasks (HotpotQA,Natural Questions Kwiatkowski et al. (</p>
<p>Table 4 :
4
Evaluation of different RAG Agents on Different Tasks and Datasets
AgentAccuracy (QA) (%) Latency (ms) Memory Usage (MB)Task 1: Multi-Document QA (HotpotQA)RAG (BM25)60.8121RAG (DPR)66.3129RAG (OpenAI Retrieval)67.4108TART63.2144FiD (Fusion-in-Decoder)70.1153ChatGPT-4 -Sage74.8 (+4.7)128(-50%)Task 2: Document Retrieval for Contextual Answering (Natural Questions)RAG (BM25)59.9125RAG (DPR)65.5131RAG (OpenAI Retrieval)66.8113TART62.4146FiD (Fusion-in-Decoder)69.8156ChatGPT-4 -Sage73.6 (+3.8)131(-49%)Task 3: Open-Domain QA with Multiple Contexts (TriviaQA)RAG (BM25)62.1124RAG (DPR)67.8129RAG (OpenAI Retrieval)68.9117TART64.7148FiD (Fusion-in-Decoder)71.9155ChatGPT-4 -Sage75.5 (+3.6)134(-47%)</p>
<p>Table 5 :
5
Ablation study for memory optimization on the task of AgentBench
ModelsOS DBKG ALF WS M2WQwen-1.8B (w/o memo)10.4 22.6 6.80.026.65.0Qwen-1.8B (w memo)18.7 28.3 45.3 10.5 31.425.1Codellama-7B (w/o memo) 9.72.70.00.014.35.0Codellama-7B (w memo)23.4 41.3 48.0 12.5 58.715.0</p>
<p>Table 6 :
6
Evaluation of Task-Splitting SOTA Agents on Different Task Types and Datasets
AgentTask Completion Answer Accuracy Dialog Coherence Step Completion Time (min) (QA)(%) (%) Accuracy (%)Task 1: Long-form Question Answering (HotpotQA)BabyAGI7.874.1--AutoGPT8.176.3--HuggingGPT6.779.2--LangChain Agent7.977.0--TaskMatrix.AI6.580.3--SAGE -ChatGPT-410.682.5 (+6.0)--Task 2: Multi-turn Dialog Completion (MultiWOZ)BabyAGI8.2-73.5-AutoGPT8.5-75.6-HuggingGPT7.1-78.1-LangChain Agent8.3-76.5-TaskMatrix.AI6.8-79.9-SAGE -ChatGPT-410.9-81.6 (+5.8)-Task 3: Sequential Task with Dependencies (ALFWorld)BabyAGI8.7--71.5AutoGPT8.3--73.1HuggingGPT7.5--75.2LangChain Agent7.8--72.8TaskMatrix.AI6.6--76.4SAGE -ChatGPT-410.7--82.3 (+5.9)
Proof.For each player i, define the best-response correspondenceSince u i is continuous and X i is compact, the maximum is attained; hence, BR i (x −i ) ̸ = ∅.The quasi-concavity (or concavity) of u i in x i ensures that the setis convex for any α ∈ R. In particular, the set BR i (x −i ) is convex for every fixed x −i .The continuity of u i implies that the best-response correspondence BR i is upper hemicontinuous.This means that for any sequence {x (k)−i } converging to x −i and any corresponding sequence {xNow we define the aggregate best-response correspondence:where(3) The correspondence BR is upper hemicontinuous.By the Debreu-Glicksberg-Fan fixed point theorem, there exists a fixed pointThis means that no player can unilaterally deviate from x * and increase their utility, which is precisely the definition of a Nash equilibrium.Next, based on the above Lemmas, we want to prove that the assistant's policy π θ is updated using policy gradient methodsSutton &amp; Barto (2018).Since R A is a continuous function of π θ , the assistant's utility is continuous.Lemma A.3.Let Θ denote the parameter space for the assistant's policy π θ , and let the assistant's utility be given by Rwhere f : Π → R is a continuous function on the space Π of policies.Assume that the mapping θ → π θ is continuous.Then the composite functionis continuous in θ.Moreover, since the assistant's policy is updated using policy gradient methods, the update rule) employs the gradient of a continuous function.Proof.We divide the proof into two parts:Step 1: Continuity of the Utility Function.Since the mapping θ → π θ is continuous and the function f : Π → R is continuous by hypothesis, their composition F(θ) = f π θ is continuous in θ.Formally, for any ϵ &gt; 0, there exists a δ &gt; 0 such that for all θ, θStep 2: Policy Gradient Updates.In the policy gradient framework, the assistant updates its parameters according to the rule:where α k &gt; 0 is a (possibly diminishing) step size and ∇ θ F(θ k ) denotes the gradient of F evaluated at θ k .Since F is continuous (and under typical smoothness assumptions,D ExamplesCases study on TriviaQA in using GPT with SAGE.User:Answer the question based on the given passages.Only give me the answer and do not output any other words.The following are given passages: History of canals in Great Britain -London Canal Museum History of canals in Great Britain Home &gt; History &gt; Canals in Britain In the history of canals, Britain was not a pioneer.The Chinese can claim that the Grand Canal of China was one of the first, in the tenth century,a. . . . . .Answer the question based on the given passages.Only give me the answer and do not output any other words.Question: Which metal is produced by the Bessemer Process?Answer:Assistant:The content of the file seems to be an HTML document related to the administrative division of Turkey, including population statistics, charts, and maps.This file contains scripts, metadata, and structured data typical for a web page.Checker:Clear Objectives: When answering user questions, the focus should be on directly addressing the question without introducing irrelevant information.Document Handling: Before confirming whether the document content is relevant to the question, detailed aspects of the document should not be directly addressed.Reflection:Issue Description: The user wants to understand why the system outputs irrelevant HTML document content based on user input and seeks detailed feedback and reflection.Reasons for the Error: Misinterpretation of Input: The system mistakenly assumed that the user uploaded a file and attempted to read its content, whereas the user only provided text input.Processing Logic Error: Without clearly determining the user's intent, the system directly parsed and outputted file content.User Experience Problems: Irrelevant Output: The user expects concise, relevant answers, but the system provided lengthy and irrelevant HTML content, affecting the user experience.Poor Communication: Failure to accurately understand and respond to the user's real needs resulted in off-topic responses In-depth Reflection and Improvement Suggestions: Clarify User Intent: Accurate Parsing of User Input: Enhance the system's natural language processing capabilities to accurately distinguish whether the user uploaded a file or simply provided text input.User Feedback Mechanism: Implement a user feedback mechanism to promptly adjust the understanding of user intent.For example, confirm the issue to verify if the user uploaded a file.Optimize Processing Logic: Layered Processing Flow: In system design, separate file processing logic from text response logic to avoid misjudgments.For instance, when a user uploads a file, process the file content separately; when a user inputs text, provide relevant answers directly.Pre-processing Check: Prior to handling files, perform pre-processing checks to confirm if the file content meets expectations. . . . . . .LLMs with SAGE response: Steel.Ground truthSteel.Cases study on LCC in using GPT with SAGE.User: import networkx as nx import pickle from Queue import PriorityQueue import copy import random import string import sys class MultiDiGraphEdgeKey(nx.MultiDiGraph): . . . . . .Assistant:You will be given the history of a past experience where you were given a task and failed to complete it.Reflect on the strategy and actions taken.Checker:The given code is a part of the Camerini algorithm, which is used for ranking edges in a directed graph.This algorithm is particularly useful for problems involving the identification of optimal or near-optimal substructures, like arborescences or spanning trees, in complex networks.The algorithm has two main phases:Collapsing Phase: This phase identifies and collapses cycles in the graph, creating supernodes.This simplification helps in managing cycles more efficiently and prepares the graph for the expansion phase.Expanding Phase: After collapsing cycles into supernodes, this phase expands the supernodes back into their original structure, resulting in a ranked arborescence, where the edges are sorted or prioritized based on certain criteria. . . . . . .LLMsAssistant:To devise a new plan of action, let's analyze the previous mistakes and come up with a solution: Mistake 1: In the KadRefreshOperation class, the execute() method calls the BucketRefreshOperation and ContentRefreshOperation without any error handling or exception handling.This can lead to unexpected errors and failures.Solution: Add proper error handling and exception handling in the execute() method of the KadRefresh-Operation class.This will ensure that any errors or exceptions are properly handled and the execution can continue smoothly. . . . . .Checker:In the 'KadRefreshOperation' class, there is no error handling when the 'execute()' method calls 'BucketRefreshOperation' and 'ContentRefreshOperation'. Analysis: If 'BucketRefreshOperation' or 'ContentRefreshOperation' throws an exception, the entire 'execute()' method will fail, potentially causing the interruption of the entire system's refresh operation.In the 'StoreOperation' class, the 'execute()' method does not handle the case of existing content in the DHT.Analysis: The 'execute()' method always returns 1 as the number of storage nodes, which is clearly incorrect.
Long-form question answering: An iterative planning-retrieval-generation approach. Pritom Saha Akash, Kashob Kumar Roy, Lucian Popa, Kevin Chen, -Chuan Chang, 2023</p>
<p>. Jinze Bai, Shuai Bai, Yunfei Chu, Zeyu Cui, Kai Dang, Xiaodong Deng, Yang Fan, Wenbin Ge, Yu Han, Fei Huang, Binyuan Hui, Luo Ji, Mei Li, Junyang Lin, Runji Lin, Dayiheng Liu, Gao Liu, Chengqiang Lu, Keming Lu, Jianxin Ma, Rui Men, Xingzhang Ren, Xuancheng Ren, Chuanqi Tan, Sinan Tan, Jianhong Tu, Peng Wang, Shijie Wang, Wei Wang, Shengguang Wu, Benfeng Xu, Jin Xu, An Yang, Hao Yang, Jian Yang, Shusheng Yang, Yang Yao, Bowen Yu, Hongyi Yuan, Zheng Yuan, Jianwei Zhang, Xingxuan Zhang, Yichang Zhang, Zhenru Zhang, Chang Zhou, Jingren Zhou, 2023Xiaohuan Zhou, and Tianhang Zhu. Qwen technical report</p>
<p>. Tom B Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, Sandhini Agarwal, Ariel Herbert-Voss, Gretchen Krueger, Tom Henighan, Rewon Child, Aditya Ramesh, Daniel M Ziegler, Jeffrey Wu, Clemens Winter, Christopher Hesse, Mark Chen, Eric Sigler, Mateusz Litwin, 2020Scott Gray, Benjamin Chess, Jack Clark, Christopher Berner, Sam McCandlish, Alec RadfordIlya Sutskever, and Dario Amodei. Language models are few-shot learners</p>
<p>Elements of Information Theory. Thomas M Cover, Joy A Thomas, Wiley Series in Telecommunications and Signal Processing. 2006ISBN 0471241954</p>
<p>MuTual: A dataset for multiturn dialogue reasoning. Leyang Cui, Yu Wu, Shujie Liu, Yue Zhang, Ming Zhou, 10.18653/v1/2020.acl-main.130Proceedings of the 58th Annual Meeting of the Association for Computational Linguistics. Dan Jurafsky, Joyce Chai, Natalie Schluter, Joel Tetreault, the 58th Annual Meeting of the Association for Computational LinguisticsAssociation for Computational LinguisticsJuly 2020</p>
<p>Mind2web: Towards a generalist agent for the web. Xiang Deng, Yu Gu, Boyuan Zheng, Shijie Chen, Samuel Stevens, Boshi Wang, Huan Sun, Yu Su, 2023</p>
<p>Über das gedächtnis: untersuchungen zur experimentellen psychologie. Hermann Ebbinghaus, Duncker &amp; Humblot1885</p>
<p>TART: Retrieval-augmented generation for task-oriented dialog. Julian Eisenschlos, Yury Zemlyanskiy, Jason Phang, Bhuwan Dhingra, William W Cohen, Proceedings of the 60th Annual Meeting of the Association for Computational Linguistics (ACL). the 60th Annual Meeting of the Association for Computational Linguistics (ACL)2022</p>
<p>The state of the art in open domain complex question answering: a survey. Romina Etezadi, Mehrnoush Shamsfard, Applied Intelligence. 5342023</p>
<p>Game Theory. Drew Fudenberg, Jean Tirole, ; Team, Glm , Aohan Zeng, Bin Xu, Bowen Wang, Chenhui Zhang, Da Yin, Diego Rojas, Guanyu Feng, Hanlin Zhao, Hanyu Lai, Hao Yu, Hongning Wang, Jiadai Sun, Jiajie Zhang, Jiale Cheng, Jiayi Gui, Jie Tang, Jing Zhang, Juanzi Li, Lei Zhao, Lindong Wu, Lucen Zhong, Mingdao Liu, Minlie Huang, Peng Zhang, Qinkai Zheng, Rui Lu, Shuaiqi Duan, Shudan Zhang, Shulin Cao, Shuxun Yang, Weng Lam Tam, Wenyi Zhao, Xiao Liu, Xiao Xia, Xiaohan Zhang, Xiaotao Gu, Xin Lv, Xinghan Liu, Xinyi Liu, Xinyue Yang, Xixuan Song, Xunkai Zhang, Yifan An, Yifan Xu, Yilin Niu, Yuantao Yang, Yueyan Li, Yushi Bai, Yuxiao Dong, Zehan Qi, Zhaoyu Wang, Zhen Yang, Zhengxiao Du, Zhenyu Hou, Zihan Wang, 1991. 2024MIT PressCambridge, MAChatglm: A family of large language models from glm-130b to glm-4 all tools</p>
<p>Hybrid computing using a neural network with dynamic external memory. Alex Graves, Greg Wayne, Malcolm Reynolds, Tim Harley, Ivo Danihelka, Agnieszka Grabska-Barwi Ńska, Sergio Gómez Colmenarejo, Edward Grefenstette, Tiago Ramalho, John Agapiou, Nature. 53876262016</p>
<p>Longcoder: A long-range pre-trained language model for code completion. Daya Guo, Canwen Xu, Nan Duan, Jian Yin, Julian Mcauley, 2023</p>
<p>Enhancing intent understanding for ambiguous prompt: A human-machine co-adaption strategy. Yangfan He, Jianhui Wang, Kun Li, Yijin Wang, Li Sun, Jun Yin, Miao Zhang, Xueqian Wang, 2024Available at SSRN 5119629</p>
<p>Enhancing intent understanding for ambiguous prompts through human-machine co-adaptation. Yangfan He, Jianhui Wang, Kun Li, Yijin Wang, Li Sun, Jun Yin, Miao Zhang, Xueqian Wang, arXiv:2501.151672025arXiv preprint</p>
<p>Large language models can self-improve. Jiaxin Huang, Shixiang Shane Gu, Le Hou, Yuexin Wu, Xuezhi Wang, Hongkun Yu, Jiawei Han, 2022</p>
<p>Leveraging passage retrieval with generative models for open domain question answering. Gautier Izacard, Edouard Grave, Proceedings of the 16th Conference of the European Chapter of the Association for Computational Linguistics: Main Volume (EACL). the 16th Conference of the European Chapter of the Association for Computational Linguistics: Main Volume (EACL)2021</p>
<p>TriviaQA: A large scale distantly supervised challenge dataset for reading comprehension. Mandar Joshi, Eunsol Choi, Daniel Weld, Luke Zettlemoyer, 10.18653/v1/P17-1147Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics. Long Papers. Regina Barzilay, Min-Yen Kan, the 55th Annual Meeting of the Association for Computational LinguisticsVancouver, CanadaAssociation for Computational LinguisticsJuly 2017a1</p>
<p>Triviaqa: A large scale distantly supervised challenge dataset for reading comprehension. Mandar Joshi, Eunsol Choi, Daniel S Weld, Luke Zettlemoyer, 2017b</p>
<p>Stochastic beams and where to find them: The gumbel-top-k trick for sampling sequences without replacement. Wouter Kool, Herke Van Hoof, Max Welling, 2019</p>
<p>Natural questions: A benchmark for question answering research. Tom Kwiatkowski, Jennimaria Palomaki, Olivia Redfield, Michael Collins, Ankur Parikh, Chris Alberti, Danielle Epstein, Illia Polosukhin, Jacob Devlin, Kenton Lee, Kristina Toutanova, Llion Jones, Matthew Kelcey, Ming-Wei Chang, Andrew M Dai, Jakob Uszkoreit, Quoc Le, Slav Petrov, 10.1162/tacl_a_00276Transactions of the Association for Computational Linguistics. 72019</p>
<p>Falcon: Feedback-driven adaptive long/short-term memory reinforced coding optimization system. Zeyuan Li, Yangfan He, Lewei He, Jianhui Wang, Tianyu Shi, Bin Lei, Yuchen Li, Qiuwu Chen, arXiv:2410.213492024arXiv preprint</p>
<p>Cmat: A multi-agent collaboration tuning framework for enhancing small language models. Xuechen Liang, Meiling Tao, Yinghui Xia, Tianyu Shi, Jun Wang, Jingsong Yang, arXiv:2404.016632024arXiv preprint</p>
<p>Repobench: Benchmarking repository-level code auto-completion systems. Tianyang Liu, Canwen Xu, Julian Mcauley, 2023a</p>
<p>Repobench: Benchmarking repositorylevel code auto-completion systems. Tianyang Liu, Canwen Xu, Julian Mcauley, The Twelfth International Conference on Learning Representations. 2024</p>
<p>Xiao Liu, Hao Yu, Hanchen Zhang, Yifan Xu, Xuanyu Lei, Hanyu Lai, Yu Gu, Hangliang Ding, Kaiwen Men, Kejuan Yang, Shudan Zhang, Xiang Deng, Aohan Zeng, Zhengxiao Du, Chenhui Zhang, Sheng Shen, Tianjun Zhang, Yu Su, Huan Sun, Minlie Huang, arXiv:2308.03688Yuxiao Dong, and Jie Tang. Agentbench: Evaluating llms as agents. 2023barXiv preprint</p>
<p>Human-level control through deep reinforcement learning. Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Andrei A Rusu, Joel Veness, Marc G Bellemare, Alex Graves, Martin Riedmiller, Andreas K Fidjeland, Georg Ostrovski, nature. 51875402015</p>
<p>Introducing the LCC metaphor datasets. Michael Mohler, Mary Brunson, Bryan Rink, Marc Tomlinson ; Thierry Declerck, Sara Goggi, Marko Grobelnik, Bente Maegaard, Joseph Mariani, Helene Mazo, Proceedings of the Tenth International Conference on Language Resources and Evaluation (LREC'16). Stelios Odijk, Piperidis, the Tenth International Conference on Language Resources and Evaluation (LREC'16)Asuncion Moreno; Portorož, SloveniaEuropean Language Resources Association (ELRAJan. May 2016</p>
<p>Babyagi: An ai agent that can achieve goals and execute tasks. Yohei Nakajima, OpenAI. Openai cookbook. 2024. 2023</p>
<p>Josh Openai, Steven Achiam, Sandhini Adler, Lama Agarwal, Ilge Ahmad, Florencia Akkaya, Diogo Leoni Aleman, Janko Almeida, Sam Altenschmidt, Shyamal Altman, Red Anadkat, Igor Avila, Suchir Babuschkin, Valerie Balaji, Paul Balcom, Haiming Baltescu, Mohammad Bao, Jeff Bavarian, Irwan Belgum, Jake Bello, Gabriel Berdine, Christopher Bernadett-Shapiro, Lenny Berner, Oleg Bogdonoff, Madelaine Boiko, Anna-Luisa Boyd, Greg Brakman, Tim Brockman, Miles Brooks, Kevin Brundage, Trevor Button, Rosie Cai, Andrew Campbell, Brittany Cann, Chelsea Carey, Rory Carlson, Brooke Carmichael, Che Chan, Fotis Chang, Derek Chantzis, Sully Chen, Ruby Chen, Jason Chen, Mark Chen, Ben Chen, Chester Chess, Casey Cho, Hyung Won Chu, Dave Chung, Jeremiah Cummings, Yunxing Currier, Cory Dai, Thomas Decareaux, Noah Degry, Damien Deutsch, Arka Deville, David Dhar, Steve Dohan, Sheila Dowling, Adrien Dunning, Atty Ecoffet, Tyna Eleti, David Eloundou, Liam Farhi, Niko Fedus, Simón Felix, Juston Posada Fishman, Isabella Forte, Leo Fulford, Elie Gao, Christian Georges, Vik Gibson, Tarun Goel, Gabriel Gogineni, Rapha Goh, Jonathan Gontijo-Lopes, Morgan Gordon, Scott Grafstein, Ryan Gray, Joshua Greene, Gross, Shane Shixiang, Yufei Gu, Chris Guo, Jesse Hallacy, Jeff Han, Yuchen Harris, Mike He, Johannes Heaton, Chris Heidecke, Alan Hesse, Wade Hickey, Peter Hickey, Brandon Hoeschele, Kenny Houghton, Shengli Hsu, Xin Hu, Joost Hu, Shantanu Huizinga, Shawn Jain, Joanne Jain, Angela Jang, Roger Jiang, Haozhun Jiang, Denny Jin, Shino Jin, Billie Jomoto, Heewoo Jonn, Tomer Jun, Łukasz Kaftan, Ali Kaiser, Ingmar Kamali, Nitish Kanitscheider, Tabarak Shirish Keskar, Logan Khan, Jong Wook Kilpatrick, Christina Kim, Yongjik Kim, Jan Hendrik Kim, Jamie Kirchner, Matt Kiros, Daniel Knight, Łukasz Kokotajlo, Andrew Kondraciuk, Aris Kondrich, Kyle Konstantinidis, Gretchen Kosic, Vishal Krueger, Michael Kuo, Ikai Lampe, Teddy Lan, Jan Lee, Jade Leike, Daniel Leung, Levy, Ming Chak, Rachel Li, Molly Lim, Stephanie Lin, Mateusz Lin, Theresa Litwin, Ryan Lopez, Patricia Lowe, Anna Lue, Kim Makanju, Sam Malfacini, Todor Manning, Yaniv Markov, Bianca Markovski, Katie Martin, Andrew Mayer, Mayne ; Aalok, Jacob Mehta, Luke Menick, Andrey Metz, Pamela Mishchenko, Ashvin Mishkin ; Mély, Reiichiro Nair, Rajeev Nakano, Arvind Nayak, Richard Neelakantan, Hyeonwoo Ngo, Long Noh, Ouyang, O' Cullen, Jakub Keefe, Alex Pachocki, Joe Paino, Ashley Palermo, Giambattista Pantuliano, Joel Parascandolo, Emy Parish, Alex Parparita, Mikhail Passos, Andrew Pavlov, Adam Peng, Kyla Perelman, Toki Sheppard, Jessica Sherbakov, Sarah Shieh, Pranav Shoker, Szymon Shyam, Eric Sidor, Maddie Sigler, Jordan Simens, Katarina Sitkin, Ian Slama, Benjamin Sohl, Yang Sokolowsky, Natalie Song, Staudacher, Wei, Akila Cj Weinmann, Peter Welihinda, Jiayi Welinder, Lilian Weng, Matt Weng, Dave Wiethoff, Clemens Willner, Samuel Winter, Hannah Wolrich, Wojciech Wong ; Yuan, Rowan Zaremba, Chong Zellers, Marvin Zhang, Shengjia Zhang, Zhao, Tianhao Zheng, Juntang Zhuang, William Zhuk, and Barret Zoph. Gpt-4 technical report. Felipe Petroski Such. Michelle Pokrass, H Vitchyr, Tolly Pong, Alethea Powell, Boris Power, Elizabeth Power, Raul Proehl, Alec Puri, Jack Radford, Aditya Rae, Cameron Ramesh, Francis Raymond, Kendra Real, Carl Rimbach, Bob Ross, Henri Rotsted, Nick Roussez, Mario Ryder, Ted Saltarelli, Shibani Sanders, Girish Santurkar, Heather Sastry, David Schmidt, John Schnurr, Daniel Schulman, Selsam, Bob McGrew, Scott Mayer McKinney, Christine McLeavey, Paul McMillan, Jake McNeil, David Medina,; Vinnie Monaco, Evan Morikawa, Daniel Mossing, Tong Mu, Mira Murati, Oleg Murk, David; Michael Petrov, Henrique Ponde de Oliveira Pinto, Michael, Pokorny; Natalie Summers, Ilya Sutskever, Jie Tang, Nikolas Tezak, Madeleine B. Thompson, Phil Tillet, Amin Tootoonchian, Elizabeth Tseng, Preston Tuggle, Nick Turley, Jerry Tworek; Chelsea Voss, Carroll Wainwright, Justin Jay Wang, Alvin Wang, Ben Wang, Jonathan Ward, Jason; Lauren Workman; Sarah Yoo, Kevin Yu2024Filipe de Avila Belbute Peres ; Juan Felipe Cerón Uribe, Andrea Vallone, Arun VijayvergiyaSherwin Wu, Jeff Wu, Michael Wu, Kai Xiao, Tao Xu</p>
<p>Charles Packer, Sarah Wooders, Kevin Lin, Vivian Fang, G Shishir, Ion Patil, Joseph E Stoica, Gonzalez, Memgpt: Towards llms as operating systems. 2024</p>
<p>Tfb: Towards comprehensive and fair benchmarking of time series forecasting methods. Xiangfei Qiu, Jilin Hu, Lekui Zhou, Xingjian Wu, Junyang Du, Buang Zhang, Chenjuan Guo, Aoying Zhou, Christian S Jensen, Zhenli Sheng, Bin Yang, Proc. VLDB Endow. VLDB Endow2024</p>
<p>Easytime: Time series forecasting made easy. Xiangfei Qiu, Xiuwen Li, Ruiyang Pang, Zhicheng Pan, Xingjian Wu, Liu Yang, Jilin Hu, Yang Shu, Xuesong Lu, Chengcheng Yang, Chenjuan Guo, Aoying Zhou, Christian S Jensen, Bin Yang, ICDE. 2025a</p>
<p>Duet: Dual clustering enhanced multivariate time series forecasting. Xiangfei Qiu, Xingjian Wu, Yan Lin, Chenjuan Guo, Jilin Hu, Bin Yang, SIGKDD. 2025b</p>
<p>Anna Jack W Rae, Potapenko, M Siddhant, Timothy P Jayakumar, Lillicrap, arXiv:1911.05507Compressive transformers for long-range sequence modelling. 2019arXiv preprint</p>
<p>Exploring the limits of transfer learning with a unified text-to-text transformer. Colin Raffel, Noam Shazeer, Adam Roberts, Katherine Lee, Sharan Narang, Michael Matena, Yanqi Zhou, Wei Li, Peter J Liu, Journal of machine learning research. 211402020</p>
<p>Dense passage retrieval: Is it retrieving?. Benjamin Reichman, Larry Heck, 2024</p>
<p>The probabilistic relevance framework: Bm25 and beyond. Stephen Robertson, Hugo Zaragoza, 10.1561/1500000019Foundations and Trends® in Information Retrieval. 1554-0669342009</p>
<p>Jonas Baptiste Rozière, Fabian Gehring, Sten Gloeckle, Itai Sootla, Gat, Ellen Xiaoqing, Yossi Tan, Jingyu Adi, Romain Liu, Tal Sauvestre, Jérémy Remez, Artyom Rapin, Ivan Kozhevnikov, Joanna Evtimov, Manish Bitton, Cristian Canton Bhatt, Aaron Ferrer, Wenhan Grattafiori, Alexandre Xiong, Jade Défossez, Faisal Copet, Hugo Azhar, Louis Touvron, Martin, Nicolas Usunier, Thomas Scialom, and Gabriel Synnaeve. Code llama: Open foundation models for code. 2024</p>
<p>Reflexion: Language agents with verbal reinforcement learning. Noah Shinn, Federico Cassano, Edward Berman, Ashwin Gopinath, Karthik Narasimhan, Shunyu Yao, 2023</p>
<p>ALFWorld: Aligning Text and Embodied Environments for Interactive Learning. Mohit Shridhar, Xingdi Yuan, Marc-Alexandre Côté, Yonatan Bisk, Adam Trischler, Matthew Hausknecht, Proceedings of the International Conference on Learning Representations (ICLR). the International Conference on Learning Representations (ICLR)2021</p>
<p>Simultaneity, sequentiality, and speed: Organizational messages about multiple-task completion. Keri K Stephens, Jaehee K Cho, Dawna I Ballard, Human Communication Research. 3812012</p>
<p>Reinforcement Learning: An Introduction. Richard S Sutton, Andrew G Barto, 2018MIT PressCambridge, MA2 edition</p>
<p>Toward self-improvement of llms via imagination, searching, and criticizing. Ye Tian, Baolin Peng, Linfeng Song, Lifeng Jin, Dian Yu, Haitao Mi, Dong Yu, 2024</p>
<p>. Hugo Touvron, Louis Martin, Kevin Stone, Peter Albert, Amjad Almahairi, Yasmine Babaei, Nikolay Bashlykov, Soumya Batra, Prajjwal Bhargava, Shruti Bhosale, Dan Bikel, Lukas Blecher, Cristian Canton Ferrer, Moya Chen, Guillem Cucurull, David Esiobu, Jude Fernandes, Jeremy Fu, Wenyin Fu, Brian Fuller, Cynthia Gao, Vedanuj Goswami, Naman Goyal, Anthony Hartshorn, Saghar Hosseini, Rui Hou, Hakan Inan, Marcin Kardas, Viktor Kerkez, Madian Khabsa, Isabel Kloumann, Artem Korenev, Punit Singh Koura, Marie-Anne Lachaux, Thibaut Lavril, Jenya Lee, Diana Liskovich, Yinghai Lu, Yuning Mao, Xavier Martinet, Todor Mihaylov, Pushkar Mishra, Igor Molybog, Yixin Nie, Andrew Poulton, Jeremy Reizenstein, Rashi Rungta, Kalyan Saladi, Alan Schelten, Ruan Silva, Eric Michael Smith, Ranjan Subramanian, Xiaoqing , Ellen Tan, Binh Tang, Ross Taylor, Adina Williams, Jian Xiang Kuan, Puxin Xu, Zheng Yan, Iliyan Zarov, Yuchen Zhang, 2023Aurelien RodriguezAngela Fan, Melanie Kambadur; Robert Stojnic, Sergey Edunovand Thomas Scialom. Llama 2: Open foundation and fine-tuned chat models</p>
<p>Unsupervised multilingual word embedding with limited resources using neural language models. Takashi Wada, Tomoharu Iwata, Yuji Matsumoto, Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics. the 57th Annual Meeting of the Association for Computational Linguistics2019</p>
<p>Auto-gpt for online decision making: Benchmarks and additional opinions. Hui Yang, Sifu Yue, Yunzhong He, 2023</p>
<p>HotpotQA: A dataset for diverse, explainable multi-hop question answering. Zhilin Yang, Peng Qi, Saizheng Zhang, Yoshua Bengio, William Cohen, Ruslan Salakhutdinov, Christopher D Manning, 10.18653/v1/D18-1259Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing. Ellen Riloff, David Chiang, Julia Hockenmaier, Jun'ichi Tsujii, the 2018 Conference on Empirical Methods in Natural Language ProcessingBrussels, BelgiumAssociation for Computational LinguisticsOctober-November 2018a</p>
<p>Hotpotqa: A dataset for diverse, explainable multihop question answering. Zhilin Yang, Peng Qi, Saizheng Zhang, Yoshua Bengio, William W Cohen, Ruslan Salakhutdinov, Christopher D Manning, 2018b</p>
<p>Webshop: Towards scalable real-world web interaction with grounded language agents. Shunyu Yao, Howard Chen, John Yang, Karthik Narasimhan, 2023a</p>
<p>React: Synergizing reasoning and acting in language models. Shunyu Yao, Jeffrey Zhao, Dian Yu, Nan Du, Izhak Shafran, Karthik Narasimhan, Yuan Cao, 2023b</p>            </div>
        </div>

    </div>
</body>
</html>