<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-3288 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-3288</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-3288</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-76.html">extraction-schema-76</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models using diverse reasoning methods versus similar reasoning styles to solve reasoning problems, including details of the reasoning methods, tasks, model types, and performance comparisons.</div>
                <p><strong>Paper ID:</strong> paper-eedf2748a9a1ba2779cde95fd8bad9c2260d5317</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/eedf2748a9a1ba2779cde95fd8bad9c2260d5317" target="_blank">LUKE: Deep Contextualized Entity Representations with Entity-aware Self-attention</a></p>
                <p><strong>Paper Venue:</strong> Conference on Empirical Methods in Natural Language Processing</p>
                <p><strong>Paper TL;DR:</strong> New pretrained contextualized representations of words and entities based on the bidirectional transformer, and an entity-aware self-attention mechanism that considers the types of tokens (words or entities) when computing attention scores are proposed.</p>
                <p><strong>Paper Abstract:</strong> Entity representations are useful in natural language tasks involving entities. In this paper, we propose new pretrained contextualized representations of words and entities based on the bidirectional transformer. The proposed model treats words and entities in a given text as independent tokens, and outputs contextualized representations of them. Our model is trained using a new pretraining task based on the masked language model of BERT. The task involves predicting randomly masked words and entities in a large entity-annotated corpus retrieved from Wikipedia. We also propose an entity-aware self-attention mechanism that is an extension of the self-attention mechanism of the transformer, and considers the types of tokens (words or entities) when computing attention scores. The proposed model achieves impressive empirical performance on a wide range of entity-related tasks. In particular, it obtains state-of-the-art results on five well-known datasets: Open Entity (entity typing), TACRED (relation classification), CoNLL-2003 (named entity recognition), ReCoRD (cloze-style question answering), and SQuAD 1.1 (extractive question answering). Our source code and pretrained representations are available at this https URL.</p>
                <p><strong>Cost:</strong> 0.016</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e3288.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e3288.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models using diverse reasoning methods versus similar reasoning styles to solve reasoning problems, including details of the reasoning methods, tasks, model types, and performance comparisons.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>LUKE</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>LUKE: Language Understanding with Knowledge-based Embeddings</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A RoBERTa-LARGE–based transformer that treats words and entities as independent tokens, is pretrained with both masked language modeling and masked-entity prediction, and introduces an entity-aware self-attention mechanism to better capture relationships between entities for entity-centric reasoning tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>LUKE</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Multi-layer bidirectional transformer (based on RoBERTa-LARGE) that accepts both word tokens and entity tokens as inputs, produces contextualized representations for words and entities, is pretrained on Wikipedia with a joint MLM + masked-entity prediction objective, and uses an entity-aware self-attention variant with separate query matrices depending on token-type pairs (word->word, word->entity, entity->word, entity->entity).</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>≈483M parameters (355M from RoBERTa + ≈128M entity embedding params)</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_methods</strong></td>
                            <td>['entity-aware self-attention (architectural attention variant)', 'masked-entity prediction (entity-level MLM extension)', 'standard masked language modeling (MLM)']</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_methods_description</strong></td>
                            <td>Entity-aware self-attention: attention scores computed using different query matrices depending on the types of attending and attended tokens (Q_w2w, Q_w2e, Q_e2w, Q_e2e) so attention heads can more easily focus on entity-entity and cross-type relations. Masked-entity prediction: an extension of BERT's MLM where entity tokens (hyperlinked spans) are masked and the model predicts the exact entity from an entity vocabulary (softmax over V_e). MLM: standard word masking (15%) used jointly with masked-entity objective during pretraining.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_of_methods</strong></td>
                            <td>Uses multiple, distinct methods/styles: (1) architectural modification (entity-aware attention) and (2) a different pretraining task (masked-entity prediction) in addition to standard MLM. These differ in mechanism (architecture vs pretraining objective) rather than being minor prompt/style variations.</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_name</strong></td>
                            <td>Entity-centric reasoning tasks including relation classification (TACRED), cloze-style QA (ReCoRD), extractive QA (SQuAD 1.1), entity typing (Open Entity), and NER (CoNLL-2003).</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_description</strong></td>
                            <td>Tasks requiring reasoning about entities and relationships: TACRED requires classifying relations between head/tail entities in a sentence; ReCoRD is cloze-style QA where the answer is an entity in a passage and often requires external/world knowledge; SQuAD is extractive span prediction; Open Entity is entity typing; CoNLL-2003 is NER (span classification).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_by_method</strong></td>
                            <td>Across tasks LUKE (entity-aware + masked-entity pretraining) outperforms baselines: Open Entity test F1 = 78.2 (LUKE) vs RoBERTa F1 = 76.2; TACRED test F1 = 72.7 (LUKE) vs RoBERTa F1 = 71.3; CoNLL-2003 test F1 = 94.3 (LUKE) vs RoBERTa 92.4; ReCoRD dev EM/F1 = 90.8/91.4 (LUKE) vs RoBERTa dev 89.0/89.5; SQuAD dev EM/F1 = 89.8/95.0 (LUKE) vs RoBERTa dev 88.9/94.6. Ablations: entity-aware attention vs original attention (LUKE architecture difference) shows improvements: Open Entity Test F1 77.9 -> 78.2; TACRED 72.2 -> 72.7; CoNLL 94.1 -> 94.3; ReCoRD dev EM/F1 90.1/90.7 -> 90.8/91.4; SQuAD dev EM/F1 89.2/94.7 -> 89.8/95.0. Removing entity inputs: CoNLL F1 drops 94.3 -> 92.9; SQuAD dev EM drops 89.8 -> 89.2 (dev F1 95.0 -> 94.8).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_of_methods</strong></td>
                            <td>Explicit ablations compare (A) original transformer attention vs entity-aware attention, (B) including entity inputs vs not, and (C) LUKE (entity-aware + masked-entity pretraining) vs RoBERTa with extra MLM pretraining. Findings: (A) entity-aware attention consistently improves performance across tasks, with larger gains on relation classification and QA (tasks requiring modeling entity-entity relations). (B) including entity inputs yields notable gains on NER and SQuAD. (C) RoBERTa extra pretraining (200K steps on same Wikipedia corpus using only MLM) does not match LUKE — RoBERTa w/ extra training yields CoNLL F1 92.5 (vs LUKE 94.3) and SQuAD dev EM 89.1 / F1 94.7 (vs LUKE 89.8 / 95.0), indicating LUKE's gains are not just due to more pretraining steps but to entity-aware modeling and masked-entity objective.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Architectural specialization for entities (entity-aware attention) combined with entity-focused pretraining (masked-entity prediction) yields consistent improvements on entity-centric reasoning tasks over a standard transformer (RoBERTa) and over simply training longer; the entity-aware attention particularly improves tasks that require reasoning about inter-entity relations (relation classification and QA).</td>
                        </tr>
                        <tr>
                            <td><strong>counter_examples_or_negative_results</strong></td>
                            <td>No case in the paper where original attention outperformed entity-aware attention; gains are modest on some tasks (e.g., Open Entity F1 improves 77.9 -> 78.2) and larger on relation/QA. A practical constraint: entity-aware query matrices were not used during pretraining (pretraining used original attention due to compute limits) — the model learns those matrices during downstream fine-tuning, which may limit how fully the architecture is exploited compared with having trained it end-to-end from scratch.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'LUKE: Deep Contextualized Entity Representations with Entity-aware Self-attention', 'publication_date_yy_mm': '2020-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3288.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e3288.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models using diverse reasoning methods versus similar reasoning styles to solve reasoning problems, including details of the reasoning methods, tasks, model types, and performance comparisons.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>RoBERTa (baseline)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>RoBERTa: A Robustly Optimized BERT Pretraining Approach</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A BERT-variant transformer pretrained with optimized MLM procedures (longer training, larger batches, dynamic masking) used here as the primary baseline for comparing LUKE, and also as the backbone initialization for LUKE.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>RoBERTa: A Robustly Optimized BERT Pretraining Approach</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>RoBERTa-LARGE (as used in LUKE experiments)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Bidirectional transformer (BERT variant) pretrained with MLM, used as the initialization for LUKE; in experiments RoBERTa is evaluated as a baseline and is also further pretrained (extra MLM steps) for ablation.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>≈355M parameters (RoBERTa-LARGE)</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_methods</strong></td>
                            <td>['standard masked language modeling (MLM)', 'original self-attention (type-agnostic attention)']</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_methods_description</strong></td>
                            <td>Standard MLM: random word token masking (15%) with softmax over vocabulary. Original self-attention: single set of Q/K/V matrices used for all token-type pairs (no token-type–dependent queries).</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_of_methods</strong></td>
                            <td>Single, consistent reasoning style: generic token-level transformer attention plus MLM pretraining; does not include entity-aware architectural variants or explicit entity-level pretraining.</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_name</strong></td>
                            <td>Same entity-centric tasks used as baselines: Open Entity, TACRED, CoNLL-2003, ReCoRD, SQuAD.</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_description</strong></td>
                            <td>See LUKE entry; RoBERTa serves as direct comparison to show effect of entity-aware methods.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_by_method</strong></td>
                            <td>Reported baseline results (RoBERTa dev/test where available): Open Entity F1 ≈ 76.2; TACRED F1 ≈ 71.3; CoNLL-2003 F1 = 92.4; ReCoRD dev EM/F1 = 89.0/89.5; SQuAD dev EM/F1 = 88.9/94.6. Extra pretraining (RoBERTa w/ extra MLM on same Wikipedia corpus for 200K steps) yields CoNLL F1 92.5 and SQuAD dev EM/F1 89.1/94.7 — modest or no gains compared to original RoBERTa and still below LUKE.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_of_methods</strong></td>
                            <td>Compared to LUKE, RoBERTa (even with extra MLM pretraining) underperforms; this supports the claim that entity-specific modeling (architecture + pretraining objective) rather than just more MLM pretraining accounts for LUKE's improvements.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Vanilla transformer attention + MLM (RoBERTa) is strong but yields lower performance on entity-reasoning tasks than a model that explicitly represents entities and uses entity-aware attention + masked-entity pretraining. Extra MLM pretraining on the same data does not close the gap.</td>
                        </tr>
                        <tr>
                            <td><strong>counter_examples_or_negative_results</strong></td>
                            <td>Extra MLM pretraining on the same Wikipedia corpus produced small improvements (e.g., CoNLL 92.4 -> 92.5), indicating that simply training longer is insufficient to match LUKE's entity-tailored approach.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'LUKE: Deep Contextualized Entity Representations with Entity-aware Self-attention', 'publication_date_yy_mm': '2020-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3288.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e3288.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models using diverse reasoning methods versus similar reasoning styles to solve reasoning problems, including details of the reasoning methods, tasks, model types, and performance comparisons.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Knowledge-enhanced CWRs (mentions)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Examples: ERNIE, KnowBERT, KEPLER, K-Adapter, SpanBERT, MTB</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Related models that inject external knowledge or span-level signals into contextualized word representations using diverse methods (static entity embeddings, knowledge-embedding objectives, span masking, adapters, task-specific pretraining). They are mentioned and compared as baselines.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>ERNIE / KnowBERT / KEPLER / K-Adapter / SpanBERT / MTB (grouped)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>ERNIE and KnowBERT augment transformers with static entity embeddings or entity linking; KEPLER jointly trains language model and knowledge embeddings; K-Adapter uses neural adapters to inject knowledge; SpanBERT masks and predicts spans (span-level MLM); MTB (Matching the Blanks) uses entity-annotated text for relation learning. These are different styles of incorporating knowledge and span-level supervision.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>varies by model (not specified in this paper)</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_methods</strong></td>
                            <td>['static entity embedding injection (KnowBERT, ERNIE)', 'joint knowledge-embedding + LM pretraining (KEPLER)', 'adapter modules to inject factual/linguistic knowledge (K-Adapter)', 'span masking and span prediction (SpanBERT)', 'matching-the-blanks style entity-based pretraining (MTB)']</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_methods_description</strong></td>
                            <td>ERNIE/KnowBERT: link text spans to KB entities and incorporate prelearned entity embeddings. KEPLER: add a knowledge-embedding objective to LM pretraining. K-Adapter: add adapter layers trained on knowledge sources. SpanBERT: mask contiguous word spans rather than single tokens and predict them. MTB: learns relation signals by blank-matching tasks on entity-annotated corpora.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_of_methods</strong></td>
                            <td>These works represent a diverse set of methods (architectural adapters, additional pretraining objectives, static embeddings, span masking). The LUKE paper situates its approach among these and reports comparative performance numbers.</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_name</strong></td>
                            <td>Same entity-centric benchmarks used in comparisons (Open Entity, TACRED, CoNLL-2003, ReCoRD, SQuAD).</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_description</strong></td>
                            <td>As above — used to evaluate benefits of different knowledge/ entity strategies.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_by_method</strong></td>
                            <td>Paper reports LUKE outperforms these models on the evaluated tasks. Example comparisons from tables: On Open Entity, KnowBERT F1 = 76.1 vs LUKE 78.2; On TACRED, KEPLER F1 = 71.7, K-Adapter F1 = 72.0, KnowBERT F1 = 71.5, MTB 71.5 (reported) vs LUKE 72.7; On ReCoRD and SQuAD LUKE also leads. Exact per-model numbers are cited in the paper's result tables.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_of_methods</strong></td>
                            <td>LUKE authors state that their combination of entity-token inputs, masked-entity pretraining, and entity-aware attention outperforms several other knowledge-enhancement strategies (static embeddings, knowledge objectives, adapters, span masking) across entity-centric tasks — i.e., the architectural + pretraining combination is more effective than the other styles evaluated here.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Various knowledge-injection methods give improvements over vanilla CWRs; LUKE's explicit entity-token modeling + entity-aware attention + masked-entity pretraining produce better empirical results on the suite of entity reasoning tasks than the referenced alternatives.</td>
                        </tr>
                        <tr>
                            <td><strong>counter_examples_or_negative_results</strong></td>
                            <td>Not reported in detail for each alternative method beyond the comparative tables; some methods (e.g., K-Adapter) approach LUKE performance on particular metrics (e.g., K-Adapter F1 77.5 vs LUKE 78.2 on Open Entity test), indicating other knowledge-injection approaches can be competitive.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'LUKE: Deep Contextualized Entity Representations with Entity-aware Self-attention', 'publication_date_yy_mm': '2020-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>RoBERTa: A Robustly Optimized BERT Pretraining Approach <em>(Rating: 2)</em></li>
                <li>SpanBERT: Improving Pre-training by Representing and Predicting Spans <em>(Rating: 2)</em></li>
                <li>Knowledge Enhanced Contextual Word Representations <em>(Rating: 2)</em></li>
                <li>KEPLER: A Unified Model for Knowledge Embedding and Pretrained Language Representation <em>(Rating: 2)</em></li>
                <li>K-Adapter: Infusing Knowledge into Pre-trained Models with Adapters <em>(Rating: 2)</em></li>
                <li>ERNIE: Enhanced Language Representation with Informative Entities <em>(Rating: 2)</em></li>
                <li>Matching the Blanks: Distributional Similarity for Relation Learning <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-3288",
    "paper_id": "paper-eedf2748a9a1ba2779cde95fd8bad9c2260d5317",
    "extraction_schema_id": "extraction-schema-76",
    "extracted_data": [
        {
            "name_short": "LUKE",
            "name_full": "LUKE: Language Understanding with Knowledge-based Embeddings",
            "brief_description": "A RoBERTa-LARGE–based transformer that treats words and entities as independent tokens, is pretrained with both masked language modeling and masked-entity prediction, and introduces an entity-aware self-attention mechanism to better capture relationships between entities for entity-centric reasoning tasks.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "LUKE",
            "model_description": "Multi-layer bidirectional transformer (based on RoBERTa-LARGE) that accepts both word tokens and entity tokens as inputs, produces contextualized representations for words and entities, is pretrained on Wikipedia with a joint MLM + masked-entity prediction objective, and uses an entity-aware self-attention variant with separate query matrices depending on token-type pairs (word-&gt;word, word-&gt;entity, entity-&gt;word, entity-&gt;entity).",
            "model_size": "≈483M parameters (355M from RoBERTa + ≈128M entity embedding params)",
            "reasoning_methods": [
                "entity-aware self-attention (architectural attention variant)",
                "masked-entity prediction (entity-level MLM extension)",
                "standard masked language modeling (MLM)"
            ],
            "reasoning_methods_description": "Entity-aware self-attention: attention scores computed using different query matrices depending on the types of attending and attended tokens (Q_w2w, Q_w2e, Q_e2w, Q_e2e) so attention heads can more easily focus on entity-entity and cross-type relations. Masked-entity prediction: an extension of BERT's MLM where entity tokens (hyperlinked spans) are masked and the model predicts the exact entity from an entity vocabulary (softmax over V_e). MLM: standard word masking (15%) used jointly with masked-entity objective during pretraining.",
            "diversity_of_methods": "Uses multiple, distinct methods/styles: (1) architectural modification (entity-aware attention) and (2) a different pretraining task (masked-entity prediction) in addition to standard MLM. These differ in mechanism (architecture vs pretraining objective) rather than being minor prompt/style variations.",
            "reasoning_task_name": "Entity-centric reasoning tasks including relation classification (TACRED), cloze-style QA (ReCoRD), extractive QA (SQuAD 1.1), entity typing (Open Entity), and NER (CoNLL-2003).",
            "reasoning_task_description": "Tasks requiring reasoning about entities and relationships: TACRED requires classifying relations between head/tail entities in a sentence; ReCoRD is cloze-style QA where the answer is an entity in a passage and often requires external/world knowledge; SQuAD is extractive span prediction; Open Entity is entity typing; CoNLL-2003 is NER (span classification).",
            "performance_by_method": "Across tasks LUKE (entity-aware + masked-entity pretraining) outperforms baselines: Open Entity test F1 = 78.2 (LUKE) vs RoBERTa F1 = 76.2; TACRED test F1 = 72.7 (LUKE) vs RoBERTa F1 = 71.3; CoNLL-2003 test F1 = 94.3 (LUKE) vs RoBERTa 92.4; ReCoRD dev EM/F1 = 90.8/91.4 (LUKE) vs RoBERTa dev 89.0/89.5; SQuAD dev EM/F1 = 89.8/95.0 (LUKE) vs RoBERTa dev 88.9/94.6. Ablations: entity-aware attention vs original attention (LUKE architecture difference) shows improvements: Open Entity Test F1 77.9 -&gt; 78.2; TACRED 72.2 -&gt; 72.7; CoNLL 94.1 -&gt; 94.3; ReCoRD dev EM/F1 90.1/90.7 -&gt; 90.8/91.4; SQuAD dev EM/F1 89.2/94.7 -&gt; 89.8/95.0. Removing entity inputs: CoNLL F1 drops 94.3 -&gt; 92.9; SQuAD dev EM drops 89.8 -&gt; 89.2 (dev F1 95.0 -&gt; 94.8).",
            "comparison_of_methods": "Explicit ablations compare (A) original transformer attention vs entity-aware attention, (B) including entity inputs vs not, and (C) LUKE (entity-aware + masked-entity pretraining) vs RoBERTa with extra MLM pretraining. Findings: (A) entity-aware attention consistently improves performance across tasks, with larger gains on relation classification and QA (tasks requiring modeling entity-entity relations). (B) including entity inputs yields notable gains on NER and SQuAD. (C) RoBERTa extra pretraining (200K steps on same Wikipedia corpus using only MLM) does not match LUKE — RoBERTa w/ extra training yields CoNLL F1 92.5 (vs LUKE 94.3) and SQuAD dev EM 89.1 / F1 94.7 (vs LUKE 89.8 / 95.0), indicating LUKE's gains are not just due to more pretraining steps but to entity-aware modeling and masked-entity objective.",
            "key_findings": "Architectural specialization for entities (entity-aware attention) combined with entity-focused pretraining (masked-entity prediction) yields consistent improvements on entity-centric reasoning tasks over a standard transformer (RoBERTa) and over simply training longer; the entity-aware attention particularly improves tasks that require reasoning about inter-entity relations (relation classification and QA).",
            "counter_examples_or_negative_results": "No case in the paper where original attention outperformed entity-aware attention; gains are modest on some tasks (e.g., Open Entity F1 improves 77.9 -&gt; 78.2) and larger on relation/QA. A practical constraint: entity-aware query matrices were not used during pretraining (pretraining used original attention due to compute limits) — the model learns those matrices during downstream fine-tuning, which may limit how fully the architecture is exploited compared with having trained it end-to-end from scratch.",
            "uuid": "e3288.0",
            "source_info": {
                "paper_title": "LUKE: Deep Contextualized Entity Representations with Entity-aware Self-attention",
                "publication_date_yy_mm": "2020-10"
            }
        },
        {
            "name_short": "RoBERTa (baseline)",
            "name_full": "RoBERTa: A Robustly Optimized BERT Pretraining Approach",
            "brief_description": "A BERT-variant transformer pretrained with optimized MLM procedures (longer training, larger batches, dynamic masking) used here as the primary baseline for comparing LUKE, and also as the backbone initialization for LUKE.",
            "citation_title": "RoBERTa: A Robustly Optimized BERT Pretraining Approach",
            "mention_or_use": "use",
            "model_name": "RoBERTa-LARGE (as used in LUKE experiments)",
            "model_description": "Bidirectional transformer (BERT variant) pretrained with MLM, used as the initialization for LUKE; in experiments RoBERTa is evaluated as a baseline and is also further pretrained (extra MLM steps) for ablation.",
            "model_size": "≈355M parameters (RoBERTa-LARGE)",
            "reasoning_methods": [
                "standard masked language modeling (MLM)",
                "original self-attention (type-agnostic attention)"
            ],
            "reasoning_methods_description": "Standard MLM: random word token masking (15%) with softmax over vocabulary. Original self-attention: single set of Q/K/V matrices used for all token-type pairs (no token-type–dependent queries).",
            "diversity_of_methods": "Single, consistent reasoning style: generic token-level transformer attention plus MLM pretraining; does not include entity-aware architectural variants or explicit entity-level pretraining.",
            "reasoning_task_name": "Same entity-centric tasks used as baselines: Open Entity, TACRED, CoNLL-2003, ReCoRD, SQuAD.",
            "reasoning_task_description": "See LUKE entry; RoBERTa serves as direct comparison to show effect of entity-aware methods.",
            "performance_by_method": "Reported baseline results (RoBERTa dev/test where available): Open Entity F1 ≈ 76.2; TACRED F1 ≈ 71.3; CoNLL-2003 F1 = 92.4; ReCoRD dev EM/F1 = 89.0/89.5; SQuAD dev EM/F1 = 88.9/94.6. Extra pretraining (RoBERTa w/ extra MLM on same Wikipedia corpus for 200K steps) yields CoNLL F1 92.5 and SQuAD dev EM/F1 89.1/94.7 — modest or no gains compared to original RoBERTa and still below LUKE.",
            "comparison_of_methods": "Compared to LUKE, RoBERTa (even with extra MLM pretraining) underperforms; this supports the claim that entity-specific modeling (architecture + pretraining objective) rather than just more MLM pretraining accounts for LUKE's improvements.",
            "key_findings": "Vanilla transformer attention + MLM (RoBERTa) is strong but yields lower performance on entity-reasoning tasks than a model that explicitly represents entities and uses entity-aware attention + masked-entity pretraining. Extra MLM pretraining on the same data does not close the gap.",
            "counter_examples_or_negative_results": "Extra MLM pretraining on the same Wikipedia corpus produced small improvements (e.g., CoNLL 92.4 -&gt; 92.5), indicating that simply training longer is insufficient to match LUKE's entity-tailored approach.",
            "uuid": "e3288.1",
            "source_info": {
                "paper_title": "LUKE: Deep Contextualized Entity Representations with Entity-aware Self-attention",
                "publication_date_yy_mm": "2020-10"
            }
        },
        {
            "name_short": "Knowledge-enhanced CWRs (mentions)",
            "name_full": "Examples: ERNIE, KnowBERT, KEPLER, K-Adapter, SpanBERT, MTB",
            "brief_description": "Related models that inject external knowledge or span-level signals into contextualized word representations using diverse methods (static entity embeddings, knowledge-embedding objectives, span masking, adapters, task-specific pretraining). They are mentioned and compared as baselines.",
            "citation_title": "",
            "mention_or_use": "mention",
            "model_name": "ERNIE / KnowBERT / KEPLER / K-Adapter / SpanBERT / MTB (grouped)",
            "model_description": "ERNIE and KnowBERT augment transformers with static entity embeddings or entity linking; KEPLER jointly trains language model and knowledge embeddings; K-Adapter uses neural adapters to inject knowledge; SpanBERT masks and predicts spans (span-level MLM); MTB (Matching the Blanks) uses entity-annotated text for relation learning. These are different styles of incorporating knowledge and span-level supervision.",
            "model_size": "varies by model (not specified in this paper)",
            "reasoning_methods": [
                "static entity embedding injection (KnowBERT, ERNIE)",
                "joint knowledge-embedding + LM pretraining (KEPLER)",
                "adapter modules to inject factual/linguistic knowledge (K-Adapter)",
                "span masking and span prediction (SpanBERT)",
                "matching-the-blanks style entity-based pretraining (MTB)"
            ],
            "reasoning_methods_description": "ERNIE/KnowBERT: link text spans to KB entities and incorporate prelearned entity embeddings. KEPLER: add a knowledge-embedding objective to LM pretraining. K-Adapter: add adapter layers trained on knowledge sources. SpanBERT: mask contiguous word spans rather than single tokens and predict them. MTB: learns relation signals by blank-matching tasks on entity-annotated corpora.",
            "diversity_of_methods": "These works represent a diverse set of methods (architectural adapters, additional pretraining objectives, static embeddings, span masking). The LUKE paper situates its approach among these and reports comparative performance numbers.",
            "reasoning_task_name": "Same entity-centric benchmarks used in comparisons (Open Entity, TACRED, CoNLL-2003, ReCoRD, SQuAD).",
            "reasoning_task_description": "As above — used to evaluate benefits of different knowledge/ entity strategies.",
            "performance_by_method": "Paper reports LUKE outperforms these models on the evaluated tasks. Example comparisons from tables: On Open Entity, KnowBERT F1 = 76.1 vs LUKE 78.2; On TACRED, KEPLER F1 = 71.7, K-Adapter F1 = 72.0, KnowBERT F1 = 71.5, MTB 71.5 (reported) vs LUKE 72.7; On ReCoRD and SQuAD LUKE also leads. Exact per-model numbers are cited in the paper's result tables.",
            "comparison_of_methods": "LUKE authors state that their combination of entity-token inputs, masked-entity pretraining, and entity-aware attention outperforms several other knowledge-enhancement strategies (static embeddings, knowledge objectives, adapters, span masking) across entity-centric tasks — i.e., the architectural + pretraining combination is more effective than the other styles evaluated here.",
            "key_findings": "Various knowledge-injection methods give improvements over vanilla CWRs; LUKE's explicit entity-token modeling + entity-aware attention + masked-entity pretraining produce better empirical results on the suite of entity reasoning tasks than the referenced alternatives.",
            "counter_examples_or_negative_results": "Not reported in detail for each alternative method beyond the comparative tables; some methods (e.g., K-Adapter) approach LUKE performance on particular metrics (e.g., K-Adapter F1 77.5 vs LUKE 78.2 on Open Entity test), indicating other knowledge-injection approaches can be competitive.",
            "uuid": "e3288.2",
            "source_info": {
                "paper_title": "LUKE: Deep Contextualized Entity Representations with Entity-aware Self-attention",
                "publication_date_yy_mm": "2020-10"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "RoBERTa: A Robustly Optimized BERT Pretraining Approach",
            "rating": 2
        },
        {
            "paper_title": "SpanBERT: Improving Pre-training by Representing and Predicting Spans",
            "rating": 2
        },
        {
            "paper_title": "Knowledge Enhanced Contextual Word Representations",
            "rating": 2
        },
        {
            "paper_title": "KEPLER: A Unified Model for Knowledge Embedding and Pretrained Language Representation",
            "rating": 2
        },
        {
            "paper_title": "K-Adapter: Infusing Knowledge into Pre-trained Models with Adapters",
            "rating": 2
        },
        {
            "paper_title": "ERNIE: Enhanced Language Representation with Informative Entities",
            "rating": 2
        },
        {
            "paper_title": "Matching the Blanks: Distributional Similarity for Relation Learning",
            "rating": 1
        }
    ],
    "cost": 0.0158255,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>LUKE: Deep Contextualized Entity Representations with Entity-aware Self-attention</h1>
<p>Ikuya Yamada ${ }^{1,2}$<br>ikuya@ousia.jp<br>Akari Asai ${ }^{3}$<br>akari@cs.washington.edu<br>Hiroyuki Shindo ${ }^{4,2}$<br>shindo@is.naist.jp Hideaki Takeda ${ }^{5}$<br>takeda@nii.ac.jp<br>Yuji Matsumoto ${ }^{2}$<br>matsu@is.naist.jp<br>${ }^{1}$ Studio Ousia ${ }^{2}$ RIKEN AIP ${ }^{3}$ University of Washington<br>${ }^{4}$ Nara Institute of Science and Technology ${ }^{5}$ National Institute of Informatics</p>
<h4>Abstract</h4>
<p>Entity representations are useful in natural language tasks involving entities. In this paper, we propose new pretrained contextualized representations of words and entities based on the bidirectional transformer (Vaswani et al., 2017). The proposed model treats words and entities in a given text as independent tokens, and outputs contextualized representations of them. Our model is trained using a new pretraining task based on the masked language model of BERT (Devlin et al., 2019). The task involves predicting randomly masked words and entities in a large entity-annotated corpus retrieved from Wikipedia. We also propose an entity-aware self-attention mechanism that is an extension of the self-attention mechanism of the transformer, and considers the types of tokens (words or entities) when computing attention scores. The proposed model achieves impressive empirical performance on a wide range of entity-related tasks. In particular, it obtains state-of-the-art results on five well-known datasets: Open Entity (entity typing), TACRED (relation classification), CoNLL-2003 (named entity recognition), ReCoRD (cloze-style question answering), and SQuAD 1.1 (extractive question answering). Our source code and pretrained representations are available at https: //github.com/studio-ousia/luke.</p>
<h2>1 Introduction</h2>
<p>Many natural language tasks involve entities, e.g., relation classification, entity typing, named entity recognition (NER), and question answering (QA). Key to solving such entity-related tasks is a model to learn the effective representations of entities. Conventional entity representations assign each entity a fixed embedding vector that stores information regarding the entity in a knowledge base (KB) (Bordes et al., 2013; Trouillon et al., 2016; Yamada et al., 2016, 2017). Although these models capture
the rich information in the KB, they require entity linking to represent entities in a text, and cannot represent entities that do not exist in the KB.</p>
<p>By contrast, contextualized word representations (CWRs) based on the transformer (Vaswani et al., 2017), such as BERT (Devlin et al., 2019), and RoBERTa (Liu et al., 2020), provide effective general-purpose word representations trained with unsupervised pretraining tasks based on language modeling. Many recent studies have solved entity-related tasks using the contextualized representations of entities computed based on CWRs (Zhang et al., 2019; Peters et al., 2019; Joshi et al., 2020). However, the architecture of CWRs is not well suited to representing entities for the following two reasons: (1) Because CWRs do not output the span-level representations of entities, they typically need to learn how to compute such representations based on a downstream dataset that is typically small. (2) Many entity-related tasks, e.g., relation classification and QA, involve reasoning about the relationships between entities. Although the transformer can capture the complex relationships between words by relating them to each other multiple times using the self-attention mechanism (Clark et al., 2019; Reif et al., 2019), it is difficult to perform such reasoning between entities because many entities are split into multiple tokens in the model. Furthermore, the word-based pretraining task of CWRs is not suitable for learning the representations of entities because predicting a masked word given other words in the entity, e.g., predicting "Rings" given "The Lord of the [MASK]", is clearly easier than predicting the entire entity.</p>
<p>In this paper, we propose new pretrained contextualized representations of words and entities by developing LUKE (Language Understanding with Knowledge-based Embeddings). LUKE is based on a transformer (Vaswani et al., 2017) trained using a large amount of entity-annotated corpus</p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Architecture of LUKE using the input sentence "<em>Beyoncé lives in Los Angeles</em>." LUKE outputs contextualized representation for each word and entity in the text. The model is trained to predict randomly masked words (e.g., <em>lives</em> and <em>Angeles</em> in the figure) and entities (e.g., <em>Los Angeles</em> in the figure). Downstream tasks are solved using its output representations with linear classifiers.</p>
<p>obtained from Wikipedia. An important difference between LUKE and existing CWRs is that it treats not only words, but also entities as independent tokens, and computes intermediate and output representations for all tokens using the transformer (see Figure 1). Since entities are treated as tokens, LUKE can directly model the relationships between entities.</p>
<p>LUKE is trained using a new pretraining task, a straightforward extension of BERT's masked language model (MLM) (Devlin et al., 2019). The task involves randomly masking entities by replacing them with [MASK] entities, and trains the model by predicting the originals of these masked entities. We use RoBERTa as base pre-trained model, and conduct pretraining of the model by simultaneously optimizing the objectives of the MLM and our proposed task. When applied to downstream tasks, the resulting model can compute representations of arbitrary entities in the text using [MASK] entities as inputs. Furthermore, if entity annotation is available in the task, the model can compute entity representations based on the rich entity-centric information encoded in the corresponding entity embeddings.</p>
<p>Another key contribution of this paper is that it extends the transformer using our <em>entity-aware</em> self-attention mechanism. Unlike existing CWRs, our model needs to deal with two types of tokens, i.e., words and entities. Therefore, we assume that it is beneficial to enable the mechanism to easily determine the types of tokens. To this end, we enhance the self-attention mechanism by adopting different query mechanisms based on the attending token and the token attended to.</p>
<p>We validate the effectiveness of our proposed model by conducting extensive experiments on five standard entity-related tasks: entity typing, relation classification, NER, cloze-style QA, and extractive QA. Our model outperforms all baseline models, including RoBERTa, in all experiments, and obtains state-of-the-art results on five tasks: entity typing on the Open Entity dataset (Choi et al., 2018), relation classification on the TACRED dataset (Zhang et al., 2017), NER on the CoNLL-2003 dataset (Tjong Kim Sang and De Meulder, 2003), cloze-style QA on the ReCoRD dataset (Zhang et al., 2018a), and extractive QA on the SQuAD 1.1 dataset (Rajpurkar et al., 2016). We publicize our source code and pretrained representations at https://github.com/studio-ousia/luke.</p>
<p>The main contributions of this paper are summarized as follows:</p>
<ul>
<li>We propose LUKE, a new contextualized representations specifically designed to address entity-related tasks. LUKE is trained to predict randomly masked words and entities using a large amount of entity-annotated corpus obtained from Wikipedia.</li>
<li>We introduce an entity-aware self-attention mechanism, an effective extension of the original mechanism of transformer. The proposed mechanism considers the type of the tokens (words or entities) when computing attention scores.</li>
<li>LUKE achieves strong empirical performance and obtains state-of-the-art results on five popular datasets: Open Entity, TACRED, CoNLL-2003, ReCoRD, and SQuAD 1.1.</li>
</ul>
<h2>2 Related Work</h2>
<p>Static Entity Representations Conventional entity representations assign a fixed embedding to each entity in the KB. They include knowledge embeddings trained on knowledge graphs (Bordes et al., 2013; Yang et al., 2015; Trouillon et al., 2016), and embeddings trained using textual contexts or descriptions of entities retrieved from a KB (Yamada et al., 2016, 2017; Cao et al., 2017; Ganea and Hofmann, 2017). Similar to our pretraining task, NTEE (Yamada et al., 2017) and RELIC (Ling et al., 2020) use an approach that trains entity embeddings by predicting entities given their textual contexts obtained from a KB. The main drawbacks of this line of work, when representing entities in text, are that (1) they need to resolve entities in the text to corresponding KB entries to represent the entities, and (2) they cannot represent entities that do not exist in the KB.</p>
<p>Contextualized Word Representations Many recent studies have addressed entity-related tasks based on the contextualized representations of entities in text computed using the word representations of CWRs (Zhang et al., 2019; Baldini Soares et al., 2019; Peters et al., 2019; Joshi et al., 2020; Wang et al., 2019b, 2020). Representative examples of CWRs are ELMo (Peters et al., 2018) and BERT (Devlin et al., 2019), which are based on deep bidirectional long short-term memory (LSTM) and the transformer (Vaswani et al., 2017), respectively. BERT is trained using an MLM, a pretraining task that masks random words in the text and trains the model to predict the masked words. Most recent CWRs, such as RoBERTa (Liu et al., 2020), XLNet (Yang et al., 2019), SpanBERT (Joshi et al., 2020), ALBERT (Lan et al., 2020), BART (Lewis et al., 2020), and T5 (Raffel et al., 2020), are based on transformer trained using a task equivalent to or similar to the MLM. Similar to our proposed pretraining task that masks entities instead of words, several recent CWRs, e.g., SpanBERT, ALBERT, BART, and T5, have extended the MLM by randomly masking word spans instead of single words.</p>
<p>Furthermore, various recent studies have explored methods to enhance CWRs by injecting them with knowledge from external sources, such as KBs. ERNIE (Zhang et al., 2019) and KnowBERT (Peters et al., 2019) use a similar idea to enhance CWRs using static entity embeddings sep-
arately learned from a KB. WKLM (Xiong et al., 2020) trains the model to detect whether an entity name in text is replaced by another entity name of the same type. KEPLER (Wang et al., 2019b) conducts pretraining based on the MLM and a knowledge-embedding objective (Bordes et al., 2013). K-Adapter (Wang et al., 2020) was proposed concurrently with our work, and extends CWRs using neural adapters that inject factual and linguistic knowledge. This line of work is related to ours because our pretraining task also enhances the model using information in the KB.</p>
<p>Unlike the CWRs mentioned above, LUKE uses an improved transformer architecture with an entity-aware self-attention mechanism that is designed to effectively solve entity-related tasks. LUKE also outputs entity representations by learning how to compute them during pretraining. It achieves superior empirical results to existing CWRs and knowledge-enhanced CWRs in all of our experiments.</p>
<h2>3 LUKE</h2>
<p>Figure 1 shows the architecture of LUKE. The model adopts a multi-layer bidirectional transformer (Vaswani et al., 2017). It treats words and entities in the document as input tokens, and computes a representation for each token. Formally, given a sequence consisting of $m$ words $w_{1}, w_{2}, \ldots, w_{m}$ and $n$ entities $e_{1}, e_{2}, \ldots, e_{n}$, our model computes $D$-dimensional word representations $\mathbf{h}<em 1="1">{w</em>}}, \mathbf{h<em 2="2">{w</em>}}, \ldots, \mathbf{h<em m="m">{w</em>}}$, where $\mathbf{h<em e__1="e_{1">{w} \in \mathbb{R}^{D}$, and entity representations $\mathbf{h}</em>}}, \mathbf{h<em 2="2">{e</em>}}, \ldots, \mathbf{h<em n="n">{e</em>$. The entities can be Wikipedia entities (e.g., Beyoncé in Figure 1) or special entities (e.g., [MASK]).}}$, where $\mathbf{h}_{e} \in$ $\mathbb{R}^{D</p>
<h3>3.1 Input Representation</h3>
<p>The input representation of a token (word or entity) is computed using the following three embeddings:</p>
<ul>
<li>
<p>Token embedding represents the corresponding token. We denote the word token embedding by $\mathbf{A} \in \mathbb{R}^{V_{w} \times D}$, where $V_{w}$ is the number of words in our vocabulary. For computational efficiency, we represent the entity token embedding by decomposing it into two small matrices, $\mathbf{B} \in \mathbb{R}^{V_{e} \times H}$ and $\mathbf{U} \in \mathbb{R}^{H \times D}$, where $V_{e}$ is the number of entities in our vocabulary. Hence, the full matrix of the entity token embedding can be computed as BU.</p>
</li>
<li>
<p>Position embedding represents the position of the token in a word sequence. A word and an entity appearing at the $i$-th position in the sequence are represented as $\mathbf{C}<em i="i">{i} \in \mathbb{R}^{D}$ and $\mathbf{D}</em>$, respectively. If an entity name contains multiple words, its position embedding is computed by averaging the embeddings of the corresponding positions, as shown in Figure 1.} \in \mathbb{R}^{D</p>
</li>
<li>Entity type embedding represents that the token is an entity. The embedding is a single vector denoted by $\mathbf{e} \in \mathbb{R}^{D}$.</li>
</ul>
<p>The input representation of a word and that of an entity are computed by summing the token and position embeddings, and the token, position, and entity type embeddings, respectively. Following past work (Devlin et al., 2019; Liu et al., 2020), we insert special tokens [CLS] and [SEP] into the word sequence as the first and last words, respectively.</p>
<h3>3.2 Entity-aware Self-attention</h3>
<p>The self-attention mechanism is the foundation of the transformer (Vaswani et al., 2017), and relates tokens each other based on the attention score between each pair of tokens. Given a sequence of input vectors $\mathbf{x}<em 2="2">{1}, \mathbf{x}</em>}, \ldots, \mathbf{x<em i="i">{k}$, where $\mathbf{x}</em>} \in \mathbb{R}^{D}$, each of the output vectors $\mathbf{y<em 2="2">{1}, \mathbf{y}</em>}, \ldots, \mathbf{y<em i="i">{k}$, where $\mathbf{y}</em>$ is computed as:} \in \mathbb{R}^{L}$, is computed based on the weighted sum of the transformed input vectors. Here, each input and output vector corresponds to a token (a word or an entity) in our model; therefore, $k=m+n$. The $i$-th output vector $\mathbf{y}_{i</p>
<p>$$
\begin{aligned}
\mathbf{y}<em j="1">{i} &amp; =\sum</em>}^{k} \alpha_{i j} \mathbf{V} \mathbf{x<em i="i" j="j">{j} \
e</em>} &amp; =\frac{\mathbf{K} \mathbf{x<em i="i">{j}^{\top} \mathbf{Q} \mathbf{x}</em> \
\alpha_{i j} &amp; =\operatorname{softmax}\left(e_{i j}\right)
\end{aligned}
$$}}{\sqrt{L}</p>
<p>where $\mathbf{Q} \in \mathbb{R}^{L \times D}, \mathbf{K} \in \mathbb{R}^{L \times D}$, and $\mathbf{V} \in \mathbb{R}^{L \times D}$ denote the query, key, and value matrices, respectively.</p>
<p>Because LUKE handles two types of tokens (i.e., words and entities), we assume that it is beneficial to use the information of target token types when computing the attention scores $\left(e_{i j}\right)$. With this in mind, we enhance the mechanism by introducing an entity-aware query mechanism that uses a different query matrix for each possible pair of token types of $\mathbf{x}<em j="j">{i}$ and $\mathbf{x}</em>$. Formally, the attention score
$e_{i j}$ is computed as follows:
$e_{i j}= \begin{cases}\mathbf{K} \mathbf{x}<em i="i">{j}^{\top} \mathbf{Q} \mathbf{x}</em>}, &amp; \text { if both } \mathbf{x<em j="j">{i} \text { and } \mathbf{x}</em>} \text { are words } \ \mathbf{K} \mathbf{x<em 2="2" e="e" w="w">{j}^{\top} \mathbf{Q}</em>} \mathbf{x<em i="i">{i}, &amp; \text { if } \mathbf{x}</em>} \text { is word and } \mathbf{x<em j="j">{j} \text { is entity } \ \mathbf{K} \mathbf{x}</em>}^{\top} \mathbf{Q<em i="i">{c 2 w} \mathbf{x}</em>}, &amp; \text { if } \mathbf{x<em j="j">{i} \text { is entity and } \mathbf{x}</em>} \text { is word } \ \mathbf{K} \mathbf{x<em 2="2" c="c" e="e">{j}^{\top} \mathbf{Q}</em>} \mathbf{x<em i="i">{i}, &amp; \text { if both } \mathbf{x}</em>} \text { and } \mathbf{x<em 2="2" e="e" w="w">{j} \text { are entities }\end{cases}$
where $\mathbf{Q}</em>}, \mathbf{Q<em 2="2" e="e">{c 2 w}, \mathbf{Q}</em>$ are query matrices. Note that the computational costs of the original mechanism and our proposed mechanism are identical except the additional cost of computing gradients and updating the parameters of the additional query matrices at the training time.} \in \mathbb{R}^{L \times D</p>
<h3>3.3 Pretraining Task</h3>
<p>To pretrain LUKE, we use the conventional MLM and a new pretraining task that is an extension of the MLM to learn entity representations. In particular, we treat hyperlinks in Wikipedia as entity annotations, and train the model using a large entityannotated corpus retrieved from Wikipedia. We randomly mask a certain percentage of the entities by replacing them with special [MASK] entities ${ }^{1}$ and then train the model to predict the masked entities. Formally, the original entity corresponding to a masked entity is predicted by applying the softmax function over all entities in our vocabulary:</p>
<p>$$
\begin{aligned}
&amp; \hat{\mathbf{y}}=\operatorname{softmax}\left(\mathbf{B T} \mathbf{m}+\mathbf{b}<em h="h">{o}\right) \
&amp; \mathbf{m}=\operatorname{layer} _ \operatorname{norm}\left(\operatorname{gelu}\left(\mathbf{W}</em>} \mathbf{h<em h="h">{e}+\mathbf{b}</em>\right)\right)
\end{aligned}
$$</p>
<p>where $\mathbf{h}<em h="h">{e}$ is the representation corresponding to the masked entity, $\mathbf{T} \in \mathbb{R}^{H \times D}$ and $\mathbf{W}</em>} \in \mathbb{R}^{D \times D}$ are weight matrices, $\mathbf{b<em e="e">{o} \in \mathbb{R}^{V</em>$ are bias vectors, gelu $(\cdot)$ is the gelu activation function (Hendrycks and Gimpel, 2016), and layer_norm( $\cdot$ ) is the layer normalization function (Lei Ba et al., 2016). Our final loss function is the sum of MLM loss and cross-entropy loss on predicting the masked entities, where the latter is computed identically to the former.}}$ and $\mathbf{b}_{h} \in \mathbb{R}^{D</p>
<h3>3.4 Modeling Details</h3>
<p>Our model configuration follows RoBERTaLARGE (Liu et al., 2020), pretrained CWRs based on a bidirectional transformer and a variant of BERT (Devlin et al., 2019). In particular, our model is based on the bidirectional transformer with $D=1024$</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>hidden dimensions, 24 hidden layers, $L=64$ attention head dimensions, and 16 self-attention heads. The number of dimensions of the entity token embedding is set to $H=256$. The total number of parameters is approximately 483 M , consisting of 355 M in RoBERTa and 128 M in our entity embeddings. The input text is tokenized into words using RoBERTa's tokenizer with the vocabulary consisting of $V_{w}=50 K$ words. For computational efficiency, our entity vocabulary does not include all entities but only the $V_{e}=500 K$ entities most frequently appearing in our entity annotations. The entity vocabulary also includes two special entities, i.e., [MASK] and [UNK].</p>
<p>The model is trained via iterations over Wikipedia pages in a random order for 200K steps. To reduce training time, we initialize the parameters that LUKE have in common with RoBERTa (parameters in the transformer and the embeddings for words) using RoBERTa. Following past work (Devlin et al., 2019; Liu et al., 2020), we mask 15\% of all words and entities at random. If an entity does not exist in the vocabulary, we replace it with the [UNK] entity. We perform pretraining using the original self-attention mechanism rather than our entity-aware self-attention mechanism because we want an ablation study of our mechanism but can not afford to run pretraining twice. Query matrices of our self-attention mechanism $\left(\mathbf{Q}<em 2="2" e="e" w="w">{w 2 e}, \mathbf{Q}</em>$ ) are learned using downstream datasets. Further details of our pretraining are described in Appendix A.}\right.$, and $\mathbf{Q}_{e 2 e</p>
<h2>4 Experiments</h2>
<p>We conduct extensive experiments using five entityrelated tasks: entity typing, relation classification, NER, cloze-style QA, and extractive QA. We use similar model architectures for all tasks based on a simple linear classifier on top of the representations of words, entities, or both. Unless otherwise specified, we create the input word sequence by inserting tokens of [CLS] and [SEP] into the original word sequence as the first and the last tokens, respectively. The input entity sequence is built using [MASK] entities, special entities introduced for the task, or Wikipedia entities. The token embedding of a task-specific special entity is initialized using that of the [MASK] entity, and the query matrices of our entity-aware self-attention mechanism $\left(\mathbf{Q}<em 2="2" e="e" w="w">{w 2 e}, \mathbf{Q}</em>$.}\right.$, and $\mathbf{Q}_{e 2 e}$ ) are initialized using the original query matrix $\mathbf{Q</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Prec.</th>
<th style="text-align: right;">Rec.</th>
<th style="text-align: right;">F1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">UFET (Zhang et al., 2019)</td>
<td style="text-align: right;">77.4</td>
<td style="text-align: right;">60.6</td>
<td style="text-align: right;">68.0</td>
</tr>
<tr>
<td style="text-align: left;">BERT (Zhang et al., 2019)</td>
<td style="text-align: right;">76.4</td>
<td style="text-align: right;">71.0</td>
<td style="text-align: right;">73.6</td>
</tr>
<tr>
<td style="text-align: left;">ERNIE (Zhang et al., 2019)</td>
<td style="text-align: right;">78.4</td>
<td style="text-align: right;">72.9</td>
<td style="text-align: right;">75.6</td>
</tr>
<tr>
<td style="text-align: left;">KEPLER (Wang et al., 2019b)</td>
<td style="text-align: right;">77.2</td>
<td style="text-align: right;">74.2</td>
<td style="text-align: right;">75.7</td>
</tr>
<tr>
<td style="text-align: left;">KnowBERT (Peters et al., 2019)</td>
<td style="text-align: right;">78.6</td>
<td style="text-align: right;">73.7</td>
<td style="text-align: right;">76.1</td>
</tr>
<tr>
<td style="text-align: left;">K-Adapter (Wang et al., 2020)</td>
<td style="text-align: right;">79.3</td>
<td style="text-align: right;">75.8</td>
<td style="text-align: right;">77.5</td>
</tr>
<tr>
<td style="text-align: left;">RoBERTa (Wang et al., 2020)</td>
<td style="text-align: right;">77.6</td>
<td style="text-align: right;">75.0</td>
<td style="text-align: right;">76.2</td>
</tr>
<tr>
<td style="text-align: left;">LUKE</td>
<td style="text-align: right;">$\mathbf{7 9 . 9}$</td>
<td style="text-align: right;">$\mathbf{7 6 . 6}$</td>
<td style="text-align: right;">$\mathbf{7 8 . 2}$</td>
</tr>
</tbody>
</table>
<p>Table 1: Results of entity typing on the Open Entity dataset.</p>
<p>Because we use RoBERTa as the base model in our pretraining, we use it as our primary baseline for all tasks. We omit a description of the baseline models in each section if they are described in Section 2. Further details of our experiments are available in Appendix B.</p>
<h3>4.1 Entity Typing</h3>
<p>We first conduct experiments on entity typing, which is the task of predicting the types of an entity in the given sentence. Following Zhang et al. (2019), we use the Open Entity dataset (Choi et al., 2018), and consider only nine general entity types. Following Wang et al. (2020), we report loose micro-precision, recall, and F1, and employ the micro-F1 as the primary metric.</p>
<p>Model We represent the target entity using the [MASK] entity, and enter words and the entity in each sentence into the model. We then classify the entity using a linear classifier based on the corresponding entity representation. We treat the task as multi-label classification, and train the model using binary cross-entropy loss averaged over all entity types.</p>
<p>Baselines UFET (Choi et al., 2018) is a conventional model that computes context representations using the bidirectional LSTM. We also use BERT, RoBERTa, ERNIE, KnowBERT, KEPLER, and KAdapter as baselines.</p>
<p>Results Table 1 shows the experimental results. LUKE significantly outperforms our primary baseline, RoBERTa, by 2.0 F1 points, and the previous best published model, KnowBERT, by 2.1 F1 points. Furthermore, LUKE achieves a new state of the art by outperforming K-Adapter by 0.7 F1 points.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Prec.</th>
<th style="text-align: right;">Rec.</th>
<th style="text-align: right;">F1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">BERT (Zhang et al., 2019)</td>
<td style="text-align: right;">67.2</td>
<td style="text-align: right;">64.8</td>
<td style="text-align: right;">66.0</td>
</tr>
<tr>
<td style="text-align: left;">C-GCN (Zhang et al., 2018b)</td>
<td style="text-align: right;">69.9</td>
<td style="text-align: right;">63.3</td>
<td style="text-align: right;">66.4</td>
</tr>
<tr>
<td style="text-align: left;">ERNIE (Zhang et al., 2019)</td>
<td style="text-align: right;">70.0</td>
<td style="text-align: right;">66.1</td>
<td style="text-align: right;">68.0</td>
</tr>
<tr>
<td style="text-align: left;">SpanBERT (Joshi et al., 2020)</td>
<td style="text-align: right;">70.8</td>
<td style="text-align: right;">70.9</td>
<td style="text-align: right;">70.8</td>
</tr>
<tr>
<td style="text-align: left;">MTB (Baldini Soares et al., 2019)</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">71.5</td>
</tr>
<tr>
<td style="text-align: left;">KnowBERT (Peters et al., 2019)</td>
<td style="text-align: right;">$\mathbf{7 1 . 6}$</td>
<td style="text-align: right;">71.4</td>
<td style="text-align: right;">71.5</td>
</tr>
<tr>
<td style="text-align: left;">KEPLER (Wang et al., 2019b)</td>
<td style="text-align: right;">70.4</td>
<td style="text-align: right;">73.0</td>
<td style="text-align: right;">71.7</td>
</tr>
<tr>
<td style="text-align: left;">K-Adapter (Wang et al., 2020)</td>
<td style="text-align: right;">68.9</td>
<td style="text-align: right;">$\mathbf{7 5 . 4}$</td>
<td style="text-align: right;">72.0</td>
</tr>
<tr>
<td style="text-align: left;">RoBERTa (Wang et al., 2020)</td>
<td style="text-align: right;">70.2</td>
<td style="text-align: right;">72.4</td>
<td style="text-align: right;">71.3</td>
</tr>
<tr>
<td style="text-align: left;">LUKE</td>
<td style="text-align: right;">70.4</td>
<td style="text-align: right;">75.1</td>
<td style="text-align: right;">$\mathbf{7 2 . 7}$</td>
</tr>
</tbody>
</table>
<p>Table 2: Results of relation classification on the TACRED dataset.</p>
<h3>4.2 Relation Classification</h3>
<p>Relation classification determines the correct relation between head and tail entities in a sentence. We conduct experiments using TACRED dataset (Zhang et al., 2017), a large-scale relation classification dataset containing 106,264 sentences with 42 relation types. Following Wang et al. (2020), we report the micro-precision, recall, and F1, and use the micro-F1 as the primary metric.</p>
<p>Model We introduce two special entities, [HEAD] and [TAIL], to represent the head and the tail entities, respectively, and input words and these two entities in each sentence to the model. We then solve the task using a linear classifier based on a concatenated representation of the head and tail entities. The model is trained using cross-entropy loss.</p>
<p>Baselines C-GCN (Zhang et al., 2018b) uses graph convolutional networks over dependency tree structures to solve the task. MTB (Baldini Soares et al., 2019) learns relation representations based on BERT through the matching-the-blanks task using a large amount of entity-annotated text. We also compare LUKE with BERT, RoBERTa, SpanBERT, ERNIE, KnowBERT, KEPLER, and K-Adapter.</p>
<p>Results The experimental results are presented in Table 2. LUKE clearly outperforms our primary baseline, RoBERTa, by 1.4 F1 points, and the previous best published models, namely MTB and KnowBERT, by 1.2 F1 points. Furthermore, it achieves a new state of the art by outperforming K-Adapter by 0.7 F1 points.</p>
<h3>4.3 Named Entity Recognition</h3>
<p>We conduct experiments on the NER task using the standard CoNLL-2003 dataset (Tjong Kim Sang and De Meulder, 2003). Following past work, we</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: center;">F1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">LSTM-CRF (Lample et al., 2016)</td>
<td style="text-align: center;">91.0</td>
</tr>
<tr>
<td style="text-align: left;">ELMo (Peters et al., 2018)</td>
<td style="text-align: center;">92.2</td>
</tr>
<tr>
<td style="text-align: left;">BERT (Devlin et al., 2019)</td>
<td style="text-align: center;">92.8</td>
</tr>
<tr>
<td style="text-align: left;">Akbik et al. (2018)</td>
<td style="text-align: center;">93.1</td>
</tr>
<tr>
<td style="text-align: left;">Baevski et al. (2019)</td>
<td style="text-align: center;">93.5</td>
</tr>
<tr>
<td style="text-align: left;">RoBERTa</td>
<td style="text-align: center;">92.4</td>
</tr>
<tr>
<td style="text-align: left;">LUKE</td>
<td style="text-align: center;">$\mathbf{9 4 . 3}$</td>
</tr>
</tbody>
</table>
<p>Table 3: Results of named entity recognition on the CoNLL-2003 dataset.
report the span-level F1.
Model Following Sohrab and Miwa (2018), we solve the task by enumerating all possible spans (or n-grams) in each sentence as entity name candidates, and classifying them into the target entity types or non-entity type, which indicates that the span is not an entity. For each sentence in the dataset, we enter words and the [MASK] entities corresponding to all possible spans. The representation of each span is computed by concatenating the word representations of the first and last words in the span, and the entity representation corresponding to the span. We classify each span using a linear classifier with its representation, and train the model using cross-entropy loss. We exclude spans longer than 16 words for computational efficiency. During the inference, we first exclude all spans classified into the non-entity type. To avoid selecting overlapping spans, we greedily select a span from the remaining spans based on the logit of its predicted entity type in descending order if the span does not overlap with those already selected. Following Devlin et al. (2019), we include the maximal document context in the target document.</p>
<p>Baselines LSTM-CRF (Lample et al., 2016) is a model based on the bidirectional LSTM with conditional random fields (CRF). Akbik et al. (2018) address the task using the bidirectional LSTM with CRF enhanced with character-level contextualized representations. Similarly, Baevski et al. (2019) use the bidirectional LSTM with CRF enhanced with CWRs based on a bidirectional transformer. We also use ELMo, BERT, and RoBERTa as baselines. To conduct a fair comparison with RoBERTa, we report its performance using the model described above with the span representation computed by concatenating the representations of the first and last words of the span.</p>
<p>Results The experimental results are shown in Table 3. LUKE outperforms RoBERTa by 1.9 F1</p>
<p>points. Furthermore, it achieves a new state of the art on this competitive dataset by outperforming the previous state of the art reported in Baevski et al. (2019) by 0.8 F1 points.</p>
<h3>4.4 Cloze-style Question Answering</h3>
<p>We evaluate our model on the ReCoRD dataset (Zhang et al., 2018a), a cloze-style QA dataset consisting of over 120K examples. An interesting characteristic of this dataset is that most of its questions cannot be solved without external knowledge. The following is an example question and its answer in the dataset:
Question: According to claims in the suit, "Parts of 'Stairway to Heaven,' instantly recognizable to the music fans across the world, sound almost identical to significant portions of ' $\mathbf{X}$."' Answer: Taurus
Given a question and a passage, the task is to find the entity mentioned in the passage that fits the missing entity (denoted by $\mathbf{X}$ in the question above). In this dataset, annotations of entity spans (start and end positions) in a passage are provided, and the answer is contained in the provided entity spans one or multiple times. Following past work, we evaluate the models using exact match (EM) and token-level F1 on the development and test sets.</p>
<p>Model We solve this task by assigning a relevance score to each entity in the passage and selecting the entity with the highest score as the answer. Following Liu et al. (2020), given a question $q_{1}, q_{2}, \ldots, q_{j}$, and a passage $p_{1}, p_{2}, \ldots, p_{l}$, the input word sequence is constructed as: $[\mathrm{CLS}] q_{1}, q_{2}, \ldots, q_{j}[\mathrm{SEP}]$ [SEP] $p_{1}, p_{2}, \ldots, p_{l}$ [SEP]. Further, we input [MASK] entities corresponding to the missing entity and all entities in the passage. We compute the relevance score of each entity in the passage using a linear classifier with the concatenated representation of the missing entity and the corresponding entity. We train the model using binary cross-entropy loss averaged over all entities in the passage, and select the entity with the highest score (logit) as the answer.</p>
<p>Baselines DocQA+ELMo (Clark and Gardner, 2018) is a model based on ELMo, bidirectional attention flow (Seo et al., 2017), and self-attention mechanism. XLNet+Verifier (Li et al., 2019) is a model based on XLNet with rule-based answer verification, and is the winner of a recent competition</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: center;">Dev <br> EM</th>
<th style="text-align: center;">Dev <br> F1</th>
<th style="text-align: center;">Test <br> EM</th>
<th style="text-align: center;">Test <br> F1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">DocQA+ELMo (Zhang et al., 2018a)</td>
<td style="text-align: center;">44.1</td>
<td style="text-align: center;">45.4</td>
<td style="text-align: center;">45.4</td>
<td style="text-align: center;">46.7</td>
</tr>
<tr>
<td style="text-align: left;">BERT (Wang et al., 2019a)</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">71.3</td>
<td style="text-align: center;">72.0</td>
</tr>
<tr>
<td style="text-align: left;">XLNet+Verifier (Li et al., 2019)</td>
<td style="text-align: center;">80.6</td>
<td style="text-align: center;">82.1</td>
<td style="text-align: center;">81.5</td>
<td style="text-align: center;">82.7</td>
</tr>
<tr>
<td style="text-align: left;">RoBERTa (Liu et al., 2020)</td>
<td style="text-align: center;">89.0</td>
<td style="text-align: center;">89.5</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">RoBERTa (ensemble) (Liu et al., 2020)</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">90.0</td>
<td style="text-align: center;">90.6</td>
</tr>
<tr>
<td style="text-align: left;">LUKE</td>
<td style="text-align: center;">$\mathbf{9 0 . 8}$</td>
<td style="text-align: center;">$\mathbf{9 1 . 4}$</td>
<td style="text-align: center;">$\mathbf{9 0 . 6}$</td>
<td style="text-align: center;">$\mathbf{9 1 . 2}$</td>
</tr>
</tbody>
</table>
<p>Table 4: Results of cloze-style question answering on the ReCoRD dataset. All models except RoBERTa (ensemble) are based on a single model.
based on this dataset (Ostermann et al., 2019). We also use BERT and RoBERTa as baselines.</p>
<p>Results The results are presented in Table 4. LUKE significantly outperforms RoBERTa, the best baseline, on the development set by 1.8 EM points and 1.9 F1 points. Furthermore, it achieves superior results to RoBERTa (ensemble) on the test set without ensembling the models.</p>
<h3>4.5 Extractive Question Answering</h3>
<p>Finally, we conduct experiments using the wellknown Stanford Question Answering Dataset (SQuAD) 1.1 consisting of 100 K question/answer pairs (Rajpurkar et al., 2016). Given a question and a Wikipedia passage containing the answer, the task is to predict the answer span in the passage. Following past work, we report the EM and token-level F1 on the development and test sets.</p>
<p>Model We construct the word sequence from the question and the passage in the same way as in the previous experiment. Unlike in the other experiments, we input Wikipedia entities into the model based on entity annotations automatically generated on the question and the passage using a mapping from entity names (e.g., "U.S.") to their referent entities (e.g., United States). The mapping is automatically created using the entity hyperlinks in Wikipedia as described in detail in Appendix C. We solve this task using the same model architecture as that of BERT and RoBERTa. In particular, we use two linear classifiers independently on top of the word representations to predict the span boundary of the answer (i.e., the start and end positions), and train the model using cross-entropy loss.</p>
<p>Baselines We compare our models with the results of recent CWRs, including BERT, RoBERTa, SpanBERT, XLNet, and ALBERT. Because the results for RoBERTa and ALBERT are reported only on the development set, we conduct a comparison</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: center;">Dev <br> EM</th>
<th style="text-align: center;">Dev <br> F1</th>
<th style="text-align: center;">Test <br> EM</th>
<th style="text-align: center;">Test <br> F1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">BERT (Devlin et al., 2019)</td>
<td style="text-align: center;">84.2</td>
<td style="text-align: center;">91.1</td>
<td style="text-align: center;">85.1</td>
<td style="text-align: center;">91.8</td>
</tr>
<tr>
<td style="text-align: left;">SpanBERT (Joshi et al., 2020)</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">88.8</td>
<td style="text-align: center;">94.6</td>
</tr>
<tr>
<td style="text-align: left;">XLNet (Yang et al., 2019)</td>
<td style="text-align: center;">89.0</td>
<td style="text-align: center;">94.5</td>
<td style="text-align: center;">89.9</td>
<td style="text-align: center;">95.1</td>
</tr>
<tr>
<td style="text-align: left;">ALBERT (Lan et al., 2020)</td>
<td style="text-align: center;">89.3</td>
<td style="text-align: center;">94.8</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">RoBERTa (Liu et al., 2020)</td>
<td style="text-align: center;">88.9</td>
<td style="text-align: center;">94.6</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">LUKE</td>
<td style="text-align: center;">$\mathbf{8 9 . 8}$</td>
<td style="text-align: center;">$\mathbf{9 5 . 0}$</td>
<td style="text-align: center;">$\mathbf{9 0 . 2}$</td>
<td style="text-align: center;">$\mathbf{9 5 . 4}$</td>
</tr>
</tbody>
</table>
<p>Table 5: Results of extractive question answering on the SQuAD 1.1 dataset.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: center;">CoNLL-2003</th>
<th style="text-align: center;">SQuAD</th>
<th style="text-align: center;">SQuAD</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">(Text F1)</td>
<td style="text-align: center;">(Dev EM)</td>
<td style="text-align: center;">(Dev F1)</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">LUKE w/o entity inputs</td>
<td style="text-align: center;">92.9</td>
<td style="text-align: center;">89.2</td>
<td style="text-align: center;">94.8</td>
</tr>
<tr>
<td style="text-align: left;">LUKE</td>
<td style="text-align: center;">$\mathbf{9 4 . 3}$</td>
<td style="text-align: center;">$\mathbf{8 9 . 8}$</td>
<td style="text-align: center;">$\mathbf{9 5 . 0}$</td>
</tr>
</tbody>
</table>
<p>Table 6: Ablation study of our entity representations.
with these models using this set. To conduct a fair compassion with RoBERTa, we use the same model architecture and hyper-parameters as those of RoBERTa (Liu et al., 2020).</p>
<p>Results The experimental results are presented in Table 5. LUKE outperforms our primary baseline, RoBERTa, by 0.9 EM points and 0.4 F1 points on the development set. Furthermore, it achieves a new state of the art on this competitive dataset by outperforming XLNet by 0.3 points both in terms of EM and F1. Note that XLNet uses a more sophisticated model involving beam search than the other models considered here.</p>
<h2>5 Analysis</h2>
<p>In this section, we provide a detailed analysis of LUKE by reporting three additional experiments.</p>
<h3>5.1 Effects of Entity Representations</h3>
<p>To investigate how our entity representations influence performance on downstream tasks, we perform an ablation experiment by addressing NER on the CoNLL-2003 dataset and extractive QA on the SQuAD dataset without inputting any entities. In this setting, LUKE uses only the word sequence to compute the representation for each word. We address the tasks using the same model architectures as those for RoBERTa described in the corresponding sections. As shown in Table 6, this setting clearly degrades performance, i.e., 1.4 F1 points on the CoNLL-2003 dataset and 0.6 EM points on the SQuAD dataset, demonstrating the effectiveness of our entity representations on these two tasks.</p>
<h3>5.2 Effects of Entity-aware Self-attention</h3>
<p>We conduct an ablation study of our entity-aware self-attention mechanism by comparing the performance of LUKE using our mechanism with that using the original mechanism of the transformer. As shown in Table 7, our entity-aware self-attention mechanism consistently outperforms the original mechanism across all tasks. Furthermore, we observe significant improvements on two kinds of tasks, relation classification (TACRED) and QA (ReCoRD and SQuAD). Because these tasks involve reasoning based on relationships between entities, we consider that our mechanism enables the model (i.e., attention heads) to easily focus on capturing the relationships between entities.</p>
<h3>5.3 Effects of Extra Pretraining</h3>
<p>As mentioned in Section 3.4, LUKE is based on RoBERTa with pretraining for 200K steps using our Wikipedia corpus. Because past studies (Liu et al., 2020; Lan et al., 2020) suggest that simply increasing the number of training steps of CWRs tends to improve performance on downstream tasks, the superior experimental results of LUKE compared with those of RoBERTa may be obtained because of its greater number of pretraining steps. To investigate this, we train another model based on RoBERTa with extra pretraining based on the MLM using the Wikipedia corpus for 200K training steps. The detailed configuration used in the pretraining is available in Appendix A.</p>
<p>We evaluate the performance of this model on the CoNLL-2003 and SQuAD datasets using the same model architectures as those for RoBERTa described in the corresponding sections. As shown in Table 8, the model achieves similar performance to the original RoBERTa on both datasets, which indicates that the superior performance of LUKE is not owing to its longer pretraining.</p>
<h2>6 Conclusions</h2>
<p>In this paper, we propose LUKE, new pretrained contextualized representations of words and entities based on the transformer. LUKE outputs the contextualized representations of words and entities using an improved transformer architecture with using a novel entity-aware self-attention mechanism. The experimental results prove its effectiveness on various entity-related tasks. Future work involves applying LUKE to domain-specific tasks, such as those in biomedical and legal domains.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: center;">Open Entity <br> (Test F1)</th>
<th style="text-align: center;">TACRED <br> (Test F1)</th>
<th style="text-align: center;">CoNLL-2003 <br> (Test F1)</th>
<th style="text-align: center;">ReCoRD <br> (Dev EM)</th>
<th style="text-align: center;">ReCoRD <br> (Dev F1)</th>
<th style="text-align: center;">SQuAD <br> (Dev EM)</th>
<th style="text-align: center;">SQuAD <br> (Dev F1)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Original Attention</td>
<td style="text-align: center;">77.9</td>
<td style="text-align: center;">72.2</td>
<td style="text-align: center;">94.1</td>
<td style="text-align: center;">90.1</td>
<td style="text-align: center;">90.7</td>
<td style="text-align: center;">89.2</td>
<td style="text-align: center;">94.7</td>
</tr>
<tr>
<td style="text-align: left;">Entity-aware Attention</td>
<td style="text-align: center;">$\mathbf{7 8 . 2}$</td>
<td style="text-align: center;">$\mathbf{7 2 . 7}$</td>
<td style="text-align: center;">$\mathbf{9 4 . 3}$</td>
<td style="text-align: center;">$\mathbf{9 0 . 8}$</td>
<td style="text-align: center;">$\mathbf{9 1 . 4}$</td>
<td style="text-align: center;">$\mathbf{8 9 . 8}$</td>
<td style="text-align: center;">$\mathbf{9 5 . 0}$</td>
</tr>
</tbody>
</table>
<p>Table 7: Ablation study of our entity-aware self-attention mechanism.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: center;">CoNLL-2003 <br> (Test F1)</th>
<th style="text-align: center;">SQuAD <br> (Dev EM)</th>
<th style="text-align: center;">SQuAD <br> (Dev F1)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">RoBERTa w/ extra training</td>
<td style="text-align: center;">92.5</td>
<td style="text-align: center;">89.1</td>
<td style="text-align: center;">94.7</td>
</tr>
<tr>
<td style="text-align: left;">RoBERTa</td>
<td style="text-align: center;">92.4</td>
<td style="text-align: center;">88.9</td>
<td style="text-align: center;">94.6</td>
</tr>
<tr>
<td style="text-align: left;">LUKE</td>
<td style="text-align: center;">$\mathbf{9 4 . 3}$</td>
<td style="text-align: center;">$\mathbf{8 9 . 8}$</td>
<td style="text-align: center;">$\mathbf{9 5 . 0}$</td>
</tr>
</tbody>
</table>
<p>Table 8: Results of RoBERTa additionally trained using our Wikipedia corpus.</p>
<h2>References</h2>
<p>Alan Akbik, Duncan Blythe, and Roland Vollgraf. 2018. Contextual String Embeddings for Sequence Labeling. In Proceedings of the 27th International Conference on Computational Linguistics, pages $1638-1649$.</p>
<p>Alexei Baevski, Sergey Edunov, Yinhan Liu, Luke Zettlemoyer, and Michael Auli. 2019. Cloze-driven Pretraining of Self-attention Networks. In Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing and the 9th International Joint Conference on Natural Language Processing, pages 5360-5369.</p>
<p>Livio Baldini Soares, Nicholas FitzGerald, Jeffrey Ling, and Tom Kwiatkowski. 2019. Matching the Blanks: Distributional Similarity for Relation Learning. In Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics, pages 2895-2905.</p>
<p>Antoine Bordes, Nicolas Usunier, Alberto GarciaDuran, Jason Weston, and Oksana Yakhnenko. 2013. Translating Embeddings for Modeling Multirelational Data. In Advances in Neural Information Processing Systems 26, pages 2787-2795.</p>
<p>Yixin Cao, Lifu Huang, Heng Ji, Xu Chen, and Juanzi Li. 2017. Bridge Text and Knowledge by Learning Multi-Prototype Entity Mention Embedding. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 1623-1633.</p>
<p>Eunsol Choi, Omer Levy, Yejin Choi, and Luke Zettlemoyer. 2018. Ultra-Fine Entity Typing. In Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 87-96.</p>
<p>Christopher Clark and Matt Gardner. 2018. Simple and Effective Multi-Paragraph Reading Comprehension. In Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 845-855.</p>
<p>Kevin Clark, Urvashi Khandelwal, Omer Levy, and Christopher D Manning. 2019. What Does BERT Look at? An Analysis of BERT's Attention. In Proceedings of the 2019 ACL Workshop BlackboxNLP: Analyzing and Interpreting Neural Networks for NLP, pages 276-286.</p>
<p>Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2019. BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding. In Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long and Short Papers), pages 4171-4186.</p>
<p>Octavian-Eugen Ganea and Thomas Hofmann. 2017. Deep Joint Entity Disambiguation with Local Neural Attention. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, pages 2619-2629.</p>
<p>Dan Hendrycks and Kevin Gimpel. 2016. Gaussian Error Linear Units (GELUs). arXiv preprint arXiv:1606.08415v3.</p>
<p>Mandar Joshi, Danqi Chen, Yinhan Liu, Daniel S Weld, Luke Zettlemoyer, and Omer Levy. 2020. SpanBERT: Improving Pre-training by Representing and Predicting Spans. Transactions of the Association for Computational Linguistics, 8:64-77.</p>
<p>Guillaume Lample, Miguel Ballesteros, Sandeep Subramanian, Kazuya Kawakami, and Chris Dyer. 2016. Neural Architectures for Named Entity Recognition. In Proceedings of the 2016 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, pages $260-270$.</p>
<p>Zhenzhong Lan, Mingda Chen, Sebastian Goodman, Kevin Gimpel, Piyush Sharma, and Radu Soricut. 2020. ALBERT: A Lite BERT for Self-supervised Learning of Language Representations. In International Conference on Learning Representations.</p>
<p>Jimmy Lei Ba, Jamie Ryan Kiros, and Geoffrey E Hinton. 2016. Layer Normalization. arXiv preprint arXiv:1607.06450v1.</p>
<p>Mike Lewis, Yinhan Liu, Naman Goyal, Marjan Ghazvininejad, Abdelrahman Mohamed, Omer Levy, Veselin Stoyanov, and Luke Zettlemoyer. 2020. BART: Denoising Sequence-to-Sequence Pretraining for Natural Language Generation, Translation, and Comprehension. In Proceedings of the 58th Annual Meeting of the Association for Computational Linguistics, pages 7871-7880.</p>
<p>Xiepeng Li, Zhexi Zhang, Wei Zhu, Zheng Li, Yuan Ni, Peng Gao, Junchi Yan, and Guotong Xie. 2019. Pingan Smart Health and SJTU at COIN - Shared Task: utilizing Pre-trained Language Models and Common-sense Knowledge in Machine Reading Tasks. In Proceedings of the First Workshop on Commonsense Inference in Natural Language Processing, pages 93-98.</p>
<p>Jeffrey Ling, Nicholas FitzGerald, Zifei Shan, Livio Baldini Soares, Thibault Févry, David Weiss, and Tom Kwiatkowski. 2020. Learning CrossContext Entity Representations from Text. arXiv preprint arXiv:2001.03765v1.</p>
<p>Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Danqi Chen, Omer Levy, Mike Lewis, Luke Zettlemoyer, and Veselin Stoyanov. 2020. RoBERTa: A Robustly Optimized BERT Pretraining Approach. arXiv preprint arXiv:1907.11692v1.</p>
<p>Simon Ostermann, Sheng Zhang, Michael Roth, and Peter Clark. 2019. Commonsense Inference in Natural Language Processing (COIN) - Shared Task Report. In Proceedings of the First Workshop on Commonsense Inference in Natural Language Processing, pages 66-74.</p>
<p>Matthew Peters, Mark Neumann, Mohit Iyyer, Matt Gardner, Christopher Clark, Kenton Lee, and Luke Zettlemoyer. 2018. Deep Contextualized Word Representations. In Proceedings of the 2018 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long Papers), pages 22272237.</p>
<p>Matthew E. Peters, Mark Neumann, Robert Logan, Roy Schwartz, Vidur Joshi, Sameer Singh, and Noah A. Smith. 2019. Knowledge Enhanced Contextual Word Representations. In Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing and the 9th International Joint Conference on Natural Language Processing, pages 43-54.</p>
<p>Colin Raffel, Noam Shazeer, Adam Roberts, Katherine Lee, Sharan Narang, Michael Matena, Yanqi Zhou, Wei Li, and Peter J Liu. 2020. Exploring the Limits of Transfer Learning with a Unified Text-toText Transformer. Journal of Machine Learning Research, 21(140):1-67.</p>
<p>Pranav Rajpurkar, Jian Zhang, Konstantin Lopyrev, and Percy Liang. 2016. SQuAD: 100,000+ Questions for Machine Comprehension of Text. In Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing, pages 2383-2392.</p>
<p>Emily Reif, Ann Yuan, Martin Wattenberg, Fernanda B Viegas, Andy Coenen, Adam Pearce, and Been Kim. 2019. Visualizing and Measuring the Geometry of BERT. In Advances in Neural Information Processing Systems 32, pages 8594-8603.</p>
<p>Minjoon Seo, Aniruddha Kembhavi, Ali Farhadi, and Hananneh Hajishirzi. 2017. Bidirectional Attention Flow for Machine Comprehension. In International Conference on Learning Representations.</p>
<p>Mohammad Golam Sohrab and Makoto Miwa. 2018. Deep Exhaustive Model for Nested Named Entity Recognition. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 2843-2849.</p>
<p>Erik F. Tjong Kim Sang and Fien De Meulder. 2003. Introduction to the CoNLL-2003 Shared Task: Language-Independent Named Entity Recognition. In Proceedings of the Seventh Conference on Natural Language Learning at HLT-NAACL 2003.</p>
<p>Théo Trouillon, Johannes Welbl, Sebastian Riedel, Eric Gaussier, and Guillaume Bouchard. 2016. Complex Embeddings for Simple Link Prediction. In Proceedings of The 33rd International Conference on Machine Learning, volume 48, pages 2071-2080.</p>
<p>Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Łukasz Kaiser, and Illia Polosukhin. 2017. Attention Is All You Need. In Advances in Neural Information Processing Systems 30, pages 5998-6008.</p>
<p>Alex Wang, Yada Pruksachatkun, Nikita Nangia, Amanpreet Singh, Julian Michael, Felix Hill, Omer Levy, and Samuel Bowman. 2019a. SuperGLUE: A Stickier Benchmark for General-Purpose Language Understanding Systems. In Advances in Neural Information Processing Systems 32, pages 3266-3280.</p>
<p>Ruize Wang, Duyu Tang, Nan Duan, Zhongyu Wei, Xuanjing Huang, Cuihong Cao, Daxin Jiang, Ming Zhou, and others. 2020. K-Adapter: Infusing Knowledge into Pre-trained Models with Adapters. arXiv preprint arXiv:2002.01808v3.</p>
<p>Xiaozhi Wang, Tianyu Gao, Zhaocheng Zhu, Zhiyuan Liu, Juanzi Li, and Jian Tang. 2019b. KEPLER: A Unified Model for Knowledge Embedding and Pretrained Language Representation. arXiv preprint arXiv:1911.06136v1.</p>
<p>Wenhan Xiong, Jingfei Du, William Yang Wang, and Veselin Stoyanov. 2020. Pretrained Encyclopedia: Weakly Supervised Knowledge-Pretrained Language Model. In International Conference on Learning Representations.</p>
<p>Ikuya Yamada, Hiroyuki Shindo, Hideaki Takeda, and Yoshiyasu Takefuji. 2016. Joint Learning of the Embedding of Words and Entities for Named Entity Disambiguation. In Proceedings of the 20th SIGNLL Conference on Computational Natural Language Learning, pages 250-259.</p>
<p>Ikuya Yamada, Hiroyuki Shindo, Hideaki Takeda, and Yoshiyasu Takefuji. 2017. Learning Distributed Representations of Texts and Entities from Knowledge Base. Transactions of the Association for Computational Linguistics, 5:397-411.</p>
<p>Bishan Yang, Scott Wen-tau Yih, Xiaodong He, Jianfeng Gao, and Li Deng. 2015. Embedding Entities and Relations for Learning and Inference in Knowledge Bases. In Proceedings of the International Conference on Learning Representations.</p>
<p>Zhilin Yang, Zihang Dai, Yiming Yang, Jaime Carbonell, Ruslan Salakhutdinov, and Quoc V Le. 2019. XLNet: Generalized Autoregressive Pretraining for Language Understanding. arXiv preprint arXiv:1906.08237v1.</p>
<p>Sheng Zhang, Xiaodong Liu, Jingjing Liu, Jianfeng Gao, Kevin Duh, and Benjamin Van Durme. 2018a. ReCoRD: Bridging the Gap between Human and Machine Commonsense Reading Comprehension. arXiv preprint arXiv:1810.12885v1.</p>
<p>Yuhao Zhang, Peng Qi, and Christopher D Manning. 2018b. Graph Convolution over Pruned Dependency Trees Improves Relation Extraction. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 22052215.</p>
<p>Yuhao Zhang, Victor Zhong, Danqi Chen, Gabor Angeli, and Christopher D Manning. 2017. Positionaware Attention and Supervised Data Improve Slot Filling. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, pages $35-45$.</p>
<p>Zhengyan Zhang, Xu Han, Zhiyuan Liu, Xin Jiang, Maosong Sun, and Qun Liu. 2019. ERNIE: Enhanced Language Representation with Informative Entities. In Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics, pages 1441-1451.</p>
<h2>Appendix for "LUKE: Deep Contextualized Entity Representations with Entity-aware Self-attention"</h2>
<h2>A Details of Pretraining</h2>
<p>As input corpus for pretraining, we use the December 2018 version of Wikipedia, comprising approximately 3.5 billion words and 11 million entity annotations. We generate input sequences by splitting the content of each page into sequences comprising $\leq 512$ words and their entity annotations (i.e., hyperlinks). We optimize the model using AdamW with learning rate warmup and linear decay of the learning rate. To stabilize training, we update only those parameters that are randomly initialized (i.e., fix the parameters that are initialized using RoBERTa) in the first 100K steps, and update all parameters in the remaining 100K steps. We run the pretraining on NVIDIA's PyTorch Docker container 19.02 hosted on a server with two Intel Xeon Platinum 8168 CPUs and 16 NVIDIA Tesla</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: center;">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Maximum word length</td>
<td style="text-align: center;">512</td>
</tr>
<tr>
<td style="text-align: left;">Batch size</td>
<td style="text-align: center;">2048</td>
</tr>
<tr>
<td style="text-align: left;">Peak learning rate</td>
<td style="text-align: center;">$1 \mathrm{e}-5$</td>
</tr>
<tr>
<td style="text-align: left;">Peak learning rate (first 100K steps)</td>
<td style="text-align: center;">$5 \mathrm{e}-4$</td>
</tr>
<tr>
<td style="text-align: left;">Learning rate decay</td>
<td style="text-align: center;">linear</td>
</tr>
<tr>
<td style="text-align: left;">Warmup steps</td>
<td style="text-align: center;">2500</td>
</tr>
<tr>
<td style="text-align: left;">Mask probability for words</td>
<td style="text-align: center;">$15 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Mask probability for entities</td>
<td style="text-align: center;">$15 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Dropout</td>
<td style="text-align: center;">0.1</td>
</tr>
<tr>
<td style="text-align: left;">Weight decay</td>
<td style="text-align: center;">0.01</td>
</tr>
<tr>
<td style="text-align: left;">Gradient clipping</td>
<td style="text-align: center;">none</td>
</tr>
<tr>
<td style="text-align: left;">Adam $\beta_{1}$</td>
<td style="text-align: center;">0.9</td>
</tr>
<tr>
<td style="text-align: left;">Adam $\beta_{2}$</td>
<td style="text-align: center;">0.999</td>
</tr>
<tr>
<td style="text-align: left;">Adam $\epsilon$</td>
<td style="text-align: center;">$1 \mathrm{e}-6$</td>
</tr>
</tbody>
</table>
<p>Table 9: Hyper-parameters used to pretrain LUKE.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Maximum word length</td>
<td style="text-align: left;">512</td>
</tr>
<tr>
<td style="text-align: left;">Batch size</td>
<td style="text-align: left;">2048</td>
</tr>
<tr>
<td style="text-align: left;">Peak learning rate</td>
<td style="text-align: left;">$1 \mathrm{e}-5$</td>
</tr>
<tr>
<td style="text-align: left;">Learning rate decay</td>
<td style="text-align: left;">linear</td>
</tr>
<tr>
<td style="text-align: left;">Warmup steps</td>
<td style="text-align: left;">2500</td>
</tr>
<tr>
<td style="text-align: left;">Mask probability for words</td>
<td style="text-align: left;">$15 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Dropout</td>
<td style="text-align: left;">0.1</td>
</tr>
<tr>
<td style="text-align: left;">Weight decay</td>
<td style="text-align: left;">0.01</td>
</tr>
<tr>
<td style="text-align: left;">Gradient clipping</td>
<td style="text-align: left;">none</td>
</tr>
<tr>
<td style="text-align: left;">Adam $\beta_{1}$</td>
<td style="text-align: left;">0.9</td>
</tr>
<tr>
<td style="text-align: left;">Adam $\beta_{2}$</td>
<td style="text-align: left;">0.999</td>
</tr>
<tr>
<td style="text-align: left;">Adam $\epsilon$</td>
<td style="text-align: left;">$1 \mathrm{e}-6$</td>
</tr>
</tbody>
</table>
<p>Table 10: Hyper-parameters used for the extra pretraining of RoBERTa on our Wikipedia corpus.</p>
<p>V100 GPUs. The training takes approximately 30 days. The detailed hyper-parameters are shown in Table 9.</p>
<p>Table 10 shows the hyper-parameters used for the extra pretraining of RoBERTa on our Wikipedia corpus described in Section 5. As shown in the Table, we use the same hyper-parameters as the ones used to train LUKE. We train the model for 200K steps and update all parameters throughout the training.</p>
<h2>B Details of Experiments</h2>
<p>We conduct the experiments using NVIDIA's PyTorch Docker container 19.02 hosted on a server with two Intel Xeon E5-2698 v4 CPUs and eight V100 GPUs. For each dataset, excluding SQuAD, we conduct hyper-parameter tuning using grid search based on the performance on the development set. We evaluate performance using EM on the ReCoRD dataset, and F1 on the other datasets. Because our computational resources are limited, we use the following constrained search space:</p>
<ul>
<li>learning rate: $1 \mathrm{e}-5,2 \mathrm{e}-5,3 \mathrm{e}-5$</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: center;">Open Entity</th>
<th style="text-align: center;">TACRED</th>
<th style="text-align: center;">CoNLL-2003</th>
<th style="text-align: center;">ReCoRD</th>
<th style="text-align: center;">SQuAD</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Learning rate</td>
<td style="text-align: center;">$1 \mathrm{e}-5$</td>
<td style="text-align: center;">$1 \mathrm{e}-5$</td>
<td style="text-align: center;">$1 \mathrm{e}-5$</td>
<td style="text-align: center;">$1 \mathrm{e}-5$</td>
<td style="text-align: center;">$15 \mathrm{e}-6$</td>
</tr>
<tr>
<td style="text-align: left;">Batch size</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">32</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">32</td>
<td style="text-align: center;">48</td>
</tr>
<tr>
<td style="text-align: left;">Training epochs</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: left;">Training time</td>
<td style="text-align: center;">10 min</td>
<td style="text-align: center;">190 min</td>
<td style="text-align: center;">203 min</td>
<td style="text-align: center;">92 min</td>
<td style="text-align: center;">42 min</td>
</tr>
<tr>
<td style="text-align: left;">Number of GPUs</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">8</td>
</tr>
<tr>
<td style="text-align: left;">Dev score</td>
<td style="text-align: center;">78.5 F1</td>
<td style="text-align: center;">72.0 F1</td>
<td style="text-align: center;">97.1 F1</td>
<td style="text-align: center;">$90.8 \mathrm{EM} / 91.4 \mathrm{~F} 1$</td>
<td style="text-align: center;">$89.8 \mathrm{EM} / 95.0 \mathrm{~F} 1$</td>
</tr>
</tbody>
</table>
<p>Table 11: Hyper-parameters and other details of our experiments.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: center;">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Maximum word length</td>
<td style="text-align: center;">512</td>
</tr>
<tr>
<td style="text-align: left;">Learning rate decay</td>
<td style="text-align: center;">linear</td>
</tr>
<tr>
<td style="text-align: left;">Warmup ratio</td>
<td style="text-align: center;">0.06</td>
</tr>
<tr>
<td style="text-align: left;">Dropout</td>
<td style="text-align: center;">0.1</td>
</tr>
<tr>
<td style="text-align: left;">Weight decay</td>
<td style="text-align: center;">0.01</td>
</tr>
<tr>
<td style="text-align: left;">Gradient clipping</td>
<td style="text-align: center;">none</td>
</tr>
<tr>
<td style="text-align: left;">Adam $\beta_{1}$</td>
<td style="text-align: center;">0.9</td>
</tr>
<tr>
<td style="text-align: left;">Adam $\beta_{2}$</td>
<td style="text-align: center;">0.98</td>
</tr>
<tr>
<td style="text-align: left;">Adam $\epsilon$</td>
<td style="text-align: center;">$1 \mathrm{e}-6$</td>
</tr>
</tbody>
</table>
<p>Table 12: Common hyper-parameters used in our experiments.</p>
<ul>
<li>batch size: $4,8,16,32,64$</li>
<li>number of training epochs: $2,3,5$</li>
</ul>
<p>We do not tune the hyper-parameters of the SQuAD dataset, and use the ones described in Liu et al. (2020). The hyper-parameters and other details, including the training time, number of GPUs used, and the best score on the development set, are shown in Table 11. For the other hyper-parameters, we simply follow Liu et al. (2020) (see Table 12). We optimize the model using AdamW with learning rate warmup and linear decay of the learning rate. We also use early stopping based on performance on the development set. The details of the datasets used in our experiments are provided below.</p>
<h2>B. 1 Open Entity</h2>
<p>The Open Entity dataset used in Zhang et al. (2019) consists of training, development, and test sets, where each set contains 1,998 examples with labels of nine general entity types. The dataset is downloaded from the website for Zhang et al. (2019). ${ }^{2}$ We compute the reported results using our code based on that of Zhang et al. (2019).</p>
<h2>B. 2 TACRED</h2>
<p>The TACRED dataset contains 68,124 training examples, 22,631 development examples, and 15,509 test examples with labels of their relation types. The total number of relation types is 42 . The</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup>dataset is obtained from the LDC website. ${ }^{3}$ We compute the reported results using our code based on that of Zhang et al. (2019).</p>
<h2>B. 3 CoNLL-2003</h2>
<p>The CoNLL-2003 dataset comprises training, development, and test sets, containing 14,987, 3,466, and 3,684 sentences, respectively. Each sentence contains annotations of four entity types, namely person, location, organization, and miscellaneous. The dataset is downloaded from the relevant website. ${ }^{4}$ The reported results are computed using the conlleval script obtained from the website.</p>
<h2>B. 4 ReCoRD</h2>
<p>The ReCoRD dataset consists of 100,730 training, 10,000 development, and 10,000 test questions created based on 80,121 unique news articles. The dataset is obtained from the relevant website. ${ }^{5}$ We compute the performance on the development set using the official evaluation script downloaded from the website. Performance on the test set is obtained by submitting our model to the leaderboard.</p>
<h2>B. 5 SQuAD 1.1</h2>
<p>The SQuAD 1.1 dataset contains 87,599 training, 10,570 development, and 9,533 test questions created based on 536 Wikipedia articles. The dataset is downloaded from the relevant website. ${ }^{6}$ We compute performance on the development set using the official evaluation script downloaded from the website. Performance on the test set is obtained by submitting our model to the leaderboard.</p>
<p><sup id="fnref:1"><a class="footnote-ref" href="#fn:1">2</a></sup></p>
<h1>C Adding Entity Annotations to SQuAD dataset</h1>
<p>For each question-passage pair in the SQuAD dataset, we first create a mapping from the entity names (e.g., "U.S.") to their referent Wikipedia entities (e.g., United States) using the entity hyperlinks on the source Wikipedia page of the passage. We then perform simple string matching to extract all entity names in the question and the passage, and treat all matched entity names as entity annotations for their referent entities. We ignore an entity name if the name refers to multiple entities on the page. Further, to reduce noise, we also exclude an entity name if its link probability, the probability that the name appears as a hyperlink in Wikipedia, is lower than $1 \%$. We use the March 2016 version of Wikipedia to collect the entity hyperlinks and the link probabilities of the entity names.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{2}$ https://github.com/thun1p/ERNIE&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:1">
<p>${ }^{3}$ https://catalog.ldc.upenn.edu/
LDC2018T24
${ }^{4}$ https://www.clips.uantwerpen.be/
conll2003/ner
${ }^{5}$ https://sheng-z.github.io/
ReCoRD-explorer
${ }^{6}$ https://rajpurkar.github.io/
SQuAD-explorer&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>