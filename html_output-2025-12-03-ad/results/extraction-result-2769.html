<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-2769 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-2769</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-2769</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-70.html">extraction-schema-70</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve text games, including details about the memory architecture, performance comparisons, and what makes memory effective or ineffective.</div>
                <p><strong>Paper ID:</strong> paper-398a0625e8707a0b41ac58eaec51e8feb87dd7cb</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/398a0625e8707a0b41ac58eaec51e8feb87dd7cb" target="_blank">ALFWorld: Aligning Text and Embodied Environments for Interactive Learning</a></p>
                <p><strong>Paper Venue:</strong> International Conference on Learning Representations</p>
                <p><strong>Paper TL;DR:</strong> ALFWorld, a simulator that enables agents to learn abstract, text-based policies in TextWorld and then execute goals from the ALFRED benchmark in a rich visual environment, enables the creation of a new BUTLER agent whose abstract knowledge corresponds directly to concrete, visually grounded actions.</p>
                <p><strong>Paper Abstract:</strong> Given a simple request (e.g., Put a washed apple in the kitchen fridge), humans can reason in purely abstract terms by imagining action sequences and scoring their likelihood of success, prototypicality, and efficiency, all without moving a muscle. Once we see the kitchen in question, we can update our abstract plans to fit the scene. Embodied agents require the same abilities, but existing work does not yet provide the infrastructure necessary for both reasoning abstractly and executing concretely. We address this limitation by introducing ALFWorld, a simulator that enables agents to learn abstract, text-based policies in TextWorld (Cote et al., 2018) and then execute goals from the ALFRED benchmark (Shridhar et al., 2020) in a rich visual environment. ALFWorld enables the creation of a new BUTLER agent whose abstract knowledge, learned in TextWorld, corresponds directly to concrete, visually grounded actions. In turn, as we demonstrate empirically, this fosters better agent generalization than training only in the visually grounded environment. BUTLER's simple, modular design factors the problem to allow researchers to focus on models for improving every piece of the pipeline (language understanding, planning, navigation, visual scene understanding, and so forth).</p>
                <p><strong>Cost:</strong> 0.014</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e2769.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e2769.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve text games, including details about the memory architecture, performance comparisons, and what makes memory effective or ineffective.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>BUTLER::BRAIN</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>BUTLER::BRAIN (Text Agent)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Text-based Seq2Seq agent that generates high-level action sentences token-by-token for TextWorld games; uses a Transformer encoder-decoder with pointer-softmax, augmented by two explicit memory mechanisms (a recurrent aggregator (GRU) and an observation queue) to handle partial observability and history.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>BUTLER::BRAIN</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>A Transformer Seq2Seq encoder-decoder (encoder/decoder blocks based on Transformers) with frozen 768-d BERT input embeddings, pointer-softmax output, a recurrent aggregator (GRU) for history, and an observation queue that caches recent unique textual observations; trained with imitation learning (DAgger) from a rule-based expert and uses beam search at evaluation to recover from failed actions.</td>
                        </tr>
                        <tr>
                            <td><strong>base_model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>game_benchmark_name</strong></td>
                            <td>ALFWorld / TextWorld (aligned to ALFRED)</td>
                        </tr>
                        <tr>
                            <td><strong>game_description</strong></td>
                            <td>ALFWorld: an aligned framework pairing TextWorld text games (procedurally-generated, PDDL-defined text games) with the embodied ALFRED tasks (household manipulation/navigation); six task types (Pick & Place, Examine in Light, Clean & Place, Heat & Place, Cool & Place, Pick Two & Place); interactive text observations and high-level actions.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_memory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>Working / short-term memory (recurrent hidden state) + short episodic observation buffer (observation queue)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_structure</strong></td>
                            <td>Two-part structure: (1) a fixed-size sequential observation queue (a short-term buffer of recent unique textual observations, with o0 always included) and (2) a recurrent hidden state (GRU) summarizing aggregated encoder representations; retrieval is via concatenation of these sources and attention (tri-linear similarity) in the encoder/aggregator and pointer-softmax in the decoder.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_content</strong></td>
                            <td>Recent textual observations (cached sentences from 'goto', 'open', etc.), the initial scene description o0 (list of receptacles), the current observation o_t, encoded goal description g, and the recurrent summary vector (GRU hidden state) representing history.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_capacity</strong></td>
                            <td>Observation queue length k (default k=5) plus the always-present initial observation o0; GRU hidden vector size H=64 (internal state).</td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_strategy</strong></td>
                            <td>Recency-based retrieval from the observation queue combined with relevance-based attention (tri-linear similarity between observation tokens and goal tokens) over the concatenated source representation; pointer-softmax allows extractive pointing to tokens from memory/source; overall retrieval is a mix of recency and attention-driven relevance.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_update_strategy</strong></td>
                            <td>Updated every game step: the observation queue is appended/maintained with most recent unique textual observations (o_t) (o0 always kept); the GRU hidden state is updated each step using a mean-pooled aggregated representation from the encoder/aggregator.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_usage_purpose</strong></td>
                            <td>Provide history in a partially-observable text game for planning and decision-making, enable the decoder to point to correct receptacle/object tokens (via pointer-softmax aided by o0 and cached observations), recover from mistakes (avoiding repeating failed actions), and learn task-guided heuristics (e.g., search patterns) that generalize to embodied settings.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>TextWorld (All Tasks) evaluation with full BUTLER::BRAIN (DAgger + observation queue k=5 + GRU + beam search): seen success 40% and unseen success 37% (Table 4). Zero-shot transfer to embodied ALFRED via ALFWorld: BUTLER (with detector and A* navigator) achieves 19% success (seen) and 10% success (unseen) on All Tasks; goal-condition success rates for transfer are 31% (seen) and 20% (unseen) (Table 2).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td>Seq2Seq (Behavior Cloning; no recurrent aggregator/observation-queue/DAgger online interaction) on All Tasks: seen 10% and unseen 9% in TextWorld (Table 4). An ablation removing beam-search decoding (BUTLER_g: greedy decoding) reduces seen All Tasks performance from 40% to 19% (a 21 percentage-point drop) and yields lower unseen scores (Table 4).</td>
                        </tr>
                        <tr>
                            <td><strong>has_memory_ablation</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_effectiveness_findings</strong></td>
                            <td>Ablations show memory components materially affect performance: (1) the observation queue (plus keeping the initial observation o0) improves generalization to unseen tasks by making receptacle/object words available to the pointer mechanism; (2) the recurrent aggregator (GRU) helps history-based decisions, especially in seen environments where tracking object locations helps; (3) beam search (used together with memory) is critical to recover from failed actions and avoid getting stuck repeating bad actions (ablation of beam search causes a 21% drop on the seen All Tasks split); (4) interactive online training (DAgger) that uses environment interaction plus memory is essential—removing it (Seq2Seq) causes a ~30% drop on seen All Tasks. Overall, memory is most effective for partial-observability, recovery from errors, and enabling learned heuristics that transfer.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_limitations</strong></td>
                            <td>Memory does not eliminate transfer domain gaps between TextWorld and embodied ALFRED (physical constraints, object size/fit, detector misdetections, navigation collisions); greedy decoding with memory can still lead to repetition and getting stuck (necessitating beam search); observation queue is short-term (k=5) so long-horizon dependencies beyond that window are not explicitly preserved; paper does not implement or evaluate larger/long-term external memory structures, so limitations on scaling to very long-horizon tasks are untested.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other_memory_types</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>best_memory_configuration</strong></td>
                            <td>The best configuration in this paper is the combined system: DAgger training + observation queue (k=5) that always includes initial observation o0 + recurrent GRU aggregator (H=64) + beam-search decoding at evaluation. This configuration produced the reported strong TextWorld generalization (All Tasks seen 40%, unseen 37%) and the best zero-shot embodied transfer scores reported for BUTLER (All Tasks transfer seen 19%, unseen 10%).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'ALFWorld: Aligning Text and Embodied Environments for Interactive Learning', 'publication_date_yy_mm': '2020-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Counting to explore and generalize in text-based games <em>(Rating: 2)</em></li>
                <li>Learning dynamic belief graphs to generalize on text-based games <em>(Rating: 2)</em></li>
                <li>Language is power: Representing states using natural language in reinforcement learning <em>(Rating: 2)</em></li>
                <li>Graph constrained reinforcement learning for natural language action spaces <em>(Rating: 1)</em></li>
                <li>Grounding language for transfer in deep reinforcement learning <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-2769",
    "paper_id": "paper-398a0625e8707a0b41ac58eaec51e8feb87dd7cb",
    "extraction_schema_id": "extraction-schema-70",
    "extracted_data": [
        {
            "name_short": "BUTLER::BRAIN",
            "name_full": "BUTLER::BRAIN (Text Agent)",
            "brief_description": "Text-based Seq2Seq agent that generates high-level action sentences token-by-token for TextWorld games; uses a Transformer encoder-decoder with pointer-softmax, augmented by two explicit memory mechanisms (a recurrent aggregator (GRU) and an observation queue) to handle partial observability and history.",
            "citation_title": "here",
            "mention_or_use": "use",
            "agent_name": "BUTLER::BRAIN",
            "agent_description": "A Transformer Seq2Seq encoder-decoder (encoder/decoder blocks based on Transformers) with frozen 768-d BERT input embeddings, pointer-softmax output, a recurrent aggregator (GRU) for history, and an observation queue that caches recent unique textual observations; trained with imitation learning (DAgger) from a rule-based expert and uses beam search at evaluation to recover from failed actions.",
            "base_model_size": null,
            "game_benchmark_name": "ALFWorld / TextWorld (aligned to ALFRED)",
            "game_description": "ALFWorld: an aligned framework pairing TextWorld text games (procedurally-generated, PDDL-defined text games) with the embodied ALFRED tasks (household manipulation/navigation); six task types (Pick & Place, Examine in Light, Clean & Place, Heat & Place, Cool & Place, Pick Two & Place); interactive text observations and high-level actions.",
            "uses_memory": true,
            "memory_type": "Working / short-term memory (recurrent hidden state) + short episodic observation buffer (observation queue)",
            "memory_structure": "Two-part structure: (1) a fixed-size sequential observation queue (a short-term buffer of recent unique textual observations, with o0 always included) and (2) a recurrent hidden state (GRU) summarizing aggregated encoder representations; retrieval is via concatenation of these sources and attention (tri-linear similarity) in the encoder/aggregator and pointer-softmax in the decoder.",
            "memory_content": "Recent textual observations (cached sentences from 'goto', 'open', etc.), the initial scene description o0 (list of receptacles), the current observation o_t, encoded goal description g, and the recurrent summary vector (GRU hidden state) representing history.",
            "memory_capacity": "Observation queue length k (default k=5) plus the always-present initial observation o0; GRU hidden vector size H=64 (internal state).",
            "memory_retrieval_strategy": "Recency-based retrieval from the observation queue combined with relevance-based attention (tri-linear similarity between observation tokens and goal tokens) over the concatenated source representation; pointer-softmax allows extractive pointing to tokens from memory/source; overall retrieval is a mix of recency and attention-driven relevance.",
            "memory_update_strategy": "Updated every game step: the observation queue is appended/maintained with most recent unique textual observations (o_t) (o0 always kept); the GRU hidden state is updated each step using a mean-pooled aggregated representation from the encoder/aggregator.",
            "memory_usage_purpose": "Provide history in a partially-observable text game for planning and decision-making, enable the decoder to point to correct receptacle/object tokens (via pointer-softmax aided by o0 and cached observations), recover from mistakes (avoiding repeating failed actions), and learn task-guided heuristics (e.g., search patterns) that generalize to embodied settings.",
            "performance_with_memory": "TextWorld (All Tasks) evaluation with full BUTLER::BRAIN (DAgger + observation queue k=5 + GRU + beam search): seen success 40% and unseen success 37% (Table 4). Zero-shot transfer to embodied ALFRED via ALFWorld: BUTLER (with detector and A* navigator) achieves 19% success (seen) and 10% success (unseen) on All Tasks; goal-condition success rates for transfer are 31% (seen) and 20% (unseen) (Table 2).",
            "performance_without_memory": "Seq2Seq (Behavior Cloning; no recurrent aggregator/observation-queue/DAgger online interaction) on All Tasks: seen 10% and unseen 9% in TextWorld (Table 4). An ablation removing beam-search decoding (BUTLER_g: greedy decoding) reduces seen All Tasks performance from 40% to 19% (a 21 percentage-point drop) and yields lower unseen scores (Table 4).",
            "has_memory_ablation": true,
            "memory_effectiveness_findings": "Ablations show memory components materially affect performance: (1) the observation queue (plus keeping the initial observation o0) improves generalization to unseen tasks by making receptacle/object words available to the pointer mechanism; (2) the recurrent aggregator (GRU) helps history-based decisions, especially in seen environments where tracking object locations helps; (3) beam search (used together with memory) is critical to recover from failed actions and avoid getting stuck repeating bad actions (ablation of beam search causes a 21% drop on the seen All Tasks split); (4) interactive online training (DAgger) that uses environment interaction plus memory is essential—removing it (Seq2Seq) causes a ~30% drop on seen All Tasks. Overall, memory is most effective for partial-observability, recovery from errors, and enabling learned heuristics that transfer.",
            "memory_limitations": "Memory does not eliminate transfer domain gaps between TextWorld and embodied ALFRED (physical constraints, object size/fit, detector misdetections, navigation collisions); greedy decoding with memory can still lead to repetition and getting stuck (necessitating beam search); observation queue is short-term (k=5) so long-horizon dependencies beyond that window are not explicitly preserved; paper does not implement or evaluate larger/long-term external memory structures, so limitations on scaling to very long-horizon tasks are untested.",
            "comparison_with_other_memory_types": true,
            "best_memory_configuration": "The best configuration in this paper is the combined system: DAgger training + observation queue (k=5) that always includes initial observation o0 + recurrent GRU aggregator (H=64) + beam-search decoding at evaluation. This configuration produced the reported strong TextWorld generalization (All Tasks seen 40%, unseen 37%) and the best zero-shot embodied transfer scores reported for BUTLER (All Tasks transfer seen 19%, unseen 10%).",
            "uuid": "e2769.0",
            "source_info": {
                "paper_title": "ALFWorld: Aligning Text and Embodied Environments for Interactive Learning",
                "publication_date_yy_mm": "2020-10"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Counting to explore and generalize in text-based games",
            "rating": 2
        },
        {
            "paper_title": "Learning dynamic belief graphs to generalize on text-based games",
            "rating": 2
        },
        {
            "paper_title": "Language is power: Representing states using natural language in reinforcement learning",
            "rating": 2
        },
        {
            "paper_title": "Graph constrained reinforcement learning for natural language action spaces",
            "rating": 1
        },
        {
            "paper_title": "Grounding language for transfer in deep reinforcement learning",
            "rating": 1
        }
    ],
    "cost": 0.0140115,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>ALFWORLD: ALIGNING TEXT AND EMBODIED ENVIRONMENTS FOR INTERACTIVE LEARNING</h1>
<p>Mohit Shridhar ${ }^{\dagger}$ Xingdi Yuan<em> Marc-Alexandre Côté</em><br>Yonatan Bisk<em> Adam Trischler</em> Matthew Hausknecht<em><br>${ }^{\dagger}$ University of Washington ${ }^{</em>}$ Microsoft Research, Montréal<br>${ }^{\ddagger}$ Carnegie Mellon University ${ }^{*}$ Microsoft Research<br>ALFWorld.github.io</p>
<h4>Abstract</h4>
<p>Given a simple request like Put a washed apple in the kitchen fridge, humans can reason in purely abstract terms by imagining action sequences and scoring their likelihood of success, prototypicality, and efficiency, all without moving a muscle. Once we see the kitchen in question, we can update our abstract plans to fit the scene. Embodied agents require the same abilities, but existing work does not yet provide the infrastructure necessary for both reasoning abstractly and executing concretely. We address this limitation by introducing ALFWorld, a simulator that enables agents to learn abstract, text-based policies in TextWorld (Côté et al., 2018) and then execute goals from the ALFRED benchmark (Shridhar et al., 2020) in a rich visual environment. ALFWorld enables the creation of a new BUTLER agent whose abstract knowledge, learned in TextWorld, corresponds directly to concrete, visually grounded actions. In turn, as we demonstrate empirically, this fosters better agent generalization than training only in the visually grounded environment. BUTLER's simple, modular design factors the problem to allow researchers to focus on models for improving every piece of the pipeline (language understanding, planning, navigation, and visual scene understanding).</p>
<h2>1 INTRODUCTION</h2>
<p>Consider helping a friend prepare dinner in an unfamiliar house: when your friend asks you to clean and slice an apple for an appetizer, how would you approach the task? Intuitively, one could reason abstractly: (1) find an apple (2) wash the apple in the sink (3) put the clean apple on the cutting board (4) find a knife (5) use the knife to slice the apple (6) put the slices in a bowl. Even in an unfamiliar setting, abstract reasoning can help accomplish the goal by leveraging semantic priors. Priors like locations of objects - apples are commonly found in the kitchen along with implements for cleaning and slicing, object affordances - a sink is useful for washing an apple unlike a refrigerator, pre-conditions - better to wash an apple before slicing it, rather than the converse. We hypothesize that, learning to solve tasks using abstract language, unconstrained by the particulars of the physical world, enables agents to complete embodied tasks in novel environments by leveraging the kinds of semantic priors that are exposed by abstraction and interaction.
<img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: ALFWorld: Interactive aligned text and embodied worlds. An example with high-level text actions (left) and low-level physical actions (right).</p>
<p>To test this hypothesis, we have created the novel ALFWorld framework, the first interactive, parallel environment that aligns text descriptions and commands with physically embodied robotic simulation. We build ALFWorld by extending two prior works: TextWorld (Côté et al., 2018) - an engine for interactive text-based games, and ALFRED (Shridhar et al., 2020) - a large scale dataset for visionlanguage instruction following in embodied environments. ALFWorld provides two views of the same underlying world and two modes by which to interact with it: TextWorld, an abstract, text-based environment, generates textual observations of the world and responds to high-level text actions; ALFRED, the embodied simulator, renders the world in high-dimensional images and responds to low-level physical actions as from a robot (Figure 1). ${ }^{1}$ Unlike prior work on instruction following (MacMahon et al., 2006; Anderson et al., 2018a), which typically uses a static corpus of cross-modal expert demonstrations, we argue that aligned parallel environments like ALFWorld offer a distinct advantage: they allow agents to explore, interact, and learn in the abstract environment of language before encountering the complexities of the embodied environment.</p>
<p>While fields such as robotic control use simulators like MuJoCo (Todorov et al., 2012) to provide infinite data through interaction, there has been no analogous mechanism - short of hiring a human around the clock - for providing linguistic feedback and annotations to an embodied agent. TextWorld addresses this discrepancy by providing programmatic and aligned linguistic signals during agent exploration. This facilitates the first work, to our knowledge, in which an embodied agent learns the meaning of complex multi-step policies, expressed in language, directly through interaction.</p>
<p>Empowered by the ALFWorld framework, we introduce BUTLER (Building Understanding in Textworld via Language for Embodied Reasoning), an agent that first learns to perform abstract tasks in TextWorld using Imitation Learning (IL) and then transfers the learned policies to embodied tasks in ALFRED. When operating in the embodied world, BUTLER leverages the abstract understanding gained from TextWorld to generate text-based actions; these serve as high-level subgoals that facilitate physical action generation by a low-level controller. Broadly, we find that BUTLER is capable of generalizing in a zero-shot manner from TextWorld to unseen embodied tasks and settings. Our results show that training first in the abstract text-based environment is not only $7 \times$ faster, but also yields better performance than training from scratch in the embodied world. These results lend credibility to the hypothesis that solving abstract language-based tasks can help build priors that enable agents to generalize to unfamiliar embodied environments.</p>
<p>Our contributions are as follows:
§ 2 ALFWorld environment: The first parallel interactive text-based and embodied environment.
§ 3 BUTLER architecture: An agent that learns high-level policies in language that transfer to low-level embodied executions, and whose modular components can be independently upgraded.
§ 4 Generalization: We demonstrate empirically that BUTLER, trained in the abstract text domain, generalizes better to unseen embodied settings than agents trained from corpora of demonstrations or from scratch in the embodied world.</p>
<h1>2 ALigning ALFRED and TextWorld</h1>
<p>The ALFRED dataset (Shridhar et al., 2020), set in the THOR simulator (Kolve et al., 2017), is a benchmark for learning to complete embodied household tasks using natural language instructions and egocentric visual observations. As shown in Figure 1 (right), ALFRED tasks pose challenging interaction and navigation problems to an agent in a high-fidelity simulated environment. Tasks are annotated with a goal description that describes the objective (e.g., "put a pan on the dining table"). We consider both template-based and human-annotated goals; further details on goal specification can be found in Appendix H. Agents observe</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Task type</th>
<th style="text-align: center;"># train</th>
<th style="text-align: center;"># seen</th>
<th style="text-align: center;"># unseen</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Pick \&amp; Place</td>
<td style="text-align: center;">790</td>
<td style="text-align: center;">35</td>
<td style="text-align: center;">24</td>
</tr>
<tr>
<td style="text-align: center;">Examine in Light</td>
<td style="text-align: center;">308</td>
<td style="text-align: center;">13</td>
<td style="text-align: center;">18</td>
</tr>
<tr>
<td style="text-align: center;">Clean \&amp; Place</td>
<td style="text-align: center;">650</td>
<td style="text-align: center;">27</td>
<td style="text-align: center;">31</td>
</tr>
<tr>
<td style="text-align: center;">Heat \&amp; Place</td>
<td style="text-align: center;">459</td>
<td style="text-align: center;">16</td>
<td style="text-align: center;">23</td>
</tr>
<tr>
<td style="text-align: center;">Cool \&amp; Place</td>
<td style="text-align: center;">533</td>
<td style="text-align: center;">25</td>
<td style="text-align: center;">21</td>
</tr>
<tr>
<td style="text-align: center;">Pick Two \&amp; Place</td>
<td style="text-align: center;">813</td>
<td style="text-align: center;">24</td>
<td style="text-align: center;">17</td>
</tr>
<tr>
<td style="text-align: center;">All</td>
<td style="text-align: center;">3,553</td>
<td style="text-align: center;">140</td>
<td style="text-align: center;">134</td>
</tr>
</tbody>
</table>
<p>Table 1: Six ALFRED task types with heldout seen and unseen evaluation sets.
the world through high-dimensional pixel images and interact using low-level action primitives: MoveAhead, RotateLeft/Right, LookUp/Down, Pickup, Put, Open, Close, and ToggleOn/Off.</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>The ALFRED dataset also includes crowdsourced language instructions like "turn around and walk over to the microwave" that explain how to complete a goal in a step-by-step manner. We depart from the ALFRED challenge by omitting these step-by-step instructions and focusing on the more diffcult problem of using only on goal descriptions specifying what needs to be achieved.
Our aligned ALFWorld framework adopts six ALFRED task-types (Table 1) of various difficulty levels. ${ }^{2}$ Tasks involve first finding a particular object, which often requires the agent to open and search receptacles like drawers or cabinets. Subsequently, all tasks other than Pick \&amp; Place require some interaction with the object such as heating (place object in microwave and start it) or cleaning (wash object in a sink). To complete the task, the object must be placed in the designated location.</p>
<p>Within each task category there is significant variation: the embodied environment includes 120 rooms ( 30 kitchens, 30 bedrooms, 30 bathrooms, 30 living rooms), each dynamically populated with a set of portable objects (e.g., apple, mug), and static receptacles (e.g., microwave, fridge). For each task type we construct a larger train set, as well as seen and unseen validation evaluation sets: (1): seen consists of known task instances {task-type, object, receptacle, room} in rooms seen during training, but with different instantiations of object locations, quantities, and visual appearances (e.g. two blue pencils on a shelf instead of three red pencils in a drawer seen in training). (2): unseen consists of new task instances with possibly known object-receptacle pairs, but always in unseen rooms with different receptacles and scene layouts than in training tasks.</p>
<p>The seen set is designed to measure in-distribution generalization, whereas the unseen set measures out-of-distribution generalization. The scenes in ALFRED are visually diverse, so even the same task instance can lead to very distinct tasks, e.g., involving differently colored apples, shaped statues, or textured cabinets. For this reason, purely vision-based agents such as the unimodal baselines in Section 5.2 often struggle to generalize to unseen environments and objects.</p>
<p>The TextWorld framework (Côté et al., 2018) procedurally generates text-based environments for training and evaluating language-based agents. In order to extend TextWorld to create text-based analogs of each ALFRED scene, we adopt a common latent structure representing the state of the simulated world. ALFWorld uses PDDL - Planning Domain Definition Language (McDermott et al., 1998) to describe each scene from ALFRED and to construct an equivalent text game using the TextWorld engine. The dynamics of each game are defined by the PDDL domain (see Appendix C for additional details). Textual observations shown in Figure 1 are generated with templates sampled from a context-sensitive grammar designed for the ALFRED environments. For interaction, TextWorld environments use the following high-level actions:</p>
<table>
<thead>
<tr>
<th style="text-align: left;">goto {recep}</th>
<th style="text-align: left;">take {obj} from {recep}</th>
<th style="text-align: left;">put {obj} in/on {recep}</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">open {recep}</td>
<td style="text-align: left;">close {recep}</td>
<td style="text-align: left;">toggle {obj} {recep}</td>
</tr>
<tr>
<td style="text-align: left;">clean {obj} with {recep}</td>
<td style="text-align: left;">heat {obj} with {recep}</td>
<td style="text-align: left;">cool {obj} with {recep}</td>
</tr>
</tbody>
</table>
<p>where ${$ obj $}$ and ${$ recep $}$ correspond to objects and receptacles. Note that heat, cool, clean, and goto are high-level actions that correspond to several low-level embodied actions.</p>
<p>ALFWorld, in summary, is an cross-modal framework featuring a diversity of embodied tasks with analogous text-based counterparts. Since both components are fully interactive, agents may be trained in either the language or embodied world and evaluated on heldout test tasks in either modality. We believe the equivalence between objects and interactions across modalities make ALFWorld an ideal framework for studying language grounding and cross-modal learning.</p>
<h1>3 Introducing BUTLER: An Embodied Multi-task Agent</h1>
<p>We investigate learning in the abstract language modality before generalizing to the embodied setting. The BUTLER agent uses three components to span the language and embodied modalities: BUTLER::BraIN - the abstract text agent, BUTLER::VISION - the language state estimator, and BUTLER::BODY - the low-level controller. An overview of BUTLER is shown in Figure 2 and each component is described below.</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: BUTLER Agent consists of three modular components. 1) BUTLER::BRAIN: a text agent pre-trained with the TextWorld engine (indicated by the dashed yellow box) which simulates an abstract textual equivalent of the embodied world. When subsequently applied to embodied tasks, it generates high-level actions that guide the controller. 2) BUTLER::VISION: a state estimator that translates, at each time step, the visual frame $v_{t}$ from the embodied world into a textual observation $o_{t}$ using a pre-trained Mask R-CNN detector. The generated observation $o_{t}$, the initial observation $o_{0}$, and the task goal $g$ are used by the text agent the to predict the next high-level action $a_{t}$. 3) BUTLER::BODY: a controller that translates the high-level text action $a_{t}$ into a sequence of one or more low-level embodied actions.</p>
<h1>3.1 BUTLER::BRAIN (TEXT AGENT) : $o_{0}, o_{t}, g \rightarrow a_{t}$</h1>
<p>BUTLER::BRAIN is a novel text-based game agent that generates high-level text actions in a token-by-token fashion akin to Natural Language Generation (NLG) approaches for dialogue (Sharma et al., 2017) and summarization (Gehrmann et al., 2018). An overview of the agent's architecture is shown in Figure 3. At game step $t$, the encoder takes the initial text observation $o_{0}$, current observation $o_{t}$, and the goal description $g$ as input and generates a contextaware representation of the current observable game state. The observation $o_{0}$ explicitly lists all the navigable receptacles in the scene, and goal $g$ is sampled from a set of language templates (see Appendix H). Since the games are partially observable, the agent only has access to the observation describing the effects of its previous action and its present location. Therefore, we incorporate two memory mechanisms to imbue the agent with history: (1) a recurrent aggregator, adapted from Yuan et al. (2018), combines the encoded state with recurrent state $h_{t-1}$ from the previous game step; (2) an observation queue feeds in the $k$ most recent, unique textual observations. The decoder generates an action sentence $a_{t}$ token-by-token to interact with the game. The encoder and decoder are based on a Transformer Seq2Seq model with pointer softmax mechanism (Gulcehre et al., 2016). We leverage pre-trained BERT embeddings (Sanh et al., 2019), and tie output embeddings with input embeddings (Press and Wolf, 2016). The agent is trained in an imitation learning setting with DAgger (Ross et al., 2011) using expert demonstrations. See Appendix A for complete details.</p>
<p>When solving a task, an agent might get stuck at certain states due to various failures (e.g., action is grammatically incorrect, wrong object name). The observation for a failed action does not contain any useful feedback, so a fully deterministic actor tends to repeatedly produce the same incorrect action. To address this problem, during evaluation in both TextWorld and ALFRED, BUTLER::BRAIN uses Beam Search (Reddy et al., 1977) to generate alternative action sentences in the event of a failed action. But otherwise greedily picks a sequence of best words for efficiency. Note that Beam Search is not used to optimize over embodied interactions like prior work (Wang et al., 2019). but rather to simply improve the generated action sentence during failures.</p>
<h3>3.2 BUTLER::VISION (STATE ESTIMATOR) : $v_{t} \rightarrow o_{t}$</h3>
<p>At test time, agents in the embodied world must operate purely from visual input. To this end, BUTLER::VISION's language state estimator functions as a captioning module that translates visual observations $v_{t}$ into textual descriptions $o_{t}$. Specifically, we use a pre-trained Mask R-CNN detec-</p>
<p>tor (He et al., 2017) to identify objects in the visual frame. The detector is trained separately in a supervised setting with random frames from ALFRED training scenes (see Appendix D). For each frame $v_{t}$, the detector generates $N$ detections $\left{\left(c_{1}, m_{1}\right),\left(c_{2}, m_{2}\right), \ldots,\left(c_{N}, m_{N}\right)\right}$, where $c_{n}$ is the predicted object class, and $m_{n}$ is a pixel-wise object mask. These detections are formatted into a sentence using a template e.g., On table 1, you see a mug 1, a tomato 1, and a tomato 2. To handle multiple instances of objects, each object is associated with a class $c_{n}$ and a number ID e.g., tomato 1. Commands goto, open, and examine generate a list of detections, whereas all other commands generate affirmative responses if the action succeeds e.g., $a_{t}$ : put mug 1 on desk $2 \rightarrow o_{t+1}$ : You put mug 1 on desk 2, otherwise produce Nothing happens to indicate failures or no state-change. See Appendix G for a full list of templates. While this work presents preliminary results with template-based descriptions, future work could generate more descriptive observations using pre-trained image-captioning models (Johnson et al., 2016), video-action captioning frameworks (Sun et al., 2019), or scene-graph parsers (Tang et al., 2020).</p>
<h1>3.3 BUTLER::BODY (CONTROLLER) : $v_{t}, a_{t} \rightarrow\left{\hat{a}<em 2="2">{1}, \hat{a}</em>\right}$}, \ldots, \hat{a}_{L</h1>
<p>The controller translates a high-level text action $a_{t}$ into a sequence of $L$ low-level physical actions $\left{\hat{a}<em 2="2">{1}, \hat{a}</em>}, \ldots, \hat{a<em n="n">{L}\right}$ that are executable in the embodied environment. The controller handles two types of commands: manipulation and navigation. For manipulation actions, we use the ALFRED API to interact with the simulator by providing an API action and a pixel-wise mask based on Mask R-CNN detections $m</em>$ that was produced during state-estimation. For navigation commands, each episode is initialized with a pre-built grid-map of the scene, where each receptacle instance is associated with a receptacle class and an interaction viewpoint $(x, y, \theta, \phi}$ with $x$ and $y$ representing the 2 D position, $\theta$ and $\phi$ representing the agent's yaw rotation and camera tilt. The goto command invokes an A* planner to find the shortest path between two viewpoints. The planner outputs a sequence of $L$ displacements in terms of motion primitives: MoveAhead, RotateRight, RotateLeft, LookUp, and LookDown, which are executed in an open-loop fashion via the ALFRED API. We note that a given pre-built grid-map of receptacle locations is a strong prior assumption, but future work could incorporate existing models from the vision-language navigation literature (Anderson et al., 2018a; Wang et al., 2019) for map-free navigation.</p>
<h2>4 EXPERIMENTS</h2>
<p>We design experiments to answer the following questions: (1) How important is an interactive language environment versus a static corpus? (2) Do policies learnt in TextWorld transfer to embodied environments? (3) Can policies generalize to human-annotated goals? (4) Does pre-training in an abstract textual environment enable better generalization in the embodied world?</p>
<h3>4.1 IMPORTANCE OF INTERACTIVE LANGUAGE</h3>
<p>The first question addresses our core hypothesis that training agents in interactive TextWorld environments leads to better generalization than training agents with a static linguistic corpus. To test this hypothesis, we use DAgger (Ross et al., 2011) to train the BUTLER::BRAIN agent in TextWorld and compare it against Seq2Seq, an identical agent trained with Behavior Cloning from an equivalentlysized corpus of expert demonstrations. The demonstrations come from the same expert policies and we control the number of episodes to ensure a fair comparison. Table 2 presents results for agents trained in TextWorld and subsequently evaluated in embodied environments in a zero-shot manner. The agents are trained independently on individual tasks and also jointly on all six task types. For each task category, we select the agent with best evaluation performance in TextWorld (from 8 random seeds); this is done separately for each split: seen and unseen. These best-performing agents are then evaluated on the heldout seen and unseen embodied ALFRED tasks. For embodied evaluations, we also report goal-condition success rates, a metric proposed in ALFRED (Shridhar et al., 2020) to measure partial goal completion.</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<table>
<thead>
<tr>
<th style="text-align: center;">task-type</th>
<th style="text-align: center;">TextWorld</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Seq2Seq</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">BUTLER</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">BUTLER-ORACLE</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Human Goals</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">seen</td>
<td style="text-align: center;">unseen</td>
<td style="text-align: center;">seen</td>
<td style="text-align: center;">unseen</td>
<td style="text-align: center;">seen</td>
<td style="text-align: center;">unseen</td>
<td style="text-align: center;">seen</td>
<td style="text-align: center;">unseen</td>
<td style="text-align: center;">seen</td>
<td style="text-align: center;">unseen</td>
</tr>
<tr>
<td style="text-align: center;">Pick \&amp; Place</td>
<td style="text-align: center;">69</td>
<td style="text-align: center;">50</td>
<td style="text-align: center;">28 (28)</td>
<td style="text-align: center;">17 (17)</td>
<td style="text-align: center;">30 (30)</td>
<td style="text-align: center;">24 (24)</td>
<td style="text-align: center;">53 (53)</td>
<td style="text-align: center;">31 (31)</td>
<td style="text-align: center;">20 (20)</td>
<td style="text-align: center;">10 (10)</td>
</tr>
<tr>
<td style="text-align: center;">Examine in Light</td>
<td style="text-align: center;">69</td>
<td style="text-align: center;">39</td>
<td style="text-align: center;">5 (13)</td>
<td style="text-align: center;">0 (6)</td>
<td style="text-align: center;">10 (26)</td>
<td style="text-align: center;">0 (15)</td>
<td style="text-align: center;">22 (41)</td>
<td style="text-align: center;">12 (37)</td>
<td style="text-align: center;">2 (9)</td>
<td style="text-align: center;">0 (8)</td>
</tr>
<tr>
<td style="text-align: center;">Clean \&amp; Place</td>
<td style="text-align: center;">67</td>
<td style="text-align: center;">74</td>
<td style="text-align: center;">32 (41)</td>
<td style="text-align: center;">12 (31)</td>
<td style="text-align: center;">32 (46)</td>
<td style="text-align: center;">22 (39)</td>
<td style="text-align: center;">44 (57)</td>
<td style="text-align: center;">41 (56)</td>
<td style="text-align: center;">18 (31)</td>
<td style="text-align: center;">22 (39)</td>
</tr>
<tr>
<td style="text-align: center;">Heat \&amp; Place</td>
<td style="text-align: center;">88</td>
<td style="text-align: center;">83</td>
<td style="text-align: center;">10 (29)</td>
<td style="text-align: center;">12 (33)</td>
<td style="text-align: center;">17 (38)</td>
<td style="text-align: center;">16 (39)</td>
<td style="text-align: center;">60 (66)</td>
<td style="text-align: center;">60 (72)</td>
<td style="text-align: center;">8 (29)</td>
<td style="text-align: center;">5 (30)</td>
</tr>
<tr>
<td style="text-align: center;">Cool \&amp; Place</td>
<td style="text-align: center;">76</td>
<td style="text-align: center;">91</td>
<td style="text-align: center;">2 (19)</td>
<td style="text-align: center;">21 (34)</td>
<td style="text-align: center;">5 (21)</td>
<td style="text-align: center;">19 (33)</td>
<td style="text-align: center;">41 (49)</td>
<td style="text-align: center;">27 (44)</td>
<td style="text-align: center;">7 (26)</td>
<td style="text-align: center;">17 (34)</td>
</tr>
<tr>
<td style="text-align: center;">Pick Two \&amp; Place</td>
<td style="text-align: center;">54</td>
<td style="text-align: center;">65</td>
<td style="text-align: center;">12 (23)</td>
<td style="text-align: center;">0 (26)</td>
<td style="text-align: center;">15 (33)</td>
<td style="text-align: center;">8 (30)</td>
<td style="text-align: center;">32 (42)</td>
<td style="text-align: center;">29 (44)</td>
<td style="text-align: center;">6 (16)</td>
<td style="text-align: center;">0 (6)</td>
</tr>
<tr>
<td style="text-align: center;">All Tasks</td>
<td style="text-align: center;">40</td>
<td style="text-align: center;">35</td>
<td style="text-align: center;">6 (15)</td>
<td style="text-align: center;">5 (14)</td>
<td style="text-align: center;">19 (31)</td>
<td style="text-align: center;">10 (20)</td>
<td style="text-align: center;">37 (46)</td>
<td style="text-align: center;">26 (37)</td>
<td style="text-align: center;">8 (17)</td>
<td style="text-align: center;">3 (12)</td>
</tr>
</tbody>
</table>
<p>Table 2: Zero-shot Domain Transfer. Left: Success percentages of the best BUTLER::Brain agents evaluated purely in TextWorld. Mid-Left: Success percentages after zero-shot transfer to embodied environments. Mid-Right: Success percentages of BUTLER with an oracle state-estimator and controller, an upper-bound. Right: Success percentages of BUTLER with human-annotated goal descriptions, an additional source of generalization difficulty. All successes are averaged across three evaluation runs. Goal-condition success rates (Shridhar et al., 2020) are given in parentheses. The Seq2Seq baseline is trained in TextWorld from pre-recorded expert demonstrations using standard supervised learning. BUTLER is our main model using the Mask R-CNN detector and A* navigator. BUTLER-ORACLE uses an oracle state-estimator with ground-truth object detections and an oracle controller that directly teleports between locations.</p>
<p>Comparing BUTLER to Seq2Seq, we see improved performance on all types of seen tasks and five of the seven types of unseen tasks, supporting the hypothesis that interactive TextWorld training is a key component in generalizing to unseen embodied tasks. Interactive language not only allows agents to explore and build an understanding of successful action patterns, but also to recover from mistakes. Through trial-and-error the BUTLER agent learns task-guided heuristics, e.g., searching all the drawers in kitchen to look for a knife. As Table 2 shows, these heuristics are subsequently more capable of generalizing to the embodied world. More details on TextWorld training and generalization performance can be found in Section 5.1.</p>
<h1>4.2 Transferring to Embodied Tasks</h1>
<p>Since TextWorld is an abstraction of the embodied world, transferring between modalities involves overcoming domain gaps that are present in the real world but not in TextWorld. For example, the physical size of objects and receptacles must be respected - while TextWorld will allow certain objects to be placed inside any receptacle, in the embodied world it might be impossible to put a larger object into a small receptacle (e.g. a large pot into a microwave).</p>
<p>Subsequently, a TextWorld-trained agent's ability to solve embodied tasks is hindered by these domain gaps. So to study the transferability of the text agent in isolation, we introduce BUTLER-ORACLE in Table 2, an oracle variant of BUTLER which uses perfect state-estimation, object-detection, and navigation. Despite these advantages, we nevertheless observe a notable drop in performance from TextWorld to BUTLER-ORACLE. This performance gap results from the domain gaps described above as well as misdetections from Mask R-CNN and navigation failures caused by collisions. Future work might address this issue by reducing the domain gap between the two environments, or performing additional fine-tuning in the embodied setting.
The supplementary video contains qualitative examples of the BUTLER agent solving tasks in unseen environments. It showcases 3 successes and 1 failure of a TextWorld-only agent trained on All Tasks. In "put a watch in the safe", the agent has never seen the 'watch'-'safe' combination as a goal.</p>
<h3>4.3 Generalizing to Human-Annotated Goals</h3>
<p>BUTLER is trained with templated language, but in realistic scenarios, goals are often posed with open-ended natural language. In Table 2, we present Human Goals results of BUTLER evaluated on human-annotated ALFRED goals, which contain 66 unseen verbs (e.g., 'wash', 'grab', 'chill') and 189 unseen nouns (e.g., 'rag', 'lotion', 'disc'; see Appendix H for full list). Surprisingly, we find non-trivial goal-completion rate indicating that certain categories of task, such as pick and place, are quite generalizable to human language. While these preliminary results with natural language are encouraging, we expect future work could augment the templated language with synthetic-to-real transfer methods (Marzoev et al., 2020) for better generalization.</p>
<h1>4.4 To Pretrain or not to Pretrain in TextWorld?</h1>
<p>Given the domain gap between TextWorld and the embodied world, Why not eliminate this gap by training from scratch in the embodied world? To answer this question, we investigate three training strategies: (i) Embodied-ONLY: pure embodied training, (ii) TW-ONLY: pure TextWorld training followed by zero-shot embodied transfer and
(iii) HYBRID training that switches between the two environments with $75 \%$ probability for TextWorld and $25 \%$ for embodied world. Table 3 presents success rates for these agents trained and evaluated on All Tasks. All evaluations were conducted with an oracle state-estimator and controller. For a fair comparison, each agent is trained for 50 K episodes and the training speed is recorded for each strategy. We report peak performance for each split.
Results indicate that TW-ONLY generalizes better to unseen environments while Embodied-ONLY quickly overfits to seen environments (even with a perfect object detector and teleport navigator). We hypothesize that the abstract TextWorld environment allows the agent to focus on quickly learning tasks without having to deal execution-failures and expert-failures caused by physical constraints inherent to embodied environments. TextWorld training is also $7 \times$ faster $^{4}$ since it does not require running a rendering or physics engine like in the embodied setting. See Section F for more quantitative evaluations on the benefits of training in TextWorld.</p>
<h2>5 Ablations</h2>
<p>We conduct ablation studies to further investigate: (1) The generalization performance of BUTLER::BraIn within TextWorld environments, (2) The ability of unimodal agents to learn directly through visual observations or action history, (3) The importance of various hyper-parameters and modeling choices for the performance of BUTLER::BRAIN.</p>
<h3>5.1 Generalization within TextWorld</h3>
<p>We train and evaluate BUTLER::BraIn in abstract TextWorld environments spanning the six tasks in Table 1, as well as All Tasks. Similar to the zero-shot results presented in Section 4.1, the All Tasks setting shows the extent to which a single policy can learn and generalize on the large set of 3,553 different tasks, but here without having to deal with failures from embodied execution.</p>
<p>We first experimented with training BUTLER::BraIn through reinforcement learning (RL) where the agent is rewarded after completing a goal. Due to the infesibility of using candidate commands or command templates as discussed in Section I, the RL agent had to generate actions token-by-token. Since the probability of randomly stumbling upon a grammatically correct and contextually valid action is very low ( $7.02 \mathrm{e}-44$ for sequence length 10 ), the RL agent struggled to make any meaningful progress towards the tasks.</p>
<p>After concluding that current reinforcement learning approaches were not successful on our set of training tasks, we turned to DAgger (Ross et al., 2011) assisted by a rule-based expert (detailed in Appendix E). BUTLER::BraIn is trained for 100K episodes using data collected by interacting with the set of training games.</p>
<p>Results in Table 4 show (i) Training success rate varies from 16-60\% depending on the category of tasks, illustrating the challenge of solving hundreds to thousands of training tasks within each category. (ii) Transferring from training to heldout test games typically reduces performance, with the unseen rooms leading to the largest performance drops. Notable exceptions include heat and cool tasks where unseen performance exceeds training performance. (iii) Beam search is a key contributor to test performance; its ablation causes a performance drop of $21 \%$ on the seen split of All Tasks. (iv) Further ablating the DAgger strategy and directly training a Sequence-to-Sequence (Seq2Seq) model</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">Pick \&amp; Place</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Examine in</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Clean \&amp; Place</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Heat \&amp; Place</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Cool \&amp; Place</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Pick Two \&amp; Place</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">All Tasks</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">th</td>
<td style="text-align: center;">sn</td>
<td style="text-align: center;">un</td>
<td style="text-align: center;">th</td>
<td style="text-align: center;">sn</td>
<td style="text-align: center;">un</td>
<td style="text-align: center;">th</td>
<td style="text-align: center;">sn</td>
<td style="text-align: center;">un</td>
<td style="text-align: center;">th</td>
<td style="text-align: center;">sn</td>
<td style="text-align: center;">un</td>
<td style="text-align: center;">th</td>
<td style="text-align: center;">sn</td>
<td style="text-align: center;">un</td>
<td style="text-align: center;">th</td>
<td style="text-align: center;">sn</td>
<td style="text-align: center;">un</td>
<td style="text-align: center;">th</td>
<td style="text-align: center;">sn</td>
</tr>
<tr>
<td style="text-align: center;">BUTLER</td>
<td style="text-align: center;">54</td>
<td style="text-align: center;">61</td>
<td style="text-align: center;">46</td>
<td style="text-align: center;">59</td>
<td style="text-align: center;">39</td>
<td style="text-align: center;">22</td>
<td style="text-align: center;">37</td>
<td style="text-align: center;">44</td>
<td style="text-align: center;">39</td>
<td style="text-align: center;">60</td>
<td style="text-align: center;">81</td>
<td style="text-align: center;">74</td>
<td style="text-align: center;">46</td>
<td style="text-align: center;">60</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">27</td>
<td style="text-align: center;">29</td>
<td style="text-align: center;">24</td>
<td style="text-align: center;">16</td>
<td style="text-align: center;">40</td>
</tr>
<tr>
<td style="text-align: center;">BUTLER $_{g}$</td>
<td style="text-align: center;">54</td>
<td style="text-align: center;">43</td>
<td style="text-align: center;">33</td>
<td style="text-align: center;">59</td>
<td style="text-align: center;">31</td>
<td style="text-align: center;">17</td>
<td style="text-align: center;">37</td>
<td style="text-align: center;">30</td>
<td style="text-align: center;">26</td>
<td style="text-align: center;">60</td>
<td style="text-align: center;">69</td>
<td style="text-align: center;">70</td>
<td style="text-align: center;">46</td>
<td style="text-align: center;">50</td>
<td style="text-align: center;">76</td>
<td style="text-align: center;">27</td>
<td style="text-align: center;">38</td>
<td style="text-align: center;">12</td>
<td style="text-align: center;">16</td>
<td style="text-align: center;">19</td>
</tr>
<tr>
<td style="text-align: center;">Seq2Seq</td>
<td style="text-align: center;">31</td>
<td style="text-align: center;">26</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">44</td>
<td style="text-align: center;">31</td>
<td style="text-align: center;">11</td>
<td style="text-align: center;">34</td>
<td style="text-align: center;">30</td>
<td style="text-align: center;">42</td>
<td style="text-align: center;">36</td>
<td style="text-align: center;">50</td>
<td style="text-align: center;">30</td>
<td style="text-align: center;">27</td>
<td style="text-align: center;">32</td>
<td style="text-align: center;">33</td>
<td style="text-align: center;">17</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">9</td>
<td style="text-align: center;">10</td>
</tr>
</tbody>
</table>
<p>Table 4: Generalization within TextWorld environments: We independently train BUTLER::Brain on each type of TextWorld task and evaluate on heldout scenes of the same type. Respectively, $\mathrm{tn} / \mathrm{sn} / \mathrm{un}$ indicate success rate on train/seen/unseen tasks. All sn and un scores are computed using the random seeds (from 8 in total) producing the best final training score on each task type. BUTLER is trained with DAgger and performs beam search during evaluation. Without beam search, BUTLER $_{g}$ decodes actions greedily and gets stuck repeating failed actions. Further removing DAgger and training the model in a Seq2Seq fashion leads to worse generalization. Note that tn scores for BUTLER are lower than sn and un as they were computed without beam search.
with pre-recorded expert demonstrations causes a bigger performance drop of $30 \%$ on seen split of All Tasks. These results suggest that online interaction with the environment, as facilitated by DAgger learning and beam search, is essential for recovering from mistakes and sub-optimal behavior.</p>
<h1>5.2 UNIMODAL BASELINES</h1>
<p>Table 5 presents results for unimodal baseline comparisons to BUTLER. For all baselines, the action space and controller are fixed, but the state space is substituted with different modalities. To study the agents' capability of learning a single policy that generalizes across various tasks, we train and evaluate on All Tasks. In Vision (ResNet18), the textual observation from the state-estimator is replaced with ResNet-18 $\mathrm{f} \subset 7$ features (He et al., 2016) from the visual frame. Similarly, Vision (MCNN-FPN) uses the pre-trained Mask R-CNN from the state-estimator to extract FPN layer features for the whole image. Action-ONLY acts without any visual or textual feedback. We report peak performance for each split.</p>
<p>The visual models tend to overfit to seen environments and generalize poorly to unfamiliar environments. Operating in text-space allows better transfer of policies without needing to learn state representations that are robust to visually diverse environments. The zero-performing Action-ONLY baseline indicates that memorizing action sequences is an infeasible strategy for agents.</p>
<h3>5.3 Model Ablations</h3>
<p>Figure 4 illustrates more factors that affect the performance of BUTLER::Brain. The three rows of plots show training curves, evaluation curves in seen and unseen settings, respectively. All experiments were trained and evaluated on All Tasks with 8 random seeds.</p>
<p>In the first column, we show the effect of using different observation queue lengths $k$ as described in Section 3.1, in which size 0 refers to not providing any observation information to the agent. In the second column, we examine the effect of explicitly keeping the initial observation $o_{0}$, which lists all the receptacles in the scene. Keeping the initial observation $o_{0}$ facilitates the decoder to generate receptacle words more accurately for unseen tasks, but may be unnecessary in seen environments. The third column suggests that the recurrent component in our aggregator is helpful in making history-based decisions</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Agent</th>
<th style="text-align: center;">seen <br> (once $\%$</th>
<th style="text-align: center;">unseen <br> (once $\%$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">BUTLER</td>
<td style="text-align: center;">$\mathbf{1 8 . 8}$</td>
<td style="text-align: center;">$\mathbf{1 0 . 1}$</td>
</tr>
<tr>
<td style="text-align: left;">VISION (RESNET18)</td>
<td style="text-align: center;">10.0</td>
<td style="text-align: center;">6.0</td>
</tr>
<tr>
<td style="text-align: left;">VISION (MCNN-FPN)</td>
<td style="text-align: center;">11.4</td>
<td style="text-align: center;">4.5</td>
</tr>
<tr>
<td style="text-align: left;">ACTION-ONLY</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">0.0</td>
</tr>
</tbody>
</table>
<p>Table 5: Unimodal Baselines. Trained on All Tasks with 50 K episodes and evaluated in the embodied environment.</p>
<p>particularly in seen environments where keeping track of object locations is useful. Finally, in the fourth column, we see that using more training games can lead to better generalizability in both seen and unseen settings. Fewer training games achieve high training scores by quickly overfitting, which lead to zero evaluation scores.</p>
<h1>6 Related Work</h1>
<p>The longstanding goal of grounding language learning in embodied settings (Bisk et al., 2020) has lead to substantial work on interactive environments. ALFWorld extends that work with fully-interactive aligned environments that parallel textual interactions with photo-realistic renderings and physical interactions.</p>
<p>Interactive Text-Only Environments: We build on the work of text-based environments like TextWorld (Côté et al., 2018) and Jericho (Hausknecht et al., 2020). While these environment allow for textual interactions, they are not grounded in visual or physical modalities.</p>
<p>Vision and language: While substantial work exists on vision-language representation learning e.g., MAttNet (Yu et al., 2018b), CMN (Hu et al., 2017), VQA (Antol et al., 2015), CLEVR (Johnson et al., 2017), ViLBERT (Lu et al., 2019), they lack embodied or sequential decision making.</p>
<p>Embodied Language Learning: To address language learning in embodied domains, a number of interactive environments have been proposed: BabyAI (Chevalier-Boisvert et al., 2019), Room2Room (Anderson et al., 2018b), ALFRED (Shridhar et al., 2020), InteractiveQA (Gordon et al., 2018), EmbodiedQA (Das et al., 2018), and NetHack (Küttler et al., 2020). These environments use language to communicate instructions, goals, or queries to the agent, but not as a fully-interactive textual modality.</p>
<p>Language for State and Action Representation: Others have used language for more than just goal-specification. Schwartz et al. (2019) use language as an intermediate state to learn policies in VizDoom. Similarly, Narasimhan et al. (2018) and Zhong et al. (2020) use language as an intermediate representation to transfer policies across different environments. Hu et al. (2019) use a natural language instructor to command a low-level executor, and Jiang et al. (2019) use language as an abstraction for hierarchical RL. However these works do not feature an interactive text environment for pre-training the agent in an abstract textual space. Zhu et al. (2017) use high-level commands similar to ALFWorld to solve tasks in THOR with IL and RL-finetuning methods, but the policy only generalizes to a small set of tasks due to the vision-based state representation. Using symbolic representations for state and action is also an inherent characteristic of works in task-and-motionplanning (Kaelbling and Lozano-Pérez, 2011; Konidaris et al., 2018) and symbolic planning (Asai and Fukunaga, 2017).</p>
<p>World Models: The concept of using TextWorld as a "game engine" to represent the world is broadly related to inverse graphics (Kulkarni et al., 2015) and inverse dynamics (Wu et al., 2017) where abstract visual or physical models are used for reasoning and future predictions. Similarly, some results in cognitive science suggest that humans use language as a cheaper alternative to sensorimotor simulation (Banks et al., 2020; Dove, 2014).</p>
<h2>7 CONCLUSION</h2>
<p>We introduced ALFWorld, the first interactive text environment with aligned embodied worlds. ALFWorld allows agents to explore, interact, and learn abstract polices in a textual environment. Pre-training our novel BUTLER agent in TextWorld, we show zero-shot generalization to embodied tasks in the ALFRED dataset. The results indicate that reasoning in textual space allows for better generalization to unseen tasks and also faster training, compared to other modalities like vision.</p>
<p>BUTLER is designed with modular components which can be upgraded in future work. Examples include the template-based state-estimator and the A* navigator which could be replaced with learned modules, enabling end-to-end training of the full pipeline. Another avenue of future work is to learn "textual dynamics models" through environment interactions, akin to vision-based world models (Ha and Schmidhuber, 2018). Such models would facilitate construction of text-engines for new domains, without requiring access to symbolic state descriptions like PDDL. Overall, we are excited by the challenges posed by aligned text and embodied environments for better cross-modal learning.</p>
<h1>ACKNOWLEDGMENTS</h1>
<p>The authors thank Cheng Zhang, Jesse Thomason, Karthik Desingh, Rishabh Joshi, Romain Laroche, Shunyu Yao, and Victor Zhong for insightful feedback and discussions. This work was done during Mohit Shridhar's internship at Microsoft Research.</p>
<h2>REFERENCES</h2>
<p>Adhikari, A., Yuan, X., Côté, M.-A., Zelinka, M., Rondeau, M.-A., Laroche, R., Poupart, P., Tang, J., Trischler, A., and Hamilton, W. L. (2020). Learning dynamic belief graphs to generalize on text-based games. In Neural Information Processing Systems (NeurIPS).</p>
<p>Ammanabrolu, P. and Hausknecht, M. (2020). Graph constrained reinforcement learning for natural language action spaces. In International Conference on Learning Representations.</p>
<p>Anderson, P., Wu, Q., Teney, D., Bruce, J., Johnson, M., Sünderhauf, N., Reid, I., Gould, S., and van den Hengel, A. (2018a). Vision-and-language navigation: Interpreting visually-grounded navigation instructions in real environments. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition.</p>
<p>Anderson, P., Wu, Q., Teney, D., Bruce, J., Johnson, M., Sünderhauf, N., Reid, I., Gould, S., and van den Hengel, A. (2018b). Vision-and-Language Navigation: Interpreting visually-grounded navigation instructions in real environments. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR).</p>
<p>Antol, S., Agrawal, A., Lu, J., Mitchell, M., Batra, D., Zitnick, C. L., and Parikh, D. (2015). VQA: Visual Question Answering. In International Conference on Computer Vision (ICCV).</p>
<p>Asai, M. and Fukunaga, A. (2017). Classical planning in deep latent space: Bridging the subsymbolicsymbolic boundary. arXiv preprint arXiv:1705.00154.</p>
<p>Ba, L. J., Kiros, J. R., and Hinton, G. E. (2016). Layer normalization. CoRR, abs/1607.06450.
Banks, B., Wingfield, C., and Connell, L. (2020). Linguistic distributional knowledge and sensorimotor grounding both contribute to semantic category production.</p>
<p>Bisk, Y., Holtzman, A., Thomason, J., Andreas, J., Bengio, Y., Chai, J., Lapata, M., Lazaridou, A., May, J., Nisnevich, A., Pinto, N., and Turian, J. (2020). Experience Grounds Language. In Empirical Methods in Natural Language Processing.</p>
<p>Chevalier-Boisvert, M., Bahdanau, D., Lahlou, S., Willems, L., Saharia, C., Nguyen, T. H., and Bengio, Y. (2019). BabyAI: First steps towards grounded language learning with a human in the loop. In International Conference on Learning Representations.</p>
<p>Cho, K., van Merriënboer, B., Gulcehre, C., Bahdanau, D., Bougares, F., Schwenk, H., and Bengio, Y. (2014). Learning phrase representations using RNN encoder-decoder for statistical machine translation. In Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP).</p>
<p>Côté, M.-A., Kádár, A., Yuan, X., Kybartas, B., Barnes, T., Fine, E., Moore, J., Tao, R. Y., Hausknecht, M., Asri, L. E., Adada, M., Tay, W., and Trischler, A. (2018). Textworld: A learning environment for text-based games. CoRR, abs/1806.11532.</p>
<p>Das, A., Datta, S., Gkioxari, G., Lee, S., Parikh, D., and Batra, D. (2018). Embodied Question Answering. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR).</p>
<p>Dove, G. (2014). Thinking in words: language as an embodied medium of thought. Topics in cognitive science, 6(3):371-389.</p>
<p>Gehrmann, S., Deng, Y., and Rush, A. (2018). Bottom-up abstractive summarization. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing.</p>
<p>Gordon, D., Kembhavi, A., Rastegari, M., Redmon, J., Fox, D., and Farhadi, A. (2018). Iqa: Visual question answering in interactive environments. In Computer Vision and Pattern Recognition (CVPR), 2018 IEEE Conference on.</p>
<p>Gulcehre, C., Ahn, S., Nallapati, R., Zhou, B., and Bengio, Y. (2016). Pointing the unknown words. In Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers).</p>
<p>Ha, D. and Schmidhuber, J. (2018). Recurrent world models facilitate policy evolution. In Advances in Neural Information Processing Systems 31.</p>
<p>Hausknecht, M. and Stone, P. (2015). Deep recurrent q-learning for partially observable mdps. arXiv preprint arXiv:1507.06527.</p>
<p>Hausknecht, M. J., Ammanabrolu, P., Côté, M.-A., and Yuan, X. (2020). Interactive fiction games: A colossal adventure. In $A A A I$.</p>
<p>He, K., Gkioxari, G., Dollár, P., and Girshick, R. (2017). Mask r-cnn. In Proceedings of the IEEE international conference on computer vision.</p>
<p>He, K., Zhang, X., Ren, S., and Sun, J. (2016). Deep residual learning for image recognition. In Proceedings of the IEEE conference on computer vision and pattern recognition.</p>
<p>Helmert, M. (2006). The Fast Downward planning system. Journal of Artificial Intelligence Research.
Hu, H., Yarats, D., Gong, Q., Tian, Y., and Lewis, M. (2019). Hierarchical decision making by generating and following natural language instructions. In Advances in Neural Information Processing Systems.</p>
<p>Hu, R., Rohrbach, M., Andreas, J., Darrell, T., and Saenko, K. (2017). Modeling relationships in referential expressions with compositional modular networks. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition.</p>
<p>Jiang, Y., Gu, S. S., Murphy, K. P., and Finn, C. (2019). Language as an abstraction for hierarchical deep reinforcement learning. In Advances in Neural Information Processing Systems.</p>
<p>Johnson, J., Hariharan, B., van der Maaten, L., Fei-Fei, L., Zitnick, C. L., and Girshick, R. (2017). Clevr: A diagnostic dataset for compositional language and elementary visual reasoning. In CVPR.</p>
<p>Johnson, J., Karpathy, A., and Fei-Fei, L. (2016). Densecap: Fully convolutional localization networks for dense captioning. In Proceedings of the IEEE conference on computer vision and pattern recognition.</p>
<p>Kaelbling, L. P. and Lozano-Pérez, T. (2011). Hierarchical task and motion planning in the now. In 2011 IEEE International Conference on Robotics and Automation, pages 1470-1477. IEEE.</p>
<p>Kingma, D. P. and Ba, J. (2014). Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980.</p>
<p>Kolve, E., Mottaghi, R., Han, W., VanderBilt, E., Weihs, L., Herrasti, A., Gordon, D., Zhu, Y., Gupta, A., and Farhadi, A. (2017). Ai2-thor: An interactive 3d environment for visual ai. arXiv preprint arXiv:1712.05474.</p>
<p>Konidaris, G., Kaelbling, L. P., and Lozano-Perez, T. (2018). From skills to symbols: Learning symbolic representations for abstract high-level planning. Journal of Artificial Intelligence Research, $61: 215-289$.</p>
<p>Kulkarni, T. D., Whitney, W. F., Kohli, P., and Tenenbaum, J. (2015). Deep convolutional inverse graphics network. In Advances in neural information processing systems.</p>
<p>Küttler, H., Nardelli, N., Miller, A. H., Raileanu, R., Selvatici, M., Grefenstette, E., and Rocktäschel, T. (2020). The nethack learning environment.</p>
<p>Lin, T.-Y., Maire, M., Belongie, S., Hays, J., Perona, P., Ramanan, D., Dollár, P., and Zitnick, C. L. (2014). Microsoft coco: Common objects in context. In European conference on computer vision.</p>
<p>Lu, J., Batra, D., Parikh, D., and Lee, S. (2019). Vilbert: Pretraining task-agnostic visiolinguistic representations for vision-and-language tasks. In Advances in Neural Information Processing Systems.</p>
<p>MacMahon, M., Stankiewicz, B., and Kuipers, B. (2006). Walk the talk: Connecting language, knowledge, and action in route instructions. In Proceedings of the 21st National Conference on Artificial Intelligence (AAAI-2006).</p>
<p>Marzoev, A., Madden, S., Kaashoek, M. F., Cafarella, M., and Andreas, J. (2020). Unnatural language processing: Bridging the gap between synthetic and natural language data. arXiv preprint arXiv:2004.13645.</p>
<p>McDermott, D., Ghallab, M., Howe, A., Knoblock, C., Ram, A., Veloso, M., Weld, D., and Wilkins, D. (1998). Pddl-the planning domain definition language.</p>
<p>Narasimhan, K., Barzilay, R., and Jaakkola, T. (2018). Grounding language for transfer in deep reinforcement learning. JAIR, 63(1):849-874.</p>
<p>Press, O. and Wolf, L. (2016). Using the output embedding to improve language models. arXiv preprint arXiv:1608.05859.</p>
<p>Reddy, D. R. et al. (1977). Speech understanding systems: A summary of results of the five-year research effort. Department of Computer Science. Camegie-Mell University, Pittsburgh, PA, 17.</p>
<p>Ross, S., Gordon, G., and Bagnell, D. (2011). A reduction of imitation learning and structured prediction to no-regret online learning. In Proceedings of the fourteenth international conference on artificial intelligence and statistics.</p>
<p>Sanh, V., Debut, L., Chaumond, J., and Wolf, T. (2019). Distilbert, a distilled version of bert: smaller, faster, cheaper and lighter. arXiv preprint arXiv:1910.01108.</p>
<p>Schwartz, E., Tennenholtz, G., Tessler, C., and Mannor, S. (2019). Language is power: Representing states using natural language in reinforcement learning.</p>
<p>Sharma, S., Asri, L. E., Schulz, H., and Zumer, J. (2017). Relevance of unsupervised metrics in taskoriented dialogue for evaluating natural language generation. arXiv preprint arXiv:1706.09799.</p>
<p>Shridhar, M., Thomason, J., Gordon, D., Bisk, Y., Han, W., Mottaghi, R., Zettlemoyer, L., and Fox, D. (2020). Alfred: A benchmark for interpreting grounded instructions for everyday tasks. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages $10740-10749$.</p>
<p>Sun, C., Myers, A., Vondrick, C., Murphy, K., and Schmid, C. (2019). Videobert: A joint model for video and language representation learning. In Proceedings of the IEEE International Conference on Computer Vision.</p>
<p>Tang, K., Niu, Y., Huang, J., Shi, J., and Zhang, H. (2020). Unbiased scene graph generation from biased training. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition.</p>
<p>Todorov, E., Erez, T., and Tassa, Y. (2012). Mujoco: A physics engine for model-based control. In 2012 IEEE/RSJ International Conference on Intelligent Robots and Systems.</p>
<p>Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N., Kaiser, L. u., and Polosukhin, I. (2017). Attention is all you need. In Advances in Neural Information Processing Systems 30.</p>
<p>Wang, X., Huang, Q., Celikyilmaz, A., Gao, J., Shen, D., Wang, Y.-F., Wang, W. Y., and Zhang, L. (2019). Reinforced cross-modal matching and self-supervised imitation learning for visionlanguage navigation. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition.</p>
<p>Wu, J., Lu, E., Kohli, P., Freeman, B., and Tenenbaum, J. (2017). Learning to see physics via visual de-animation. In Advances in Neural Information Processing Systems.</p>
<p>Yu, A. W., Dohan, D., Le, Q., Luong, T., Zhao, R., and Chen, K. (2018a). Fast and accurate reading comprehension by combining self-attention and convolution. In International Conference on Learning Representations.</p>
<p>Yu, L., Lin, Z., Shen, X., Yang, J., Lu, X., Bansal, M., and Berg, T. L. (2018b). Mattnet: Modular attention network for referring expression comprehension. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition.</p>
<p>Yuan, X., Côté, M.-A., Sordoni, A., Laroche, R., Combes, R. T. d., Hausknecht, M., and Trischler, A. (2018). Counting to explore and generalize in text-based games. arXiv preprint arXiv:1806.11525.</p>
<p>Zhong, V., Rocktäschel, T., and Grefenstette, E. (2020). RTFM: Generalising to novel environment dynamics via reading. In $I C L R$.</p>
<p>Zhu, Y., Gordon, D., Kolve, E., Fox, D., Fei-Fei, L., Gupta, A., Mottaghi, R., and Farhadi, A. (2017). Visual semantic planning using deep successor representations. In IEEE International Conference on Computer Vision, ICCV 2017, Venice, Italy, October 22-29, 2017.</p>
<h1>A DETAILS OF BUTLER::BRAIN</h1>
<p>In this section, we use $o_{t}$ to denote text observation at game step $t, g$ to denote the goal description provided by a game.
We use $L$ to refer to a linear transformation and $L^{f}$ means it is followed by a non-linear activation function $f$. Brackets $[\cdot ; \cdot]$ denote vector concatenation, $\odot$ denotes element-wise multiplication.</p>
<h2>A. 1 ObSERVATION QUEUE</h2>
<p>As mentioned in Section 3.1, we utilize an observation queue to cache the text observations that have been seen recently. Since the initial observation $o_{0}$ describes the high level layout of a room, including receptacles present in the current game, we it visible to BUTLER::BraIn at all game steps, regardless of the length of the observation queue. Specifically, the observation queue has an extra space storing $o_{0}$, at any game step, we first concatenate all cached observations in the queue, then prepend the $o_{0}$ to form the input to the encoder. We find this helpful because it facilitates the pointer softmax mechanism in the decoder (described below) by guiding it to point to receptacle words in the observation. An ablation study on this is provided in Section 5.</p>
<h2>A. 2 ENCODER</h2>
<p>We use a transformer-based encoder, which consists of an embedding layer and a transformer block (Vaswani et al., 2017). Specifically, embeddings are initialized by pre-trained 768-dimensional BERT embeddings (Sanh et al., 2019). The embeddings are fixed during training in all settings.
The transformer block consists of a stack of 5 convolutional layers, a self-attention layer, and a 2-layer MLP with a ReLU non-linear activation function in between. In the block, each convolutional layer has 64 filters, each kernel's size is 5 . In the self-attention layer, we use a block hidden size $H$ of 64, as well as a single head attention mechanism. Layernorm (Ba et al., 2016) is applied after each component inside the block. Following standard transformer training, we add positional encodings into each block's input.
At every game step $t$, we use the same encoder to process text observation $o_{t}$ and goal description $g$. The resulting representations are $h_{o_{t}} \in \mathbb{R}^{L_{o_{t}} \times H}$ and $h_{g} \in \mathbb{R}^{L_{g} \times H}$, where $L_{o_{t}}$ is the number of tokens in $o_{t}, L_{g}$ denotes the number of tokens in $g, H=64$ is the hidden size.</p>
<h2>A. 3 AGGREGATOR</h2>
<p>We adopt the context-query attention mechanism from the question answering literature (Yu et al., 2018a) to aggregate the two representations $h_{o_{t}}$ and $h_{g}$.
Specifically, a tri-linear similarity function is used to compute the similarity between each token in $h_{o_{t}}$ with each token in $h_{g}$. The similarity between $i$-th token in $h_{o}$ and $j$-th token in $h_{g}$ is thus computed by (omitting game step $t$ for simplicity):</p>
<p>$$
\operatorname{Sim}(i, j)=W\left(h_{o_{t}}, h_{g_{j}}, h_{o_{t}} \odot h_{g_{j}}\right)
$$</p>
<p>where $W$ is a trainable parameter in the tri-linear function. By applying the above computation for each $h_{o}$ and $h_{g}$ pair, we get a similarity matrix $S \in \mathbb{R}^{L_{o} \times L_{g}}$.
By computing the softmax of the similarity matrix $S$ along both dimensions (number of tokens in goal description $L_{g}$ and number of tokens in observation $L_{o}$ ), we get $S_{g}$ and $S_{o}$, respectively. The two representations are then aggregated by:</p>
<p>$$
\begin{aligned}
h_{o g} &amp; =\left[h_{o} ; P ; h_{o} \odot P ; h_{o} \odot Q\right] \
P &amp; =S_{g} h_{g}^{\top} \
Q &amp; =S_{g} S_{o}^{\top} h_{o}^{\top}
\end{aligned}
$$</p>
<p>where $h_{o g} \in \mathbb{R}^{L_{o} \times 4 H}$ is the aggregated observation representation.</p>
<p>Next, a linear transformation projects the aggregated representations to a space with size $H=64$ :</p>
<p>$$
h_{o g}=L^{\text {tanh }}\left(h_{o g}\right)
$$</p>
<p>To incorporate history, we use a recurrent neural network. Specifically, we use a GRU (Cho et al., 2014):</p>
<p>$$
\begin{aligned}
h_{\mathrm{RNN}} &amp; =\operatorname{Mean}\left(h_{o g}\right) \
h_{t} &amp; =\operatorname{GRU}\left(h_{\mathrm{RNN}}, h_{t-1}\right)
\end{aligned}
$$</p>
<p>in which, the mean pooling is performed along the dimension of number of tokens, i.e., $h_{\mathrm{RNN}} \in \mathbb{R}^{H}$. $h_{t-1}$ is the output of the GRU cell at game step $t-1$.</p>
<h1>A. 4 DECODER</h1>
<p>Our decoder consists of an embedding layer, a transformer block and a pointer softmax mechanism (Gulcehre et al., 2016). We first obtain the source representation by concatenating $h_{o g}$ and $h_{t}$, resulting $h_{\text {src }} \in \mathbb{R}^{L_{o} \times 2 H}$.</p>
<p>Similar to the encoder, the embedding layer is frozen after initializing it with pre-trained BERT embeddings. The transformer block consists of two attention layers and a 3-layer MLP with ReLU non-linear activation functions inbetween. The first attention layer computes the self attention of the input embeddings $h_{\text {self }}$ as a contextual encoding for the target tokens. The second attention layer then computes the attention $\alpha_{\text {src }}^{i} \in \mathbb{R}^{L_{o}}$ between the source representation $h_{\text {src }}$ and the $i$-th token in $h_{\text {self }}$. The $i$-th target token is consequently represented by the weighted sum of $h_{\text {src }}$, with the weights $\alpha_{\text {src }}^{i}$. This generates a source information-aware target representation $h_{\text {tgt }}^{i} \in \mathbb{R}^{L_{\text {tgt }} \times H}$, where $L_{\text {tgt }}$ denotes the number of tokens in the target sequence. Next, $h_{\text {tgt }}^{i}$ is fed into the 3-layer MLP with ReLU activation functions inbetween, resulting $h_{\text {tgt }} \in \mathbb{R}^{L_{\text {tgt }} \times H}$. The block hidden size of this transformer is $H=64$.</p>
<p>Taking $h_{\text {tgt }}$ as input, a linear layer with tanh activation projects the target representation into the same space as the embeddings (with dimensionality of 768), then the pre-trained embedding matrix $E$ generates output logits (Press and Wolf, 2016), where the output size is same as the vocabulary size. The resulting logits are then normalized by a softmax to generate a probability distribution over all tokens in vocabulary:</p>
<p>$$
p_{a}\left(y^{i}\right)=E^{\text {Softmax }}\left(L^{\text {tanh }}\left(h_{\text {tgt }}\right)\right)
$$</p>
<p>in which, $p_{a}\left(y^{i}\right)$ is the generation (abstractive) probability distribution.
We employ the pointer softmax (Gulcehre et al., 2016) mechanism to switch between generating a token $y^{i}$ (from a vocabulary) and pointing (to a token in the source text). Specifically, the pointer softmax module computes a scalar switch $s^{i}$ at each generation time-step $i$ and uses it to interpolate the abstractive distribution $p_{a}\left(y^{i}\right)$ over the vocabulary (Equation 5) and the extractive distribution $p_{x}\left(y^{i}\right)=\alpha_{\text {src }}^{i}$ over the source text tokens:</p>
<p>$$
p\left(y^{i}\right)=s^{i} \cdot p_{a}\left(y^{i}\right)+\left(1-s^{i}\right) \cdot p_{x}\left(y^{i}\right)
$$</p>
<p>where $s^{i}$ is conditioned on both the attention-weighted source representation $\sum_{j} \alpha_{\text {src }}^{i, j} \cdot h_{\text {src }}^{j}$ and the decoder state $h_{\text {tgt }}^{i}$ :</p>
<p>$$
s^{i}=L_{1}^{\text {sigmoid }}\left(\tanh \left(L_{2}\left(\sum_{j} \alpha_{\text {src }}^{i, j} \cdot h_{\text {src }}^{j}\right)+L_{3}\left(h_{\text {tgt }}^{i}\right)\right)\right)
$$</p>
<p>In which, $L_{1} \in \mathbb{R}^{H \times 1}, L_{2} \in \mathbb{R}^{2 H \times H}$ and $L_{3} \in \mathbb{R}^{H \times H}$ are linear layers, $H=64$.</p>
<h2>B TRAINING AND IMPLEMENTATION DETAILS</h2>
<p>In this section, we provide hyperparameters and other implementation details.
For all experiments, we use Adam (Kingma and Ba, 2014) as the optimizer. The learning rate is set to 0.001 with a clip gradient norm of 5 .</p>
<p>During training with DAgger, we use a batch size of 10 to collect transitions (tuples of $\left{o_{0}, o_{t}, g, \hat{a}<em t="t">{t}\right}$ ) at each game step $t$, where $\hat{a}</em>$ is the ground-truth action provided by the rule-based expert (see Section E). We gather a sequence of transitions from each game episode, and push each sequence into a replay buffer, which has a capacity of 500 K episodes. We set the max number of steps per episode to be 50 . If the agent uses up this budget, the game episode is forced to terminate. We linearly anneal the fraction of the expert's assistance from $100 \%$ to $1 \%$ across a window of 50 K episodes.</p>
<p>The agent is updated after every 5 steps of data collection. We sample a batch of 64 data points from the replay buffer. In the setting with the recurrent aggregator, every sampled data point is a sequence of 4 consecutive transitions. Following the training strategy used in the recurrent DQN literature (Hausknecht and Stone, 2015; Yuan et al., 2018), we use the first 2 transitions to estimate the recurrent states, and the last 2 transitions for updating the model parameters.</p>
<p>BUTLER::Brain learns to generate actions token-by-token, where we set the max token length to be 20. The decoder stops generation either when it generates a special end-of-sentence token [EOS], or hits the token length limit.</p>
<p>When using the beam search heuristic to recover from failed actions (see Figure 5), we use a beam width of 10, and take the top-5 ranked outputs as candidates. We iterate through the candidates in the rank order until one of them succeeds. This heuristic is not always guaranteed to succeed, however, we find it helpful in most cases. Note that we do not employ beam search when we evaluate during the training process for efficiency, e.g., in the seen and unseen curves shown in Figure 4. We take the best performing checkpoints and then apply this heuristic during evaluation and report the resulting scores in tables (e.g., Table 2).
<img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 5: Beam search for recovery actions.
By default unless mentioned otherwise (ablations), we use all available training games in each of the task types. We use an observation queue length of 5 and use a recurrent aggregator. The model is trained with DAgger, and during evaluation, we apply the beam search heuristic to produce the reported scores. All experiment settings in TextWorld are run with 8 random seeds. All text agents are trained for 50,000 episodes.</p>
<h1>C TextWorld Engine</h1>
<p>Internally, the TextWorld Engine is divided into two main components: a planner and text generator.
Planner TextWorld Engine uses Fast Downward (Helmert, 2006), a domain-independent classical planning system to maintain and update the current state of the game. A state is represented by a set of predicates which define the relations between the entities (objects, player, room, etc.) present in the game. A state can be modified by applying production rules corresponding to the actions listed in Table 6. All variables, predicates, and rules are defined using the PDDL language.</p>
<p>For instance, here is a simple state representing a player standing next to a microwave which is closed and contains a mug:</p>
<p>$$
\begin{aligned}
s_{t}= &amp; \text { at }(\text { player, microwave }) \text { @in }(\text { mug, microwave }) \
&amp; \text { @ closed(microwave) @ openable(microwave), }
\end{aligned}
$$</p>
<p>where the symbol @ is the linear logic multiplicative conjunction operator. Given that state, a valid action could be open microwave, which would essentially transform the state by replacing closed(microwave) with open(microwave).</p>
<p>Text generator The other component of the TextWorld Engine, the text generator, uses a contextsensitive grammar designed for the ALFRED environments. The grammar consists of text templates similar to those listed in Table 6. When needed, the engine will sample a template given some context,</p>
<p>i.e., the current state and the last action. Then, the template gets realized using the predicates found in the current state.</p>
<h1>D Mask R-CNN Detector</h1>
<p>We use a Mask R-CNN detector (He et al., 2017) pre-trained on MSCOCO (Lin et al., 2014) and fine-tune it with additional labels from ALFRED training scenes. To generate additional labels, we replay the expert demonstrations from ALFRED and record ground-truth image and instance segmentation pairs from the simulator (THOR) after completing each high-level action e.g., goto, pickup etc. We generate a dataset of 50 K images, and fine-tune the detector for 4 epochs with a batch size of 8 and a learning rate of $5 e-4$. The detector recognizes 73 object classes where each class could vary up to 1-10 instances. Since demonstrations in the kitchen are often longer as they involve complex sequences like heating, cleaning etc., the labels are slightly skewed towards kitchen objects. To counter this, we balance the number of images sampled from each room (kitchen, bedroom, livingroom, bathroom) so the distribution of object categories is uniform across the dataset.</p>
<h2>E Rule-based Expert</h2>
<p>To train text agents in an imitation learning (IL) setting, we use a rule-based expert for supervision. A given task is decomposed into sequence of subgoals (e.g., for heat \&amp; place: find the object, pick the object, find the microwave, heat the object with the microwave, find the receptacle, place the object in the receptacle), and a closed-loop controller tries to sequentially execute these goals. We note that while designing rule-based experts for ALFWorld is relatively straightforward, experts operating directly in embodied settings like the PDDL planner used in ALFRED are prone to failures due to physical infeasibilities and non-deterministic behavior in physics-based environments.</p>
<h2>F Benefits of Training in TextWorld over Embodied World</h2>
<p>Pre-training in TextWorld offers several benefits over directly training in embodied environments. Figure 6 presents the performance of an expert (that agents are trained to imitate) across various environments. The abstract textual space leads to higher goal success rates resulting from successful navigation and manipulation subroutines. TextWorld agents also do not suffer from object misdetections and slow execution speed.
<img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 6: Domain Analysis: The performance of an expert across various environments.</p>
<h1>G Observation Templates</h1>
<p>The following templates are used by the state-estimator to generate textual observations $o_{t}$. The object IDs {obj id} correspond to Mask R-CNN objects detection or ground-truth instance IDs. The receptacle IDs {recep id} are based on the receptacles listed in the initial observation $o_{0}$. Failed actions and actions without any state-changes result in Nothing happens.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Actions</th>
<th style="text-align: center;">Templates</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">goto</td>
<td style="text-align: center;">(a) You arrive at {loc id}. On the {recep id}, you see a {objl id}, ... and a {objN id}. <br> (b) You arrive at {loc id}. The {recep id} is closed. <br> (c) You arrive at {loc id}. The {recep id} is open. <br> On it, you see a {objl id}, ... and a {objN id}.</td>
</tr>
<tr>
<td style="text-align: center;">take</td>
<td style="text-align: center;">You pick up the {obj id} from the {recep id}.</td>
</tr>
<tr>
<td style="text-align: center;">put</td>
<td style="text-align: center;">You put the {obj id} on the {recep id}.</td>
</tr>
<tr>
<td style="text-align: center;">open</td>
<td style="text-align: center;">(a) You open the {recep id}. In it, you see a {objl id}, ... and a {objN id}. <br> (b) You open the {recep id}. The {recep id} is empty.</td>
</tr>
<tr>
<td style="text-align: center;">close</td>
<td style="text-align: center;">You close the {recep id}.</td>
</tr>
<tr>
<td style="text-align: center;">toggle</td>
<td style="text-align: center;">You turn the {obj id} on.</td>
</tr>
<tr>
<td style="text-align: center;">heat</td>
<td style="text-align: center;">You heat the {obj id} with the {recep id}.</td>
</tr>
<tr>
<td style="text-align: center;">cool</td>
<td style="text-align: center;">You cool the {obj id} with the {recep id}.</td>
</tr>
<tr>
<td style="text-align: center;">clean</td>
<td style="text-align: center;">You clean the {obj id} with the {recep id}.</td>
</tr>
<tr>
<td style="text-align: center;">inventory</td>
<td style="text-align: center;">(a) You are carrying: {obj id}. <br> (b) You are not carrying anything.</td>
</tr>
<tr>
<td style="text-align: center;">examine</td>
<td style="text-align: center;">(a) On the {recep id}, you see a {objl id}, ... and a {objN id}. <br> (b) This is a hot/cold/clean {obj}.</td>
</tr>
</tbody>
</table>
<p>Table 6: High-level text actions supported in ALFWorld along with their observation templates.</p>
<h1>H GOAL DESCRIPTIONS</h1>
<h2>H. 1 TEMPLATED GOALS</h2>
<p>The goal instructions for training games are generated with following templates. Here obj, recep, lamp refer to object, receptacle, and lamp classes, respectively, that pertain to a particular task. For each task, the two corresponding templates are sampled with equal probability.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">task-type</th>
<th style="text-align: center;">Templates</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Pick \&amp; Place</td>
<td style="text-align: center;">(a) put a {obj} in {recep}. <br> (b) put some {obj} on {recep}.</td>
</tr>
<tr>
<td style="text-align: center;">Examine in Light</td>
<td style="text-align: center;">(a) look at {obj} under the {lamp}. <br> (b) examine the {obj} with the {lamp}.</td>
</tr>
<tr>
<td style="text-align: center;">Clean \&amp; Place</td>
<td style="text-align: center;">(a) put a clean {obj} in {recep}. <br> (b) clean some {obj} and put it in {recep}.</td>
</tr>
<tr>
<td style="text-align: center;">Heat \&amp; Place</td>
<td style="text-align: center;">(a) put a hot {obj} in {recep}. <br> (b) heat some {obj} and put it in {recep}.</td>
</tr>
<tr>
<td style="text-align: center;">Cool \&amp; Place</td>
<td style="text-align: center;">(a) put a cool {obj} in {recep}. <br> (b) cool some {obj} and put it in {recep}.</td>
</tr>
<tr>
<td style="text-align: center;">Pick Two \&amp; Place</td>
<td style="text-align: center;">(a) put two {obj} in {recep}. <br> (b) find two {obj} and put them {recep}.</td>
</tr>
</tbody>
</table>
<p>Table 7: Task-types and the corresponding goal description templates.</p>
<h2>H. 2 Human AnNotated Goals</h2>
<p>The human goal descriptions used during evaluation contain 66 unseen verbs and 189 unseen nouns with respect to the templated goal instructions used during training.</p>
<p>Unseen Verbs: acquire, arrange, can, carry, chill, choose, cleaning, clear, cook, cooked, cooled, dispose, done, drop, end, fill, filled, frying, garbage, gather, go, grab, handled, heated, heating, hold, holding, inspect, knock, left, lit, lock, microwave, microwaved, move, moving, pick, picking, place, placed, placing, putting, read, relocate, remove, retrieve, return, rinse, serve, set, soak, stand, standing, store, take, taken, throw, transfer, turn, turning, use, using, walk, warm, wash, washed.</p>
<p>Unseen Nouns: alarm, area, back, baisin, bar, bars, base, basin, bathroom, beat, bed, bedroom, bedside, bench, bin, books, bottle, bottles, bottom, box, boxes, bureau, burner, butter, can, canteen, card, cardboard, cards, cars, cds, cell, chair, chcair, chest, chill, cistern, cleaning, clock, clocks, coffee, container, containers, control, controllers, controls, cooker, corner, couch, count, counter, cover, cream, credit, cupboard, dining, disc, discs, dishwasher, disks, dispenser, door, drawers, dresser, edge, end, floor, food, foot, freezer, game, garbage, gas, glass, glasses, gold, grey, hand, head, holder, ice, inside, island, item, items, jars, keys, kitchen, knifes, knives, laddle, lamp, lap, left, lid, light, loaf, location, lotion, machine, magazine, maker, math, metal, microwaves, move, nail, newsletters, newspapers, night, nightstand, object, ottoman, oven, pans, paper, papers, pepper, phone, piece, pieces, pillows, place, polish, pot, pullout, pump, rack, rag, recycling, refrigerator, remote, remotes, right, rinse, roll, rolls, room, safe, salt, scoop, seat, sets, shaker, shakers, shelves, side, sink, sinks, skillet, soap, soaps, sofa, space, spatulas, sponge, spoon, spot, spout, spray, stand, stool, stove, supplies, table, tale, tank, television, textbooks, time, tissue, tissues, toaster, top, towel, trash, tray, tv, vanity, vases, vault, vegetable, wall, wash, washcloth, watches, water, window, wine.</p>
<h2>I Action Candidates vs Action Generation</h2>
<p>BUTLER::BraIn generates actions in a token-by-token fashion. Prior text-based agents typically use a list of candidate commands from the game engine (Adhikari et al., 2020) or populate a list of command templates (Ammanabrolu and Hausknecht, 2020). We initially trained our agents with candidate commands from the TextWorld Engine, but they quickly ovefit without learning affordances,</p>
<p>commonsense, or pre-conditions, and had zero performance on embodied transfer. In the embodied setting, without access to a TextWorld Engine, it is difficult to generate candidate actions unless a set of heuristics is handcrafted with strong priors and commonsense knowledge. We also experimented with populating a list of command templates, but found this to be infeasible as some scenarios involved 1000s of populated actions per game step.</p>
<h1>J ALFRED TASK DESCRIPTIONS</h1>
<p>The following descriptions describe the processes involved in each of six task-types:</p>
<ul>
<li>Pick \&amp; Place (e.g., "put a plate on the coffee table") - the agent must find an object of the desired type, pick it up, find the correct location to place it, and put it down there.</li>
<li>Examine in Light (e.g., "examine a book under the lamp") - the agent must find an object of the desired type, locate and turn on a light source with the desired object in-hand.</li>
<li>Clean \&amp; Place (e.g., "clean the knife and put in the drawer") - the agent must find an object of the desired type, pick it up, go to a sink or a basin, wash the object by turning on the faucet, then find the correct location to place it, and put it down there.</li>
<li>Heat \&amp; Place (e.g., "heat a mug and put on the coffee table") - the agent must find an object of the desired type, pick it up, go to a microwave, heat the object turning on the microwave, then find the correct location to place it, and put it down there.</li>
<li>Cool \&amp; Place (e.g., "put a cool bottle on the countertop") - the agent must find an object of the desired type, pick it up, go to a fridge, put the object inside the fridge and cool it, then find the correct location to place it, and put it down there.</li>
<li>Pick Two \&amp; Place (e.g., "put two pencils in the drawer") - the agent must find an object of the desired type, pick it up, find the correct location to place it, put it down there, then look for another object of the desired type, pick it up, return to previous location, and put it down there with the other object.</li>
</ul>
<h1>K ALFWorld Text Game Examples</h1>
<h2>Three examples of ALFWorld text game walkthroughs:</h2>
<div class="codehilite"><pre><span></span><code><span class="n">You</span><span class="w"> </span><span class="k">are</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">middle</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">room</span><span class="p">.</span><span class="w"> </span><span class="n">Looking</span><span class="w"> </span><span class="n">quickly</span><span class="w"> </span><span class="n">around</span><span class="w"> </span><span class="n">you</span><span class="p">,</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">see</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">towelholder</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="n">a</span><span class="w"> </span><span class="n">toilet</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">bathtubbasin</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">drawer</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">handtowelholder</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">drawer</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">drawer</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="n">a</span><span class="w"> </span><span class="n">countertop</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">sinkbasin</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">drawer</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">drawer</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">toiletpaperhanger</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">drawer</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span>
<span class="n">a</span><span class="w"> </span><span class="n">handtowelholder</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">towelholder</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">sinkbasin</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">garbagecan</span><span class="w"> </span><span class="mf">1.</span>
<span class="n">Your</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">to</span><span class="err">:</span><span class="w"> </span><span class="n">put</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">clean</span><span class="w"> </span><span class="n">cloth</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">bathtubbasin</span><span class="p">.</span>
<span class="o">&gt;</span><span class="w"> </span><span class="k">go</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">drawer</span><span class="w"> </span><span class="mi">5</span>
<span class="n">You</span><span class="w"> </span><span class="n">arrive</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="mf">9.</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">drawer</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">closed</span><span class="p">.</span>
<span class="o">&gt;</span><span class="w"> </span><span class="k">open</span><span class="w"> </span><span class="n">drawer</span><span class="w"> </span><span class="mi">5</span>
<span class="n">You</span><span class="w"> </span><span class="k">open</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">drawer</span><span class="w"> </span><span class="mf">5.</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">drawer</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">open</span><span class="p">.</span><span class="w"> </span><span class="ow">In</span><span class="w"> </span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">see</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">candle</span><span class="w"> </span><span class="mf">1.</span>
<span class="o">&gt;</span><span class="w"> </span><span class="k">close</span><span class="w"> </span><span class="n">drawer</span><span class="w"> </span><span class="mi">5</span>
<span class="n">You</span><span class="w"> </span><span class="k">close</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">drawer</span><span class="w"> </span><span class="mf">5.</span>
<span class="o">&gt;</span><span class="w"> </span><span class="k">go</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">countertop</span><span class="w"> </span><span class="mi">1</span>
<span class="n">You</span><span class="w"> </span><span class="n">arrive</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="mf">25.</span><span class="w"> </span><span class="k">On</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">countertop</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">see</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">cloth</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">soapbottle</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">cloth</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="ow">and</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">candle</span><span class="w"> </span><span class="mf">3.</span>
<span class="o">&gt;</span><span class="w"> </span><span class="n">take</span><span class="w"> </span><span class="n">cloth</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">countertop</span><span class="w"> </span><span class="mi">1</span>
<span class="n">You</span><span class="w"> </span><span class="n">pick</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">cloth</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">countertop</span><span class="w"> </span><span class="mf">1.</span>
<span class="o">&gt;</span><span class="w"> </span><span class="k">go</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">sinkbasin</span><span class="w"> </span><span class="mi">1</span>
<span class="n">You</span><span class="w"> </span><span class="n">arrive</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="mf">20.</span><span class="w"> </span><span class="k">On</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">sinkbasin</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">see</span><span class="w"> </span><span class="n">nothing</span><span class="p">.</span>
<span class="o">&gt;</span><span class="w"> </span><span class="n">clean</span><span class="w"> </span><span class="n">cloth</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">sinkbasin</span><span class="w"> </span><span class="mi">1</span>
<span class="n">You</span><span class="w"> </span><span class="n">clean</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">cloth</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">sinkbasin</span><span class="w"> </span><span class="mf">1.</span>
<span class="o">&gt;</span><span class="w"> </span><span class="k">go</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">bathtubbasin</span><span class="w"> </span><span class="mi">1</span>
<span class="n">You</span><span class="w"> </span><span class="n">arrive</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="mf">14.</span><span class="w"> </span><span class="k">On</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">bathtubbasin</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">see</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">soapbar</span><span class="w"> </span><span class="mf">1.</span>
<span class="o">&gt;</span><span class="w"> </span><span class="n">put</span><span class="w"> </span><span class="n">cloth</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">in</span><span class="o">/</span><span class="k">on</span><span class="w"> </span><span class="n">bathtubbasin</span><span class="w"> </span><span class="mi">1</span>
<span class="n">You</span><span class="w"> </span><span class="n">won</span><span class="err">!</span>
</code></pre></div>

<p>$\qquad$
You are in the middle of a room. Looking quickly around you, you see a drawer 15, a drawer 19, a drawer 7, a armchair 1, a drawer 3, a drawer 16, a drawer 2, a drawer 17, a sidetable 3, a sidetable 5, a drawer 4, a drawer 20, a sofa 1, a drawer 13, a drawer 12, a drawer 9, a drawer 21, a sidetable 4, a sidetable 2, a drawer 5, a drawer 11, a drawer 1, a garbagecan 1, a dresser 1, a cabinet 1, a drawer 8, a drawer 18, a sidetable 1, a drawer 14, a drawer 6, and a drawer 10 .</p>
<p>Your task is to: find two remotecontrol and put them in armchair.</p>
<div class="codehilite"><pre><span></span><code><span class="o">&gt;</span><span class="w"> </span><span class="k">go</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">sidetable</span><span class="w"> </span><span class="mi">2</span>
<span class="n">You</span><span class="w"> </span><span class="n">arrive</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="mf">34.</span><span class="w"> </span><span class="k">On</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">sidetable</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">see</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">remotecontrol</span><span class="w"> </span><span class="mf">1.</span>
<span class="o">&gt;</span><span class="w"> </span><span class="n">take</span><span class="w"> </span><span class="n">remotecontrol</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">sidetable</span><span class="w"> </span><span class="mi">2</span>
<span class="n">You</span><span class="w"> </span><span class="n">pick</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">remotecontrol</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">sidetable</span><span class="w"> </span><span class="mf">2.</span>
<span class="o">&gt;</span><span class="w"> </span><span class="k">go</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">armchair</span><span class="w"> </span><span class="mi">1</span>
<span class="n">You</span><span class="w"> </span><span class="n">arrive</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="mf">1.</span><span class="w"> </span><span class="k">On</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">armchair</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">see</span><span class="w"> </span><span class="n">nothing</span><span class="p">.</span>
<span class="o">&gt;</span><span class="w"> </span><span class="n">put</span><span class="w"> </span><span class="n">remotecontrol</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">in</span><span class="o">/</span><span class="k">on</span><span class="w"> </span><span class="n">armchair</span><span class="w"> </span><span class="mi">1</span>
<span class="n">You</span><span class="w"> </span><span class="n">put</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">remotecontrol</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">in</span><span class="o">/</span><span class="k">on</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">armchair</span><span class="w"> </span><span class="mf">1.</span>
<span class="o">&gt;</span><span class="w"> </span><span class="k">go</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">dresser</span><span class="w"> </span><span class="mi">1</span>
<span class="n">You</span><span class="w"> </span><span class="n">arrive</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="mf">18.</span><span class="w"> </span><span class="k">On</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">dresser</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">see</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">creditcard</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">television</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">laptop</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="n">a</span><span class="w"> </span><span class="n">book</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">statue</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">cellphone</span><span class="w"> </span><span class="mf">2.</span>
<span class="o">&gt;</span><span class="w"> </span><span class="k">go</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">sidetable</span><span class="w"> </span><span class="mi">5</span>
<span class="n">You</span><span class="w"> </span><span class="n">arrive</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="mf">17.</span><span class="w"> </span><span class="k">On</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">sidetable</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">see</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">box</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">creditcard</span><span class="w"> </span><span class="mf">2.</span>
<span class="o">&gt;</span><span class="w"> </span><span class="k">go</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">sofa</span><span class="w"> </span><span class="mi">1</span>
<span class="n">You</span><span class="w"> </span><span class="n">arrive</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="mf">2.</span><span class="w"> </span><span class="k">On</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">sofa</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">see</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">newspaper</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">pillow</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">remotecontrol</span><span class="w"> </span><span class="mf">2.</span>
<span class="o">&gt;</span><span class="w"> </span><span class="n">take</span><span class="w"> </span><span class="n">remotecontrol</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">sofa</span><span class="w"> </span><span class="mi">1</span>
<span class="n">You</span><span class="w"> </span><span class="n">pick</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">remotecontrol</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">sofa</span><span class="w"> </span><span class="mf">1.</span>
<span class="o">&gt;</span><span class="w"> </span><span class="k">go</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">armchair</span><span class="w"> </span><span class="mi">1</span>
<span class="n">You</span><span class="w"> </span><span class="n">arrive</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="mf">1.</span><span class="w"> </span><span class="k">On</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">armchair</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">see</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">remotecontrol</span><span class="w"> </span><span class="mf">1.</span>
<span class="o">&gt;</span><span class="w"> </span><span class="n">put</span><span class="w"> </span><span class="n">remotecontrol</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">in</span><span class="o">/</span><span class="k">on</span><span class="w"> </span><span class="n">armchair</span><span class="w"> </span><span class="mi">1</span>
<span class="n">You</span><span class="w"> </span><span class="n">won</span><span class="err">!</span>
</code></pre></div>

<p>$\qquad$
You are in the middle of a room. Looking quickly around you, you see a safe 1, a shelf 4, a drawer 2, a bed 1, a drawer 1, a shelf 5, a shelf 2, a sidetable 2, a shelf 3, a drawer 3, a shelf 1, a sidetable 1, a desk 1, and a garbagecan 1.</p>
<p>Your task is to: examine the alarmclock with the desklamp.</p>
<div class="codehilite"><pre><span></span><code><span class="o">&gt;</span><span class="w"> </span><span class="k">go</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">desk</span><span class="w"> </span><span class="mi">1</span>
<span class="n">You</span><span class="w"> </span><span class="n">arrive</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="mf">8.</span><span class="w"> </span><span class="k">On</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">desk</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">see</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">pen</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">bowl</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">alarmclock</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">pencil</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">pencil</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="n">a</span><span class="w"> </span><span class="n">creditcard</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">book</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">alarmclock</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">keychain</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">book</span><span class="w"> </span><span class="mf">2.</span>
<span class="o">&gt;</span><span class="w"> </span><span class="n">take</span><span class="w"> </span><span class="n">alarmclock</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">desk</span><span class="w"> </span><span class="mi">1</span>
<span class="n">You</span><span class="w"> </span><span class="n">pick</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">alarmclock</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">desk</span><span class="w"> </span><span class="mf">1.</span>
<span class="o">&gt;</span><span class="w"> </span><span class="k">go</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">sidetable</span><span class="w"> </span><span class="mi">2</span>
<span class="n">You</span><span class="w"> </span><span class="n">arrive</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="mf">1.</span><span class="w"> </span><span class="k">On</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">sidetable</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">see</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">desklamp</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">alarmclock</span><span class="w"> </span><span class="mf">1.</span>
<span class="o">&gt;</span><span class="w"> </span><span class="k">use</span><span class="w"> </span><span class="n">desklamp</span><span class="w"> </span><span class="mi">1</span>
<span class="n">You</span><span class="w"> </span><span class="n">won</span><span class="err">!</span>
</code></pre></div>

<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{4}$ For a fair comparison, all agents in Table 3 use a batch-size of 10. THOR instances use 100MB $\times$ batch-size of GPU memory for rendering, whereas TextWorld instances are CPU-only and are thus much easier to scale up.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>