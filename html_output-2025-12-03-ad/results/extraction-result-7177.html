<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-7177 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-7177</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-7177</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-135.html">extraction-schema-135</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of graph-to-text representations used to convert graphs into textual sequences for language model training, including their description, encoding method, properties, datasets, models, evaluation metrics, performance outcomes, and any reported advantages or limitations.</div>
                <p><strong>Paper ID:</strong> paper-7083181d36fa22a35a511f3eb361fa4ab312de24</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/7083181d36fa22a35a511f3eb361fa4ab312de24" target="_blank">KG-FiD: Infusing Knowledge Graph in Fusion-in-Decoder for Open-Domain Question Answering</a></p>
                <p><strong>Paper Venue:</strong> Annual Meeting of the Association for Computational Linguistics</p>
                <p><strong>Paper TL;DR:</strong> This paper introduces a knowledge-enhanced version of Fusion-in-Decoder, namely KG-FiD, which uses a knowledge graph to establish the structural relationship among the retrieved passages, and a graph neural network to re-rank the passages and select only a top few for further processing.</p>
                <p><strong>Paper Abstract:</strong> Current Open-Domain Question Answering (ODQA) models typically include a retrieving module and a reading module, where the retriever selects potentially relevant passages from open-source documents for a given question, and the reader produces an answer based on the retrieved passages. The recently proposed Fusion-in-Decoder (FiD) framework is a representative example, which is built on top of a dense passage retriever and a generative reader, achieving the state-of-the-art performance. In this paper we further improve the FiD approach by introducing a knowledge-enhanced version, namely KG-FiD. Our new model uses a knowledge graph to establish the structural relationship among the retrieved passages, and a graph neural network (GNN) to re-rank the passages and select only a top few for further processing. Our experiments on common ODQA benchmark datasets (Natural Questions and TriviaQA) demonstrate that KG-FiD can achieve comparable or better performance in answer prediction than FiD, with less than 40% of the computation cost.</p>
                <p><strong>Cost:</strong> 0.009</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e7177.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e7177.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of graph-to-text representations used to convert graphs into textual sequences for language model training, including their description, encoding method, properties, datasets, models, evaluation metrics, performance outcomes, and any reported advantages or limitations.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>UniK-QA</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Unified open-domain question answering with structured and unstructured knowledge</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A prior method that serializes knowledge-graph triplets into natural-language sentences and appends them to the text corpus so that standard text retrievers/models can access KG facts as plain text; noted in this paper as losing KG structural information.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Unified open-domain question answering with structured and unstructured knowledge</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>KG triplet sentence serialization</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Each knowledge-graph triplet (head, relation, tail) is converted into a standalone natural-language sentence and combined into the textual corpus used for retrieval and language-model training; no special graph markers or canonical structural encoding are reported in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>representation_type</strong></td>
                            <td>lossy; sequential; token-based</td>
                        </tr>
                        <tr>
                            <td><strong>encoding_method</strong></td>
                            <td>triplet-to-sentence verbalization (KG triplets → individual text sentences); exact verbalization/template algorithm not specified in this paper</td>
                        </tr>
                        <tr>
                            <td><strong>canonicalization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>average_token_length</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>dataset_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>KG verbalization for building a combined text retrieval corpus / retrieval-augmented QA</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_value</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>impact_on_training</strong></td>
                            <td>Provides additional textual training/retrieval data derived from KG facts but (as reported here) discards explicit graph structure; the paper notes this as a limitation rather than reporting quantitative training impacts.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations</strong></td>
                            <td>Reported to lose structure information of the knowledge graph (i.e., relational/graph topology is not preserved when triplets are flattened into sentences).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other</strong></td>
                            <td>Compared in this paper as a contrastive approach: UniK-QA flattens KG triplets into text (losing structure), whereas the KG‑FiD approach retains and exploits KG-derived passage relationships via graph models (GNN reranking) to preserve structural information for reranking and filtering.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'KG-FiD: Infusing Knowledge Graph in Fusion-in-Decoder for Open-Domain Question Answering', 'publication_date_yy_mm': '2021-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Unified open-domain question answering with structured and unstructured knowledge <em>(Rating: 2)</em></li>
                <li>Learning to retrieve reasoning paths over wikipedia graph for question answering <em>(Rating: 1)</em></li>
                <li>Knowledge guided text retrieval and reading for open domain question answering <em>(Rating: 1)</em></li>
                <li>Knowledge-aided open-domain question answering <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-7177",
    "paper_id": "paper-7083181d36fa22a35a511f3eb361fa4ab312de24",
    "extraction_schema_id": "extraction-schema-135",
    "extracted_data": [
        {
            "name_short": "UniK-QA",
            "name_full": "Unified open-domain question answering with structured and unstructured knowledge",
            "brief_description": "A prior method that serializes knowledge-graph triplets into natural-language sentences and appends them to the text corpus so that standard text retrievers/models can access KG facts as plain text; noted in this paper as losing KG structural information.",
            "citation_title": "Unified open-domain question answering with structured and unstructured knowledge",
            "mention_or_use": "mention",
            "representation_name": "KG triplet sentence serialization",
            "representation_description": "Each knowledge-graph triplet (head, relation, tail) is converted into a standalone natural-language sentence and combined into the textual corpus used for retrieval and language-model training; no special graph markers or canonical structural encoding are reported in this paper.",
            "representation_type": "lossy; sequential; token-based",
            "encoding_method": "triplet-to-sentence verbalization (KG triplets → individual text sentences); exact verbalization/template algorithm not specified in this paper",
            "canonicalization": null,
            "average_token_length": null,
            "dataset_name": null,
            "task_name": "KG verbalization for building a combined text retrieval corpus / retrieval-augmented QA",
            "model_name": null,
            "model_description": null,
            "performance_metric": null,
            "performance_value": null,
            "impact_on_training": "Provides additional textual training/retrieval data derived from KG facts but (as reported here) discards explicit graph structure; the paper notes this as a limitation rather than reporting quantitative training impacts.",
            "limitations": "Reported to lose structure information of the knowledge graph (i.e., relational/graph topology is not preserved when triplets are flattened into sentences).",
            "comparison_with_other": "Compared in this paper as a contrastive approach: UniK-QA flattens KG triplets into text (losing structure), whereas the KG‑FiD approach retains and exploits KG-derived passage relationships via graph models (GNN reranking) to preserve structural information for reranking and filtering.",
            "uuid": "e7177.0",
            "source_info": {
                "paper_title": "KG-FiD: Infusing Knowledge Graph in Fusion-in-Decoder for Open-Domain Question Answering",
                "publication_date_yy_mm": "2021-10"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Unified open-domain question answering with structured and unstructured knowledge",
            "rating": 2
        },
        {
            "paper_title": "Learning to retrieve reasoning paths over wikipedia graph for question answering",
            "rating": 1
        },
        {
            "paper_title": "Knowledge guided text retrieval and reading for open domain question answering",
            "rating": 1
        },
        {
            "paper_title": "Knowledge-aided open-domain question answering",
            "rating": 1
        }
    ],
    "cost": 0.009323999999999999,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>KG-FiD: Infusing Knowledge Graph in Fusion-in-Decoder for Open-Domain Question Answering</h1>
<p>Donghan $\mathbf{Y u}^{1 <em>}$, Chenguang $\mathbf{Z h u}^{2}$, Yuwei Fang ${ }^{2}$, Wenhao $\mathbf{Y u}^{3 </em>}$, Shuohang Wang ${ }^{2}$, Yichong $\mathbf{X u}^{2}$, Xiang Ren ${ }^{4}$, Yiming Yang ${ }^{1}$, Michael Zeng ${ }^{2}$<br>${ }^{1}$ Carnegie Mellon University ${ }^{2}$ Microsoft Cognitive Services Research Group<br>${ }^{3}$ University of Notre Dame ${ }^{4}$ University of Southern California<br>${ }^{1}$ dyu2@cs.cmu.edu, ${ }^{2}$ chezhu@microsoft.com</p>
<h4>Abstract</h4>
<p>Current Open-Domain Question Answering (ODQA) models typically include a retrieving module and a reading module, where the retriever selects potentially relevant passages from open-source documents for a given question, and the reader produces an answer based on the retrieved passages. The recently proposed Fusion-in-Decoder (FiD) framework is a representative example, which is built on top of a dense passage retriever and a generative reader, achieving the state-of-the-art performance. In this paper we further improve the FiD approach by introducing a knowledgeenhanced version, namely KG-FiD. Our new model uses a knowledge graph to establish the structural relationship among the retrieved passages, and a graph neural network (GNN) to re-rank the passages and select only a top few for further processing. Our experiments on common ODQA benchmark datasets (Natural Questions and TriviaQA) demonstrate that KG-FiD can achieve comparable or better performance in answer prediction than FiD, with less than $40 \%$ of the computation cost.</p>
<h2>1 Introduction</h2>
<p>Open-Domain Question Answering (ODQA) is the task of answering natural language questions in open domains. A successful ODQA model relies on effective acquisition of world knowledge. A popular line of work treats a large collection of open-domain documents (such as Wikipedia articles) as the knowledge source, and design a ODQA system that consists of a retrieving module and a reading module. The retriever pulls out a small set of potentially relevant passages from the opensource documents for a given question, and the reader produces an answer based on the retrieved passages (Karpukhin et al., 2020; Guu et al., 2020; Izacard and Grave, 2020). An earlier example of this kind is DrQA (Chen et al., 2017), which used</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup>an traditional search engine based on the bag of words (BoW) document representation with TFIDF term weighting, and a neural reader for extracting candidate answers for each query based on the dense embedding of the retrieved passages. With the successful development of Pre-trained Language Models (PLMs) in neural network research, dense embedding based passage retrieval (DPR) models (Karpukhin et al., 2020; Qu et al., 2021) have shown superior performance over BoW/TFIDF based retrieval models due to utilization of contextualized word embedding in DPR, and generative QA readers (Lewis et al., 2020; Roberts et al., 2020) usually outperform extraction based readers (Devlin et al., 2019; Guu et al., 2020) due to the capability of the former in capturing lexical variants with a richer flexibility.</p>
<p>The recently proposed Fusion-in-Decoder (FiD) model (Izacard and Grave, 2021) is representative of those methods with a DPR retriever and a generative reader, achieving the state-of-the-art results on ODQA evaluation benchmarks. FiD also significantly improved the scalability of the system over previous generative methods by encoding the retrieved passages independently instead of encoding the concatenation of all retrieved passages (which was typical in previous methods).</p>
<p>Inspired by the success of FiD, this paper aims further improvements of the state of the art of ODQA in the paradigm with a DPR retriever and a generative reader. Specifically, we point out two potential weaknesses or limitations of FiD as the rooms for improvements, and we propose a novel solution namely KG-FiD to address these issues with FiD. The two issues are:</p>
<p>Issue 1. The independent assumption among passages is not justified. Notice that both the DPR retriever and the generative reader of FiD perform independent encoding of the retrieved passages, which means that they cannot leverage the semantic relationship among passages for passage</p>
<p>embedding and answer generation even if such relational knowledge is available. But we know that rich semantic connections between passages often provide clues for better answering questions (Min et al., 2019).</p>
<p>Issue 2. Efficiency Bottleneck. For each input question, the FiD generative reader receives about 100 passages from the DPR module, with a relatively high computational cost. For example, the inference per question takes more than 6 trillion floating-point operations. Simply reducing the number of retrieved passages sent to the reader will not be a good solution as it will significantly decrease the model performance (Izacard and Grave, 2021). How to overcome such inefficient computation issue is a challenging question for the success of FiD in realistic ODQA settings.</p>
<p>We propose to address both of the above issues with FiD by leveraging an existing knowledge graph (KG) to establish relational dependencies among retrieved passages, and employing Graph Neural Networks (GNNs) to re-rank and prune retrieved passages for each query. We name our new approach as KG-FiD.</p>
<p>Specifically, KG-FiD employs a two-stage passage reranking by applying GNN to model structural and semantic information of passages. Both stages rerank the input passages and only a few top-reranked passages are fed into subsequent modules. The first stage reranks passages returned by the retriever, where we use the passage embeddings generated by DPR as the initial GNN node representation. This allows reranking a much larger set of initial candidate passages to enhance coverage of answers. The second stage performs joint passage reranking and answer generation, where the node embeddings are initialized by the embeddings of passage-question pairs output from the reader encoder. This stage operates on a smaller candidate set but aims for more accurate reranking and passage pruning.</p>
<p>To improve the efficiency, in the second-stage reranking, our GNN model adopts representations from the intermediate layer in the reader encoder instead of the final layer to initiate passage node embeddings. Then only a few top reranked passages will be passed into the higher layers of encoder and the decoder for answer generation, while other passages will not be further processed. This is coupled with a joint training of passage reranking and answer generation. As shown in Section 4.3, these
strategies significantly reduce the computation cost while still maintaining a good QA performance.</p>
<p>Our experiments on ODQA benchmark datasets Natural Questions and TriviaQA demonstrate that KG-FiD can achieve comparable or better performance in answer prediction than FiD, with only $40 \%$ of the computation cost of FiD.</p>
<h2>2 Related Work</h2>
<p>ODQA with text corpus ODQA usually assumes that a large external knowledge source is accessible and can be leveraged to help answer prediction. For example, previous works (Chen et al., 2017; Karpukhin et al., 2020; Izacard and Grave, 2021) mainly use Wikipedia as knowledge source which contains millions of text passages. In this case, current ODQA models mainly contains a retriever to select related passages and a reader to generate the answer. Thus, the follow-up works mainly aim to: (1) Improve the retriever: from sparse retrieval based on TF-IDF or BM25 (Chen et al., 2017; Yang et al., 2019) to dense retrieval (Karpukhin et al., 2020) based on contextualized embeddings generated by pre-trained language models (PLMs). Moreover, some further improvement are also proposed such as better training strategy (Qu et al., 2021), reranking based on retrieved passages (Wang et al., 2018; Nogueira and Cho, 2019; Mao et al., 2021), and knowledge distillation from reader to retriever (Izacard and Grave, 2020); (2) Improve the reader: changing from Recurrent Neural Network (Chen et al., 2017) to PLMs such as extractive reader BERT (Karpukhin et al., 2020; Iyer et al., 2021; Guu et al., 2020) and generative reader BART and T5 (Izacard and Grave, 2021; Lewis et al., 2020). Besides, some works (Guu et al., 2020; Lewis et al., 2020; Sachan et al., 2021) have shown that additional unsupervised pre-training on retrieval-related language modeling tasks can further improve ODQA performance. However, none of these methods modeled the relationships among different passages.</p>
<p>ODQA with knowledge graph Besides the unstructured text corpus, world knowledge also exists in knowledge graphs (KGs), which represent entities and relations in a structural way and have been used in a variety of NLP tasks (Xu et al., 2021b; Yu et al., 2020; Xu et al., 2021a). Some works (Berant et al., 2013; Sun et al., 2018, 2019; Xiong et al., 2019) restrict the answer to be entities in the knowledge graph, while our work focus on more general</p>
<p>ODQA setting where the answer can be any words or phrases. Under this setting, some recent efforts have been made to leverage knowledge graphs for ODQA (Min et al., 2019; Asai et al., 2020; Zhou et al., 2020). For example, UniK-QA (Oguz et al., 2020) transforms KG triplets into text sentences and combine them into text corpus, which loses structure information of KG. Other works use KG to build relationship among passages similar to ours. KAQA (Zhou et al., 2020) use passage graph to propagate passage retrieve scores and answer span scores. Graph-Retriever (Min et al., 2019) iteratively retrieve passages based on the relationship between passages, and also use passage graph to improve passage selection in an extractive reader. However, applying KG to improve the recent advanced FiD framework remains unstudied.</p>
<h2>3 Method</h2>
<p>In the following sections, we first introduce how to apply KG to build a graph structure among the retrieved passages (Section 3.1). Then we show how we adopt the graph-based stage-1 reranking with DPR retriever to improve passage retrieval (Section 3.2). Next we introduce joint stage-2 reranking and answer generation in the reading module (Section 3.3). Finally we illustrate the improvement of efficiency by using intermediate layer representation for stage-2 reranking (Section 3.4). The overview of our framework is illustrated in Figure 1.</p>
<h3>3.1 Construct Passage Graph using KG</h3>
<p>The intuition behind using KG is that there exists the structural relationship among the retrieved passages which can be captured by the KG. Similar to (Min et al., 2019), we construct the passage graph where vertices are passages of text and the edges represent the relationships that are derived from the external KGs as $\mathcal{K G}=\left{\left(e_{h}, r, e_{t}\right)\right}$, where $e_{h}, r, e_{t}$ are the head entity, relation and tail entity of a triplet respectively.</p>
<p>First, we formalize the definition of a passage. Following previous works (Wang et al., 2019; Karpukhin et al., 2020), each article in the text corpus is split into multiple disjoint text blocks of 100 words called passages, which serve as the basic retrieval units. We assume there is a oneone mapping between the KG entities and articles in the text corpus. Specifically, we use English Wikipedia as the text corpus and English Wikidata (Vrandečić and Krötzsch, 2014) as the knowl-
edge graph, since there exists an alignment between the two resources ${ }^{1}$. For example, for the article titled with "New York Yankees", it contains passages such as "The New York Yankees are an American professional baseball team ...". The article also corresponds to a KG entity with the same name as "New York Yankees".</p>
<p>Then we define the mapping function $e=f(p)$, where the KG entity $e$ corresponds to the article which $p$ belongs to. Note that one passage can only be mapped to one entity, but multiple passages could be mapped to the same entity. The final passage graph is defined as $\mathcal{G}=\left{\left(p_{i}, p_{j}\right)\right}$, where passages $p_{i}$ and $p_{j}$ are connected if and only if their mapped entities are directly connected in the KG, i.e., $\left(f\left(p_{i}\right), r, f\left(p_{j}\right)\right) \in \mathcal{K G}$.</p>
<p>Since the total number of passages is very large, e.g., more than 20 M in Wikipedia, constructing and maintaining a graph over all the passages is inefficient and memory-consuming. Thus, we build a passage graph on the fly for each question, based on the retrieved passages.</p>
<h3>3.2 Passage Retrieving \&amp; Stage-1 Reranking</h3>
<p>DPR Retriever: Our framework applies DPR (Karpukhin et al., 2020) as the retriever, which uses a BERT based passage encoder to encode all the $N$ passages in the text corpus $\left{p_{1}, p_{2}, \cdots, p_{N}\right}$. Suppose all the passage embeddings are fixed and stored in memory as $M \in \mathbb{R}^{N \times D}$ where $D$ is the hidden dimension:</p>
<p>$$
M_{i}=\operatorname{BERT}\left(p_{i}\right) \text { for } i \in{1,2, \cdots N}
$$</p>
<p>For an input question $q$, DPR applies another BERTbased question encoder to obtain its representation $Q$, then it builds on FAISS (Johnson et al., 2019) to conduct fast dot-product similarity search between $Q$ and $M$, and returns $N_{1}\left(N_{1} \ll N\right)$ passages with the highest similarity scores.</p>
<p>Stage-1 Reranking: We see that the DPR retriever returns $N_{1}$ passages which are independently retrieved based on the similarity between the question and each passage, without considering inter-passage relationship. Thus instead of directly retrieving $N_{1}$ passages for the reader, we propose to first retrieve $N_{0}\left(N_{0}&gt;N_{1}\right)$ passages, then rerank them and output top- $N_{1}$ reranked passages into the reader.</p>
<p>Following Section 3.1, we construct a graph among the $N_{0}$ retrieved passages denoted as $\mathcal{G}_{0}$.</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Overall Model Framework. P<em>i</em> indicates the node of the passage originally ranked the <em>i</em>-th by the DPR retriever, with the article title below it. The left part shows passage retrieval by DPR, passage graph construction based on KG (Section 3.1) and stage-1 reranking (Section 3.2). The right part shows joint stage-2 reranking and answer generation in the reading module (Section 3.3 and 3.4).</p>
<p>We aim to rerank the retrieved passages based on both the structural information and the textual semantic information of them.</p>
<p>To represent the semantic information of passages, one can use another pre-trained language model to encode the passage texts, but this will not only include lots of additional model parameters, but also incur heavy computational cost as <em>N</em><sub>0</sub> can be large. To avoid both additional memory and computation cost, we propose to reuse the offline passage embeddings <em>M</em> generated from the DPR retriever in Equation 1 as the initial node representation: <em>E</em><sub><em>i</em></sub><sup>(0)</sup> = <em>M</em><sub><em>r<sub>i</sub></sub> where {</em>r<sub>i</sub><em>|</em>i<em> ∈ {1, 2, ..., </em>N*<sub>0</sub>}} is the set of retrieved passage indices.</p>
<p>Then we employ a graph attention network (GAT) Velickovic2018 with <em>L</em><sub><em>g</em></sub> layers as GNN model to update representations for each node based on the passage graph and initial representation. The <em>l</em>-th layer of the GNN model updates the embedding of node <em>i</em> as follows:</p>
<p>$$E_i^{(l)} = h(E_i^{(l-1)},{E_j^{(l-1)}}_{(i,j) \in G_0}) \tag{2}$$</p>
<p>where <em>h</em> is usually a non-linear learnable function which aggregates the embeddings of the node itself and its neighbor nodes. The reranking score for each passage <em>p</em><sub><em>r<sub>i</sub></sub> is calculated by </em>s<em><sub></em>i<em></sub><sup>stage-1</sup> = </em>Q<em><sup></em>T<em></sup></em>E<em><sub></em>i<em></sub><sup>(</em>L<em><sub></em>g<em></sub>)<sup>i</sup>, where </em>Q<em> is the question embedding also generated by the DPR retriever. Then we sort the retrieved passages by the reranking scores, and input the top-</em>N*<sub>1</sub> passages into the reader. The training loss of passage ranking for each question is:</p>
<p>$$\mathcal{L}<em i="1">{i}^{\text{stage-1}} = -\sum</em>$$}^{N_0} y_i \log \left( \frac{\exp(s_{i}^{\text{stage-1}})}{\sum_{j=1}^{N_0} \exp(s_{j}^{\text{stage-1}})} \right) \tag{3</p>
<p>where <em>y</em><sub><em>i</em></sub> = 1 if <em>p</em><sub>*r<sub>i</sub></sub> is the gold passage<sup>2</sup> that contains the answer, and 0 otherwise.</p>
<p>As we only add a lightweight graph neural network and reuse the pre-computed and static DPR passage embeddings, our reranking module can process a large number of candidate passages efficiently for each question. In experiments, we set <em>N</em><sub>0</sub> = 1000 and <em>N</em><sub>1</sub> = 100.</p>
<h3>3.3 Joint Stage-2 Reranking and Answer Generation</h3>
<p>In this section, we briefly introduce the vanilla FiD reading module before illustrating our joint</p>
<p><sup>2</sup>We follow Karpukhin et al. (2020) on the definition of gold passages.</p>
<p>reranking method. We suppose the reader takes $N_{1}$ retrieved passages $\left{p_{a_{1}}, p_{a_{2}}, \cdots, p_{a_{N_{1}}}\right}$ as input.</p>
<p>Vanilla FiD Reading Module: We denote the hidden dimension as $H$ and number of encoder layers and decoder layers as $L$, FiD reader first separately encodes each passage $p_{a_{i}}$ concatenated with question $q$ :</p>
<p>$$
\begin{aligned}
&amp; \mathbf{P}<em a__i="a_{i">{i}^{(0)}=\mathrm{T} 5-\operatorname{Embed}\left(q+p</em> \
&amp; \mathbf{P}}}\right) \in \mathbb{R}^{T_{p} \times H<em l="l">{i}^{(l)}=\mathrm{T} 5-\operatorname{Encoder}</em>}\left(\mathbf{P<em p="p">{i}^{(l-1)}\right) \in \mathbb{R}^{T</em>
\end{aligned}
$$} \times H</p>
<p>where $T_{p}$ is the sequence length of a passage concatenated with the question. T5-Embed $(\cdot)$ is the initial embedding layer of T5 model (Raffel et al., 2019) and T5-Encoder ${ }_{l}(\cdot)$ is the $l$-th layer of its encoder module. Then the token embeddings of all passages output from the last layer of the encoder are concatenated and sent to the decoder to generate the answer tokens $\mathbf{A}$ :</p>
<p>$$
\mathbf{A}=\mathrm{T} 5 \text {-Decoder }\left(\left|\mathbf{P}<em 2="2">{1}^{(L)} ; \mathbf{P}</em>}^{(L)} ; \cdots ; \mathbf{P<em 1="1">{N</em>\right|\right)
$$}}^{(L)</p>
<p>Stage-2 Reranking: Note that vanilla FiD reader neglect the cross information among passages, and the joint modeling in the decoding process makes it vulnerable to the noisy irrelevant passages. Thus, we propose to leverage the passage graph to rerank the input $N_{1}$ passages during the encoding and only select top- $N_{2}\left(N_{2}&lt;N_{1}\right)$ reranked passages into the decoder, which is named as stage-2 reranking.</p>
<p>Similar to stage-1 reranking, the reranking model is based on both the structural information and the textual semantic information of passages. We denote the passage graph as $\mathcal{G}<em 0="0">{1}$, which is a subgraph of $\mathcal{G}</em>}$. To avoid additional computation and memory cost, we propose to reuse the encodergenerated question-aware passage representation from FiD reader for passage reranking as it is already computed in Equation 5. Specifically, the initial node embeddings $Z_{i}^{(0)}$ for passage $p_{a_{i}}$ comes from the first token embedding of the final layer in the FiD-Encoder, i.e., $Z_{i}^{(0)}=\mathbf{P<em g="g">{i}^{(L)}(0) \in \mathbb{R}^{D}$. Then same as stage-1 reranking, we also employ a GAT (Velickovic et al., 2018) with $L</em>}$ layers as the graph neural network (GNN) model to update representations for each node based on the passage graph, similar to Equation 2: $Z^{\left(L_{g}\right)}=\operatorname{GAT}\left(Z^{(0)}, \mathcal{G<em a__i="a_{i">{1}^{i}\right)$. The reranking score of passage $p</em>$ where $W$ is a trainable model parameter. After reranking, only the final
top- $N_{2}\left(N_{2}&lt;N_{1}\right)$ passages are sent for decoding. Suppose their indices are $\left{g_{1}, g_{2}, \cdots, g_{N_{2}}\right}$, the decoding process in Equation 6 becomes:}}$ is calculated by $s_{i}^{\text {stage-2 }}=W^{T} Z_{i}^{\left(L_{g}\right)</p>
<p>$$
\mathbf{A}=\mathrm{T} 5 \text {-Decoder }\left(\left|\mathbf{P}<em 1="1">{g</em>}}^{(L)} ; \mathbf{P<em 2="2">{g</em>}}^{(L)} ; \cdots ; \mathbf{P<em N__2="N_{2">{g</em>\right|\right)
$$}}}^{(L)</p>
<p>where $\mathbf{A}$ is the generated answer. Similar to stage-1 reranking, the training loss of passage ranking for each question is:</p>
<p>$$
\mathcal{L}<em i="1">{r}^{\text {stage-2 }}=-\sum</em>\right)
$$}^{N_{1}} y_{i} \log \left(\frac{\exp \left(s_{i}^{\text {stage-2 }}\right)}{\sum_{j=1}^{N_{1}} \exp \left(s_{j}^{\text {stage-2 }}\right)</p>
<p>where $y_{i}=1$ if $p_{a_{i}}$ is the gold passage that contains the answer, and 0 otherwise.</p>
<p>The passage reranking and answer generation are jointly trained. We denote the answer generation loss for each question is $\mathcal{L}<em a="a">{a}$, then the final training loss of our reader module is $\mathcal{L}=\mathcal{L}</em>$, where $\lambda$ is a hyper-parameter which controls the weight of reranking task in the total loss.}+\lambda \mathcal{L}_{r}^{\text {stage-2 }</p>
<p>Note that the first stage reranking is based on DPR embeddings, which are are high-level (one vector per passage) and not further trained. While the second stage is based on reader-generated passage-question embeddings, which are semanticlevel and trainable as part of the model output. Thus the second stage can better capture semantic information of passages and aims for more accurate reranking over a smaller candidate set. In the experiment, we set $N_{1}=100$ and $N_{2}=20$.</p>
<h3>3.4 Improving Efficiency via Intermediate Representation in Stage-2 Reranking</h3>
<p>Recall that in the stage-2 reranking, we take the passage representation from the last layer of reader encoder for passage reranking. In this section, we propose to further reduce the computation cost by taking the intermediate layer representation rather than the last layer. The intuition is that answer generation task is more difficult than passage reranking which only needs to predict whether the passage contains the answer or not. Thus we may not need the representation from the whole encoder module for passage reranking.</p>
<p>Suppose we take the representation from the $L_{1}$ th layer $\left(1 \leq L_{1}&lt;L\right)$, i.e., $Z_{i}^{(0)}=\mathbf{P}<em 1="1">{i}^{\left(L</em>\right)$ reranked passages will go through the rest layers of FiD-encoder. Suppose their indices are}\right)}(0)$ for $i \in\left{1,2, \cdots, N_{1}\right}$, and the reranking method remains the same. Then only the top $N_{2}\left(N_{2}&lt;N_{1</p>
<p>$I_{g}=\left{g_{1}, g_{2}, \cdots, g_{N_{2}}\right}$, for $l \geq L_{1}+1:$</p>
<p>$$
\mathbf{P}<em l="l">{i}^{(l)}= \begin{cases}\text { T5-Encoder }</em>}\left(\mathbf{P<em g="g">{i}^{(l-1)}\right) &amp; \text { if } i \in I</em>
$$} \ \text { Stop-Computing } &amp; \text { else }\end{cases</p>
<p>Then $\mathbf{P}<em 1="1">{g</em>}}^{(L)}, \mathbf{P<em 2="2">{g</em>}}^{(L)}, \cdots, \mathbf{P<em N__2="N_{2">{g</em>$ are sent into the decoder for answer generation as in Equation 7. In Section 4.3, we demonstrate this can reduce $60 \%$ computation cost than the original FiD while keeping the on-par performance on two benchmark datasets.}}}^{(L)</p>
<h3>3.5 Analysis on Computational Complexity</h3>
<p>Here we analyze the theoretical time complexity of our proposed KG-FiD compared to vanilla FiD. More practical computation cost comparison is shown in Appendix A.5. Because both the computations of DPR retrieving and stage-1 reranking are negligible compared to the reading part, we only analyze the reading module here.</p>
<p>Suppose the length of answer sequence $\mathbf{A}$ is denoted as $T_{a}$ and the average length of the passage (concatenated with question) is $T_{p}$. For vanilla FiD reader, the time complexity of the encoder module is $O\left(L \cdot N_{1} \cdot T_{p}^{2}\right)$, where $L, N_{1}$ denote the number of encoder layers and the number of passages for reading. The square comes from the self-attention mechanism. The decoder time complexity is $O\left(L \cdot\left(N_{1} \cdot T_{p} \cdot T_{a}+T_{a}^{2}\right)\right)$, where $N_{1} \cdot T_{p} \cdot T_{a}$ comes from the cross-attention mechanism. For our reading module, all the $N_{1}$ candidate passages are processed by the first $L_{1}$ layers of encoder. But only $N_{2}$ passages are processed by the remaining $L-L_{1}$ encoder layers and sent into the decoder. Thus, the encoder computation complexity becomes $O\left(\left(L_{1} \cdot N_{1}+\left(L-L_{1}\right) \cdot N_{2}\right) \cdot T_{p}^{2}\right)$, and the decoder computation takes $O\left(L \cdot\left(N_{2} \cdot T_{p} \cdot T_{a}+T_{a}^{2}\right)\right)$. Because $L_{1}&lt;L, N_{2}&lt;N_{1}$, both the encoding and decoding of our method is more efficient than vanilla FiD.</p>
<p>Furthermore, the answer is usually much shorter than the passage (which is the case in our experiments), i.e., $T_{a} \ll T_{p}$. Then the decoding computation can be negligible compared to the encoding. In this case, the approximated ratio of saved computation cost brought by our proposed method is:</p>
<p>$$
\begin{aligned}
S &amp; =1-\frac{\left(L_{1} \cdot N_{1}+\left(L-L_{1}\right) \cdot N_{2}\right) \cdot T_{p}^{2}}{L \cdot N_{1} \cdot T_{p}^{2}} \
&amp; =\left(1-\frac{L_{1}}{L}\right)\left(1-\frac{N_{2}}{N_{1}}\right)
\end{aligned}
$$</p>
<p>This shows that we can reduce more computation cost by decreasing $L_{1}$ or $N_{2}$. For example, if setting $L_{1}=L / 4, N_{2}=N_{1} / 5$, we can reduce about $60 \%$ of computation cost. More empirical results and discussions will be presented in Section 4.3.</p>
<h2>4 Experiment</h2>
<p>In this section, we conduct extensive experiments on two most commonly-used ODQA benchmark datasets: Natural Questions (NQ) (Kwiatkowski et al., 2019) which is based on Google Search Queries, and TriviaQA (Joshi et al., 2017) which contains questions from trivia and quiz-league websites. We follow the same setting as (Izacard and Grave, 2021) to preprocess these datasets, which is introduced in Appendix A.1. All our experiments are conducted on 8 Tesla A100 40GB GPUs.</p>
<h3>4.1 Implementation Details</h3>
<p>Knowledge Source: Following (Karpukhin et al., 2020; Izacard and Grave, 2021), we use the English Wikipedia as the text corpus, and apply the same preprocessing to divide them into disjoint passages with 100 words, which produces 21 M passages in total. For the knowledge graph, we use English Wikidata. The number of aligned entities, relations and triplets among these entities are 2.7M, 974 and 14 M respectively.</p>
<p>Model Details: For the retrieving module, we use the DPR retriever (Karpukhin et al., 2020) which contains two BERT (base) models for encoding question and passage separately. For the GNN reranking models, we adopt 3-layer Graph Attention Networks (GAT) (Velickovic et al., 2018). For the reading module, same as (Izacard and Grave, 2021), we initialize it with the pretrained T5-base and T5-large models (Raffel et al., 2019), and we name the former one as KG-FiD (base) and the latter one as KG-FiD (large). Our implementation is based on the HuggingFace Transformers library (Wolf et al., 2019). For number of passages, we set $N_{0}=1000, N_{1}=100, N_{2}=20$. The training process of our method is introduced in Appendix A.3. More results about model design and hyper-parameter search is in Appendix A.4.</p>
<p>Evaluation: We follow the standard evaluation metric of answer prediction in ODQA, which is the exact match score (EM) (Rajpurkar et al., 2016). A generated answer is considered correct if it matches any answer in the list of acceptable answers after</p>
<p>normalization ${ }^{3}$. For all the experiments, we conduct 5 runs with different random seeds and report the averaged scores.</p>
<h3>4.2 Baseline Methods</h3>
<p>We mainly compare KG-FiD with the baseline model FiD (Izacard and Grave, 2021). For other baselines, we compare with representative methods from each category: (1) not using external knowledge source: T5 (Roberts et al., 2020) and GPT-3 (Brown et al., 2020); (2) reranking-based methods: RIDER (Mao et al., 2021) and RECONSIDER (Iyer et al., 2021); (3) leveraging knowledge graphs or graph information between passages: Graph-Retriever (Min et al., 2019), PathRetriever (Asai et al., 2020), KAQA (Zhou et al., 2020), and UniK-QA (Oguz et al., 2020). We also compare with methods (4) with additional largescale pre-training: REALM (Guu et al., 2020), RAG (Lewis et al., 2020) and Joint Top-K (Sachan et al., 2021).</p>
<h3>4.3 Main Results</h3>
<p>Comparison with Baselines: Table 1 shows the results of our method and all baselines. We see that our proposed model KG-FiD consistently and significantly improves FiD on both NQ and TriviaQA datasets over both base and large model. Specifically, for large model, KG-FiD improves FiD by $1.5 \%$ and $1.1 \%$ on two datasets respectively, which has larger improvement compared to base model. We think the reason is that more expressive reader will also benefit the stage-2 reranking since the initial passage embeddings are generated by the reader encoder module. We also see that our proposed method outperforms all the baseline methods except UniK-QA (Oguz et al., 2020). However, UniK-QA uses additional knowledge source Wikipedia-Table for retrieval, which is highly related with the NQ dataset and makes it unfair to directly compare with our method.</p>
<p>Efficiency \&amp; Accuracy: Table 2 show the detailed comparison between our method and FiD in the large model version. The results of base model version is shown in Appendix A.4. Besides EM score, we also report the ratio of computation flops (#FLOPs) and inference latency (per question). The detailed calculation of #FLOPs is shown in Appendix A.5. From table 2, we see</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup>Table 1: Exact match score of different models over the test sets of NQ and TriviaQA datasets. $\star$ means that additional knowledge source Wikipedia-Tables is used in this method.
that (1) for KG-FiD, decreasing $L_{1}$ can improve the computation efficiency as analyzed in Section 3.4, while increasing $L_{1}$ can improve the model performance. We think the performance improvement comes from the noise reduction of passage filtering. For a larger $L_{1}$, the passage embeddings for reranking will have a better quality so that the gold passages are less likely to be filtered out. (2) Simply reducing the number of passages $N_{1}$ into vanilla FiD reader can reduce computation cost, but the performance will also drop significantly (from 51.9 to 50.3 on NQ dataset). (3) Our model can achieve the performance on par with FiD with only $38 \%$ of computation cost. When consuming the same amount of computations ( $L_{1}=24$ ), our model significantly outperforms FiD on both NQ and TriviaQA datasets. These experiments demonstrate that our model is very flexible and can improve both the efficiency and effectiveness by changing $L_{1}$.</p>
<h3>4.4 Ablation Study</h3>
<p>Effect of Each Reranking Stage: Since our proposed graph-based reranking method are applied in both retrieving stage (Section 3.2) and reading stage (Section 3.3). We conduct ablation study</p>
<table>
<thead>
<tr>
<th>Model</th>
<th>#FLOPs</th>
<th>NQ</th>
<th></th>
<th>TriviaQA</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>EM</td>
<td>Latency (s)</td>
<td>EM</td>
<td>Latency (s)</td>
</tr>
<tr>
<td>FiD $\left(\mathrm{N}_{1}=40\right)$</td>
<td>0.40 x</td>
<td>50.3</td>
<td>$0.74(0.45 \mathrm{x})$</td>
<td>67.5</td>
<td>$0.73(0.44 \mathrm{x})$</td>
</tr>
<tr>
<td>FiD $\left(\mathrm{N}_{1}=100\right)$</td>
<td>1.00 x</td>
<td>51.9</td>
<td>$1.65(1.00 \mathrm{x})$</td>
<td>68.7</td>
<td>$1.66(1.00 \mathrm{x})$</td>
</tr>
<tr>
<td>KG-FiD $\left(\mathrm{N}<em 1="1">{1}=100, \mathrm{~L}</em>=6\right)$</td>
<td>0.38 x</td>
<td>52.0</td>
<td>$0.70(0.42 \mathrm{x})$</td>
<td>68.9</td>
<td>$0.68(0.41 \mathrm{x})$</td>
</tr>
<tr>
<td>KG-FiD $\left(\mathrm{N}<em 1="1">{1}=100, \mathrm{~L}</em>=12\right)$</td>
<td>0.55 x</td>
<td>52.3</td>
<td>$0.96(0.58 \mathrm{x})$</td>
<td>69.2</td>
<td>$0.94(0.57 \mathrm{x})$</td>
</tr>
<tr>
<td>KG-FiD $\left(\mathrm{N}<em 1="1">{1}=100, \mathrm{~L}</em>=18\right)$</td>
<td>0.72 x</td>
<td>52.6</td>
<td>$1.22(0.74 \mathrm{x})$</td>
<td>69.8</td>
<td>$1.22(0.73 \mathrm{x})$</td>
</tr>
<tr>
<td>KG-FiD $\left(\mathrm{N}<em 1="1">{1}=100, \mathrm{~L}</em>=24\right)$</td>
<td>0.90 x</td>
<td>53.4</td>
<td>$1.49(0.90 \mathrm{x})$</td>
<td>69.8</td>
<td>$1.48(0.89 \mathrm{x})$</td>
</tr>
</tbody>
</table>
<p>Table 2: Inference #FLOPs, Latency (second) and Exact match score of FiD (large) and KG-FiD (large). $N_{1}$ is the number of passages into the reader and $L_{1}$ is the number of intermediate layers used for stage-2 reranking as introduced in Section 3.4. The details of flop computation is introduced in Appendix A.5.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: left;">NQ</th>
<th style="text-align: left;"></th>
<th style="text-align: left;">TriviaQA</th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">base</td>
<td style="text-align: left;">large</td>
<td style="text-align: left;">base</td>
<td style="text-align: left;">large</td>
</tr>
<tr>
<td style="text-align: left;">FiD</td>
<td style="text-align: left;">48.8</td>
<td style="text-align: left;">51.9</td>
<td style="text-align: left;">66.2</td>
<td style="text-align: left;">68.7</td>
</tr>
<tr>
<td style="text-align: left;">KG-FiD</td>
<td style="text-align: left;">49.6</td>
<td style="text-align: left;">53.4</td>
<td style="text-align: left;">66.7</td>
<td style="text-align: left;">69.8</td>
</tr>
<tr>
<td style="text-align: left;">w/o Stage-1</td>
<td style="text-align: left;">49.3</td>
<td style="text-align: left;">53.1</td>
<td style="text-align: left;">66.2</td>
<td style="text-align: left;">69.5</td>
</tr>
<tr>
<td style="text-align: left;">w/o Stage-2</td>
<td style="text-align: left;">49.4</td>
<td style="text-align: left;">52.3</td>
<td style="text-align: left;">66.5</td>
<td style="text-align: left;">69.2</td>
</tr>
</tbody>
</table>
<p>Table 3: Ablation study of our graph-based reranking method in two stages. EM scores are reported over NQ and Trivia datasets with both base and large model version.
to validate the effectiveness of each one. Table 3 shows the experiment results by removing each module. We see the performance of KG-FiD drops when removing any of the two reranking modules, demonstrating both of them can improve model performance. Another thing we observe is that stage-1 reranking is more effective in base model while stage-2 reranking is more effective in large model. This is reasonable since stage-2 reranking relies on the effectiveness of reader encoder module, where the large model is usually better than the base model.</p>
<p>Passage Ranking Results: We additionally show that our proposed GNN reranking method can improve the passage retrieval results. This is demonstrated in Figure 2, where we report Hits@K metric over NQ test set, measuring the percentage of top-K retrieved passages that contain the gold passages (passages that contain the answer). We see that DPR+stage-1 reranking consistently outperforms DPR for all the $K \in{10,20,50,100}$. With two stages of reranking, the retrieval results are further improved for $K \in{10,20}$ (We only cares about $K \leq 20$ for stage- 2 reranking since $N_{2}=20$ ). This shows that such reranking can increase the rank of gold passages which are previ-
<img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: Passage ranking results over NQ test set of DPR retriever and our proposed two-stage rerankings over base model.
ously ranked lower by DPR retriever and improve the efficacy of passage pruning.</p>
<h2>5 Conclusion</h2>
<p>This work tackles the task of Open-Domain Question Answering. We focus on the current best performed framework FiD and propose a novel KG-based reranking method to enhance the crossmodeling between passages and improve computation efficiency. Our two-stage reranking methods reuses the passage representation generated by DPR retriver and the reader encoder and apply graph neural networks to compute reranking scores. We further propose to use the intermediate layer of encoder to reduce computation cost while still maintaining good performance. Experiments on Natural Questions and TriviaQA show that our model can significantly improve original FiD by $1.5 \%$ exact match score and achieve on-par performance with FiD but reducing over $60 \%$ of computation cost.</p>
<h2>6 Acknowledgements</h2>
<p>We thank all the reviewers for their valuable comments. We also thank Woojeong Jin, Dong-Ho Lee, and Aaron Chan for useful discussions. Donghan Yu and Yiming Yang are supported in part by the United States Department of Energy via the Brookhaven National Laboratory under Contract No. 384608.</p>
<h2>References</h2>
<p>Akari Asai, Kazuma Hashimoto, Hannaneh Hajishirzi, Richard Socher, and Caiming Xiong. 2020. Learning to retrieve reasoning paths over wikipedia graph for question answering. In 8th International Conference on Learning Representations, ICLR 2020, Addis Ababa, Ethiopia, April 26-30, 2020. OpenReview.net.</p>
<p>Jonathan Berant, Andrew Chou, Roy Frostig, and Percy Liang. 2013. Semantic parsing on Freebase from question-answer pairs. In Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing, pages 1533-1544, Seattle, Washington, USA. Association for Computational Linguistics.</p>
<p>Tom B. Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, Sandhini Agarwal, Ariel Herbert-Voss, Gretchen Krueger, Tom Henighan, Rewon Child, Aditya Ramesh, Daniel M. Ziegler, Jeffrey Wu, Clemens Winter, Christopher Hesse, Mark Chen, Eric Sigler, Mateusz Litwin, Scott Gray, Benjamin Chess, Jack Clark, Christopher Berner, Sam McCandlish, Alec Radford, Ilya Sutskever, and Dario Amodei. 2020. Language models are few-shot learners. In Advances in Neural Information Processing Systems 33: Annual Conference on Neural Information Processing Systems 2020, NeurIPS 2020, December 6-12, 2020, virtual.</p>
<p>Danqi Chen, Adam Fisch, Jason Weston, and Antoine Bordes. 2017. Reading Wikipedia to answer opendomain questions. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 1870-1879, Vancouver, Canada. Association for Computational Linguistics.</p>
<p>Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2019. BERT: Pre-training of deep bidirectional transformers for language understanding. In Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long and Short Papers), pages 4171-4186, Minneapolis, Minnesota. Association for Computational Linguistics.</p>
<p>Kelvin Guu, Kenton Lee, Zora Tung, Panupong Pasupat, and Ming-Wei Chang. 2020. Realm: Retrievalaugmented language model pre-training. arXiv preprint arXiv:2002.08909.</p>
<p>Srinivasan Iyer, Sewon Min, Yashar Mehdad, and Wentau Yih. 2021. RECONSIDER: Improved re-ranking using span-focused cross-attention for open domain question answering. In Proceedings of the 2021 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, pages 1280-1287, Online. Association for Computational Linguistics.</p>
<p>Gautier Izacard and Edouard Grave. 2020. Distilling knowledge from reader to retriever for question answering. arXiv preprint arXiv:2012.04584.</p>
<p>Gautier Izacard and Edouard Grave. 2021. Leveraging passage retrieval with generative models for open domain question answering. In Proceedings of the 16th Conference of the European Chapter of the Association for Computational Linguistics: Main Volume, pages 874-880, Online. Association for Computational Linguistics.</p>
<p>Jeff Johnson, Matthijs Douze, and Hervé Jégou. 2019. Billion-scale similarity search with gpus. IEEE Transactions on Big Data.</p>
<p>Mandar Joshi, Eunsol Choi, Daniel Weld, and Luke Zettlemoyer. 2017. TriviaQA: A large scale distantly supervised challenge dataset for reading comprehension. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 1601-1611, Vancouver, Canada. Association for Computational Linguistics.</p>
<p>Vladimir Karpukhin, Barlas Oguz, Sewon Min, Patrick Lewis, Ledell Wu, Sergey Edunov, Danqi Chen, and Wen-tau Yih. 2020. Dense passage retrieval for opendomain question answering. In Proceedings of the 2020 Conference on Empirical Methods in Natural Language Processing (EMNLP), pages 6769-6781, Online. Association for Computational Linguistics.</p>
<p>Thomas N. Kipf and Max Welling. 2017. Semisupervised classification with graph convolutional networks. In 5th International Conference on Learning Representations, ICLR 2017, Toulon, France, April 24-26, 2017, Conference Track Proceedings. OpenReview.net.</p>
<p>Tom Kwiatkowski, Jennimaria Palomaki, Olivia Redfield, Michael Collins, Ankur Parikh, Chris Alberti, Danielle Epstein, Illia Polosukhin, Jacob Devlin, Kenton Lee, Kristina Toutanova, Llion Jones, Matthew Kelcey, Ming-Wei Chang, Andrew M. Dai, Jakob Uszkoreit, Quoc Le, and Slav Petrov. 2019. Natural questions: A benchmark for question answering research. Transactions of the Association for Computational Linguistics, 7:452-466.</p>
<p>Patrick S. H. Lewis, Ethan Perez, Aleksandra Piktus, Fabio Petroni, Vladimir Karpukhin, Naman</p>
<p>Goyal, Heinrich Küttler, Mike Lewis, Wen-tau Yih, Tim Rocktäschel, Sebastian Riedel, and Douwe Kiela. 2020. Retrieval-augmented generation for knowledge-intensive NLP tasks. In Advances in Neural Information Processing Systems 33: Annual Conference on Neural Information Processing Systems 2020, NeurIPS 2020, December 6-12, 2020, virtual.</p>
<p>Ilya Loshchilov and Frank Hutter. 2019. Decoupled weight decay regularization. In 7th International Conference on Learning Representations, ICLR 2019, New Orleans, LA, USA, May 6-9, 2019. OpenReview.net.</p>
<p>Yuning Mao, Pengcheng He, Xiaodong Liu, Yelong Shen, Jianfeng Gao, Jiawei Han, and Weizhu Chen. 2021. Reader-guided passage reranking for opendomain question answering. In Findings of the Association for Computational Linguistics: ACL-IJCNLP 2021, pages 344-350, Online. Association for Computational Linguistics.</p>
<p>Sewon Min, Danqi Chen, Luke Zettlemoyer, and Hannaneh Hajishirzi. 2019. Knowledge guided text retrieval and reading for open domain question answering. arXiv preprint arXiv:1911.03868.</p>
<p>Rodrigo Nogueira and Kyunghyun Cho. 2019. Passage re-ranking with bert. arXiv preprint arXiv:1901.04085.</p>
<p>Barlas Oguz, Xilun Chen, Vladimir Karpukhin, Stan Peshterliev, Dmytro Okhonko, Michael Schlichtkrull, Sonal Gupta, Yashar Mehdad, and Scott Yih. 2020. Unified open-domain question answering with structured and unstructured knowledge. arXiv preprint arXiv:2012.14610.</p>
<p>Yingqi Qu, Yuchen Ding, Jing Liu, Kai Liu, Ruiyang Ren, Wayne Xin Zhao, Daxiang Dong, Hua Wu, and Haifeng Wang. 2021. RocketQA: An optimized training approach to dense passage retrieval for opendomain question answering. In Proceedings of the 2021 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, pages 5835-5847, Online. Association for Computational Linguistics.</p>
<p>Colin Raffel, Noam Shazeer, Adam Roberts, Katherine Lee, Sharan Narang, Michael Matena, Yanqi Zhou, Wei Li, and Peter J Liu. 2019. Exploring the limits of transfer learning with a unified text-to-text transformer. arXiv preprint arXiv:1910.10683.</p>
<p>Pranav Rajpurkar, Jian Zhang, Konstantin Lopyrev, and Percy Liang. 2016. SQuAD: 100,000+ questions for machine comprehension of text. In Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing, pages 2383-2392, Austin, Texas. Association for Computational Linguistics.</p>
<p>Adam Roberts, Colin Raffel, and Noam Shazeer. 2020. How much knowledge can you pack into the parameters of a language model? In Proceedings of the 2020 Conference on Empirical Methods in Natural</p>
<p>Language Processing (EMNLP), pages 5418-5426, Online. Association for Computational Linguistics.</p>
<p>Devendra Sachan, Mostofa Patwary, Mohammad Shoeybi, Neel Kant, Wei Ping, William L. Hamilton, and Bryan Catanzaro. 2021. End-to-end training of neural retrievers for open-domain question answering. In Proceedings of the 59th Annual Meeting of the Association for Computational Linguistics and the 11th International Joint Conference on Natural Language Processing (Volume 1: Long Papers), pages 6648-6662, Online. Association for Computational Linguistics.</p>
<p>Haitian Sun, Tania Bedrax-Weiss, and William Cohen. 2019. PullNet: Open domain question answering with iterative retrieval on knowledge bases and text. In Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing and the 9th International Joint Conference on Natural Language Processing (EMNLP-IJCNLP), pages 23802390, Hong Kong, China. Association for Computational Linguistics.</p>
<p>Haitian Sun, Bhuwan Dhingra, Manzil Zaheer, Kathryn Mazaitis, Ruslan Salakhutdinov, and William Cohen. 2018. Open domain question answering using early fusion of knowledge bases and text. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 4231-4242, Brussels, Belgium. Association for Computational Linguistics.</p>
<p>Petar Velickovic, Guillem Cucurull, Arantxa Casanova, Adriana Romero, Pietro Liò, and Yoshua Bengio. 2018. Graph attention networks. In 6th International Conference on Learning Representations, ICLR 2018, Vancouver, BC, Canada, April 30 - May 3, 2018, Conference Track Proceedings. OpenReview.net.</p>
<p>Petar Velickovic, William Fedus, William L. Hamilton, Pietro Liò, Yoshua Bengio, and R. Devon Hjelm. 2019. Deep graph infomax. In 7th International Conference on Learning Representations, ICLR 2019, New Orleans, LA, USA, May 6-9, 2019. OpenReview.net.</p>
<p>Denny Vrandečić and Markus Krötzsch. 2014. Wikidata: a free collaborative knowledgebase. Communications of the ACM, 57(10):78-85.</p>
<p>Shuohang Wang, Mo Yu, Xiaoxiao Guo, Zhiguo Wang, Tim Klinger, Wei Zhang, Shiyu Chang, Gerry Tesauro, Bowen Zhou, and Jing Jiang. 2018. R 3: Reinforced ranker-reader for open-domain question answering. In Thirty-Second AAAI Conference on Artificial Intelligence.</p>
<p>Zhiguo Wang, Patrick Ng, Xiaofei Ma, Ramesh Nallapati, and Bing Xiang. 2019. Multi-passage BERT: A globally normalized BERT model for open-domain question answering. In Proceedings of the 2019 Conference on Empirical Methods in Natural Language</p>
<p>Processing and the 9th International Joint Conference on Natural Language Processing (EMNLPIJCNLP), pages 5878-5882, Hong Kong, China. Association for Computational Linguistics.</p>
<p>Thomas Wolf, Lysandre Debut, Victor Sanh, Julien Chaumond, Clement Delangue, Anthony Moi, Pierric Cistac, Tim Rault, Rémi Louf, Morgan Funtowicz, et al. 2019. Huggingface's transformers: State-of-the-art natural language processing. arXiv preprint arXiv:1910.03771.</p>
<p>Wenhan Xiong, Mo Yu, Shiyu Chang, Xiaoxiao Guo, and William Yang Wang. 2019. Improving question answering over incomplete KBs with knowledgeaware reader. In Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics, pages 4258-4264, Florence, Italy. Association for Computational Linguistics.</p>
<p>Keyulu Xu, Weihua Hu, Jure Leskovec, and Stefanie Jegelka. 2019. How powerful are graph neural networks? In 7th International Conference on Learning Representations, ICLR 2019, New Orleans, LA, USA, May 6-9, 2019. OpenReview.net.</p>
<p>Ruochen Xu, Yuwei Fang, Chenguang Zhu, and Michael Zeng. 2021a. Does knowledge help general nlu? an empirical study. arXiv preprint arXiv:2109.00563.</p>
<p>Yichong Xu, Chenguang Zhu, Ruochen Xu, Yang Liu, Michael Zeng, and Xuedong Huang. 2021b. Fusing context into knowledge graph for commonsense question answering. In Findings of the Association for Computational Linguistics: ACL-IJCNLP 2021, pages 1201-1207, Online. Association for Computational Linguistics.</p>
<p>Wei Yang, Yuqing Xie, Aileen Lin, Xingyu Li, Luchen Tan, Kun Xiong, Ming Li, and Jimmy Lin. 2019. End-to-end open-domain question answering with BERTserini. In Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics (Demonstrations), pages 72-77, Minneapolis, Minnesota. Association for Computational Linguistics.</p>
<p>Donghan Yu, Chenguang Zhu, Yiming Yang, and Michael Zeng. 2020. Jaket: Joint pre-training of knowledge graph and language understanding. arXiv preprint arXiv:2010.00796.</p>
<p>Mantong Zhou, Zhouxing Shi, Minlie Huang, and Xiaoyan Zhu. 2020. Knowledge-aided opendomain question answering. arXiv preprint arXiv:2006.05244.</p>
<h2>A Appendix</h2>
<h2>A. 1 Dataset</h2>
<p>The datasets we use are Natural Questions (NQ) and TriviaQA. The open-domain version of NQ is obtained by discarding answers with more than 5 tokens. For TriviaQA, its unfiltered version is used
for ODQA. We also convert all letters of answers in lowercase except the first letter of each word on TriviaQA. When training on NQ, we sample the answer target among the given list of answers, while for TriviaQA, we use the unique human-generated answer as generation target. For both datasets, we use the original validation data as test data, and keep $10 \%$ of the training set for validation.</p>
<h2>A. 2 Preliminary Analysis</h2>
<p>We conduct preliminary analysis on the graph constructed among passages. Note that for each question, we first apply the retriever to retrieve a few candidate passages, then build edge connection only among the retrieved passages, which means that the passage graph is question-specific. Since the passage graph depends on the retrieved passages, before further utilizing the graph, we need avoid two trivia situations: (1) all the retrieved passages come from the same article; (2) The number of graph edges is very small. Thus we conduct statistics of the passage graphs on two ODQA benchmark datasets, which is shown in Figure 3. For each question, the number of retrieved passages is 100 . We see that the two trivia situations only happen for a small portion of questions.</p>
<h2>A. 3 Training Process</h2>
<p>For training our framework, we adopt the separatetraining strategy to avoid out-of-memory issue: we first train the DPR model following its original paper, then freeze the DPR model to train the stage1 reranking module, and finally jointly train stage-2 reranking and reader part. For the training of stage1 reranking, the optimizer is AdamW (Loshchilov and Hutter, 2019) with learning rate as $1 \mathrm{e}-3$ and linear-decay scheduler. The weight decay rate is 0.01 . Batch size is set as 64 . The number of total training steps is 15 k , and the model is evaluated every 500 steps and the model with best validation results is saved as the final model. For the training of reading part, we adopt the same training setting except that the learning rate is $1 \mathrm{e}-4$ for the base model and $5 \mathrm{e}-5$ for the large model. We also adopt learning rate warm up with 1000 steps.</p>
<h2>A. 4 Additional Experiment Results</h2>
<p>We show additional experiment results in this section, which includes the efficiency and performance comparison between FiD (base) and KG-FiD (base) shown in Table 4, and hyper-parameter search results listed below:</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: Preliminary Analysis on the retrieved passages by DPR.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Model</th>
<th style="text-align: center;">#FLOPs</th>
<th style="text-align: center;">NQ</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">TriviaQA</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">EM</td>
<td style="text-align: center;">Latency (s)</td>
<td style="text-align: center;">EM</td>
<td style="text-align: center;">Latency (s)</td>
</tr>
<tr>
<td style="text-align: center;">FiD $\left(\mathrm{N}_{1}=40\right)$</td>
<td style="text-align: center;">0.40x</td>
<td style="text-align: center;">47.2</td>
<td style="text-align: center;">0.27 (0.47x)</td>
<td style="text-align: center;">64.1</td>
<td style="text-align: center;">0.27 (0.46x)</td>
</tr>
<tr>
<td style="text-align: center;">FiD $\left(\mathrm{N}_{1}=100\right)$</td>
<td style="text-align: center;">1.00x</td>
<td style="text-align: center;">48.8</td>
<td style="text-align: center;">0.58 (1.00x)</td>
<td style="text-align: center;">66.2</td>
<td style="text-align: center;">0.59 (1.00x)</td>
</tr>
<tr>
<td style="text-align: center;">KG-FiD $\left(\mathrm{N}<em 1="1">{1}=100, \mathrm{~L}</em>=3\right)$</td>
<td style="text-align: center;">0.38x</td>
<td style="text-align: center;">48.4</td>
<td style="text-align: center;">0.27 (0.47x)</td>
<td style="text-align: center;">65.6</td>
<td style="text-align: center;">0.26 (0.44x)</td>
</tr>
<tr>
<td style="text-align: center;">KG-FiD $\left(\mathrm{N}<em 1="1">{1}=100, \mathrm{~L}</em>=6\right)$</td>
<td style="text-align: center;">0.56x</td>
<td style="text-align: center;">49.0</td>
<td style="text-align: center;">0.35 (0.60x)</td>
<td style="text-align: center;">66.1</td>
<td style="text-align: center;">0.34 (0.58x)</td>
</tr>
<tr>
<td style="text-align: center;">KG-FiD $\left(\mathrm{N}<em 1="1">{1}=100, \mathrm{~L}</em>=9\right)$</td>
<td style="text-align: center;">0.73x</td>
<td style="text-align: center;">49.3</td>
<td style="text-align: center;">0.43 (0.74x)</td>
<td style="text-align: center;">66.3</td>
<td style="text-align: center;">0.43 (0.73x)</td>
</tr>
<tr>
<td style="text-align: center;">KG-FiD $\left(\mathrm{N}<em 1="1">{1}=100, \mathrm{~L}</em>=12\right)$</td>
<td style="text-align: center;">0.91x</td>
<td style="text-align: center;">49.6</td>
<td style="text-align: center;">0.50 (0.86x)</td>
<td style="text-align: center;">66.7</td>
<td style="text-align: center;">0.49 (0.83x)</td>
</tr>
</tbody>
</table>
<p>Table 4: Inference #FLOPs, Latency (second) and Exact match score of FiD (base) and KG-FiD (base). $N_{1}$ is the number of passages into the reader and $L_{1}$ is the number of intermediate layers used for stage-2 reranking as introduced in Section 3.4. The details of flop computation is introduced in Appendix A.5.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Model</th>
<th style="text-align: center;">H@1</th>
<th style="text-align: center;">H@5</th>
<th style="text-align: center;">H@10</th>
<th style="text-align: center;">H@20</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">GCN</td>
<td style="text-align: center;">49.1</td>
<td style="text-align: center;">69.7</td>
<td style="text-align: center;">75.7</td>
<td style="text-align: center;">79.9</td>
</tr>
<tr>
<td style="text-align: center;">GAT</td>
<td style="text-align: center;">50.1</td>
<td style="text-align: center;">70.1</td>
<td style="text-align: center;">76.1</td>
<td style="text-align: center;">80.2</td>
</tr>
<tr>
<td style="text-align: center;">#Layers</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">49.0</td>
<td style="text-align: center;">69.7</td>
<td style="text-align: center;">75.8</td>
<td style="text-align: center;">79.8</td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;">49.6</td>
<td style="text-align: center;">70.0</td>
<td style="text-align: center;">76.0</td>
<td style="text-align: center;">80.2</td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: center;">50.1</td>
<td style="text-align: center;">70.1</td>
<td style="text-align: center;">76.1</td>
<td style="text-align: center;">80.2</td>
</tr>
<tr>
<td style="text-align: center;">4</td>
<td style="text-align: center;">49.5</td>
<td style="text-align: center;">69.9</td>
<td style="text-align: center;">76.1</td>
<td style="text-align: center;">80.1</td>
</tr>
</tbody>
</table>
<p>Table 5: Passage Retrieval Results on NQ dev data of our model under different GNN types and number of layers.</p>
<p>GNN Model Design: We conduct tuning on the model type and number of layers of our GNN based reranking model. For efficiency, we rerank 100 passages returned by DPR retriever and search them based on the passage retrieval results. Table 5 shows the Hits scores for different choices. We see that GAT outperforms vanilla GCN model (Kipf and Welling, 2017) which is reasonable since GAT leverage attention to reweight neighbor passages by their embeddings. The best choice for the number of GNN layers is 3. Note that other GNN models such as GIN (Xu et al., 2019), DGI (Velickovic et al., 2019) can also be applied here and we leave the further exploration of GNN models as future work.
$N_{2}$ and $\lambda$. For the stage-2 reranking part in Section 3.3, we also conduct hyper-parameter search on the number of passages after filtering: $N_{2} \in$ ${10,20,30}$ and the weight of reranking loss when training the reading module: $\lambda \in{0.01,0.1,1.0}$. As shown in Table 6, $N_{2}=20$ achieves better results than $N_{2}=10$, but further increasing $N_{2}$ does not bring performance gain while decreasing the efficiency of model since the number of passages to be processed by the decoder is increased. Thus we choose $N_{2}=20$. For the loss weight $\lambda$, we found that with its increment, the performance first increases then significantly drops. This shows that it's important to balance the weight of two training losses, as we want the model to learn better passage reranking while not overwhelming the training signal of answer generation.</p>
<h2>A. 5 FLOPs Computation</h2>
<p>In this section we compute the FLOPs of each module ${ }^{4}$. The results are shown in Table 7 and 8 for</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup>${ }^{4}$ Our computation is based on https://github.com/googleresearch/electra/blob/master/flops_computation.py</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Model</th>
<th style="text-align: center;">$\mathrm{N}_{2}=10$</th>
<th style="text-align: center;">$\mathrm{~N}_{2}=20$</th>
<th style="text-align: center;">$\mathrm{~N}_{2}=30$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">KG-FiD</td>
<td style="text-align: center;">47.6</td>
<td style="text-align: center;">48.0</td>
<td style="text-align: center;">48.0</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">$\lambda=0.01$</td>
<td style="text-align: center;">$\lambda=0.1$</td>
<td style="text-align: center;">$\lambda=1.0$</td>
</tr>
<tr>
<td style="text-align: center;">KG-FiD</td>
<td style="text-align: center;">47.7</td>
<td style="text-align: center;">48.0</td>
<td style="text-align: center;">46.6</td>
</tr>
</tbody>
</table>
<p>Table 6: EM scores on NQ dev data of our model under different choices of filtered passage numbers and weights of reranking loss.
base model and large model respectively. Before the computation, we first show some basic statistics on two benchmark datasets: the average question length is 20 , and the average answer length is 5 . For the reading part, the length of concatenated passage question pair is 250 , number of input passages is $N_{1}=100$.</p>
<p>We first calculate the number of FLOPs of vanilla FiD model. For the retrieving part, it contains both question encoding and passage similarity search. We only consider the former part as the latter part depends on the corpus size and search methods and is usually very efficient. The question encoding flops by BERT-based model is about 4.4 Gigaflops (GFLOPs). For the reading part, the encoding of each question passage pair takes about 57/174 GFLOPs for base/large model, and the encoding of 100 passages takes 5772/17483 GFLOPs. The decoder part only costs 714.2/2534.5 GFLOPs for base/large model since the average length of answer is very small. In summary, vanilla FiD base/large model costs 6491.0/20022.0 GFLOPs.</p>
<p>For our model, the computation cost of retrieving part is the same as vanilla FiD. Since we set $N_{0}=1000$ and $N_{1}=100$, the GAT (Velickovic et al., 2018) computation in stage-1 reranking takes about 3.5 GFLOPs, and the stage-2 reranking takes only 0.4/0.6 GFLOPs for base/large model. For the reader encoding part, the computation cost depends on $L_{1}$ and $N_{2}$, which is analyzed in Section 3.5. For the reader decoding part, where cross attention takes most of the computation, KG-FiD only takes about $N_{2} / N_{1}=1 / 5$ cost of vanilla FiD, which is 143.9/510.0 for base/large model respectively. The detailed flops are shown in Table 7 and 8.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: center;">Retrieving</th>
<th style="text-align: center;">Stage-1 <br> Reranking</th>
<th style="text-align: center;">Reader <br> Encoding</th>
<th style="text-align: center;">Stage-2 <br> Reranking</th>
<th style="text-align: center;">Reader <br> Decoding</th>
<th style="text-align: center;">All</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">FiD</td>
<td style="text-align: center;">4.4</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">5772.3</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">714.2</td>
<td style="text-align: center;">$6491.0(1.00 \mathrm{x})$</td>
</tr>
<tr>
<td style="text-align: left;">KG-FiD $\left(\mathrm{L}_{1}=3\right)$</td>
<td style="text-align: center;">4.4</td>
<td style="text-align: center;">3.5</td>
<td style="text-align: center;">2308.9</td>
<td style="text-align: center;">0.4</td>
<td style="text-align: center;">143.9</td>
<td style="text-align: center;">$2461.1(0.38 \mathrm{x})$</td>
</tr>
<tr>
<td style="text-align: left;">KG-FiD $\left(\mathrm{L}_{1}=6\right)$</td>
<td style="text-align: center;">4.4</td>
<td style="text-align: center;">3.5</td>
<td style="text-align: center;">3463.4</td>
<td style="text-align: center;">0.4</td>
<td style="text-align: center;">143.9</td>
<td style="text-align: center;">$3615.5(0.56 \mathrm{x})$</td>
</tr>
<tr>
<td style="text-align: left;">KG-FiD $\left(\mathrm{L}_{1}=9\right)$</td>
<td style="text-align: center;">4.4</td>
<td style="text-align: center;">3.5</td>
<td style="text-align: center;">4617.9</td>
<td style="text-align: center;">0.4</td>
<td style="text-align: center;">143.9</td>
<td style="text-align: center;">$4770.0(0.73 \mathrm{x})$</td>
</tr>
<tr>
<td style="text-align: left;">KG-FiD $\left(\mathrm{L}_{1}=12\right)$</td>
<td style="text-align: center;">4.4</td>
<td style="text-align: center;">3.5</td>
<td style="text-align: center;">5772.3</td>
<td style="text-align: center;">0.4</td>
<td style="text-align: center;">143.9</td>
<td style="text-align: center;">$5924.5(0.91 \mathrm{x})$</td>
</tr>
</tbody>
</table>
<p>Table 7: #GFLOPs of FiD (base) and KG-FiD (base) over different stages in the model.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: center;">Retrieving</th>
<th style="text-align: center;">Stage-1 <br> Reranking</th>
<th style="text-align: center;">Reader <br> Encoding</th>
<th style="text-align: center;">Stage-2 <br> Reranking</th>
<th style="text-align: center;">Reader <br> Decoding</th>
<th style="text-align: center;">All</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">FiD</td>
<td style="text-align: center;">4.4</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">17483.2</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">2534.5</td>
<td style="text-align: center;">$20022.0(1.00 \mathrm{x})$</td>
</tr>
<tr>
<td style="text-align: left;">KG-FiD $\left(\mathrm{L}_{1}=6\right)$</td>
<td style="text-align: center;">4.4</td>
<td style="text-align: center;">3.5</td>
<td style="text-align: center;">6993.3</td>
<td style="text-align: center;">0.6</td>
<td style="text-align: center;">510.0</td>
<td style="text-align: center;">$7511.8(0.38 \mathrm{x})$</td>
</tr>
<tr>
<td style="text-align: left;">KG-FiD $\left(\mathrm{L}_{1}=12\right)$</td>
<td style="text-align: center;">4.4</td>
<td style="text-align: center;">3.5</td>
<td style="text-align: center;">10489.9</td>
<td style="text-align: center;">0.6</td>
<td style="text-align: center;">510.0</td>
<td style="text-align: center;">$11008.4(0.55 \mathrm{x})$</td>
</tr>
<tr>
<td style="text-align: left;">KG-FiD $\left(\mathrm{L}_{1}=18\right)$</td>
<td style="text-align: center;">4.4</td>
<td style="text-align: center;">3.5</td>
<td style="text-align: center;">13986.5</td>
<td style="text-align: center;">0.6</td>
<td style="text-align: center;">510.0</td>
<td style="text-align: center;">$14505.1(0.72 \mathrm{x})$</td>
</tr>
<tr>
<td style="text-align: left;">KG-FiD $\left(\mathrm{L}_{1}=24\right)$</td>
<td style="text-align: center;">4.4</td>
<td style="text-align: center;">3.5</td>
<td style="text-align: center;">17483.2</td>
<td style="text-align: center;">0.6</td>
<td style="text-align: center;">510.0</td>
<td style="text-align: center;">$18001.7(0.90 \mathrm{x})$</td>
</tr>
</tbody>
</table>
<p>Table 8: #GFLOPs of FiD (large) and KG-FiD (large) over different stages in the model.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{4}$ Our computation is based on https://github.com/googleresearch/electra/blob/master/flops_computation.py&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>