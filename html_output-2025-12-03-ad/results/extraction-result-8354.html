<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-8354 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-8354</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-8354</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-149.html">extraction-schema-149</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, probing results, interventions, performance, and error analysis.</div>
                <p><strong>Paper ID:</strong> paper-a0dc3135c40e150f0271002a96b7c9680b6cac40</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/a0dc3135c40e150f0271002a96b7c9680b6cac40" target="_blank">Fourier Features Let Networks Learn High Frequency Functions in Low Dimensional Domains</a></p>
                <p><strong>Paper Venue:</strong> Neural Information Processing Systems</p>
                <p><strong>Paper TL;DR:</strong> An approach for selecting problem-specific Fourier features that greatly improves the performance of MLPs for low-dimensional regression tasks relevant to the computer vision and graphics communities is suggested.</p>
                <p><strong>Paper Abstract:</strong> We show that passing input points through a simple Fourier feature mapping enables a multilayer perceptron (MLP) to learn high-frequency functions in low-dimensional problem domains. These results shed light on recent advances in computer vision and graphics that achieve state-of-the-art results by using MLPs to represent complex 3D objects and scenes. Using tools from the neural tangent kernel (NTK) literature, we show that a standard MLP fails to learn high frequencies both in theory and in practice. To overcome this spectral bias, we use a Fourier feature mapping to transform the effective NTK into a stationary kernel with a tunable bandwidth. We suggest an approach for selecting problem-specific Fourier features that greatly improves the performance of MLPs for low-dimensional regression tasks relevant to the computer vision and graphics communities.</p>
                <p><strong>Cost:</strong> 0.005</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <p class="empty-note">No extracted data.</p>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <p class="empty-note">No potentially relevant new papers extracted.</p>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-8354",
    "paper_id": "paper-a0dc3135c40e150f0271002a96b7c9680b6cac40",
    "extraction_schema_id": "extraction-schema-149",
    "extracted_data": [],
    "potentially_relevant_new_papers": [],
    "cost": 0.005328749999999999,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Fourier Features Let Networks Learn High Frequency Functions in Low Dimensional Domains</h1>
<p>Matthew Tancik ${ }^{1 <em>}$ Pratul P. Srinivasan ${ }^{1,2 </em>}$ Ben Mildenhall ${ }^{1 *}$ Sara Fridovich-Keil ${ }^{1}$<br>Nithin Raghavan ${ }^{1}$ Utkarsh Singhal ${ }^{1}$ Ravi Ramamoorthi ${ }^{3}$ Jonathan T. Barron ${ }^{2}$ Ren Ng ${ }^{1}$<br>${ }^{1}$ University of California, Berkeley ${ }^{2}$ Google Research ${ }^{3}$ University of California, San Diego</p>
<h4>Abstract</h4>
<p>We show that passing input points through a simple Fourier feature mapping enables a multilayer perceptron (MLP) to learn high-frequency functions in lowdimensional problem domains. These results shed light on recent advances in computer vision and graphics that achieve state-of-the-art results by using MLPs to represent complex 3D objects and scenes. Using tools from the neural tangent kernel (NTK) literature, we show that a standard MLP fails to learn high frequencies both in theory and in practice. To overcome this spectral bias, we use a Fourier feature mapping to transform the effective NTK into a stationary kernel with a tunable bandwidth. We suggest an approach for selecting problem-specific Fourier features that greatly improves the performance of MLPs for low-dimensional regression tasks relevant to the computer vision and graphics communities.</p>
<h2>1 Introduction</h2>
<p>A recent line of research in computer vision and graphics replaces traditional discrete representations of objects, scene geometry, and appearance (e.g. meshes and voxel grids) with continuous functions parameterized by deep fully-connected networks (also called multilayer perceptrons or MLPs). These MLPs, which we will call "coordinate-based" MLPs, take low-dimensional coordinates as inputs (typically points in $\mathbb{R}^{3}$ ) and are trained to output a representation of shape, density, and/or color at each input location (see Figure 1). This strategy is compelling since coordinate-based MLPs are amenable to gradient-based optimization and machine learning, and can be orders of magnitude more compact than grid-sampled representations. Coordinate-based MLPs have been used to represent images [28, 38] (referred to as "compositional pattern producing networks"), volume density [27], occupancy [24], and signed distance [32], and have achieved state-of-the-art results across a variety of tasks such as shape representation [9, 10, 12, 13, 17, 26, 32], texture synthesis [15, 31], shape inference from images [22, 23], and novel view synthesis [27, 29, 35, 37].
We leverage recent progress in modeling the behavior of deep networks using kernel regression with a neural tangent kernel (NTK) [16] to theoretically and experimentally show that standard MLPs are poorly suited for these low-dimensional coordinate-based vision and graphics tasks. In particular, MLPs have difficulty learning high frequency functions, a phenomenon referred to in the literature as "spectral bias" [3, 33]. NTK theory suggests that this is because standard coordinate-based MLPs correspond to kernels with a rapid frequency falloff, which effectively prevents them from being able to represent the high-frequency content present in natural images and scenes.
A few recent works [27, 44] have experimentally found that a heuristic sinusoidal mapping of input coordinates (called a "positional encoding") allows MLPs to represent higher frequency content.</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Fourier features improve the results of coordinate-based MLPs for a variety of high-frequency low-dimensional regression tasks, both with direct (b, c) and indirect (d, e) supervision. We visualize an example MLP (a) for an image regression task (b), where the input to the network is a pixel coordinate and the output is that pixel's color. Passing coordinates directly into the network (top) produces blurry images, whereas preprocessing the input with a Fourier feature mapping (bottom) enables the MLP to represent higher frequency details.</p>
<p>We observe that this is a special case of Fourier features [34]: mapping input coordinates <strong>v</strong> to γ(<strong>v</strong>) = [a_{1} cos(2π<strong>b</strong><em 1="1">{1}^{T}<strong>v</strong>), a</em> sin(2π<strong>b</strong><em m="m">{1}^{T}<strong>v</strong>), . . . , a</em> cos(2π<strong>b</strong><em m="m">{m}^{T}<strong>v</strong>), a</em> sin(2π<strong>b</strong><em j="j">{m}^{T}<strong>v</strong>)]^{<em>T</em>} before passing them into an MLP. We show that this mapping transforms the NTK into a stationary (shift-invariant) kernel and enables tuning the NTK's spectrum by modifying the frequency vectors <strong>b</strong></em> = 1 and randomly sampling }, thereby controlling the range of frequencies that can be learned by the corresponding MLP. We show that the simple strategy of setting a_{j<strong>b</strong>_{j} from an isotropic distribution achieves good performance, and that the scale (standard deviation) of this distribution matters much more than its specific shape. We train MLPs with this Fourier feature input mapping across a range of tasks relevant to the computer vision and graphics communities. As highlighted in Figure 1, our proposed mapping dramatically improves the performance of coordinate-based MLPs. In summary, we make the following contributions:</p>
<ul>
<li>We leverage NTK theory and simple experiments to show that a Fourier feature mapping can be used to overcome the spectral bias of coordinate-based MLPs towards low frequencies by allowing them to learn much higher frequencies (Section 4).</li>
<li>We demonstrate that a random Fourier feature mapping with an appropriately chosen scale can dramatically improve the performance of coordinate-based MLPs across many low-dimensional tasks in computer vision and graphics (Section 5).</li>
</ul>
<h2>2 Related Work</h2>
<p>Our work is motivated by the widespread use of coordinate-based MLPs to represent a variety of visual signals, including images [38] and 3D scenes [24, 27, 32]. In particular, our analysis is intended to clarify experimental results demonstrating that an input mapping of coordinates (which they called a "positional encoding") using sinusoids with logarithmically-spaced axis-aligned frequencies improves the performance of coordinate-based MLPs on the tasks of novel view synthesis from 2D images [27] and protein structure modeling from cryo-electron microscopy [44]. We analyze this technique to show that it corresponds to a modification of the MLP's NTK, and we show that other non-axis-aligned frequency distributions can outperform this positional encoding.</p>
<p>Prior works in natural language processing and time series analysis [18, 39, 42] have used a similar positional encoding to represent time or 1D position. In particular, Xu <em>et al.</em> [42] use random Fourier features (RFF) [34] to approximate stationary kernels with a sinusoidal input mapping and propose techniques to tune the mapping parameters. Our work extends this by directly explaining such</p>
<p>mappings as a modification of the resulting network’s NTK. Additionally, we address the embedding of multidimensional coordinates, which is necessary for vision and graphics tasks.</p>
<p>To analyze the effects of applying a Fourier feature mapping to input coordinates before passing them through an MLP, we rely on recent theoretical work that models neural networks in the limits of infinite width and infinitesimal learning rate as kernel regression using the NTK [2, 5, 11, 16, 20]. In particular, we use the analyses from Lee et al. [20] and Arora et al. [2], which show that the outputs of a network throughout gradient descent remain close to those of a linear dynamical system whose convergence rate is governed by the eigenvalues of the NTK matrix [2, 3, 5, 20, 43]. Analysis of the NTK’s eigendecomposition shows that its eigenvalue spectrum decays rapidly as a function of frequency, which explains the widely-observed “spectral bias” of deep networks towards learning low-frequency functions [3, 4, 33].</p>
<p>We leverage this analysis to consider the implications of adding a Fourier feature mapping before the network, and we show that this mapping has a significant effect on the NTK’s eigenvalue spectrum and on the corresponding network’s convergence properties in practice.</p>
<h2>3 Background and Notation</h2>
<p>To lay the foundation for our theoretical analysis, we first review classic kernel regression and its connection to recent results that analyze the training dynamics and generalization behavior of deep fully-connected networks. In later sections, we use these tools to analyze the effects of training coordinate-based MLPs with Fourier feature mappings.</p>
<p>Kernel regression. Kernel regression is a classic nonlinear regression algorithm [40]. Given a training dataset $(\mathbf{X},\mathbf{y})={(\mathbf{x}<em i="i">{i},y</em>)}<em i="i">{i=1}^{n}$, where $\mathbf{x}</em>$ as:}$ are input points and $y_{i}=f(\mathbf{x}_{i})$ are the corresponding scalar output labels, kernel regression constructs an estimate $\hat{f}$ of the underlying function at any point $\mathbf{x</p>
<p>$\hat{f}(\mathbf{x})=\sum_{i=1}^{n}\left(\mathbf{K}^{-1}\mathbf{y}\right)<em i="i">{i}k(\mathbf{x}</em>),$ (1)},\mathbf{x</p>
<p>where $\mathbf{K}$ is an $n\times n$ kernel (Gram) matrix with entries $\mathbf{K}<em i="i">{ij}=k(\mathbf{x}</em>},\mathbf{x<em i="i">{j})$ and $k$ is a symmetric positive semidefinite (PSD) kernel function which represents the “similarity” between two input vectors. Intuitively, the kernel regression estimate at any point $\mathbf{x}$ can be thought of as a weighted sum of training labels $y</em>$.}$ using the similarity between the corresponding $\mathbf{x}_{i}$ and $\mathbf{x</p>
<p>Approximating deep networks with kernel regression. Let $f$ be a fully-connected deep network with weights $\theta$ initialized from a Gaussian distribution $\mathcal{N}$. Theory proposed by Jacot et al. [16] and extended by others [2, 3, 20] shows that when the width of the layers in $f$ tends to infinity and the learning rate for SGD tends to zero, the function $f(\mathbf{x} ;\theta)$ converges over the course of training to the kernel regression solution using the neural tangent kernel (NTK), defined as:</p>
<p>$k_{\mathrm{NTK}}(\mathbf{x}<em j="j">{i},\mathbf{x}</em>})=\mathbb{E<em i="i">{\theta \sim \mathcal{N}}\left\langle\frac{\partial f(\mathbf{x}</em>\right\rangle.$ (2)} ;\theta)}{\partial \theta}, \frac{\partial f(\mathbf{x}_{j} ; \theta)}{\partial \theta</p>
<p>When the inputs are restricted to a hypersphere, the NTK for an MLP can be written as a dot product kernel (a kernel in the form $h_{\mathrm{NTK}}\left(\mathbf{x}<em j="j">{i}^{\mathrm{T}} \mathbf{x}</em>$ ).}\right)$ for a scalar function $h_{\mathrm{NTK}}: \mathbb{R} \rightarrow \mathbb{R</p>
<p>Prior work [2, 3, 16, 20] shows that an NTK linear system model can be used to approximate the dynamics of a deep network during training. We consider a network trained with an L2 loss and a learning rate $\eta$, where the network’s weights are initialized such that the output of the network at initialization is close to zero. Under asymptotic conditions stated in Lee et al. [20], the network’s output for any data $\mathbf{X}_{\text {test }}$ after $t$ training iterations can be approximated as:</p>
<p>$$
\hat{\mathbf{y}}^{(t)} \approx \mathbf{K}_{\text {test }} \mathbf{K}^{-1}\left(\mathbf{I}-e^{-\eta \mathbf{K} t}\right) \mathbf{y}
$$</p>
<p>where $\hat{\mathbf{y}}^{(t)}=f\left(\mathbf{X}<em _test="{test" _text="\text">{\text {test }} ; \theta\right)$ are the network’s predictions on input points $\mathbf{X}</em>}}$ at training iteration $t$, $\mathbf{K}$ is the NTK matrix between all pairs of training points in $\mathbf{X}$, and $\mathbf{K<em _test="{test" _text="\text">{\text {test }}$ is the NTK matrix between all points in $\mathbf{X}</em>$.}}$ and all points in the training dataset $\mathbf{X</p>
<p>Spectral bias when training neural networks. Let us consider the training error $\hat{\mathbf{y}}<em _text="\text" _train="{train">{\text {train }}^{(t)}-\mathbf{y}$, where $\hat{\mathbf{y}}</em>$}}^{(t)}$ are the network’s predictions on the training dataset at iteration $t$. Since the NTK matrix $\mathbf{K</p>
<p>must be PSD, we can take its eigendecomposition $\mathbf{K}=\mathbf{Q}\boldsymbol{\Lambda}\mathbf{Q}^{\mathrm{T}}$, where $\mathbf{Q}$ is orthogonal and $\boldsymbol{\Lambda}$ is a diagonal matrix whose entries are the eigenvalues $\lambda_{i} \geq 0$ of $\mathbf{K}$. Then, since $e^{-\eta \mathbf{K} t}=\mathbf{Q} e^{-\eta \boldsymbol{\Lambda} t} \mathbf{Q}^{\mathrm{T}}$ :</p>
<p>$$
\mathbf{Q}^{\mathrm{T}}\left(\hat{\mathbf{y}}_{\text {train }}^{(t)}-\mathbf{y}\right) \approx \mathbf{Q}^{\mathrm{T}}\left(\left(\mathbf{I}-e^{-\eta \mathbf{K} t}\right) \mathbf{y}-\mathbf{y}\right)=-e^{-\eta \boldsymbol{\Lambda} t} \mathbf{Q}^{\mathrm{T}} \mathbf{y}
$$</p>
<p>This means that if we consider training convergence in the eigenbasis of the NTK, the $i^{\text {th }}$ component of the absolute error $\left|\mathbf{Q}^{\mathrm{T}}\left(\hat{\mathbf{y}}<em i="i">{\text {train }}^{(t)}-\mathbf{y}\right)\right|</em>$. In other words, components of the target function that correspond to kernel eigenvectors with larger eigenvalues will be learned faster. For a conventional MLP, the eigenvalues of the NTK decay rapidly [4, 5, 14]. This results in extremely slow convergence to the high frequency components of the target function, to the point where standard MLPs are effectively unable to learn these components, as visualized in Figure 1. Next, we describe a technique to address this slow convergence by using a Fourier feature mapping of input coordinates before passing them to the MLP.}$ will decay approximately exponentially at the rate $\eta \lambda_{i</p>
<h1>4 Fourier Features for a Tunable Stationary Neural Tangent Kernel</h1>
<p>Machine learning analysis typically addresses the case in which inputs are high dimensional points (e.g. the pixels of an image reshaped into a vector) and training examples are sparsely distributed. In contrast, in this work we consider low-dimensional regression tasks, wherein inputs are assumed to be dense coordinates in a subset of $\mathbb{R}^{d}$ for small values of $d$ (e.g. pixel coordinates). This setting has two significant implications when viewing deep networks through the lens of kernel regression:</p>
<ol>
<li>We would like the composed NTK to be shift-invariant over the input domain, since the training points are distributed with uniform density. In problems where the inputs are normalized to the surface of a hypersphere (common in machine learning), a dot product kernel (such as the regular NTK) corresponds to spherical convolution. However, inputs in our setting are dense in Euclidean space. A Fourier feature mapping of input coordinates makes the composed NTK stationary (shift-invariant), acting as a convolution kernel over the input domain (see Appendix C for additional discussion on stationary kernels).</li>
<li>We would like to control the bandwidth of the NTK to improve training speed and generalization. As we see from Eqn. 4, a "wider" kernel with a slower spectral falloff achieves faster training convergence for high frequency components. However, we know from signal processing that reconstructing a signal using a kernel whose spectrum is too wide causes high frequency aliasing artifacts. We show in Section 5 that a Fourier feature input mapping can be tuned to lie between these "underfitting' and "overfitting" extremes, enabling both fast convergence and low test error.</li>
</ol>
<p>Fourier features and the composed neural tangent kernel. Fourier feature mappings have been used in many applications since their introduction in the seminal work of Rahimi and Recht [34], which used random Fourier features to approximate an arbitrary stationary kernel function by applying Bochner's theorem. Extending this technique, we use a Fourier feature mapping $\gamma$ to featurize input coordinates before passing them through a coordinate-based MLP, and investigate the theoretical and practical effect this has on convergence speed and generalization. The function $\gamma$ maps input points $\mathbf{v} \in[0,1)^{d}$ to the surface of a higher dimensional hypersphere with a set of sinusoids:</p>
<p>$$
\gamma(\mathbf{v})=\left[a_{1} \cos \left(2 \pi \mathbf{b}<em 1="1">{1}^{\mathrm{T}} \mathbf{v}\right), a</em>} \sin \left(2 \pi \mathbf{b<em m="m">{1}^{\mathrm{T}} \mathbf{v}\right), \ldots, a</em>} \cos \left(2 \pi \mathbf{b<em m="m">{m}^{\mathrm{T}} \mathbf{v}\right), a</em>
$$} \sin \left(2 \pi \mathbf{b}_{m}^{\mathrm{T}} \mathbf{v}\right)\right]^{\mathrm{T}</p>
<p>Because $\cos (\alpha-\beta)=\cos \alpha \cos \beta+\sin \alpha \sin \beta$, the kernel function induced by this mapping is:</p>
<p>$$
\begin{gathered}
k_{\gamma}\left(\mathbf{v}<em 2="2">{1}, \mathbf{v}</em>}\right)=\gamma\left(\mathbf{v<em 2="2">{1}\right)^{\mathrm{T}} \gamma\left(\mathbf{v}</em>}\right)=\sum_{j=1}^{m} a_{j}^{2} \cos \left(2 \pi \mathbf{b<em 1="1">{j}^{\mathrm{T}}\left(\mathbf{v}</em>}-\mathbf{v<em _gamma="\gamma">{2}\right)\right)=h</em>}\left(\mathbf{v<em 2="2">{1}-\mathbf{v}</em>\right) \
\text { where } h_{\gamma}\left(\mathbf{v}<em j="1">{\Delta}\right) \triangleq \sum</em>}^{m} a_{j}^{2} \cos \left(2 \pi \mathbf{b<em _Delta="\Delta">{j}^{\mathrm{T}} \mathbf{v}</em>\right)
\end{gathered}
$$</p>
<p>Note that this kernel is stationary (a function of only the difference between points). We can think of the mapping as a Fourier approximation of a kernel function: $\mathbf{b}<em j="j">{j}$ are the Fourier basis frequencies used to approximate the kernel, and $a</em>$ are the corresponding Fourier series coefficients.
After computing the Fourier features for our input points, we pass them through an MLP to get $f(\gamma(\mathbf{v}) ; \theta)$. As discussed previously, the result of training a network can be approximated by kernel}^{2</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: Adding a Fourier feature mapping can improve the poor conditioning of a coordinate-based MLP's neural tangent kernel (NTK). (a) We visualize the NTK function $k_{\mathrm{NTK}}\left(x_{i},x_{j}\right)$ (Eqn. 2) for a 4-layer ReLU MLP with one scalar input. This kernel is not shift-invariant and does not have a strong diagonal, making it poorly suited for kernel regression in low-dimensional problems. (b) A basic input mapping $\gamma(v)=\left[\cos 2\pi v, \sin 2 \pi v\right]^{\mathrm{T}}$ makes the composed NTK $k_{\mathrm{NTK}}\left(\gamma\left(v_{i}\right), \gamma\left(v_{j}\right)\right)$ shift-invariant (stationary). (c) A Fourier feature input mapping (Eqn. 5) can be used to tune the composed kernel's width, where we set $a_{j}=1 / j^{p}$ and $b_{j}=j$ for $j=1, \ldots, n / 2$. (d) Higher frequency mappings (lower $p$ ) result in composed kernels with wider spectra, which enables faster convergence for high-frequency components (see Figure 3).</p>
<p>Regression using the kernel $h_{\mathrm{NTK}}\left(\mathbf{x}<em j="j">{i}^{\mathrm{T}} \mathbf{x}</em>}\right)$. In our case, $\mathbf{x<em i="i">{i}=\gamma\left(\mathbf{v}</em>\right)$ so the composed kernel becomes:</p>
<p>$$
h_{\mathrm{NTK}}\left(\mathbf{x}<em j="j">{i}^{\mathrm{T}} \mathbf{x}</em>}\right)=h_{\mathrm{NTK}}\left(\gamma\left(\mathbf{v<em j="j">{i}\right)^{\mathrm{T}} \gamma\left(\mathbf{v}</em>}\right)\right)=h_{\mathrm{NTK}}\left(h_{\gamma}\left(\mathbf{v<em j="j">{i}-\mathbf{v}</em>\right)\right)
$$</p>
<p>Thus, training a network on these embedded input points corresponds to kernel regression with the <em>stationary</em> composed NTK function $h_{\mathrm{NTK}} \circ h_{\gamma}$. The MLP function approximates a convolution of the composed NTK with a weighted Dirac delta at each input training point $\mathbf{v}_{i}$ :</p>
<p>$$
\hat{f}=\left(h_{\mathrm{NTK}} \circ h_{\gamma}\right) * \sum_{i=1}^{n} w_{i} \delta_{\mathbf{v}_{i}}
$$</p>
<p>where $\mathbf{w}=\mathbf{K}^{-1} \mathbf{y}$ (from Eqn. 1). This allows us to draw analogies to signal processing, where the composed NTK acts similarly to a reconstruction filter. In the next section, we show that the frequency decay of the composed NTK determines the behavior of the reconstructed signal.</p>
<h1>5 Manipulating the Fourier Feature Mapping</h1>
<p>Preprocessing the inputs to a coordinate-based MLP with a Fourier feature mapping creates a composed NTK that is not only stationary but also <em>tunable</em>. By manipulating the settings of the $a_{j}$ and $\mathbf{b}_{j}$ parameters in Eqn. 5, it is possible to dramatically change both the rate of convergence and the generalization behavior of the resulting network. In this section, we investigate the effects of the Fourier feature mapping in the setting of 1D function regression.</p>
<p>We train MLPs to learn signals $f$ defined on the interval $[0,1)$. We sample $c n$ linearly spaced points on the interval, using every $c^{\text {th }}$ point as the training set and the remaining points as the test set. Since our composed kernel function is stationary, evaluating it at linearly spaced points on a periodic domain makes the resulting kernel matrix circulant: it represents a convolution and is diagonalizable by the Fourier transform. Thus, we can compute the eigenvalues of the composed NTK matrix by simply taking the Fourier transform of a single row. All experiments are implemented in JAX [8] and the NTK functions are calculated automatically using the Neural Tangents library [30].</p>
<p>Visualizing the composed NTK. We first visualize how modifying the Fourier feature mapping changes the composed NTK. We set $b_{j}=j$ (full Fourier basis in 1D) and $a_{j}=1 / j^{p}$ for $j=$ $1, \ldots, n / 2$. We use $p=\infty$ to denote the mapping $\gamma(v)=\left[\cos 2 \pi v, \sin 2 \pi v\right]^{\mathrm{T}}$ that simply wraps $[0,1)$ around the unit circle (this is referred to as the "basic" mapping in later experiments). Figure 2 demonstrates the effect of varying $p$ on the composed NTK. By construction, lower $p$ values result in a slower falloff in the frequency domain and a correspondingly narrower kernel in the spatial domain.</p>
<p>Effects of Fourier features on network convergence. We generate ground truth 1D functions by sampling $c n$ values from a family with parameter $\alpha$ as follows: we sample a standard i.i.d. Gaussian vector of length $c n$, scale its $i^{\text {th }}$ entry by $1 / i^{\alpha}$, then return the real component of its inverse Fourier transform. We will refer to this as a " $1 / f^{\alpha}$ noise" signal.</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: Combining a network with a Fourier feature mapping has dramatic effects on convergence and generalization. Here we train a network on 32 sampled points from a 1D function (a) using mappings shown in Fig. 2. A mapping with a smaller <em>p</em> value yields a composed NTK with more power in higher frequencies, enabling the corresponding network to learn a higher frequency function. The theoretical and experimental training loss improves monotonically with higher frequency kernels (d), but the test-set loss is lowest at <em>p</em> = 1 and falls as the network starts to overfit (b). As predicted by Eqn. 4, we see roughly log-linear convergence of the training loss frequency components (c). Higher frequency kernels result in faster convergence for high frequency loss components, thereby overcoming the "spectral bias" observed when training networks with no input mapping.</p>
<p>In Figure 3, we train MLPs (4 layers, 1024 channels, ReLU activations) to fit a bandlimited 1/<em>f</em><sup>1</sup> noise signal (<em>c</em> = 8, <em>n</em> = 32) using Fourier feature mappings with different <em>p</em> values. Figures 3b and 3d show that the NTK linear dynamics model accurately predict the effects of modifying the Fourier feature mapping parameters. Separating different frequency components of the training error in Figure 3c reveals that networks with narrower NTK spectra converge faster for low frequency components but essentially never converge for high frequency components, whereas networks with wider NTK spectra successfully converge across all components. The Fourier feature mapping <em>p</em> = 1 has adequate power across frequencies present in the target signal (so the network converges rapidly during training) but limited power in higher frequencies (preventing overfitting or aliasing).</p>
<p><strong>Tuning Fourier features in practice.</strong> Eqn. 3 allows us to estimate a trained network's theoretical loss on a validation set using the composed kernel. For small 1D problems, we can minimize this loss with gradient-based optimization to choose mapping parameters <em>a</em><sup><em>j</em></sup> (given a dense sampling of <em>b</em><sup><em>j</em></sup>). In this carefully controlled setting (1D signals, small training dataset, gradient descent with small learning rate, very wide networks), we find that this optimized mapping also achieves the best performance when training networks. Please refer to Appendix A.1 for details and experiments.</p>
<p>In real-world problems, especially in multiple dimensions, it is not feasible to use a feature mapping that densely samples Fourier basis functions; the number of Fourier basis functions scales with the number of training data points, which grows exponentially with dimension. Instead, we sample a set of random Fourier features [34] from a parametric distribution. We find that the exact sampling distribution family is much less important than the distribution's scale (standard deviation).</p>
<p>Figure 4 demonstrates this point using hyperparameter sweeps for a variety of sampling distributions. In each subfigure, we draw 1D target signals (<em>c</em> = 2, <em>n</em> = 1024) from a fixed 1/<em>f</em><sup><em>n</em></sup> distribution and train networks to learn them. We use random Fourier feature mappings (of length 16) sampled from different distribution families (Gaussian, uniform, uniform in log space, and Laplacian) and sweep over each distribution's scale. Perhaps surprisingly, the standard deviation of the sampled frequencies alone is enough to predict test set performance, regardless of the underlying distribution's shape. We show that this holds for higher-dimensional tasks in Appendix A.4. We also observe that passing this sparse sampling of Fourier features through an MLP matches the performance of using a dense set of Fourier features with the same MLP, suggesting a strategy for scaling to higher dimensions. We</p>
<p><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 4: We find that a sparse random sampling of Fourier features can perform as well as a dense set of features and that the width of the distribution matters more than the shape. Here, we generate random 1D signals from $1 / f^{\alpha}$ noise and report the test-set accuracy of different trained models that use a sparse set (16 out of 1024) of random Fourier features sampled from different distributions. Each subplot represents a different family of 1D signals. Each dot represents a trained network, where the color indicates which Fourier feature sampling distribution is used. We plot the test error of each model versus the empirical standard deviation of its sampled frequencies. The best models using sparsely sampled features are able to match the performance of a model trained with dense Fourier features (dashed lines with error bars). All sampling distributions trace out the same curve, exhibiting underfitting (slow convergence) when the standard deviation of sampled frequencies is too low and overfitting when it is too high. This implies that the precise shape of the distribution used to sample frequencies does not have a significant impact on performance.
proceed with a Gaussian distribution for our higher-dimensional experiments in Section 6 and treat the scale as a hyperparameter to tune on a validation dataset.</p>
<h1>6 Experiments</h1>
<p>We validate the benefits of using Fourier feature mappings for coordinate-based MLPs with experiments on a variety of regression tasks relevant to the computer vision and graphics communities.</p>
<h3>6.1 Compared mappings</h3>
<p>In Table 1, we compare the performance of coordinate-based MLPs with no input mapping and with the following Fourier feature mappings ( $\cos , \sin$ are applied elementwise):
Basic: $\gamma(\mathbf{v})=[\cos (2 \pi \mathbf{v} v), \sin (2 \pi \mathbf{v})]^{\mathrm{T}}$. Simply wraps input coordinates around the circle.
Positional encoding: $\gamma(\mathbf{v})=\left[\ldots, \cos \left(2 \pi \sigma^{j / m} \mathbf{v}\right), \sin \left(2 \pi \sigma^{j / m} \mathbf{v}\right), \ldots\right]^{\mathrm{T}}$ for $j=0, \ldots, m-1$. Uses log-linear spaced frequencies for each dimension, where the scale $\sigma$ is chosen for each task and dataset by a hyperparameter sweep. This is a generalization of the "positional encoding" used by prior work [27, 39, 44]. Note that this mapping is deterministic and only contains on-axis frequencies, making it naturally biased towards data that has more frequency content along the axes.
Gaussian: $\gamma(\mathbf{v})=[\cos (2 \pi \mathbf{B} \mathbf{v}), \sin (2 \pi \mathbf{B} \mathbf{v})]^{\mathrm{T}}$, where each entry in $\mathbf{B} \in \mathbb{R}^{m \times d}$ is sampled from $\mathcal{N}\left(0, \sigma^{2}\right)$, and $\sigma$ is chosen for each task and dataset with a hyperparameter sweep. In the absence of any strong prior on the frequency spectrum of the signal, we use an isotropic Gaussian distribution.
Our experiments show that all of the Fourier feature mappings improve the performance of coordinatebased MLPs over using no mapping and that the Gaussian RFF mapping performs best.</p>
<h3>6.2 Tasks</h3>
<p>We conduct experiments with direct regression, where supervision labels are in the same space as the network outputs, as well as indirect regression, where the network outputs are passed through a forward model to produce observations in the same space as the supervision labels (Appendix D contains a theoretical analysis of indirect regression through a linear forward model). For each task and dataset, we tune Fourier feature scales on a held-out set of signals. For each target signal, we train an MLP on a training subset of the signal and compute error over the remaining test subset. All tasks</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: center;">Direct supervision</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Indirect supervision</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;">2D image</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">3D shape [24]</td>
<td style="text-align: center;">2D CT</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">3D MRI</td>
<td style="text-align: center;">3D NeRF [27]</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;">Natural</td>
<td style="text-align: center;">Text</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Shepp</td>
<td style="text-align: center;">ATLAS</td>
<td style="text-align: center;">ATLAS</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">No mapping</td>
<td style="text-align: center;">19.32</td>
<td style="text-align: center;">18.40</td>
<td style="text-align: center;">0.864</td>
<td style="text-align: center;">16.75</td>
<td style="text-align: center;">15.44</td>
<td style="text-align: center;">26.14</td>
<td style="text-align: center;">22.41</td>
</tr>
<tr>
<td style="text-align: left;">Basic</td>
<td style="text-align: center;">21.71</td>
<td style="text-align: center;">20.48</td>
<td style="text-align: center;">0.892</td>
<td style="text-align: center;">23.31</td>
<td style="text-align: center;">16.95</td>
<td style="text-align: center;">28.58</td>
<td style="text-align: center;">23.16</td>
</tr>
<tr>
<td style="text-align: left;">Positional enc.</td>
<td style="text-align: center;">24.95</td>
<td style="text-align: center;">27.57</td>
<td style="text-align: center;">0.960</td>
<td style="text-align: center;">26.89</td>
<td style="text-align: center;">19.55</td>
<td style="text-align: center;">32.23</td>
<td style="text-align: center;">25.28</td>
</tr>
<tr>
<td style="text-align: left;">Gaussian</td>
<td style="text-align: center;">$\mathbf{2 5 . 5 7}$</td>
<td style="text-align: center;">$\mathbf{3 0 . 4 7}$</td>
<td style="text-align: center;">$\mathbf{0 . 9 7 3}$</td>
<td style="text-align: center;">$\mathbf{2 8 . 3 3}$</td>
<td style="text-align: center;">$\mathbf{1 9 . 8 8}$</td>
<td style="text-align: center;">$\mathbf{3 4 . 5 1}$</td>
<td style="text-align: center;">$\mathbf{2 5 . 4 8}$</td>
</tr>
</tbody>
</table>
<p>Table 1: We compare four different input mappings on a variety of low-dimensional regression tasks. All results are reported in PSNR except 3D shape, which uses IoU (higher is better for all). No mapping represents using a standard MLP with no feature mapping. Basic, Positional encoding, and Gaussian are different variants of Fourier feature maps. For the Direct supervision tasks, the network is supervised using ground truth labels for each input coordinate. For the Indirect supervision tasks, the network outputs are passed through a forward model before the loss is applied (integral projection for CT, the Fourier transform for MRI, and nonlinear volume rendering for NeRF). Fourier feature mappings improve results across all tasks, with random Gaussian features performing best.
(except 3D shape regression) use L2 loss and a ReLU MLP with 4 layers and 256 channels. The 3D shape regression task uses cross-entropy loss and a ReLU MLP with 8 layers and 256 channels. We apply a sigmoid activation to the output for each task (except the view synthesis density prediction). We use 256 frequencies for the feature mapping in all experiments (see Appendix A. 2 for experiments that investigate the effects of network depth and feature mapping sparsity). Appendix E provides additional details on each task and our implementations, and Appendix F shows more result figures.
2D image regression. In this task, we train an MLP to regress from a 2D input pixel coordinate to the corresponding RGB value of an image. For each test image, we train an MLP on a regularly-spaced grid containing $1 / 4$ of the pixels and report test error on the remaining pixels. We compare input mappings over a dataset of natural images and a dataset of text images.
3D shape regression. Occupancy Networks [24] implicitly represent a 3D shape as the "decision boundary" of an MLP, which is trained to output 0 for points outside the shape and 1 for points inside the shape. Each batch of training data is generated by sampling points uniformly at random from the bounding box of the shape and calculating their labels using the ground truth mesh. Test error is calculated using intersection-over-union versus ground truth on a set of points randomly sampled near the mesh surface to better highlight the different mappings' abilities to resolve fine details.
2D computed tomography (CT). In CT, we observe integral projections of a density field instead of direct measurements. In our 2D CT experiments, we train an MLP that takes in a 2D pixel coordinate and predicts the corresponding volume density at that location. The network is indirectly supervised by the loss between a sparse set of ground-truth integral projections and integral projections computed from the network's output. We conduct experiments using two datasets: procedurally-generated Shepp-Logan phantoms [36] and 2D brain images from the ATLAS dataset [21].
3D magnetic resonance imaging (MRI). In MRI, we observe Fourier transform coefficients of atomic response to radio waves under a magnetic field. In our 3D MRI experiments, we train an MLP that takes in a 3D voxel coordinate and predicts the corresponding response at that location. The network is indirectly supervised by the loss between a sparse set of ground-truth Fourier transform coefficients and Fourier transform coefficients computed from discretely querying the MLP on a voxel grid. We conduct experiments using the ATLAS dataset [21].
3D inverse rendering for view synthesis. In view synthesis, we observe 2D photographs of a 3D scene, reconstruct a representation of that scene, then render images from new viewpoints. To perform this task, we train a coordinate-based MLP that takes in a 3D location and outputs a color and volume density. This MLP is indirectly supervised by the loss between the set of 2D image observations and the same viewpoints re-rendered from the predicted scene representation. We use a simplified version of the method described in NeRF [27], where we remove hierarchical sampling and view dependence and replace the original positional encoding with our compared input mappings.</p>
<h1>7 Conclusion</h1>
<p>We leverage NTK theory to show that a Fourier feature mapping can make coordinate-based MLPs better suited for modeling functions in low dimensions, thereby overcoming the spectral bias inherent in coordinate-based MLPs. We experimentally show that tuning the Fourier feature parameters offers control over the frequency falloff of the combined NTK and significantly improves performance across a range of graphics and imaging tasks. These findings shed light on the burgeoning technique of using coordinate-based MLPs to represent 3D shapes in computer vision and graphics pipelines, and provide a simple strategy for practitioners to improve results in these domains.</p>
<h2>Acknowledgements</h2>
<p>We thank Ben Recht for advice, and Cecilia Zhang and Tim Brooks for their comments on the text. BM is funded by a Hertz Foundation Fellowship and acknowledges support from the Google BAIR Commons program. MT, PS and SFK are funded by NSF Graduate Fellowships. RR was supported in part by ONR grants N000141712687 and N000142012529 and the Ronald L. Graham Chair. RN was supported in part by an FHL Vive Center Seed Grant. Google University Relations provided a generous donation of compute credits.</p>
<h2>References</h2>
<p>[1] Eirikur Agustsson and Radu Timofte. NTIRE 2017 challenge on single image super-resolution: Dataset and study. CVPR Workshops, 2017.
[2] Sanjeev Arora, Simon Du, Wei Hu, Zhiyuan Li, and Ruosong Wang. Fine-grained analysis of optimization and generalization for overparameterized two-layer neural networks. ICML, 2019.
[3] Ronen Basri, Meirav Galun, Amnon Geifman, David Jacobs, Yoni Kasten, and Shira Kritchman. Frequency bias in neural networks for input of non-uniform density. arXiv preprint arXiv:2003.04560, 2020.
[4] Ronen Basri, David Jacobs, Yoni Kasten, and Shira Kritchman. The convergence rate of neural networks for learned functions of different frequencies. NeurIPS, 2019.
[5] Alberto Bietti and Julien Mairal. On the inductive bias of neural tangent kernels. NeurIPS, 2019.
[6] Blake Bordelon, Abdulkadir Canatar, and Cengiz Pehlevan. Spectrum dependent learning curves in kernel regression and wide neural networks. arXiv preprint arXiv:2002.02561, 2020.
[7] R. N. Bracewell. Strip integration in radio astronomy. Australian Journal of Physics, 1956.
[8] James Bradbury, Roy Frostig, Peter Hawkins, Matthew James Johnson, Chris Leary, Dougal Maclaurin, and Skye Wanderman-Milne. JAX: composable transformations of Python+NumPy programs, 2018. http://github.com/google/jax.
[9] Zhiqin Chen and Hao Zhang. Learning implicit fields for generative shape modeling. CVPR, 2019.
[10] Boyang Deng, JP Lewis, Timothy Jeruzalski, Gerard Pons-Moll, Geoffrey Hinton, Mohammad Norouzi, and Andrea Tagliasacchi. Neural articulated shape approximation. arXiv preprint arXiv:1912.03207, 2019.
[11] Simon S. Du, Xiyu Zhai, Barnabas Poczos, and Aarti Singh. Gradient descent provably optimizes over-parameterized neural networks. ICLR, 2019.
[12] Kyle Genova, Forrester Cole, Aaron Sarna Daniel Vlasic, William T. Freeman, and Thomas Funkhouser. Learning shape templates with structured implicit functions. ICCV, 2019.
[13] Kyle Genova, Forrester Cole, Avneesh Sud, Aaron Sarna, and Thomas Funkhouser. Local deep implicit functions for 3D shape. CVPR, 2020.
[14] Reinhard Heckel and Mahdi Soltanolkotabi. Compressive sensing with un-trained neural networks: Gradient descent finds the smoothest approximation. arXiv preprint arXiv:2005.03991, 2020.</p>
<p>[15] Philipp Henzler, Niloy J Mitra, and Tobias Ritschel. Learning a neural 3d texture space from 2d exemplars. CVPR, 2020.
[16] Arthur Jacot, Franck Gabriel, and Clément Hongler. Neural Tangent Kernel: Convergence and generalization in neural networks. NeurIPS, 2018.
[17] Chiyu Jiang, Avneesh Sud, Ameesh Makadia, Jingwei Huang, Matthias Nießner, and Thomas Funkhouser. Local implicit grid representations for 3D scenes. CVPR, 2020.
[18] Seyed Mehran Kazemi, Rishab Goel, Sepehr Eghbali, Janahan Ramanan, Jaspreet Sahota, Sanjay Thakur, Stella Wu, Cathal Smyth, Pascal Poupart, and Marcus Brubaker. Time2vec: Learning a vector representation of time. arXiv preprint arXiv:1907.05321, 2019.
[19] Diederik P. Kingma and Jimmy Ba. Adam: A method for stochastic optimization. ICLR, 2015.
[20] Jaehoon Lee, Lechao Xiao, Samuel Schoenholz, Yasaman Bahri, Roman Novak, Jascha SohlDickstein, and Jeffrey Pennington. Wide neural networks of any depth evolve as linear models under gradient descent. NeurIPS, 2019.
[21] Sook-Lei Liew, Julia M. Anglin, Nick W. Banks, Matt Sondag, Kaori L. Ito, Kim, et al. A large, open source dataset of stroke anatomical brain images and manual lesion segmentations. Scientific Data, 2018.
[22] Shaohui Liu, Yinda Zhang, Songyou Peng, Boxin Shi, Marc Pollefeys, and Zhaopeng Cui. Dist: Rendering deep implicit signed distance function with differentiable sphere tracing. CVPR, 2020.
[23] Shichen Liu, Shunsuke Saito, Weikai Chen, and Hao Li. Learning to infer implicit surfaces without 3D supervision. NeurIPS, 2019.
[24] Lars Mescheder, Michael Oechsle, Michael Niemeyer, Sebastian Nowozin, and Andreas Geiger. Occupancy networks: Learning 3D reconstruction in function space. CVPR, 2019.
[25] Michael Dawson-Haggerty et al. trimesh, 2019. https://trimsh.org/.
[26] Mateusz Michalkiewicz, Jhony K Pontes, Dominic Jack, Mahsa Baktashmotlagh, and Anders Eriksson. Implicit surface representations as layers in neural networks. ICCV, 2019.
[27] Ben Mildenhall, Pratul P Srinivasan, Matthew Tancik, Jonathan T. Barron, Ravi Ramamoorthi, and Ren Ng. NeRF: Representing scenes as neural radiance fields for view synthesis. arXiv preprint arXiv:2003.08934, 2020.
[28] Anh Nguyen, Jason Yosinski, and Jeff Clune. Deep neural networks are easily fooled: High confidence predictions for unrecognizable images. CVPR, 2015.
[29] Michael Niemeyer, Lars Mescheder, Michael Oechsle, and Andreas Geiger. Differentiable volumetric rendering: Learning implicit 3D representations without 3D supervision. CVPR, 2020.
[30] Roman Novak, Lechao Xiao, Jiri Hron, Jaehoon Lee, Alexander A. Alemi, Jascha SohlDickstein, and Samuel S. Schoenholz. Neural tangents: Fast and easy infinite neural networks in Python. ICLR, 2020.
[31] Michael Oechsle, Lars Mescheder, Michael Niemeyer, Thilo Strauss, and Andreas Geiger. Texture fields: Learning texture representations in function space. ICCV, 2019.
[32] Jeong Joon Park, Peter Florence, Julian Straub, Richard Newcombe, and Steven Lovegrove. DeepSDF: Learning continuous signed distance functions for shape representation. CVPR, 2019.
[33] Nasim Rahaman, Aristide Baratin, Devansh Arpit, Felix Draxler, Min Lin, Fred A. Hamprecht, Yoshua Bengio, and Aaron Courville. On the spectral bias of neural networks. ICML, 2019.
[34] Ali Rahimi and Benjamin Recht. Random features for large-scale kernel machines. NeurIPS, 2007.
[35] Shunsuke Saito, , Zeng Huang, Ryota Natsume, Shigeo Morishima, Angjoo Kanazawa, and Hao Li. PIFu: Pixel-aligned implicit function for high-resolution clothed human digitization. ICCV, 2019.
[36] Lawrence A. Shepp and Benjamin F. Logan. The Fourier reconstruction of a head section. IEEE Transactions on nuclear science, 1974.</p>
<p>[37] Vincent Sitzmann, Michael Zollhoefer, and Gordon Wetzstein. Scene representation networks: Continuous 3D-structure-aware neural scene representations. NeurIPS, 2019.
[38] Kenneth O. Stanley. Compositional pattern producing networks: A novel abstraction of development. Genetic Programming and Evolvable Machines, 2007.
[39] Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Łukasz Kaiser, and Illia Polosukhin. Attention is all you need. NeurIPS, 2017.
[40] Martin J. Wainwright. Reproducing Kernel Hilbert Spaces, page 383-415. Cambridge Series in Statistical and Probabilistic Mathematics. Cambridge University Press, 2019.
[41] Ingo Wald, Sven Woop, Carsten Benthin, Gregory S Johnson, and Manfred Ernst. Embree: a kernel framework for efficient CPU ray tracing. ACM Transactions on Graphics (TOG), 2014.
[42] Da Xu, Chuanwei Ruan, Evren Korpeoglu, Sushant Kumar, and Kannan Achan. Self-attention with functional time representation learning. NeurIPS, 2019.
[43] Greg Yang and Hadi Salman. A fine-grained spectral perspective on neural networks. arXiv preprint arXiv:1907.10599, 2019.
[44] Ellen D. Zhong, Tristan Bepler, Joseph H. Davis, and Bonnie Berger. Reconstructing continuous distributions of 3D protein structure from cryo-EM images. ICLR, 2020.</p>
<h1>A Further experiments</h1>
<h2>A. 1 Optimizing validation error through the NTK linear dynamics</h2>
<p>Using Eqn. 3 in the main paper, we can predict what error a trained network will achieve on a set of testing points. Since this equation depends on the composed NTK, we can directly relate predicted test set loss to the Fourier feature mapping parameters $a$ and $b$ for a validation set of signals $\mathbf{y}_{\text {val }}$ :</p>
<p>$$
\mathcal{L}<em _mathrm_val="\mathrm{val">{\mathrm{opt}}=\left|\mathbf{u}^{(t)}-\mathbf{y}</em>\right|}<em _mathrm_val="\mathrm{val">{2}^{2} \approx\left|\mathbf{K}</em>}} \mathbf{K}^{-1}\left(\mathbf{I}-e^{-\eta \mathbf{K} t}\right) \mathbf{y}-\mathbf{y<em 2="2">{\mathrm{val}}\right|</em>
$$}^{2</p>
<p>where $\mathbf{K}<em _text="\text" _val="{val">{\text {val }}$ is the composed NTK evaluated between points in a validation dataset $\mathbf{X}</em>$, and $\eta$ and $t$ are the learning rate and number of iterations that will be used when training the actual network.}}$ and training dataset $\mathbf{X</p>
<p>In Figure 5, we show the results of minimizing Eqn. 10 by gradient descent on $a_{j}$ values (with fixed corresponding "densely sampled" $b_{j}=j$ ) for validation sets sampled from three different $1 / f^{\alpha}$ noise families. Note that gradient descent on this theoretical loss approximation produces $a_{j}$ values which are able to perform as well as the best "power law" $a_{j}$ values for each respective signal class (compared dashed lines versus $\times$ markers in Figure 5b). As mentioned in the main text, we find that this optimization strategy is only viable for small 1D regression problems. In our multidimensional tasks, using densely sampled $\mathbf{b}_{j}$ values is not tractable due to memory constraints. In addition, the theoretical approximation only holds when training the network using SGD, and in practice we train using the Adam optimizer [19].
<img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 5: The Fourier feature mappings can be optimized for better performance on a class of target signals by using the linearized network approximation. Here we consider target signals sampled from three different power law distributions. In (a) we show the spectrum for composed kernels corresponding to different optimized feature mappings, where the feature mappings are initialized to match the "Power $\infty$ " distribution. In (b) we take an alternative approach where we sweep over "power law" settings for our Fourier features. We find that tuning this simple parameterization is able to perform on par with the optimized feature maps.</p>
<h2>A. 2 Feature sparsity and network depth</h2>
<p>In our experiments, we observe that deeper networks need fewer Fourier features than shallow networks. As the depth of the MLP increases, we observe that a sparser set of frequencies can achieve similar performance; Figure 6 illustrates this effect in the context of 2D image regression.</p>
<p>Again drawing on NTK theory, we understand this tradeoff as an effect of frequency "spreading," as illustrated in Figure 7. A Fourier featurization consists of only discrete frequencies, but when composed with the NTK, the influence of each discrete frequency "spreads" over its local neighborhood in the final spectrum. We find that the "spread" around each frequency feature increases for deeper networks. For an MLP to learn all of the frequency components in the target signal, its corresponding composed NTK must contain adequate power across the frequency support of the target signal. This is accomplished either by including more frequencies in the Fourier features or by spreading those frequencies through sufficient NTK depth.</p>
<p><img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>Figure 6: In a 2D image regression task (explained in Section E.1) we find that shallower networks require more Fourier features than deeper networks. This is explained by the frequency spreading effect shown in Figure 7. In this experiment we use the Natural image dataset and a Gaussian mapping. All of the network layers have 256 channels, and the networks are trained using an Adam [19] optimizer with a learning rate of $10^{-3}$.
<img alt="img-6.jpeg" src="img-6.jpeg" /></p>
<p>Figure 7: Each frequency included in a Fourier embedding is "spread" by the NTK, with deeper NTKs causing more frequency spreading. We posit that this frequency spreading is what enables an MLP with a sparse set of Fourier features to faithfully reconstruct a complex signal, which would be poorly reconstructed by either sparse Fourier feature regression or a plain coordinate-based MLP.</p>
<h1>A. 3 Gradient descent does not optimize Fourier features</h1>
<p>One may wonder if the Fourier feature mapping parameters $a_{j}$ and $\mathbf{b}<em j="j">{j}$ can be optimized alongside network weights using gradient descent, which may circumvent the need for careful initialization. We performed an experiment in which the $a</em>$ values are treated as trainable variables (along with the weights of the network) and optimize all variables with Adam to minimize training loss. Figure 8 shows that jointly optimizing these parameters does not improve performance compared to leaving them fixed.
}, \mathbf{b}_{j<img alt="img-7.jpeg" src="img-7.jpeg" /></p>
<p>Figure 8: "Training" the Fourier feature mapping parameters $a_{j}$ and $\mathbf{b}<em j="j">{j}$ along with the network weights using Adam does not improve performance, as the $\mathbf{b}</em>}$ values do not deviate significantly from their initial values. We show that this holds when $\mathbf{b<em j="j">{j}$ are initialized at three different scales of Gaussian Fourier features in the case of the 2D image task ( $a</em>$ are always initialized as 1 ).</p>
<h1>A. 4 Visualizing underfitting and overfitting in 2D</h1>
<p>Figure 4 in the main text shows (in a 1D setting) that as the scale of the Fourier feature sampling distribution increases, the trained network's error traces out a curve that starts in an underfitting regime (only low frequencies are learned) and ends in an overfitting regime (the learned function includes high-frequency detail not present in the training data). In Figure 9, we show analogous behavior for 2D image regression, demonstrating that the same phenomenon holds in a multidimensional problem. In Figure 10, we show how changing the scale for Gaussian Fourier features qualitatively affects the final result in the 2D image regression task.
<img alt="img-8.jpeg" src="img-8.jpeg" /></p>
<p>Figure 9: An alternate version of Figure 4 from the main text where the underlying signal is a 2D image (see 2D image task details in Section E.1) instead of 1D signal. This multi-dimensional case exhibits the same behavior as was seen in the 1D case: we see the same underfitting/overfitting pattern for four different isotropic Fourier feature distributions, and the distribution shape matters less than the scale of sampled $b_{i}$ values.
<img alt="img-9.jpeg" src="img-9.jpeg" /></p>
<p>Figure 10: A visualization of the 2D image regression task with different Gaussian scales (corresponding to points along the curve shown in Figure 9). Low values of $\sigma$ underfit, resulting in oversmoothed interpolation, and large values of $\sigma$ overfit, resulting in noisy interpolation. We find that $\sigma=10$ performs best for our Natural image dataset.</p>
<h2>A. 5 Failures of positional encoding (axis-aligned bias)</h2>
<p>Here we present a simple experiment to directly showcase the benefits of using an isotropic frequency distribution, such as Gaussian RFF, compared to the axis-aligned "positional encoding" used in prior work [27, 44]. As discussed in the main paper, the positional encoding mapping only uses on-axis frequencies. This approach is well-suited to data that has more frequency content along the coordinate axes, but is not as effective for more natural signals.
In Figure 11, we conduct a simple 2D image experiment where we train a coordinate-based MLP (2 layers, 256 channels) to fit target 2D sinusoid images ( $512 \times 512$ resolution). We sample 64 such 2D sinusoid images (regularly-sampled in polar coordinates, with 16 angles and 4 radii) and train a 2D coordinate-based MLP to fit each, using the same setup as the 2D image experiments described in Section E.1. The isotropic Gaussian RFF mapping performs well across all angles, while the positional encoding mapping performs worse for frequencies that are not axis-aligned.</p>
<p><img alt="img-10.jpeg" src="img-10.jpeg" /></p>
<p>Figure 11: We train a coordinate-based MLP to fit target 2D images consisting of simple sinusoids at different frequencies and angles. The positional encoding mapping performs well at on-axis angles and performs worse on off-axis angles, while the Gaussian RFF mapping performs similarly well across all angles (results are averaged over radii). Error bars are plotted over runs with different randomly-sampled frequencies for the Gaussian RFF mapping, while positional encoding is deterministic.</p>
<h1>B Additional details for main text figures</h1>
<h2>B. 1 Main text Figure 3 (effect of feature mapping on convergence speed)</h2>
<p>In Figure 12, we present an alternate version of Figure 3 from the main text showing a denser sampling of $p$ values to better visualize the effect of changing Fourier feature falloff on the resulting trained network. Again, the feature mapping used here is $a_{j}=1 / j^{p}, b_{j}=j$ for $j=1, \ldots, n / 2$.
<img alt="img-11.jpeg" src="img-11.jpeg" /></p>
<p>Figure 12: An extension of Figure 3 from the main paper, showing more values of $p$. In (c) we see that mappings with more gradual frequency falloff (lower $p$ ) converge significantly faster in mid and high frequencies, resulting in faster overall training convergence (d). In (b) we see that $p=1$ achieves a lower test error than the other mappings.</p>
<h2>B. 2 Main text Figure 4 (different random feature distributions in 1D)</h2>
<p>Exact details for the sampling distributions used to generate $b_{j}$ values for Figure 4 in the main text are shown in Table 2. In Figure 13, we present an alternate version showing both train and test performance, emphasizing the underfitting/overfitting regimes created by manipulating the scale of the Fourier features.</p>
<p>Uniform log distribution We include the Uniform log distribution because it is the random equivalent of the "positional encoding" sometimes used in prior work. One observation is that the sampling</p>
<p>for uniform- $\log$ variables $\left(X^{\prime}=\sigma_{u l}^{X}\right.$ where $\left.X \sim \mathcal{U}[0,1)\right)$ corresponds to the following CDF:</p>
<p>$$
P\left(X^{\prime} \leq x\right)=\frac{\log x}{\log \sigma_{u l}}, \quad \text { for } x \in\left[1, \sigma_{u l}\right)
$$</p>
<p>which has the following PDF:</p>
<p>$$
p(x)=\frac{d}{d x} P\left(X^{\prime} \leq x\right)=\frac{1}{x \log \sigma_{u l}}
$$</p>
<p>This shows that the randomized equivalent of positional encoding is sampling from a distribution proportional to a $1 / f$ falloff power law.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: center;">Sampled $b_{j}$ values</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Gaussian</td>
<td style="text-align: center;">$\sigma_{g} X$ for $X \sim \mathcal{N}(0,1)$</td>
</tr>
<tr>
<td style="text-align: left;">Uniform</td>
<td style="text-align: center;">$\sigma_{u} X$ for $X \sim \mathcal{U}[0,1)$</td>
</tr>
<tr>
<td style="text-align: left;">Uniform log</td>
<td style="text-align: center;">$\sigma_{u l}^{X}$ for $X \sim \mathcal{U}[0,1)$</td>
</tr>
<tr>
<td style="text-align: left;">Laplacian</td>
<td style="text-align: center;">$\sigma_{l} X$ for $X \sim \operatorname{Laplace}(0,1)$</td>
</tr>
<tr>
<td style="text-align: left;">Positional Enc.</td>
<td style="text-align: center;">$2^{\sigma_{p} X}$ for $X \in \operatorname{linspace}(0,1)$ (deterministic)</td>
</tr>
</tbody>
</table>
<p>Table 2: Different distributions used for sampling frequencies, where $\sigma$ is each distribution's "scale".
<img alt="img-12.jpeg" src="img-12.jpeg" /></p>
<p>Figure 13: An alternate version of Figure 4 from the main text showing both training error and test error for a variety of different Fourier feature sampling distributions. Adding training error to the plot clearly distinguishes between the underfitting regime with low frequency $b_{i}$ (where train and test error are similar) versus the overfitting regime with high frequency $b_{i}$ (where the test error increases but training error approaches machine precision).</p>
<h1>C Stationary kernels</h1>
<p>One of the primary benefits of our Fourier feature mapping is that it results in a stationary composed NTK function. In this section, we offer some intuition for why stationarity is desirable for our low-dimensional graphics and imaging problems.
First, let us consider the implications of using an MLP applied directly to a low-dimensional input (without any Fourier feature mapping). In this setting, the NTK is a function of the dot product between its inputs and of their norms [3, 5, 6, 16]. This makes the NTK rotation-invariant, but not translation-invariant. For our graphics and imaging applications, we want to be able to model an object or scene equally well regardless of its location, so translation-invariance or stationarity is a crucial property. We can then add approximate rotation invariance back by using an isotropic frequency sampling distribution.
This aligns with standard practice in signal processing, in which $k(\mathbf{u}, \mathbf{v})=\tilde{h}(\mathbf{u}-\mathbf{v})=\tilde{h}(\mathbf{v}-\mathbf{u})$ (e.g. the Gaussian or radial basis function kernel, or the sinc reconstruction filter kernel). This Euclidean notion of similarity based on difference vectors is better suited to the low-dimensional regime, in which we expect (and can afford) dense and nearly uniform sampling. Regression with a stationary kernel corresponds to reconstruction with a convolution filter: new predictions are sums of training points, weighted by a function of Euclidean distance.
One of the most important features of our sinusoidal input mapping is that it translates between these two regimes. If $\mathbf{u}, \mathbf{v} \in \mathbb{R}^{d}$ for small $d, \gamma$ is our Fourier feature embedding function, and $k$ is a dot</p>
<p>product kernel function, then $k(\gamma(\mathbf{u}),\gamma(\mathbf{v}))=h(\gamma(\mathbf{u})^{\mathrm{T}}\gamma(\mathbf{v}))=\tilde{h}(\mathbf{u}-\mathbf{v})$. In words, our sinusoidal input mapping transforms a dot product kernel into a stationary one, making it better suited to the low-dimensional regime.</p>
<p>This effect is illustrated in a simple 1D example in Figure 14, which shows that the benefits of a stationary composed NTK indeed appear in the MLP setting with a basic Fourier featurization (using a single frequency). We train MLPs with and without this basic Fourier embedding to learn a set of shifted 1D Gaussian probability density functions. The plain MLP successfully fits a zero-centered function but struggles to fit shifted functions, while the MLP with basic Fourier embedding exhibits stationary behavior, with good performance regardless of shifts.
<img alt="img-13.jpeg" src="img-13.jpeg" /></p>
<p>Figure 14: A plain coordinate-based MLP can learn a centered function (in this case a Gaussian density) but struggles to model shifts of the same function. Adding a basic Fourier embedding (with a single frequency) enables the MLP to fit the target function equally well regardless of shifts. The NTK corresponding to the plain MLP is based on dot products between inputs, whereas the NTK corresponding to the NTK with Fourier embedding is based on Euclidean distances between inputs, making it shift-invariant. In this experiment we train an MLP (4 layers, 256 channels, ReLU activation) for 500 iterations using the Adam [19] optimizer with a learning rate of $10^{-4}$. We report mean and standard deviation performance over 20 random network initializations.</p>
<h1>D Indirect supervision through a linear map</h1>
<p>In some of the tasks we explore in this work, such as image regression or 3D shape regression, optimization is performed by minimizing a loss between the output of a network and a directly observed quantity, such as the color of a pixel or the occupancy of a voxel. But in many graphics and imaging applications of interest, measurements are indirect, and the loss must be computed on the output of a network after it has been processed by some physical forward model. In NeRF [27], measurements are taken by sampling and compositing along rays in each viewing direction. In MRI, measurements are taken along various curves through the frequency domain. In CT, measurements are integral projections of the subject at various angles, which correspond to measuring lines through the origin in the frequency domain. Although the measurement transformation for NeRF is nonlinear (in density, although it is linear in color), those for both CT and MRI are linear. In this section, we extend the linearized training dynamics of Lee et al. [20] to the setting of training through a linear operator denoted by a matrix $\mathbf{A}$. This allows us to modify Eqn. 3 to incorporate $\mathbf{A}$, thereby demonstrating that the conclusions drawn in this work for the "direct" regression case also apply to the "indirect" case.</p>
<p>Our derivation closely follows Lee et al. [20], and begins by replacing the neural network $f$ with its linearization around the initial parameters $\theta_{0}$ :</p>
<p>$$
f_{t}^{\text {lin }}(\mathbf{x}) \triangleq f_{0}(\mathbf{x})+\left.\nabla_{\theta} f_{0}(\mathbf{x})\right|<em 0="0">{\theta=\theta</em>
$$}} \omega_{t</p>
<p>where $\omega_{t} \triangleq \theta_{t}-\theta_{0}$ denotes the change in network parameters since initialization and $t$ denotes time in continuous-time gradient flow dynamics. Then [20] describes the dynamics of gradient flow:</p>
<p>$$
\dot{f}<em 0="0">{t}^{\text {lin }}(\mathbf{x})=-\eta \hat{\Theta}</em>
$$}(\mathbf{x}, \mathbf{X}) \nabla_{f_{t}^{\text {lin }}(\mathbf{X})} \mathcal{L</p>
<p>where $\hat{\Theta}<em _theta="\theta">{t}(\cdot, \cdot)=\nabla</em>} f_{t}(\cdot) \nabla_{\theta} f_{t}(\cdot)^{\mathrm{T}}$ is the NTK matrix at time $t$ ( $\hat{\Theta<em t="t">{t}$ is shorthand for $\hat{\Theta}</em>$ is the training loss. At this point, we depart slightly from the analysis of [20]: instead of}(\mathbf{X}, \mathbf{X})$ ) and $\mathcal{L</p>
<p>$\mathcal{L}=\sum_{(\mathbf{x}, y) \in \mathcal{D}} \ell\left(f_{t}^{\operatorname{lin}}(\mathbf{x}), y\right)$ we have $\mathcal{L}=\frac{1}{2}\left|\mathbf{A}\left(f_{t}^{\operatorname{lin}}(\mathbf{X})-\mathbf{y}\right)\right|_{2}^{2}$, where $\mathbf{y}$ denotes the vector of training labels. The gradient of the loss is then</p>
<p>$$
\begin{aligned}
\nabla_{f_{t}^{\operatorname{lin}}(\mathbf{X})} \mathcal{L} &amp; =\nabla_{f_{t}^{\operatorname{lin}}(\mathbf{X})} \frac{1}{2}\left|\mathbf{A}\left(f_{t}^{\operatorname{lin}}(\mathbf{X})-\mathbf{y}\right)\right|<em t="t">{2}^{2} \
&amp; =\mathbf{A}^{\mathrm{T}} \mathbf{A}\left(f</em>\right)
\end{aligned}
$$}^{\operatorname{lin}}(\mathbf{X})-\mathbf{y</p>
<p>Substituting this into the gradient flow dynamics of Eqn. 14 gives us:</p>
<p>$$
\dot{f}<em 0="0">{t}^{\operatorname{lin}}(\mathbf{x})=-\eta \hat{\Theta}</em>\right)
$$}(\mathbf{x}, \mathbf{X}) \mathbf{A}^{\mathrm{T}} \mathbf{A}\left(f_{t}^{\operatorname{lin}}(\mathbf{X})-\mathbf{y</p>
<p>with corresponding solution:</p>
<p>$$
f_{t}^{\operatorname{lin}}(\mathbf{X})=\left(\mathbf{I}-e^{-\eta \hat{\Theta}<em 0="0">{0} \mathbf{A}^{\mathrm{T}} \mathbf{A} t}\right) \mathbf{y}+e^{-\eta \hat{\Theta}</em>)
$$} \mathbf{A}^{\mathrm{T}} \mathbf{A} t} f_{0}(\mathbf{X</p>
<p>Finally, again following [20], we can decompose $f_{t}^{\operatorname{lin}}(\mathbf{x})=\mu_{t}(\mathbf{x})+\gamma_{t}(\mathbf{x})$ at any test point $\mathbf{x}$, where</p>
<p>$$
\begin{aligned}
&amp; \mu_{t}(\mathbf{x})=\hat{\Theta}<em 0="0">{0}(\mathbf{x}, \mathbf{X}) \hat{\Theta}</em>}^{-1}\left(\mathbf{I}-e^{-\eta \hat{\Theta<em t="t">{0} \mathbf{A}^{\mathrm{T}} \mathbf{A} t}\right) \mathbf{y} \
&amp; \gamma</em>}(\mathbf{x})=f_{0}(\mathbf{x})-\hat{\Theta<em 0="0">{0}(\mathbf{x}, \mathbf{X}) \hat{\Theta}</em>}^{-1}\left(\mathbf{I}-e^{-\eta \hat{\Theta<em 0="0">{0} \mathbf{A}^{\mathrm{T}} \mathbf{A} t}\right) f</em>)
\end{aligned}
$$}(\mathbf{X</p>
<p>Assuming our initialization is small, i.e., $f_{0}(\mathbf{x}) \approx 0 \forall \mathbf{x}$, we can write our approximate linearized network output as:</p>
<p>$$
f_{t}^{\operatorname{lin}}(\mathbf{x}) \approx \hat{\Theta}<em 0="0">{0}(\mathbf{x}, \mathbf{X}) \hat{\Theta}</em>
$$}^{-1}\left(\mathbf{I}-e^{-\eta \hat{\Theta}_{0} \mathbf{A}^{\mathrm{T}} \mathbf{A} t}\right) \mathbf{y</p>
<p>In our previous analysis, we work instead with the expected or infinite-width NTK matrix $\mathbf{K}$, which is fixed throughout training. Using this notation, we have</p>
<p>$$
\dot{\mathbf{y}}^{(t)} \approx f_{t}^{\operatorname{lin}}\left(\mathbf{X}<em _test="{test" _text="\text">{\text {test }}\right) \approx \mathbf{K}</em>
$$}} \mathbf{K}^{-1}\left(\mathbf{I}-e^{-\eta \mathbf{K A}^{\mathrm{T}} \mathbf{A} t}\right) \mathbf{y</p>
<p>This is nearly identical to Eqn. 3in the main paper, except that the convergence is governed by the spectrum of $\mathbf{K A}^{\mathrm{T}} \mathbf{A}$ rather than $\mathbf{K}$ alone. If $\mathbf{A}$ is unitary, such as the Fourier transform matrix used in (densely sampled) MRI, then training should behave exactly as if we were training on direct measurements. However, if $\mathbf{A}$ is not full rank, then training will only affect the components with nonzero eigenvalues in $\mathbf{K} \mathbf{A}^{\mathrm{T}} \mathbf{A}$. In this more common scenario, we want to design a kernel that will provide large eigenvalues in the components that $\mathbf{A}$ can represent, so that the learnable components will converge quickly, and provide reasonable priors for the components we cannot learn.
In our two tasks that supervise through a linear map, CT and MRI, the $\mathbf{A}^{\mathrm{T}} \mathbf{A}$ has a structure that illuminates how the linear map interacts with the composed NTK. The $\mathbf{A}^{\mathrm{T}} \mathbf{A}$ matrices for both these tasks are diagonalizable by the DFT matrix, where the diagonal entries are simply the number of times the corresponding frequency is measured by the MRI or CT sampling patterns. This follows from the fact that CT and MRI measurements can both be formulated as Fourier space sampling: CT samples rotated slices in Fourier space through the origin [7] and MRI samples operator-chosen Fourier trajectories. This means that frequencies not observed by the MRI or CT sampling patterns will never be supervised during training. Therefore, it is crucial to choose a Fourier feature mapping that results in a composed NTK with a good prior on these frequencies.</p>
<h1>E Task details</h1>
<p>We present additional details for each task from Section 6 in the main text, including training parameters, forward models, datasets, etc. All experiments are implemented using JAX [8] and trained on a single K80 or RTX2080Ti GPU. Training a single MLP took between 10 seconds (for the 2D image task) and 30 minutes (for the inverse rendering task).</p>
<h2>E. 1 2D image</h2>
<p>The 2D image regression tasks presented in the main text all use $512 \times 512$ resolution images. A subsampled grid of $256 \times 256$ pixels is used as training data, and an offset grid of $256 \times 256$ pixels</p>
<p>is used for testing. We use two image datasets: Natural and Text, each consisting of 32 images. The Natural images are generated by taking center crops of randomly sampled images from the Div2K dataset [1]. The Text images are generated by placing random strings of text with random sizes and colors on a white background (examples can be seen in Figure 15). For each dataset we perform a hyperparameter sweep over feature mapping scales on 16 images. We find that scales $\sigma_{g}=10$ and $\sigma_{p}=6$ work best for the Natural dataset and $\sigma_{g}=14$ and $\sigma_{p}=5$ work best for the Text dataset (see Table 2 for mapping definitions). In Table 3, we report model performance using the optimal mapping scale on the remaining 16 images.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: center;">Natural</th>
<th style="text-align: center;">Text</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">No mapping</td>
<td style="text-align: center;">$19.32 \pm 2.48$</td>
<td style="text-align: center;">$18.40 \pm 2.23$</td>
</tr>
<tr>
<td style="text-align: left;">Basic</td>
<td style="text-align: center;">$21.71 \pm 2.71$</td>
<td style="text-align: center;">$20.48 \pm 1.96$</td>
</tr>
<tr>
<td style="text-align: left;">Positional enc.</td>
<td style="text-align: center;">$24.95 \pm 3.72$</td>
<td style="text-align: center;">$27.57 \pm 3.07$</td>
</tr>
<tr>
<td style="text-align: left;">Gaussian</td>
<td style="text-align: center;">$\mathbf{2 5 . 5 7} \pm \mathbf{4 . 1 9}$</td>
<td style="text-align: center;">$\mathbf{3 0 . 4 7} \pm \mathbf{2 . 1 1}$</td>
</tr>
</tbody>
</table>
<p>Table 3: 2D image results (mean $\pm$ standard deviation of PSNR)</p>
<p>Each model (MLP with 4 layers, 256 channels, ReLU activation, sigmoid output) is trained for 2000 iterations using the Adam [19] optimizer with default settings ( $\beta_{1}=0.9, \beta_{2}=0.999, \epsilon=10^{-8}$ ). Learning rates are manually tuned for each dataset and method. For Natural images a learning rate of $10^{-3}$ is used for the Gaussian RFF and the positional encoding, and a learning rate of $10^{-2}$ is used for the basic mapping and "no mapping" methods. For the Text images a learning rate of $10^{-3}$ is used for all methods.</p>
<h1>E. 2 3D shape</h1>
<p>We evaluate the 3D shape regression task (similar to Occupancy Networks [24]) on four complex triangle meshes commonly used in computer graphics applications (Dragon, Armadillo, Buddha, and Lucy, shown in Figure 16), each containing hundreds of thousands of vertices. We train one coordinate-based MLP network to represent a single mesh rather than trying to generalize one network to encode multiple objects, since our goal is to demonstrate that a network with no mapping or the low frequency "basic" mapping cannot accurately represent even a single shape, let alone a whole class of objects.</p>
<p>We use a network with 8 layers of 256 channels each and a ReLU nonlinearity between each layer. We apply a sigmoid activation to the output. Our batch size is $32^{3}$ points, and we use the Adam optimizer [19] with a learning rate starting at $5 \times 10^{-4}$ and exponentially decaying by a factor of 0.01 over the course of 10000 total training iterations. At each training iteration, we sample a batch of 3D points uniformly at random from the bounding box of the mesh, and then calculate ground truth labels (using the point-in-mesh method implemented in the Trimesh library [25], which relies on the Embree kernel for acceleration [41]). We use cross-entropy loss to train the network to match these classification labels ( 0 for points outside the mesh, 1 for points inside).
The meshes are scaled to fit inside the unit cube $[0,1]^{3}$ such that the centroid of the mesh is $(0.5,0.5,0.5)$. We use the Lucy statue mesh as a validation object to find optimal scale values for the positional encoding and Gaussian feature mapping. As described in the caption for Table 4, we calculate error on both a uniformly random test set and a test set that is close to the mesh surface (randomly chosen mesh vertices that have been perturbed by a random Gaussian vector with standard deviation 0.01 ) in order to illustrate that Fourier feature mappings provide a large benefit in resolving fine surface details. Both test sets have $64^{3}$ points.</p>
<p>In Figure 16, we visualize additional results on all four meshes mentioned above (including the validation mesh Lucy). We render normal maps, which are computed by taking the cross product of the numerical horizontal and vertical derivatives of the depth map. The original depth map is generated by intersecting camera rays with the first 0.5 isosurface of the network. We select the Fourier feature scales for (d) and (e) by doing a hyperparameter search based on validation loss for the Lucy mesh in the last row and report test loss over the other three meshes (Table 4). Note that the weights for each trained MLP are only 2 MB , while the triangle mesh files for the objects shown are $61 \mathrm{MB}, 7 \mathrm{MB}, 79 \mathrm{MB}$, and 32 MB respectively.</p>
<table>
<thead>
<tr>
<th></th>
<th>Uniform points</th>
<th>Boundary points</th>
</tr>
</thead>
<tbody>
<tr>
<td>No mapping</td>
<td>$0.959 \pm 0.006$</td>
<td>$0.864 \pm 0.014$</td>
</tr>
<tr>
<td>Basic</td>
<td>$0.966 \pm 0.007$</td>
<td>$0.892 \pm 0.017$</td>
</tr>
<tr>
<td>Positional enc.</td>
<td>$0.987 \pm 0.005$</td>
<td>$0.960 \pm 0.011$</td>
</tr>
<tr>
<td>Gaussian</td>
<td>$\mathbf{0 . 9 8 8} \pm \mathbf{0 . 0 0 7}$</td>
<td>$\mathbf{0 . 9 7 3} \pm \mathbf{0 . 0 1 0}$</td>
</tr>
</tbody>
</table>
<p>Table 4: 3D shape results (mean $\pm$ standard deviation of intersection-over-union). Uniform points is an "easy" test set where points are sampled uniformly at random from the bounding box of the ground truth mesh, while Boundary points is a "hard" test set where points are sampled near the boundary of the ground truth mesh.</p>
<h1>E. 3 2D CT</h1>
<p>In computed tomography (CT), we observe measurements that are integral projections (integrals along parallel lines) of a density field. We construct a 2D CT task by using ground truth $512 \times 512$ resolution images, and computing 20 synthetic integral projections at evenly-spaced angles. For each of these images, the supervision data is the set of integral projections, and the test PSNR is evaluated over the original image.</p>
<p>We use two datasets for our 2D CT task: randomized Shepp-Logan phantoms [36], and the ATLAS brain dataset [21]. For each dataset, we perform a hyperparameter sweep over mapping scales on 8 examples. We found that scales $\sigma_{g}=4$ and $\sigma_{p}=3$ work best for the Shepp dataset and $\sigma_{g}=5$ and $\sigma_{p}=5$ work best for the ATLAS dataset. In Table 5, we report model performance using the optimal mapping scale on a distinct set of 8 images.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: center;">Shepp</th>
<th style="text-align: center;">ATLAS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">No mapping</td>
<td style="text-align: center;">$16.75 \pm 3.64$</td>
<td style="text-align: center;">$15.44 \pm 1.28$</td>
</tr>
<tr>
<td style="text-align: left;">Basic</td>
<td style="text-align: center;">$23.31 \pm 4.66$</td>
<td style="text-align: center;">$16.95 \pm 0.72$</td>
</tr>
<tr>
<td style="text-align: left;">Positional enc.</td>
<td style="text-align: center;">$26.89 \pm 1.46$</td>
<td style="text-align: center;">$19.55 \pm 1.09$</td>
</tr>
<tr>
<td style="text-align: left;">Gaussian</td>
<td style="text-align: center;">$\mathbf{2 8 . 3 3} \pm \mathbf{1 . 1 5}$</td>
<td style="text-align: center;">$\mathbf{1 9 . 8 8} \pm \mathbf{1 . 2 3}$</td>
</tr>
</tbody>
</table>
<p>Table 5: 2D CT results (mean $\pm$ standard deviation of PSNR).</p>
<p>Each model (MLP with 4 layers, 256 channels, ReLU activation, sigmoid output) is trained for 1000 iterations using the Adam [19] optimizer with default settings ( $\beta_{1}=0.9, \beta_{2}=0.999, \epsilon=10^{-8}$ ). The learning rate is manually tuned for each method. Gaussian RFF and positional encoding use a learning rate of $10^{-3}$, and the basic and "no mapping" method use a learning rate of $10^{-2}$.</p>
<h2>E. 4 3D MRI</h2>
<p>In magnetic resonance imaging (MRI), we observe measurements that are Fourier coefficients of the atomic response to radio waves under a magnetic field. We construct a toy 3D MRI task by using ground truth $96 \times 96 \times 96$ resolution volumes and randomly sampling $\sim 13 \%$ of the Fourier coefficients for each volume from an isotropic Gaussian. For each of these volumes, the supervision data is the set of sampled Fourier coefficients, and the test PSNR is evaluated over the original volume.
We use the ATLAS brain dataset [21] for our 3D MRI experiments. We perform a hyperparameter sweep over mapping scales on 6 examples. We find that scales $\sigma_{g}=5$ and $\sigma_{p}=4$ perform best. In Table 6, we report model performance using the optimal mapping scale on a distinct set of 6 images. Each model (MLP with 4 layers, 256 channels, ReLU activation, sigmoid output) is trained for 1000 iterations using the Adam [19] optimizer with default settings ( $\beta_{1}=0.9, \beta_{2}=0.999, \epsilon=10^{-8}$ ). We use a manually-tuned learning rate of $2 \times 10^{-3}$ for each method. Results are visualized in Figure 18.</p>
<h2>E. 5 3D inverse rendering for view synthesis</h2>
<p>In this task we use the "tiny NeRF" simplified version of the view synthesis method NeRF [27] where hierarchical sampling and view dependence have been removed. The model is trained to predict the color and volume density at an input 3D point. Volumetric rendering is used to render novel</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: center;">ATLAS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">No mapping</td>
<td style="text-align: center;">$26.14 \pm 1.45$</td>
</tr>
<tr>
<td style="text-align: left;">Basic</td>
<td style="text-align: center;">$28.58 \pm 2.45$</td>
</tr>
<tr>
<td style="text-align: left;">Positional enc.</td>
<td style="text-align: center;">$32.23 \pm 3.08$</td>
</tr>
<tr>
<td style="text-align: left;">Gaussian</td>
<td style="text-align: center;">$\mathbf{3 4 . 5 1} \pm \mathbf{2 . 7 2}$</td>
</tr>
</tbody>
</table>
<p>Table 6: 3D MRI results (mean $\pm$ standard deviation of PSNR).
viewpoints of the object. The loss is calculated between the rendered views and ground truth renders. In our experiments we use the NeRF Lego dataset of 120 images downsampled to $400 \times 400$ pixel resolution. The dataset is split into 100 training images, 7 validation images, and 13 test images. The reconstruction quality on the validation images is used to determine the best mapping scale; for this scene we find $\sigma_{g}=6.05$ and $\sigma_{p}=1.27$ perform best.
The model (MLP with 4 layers, 256 channels, ReLU activation, sigmoid on RGB output) is trained for $5 \times 10^{5}$ iterations using the Adam [19] optimizer with default settings ( $\beta_{1}=0.9, \beta_{2}=0.999$, $\epsilon=10^{-8}$ ). The learning rate is manually tuned for each mapping: $10^{-3}$ for no mapping, $5 \times 10^{-3}$ for basic, $5 \times 10^{-4}$ for positional encoding, and $5 \times 10^{-4}$ for Gaussian. During training we use batches of 1024 rays.
The original NeRF method [27] uses an input mapping similar to the Positional encoding we compare against. The original NeRF mapping is smaller than our mappings ( 8 vs. 256 frequencies). We include metrics for this mapping in Table 7 under Original pos. enc. The positional encoding mappings only contain frequencies on the axes, and are therefore biased towards signals with on-axis frequency content (as demonstrated in Section A.5). In our experiments we rotate the Lego scene, which was manually axis-aligned in the original dataset, for a more equitable comparison. Table 7 also reports metrics for positional encodings on the original axis-aligned scene. Results are visualized in Figure 19.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: center;">3D NeRF</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">No mapping</td>
<td style="text-align: center;">$22.41 \pm 0.92$</td>
</tr>
<tr>
<td style="text-align: left;">Basic</td>
<td style="text-align: center;">$23.16 \pm 0.90$</td>
</tr>
<tr>
<td style="text-align: left;">Original pos. enc.</td>
<td style="text-align: center;">$24.81 \pm 0.88$</td>
</tr>
<tr>
<td style="text-align: left;">Positional enc.</td>
<td style="text-align: center;">$25.28 \pm 0.83$</td>
</tr>
<tr>
<td style="text-align: left;">Gaussian</td>
<td style="text-align: center;">$\mathbf{2 5 . 4 8} \pm \mathbf{0 . 8 9}$</td>
</tr>
<tr>
<td style="text-align: left;">Original pos. enc. (axis-aligned)</td>
<td style="text-align: center;">$25.60 \pm 0.76$</td>
</tr>
<tr>
<td style="text-align: left;">Positional enc. (axis-aligned)</td>
<td style="text-align: center;">$26.27 \pm 0.91$</td>
</tr>
</tbody>
</table>
<p>Table 7: 3D NeRF results (mean and standard deviation of PSNR). Error is calculated based on held-out images of the scene since the ground truth radiance field is not known.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<ul>
<li>Authors contributed equally to this work.</li>
</ul>
<p><a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>