<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-6453 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-6453</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-6453</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-127.html">extraction-schema-127</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents that employ a memory mechanism to solve tasks, including details of the memory type, how it is accessed or updated, the tasks/benchmarks evaluated, performance with and without the memory, and any reported trade‑offs or limitations.</div>
                <p><strong>Paper ID:</strong> paper-41b796b026a1d322de6ef0b280d3e2e68eee65bd</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/41b796b026a1d322de6ef0b280d3e2e68eee65bd" target="_blank">Lift Yourself Up: Retrieval-augmented Text Generation with Self Memory</a></p>
                <p><strong>Paper Venue:</strong> Neural Information Processing Systems</p>
                <p><strong>Paper TL;DR:</strong> This paper proposes a novel framework, selfmem, which addresses the duality of the primal problem: better generation also prompts better memory by iteratively employing a retrieval-augmented generator to create an unbounded memory pool and using a memory selector to choose one output as memory for the subsequent generation round.</p>
                <p><strong>Paper Abstract:</strong> With direct access to human-written reference as memory, retrieval-augmented generation has achieved much progress in a wide range of text generation tasks. Since better memory would typically prompt better generation~(we define this as primal problem). The traditional approach for memory retrieval involves selecting memory that exhibits the highest similarity to the input. However, this method is constrained by the quality of the fixed corpus from which memory is retrieved. In this paper, by exploring the duality of the primal problem: better generation also prompts better memory, we propose a novel framework, selfmem, which addresses this limitation by iteratively employing a retrieval-augmented generator to create an unbounded memory pool and using a memory selector to choose one output as memory for the subsequent generation round. This enables the model to leverage its own output, referred to as self-memory, for improved generation. We evaluate the effectiveness of selfmem on three distinct text generation tasks: neural machine translation, abstractive text summarization, and dialogue generation, under two generation paradigms: fine-tuned small model and few-shot LLM. Our approach achieves state-of-the-art results in four directions in JRC-Acquis, XSum (50.3 ROUGE-1), and BigPatent (62.9 ROUGE-1), demonstrating the potential of self-memory in enhancing retrieval-augmented generation models. Furthermore, we conduct thorough analyses of each component in the selfmem framework to identify bottlenecks and provide insights for future research.</p>
                <p><strong>Cost:</strong> 0.018</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e6453.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e6453.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents that employ a memory mechanism to solve tasks, including details of the memory type, how it is accessed or updated, the tasks/benchmarks evaluated, performance with and without the memory, and any reported trade‑offs or limitations.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Selfmem</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Selfmem: Retrieval-augmented Text Generation with Self-Memory</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A retrieval-augmented generation framework that iteratively uses a generator to produce candidate outputs and a learned memory selector to pick one generated candidate as 'self-memory' to feed the generator in the next round, enabling unbounded, model‑produced memory that improves downstream generation.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>Selfmem</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Two-component agent: (1) a retrieval-augmented generator (G_ξ) that conditions generation on a memory item plus the source (implemented as Transformer joint- or dual-encoder; also used as few-shot LLM with in‑context examples), and (2) a memory selector (S_θ) that scores generated candidates with a model (XLM‑R or RoBERTa backbone) against a model‑free metric Δ (BLEU/ROUGE/Distinct) and selects a candidate to become the next-round memory; the process iterates until validation convergence.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>Transformer-base (trainable small model); XGLM few-shot backbones: 1.7B, 4.5B, 7.5B</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>Retrieval-augmented generation with 'self-memory' (model-generated text used as external memory); initial memory from fixed datastore via BM25</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Raw text target passages / generated candidate target sentences (target side of retrieved examples or selected generated candidate)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_access_mechanism</strong></td>
                            <td>Initial read: BM25 retrieval from training datastore; subsequent read/write: generator produces N candidates (beam search, beam=50), memory selector S_θ scores source+candidate pairs (softmax over scorer outputs trained to match Δ-based soft labels) and writes by replacing memory with the chosen generated candidate for the next iteration</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>JRC-Acquis (En<->De, En<->Es) translation; XSum and BigPatent abstractive summarization; DailyDialog dialogue generation. Also evaluated few-shot with XGLM on the JRC translation directions.</td>
                        </tr>
                        <tr>
                            <td><strong>task_category</strong></td>
                            <td>Machine translation; abstractive summarization; dialogue response generation; few-shot in-context learning</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>Translation (Transformer_joint En→De test BLEU): Selfmem 60.11 BLEU (vs retrieval 58.58 BLEU); Translation (various directions) improvements reported across four JRC directions (examples: En→Es Selfmem test BLEU 68.80 vs retrieval ~67.32). Few‑shot LLM (XGLM-7.5B En→De): Self (in-context chosen examples) 48.32 BLEU, kNN 47.82, Random 18.48 (Table 4). Summarization: XSum BRIO_joint Self R-1=50.3 (vs retrieval 49.5); BigPatent BART_joint Self R-1=62.9 (vs retrieval 59.6). Dialogue (DailyDialog) BART_joint Self B-1=39.80, B-2=32.15 (vs retrieval B-1=36.72, B-2=31.55).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td>No-memory baselines: Translation Transformer (no memory) En→De BLEU 55.43 (vs retrieval 58.58, self 60.11). Summarization and dialogue no-memory baselines reported (e.g., BART no-memory BigPatent R-1=44.4). Few-shot LLM with Random examples much worse (e.g., XGLM-7.5B Random 18.48 BLEU for En→De).</td>
                        </tr>
                        <tr>
                            <td><strong>has_comparative_results</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td>BLEU (translation, dialogue BLEU), ROUGE-1/2/L (summarization), Distinct (dialogue diversity), chrF++ and TER (additional MT evals)</td>
                        </tr>
                        <tr>
                            <td><strong>tradeoffs_reported</strong></td>
                            <td>Increased computation and latency: Selfmem candidate generation + selection adds overhead (CPU total time multipliers ~4.6–6.0× vs retrieval baseline; CUDA multipliers ~2.8–3.4×; see Table 12). Metric optimization trade-offs: optimizing S_θ for BLEU improved BLEU but reduced Distinct in dialogue; switching Δ to Distinct increased diversity but changed BLEU. Memory selection requires extra model inference (selector) and candidate generation (beam=50), increasing resource usage.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Requires more compute for candidate generation and selection (especially on long-context datasets like BigPatent due to Transformer's quadratic cost). The generator can fall into a confidence region where beam outputs provide no information gain (beam memory sometimes fails to improve generation). Self-memory can trade off diversity (Distinct) for n‑gram overlap metrics when selector is optimized for the latter. The paper notes architecture/design is uniform across tasks and task-specific designs may yield further gains.</td>
                        </tr>
                        <tr>
                            <td><strong>citation</strong></td>
                            <td>Xin Cheng, Di Luo, Xiuying Chen, Lemao Liu, Dongyan Zhao, Rui Yan. Lift Yourself Up: Retrieval-augmented Text Generation with Self-Memory.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Lift Yourself Up: Retrieval-augmented Text Generation with Self Memory', 'publication_date_yy_mm': '2023-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6453.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e6453.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents that employ a memory mechanism to solve tasks, including details of the memory type, how it is accessed or updated, the tasks/benchmarks evaluated, performance with and without the memory, and any reported trade‑offs or limitations.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Retrieval-augmented generator (G_ξ)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Retrieval-augmented generator G_ξ (Joint-Encoder / Dual-Encoder variants)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A generator that conditions on source x and a retrieved memory m to produce target y; implemented either as joint encoder (concatenate source and memory) or dual encoder (separate encoders for source and memory) using Transformer backbone and trained with NLL.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>Retrieval-augmented generator (G_ξ)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Encoder-decoder Transformer that takes source and retrieved memory (target-side retrieved example) as input; joint-encoder concatenates x[SEP]m into a single encoder, dual-encoder uses separate encoders and dual cross-attention in the decoder; used both as a trainable small model and as black-box LLM via in‑context examples for few-shot experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>Transformer-base (randomly initialized) for trainable models; BART_base/BRIO for summarization; XGLM 1.7B/4.5B/7.5B when used as LLM generator</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>Retrieval-augmented (external datastore of training examples) and self-memory when plugged into Selfmem</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Target-side text segments (sentences/summaries/responses) retrieved from datastore (training set) or produced/generated candidate strings for self-memory</td>
                        </tr>
                        <tr>
                            <td><strong>memory_access_mechanism</strong></td>
                            <td>Initial lookup via BM25; memory inserted into encoder input (joint) or memory encoder (dual); for self-memory, memory is replaced by selected generated candidate chosen by S_θ and fed as input without model parameter updates (generator often kept fixed during iterations)</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>JRC-Acquis translation; XSum/BigPatent summarization; DailyDialog dialogue generation; used as both fine‑tuned small model and few‑shot LLM generator</td>
                        </tr>
                        <tr>
                            <td><strong>task_category</strong></td>
                            <td>Translation, summarization, dialogue; retrieval-augmented generation</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>Examples: On JRC En→De, retrieval memory yields hypothesis BLEU 58.58 (Table 1); retrieval-augmented generator discriminates memory quality: Reference memory (oracle) gives hypothesis BLEU 90.43; Random memory yields 49.08 BLEU (Table 1). Using retrieved memory in standard setup yields improvements over no memory (e.g., Transformer no-memory 55.43 → retrieval 58.58 BLEU).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td>No-memory generator baseline En→De BLEU 55.43 (Transformer, Table 9); beam outputs used as memory (beam memory) produced no improvement over retrieval in some cases (Beam memory hypothesis BLEU 58.43 vs retrieval 58.58 in Table 1).</td>
                        </tr>
                        <tr>
                            <td><strong>has_comparative_results</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td>BLEU (primary for MT), also TER and chrF++ reported</td>
                        </tr>
                        <tr>
                            <td><strong>tradeoffs_reported</strong></td>
                            <td>Generator tends to be confident about tokens in its high-probability region (set confidence ψ): beam-selected outputs may lie in this region and provide little information gain; generator generalization can be sensitive to memory distribution shifts (retrieved → self outputs).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Beam memory (model's own beams) may not add information and can fail to improve generation due to high model confidence over those tokens; effectiveness depends strongly on quality/diversity of memory; generator was kept fixed because it already discriminates memory quality, but this may limit adaptation to new memory distributions.</td>
                        </tr>
                        <tr>
                            <td><strong>citation</strong></td>
                            <td>Xin Cheng, Di Luo, Xiuying Chen, Lemao Liu, Dongyan Zhao, Rui Yan. Lift Yourself Up: Retrieval-augmented Text Generation with Self-Memory.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Lift Yourself Up: Retrieval-augmented Text Generation with Self Memory', 'publication_date_yy_mm': '2023-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6453.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e6453.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents that employ a memory mechanism to solve tasks, including details of the memory type, how it is accessed or updated, the tasks/benchmarks evaluated, performance with and without the memory, and any reported trade‑offs or limitations.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Memory selector (S_θ)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Memory selector S_θ (candidate reranker used as memory picker)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A learned reranker that takes source+candidate as input and outputs a distribution over candidates; trained to match metric-based soft labels (Δ, e.g., BLEU/ROUGE/Distinct) via KL divergence and used to choose which generated candidate becomes self-memory.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>Memory selector (S_θ)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Classifier/ranker (XLM‑R_base or RoBERTa_base backbone depending on task) that consumes concatenated source and candidate text and outputs scores; training objective minimizes KL divergence between selector distribution and a Δ-based soft target distribution (temperature τ); at inference it selects argmax candidate as memory for the next iteration.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>XLM‑R_base or RoBERTa_base backbones (task-dependent)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>Learned selection policy over a pool of generated candidate memories (i.e., a learned reranker used to pick self-memory)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Raw candidate text (generated outputs); input to selector is source + candidate string</td>
                        </tr>
                        <tr>
                            <td><strong>memory_access_mechanism</strong></td>
                            <td>Reads candidate pool produced by generator (beam search N candidates); computes S_θ(x[SEP]c_i) scores; training target p_M(c_i) = softmax(Δ(c_i, y)/τ) where Δ is model-free metric (BLEU/ROUGE/Distinct); writes by returning chosen candidate as memory for generator</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Used across experiments for MT (BLEU as Δ), Summarization (ROUGE as Δ), Dialogue (BLEU or Distinct as Δ).</td>
                        </tr>
                        <tr>
                            <td><strong>task_category</strong></td>
                            <td>Reranking / memory selection for retrieval-augmented generation; used in translation, summarization, dialogue</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td>When trained and applied, selector-chosen self-memory improves final generation (illustrative numbers: JRC En→De retrieval memory quality 38.89 BLEU → selected self-memory 57.92 BLEU and final hypothesis improved from 58.58 → 60.11 BLEU; Table 3). Dialogue: selecting with BLEU improved B-1 from 36.72 (retrieval) to 39.80 (self), but reduced Distinct; optimizing selector on Distinct yields D-1=9.12, D-2=37.05 at some BLEU cost (Table 6).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td>If no learned selector is used and retrieval-only memory is fed, performance is lower (see retrieval baselines in Tables 2,3,5,6). Beam-as-memory without selector produced little or no improvement (Beam memory hypothesis BLEU 58.43 vs retrieval 58.58, Table 1).</td>
                        </tr>
                        <tr>
                            <td><strong>has_comparative_results</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td>Selector is trained using Δ which may be BLEU (MT), ROUGE (summarization), or Distinct (dialogue), and final system measured by BLEU/ROUGE/Distinct depending on task</td>
                        </tr>
                        <tr>
                            <td><strong>tradeoffs_reported</strong></td>
                            <td>Selection step adds latency and compute (Table 12: memory selection CPU times ~0.5–0.95s; on CUDA selection is small but candidate generation dominates). Choice of Δ leads to metric trade-offs (e.g., optimizing for BLEU reduces Distinct). Selector training requires Δ values computed w.r.t. references (supervision) and a candidate pool, increasing training complexity.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Selector performance depends on candidate pool quality; oracle selector experiments indicate further room for improvement (selector is a current bottleneck). Using metrics correlated with n‑gram overlap can hurt diversity; selection requires ground-truth references for training Δ-based labels and can be expensive on very large datasets.</td>
                        </tr>
                        <tr>
                            <td><strong>citation</strong></td>
                            <td>Xin Cheng, Di Luo, Xiuying Chen, Lemao Liu, Dongyan Zhao, Rui Yan. Lift Yourself Up: Retrieval-augmented Text Generation with Self-Memory.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Lift Yourself Up: Retrieval-augmented Text Generation with Self Memory', 'publication_date_yy_mm': '2023-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Generate rather than retrieve: Large language models are strong context generators <em>(Rating: 2)</em></li>
                <li>Generate-and-retrieve: Use your predictions to improve retrieval for semantic parsing <em>(Rating: 2)</em></li>
                <li>Retrieval-augmented generation for knowledge-intensive NLP tasks <em>(Rating: 2)</em></li>
                <li>Generalization through memorization: Nearest neighbor language models <em>(Rating: 2)</em></li>
                <li>Nearest neighbor machine translation <em>(Rating: 1)</em></li>
                <li>REPLUG: retrieval-augmented black-box language models <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-6453",
    "paper_id": "paper-41b796b026a1d322de6ef0b280d3e2e68eee65bd",
    "extraction_schema_id": "extraction-schema-127",
    "extracted_data": [
        {
            "name_short": "Selfmem",
            "name_full": "Selfmem: Retrieval-augmented Text Generation with Self-Memory",
            "brief_description": "A retrieval-augmented generation framework that iteratively uses a generator to produce candidate outputs and a learned memory selector to pick one generated candidate as 'self-memory' to feed the generator in the next round, enabling unbounded, model‑produced memory that improves downstream generation.",
            "citation_title": "here",
            "mention_or_use": "use",
            "agent_name": "Selfmem",
            "agent_description": "Two-component agent: (1) a retrieval-augmented generator (G_ξ) that conditions generation on a memory item plus the source (implemented as Transformer joint- or dual-encoder; also used as few-shot LLM with in‑context examples), and (2) a memory selector (S_θ) that scores generated candidates with a model (XLM‑R or RoBERTa backbone) against a model‑free metric Δ (BLEU/ROUGE/Distinct) and selects a candidate to become the next-round memory; the process iterates until validation convergence.",
            "model_size": "Transformer-base (trainable small model); XGLM few-shot backbones: 1.7B, 4.5B, 7.5B",
            "memory_used": true,
            "memory_type": "Retrieval-augmented generation with 'self-memory' (model-generated text used as external memory); initial memory from fixed datastore via BM25",
            "memory_representation": "Raw text target passages / generated candidate target sentences (target side of retrieved examples or selected generated candidate)",
            "memory_access_mechanism": "Initial read: BM25 retrieval from training datastore; subsequent read/write: generator produces N candidates (beam search, beam=50), memory selector S_θ scores source+candidate pairs (softmax over scorer outputs trained to match Δ-based soft labels) and writes by replacing memory with the chosen generated candidate for the next iteration",
            "task_name": "JRC-Acquis (En&lt;-&gt;De, En&lt;-&gt;Es) translation; XSum and BigPatent abstractive summarization; DailyDialog dialogue generation. Also evaluated few-shot with XGLM on the JRC translation directions.",
            "task_category": "Machine translation; abstractive summarization; dialogue response generation; few-shot in-context learning",
            "performance_with_memory": "Translation (Transformer_joint En→De test BLEU): Selfmem 60.11 BLEU (vs retrieval 58.58 BLEU); Translation (various directions) improvements reported across four JRC directions (examples: En→Es Selfmem test BLEU 68.80 vs retrieval ~67.32). Few‑shot LLM (XGLM-7.5B En→De): Self (in-context chosen examples) 48.32 BLEU, kNN 47.82, Random 18.48 (Table 4). Summarization: XSum BRIO_joint Self R-1=50.3 (vs retrieval 49.5); BigPatent BART_joint Self R-1=62.9 (vs retrieval 59.6). Dialogue (DailyDialog) BART_joint Self B-1=39.80, B-2=32.15 (vs retrieval B-1=36.72, B-2=31.55).",
            "performance_without_memory": "No-memory baselines: Translation Transformer (no memory) En→De BLEU 55.43 (vs retrieval 58.58, self 60.11). Summarization and dialogue no-memory baselines reported (e.g., BART no-memory BigPatent R-1=44.4). Few-shot LLM with Random examples much worse (e.g., XGLM-7.5B Random 18.48 BLEU for En→De).",
            "has_comparative_results": true,
            "performance_metric": "BLEU (translation, dialogue BLEU), ROUGE-1/2/L (summarization), Distinct (dialogue diversity), chrF++ and TER (additional MT evals)",
            "tradeoffs_reported": "Increased computation and latency: Selfmem candidate generation + selection adds overhead (CPU total time multipliers ~4.6–6.0× vs retrieval baseline; CUDA multipliers ~2.8–3.4×; see Table 12). Metric optimization trade-offs: optimizing S_θ for BLEU improved BLEU but reduced Distinct in dialogue; switching Δ to Distinct increased diversity but changed BLEU. Memory selection requires extra model inference (selector) and candidate generation (beam=50), increasing resource usage.",
            "limitations_or_failure_cases": "Requires more compute for candidate generation and selection (especially on long-context datasets like BigPatent due to Transformer's quadratic cost). The generator can fall into a confidence region where beam outputs provide no information gain (beam memory sometimes fails to improve generation). Self-memory can trade off diversity (Distinct) for n‑gram overlap metrics when selector is optimized for the latter. The paper notes architecture/design is uniform across tasks and task-specific designs may yield further gains.",
            "citation": "Xin Cheng, Di Luo, Xiuying Chen, Lemao Liu, Dongyan Zhao, Rui Yan. Lift Yourself Up: Retrieval-augmented Text Generation with Self-Memory.",
            "uuid": "e6453.0",
            "source_info": {
                "paper_title": "Lift Yourself Up: Retrieval-augmented Text Generation with Self Memory",
                "publication_date_yy_mm": "2023-05"
            }
        },
        {
            "name_short": "Retrieval-augmented generator (G_ξ)",
            "name_full": "Retrieval-augmented generator G_ξ (Joint-Encoder / Dual-Encoder variants)",
            "brief_description": "A generator that conditions on source x and a retrieved memory m to produce target y; implemented either as joint encoder (concatenate source and memory) or dual encoder (separate encoders for source and memory) using Transformer backbone and trained with NLL.",
            "citation_title": "",
            "mention_or_use": "use",
            "agent_name": "Retrieval-augmented generator (G_ξ)",
            "agent_description": "Encoder-decoder Transformer that takes source and retrieved memory (target-side retrieved example) as input; joint-encoder concatenates x[SEP]m into a single encoder, dual-encoder uses separate encoders and dual cross-attention in the decoder; used both as a trainable small model and as black-box LLM via in‑context examples for few-shot experiments.",
            "model_size": "Transformer-base (randomly initialized) for trainable models; BART_base/BRIO for summarization; XGLM 1.7B/4.5B/7.5B when used as LLM generator",
            "memory_used": true,
            "memory_type": "Retrieval-augmented (external datastore of training examples) and self-memory when plugged into Selfmem",
            "memory_representation": "Target-side text segments (sentences/summaries/responses) retrieved from datastore (training set) or produced/generated candidate strings for self-memory",
            "memory_access_mechanism": "Initial lookup via BM25; memory inserted into encoder input (joint) or memory encoder (dual); for self-memory, memory is replaced by selected generated candidate chosen by S_θ and fed as input without model parameter updates (generator often kept fixed during iterations)",
            "task_name": "JRC-Acquis translation; XSum/BigPatent summarization; DailyDialog dialogue generation; used as both fine‑tuned small model and few‑shot LLM generator",
            "task_category": "Translation, summarization, dialogue; retrieval-augmented generation",
            "performance_with_memory": "Examples: On JRC En→De, retrieval memory yields hypothesis BLEU 58.58 (Table 1); retrieval-augmented generator discriminates memory quality: Reference memory (oracle) gives hypothesis BLEU 90.43; Random memory yields 49.08 BLEU (Table 1). Using retrieved memory in standard setup yields improvements over no memory (e.g., Transformer no-memory 55.43 → retrieval 58.58 BLEU).",
            "performance_without_memory": "No-memory generator baseline En→De BLEU 55.43 (Transformer, Table 9); beam outputs used as memory (beam memory) produced no improvement over retrieval in some cases (Beam memory hypothesis BLEU 58.43 vs retrieval 58.58 in Table 1).",
            "has_comparative_results": true,
            "performance_metric": "BLEU (primary for MT), also TER and chrF++ reported",
            "tradeoffs_reported": "Generator tends to be confident about tokens in its high-probability region (set confidence ψ): beam-selected outputs may lie in this region and provide little information gain; generator generalization can be sensitive to memory distribution shifts (retrieved → self outputs).",
            "limitations_or_failure_cases": "Beam memory (model's own beams) may not add information and can fail to improve generation due to high model confidence over those tokens; effectiveness depends strongly on quality/diversity of memory; generator was kept fixed because it already discriminates memory quality, but this may limit adaptation to new memory distributions.",
            "citation": "Xin Cheng, Di Luo, Xiuying Chen, Lemao Liu, Dongyan Zhao, Rui Yan. Lift Yourself Up: Retrieval-augmented Text Generation with Self-Memory.",
            "uuid": "e6453.1",
            "source_info": {
                "paper_title": "Lift Yourself Up: Retrieval-augmented Text Generation with Self Memory",
                "publication_date_yy_mm": "2023-05"
            }
        },
        {
            "name_short": "Memory selector (S_θ)",
            "name_full": "Memory selector S_θ (candidate reranker used as memory picker)",
            "brief_description": "A learned reranker that takes source+candidate as input and outputs a distribution over candidates; trained to match metric-based soft labels (Δ, e.g., BLEU/ROUGE/Distinct) via KL divergence and used to choose which generated candidate becomes self-memory.",
            "citation_title": "",
            "mention_or_use": "use",
            "agent_name": "Memory selector (S_θ)",
            "agent_description": "Classifier/ranker (XLM‑R_base or RoBERTa_base backbone depending on task) that consumes concatenated source and candidate text and outputs scores; training objective minimizes KL divergence between selector distribution and a Δ-based soft target distribution (temperature τ); at inference it selects argmax candidate as memory for the next iteration.",
            "model_size": "XLM‑R_base or RoBERTa_base backbones (task-dependent)",
            "memory_used": true,
            "memory_type": "Learned selection policy over a pool of generated candidate memories (i.e., a learned reranker used to pick self-memory)",
            "memory_representation": "Raw candidate text (generated outputs); input to selector is source + candidate string",
            "memory_access_mechanism": "Reads candidate pool produced by generator (beam search N candidates); computes S_θ(x[SEP]c_i) scores; training target p_M(c_i) = softmax(Δ(c_i, y)/τ) where Δ is model-free metric (BLEU/ROUGE/Distinct); writes by returning chosen candidate as memory for generator",
            "task_name": "Used across experiments for MT (BLEU as Δ), Summarization (ROUGE as Δ), Dialogue (BLEU or Distinct as Δ).",
            "task_category": "Reranking / memory selection for retrieval-augmented generation; used in translation, summarization, dialogue",
            "performance_with_memory": "When trained and applied, selector-chosen self-memory improves final generation (illustrative numbers: JRC En→De retrieval memory quality 38.89 BLEU → selected self-memory 57.92 BLEU and final hypothesis improved from 58.58 → 60.11 BLEU; Table 3). Dialogue: selecting with BLEU improved B-1 from 36.72 (retrieval) to 39.80 (self), but reduced Distinct; optimizing selector on Distinct yields D-1=9.12, D-2=37.05 at some BLEU cost (Table 6).",
            "performance_without_memory": "If no learned selector is used and retrieval-only memory is fed, performance is lower (see retrieval baselines in Tables 2,3,5,6). Beam-as-memory without selector produced little or no improvement (Beam memory hypothesis BLEU 58.43 vs retrieval 58.58, Table 1).",
            "has_comparative_results": true,
            "performance_metric": "Selector is trained using Δ which may be BLEU (MT), ROUGE (summarization), or Distinct (dialogue), and final system measured by BLEU/ROUGE/Distinct depending on task",
            "tradeoffs_reported": "Selection step adds latency and compute (Table 12: memory selection CPU times ~0.5–0.95s; on CUDA selection is small but candidate generation dominates). Choice of Δ leads to metric trade-offs (e.g., optimizing for BLEU reduces Distinct). Selector training requires Δ values computed w.r.t. references (supervision) and a candidate pool, increasing training complexity.",
            "limitations_or_failure_cases": "Selector performance depends on candidate pool quality; oracle selector experiments indicate further room for improvement (selector is a current bottleneck). Using metrics correlated with n‑gram overlap can hurt diversity; selection requires ground-truth references for training Δ-based labels and can be expensive on very large datasets.",
            "citation": "Xin Cheng, Di Luo, Xiuying Chen, Lemao Liu, Dongyan Zhao, Rui Yan. Lift Yourself Up: Retrieval-augmented Text Generation with Self-Memory.",
            "uuid": "e6453.2",
            "source_info": {
                "paper_title": "Lift Yourself Up: Retrieval-augmented Text Generation with Self Memory",
                "publication_date_yy_mm": "2023-05"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Generate rather than retrieve: Large language models are strong context generators",
            "rating": 2,
            "sanitized_title": "generate_rather_than_retrieve_large_language_models_are_strong_context_generators"
        },
        {
            "paper_title": "Generate-and-retrieve: Use your predictions to improve retrieval for semantic parsing",
            "rating": 2,
            "sanitized_title": "generateandretrieve_use_your_predictions_to_improve_retrieval_for_semantic_parsing"
        },
        {
            "paper_title": "Retrieval-augmented generation for knowledge-intensive NLP tasks",
            "rating": 2,
            "sanitized_title": "retrievalaugmented_generation_for_knowledgeintensive_nlp_tasks"
        },
        {
            "paper_title": "Generalization through memorization: Nearest neighbor language models",
            "rating": 2,
            "sanitized_title": "generalization_through_memorization_nearest_neighbor_language_models"
        },
        {
            "paper_title": "Nearest neighbor machine translation",
            "rating": 1,
            "sanitized_title": "nearest_neighbor_machine_translation"
        },
        {
            "paper_title": "REPLUG: retrieval-augmented black-box language models",
            "rating": 1,
            "sanitized_title": "replug_retrievalaugmented_blackbox_language_models"
        }
    ],
    "cost": 0.01825575,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Lift Yourself Up: Retrieval-augmented Text Generation with Self-Memory</h1>
<p>Xin Cheng ${ }^{1}$ Di Luo $^{2}$ Xiuying Chen ${ }^{3}$ Lemao Liu ${ }^{4}$ Dongyan Zhao ${ }^{1}$ Rui Yan ${ }^{2}$<br>${ }^{1}$ Peking University ${ }^{2}$ Renmin University of China<br>${ }^{3}$ KAUST ${ }^{4}$ Tencent AI Lab<br>chengxin1998@stu.pku.edu.cn</p>
<h4>Abstract</h4>
<p>With direct access to human-written reference as memory, retrieval-augmented generation has achieved much progress in a wide range of text generation tasks. Since better memory would typically prompt better generation (we define this as primal problem). The traditional approach for memory retrieval involves selecting memory that exhibits the highest similarity to the input. However, this method is constrained by the quality of the fixed corpus from which memory is retrieved. In this paper, by exploring the duality of the primal problem: better generation also prompts better memory, we propose a novel framework, Selfmem, which addresses this limitation by iteratively employing a retrieval-augmented generator to create an unbounded memory pool and using a memory selector to choose one output as memory for the subsequent generation round. This enables the model to leverage its own output, referred to as self-memory, for improved generation. We evaluate the effectiveness of Selfmem on three distinct text generation tasks: neural machine translation, abstractive text summarization, and dialogue generation, under two generation paradigms: fine-tuned small model and few-shot LLM. Our approach achieves state-of-the-art results in four directions in JRC-Acquis translation dataset, 50.3 ROUGE-1 in XSum, and 62.9 ROUGE-1 in BigPatent, demonstrating the potential of self-memory in enhancing retrieval-augmented generation models. Furthermore, we conduct thorough analyses of each component in the Selfmem framework to identify current system bottlenecks and provide insights for future research ${ }^{1}$.</p>
<h2>1 Introduction</h2>
<p>In recent years, retrieval-augmented text generation has attracted growing interest across various fields, including neural machine translation[28, 17, 2], dialogue response generation[81, 6, 46], and language modeling[36, 77, 19]. This innovative generation paradigm initially equips a fine-tuned small model or a large language model (LLM) with access to an external database (typically the training corpus) using information retrieval techniques. Subsequently, the generation process is conducted based on both the input text and the retrieved memory.</p>
<p>In this paradigm, the guiding principle for memory retrieval is to find the memory that exhibits the highest similarity to the current input [36, 96, 49]. This aligns with the human intuition that a more similar demonstration sample typically offers more hints. As demonstrated in Figure 1, for a retrieval-augmented translation model, the memory similarity alone exhibits a strong correlation with the final translation quality, regardless of other factors that may influence translation quality (e.g.,</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>polysemy, morphology, and coreference). We define this as the primal problem: better memory prompts better generation. Consequently, numerous studies have focused on how to retrieve better memory, ranging from sparse retrieval to dense retrieval [10, 63], from a fixed retriever to a learnable retriever [41, 8], and from sentence-level memory to more fine-grained token-level memory [36, 35].</p>
<p>However, a fundamental limitation exists in all previous works: the memory is retrieved from a fixed corpus and is constrained by the corpus’s quality. Due to the finite retrieval space, bounded memory significantly restricts the potential of memory-augmented generation models [97]. In this paper, we explore the duality of the primal problem, which posits that better generation also prompts better memory. We propose a novel framework called Selfmem, which iteratively employs a retrieval-augmented generator to create an unbounded memory pool and uses a memory selector to choose one output as memory for the subsequent generation round. By combining the primal and dual problem, a retrievalaugmented generation model can elevate itself using its own output, referred to as self-memory. The key insight behind Selfmem is that the text more closely resembling the data distribution during inference is not the training data [87], but the model’s own output.</p>
<p>Selfmem consists of two complementary components: a retrieval-augmented generator and a memory selector. The generator operates under two distinct paradigms: fine-tuning a small model or few-shot prompting an LLM. For the former, we train the generator with labeled data and retrieved memory, while for the latter, we employ a fixed black-box LLM exclusively for inference alongside retrieved in-context learning samples. We then use the generator’s output to train a memory selector based on a specific performance metric. By simply replacing the retrieved memory with unbounded generated memory, we achieve higher-quality generation output (primal problem), which subsequently serves as memory for the next round after being refined by the memory selector (dual problem).</p>
<p>To evaluate the efficacy of the Selfmem, we carry out comprehensive experiments in three distinct text generation tasks: neural machine translation, abstractive text summarization, and dialogue generation. We witness substantial enhancements over robust baselines, attaining state-of-the-art outcomes in JRC-Acquis (four directions), XSum (50.3 ROUGE-1), and BigPatent (62.9 ROUGE-1). To gain deeper insights into the Selfmem, we meticulously investigate each crucial component and pinpoint the existing system bottleneck to guide future research endeavors.</p>
<h2>2 Related Work</h2>
<h3>2.1 Retrieval-augmented Text Generation</h3>
<p>Since the world is not a snapshot once the training corpus is collected, we can never expect an ever-large model to capture everything in its parameters, even for LLMs like GPT-4 [62]. Therefore, it is crucial to equip these models with an external memory bank to store additional knowledge or useful demonstration examples for solving various NLP tasks [41, 78, 95].</p>
<p>In the translation domain, retrieval techniques have long been employed by the localization industry to enhance human translators’ productivity and consistency even before the advent of machine translation [94]. Early works on machine translation primarily focused on utilizing memory for statistical machine translation (SMT) systems [80, 50]. For neural machine translation (NMT), [28] were the first to use search engines to retrieve memory from the training set and incorporate it with an external memory network. Subsequent research explored various aspects of retrievalaugmented NMT, such as memory encoding methods [92, 93, 31], joint training of retrievers and generators with monolingual data [8], memory granularity [35], and memory diversity [17]. For few-shot LLM generation, strategies for in-context example selection have been proposed to improve translation quality [2]. Furthermore, in-context machine translation has been shown to be effective for on-the-fly adaptation [79]. For dialogue response generation tasks, employing exemplar/template</p>
<p>retrieval as an intermediate step has proven advantageous for generating informative responses [89, $91,6,7]$. In-context learning example retrieval also aids in controllable dialogue [46]. Other applications include abstractive summarization [64, 14, 18, 15], code generation [30], paraphrase generation [34, 83], language modeling [36, 105], counterfactual data generation [24], open domain question answering $[12,33]$ and semantic parsing [99].</p>
<h1>2.2 Neural Text Reranking</h1>
<p>By alleviating the discrepancy between training and inference (i.e., exposure bias) and directly optimizing desired metrics, two-stage reranking methods have facilitated significant progress in various text generation tasks. In machine translation, pioneering works by [75] and [61] introduced and popularized discriminative reranking for SMT. In the context of NMT, research has focused on two primary reranking approaches: generative reranking [56, 32, 88] and discriminative reranking [39, 71, 23]. For syntactic parsing, [21] were the first to employ a two-stage reranking method to select outputs from a base parser, while [11] introduced a maximum entropy reranker. In text summarization, RefSum [53] proposed a second-stage summarization framework to address train-test distribution mismatches. SimCLS [54] used pairwise Learning To Rank (LTR) to select candidates with the highest matching scores. SummaReranker [68] adopted a multi-task mixture-of-experts framework to leverage different metrics capturing various aspects of generated candidates. BRIO [55] reused the base model for a second round of fine-tuning with both cross-entropy loss and a candidate-level ranking loss. JGR [76] employed an alternate training paradigm to train the generator and reranker.
A key limitation of these reranking methods is that they only represent a one-way process, wherein the selected candidates become the system's final output. In contrast, our framework innovatively utilizes the chosen candidates as memory for the subsequent generation round of a retrieval-augmented generator, which can produce better candidates with enhanced memory.</p>
<h2>3 Methods</h2>
<p>In this section, we begin with a motivating experiment on generation as memory (§ 3.1). Then, we introduce Selfmem, a framework comprising a retrieval-augmented generator (§ 3.2) and a memory selector (§ 3.3). The complete framework and algorithm are illustrated in Figure 2 and Algorithm 1.</p>
<h3>3.1 Generation as Memory</h3>
<p>The primary motivation behind our framework stems from the observation that the memory, which is more similar in distribution to the data during inference, is not the training data ( 38.89 BLEU, as shown in the first row of Table 1). Instead, it is the model's own output ( 58.58 BLEU) within the unbounded generation space. One interesting exploration involves directly utilizing the generated output as memory in relation to the primal problem: better memory prompts better generation.</p>
<p>We conduct experiments on the JRC-Acquis $\mathrm{En} \rightarrow \mathrm{De}$ dataset. The first row in Table 1 represents conventional retrieval-augmented training with retrieved memory and achieves a 58.58 BLEU score. However, directly incorporating beam output of this trained model as memory (Beam) back into the generation model does not yield any improvements (row 2), despite its higher similarity to the reference compared to the retrieved ones. We hypothesize two potential reasons for this: (1) the retrieval-augmented generator may not generalize effectively in this context due to the memory distribution shift (from 38.89 to 58.58), and (2) the beam memory does not offer any information gain compared to the retrieved one, even it exhibits more overlap with the references.
To investigate the first hypothesis, we conduct experiments under the oracle and random scenarios by using the reference as memory (Reference) and randomly sampled sentences as memory (Random). The result is shown in Table 1 and it illustrates that a retrieval-augmented generator (trained with</p>
<p>Table 1: Experiments on the relation between memory quality and the final hypothesis quality, measured by the BLEU score with ground truth translation. The retrieval-augmented translator keeps fixed while the memory is obtained from different sources.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Memory Source</th>
<th style="text-align: center;">Memory Quality</th>
<th style="text-align: center;">Hypothesis Quality</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Retrieval</td>
<td style="text-align: center;">38.89</td>
<td style="text-align: center;">58.58</td>
</tr>
<tr>
<td style="text-align: center;">Beam</td>
<td style="text-align: center;">58.58</td>
<td style="text-align: center;">58.43</td>
</tr>
<tr>
<td style="text-align: center;">Reference</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">90.43</td>
</tr>
<tr>
<td style="text-align: center;">Random</td>
<td style="text-align: center;">1.14</td>
<td style="text-align: center;">49.08</td>
</tr>
</tbody>
</table>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 2: Overall framework. There are two components in Selfmem, a retrieval-augmented generator (a) and a memory selector (b). For the primal problem, (a) takes source and memory as input to generate candidates for (b). For the dual problem, (b) takes as input source and generated candidates to select memory for (a).
retrieved memory) has already learned to discriminate between different memories in both oracle and random scenarios, without updating the model weights.
To evaluate the second conjecture, we first define the token sets of the reference, retrieved memory, and beam memory as $\mathcal{R}, \mathcal{M}$, and $\mathcal{B}$, respectively. The overlap token set, denoted by $\mathcal{O}$, is defined as the tokens that overlap with the references in the beam memory but not in the retrieved memory, which is represented as $\mathcal{R} \cap \mathcal{B}-\mathcal{R} \cap \mathcal{M} . \mathcal{O}$ is considered as the additional information provided by the beam memory. Inspired by the confidence analysis of NMT model [58], we compute the set confidence score, $\psi(\cdot)$, as follows:</p>
<p>$$
\psi(\cdot)=\frac{1}{|\cdot|} \sum_{y^{\prime} \in \cdot} p\left(y_{i} \mid x, y_{&lt;i}\right)
$$</p>
<p>where $p\left(y_{i} \mid x, y_{&lt;i}\right)$ is defined by the generation model. $\psi(\cdot)$ measures the confidence with which the generation model generates the tokens. The value of $\psi(\mathcal{R})$ is 0.58 , while that of $\mathcal{O}$ is 0.76 , indicating that the generator is relatively confident in generating tokens in $\mathcal{O}$, and therefore does not need to resort to external memory [38]. Beam search ranks generated candidates based on $p(y \mid x)$, where the selected memory falls within the confidence region of the generator and consequently provides no information gain. This observation motivates us to select memory according to metrics other than $p(y \mid x)$ in the memory selector (§3.3).</p>
<h1>3.2 Retrieval-augmented Generator</h1>
<p>Given a text pair $(x, y)$, where $x=\left{\mathrm{x}<em _x_="|x|">{1}, \ldots, \mathrm{x}</em>}\right}$ is the source, $y=\left{\mathrm{y<em _y_="|y|">{1}, \ldots, \mathrm{y}</em>\right)\right}}\right}$ is the target. They could be (document, summary) in summarization, (context, response) in dialogue generation or (source, target) in machine translation. The retrieval-augmented generation would first use $x$ to retrieve memory $m$ from datastore $\mathbb{D}$. Then the generator $G_{\xi}(x, m)$, parameterized by $\xi$, would take both $x$ and $m$ as input to generate the target sentence $y$. In this paper, following standard practice, we choose the training set as $\mathbb{D}=\left{\left(x^{i}, y^{i<em _xi="\xi">{i=1}^{|\mathbb{D}|}$. For LLM as $G</em>$, we only keep the target side of top-1 retrieval results as memory and we consider two commonly used architectures: Joint-Encoder [29, 87, 41] and Dual-Encoder [92, 8, 17].}$, we use the standard in-context learning format to give $(x, y)$ as demonstration example. For tunable generator $G_{\xi</p>
<p>Joint-Encoder This architecture is the standard encoder-decoder-based model [3, 84]. The input is the concatenation of $x$ and $m$. The encoder would first map the input into the hidden states $H$ :</p>
<p>$$
H=\operatorname{Encoder}(x[\mathrm{SEP}] m)
$$</p>
<p>And the decoder would incorporate $H$ by attention mechanism and generate tokens in an autoregressive manner:</p>
<p>$$
h^{i}=\operatorname{Decoder}\left(\operatorname{CrossAttn}(H), y_{&lt;i}\right) \quad P_{G_{\xi}}\left(\cdot \mid x, y_{&lt;i}\right)=\operatorname{Softmax}\left(h^{i}\right)
$$</p>
<p>Dual-Encoder Instead of treating $x$ and $m$ as a long sequence, this architecture has two encoders, one for $x$ and the other for $m$. Their outputs are sequentially attended by the decoder with dual cross attention as in [17]:</p>
<p>$$
\begin{gathered}
H_{x}=\operatorname{SourceEncoder}(x) \quad H_{m}=\operatorname{MemoryEncoder}(m) \
h^{i}=\operatorname{Decoder}\left(\operatorname{CrossAttn}\left(H_{x}, H_{m}\right), y_{&lt;i}\right)
\end{gathered}
$$</p>
<p>We use Transformer [84] as the building block for both architectures and optimize $G_{\xi}$ with NLL loss:</p>
<p>$$
\mathcal{L}<em t="1">{\text {nll }}=-\sum</em>\right)
$$}^{|y|} \log P_{G_{\xi}}\left(y_{t} \mid x, m, y_{&lt;t</p>
<h1>3.3 Memory Selector</h1>
<p>The role of memory selector $S_{\theta}(x, c)$, parameterized by $\theta$, is to select one candidate $c$ from the candidate pool $\mathbb{C}$ generated by $G_{\xi}$ based on a specific metric $\Delta(\cdot, \cdot)$. The chosen candidate $c$ is then utilized as memory $m$ for the subsequent generation round of $G_{\xi}$. As discussed in $\S 3.1$, using $p_{G_{\xi}}(y \mid x)$ as the metric $\Delta(\cdot, \cdot)$ would result in falling into the confidence region of $G_{\xi}$, leading to no information gain. Moreover, a larger value of $p_{G_{\xi}}(y \mid x)$ does not necessarily guarantee improved generation quality [59]. Consequently, we define $\Delta(\cdot, \cdot)$ as model-free metrics that are widely employed for assessing generation quality, such as BLEU for Neural Machine Translation (NMT) and ROUGE for Summarization. Our memory selector takes the concatenation of the source $x$ and candidate $c_{i}$ as input, and produces a multinomial distribution $p_{S_{\theta}}(\cdot \mid x)$ over $\mathbb{C}$.
In this paper, we focus on the role of the memory selector, $S_{\theta}(x, c)$, which is parameterized by $\theta$. The objective of this selector is to choose a single candidate $c$ from the candidate pool $\mathbb{C}$, generated by $G_{\xi}$, based on a specific metric, $\Delta(\cdot, \cdot)$.</p>
<p>$$
p_{S_{\theta}}\left(c_{i} \mid x\right)=\frac{\exp \left(S_{\theta}\left(x\left[\operatorname{SEP}\left[c_{i}\right)\right)\right.}{\sum_{j=1}^{|\mathbb{C}|} \exp \left(S_{\theta}\left(x[\operatorname{SEP}] c_{j}\right)\right)}
$$</p>
<p>In accordance with [39], the training goal for $S_{\theta}$ is to minimize the discrepancy between the $S_{\theta}$ 's predictions and the scores determined by $\Delta(\cdot, \cdot)$. This divergence is quantified using the KullbackLeibler (KL) divergence.</p>
<p>$$
\mathcal{L}<em i="1">{\mathrm{kl}}=-\sum</em>
$$}^{|\mathbb{C}|} p_{M}\left(c_{i}\right) \log p_{S_{\theta}}\left(c_{i} \mid x\right) \quad \text { where } \quad p_{M}\left(c_{i}\right)=\frac{\exp \left(\Delta\left(c_{i}, y\right) / \tau\right)}{\sum_{j=1}^{|\mathbb{C}|} \exp \left(\Delta\left(c_{j}, y\right) / \tau\right)</p>
<p>$\tau$ is the temperature to control the smoothness of the distribution. At inference, the output of the $S_{\theta}$ is $\underset{c_{i} \in \mathbb{C}}{\arg \max } p_{S_{\theta}}\left(c_{i} \mid x\right)$.</p>
<h3>3.4 Combine Generator and Selector</h3>
<p>We define two generation modes for $G_{\xi}$. The first mode, referred to as the hypothesis mode, generates a single output for each input, which is utilized for system evaluation. The second mode, known as the candidate mode, produces N outputs for a given input, and is employed for training $S_{\theta}$ as well as memory selection. By integrating two modes together, we present the complete framework of our proposed model, Selfmem, as illustrated in Algorithm 1.</p>
<h2>4 Experimental Setup</h2>
<h3>4.1 Dataset</h3>
<p>We assess the performance of Selfmem on three generation tasks, utilizing a total of seven datasets. Translation. We evaluate our framework on JRC-Acquis datasets [82], a collection of parallel</p>
<div class="codehilite"><pre><span></span><code><span class="nx">Algorithm</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nx">Selfmem</span><span class="w"> </span><span class="nx">Framework</span>
<span class="nx">Require</span><span class="p">:</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="nx">dataset</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">mathbb</span><span class="p">{</span><span class="nx">D</span><span class="p">}</span><span class="err">\</span><span class="p">),</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="nx">retriever</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="nx">R</span><span class="err">\</span><span class="p">),</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="nx">memory</span><span class="w"> </span><span class="nx">selection</span><span class="w"> </span><span class="nx">metric</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">Delta</span><span class="p">(</span><span class="err">\</span><span class="nx">cdot</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="nx">cdot</span><span class="p">)</span><span class="err">\</span><span class="p">),</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="nx">retrieval</span><span class="o">-</span><span class="nx">augmented</span>
<span class="w">    </span><span class="nx">generator</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="nx">G_</span><span class="p">{</span><span class="err">\</span><span class="nx">xi</span><span class="p">}</span><span class="err">\</span><span class="p">),</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="nx">memory</span><span class="w"> </span><span class="nx">selector</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="nx">S_</span><span class="p">{</span><span class="err">\</span><span class="nx">theta</span><span class="p">}</span><span class="err">\</span><span class="p">)</span>
<span class="w">    </span><span class="nx">retrieve</span><span class="w"> </span><span class="nx">memory</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">mathbb</span><span class="p">{</span><span class="nx">M</span><span class="p">}</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">mathbb</span><span class="p">{</span><span class="nx">D</span><span class="p">}</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="nx">R</span><span class="err">\</span><span class="p">)</span>
<span class="w">    </span><span class="nx">train</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="nx">G_</span><span class="p">{</span><span class="err">\</span><span class="nx">xi</span><span class="p">}</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">mathbb</span><span class="p">{</span><span class="nx">D</span><span class="p">}</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">mathbb</span><span class="p">{</span><span class="nx">M</span><span class="p">}</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="nx">LLM</span><span class="p">)</span>
<span class="w">    </span><span class="nx">use</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="nx">G_</span><span class="p">{</span><span class="err">\</span><span class="nx">xi</span><span class="p">}</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">generate</span><span class="w"> </span><span class="nx">candidate</span><span class="w"> </span><span class="nx">pool</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">mathbb</span><span class="p">{</span><span class="nx">C</span><span class="p">}</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">mathbb</span><span class="p">{</span><span class="nx">M</span><span class="p">}</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nx">candidate</span><span class="w"> </span><span class="nx">mode</span>
<span class="w">    </span><span class="nx">train</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="nx">S_</span><span class="p">{</span><span class="err">\</span><span class="nx">theta</span><span class="p">}</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">on</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">mathbb</span><span class="p">{</span><span class="nx">C</span><span class="p">}</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">Delta</span><span class="p">(</span><span class="err">\</span><span class="nx">cdot</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="nx">cdot</span><span class="p">)</span><span class="err">\</span><span class="p">)</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="nx">converged</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">validation</span><span class="w"> </span><span class="nx">set</span><span class="w"> </span><span class="nx">do</span>
<span class="w">        </span><span class="err">\</span><span class="p">(</span><span class="nx">S_</span><span class="p">{</span><span class="err">\</span><span class="nx">theta</span><span class="p">}</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">selects</span><span class="w"> </span><span class="nx">memory</span><span class="w"> </span><span class="nx">from</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">mathbb</span><span class="p">{</span><span class="nx">C</span><span class="p">}</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">mathbb</span><span class="p">{</span><span class="nx">M</span><span class="p">}</span><span class="err">\</span><span class="p">)</span>
<span class="w">        </span><span class="err">\</span><span class="p">(</span><span class="nx">G_</span><span class="p">{</span><span class="err">\</span><span class="nx">xi</span><span class="p">}</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">generates</span><span class="w"> </span><span class="nx">candidate</span><span class="w"> </span><span class="nx">pool</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">mathbb</span><span class="p">{</span><span class="nx">C</span><span class="p">}</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">mathbb</span><span class="p">{</span><span class="nx">M</span><span class="p">}</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nx">candidate</span><span class="w"> </span><span class="nx">mode</span>
<span class="w">    </span><span class="nx">end</span><span class="w"> </span><span class="k">while</span>
<span class="w">    </span><span class="err">\</span><span class="p">(</span><span class="nx">G_</span><span class="p">{</span><span class="err">\</span><span class="nx">xi</span><span class="p">}</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="nx">generates</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="k">final</span><span class="w"> </span><span class="nx">hypothesis</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">mathbb</span><span class="p">{</span><span class="nx">M</span><span class="p">}</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nx">hypothesis</span><span class="w"> </span><span class="nx">mode</span>
</code></pre></div>

<p>legislative text of European Union Law. It is the benchmark dataset used in translation memoryaugmented NMT task [28, 92, 8, 17]. We choose 4 translation directions, namely, Spanish $\leftrightarrow$ English (Es $\leftrightarrow$ En), German $\leftrightarrow$ English (De $\leftrightarrow$ En). Summarization. We evaluate on 2 summarization datasets: 1) XSum [60], extreme summarization, a single-document summarization dataset with highly abstractive articles from British Broadcasting Corporation. 2) BigPatent [73], consisting of 1.3 million records of U.S. patent documents along with human-written abstractive summaries. Dialogue. We experiment on DailyDialog [44], which contains multi-turn dialogs on daily life topics and is used by $[13,4,103]$. The detailed statistics for these datasets can be found in the Appendix A.</p>
<h1>4.2 Implementation Details</h1>
<p>We utilize the BM25 algorithm [70] for retrieval purposes. For all tasks, the candidate generation method consists of beam search with a beam width of 50 . The number of iterations is determined by the performance on the validation set. For translation, we follow the approach of [93, 8, 17], employing a randomly initialized Transformer base architecture as $G_{\xi}$ for trainable small model and XGLM [48] for LLM in-context learning. Evaluation metrics include BLEU, TER, and chrF++ obtained from SacreBLEU[66]. The memory selector $S_{\theta}$ utilizes an XLM-R ${ }<em _xi="\xi">{\text {base }}$ [22] as backbone, with BLEU serving as $\Delta(\cdot, \cdot)$. For summarization, we initialize $G</em>}$ with BART ${ <em _base="{base" _text="\text">{\text {base }}[40]$ for BigPatent and employ BRIO [55] for XSum. The evaluation metric comprises ROUGE (R$1 / 2 / \mathrm{L})$ [47]. For dialogue generation, BART ${ }</em>$. The linear combination of B-1/2 is chosen as $\Delta(\cdot, \cdot)$ for Dialogue Generation, while R-1/2/L is used for Summarization, following [76]. For further implementation details, please refer to the Appendix B and Appendix C for evaluation metrics.}}$ serves as the backbone for $G_{\xi}$. Our dialogue system is evaluated using BLEU (B-1/2) and Distinct (D-1/2) scores [43]. For both dialogue and summarization tasks, we adhere to the methods of [54, 26], adopting RoBERTa base [52] as the backbone for $S_{\theta</p>
<h2>5 Experimental Results</h2>
<h3>5.1 Machine Translation</h3>
<p>We select four translation directions and experiment with two generation paradigms: trainable small models and few-shot prompted LLMs [85, 20]. For trainable models, we explore two architectures (joint and dual, as detailed in §3.2). The baselines comprise two types of translation systems: one being the vanilla sequence-to-sequence model [3, 84] without memory augmentation, and the other consisting of retrieval-augmented translation models focusing on memory encoding [28, 92], memory construction [101], memory retrieval [8], and memory diversity [17]. Based on the experimental results ${ }^{2}$ shown in Table 2, Selfmem significantly enhances the performance of $G_{\xi}$ across four translation datasets and two different architectures. This is noteworthy, given that the parameters of the $G_{\xi}$ remain fixed, with the only variable being the input memory. This finding is consistent with the primal problem which posits that improved memory typically leads to better generation results.</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>Table 2: Results of translation task on JRC-Acquis measured by BLEU. Models denoted by the same symbol (* and $\dagger$ ) have the same parameters and only differ in memory as input. The bolded numbers show the SOTA performance and the underlined numbers show the second-best result. * denotes the system is significantly better than baselines with $p$-value $&lt;0.05$ tested by [37].</p>
<table>
<thead>
<tr>
<th>System</th>
<th>$\mathbf{E s} \rightarrow$ En</th>
<th></th>
<th>En $\rightarrow$ Es</th>
<th></th>
<th>De $\rightarrow$ En</th>
<th></th>
<th>En $\rightarrow$ De</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Dev</td>
<td>Test</td>
<td>Dev</td>
<td>Test</td>
<td>Dev</td>
<td>Test</td>
<td>Dev</td>
<td>Test</td>
</tr>
<tr>
<td>None Memory</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>RNNsearch [3]</td>
<td>55.02</td>
<td>59.34</td>
<td>50.54</td>
<td>50.48</td>
<td>50.20</td>
<td>49.74</td>
<td>44.94</td>
<td>43.98</td>
</tr>
<tr>
<td>Transformer [84]</td>
<td>64.08</td>
<td>64.63</td>
<td>62.02</td>
<td>61.80</td>
<td>60.18</td>
<td>60.16</td>
<td>54.65</td>
<td>55.43</td>
</tr>
<tr>
<td>Retrieval Memory</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>SEG-NMT [28]</td>
<td>60.28</td>
<td>59.34</td>
<td>57.62</td>
<td>57.27</td>
<td>55.63</td>
<td>55.33</td>
<td>49.26</td>
<td>48.80</td>
</tr>
<tr>
<td>NMT-pieces [101]</td>
<td>63.97</td>
<td>64.30</td>
<td>61.50</td>
<td>61.56</td>
<td>60.10</td>
<td>60.26</td>
<td>55.54</td>
<td>55.14</td>
</tr>
<tr>
<td>G-TFM [92]</td>
<td>66.37</td>
<td>66.21</td>
<td>62.50</td>
<td>62.76</td>
<td>61.85</td>
<td>61.72</td>
<td>57.43</td>
<td>56.88</td>
</tr>
<tr>
<td>MonoNMT [8]</td>
<td>67.73</td>
<td>67.42</td>
<td>64.18</td>
<td>63.86</td>
<td>64.48</td>
<td>64.62</td>
<td>58.77</td>
<td>58.42</td>
</tr>
<tr>
<td>CMM [17]</td>
<td>67.48</td>
<td>67.76</td>
<td>63.84</td>
<td>64.04</td>
<td>64.22</td>
<td>64.33</td>
<td>58.94</td>
<td>58.69</td>
</tr>
<tr>
<td>Transformer ${ }_{\text {dual }}{ }^{*}$</td>
<td>66.87</td>
<td>67.12</td>
<td>63.14</td>
<td>63.54</td>
<td>64.09</td>
<td>63.36</td>
<td>58.69</td>
<td>58.06</td>
</tr>
<tr>
<td>Transformer ${ }_{\text {sen }}$</td>
<td>67.74</td>
<td>67.32</td>
<td>63.93</td>
<td>64.12</td>
<td>64.50</td>
<td>64.40</td>
<td>58.16</td>
<td>58.58</td>
</tr>
<tr>
<td>Self-Memory</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Transformer ${ }_{\text {dual }}{ }^{*}$</td>
<td>$\mathbf{6 8 . 6 3}{ }^{*}$</td>
<td>$\mathbf{6 9 . 2 0}{ }^{*}$</td>
<td>$64.12^{*}$</td>
<td>$64.67^{*}$</td>
<td>$65.06^{*}$</td>
<td>$64.98^{*}$</td>
<td>$59.26^{*}$</td>
<td>$59.49^{*}$</td>
</tr>
<tr>
<td>Transformer ${ }_{\text {sen }}$</td>
<td>$68.26^{*}$</td>
<td>$68.80^{*}$</td>
<td>$\mathbf{6 6 . 0 7}^{*}$</td>
<td>$\mathbf{6 5 . 9 4}^{*}$</td>
<td>$\mathbf{6 5 . 3 2}^{*}$</td>
<td>$\mathbf{6 5 . 6 5}^{*}$</td>
<td>$\mathbf{5 9 . 8 8}^{*}$</td>
<td>$\mathbf{6 0 . 1 1}^{*}$</td>
</tr>
</tbody>
</table>
<p>Table 3: Comparison between retrieval memory and self-memory. The quality of memory and hypothesis is measured by the n-gram overlap with reference (BLEU). All experiments are conducted with Transformer ${ }_{\text {joint }}$ on JRC-Acquis.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Retrieval</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Self</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">memory</td>
<td style="text-align: center;">hypothesis</td>
<td style="text-align: center;">memory</td>
<td style="text-align: center;">hypothesis</td>
</tr>
<tr>
<td style="text-align: left;">En-De</td>
<td style="text-align: center;">$\rightarrow$</td>
<td style="text-align: center;">38.89</td>
<td style="text-align: center;">58.58</td>
<td style="text-align: center;">57.92</td>
<td style="text-align: center;">60.11</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;">$\leftarrow$</td>
<td style="text-align: center;">42.56</td>
<td style="text-align: center;">64.40</td>
<td style="text-align: center;">64.32</td>
<td style="text-align: center;">65.65</td>
</tr>
<tr>
<td style="text-align: left;">En-Es</td>
<td style="text-align: center;">$\rightarrow$</td>
<td style="text-align: center;">40.67</td>
<td style="text-align: center;">64.12</td>
<td style="text-align: center;">63.57</td>
<td style="text-align: center;">65.94</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;">$\leftarrow$</td>
<td style="text-align: center;">43.05</td>
<td style="text-align: center;">67.32</td>
<td style="text-align: center;">67.78</td>
<td style="text-align: center;">68.80</td>
</tr>
</tbody>
</table>
<p>The dual problem is revealed in Table 3. Self-memory, which essentially represents the model's own output, exhibits greater similarity with the ground truth and serves as a more effective memory for generating the final output. This observation highlights a key distinction between Selfmem and previous reranking works [39, 68]. Reranking aims to select candidates of higher quality than the beam output, whereas in Selfmem, the chosen candidates serve as memory for the retrieval-augmented generator and do not necessarily need to surpass the quality of the beam hypotheses.</p>
<p>Table 4: Evaluation results of in-context learning with self-memory.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">XGLM-1.7B</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">XGLM-4.5B</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">XGLM-7.5B</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Random</td>
<td style="text-align: center;">kNN</td>
<td style="text-align: center;">Self</td>
<td style="text-align: center;">Random</td>
<td style="text-align: center;">kNN</td>
<td style="text-align: center;">Self</td>
<td style="text-align: center;">Random</td>
<td style="text-align: center;">kNN</td>
<td style="text-align: center;">Self</td>
</tr>
<tr>
<td style="text-align: center;">En-De</td>
<td style="text-align: center;">$\rightarrow$</td>
<td style="text-align: center;">11.51</td>
<td style="text-align: center;">37.87</td>
<td style="text-align: center;">40.94</td>
<td style="text-align: center;">17.51</td>
<td style="text-align: center;">37.60</td>
<td style="text-align: center;">38.25</td>
<td style="text-align: center;">18.48</td>
<td style="text-align: center;">47.82</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">$\leftarrow$</td>
<td style="text-align: center;">27.42</td>
<td style="text-align: center;">51.00</td>
<td style="text-align: center;">51.88</td>
<td style="text-align: center;">30.62</td>
<td style="text-align: center;">48.12</td>
<td style="text-align: center;">48.36</td>
<td style="text-align: center;">33.03</td>
<td style="text-align: center;">55.65</td>
</tr>
<tr>
<td style="text-align: center;">En-Es</td>
<td style="text-align: center;">$\rightarrow$</td>
<td style="text-align: center;">23.87</td>
<td style="text-align: center;">46.20</td>
<td style="text-align: center;">48.56</td>
<td style="text-align: center;">31.83</td>
<td style="text-align: center;">48.37</td>
<td style="text-align: center;">49.17</td>
<td style="text-align: center;">29.97</td>
<td style="text-align: center;">53.86</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">$\leftarrow$</td>
<td style="text-align: center;">25.29</td>
<td style="text-align: center;">51.55</td>
<td style="text-align: center;">53.13</td>
<td style="text-align: center;">32.16</td>
<td style="text-align: center;">48.55</td>
<td style="text-align: center;">49.22</td>
<td style="text-align: center;">35.22</td>
<td style="text-align: center;">57.25</td>
</tr>
</tbody>
</table>
<p>In Table 4, we present the results of LLM with self-memory. We employ XGLM [48] as our backbone generator, with three different sizes ranging from 1.7 B to 7.5 B . We utilize the recommended prompt as described in [48]. We select three in-context learning examples and report the average scores from three separate runs, taking into account the sensitivity of example selection in ICL [49]. From the table, we first observe a general trend where few-shot translation performance improves as the</p>
<p>size of the model increases. Furthermore, we find that more similar translation demonstrations significantly enhance performance across all model sizes (from random, kNN to Self). This suggests that demonstration examples in in-context learning not only act as triggers for model ability but also adhere to the primal problem, where better demonstration example leads to better generation. Also, by comparing the results in Table 2 and Table 4, we can conclude that the cross-lingual LLM with designed examples still falls short of the supervised baselines in this task.</p>
<h1>5.2 Summarization</h1>
<p>In this paper, we compare the performance of our trainable model with those of REINA [87], PEGASUS [100], and BART [40]. The results are presented in Table5. Initially, it can be observed that memory has varying impacts on different datasets. The enhancement brought by memory in the BigPatent dataset is significantly larger than that in the XSum dataset. This can be attributed to the inherent characteristics of the BigPatent dataset, which consists of official patent documents that exhibit considerable similarity. Consequently, this greatly improves the summarization quality in accordance with the primal problem. Furthermore, we discovered that self-memory substantially enhances the performance of both BRIO (+1.2 R1) and BART (+18.5 R1), achieving state-of-the-art results on both datasets. We selected these baselines for a fair comparison, as they share the same base generator. Due to space constraints, additional comparisons and the confidence region of the SOTA model can be found in the Appendix E.</p>
<p>Table 5: Results of summarization task on XSum and BigPatent measured by ROUGE.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">System</th>
<th style="text-align: center;">Memory</th>
<th style="text-align: center;">R-1</th>
<th style="text-align: center;">R-2</th>
<th style="text-align: center;">R-L</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">XSum</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">PEGASUS</td>
<td style="text-align: center;">None</td>
<td style="text-align: center;">47.2</td>
<td style="text-align: center;">24.6</td>
<td style="text-align: center;">39.3</td>
</tr>
<tr>
<td style="text-align: center;">BRIO</td>
<td style="text-align: center;">None</td>
<td style="text-align: center;">49.1</td>
<td style="text-align: center;">25.6</td>
<td style="text-align: center;">40.4</td>
</tr>
<tr>
<td style="text-align: center;">REINA (PG)</td>
<td style="text-align: center;">Retrieval</td>
<td style="text-align: center;">48.2</td>
<td style="text-align: center;">26.0</td>
<td style="text-align: center;">40.2</td>
</tr>
<tr>
<td style="text-align: center;">REINA (B)</td>
<td style="text-align: center;">Retrieval</td>
<td style="text-align: center;">43.2</td>
<td style="text-align: center;">21.0</td>
<td style="text-align: center;">35.5</td>
</tr>
<tr>
<td style="text-align: center;">REINA (L)</td>
<td style="text-align: center;">Retrieval</td>
<td style="text-align: center;">46.5</td>
<td style="text-align: center;">24.1</td>
<td style="text-align: center;">38.6</td>
</tr>
<tr>
<td style="text-align: center;">BRIO $_{\text {dual } *}$</td>
<td style="text-align: center;">Retrieval</td>
<td style="text-align: center;">48.6</td>
<td style="text-align: center;">26.1</td>
<td style="text-align: center;">40.6</td>
</tr>
<tr>
<td style="text-align: center;">BRIO $_{\text {joint }} \dagger$</td>
<td style="text-align: center;">Retrieval</td>
<td style="text-align: center;">49.5</td>
<td style="text-align: center;">26.5</td>
<td style="text-align: center;">41.2</td>
</tr>
<tr>
<td style="text-align: center;">BRIO $_{\text {dual } *}$</td>
<td style="text-align: center;">Self</td>
<td style="text-align: center;">49.2</td>
<td style="text-align: center;">26.2</td>
<td style="text-align: center;">40.8</td>
</tr>
<tr>
<td style="text-align: center;">BRIO $_{\text {joint }} \dagger$</td>
<td style="text-align: center;">Self</td>
<td style="text-align: center;">50.3</td>
<td style="text-align: center;">26.7</td>
<td style="text-align: center;">41.6</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;">System</th>
<th style="text-align: center;">Memory</th>
<th style="text-align: center;">R-1</th>
<th style="text-align: center;">R-2</th>
<th style="text-align: center;">R-L</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">BigPatent</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">PEGASUS</td>
<td style="text-align: center;">None</td>
<td style="text-align: center;">53.6</td>
<td style="text-align: center;">33.2</td>
<td style="text-align: center;">43.2</td>
</tr>
<tr>
<td style="text-align: center;">BART</td>
<td style="text-align: center;">None</td>
<td style="text-align: center;">44.4</td>
<td style="text-align: center;">21.3</td>
<td style="text-align: center;">31.0</td>
</tr>
<tr>
<td style="text-align: center;">REINA (B)</td>
<td style="text-align: center;">Retrieval</td>
<td style="text-align: center;">59.5</td>
<td style="text-align: center;">42.6</td>
<td style="text-align: center;">50.6</td>
</tr>
<tr>
<td style="text-align: center;">REINA (L)</td>
<td style="text-align: center;">Retrieval</td>
<td style="text-align: center;">60.7</td>
<td style="text-align: center;">43.3</td>
<td style="text-align: center;">51.3</td>
</tr>
<tr>
<td style="text-align: center;">REINA (PG)</td>
<td style="text-align: center;">Retrieval</td>
<td style="text-align: center;">44.6</td>
<td style="text-align: center;">21.5</td>
<td style="text-align: center;">33.3</td>
</tr>
<tr>
<td style="text-align: center;">BART $_{\text {dual } *}$</td>
<td style="text-align: center;">Retrieval</td>
<td style="text-align: center;">57.4</td>
<td style="text-align: center;">43.3</td>
<td style="text-align: center;">49.7</td>
</tr>
<tr>
<td style="text-align: center;">BART $_{\text {joint }} \dagger$</td>
<td style="text-align: center;">Retrieval</td>
<td style="text-align: center;">59.6</td>
<td style="text-align: center;">43.4</td>
<td style="text-align: center;">51.0</td>
</tr>
<tr>
<td style="text-align: center;">BART $_{\text {dual } *}$</td>
<td style="text-align: center;">Self</td>
<td style="text-align: center;">61.2</td>
<td style="text-align: center;">44.6</td>
<td style="text-align: center;">52.3</td>
</tr>
<tr>
<td style="text-align: center;">BART $_{\text {joint }} \dagger$</td>
<td style="text-align: center;">Self</td>
<td style="text-align: center;">62.9</td>
<td style="text-align: center;">48.1</td>
<td style="text-align: center;">59.6</td>
</tr>
</tbody>
</table>
<h3>5.3 Dialogue Generation</h3>
<p>As demonstrated in Table 6, the self-memory significantly enhances the performance of the retrievalaugmented generator for dialogue generation tasks. By optimizing memory using BLEU as $\Delta(\cdot, \cdot)$, the self-memory improves the B-1,2 score over retrieved memory by 3.08 B-1 and 0.6 B-2 on BART $<em _theta="\theta">{\text {joint }}$. Intriguingly, although Selfmem surpasses the baselines in terms of B-1/2, it falls behind in D-1 and D-2, which can be attributed to the trade-off between BLEU score and Distinct score when evaluating a dialogue system [104]. To address this issue, we opt for D-1,2 as $\Delta(\cdot, \cdot)$ when optimizing $S</em>)$. The results in Table 6 highlight the remarkable flexibility of Selfmem by directly optimizing memory to achieve the desired attributes for diverse and informative dialogue.}$, denoted as BART $_{\text {joint }} \dagger(\mathrm{D</p>
<h2>6 Further Analysis</h2>
<p>To gain a deeper insight into Selfmem, we first examine the impact of each key component, namely $G_{\xi}$ and $S_{\theta}$. Subsequently, we perform a detailed token-level analysis of the generated output concerning their frequency in the training set. Experiments are conducted on the JRC-Acquis En $\rightarrow$ De dataset. We also include latency analysis and human evaluation on Appendix F and G.</p>
<p>Tuning $S_{\theta}$ We explored various $S_{\theta}$ by direct selection from the candidate pool based on gold rankings. As shown in Figure 3a, both architectures with enhanced $S_{\theta}$ significantly outperform the current SOTA performance ( 60.11 BLEU). Moreover, we assessed the candidate pool quality during this iterative process using an oracle $S_{\theta}$, as displayed in Figure 3b. A clear pattern emerges</p>
<p>Table 6: Results of dialogue generation task on DailyDialog measured by B-1/2 and D-1/2. BART ${ }<em _theta="\theta">{\text {joint }}(\mathrm{D})$ denotes the metric $\Delta(\cdot, \cdot)$ for $S</em>$ is the average of D-1 and D-2.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">System</th>
<th style="text-align: center;">Memory</th>
<th style="text-align: center;">B-1</th>
<th style="text-align: center;">B-2</th>
<th style="text-align: center;">D-1</th>
<th style="text-align: center;">D-2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">NCM [86]</td>
<td style="text-align: center;">None</td>
<td style="text-align: center;">33.60</td>
<td style="text-align: center;">26.80</td>
<td style="text-align: center;">3.00</td>
<td style="text-align: center;">12.80</td>
</tr>
<tr>
<td style="text-align: left;">iVAE [25]</td>
<td style="text-align: center;">None</td>
<td style="text-align: center;">30.90</td>
<td style="text-align: center;">24.90</td>
<td style="text-align: center;">2.90</td>
<td style="text-align: center;">25.00</td>
</tr>
<tr>
<td style="text-align: left;">PLATO-2 [5]</td>
<td style="text-align: center;">None</td>
<td style="text-align: center;">34.80</td>
<td style="text-align: center;">25.12</td>
<td style="text-align: center;">3.54</td>
<td style="text-align: center;">25.11</td>
</tr>
<tr>
<td style="text-align: left;">DialoFlow [45]</td>
<td style="text-align: center;">None</td>
<td style="text-align: center;">36.17</td>
<td style="text-align: center;">27.67</td>
<td style="text-align: center;">4.56</td>
<td style="text-align: center;">27.12</td>
</tr>
<tr>
<td style="text-align: left;">BART</td>
<td style="text-align: center;">None</td>
<td style="text-align: center;">20.72</td>
<td style="text-align: center;">11.36</td>
<td style="text-align: center;">3.92</td>
<td style="text-align: center;">19.44</td>
</tr>
<tr>
<td style="text-align: left;">BART $_{\text {dual }}{ }^{*}$</td>
<td style="text-align: center;">Retrieval</td>
<td style="text-align: center;">29.50</td>
<td style="text-align: center;">21.89</td>
<td style="text-align: center;">4.74</td>
<td style="text-align: center;">26.01</td>
</tr>
<tr>
<td style="text-align: left;">BART $_{\text {joint }} \dagger$</td>
<td style="text-align: center;">Retrieval</td>
<td style="text-align: center;">36.72</td>
<td style="text-align: center;">31.55</td>
<td style="text-align: center;">6.13</td>
<td style="text-align: center;">35.65</td>
</tr>
<tr>
<td style="text-align: left;">BART $_{\text {dual }}{ }^{*}$</td>
<td style="text-align: center;">Self</td>
<td style="text-align: center;">33.43</td>
<td style="text-align: center;">22.85</td>
<td style="text-align: center;">4.66</td>
<td style="text-align: center;">26.16</td>
</tr>
<tr>
<td style="text-align: left;">BART $_{\text {joint }} \dagger$</td>
<td style="text-align: center;">Self</td>
<td style="text-align: center;">$\mathbf{3 9 . 8 0}$</td>
<td style="text-align: center;">$\mathbf{3 2 . 1 5}$</td>
<td style="text-align: center;">5.84</td>
<td style="text-align: center;">32.16</td>
</tr>
<tr>
<td style="text-align: left;">BART $_{\text {joint }} \dagger$ (D)</td>
<td style="text-align: center;">Self</td>
<td style="text-align: center;">36.92</td>
<td style="text-align: center;">32.09</td>
<td style="text-align: center;">$\mathbf{9 . 1 2}$</td>
<td style="text-align: center;">$\mathbf{3 7 . 0 5}$</td>
</tr>
</tbody>
</table>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 3: (a) shows generation quality in the iteration process with different $S_{\theta}$ in both trainable generator architectures. (b) shows candidates quality in the iteration process with an oracle $S_{\theta}$.
in this boxplot, revealing improvements in the oracle, quartile, average, and minimum scores of the candidate pool. These two experiments jointly clarify the Selfmem's underlying intuition: a retrieval-augmented generator profits from superior memory, which can be chosen from its own unbounded output, and subsequently, the generator with improved memory produces a higher-quality candidate pool for the next selection round. Consequently, the model lift itself up.</p>
<p>Tuning $G_{\xi}$ As discussed in $\S 3.1$, we demonstrated that a trained retrieval-augmented generator, with fixed parameters, possesses the ability to distinguish between "good" and "bad" memory. This observation not only justifies our decision to maintain a fixed generator within our framework but also implies that the $G_{\xi}$ is not the current bottleneck of the Selfmem.</p>
<p>Frequency Analysis We conduct a comprehensive tokenlevel analysis by computing the 1-gram F1 scores for generated translations and subsequently categorizing the tokens based on their frequency in the training set. The results are depicted in Figure 4. A noticeable pattern emerges, suggesting that the more frequently a model encounters a token during training, the higher the accuracy of the generated output [102]. Moreover, our findings indicate that retrievalaugmented models, particularly those incorporating self-memory augmentation, exhibit superior performance in handling long-tail inputs which are challenges for parametric models [67, 57].</p>
<h1>7 Conclusion</h1>
<p>For the first time, we investigate the fundamental limitation of bounded memory in the current retrieval-augmented literature. We combine the primal and dual problems together and propose Selfmem, a general framework for retrieval-augmented text generation by uplifting generation model with its own output. We conduct comprehensive experiments across various text generation tasks and different generation paradigms, including trainable small model and few-shot prompted LLM. We surpass strong baselines and improve the state-of-the-art performance in serval datasets. We also meticulously investigate each crucial component and pinpoint the existing system bottleneck to guide future research endeavors.</p>
<h2>Limitations</h2>
<p>We discuss the limitations of our framework as follows:
(1) Although Selfmem greatly improves the generation quality compared with other retrievalaugmented generation models, it requires more computational resources with respect to the memory selection process. For large dataset with long context (e.g., BigPatent), it would become a more crucial problem considering the quadratic time complexity of transformer architecture.
(2) This paper proposes a general idea for the retrieval-augmented generation. But we only experiment with transformer-based architecture for both generator and memory selector and the architecture of generator and memory selector keeps the same across all text generation tasks. We believe the task-specific design for the model architecture, training objective and generation methods in different text generation scenarios would further improve the performance.</p>
<h2>Acknowledgement</h2>
<p>This work was supported by the National Key Research and Development Program of China (No.2021YFC3340304) and National Natural Science Foundation of China (NSFC Grant No. 62122089). We appreciate the anonymous reviewers for their helpful comments. Dongyan Zhao and Rui Yan are the corresponding authors.</p>
<h2>References</h2>
<p>[1] Armen Aghajanyan, Anchit Gupta, Akshat Shrivastava, Xilun Chen, Luke Zettlemoyer, and Sonal Gupta. Muppet: Massive multi-task representations with pre-finetuning. In Proc. of EMNLP, 2021.
[2] Sweta Agrawal, Chunting Zhou, Mike Lewis, Luke Zettlemoyer, and Marjan Ghazvininejad. In-context examples selection for machine translation. CoRR, 2022.
[3] Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. Neural machine translation by jointly learning to align and translate. In Proc. of ICLR, 2015.
[4] Siqi Bao, Huang He, Fan Wang, Hua Wu, and Haifeng Wang. PLATO: pre-trained dialogue generation model with discrete latent variable. In Proc. of ACL, 2020.
[5] Siqi Bao, Huang He, Fan Wang, Hua Wu, Haifeng Wang, Wenquan Wu, Zhen Guo, Zhibin Liu, and Xinchao Xu. PLATO-2: Towards building an open-domain chatbot via curriculum learning. In Proc. of ACL Findings, 2021.
[6] Deng Cai, Yan Wang, Wei Bi, Zhaopeng Tu, Xiaojiang Liu, Wai Lam, and Shuming Shi. Skeleton-to-response: Dialogue generation guided by retrieval memory. In Proc. of NAACL, 2019.
[7] Deng Cai, Yan Wang, Wei Bi, Zhaopeng Tu, Xiaojiang Liu, and Shuming Shi. Retrieval-guided dialogue response generation via a matching-to-generation framework. In Proc. of EMNLP, 2019.</p>
<p>[8] Deng Cai, Yan Wang, Huayang Li, Wai Lam, and Lemao Liu. Neural machine translation with monolingual translation memory. In Proc. of ACL, 2021.
[9] Chris Callison-Burch, Miles Osborne, and Philipp Koehn. Re-evaluating the role of Bleu in machine translation research. In Proc. of EACL, 2006.
[10] Qian Cao and Deyi Xiong. Encoding gated translation memory into neural machine translation. In Proc. of EMNLP, 2018.
[11] Eugene Charniak and Mark Johnson. Coarse-to-fine n-best parsing and maxent discriminative reranking. In Proc. of ACL, 2005.
[12] Danqi Chen, Adam Fisch, Jason Weston, and Antoine Bordes. Reading wikipedia to answer open-domain questions. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 1870-1879, 2017.
[13] Wei Chen, Yeyun Gong, Song Wang, Bolun Yao, Weizhen Qi, Zhongyu Wei, Xiaowu Hu, Bartuer Zhou, Yi Mao, Weizhu Chen, Biao Cheng, and Nan Duan. Dialogved: A pre-trained latent variable encoder-decoder model for dialog response generation. In Proc. of ACL, 2022.
[14] Xiuying Chen, Hind Alamro, Mingzhe Li, Shen Gao, Rui Yan, Xin Gao, and Xiangliang Zhang. Target-aware abstractive related work generation with contrastive learning. In Proc. of SIGIR, 2022.
[15] Xiuying Chen, Mingzhe Li, Shen Gao, Xin Cheng, Qiang Yang, Qishen Zhang, Xin Gao, and Xiangliang Zhang. A topic-aware summarization framework with different modal side information. Proc. of SIGIR, 2023.
[16] Xiuying Chen, Mingzhe Li, Xin Gao, and Xiangliang Zhang. Towards improving faithfulness in abstractive summarization. In Proc. of NeurIPS, 2022.
[17] Xin Cheng, Shen Gao, Lemao Liu, Dongyan Zhao, and Rui Yan. Neural machine translation with contrastive translation memories. In Proc. of EMNLP, 2022.
[18] Xin Cheng, Shen Gao, Yuchi Zhang, Yongliang Wang, Xiuying Chen, Mingzhe Li, Dongyan Zhao, and Rui Yan. Towards personalized review summarization by modeling historical reviews from customer and product separately. arXiv preprint arXiv:2301.11682, 2023.
[19] Xin Cheng, Yankai Lin, Xiuying Chen, Dongyan Zhao, and Rui Yan. Decouple knowledge from paramters for plug-and-play language modeling. In Findings of the Association for Computational Linguistics: ACL 2023, pages 14288-14308, Toronto, Canada, July 2023. Association for Computational Linguistics.
[20] Xin Cheng, Xun Wang, Tao Ge, Si-Qing Chen, Furu Wei, Dongyan Zhao, and Rui Yan. Scale: Synergized collaboration of asymmetric language translation engines, 2023.
[21] Michael Collins and Terry Koo. Discriminative reranking for natural language parsing. Comput. Linguistics, 2005.
[22] Alexis Conneau, Kartikay Khandelwal, Naman Goyal, Vishrav Chaudhary, Guillaume Wenzek, Francisco Guzmán, Edouard Grave, Myle Ott, Luke Zettlemoyer, and Veselin Stoyanov. Unsupervised cross-lingual representation learning at scale. In Proc. of ACL, 2020.
[23] Yuntian Deng, Anton Bakhtin, Myle Ott, Arthur Szlam, and Marc'Aurelio Ranzato. Residual energy-based models for text generation. In Proc. of ICLR, 2020.
[24] Tanay Dixit, Bhargavi Paranjape, Hannaneh Hajishirzi, and Luke Zettlemoyer. CORE: A retrieve-then-edit framework for counterfactual data generation. In Proc. of EMNLP Findings, 2022.
[25] Le Fang, Chunyuan Li, Jianfeng Gao, Wen Dong, and Changyou Chen. Implicit deep latent variable models for text generation. In Proc. of EMNLP, 2019.</p>
<p>[26] Jiazhan Feng, Chongyang Tao, Zhen Li, Chang Liu, Tao Shen, and Dongyan Zhao. Reciprocal learning of knowledge retriever and response ranker for knowledge-grounded conversations. In Proc. of COLING, 2022.
[27] Tingchen Fu, Xueliang Zhao, Chongyang Tao, Ji-Rong Wen, and Rui Yan. There are a thousand hamlets in a thousand people’s eyes: Enhancing knowledge-grounded dialogue with personal memory. In Proc. of ACL, 2022.
[28] Jiatao Gu, Yong Wang, Kyunghyun Cho, and Victor O. K. Li. Search engine guided neural machine translation. In Proc. of AAAI, 2018.
[29] Kelvin Guu, Kenton Lee, Zora Tung, Panupong Pasupat, and Ming-Wei Chang. Retrieval augmented language model pre-training. In Proc. of ICML, 2020.
[30] Tatsunori B. Hashimoto, Kelvin Guu, Yonatan Oren, and Percy Liang. A retrieve-and-edit framework for predicting structured outputs. In Proc. of NeurIPS, 2018.
[31] Qiuxiang He, Guoping Huang, Qu Cui, Li Li, and Lemao Liu. Fast and accurate neural machine translation with translation memory. In Proc. of ACL, 2021.
[32] Kenji Imamura and Eiichiro Sumita. Ensemble and reranking: Using multiple models in the NICT-2 neural machine translation system at WAT2017. In Proceedings of the 4th Workshop on Asian Translation, WAT@IJCNLP 2017, Taipei, Taiwan, November 27- December 1, 2017, 2017.
[33] Gautier Izacard and Edouard Grave. Leveraging passage retrieval with generative models for open domain question answering. In Proceedings of the 16th Conference of the European Chapter of the Association for Computational Linguistics: Main Volume, pages 874-880, Online, April 2021. Association for Computational Linguistics.
[34] Amirhossein Kazemnejad, Mohammadreza Salehi, and Mahdieh Soleymani Baghshah. Paraphrase generation by learning how to edit from samples. In Proc. of ACL, 2020.
[35] Urvashi Khandelwal, Angela Fan, Dan Jurafsky, Luke Zettlemoyer, and Mike Lewis. Nearest neighbor machine translation. In Proc. of ICLR, 2021.
[36] Urvashi Khandelwal, Omer Levy, Dan Jurafsky, Luke Zettlemoyer, and Mike Lewis. Generalization through memorization: Nearest neighbor language models. In Proc. of ICLR, 2020.
[37] Philipp Koehn. Statistical significance tests for machine translation evaluation. In Proc. of EMNLP, 2004.
[38] Ankit Kumar, Ozan Irsoy, Peter Ondruska, Mohit Iyyer, James Bradbury, Ishaan Gulrajani, Victor Zhong, Romain Paulus, and Richard Socher. Ask me anything: Dynamic memory networks for natural language processing. In Proc. of ICML, 2016.
[39] Ann Lee, Michael Auli, and Marc'Aurelio Ranzato. Discriminative reranking for neural machine translation. In Proc. of ACL, 2021.
[40] Mike Lewis, Yinhan Liu, Naman Goyal, Marjan Ghazvininejad, Abdelrahman Mohamed, Omer Levy, Veselin Stoyanov, and Luke Zettlemoyer. BART: denoising sequence-to-sequence pre-training for natural language generation, translation, and comprehension. In Proc. of ACL, 2020.
[41] Patrick S. H. Lewis, Ethan Perez, Aleksandra Piktus, Fabio Petroni, Vladimir Karpukhin, Naman Goyal, Heinrich Küttler, Mike Lewis, Wen-tau Yih, Tim Rocktäschel, Sebastian Riedel, and Douwe Kiela. Retrieval-augmented generation for knowledge-intensive NLP tasks. In Proc. of NeurIPS, 2020.
[42] Jinpeng Li, Yingce Xia, Rui Yan, Hongda Sun, Dongyan Zhao, and Tie-Yan Liu. Stylized dialogue generation with multi-pass dual learning. In Proc. of NeurIPS, 2021.
[43] Jiwei Li, Michel Galley, Chris Brockett, Jianfeng Gao, and Bill Dolan. A diversity-promoting objective function for neural conversation models. In Proc. of NAACL, 2016.</p>
<p>[44] Yanran Li, Hui Su, Xiaoyu Shen, Wenjie Li, Ziqiang Cao, and Shuzi Niu. Dailydialog: A manually labelled multi-turn dialogue dataset. In Proceedings of the Eighth International Joint Conference on Natural Language Processing, IJCNLP 2017, Taipei, Taiwan, November 27 December 1, 2017 - Volume 1: Long Papers, 2017.
[45] Zekang Li, Jinchao Zhang, Zhengcong Fei, Yang Feng, and Jie Zhou. Conversations are not flat: Modeling the dynamic information flow across dialogue utterances. In Proc. of ACL, 2021.
[46] Zekun Li, Wenhu Chen, Shiyang Li, Hong Wang, Jing Qian, and Xifeng Yan. Controllable dialogue simulation with in-context learning. In Proc. of EMNLP Findings, 2022.
[47] Chin-Yew Lin. ROUGE: A package for automatic evaluation of summaries. In Text Summarization Branches Out, 2004.
[48] Xi Victoria Lin, Todor Mihaylov, Mikel Artetxe, Tianlu Wang, Shuohui Chen, Daniel Simig, Myle Ott, Naman Goyal, Shruti Bhosale, Jingfei Du, Ramakanth Pasunuru, Sam Shleifer, Punit Singh Koura, Vishrav Chaudhary, Brian O’Horo, Jeff Wang, Luke Zettlemoyer, Zornitsa Kozareva, Mona T. Diab, Veselin Stoyanov, and Xian Li. Few-shot learning with multilingual generative language models. In Proc. of EMNLP, 2022.
[49] Jiachang Liu, Dinghan Shen, Yizhe Zhang, Bill Dolan, Lawrence Carin, and Weizhu Chen. What makes good in-context examples for gpt-3? In Proceedings of Deep Learning Inside Out: The 3rd Workshop on Knowledge Extraction and Integration for Deep Learning Architectures, DeeLIO@ACL 2022, Dublin, Ireland and Online, May 27, 2022, 2022.
[50] Lemao Liu, Hailong Cao, Taro Watanabe, Tiejun Zhao, Mo Yu, and Conghui Zhu. Locally training the log-linear model for SMT. In Proc. of EMNLP, 2012.
[51] Yang Liu and Mirella Lapata. Text summarization with pretrained encoders. In Proc. of EMNLP, 2019.
[52] Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Danqi Chen, Omer Levy, Mike Lewis, Luke Zettlemoyer, and Veselin Stoyanov. Roberta: A robustly optimized BERT pretraining approach. CoRR, 2019.
[53] Yixin Liu, Zi-Yi Dou, and Pengfei Liu. Refsum: Refactoring neural summarization. In Proc. of NAACL, 2021.
[54] Yixin Liu and Pengfei Liu. Simcls: A simple framework for contrastive learning of abstractive summarization. In Proc. of ACL, 2021.
[55] Yixin Liu, Pengfei Liu, Dragomir R. Radev, and Graham Neubig. BRIO: bringing order to abstractive summarization. In Proc. of ACL, 2022.
[56] Yuchen Liu, Long Zhou, Yining Wang, Yang Zhao, Jiajun Zhang, and Chengqing Zong. A comparable study on model averaging, ensembling and reranking in NMT. In Proc. of NLPCC, 2018.
[57] Alexander Long, Wei Yin, Thalaiyasingam Ajanthan, Vu Nguyen, Pulak Purkait, Ravi Garg, Alan Blair, Chunhua Shen, and Anton van den Hengel. Retrieval augmented classification for long-tail visual recognition. In Proc. of CVPR, 2022.
[58] Yu Lu, Jiali Zeng, Jiajun Zhang, Shuangzhi Wu, and Mu Li. Learning confidence for transformer-based neural machine translation. In Proc. of ACL, 2022.
[59] Clara Meister, Ryan Cotterell, and Tim Vieira. If beam search is the answer, what was the question? In Proc. of EMNLP, 2020.
[60] Shashi Narayan, Shay B. Cohen, and Mirella Lapata. Don't give me the details, just the summary! topic-aware convolutional neural networks for extreme summarization. In Proc. of EMNLP, 2018.</p>
<p>[61] Franz Josef Och, Daniel Gildea, Sanjeev Khudanpur, Anoop Sarkar, Kenji Yamada, Alexander M. Fraser, Shankar Kumar, Libin Shen, David Smith, Katherine Eng, Viren Jain, Zhen Jin, and Dragomir R. Radev. A smorgasbord of features for statistical machine translation. In Proc. of NAACL, 2004.
[62] OpenAI. GPT-4 technical report. CoRR, 2023.
[63] Md. Rizwan Parvez, Wasi Uddin Ahmad, Saikat Chakraborty, Baishakhi Ray, and Kai-Wei Chang. Retrieval augmented code generation and summarization. In Proc. of EMNLP Findings, 2021.
[64] Hao Peng, Ankur P. Parikh, Manaal Faruqui, Bhuwan Dhingra, and Dipanjan Das. Text generation with exemplar-based adaptive decoding. In Proc. of NAACL, 2019.
[65] Jonathan Pilault, Raymond Li, Sandeep Subramanian, and Chris Pal. On extractive and abstractive neural document summarization with transformer language models. In Proc. of EMNLP, 2020.
[66] Matt Post. A call for clarity in reporting BLEU scores. In Proceedings of the Third Conference on Machine Translation: Research Papers, WMT 2018, Belgium, Brussels, October 31 November 1, 2018, 2018.
[67] Vikas Raunak, Siddharth Dalmia, Vivek Gupta, and Florian Metze. On long-tailed phenomena in neural machine translation. In Proc. of EMNLP Findings, 2020.
[68] Mathieu Ravaut, Shafiq R. Joty, and Nancy F. Chen. Summareranker: A multi-task mixture-ofexperts re-ranking framework for abstractive summarization. In Proc. of ACL, 2022.
[69] Mathieu Ravaut, Shafiq R. Joty, and Nancy F. Chen. Towards summary candidates fusion. CoRR, 2022.
[70] Stephen E. Robertson and Hugo Zaragoza. The probabilistic relevance framework: BM25 and beyond. Found. Trends Inf. Retr., 2009.
[71] Julian Salazar, Davis Liang, Toan Q. Nguyen, and Katrin Kirchhoff. Masked language model scoring. In Proc. of ACL, 2020.
[72] Rico Sennrich, Barry Haddow, and Alexandra Birch. Neural machine translation of rare words with subword units. In Proc. of ACL, 2016.
[73] Eva Sharma, Chen Li, and Lu Wang. BIGPATENT: A large-scale dataset for abstractive and coherent summarization. In Proc. of ACL, 2019.
[74] Noam Shazeer and Mitchell Stern. Adafactor: Adaptive learning rates with sublinear memory cost. In Proc. of ICML, 2018.
[75] Libin Shen, Anoop Sarkar, and Franz Josef Och. Discriminative reranking for machine translation. In Proc. of NAACL, 2004.
[76] Weizhou Shen, Yeyun Gong, Yelong Shen, Song Wang, Xiaojun Quan, Nan Duan, and Weizhu Chen. Joint generator-ranker learning for natural language generation. CoRR, 2022.
[77] Weijia Shi, Sewon Min, Michihiro Yasunaga, Minjoon Seo, Rich James, Mike Lewis, Luke Zettlemoyer, and Wen tau Yih. Replug: Retrieval-augmented black-box language models, 2023.
[78] Weijia Shi, Sewon Min, Michihiro Yasunaga, Minjoon Seo, Rich James, Mike Lewis, Luke Zettlemoyer, and Wen-tau Yih. REPLUG: retrieval-augmented black-box language models. CoRR, 2023.
[79] Suzanna Sia and Kevin Duh. In-context learning as maintaining coherency: A study of on-the-fly machine translation using large language models. CoRR, 2023.</p>
<p>[80] Michel Simard and Pierre Isabelle. Phrase-based machine translation in a computer-assisted translation environment. In Proceedings of Machine Translation Summit XII: Papers, MTSummit 2009, Ottawa, Canada, August 26-30, 2009, 2009.
[81] Yiping Song, Rui Yan, Xiang Li, Dongyan Zhao, and Ming Zhang. Two are better than one: An ensemble of retrieval- and generation-based dialog systems. CoRR, 2016.
[82] Ralf Steinberger, Bruno Pouliquen, Anna Widiger, Camelia Ignat, Tomaz Erjavec, Dan Tufis, and Dániel Varga. The jrc-acquis: A multilingual aligned parallel corpus with 20+ languages. In Proc. of LREC, 2006.
[83] Yixuan Su, David Vandyke, Simon Baker, Yan Wang, and Nigel Collier. Keep the primary, rewrite the secondary: A two-stage approach for paraphrase generation. In Proc. of ACL Findings, 2021.
[84] Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser, and Illia Polosukhin. Attention is all you need. In Proc. of NeurIPS, 2017.
[85] David Vilar, Markus Freitag, Colin Cherry, Jiaming Luo, Viresh Ratnakar, and George Foster. Prompting palm for translation: Assessing strategies and performance, 2023.
[86] Oriol Vinyals and Quoc V. Le. A neural conversational model. CoRR, 2015.
[87] Shuohang Wang, Yichong Xu, Yuwei Fang, Yang Liu, Siqi Sun, Ruochen Xu, Chenguang Zhu, and Michael Zeng. Training data is more valuable than you think: A simple and effective method by retrieving from training data. In Proc. of ACL, 2022.
[88] Yuguang Wang, Shanbo Cheng, Liyang Jiang, Jiajun Yang, Wei Chen, Muze Li, Lin Shi, Yanfeng Wang, and Hongtao Yang. Sogou neural machine translation systems for WMT17. In Proceedings of the Second Conference on Machine Translation, WMT 2017, Copenhagen, Denmark, September 7-8, 2017, 2017.
[89] Jason Weston, Emily Dinan, and Alexander H. Miller. Retrieve and refine: Improved sequence generation models for dialogue. In Proceedings of the 2nd International Workshop on SearchOriented Conversational AI, SCAI@EMNLP 2018, Brussels, Belgium, October 31, 2018, 2018.
[90] Wenhao Wu, Wei Li, Xinyan Xiao, Jiachen Liu, Ziqiang Cao, Sujian Li, Hua Wu, and Haifeng Wang. BASS: boosting abstractive summarization with unified semantic graph. In Proc. of $A C L, 2021$.
[91] Yu Wu, Furu Wei, Shaohan Huang, Yunli Wang, Zhoujun Li, and Ming Zhou. Response generation by context-aware prototype editing. In Proc. of AAAI, 2019.
[92] Mengzhou Xia, Guoping Huang, Lemao Liu, and Shuming Shi. Graph based translation memory for neural machine translation. In Proc. of AAAI, 2019.
[93] Jitao Xu, Josep Maria Crego, and Jean Senellart. Boosting neural machine translation with similar translations. In Proc. of ACL, 2020.
[94] Masaru Yamada. The effect of translation memory databases on productivity. Translation research projects, 2011.
[95] Michihiro Yasunaga, Armen Aghajanyan, Weijia Shi, Rich James, Jure Leskovec, Percy Liang, Mike Lewis, Luke Zettlemoyer, and Wen-tau Yih. Retrieval-augmented multimodal language modeling. CoRR, 2022.
[96] Dani Yogatama, Cyprien de Masson d'Autume, and Lingpeng Kong. Adaptive semiparametric language models. Trans. Assoc. Comput. Linguistics, 2021.
[97] Wenhao Yu, Dan Iter, Shuohang Wang, Yichong Xu, Mingxuan Ju, Soumya Sanyal, Chenguang Zhu, Michael Zeng, and Meng Jiang. Generate rather than retrieve: Large language models are strong context generators, 2023.</p>
<p>[98] Manzil Zaheer, Guru Guruganesh, Kumar Avinava Dubey, Joshua Ainslie, Chris Alberti, Santiago Ontanon, Philip Pham, Anirudh Ravula, Qifan Wang, Li Yang, and Amr Ahmed. Big bird: Transformers for longer sequences. In Proc. of NeurIPS, 2020.
[99] Yury Zemlyanskiy, Michiel de Jong, Joshua Ainslie, Panupong Pasupat, Peter Shaw, Linlu Qiu, Sumit Sanghai, and Fei Sha. Generate-and-retrieve: Use your predictions to improve retrieval for semantic parsing. In Proceedings of the 29th International Conference on Computational Linguistics, pages 4946-4951, Gyeongju, Republic of Korea, October 2022. International Committee on Computational Linguistics.
[100] Jingqing Zhang, Yao Zhao, Mohammad Saleh, and Peter J. Liu. PEGASUS: pre-training with extracted gap-sentences for abstractive summarization. In Proc. of ICML, 2020.
[101] Jingyi Zhang, Masao Utiyama, Eiichiro Sumita, Graham Neubig, and Satoshi Nakamura. Guiding neural machine translation with retrieved translation pieces. In Proc. of NAACL, 2018.
[102] Tong Zhang, Wei Ye, Baosong Yang, Long Zhang, Xingzhang Ren, Dayiheng Liu, Jinan Sun, Shikun Zhang, Haibo Zhang, and Wen Zhao. Frequency-aware contrastive learning for neural machine translation. In Proc. of AAAI, 2022.
[103] Xueliang Zhao, Lemao Liu, Tingchen Fu, Shuming Shi, Dongyan Zhao, and Rui Yan. Towards efficient dialogue pre-training with transferable and interpretable latent structure. CoRR, 2022.
[104] Yinhe Zheng, Zikai Chen, Rongsheng Zhang, Shilei Huang, Xiaoxi Mao, and Minlie Huang. Stylized dialogue response generation using stylized unpaired texts. In Proc. of AAAI, 2021.
[105] Zexuan Zhong, Tao Lei, and Danqi Chen. Training language models with memory augmentation. CoRR, 2022.</p>
<h1>A Dataset Details</h1>
<p>Table 7: Dataset statistics for three tasks.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Task</th>
<th style="text-align: center;">Dataset</th>
<th style="text-align: center;">#Train</th>
<th style="text-align: center;">#Dev</th>
<th style="text-align: center;">#Test</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Translation</td>
<td style="text-align: center;">JRC (en $\leftrightarrow$ de)</td>
<td style="text-align: center;">663,487</td>
<td style="text-align: center;">2,454</td>
<td style="text-align: center;">2,483</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">JRC (en $\leftrightarrow$ es)</td>
<td style="text-align: center;">653,127</td>
<td style="text-align: center;">2,533</td>
<td style="text-align: center;">2,596</td>
</tr>
<tr>
<td style="text-align: center;">Summarization</td>
<td style="text-align: center;">BigPatent</td>
<td style="text-align: center;">$1,207,222$</td>
<td style="text-align: center;">67,068</td>
<td style="text-align: center;">67,072</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">XSum</td>
<td style="text-align: center;">204,045</td>
<td style="text-align: center;">11,332</td>
<td style="text-align: center;">11,334</td>
</tr>
<tr>
<td style="text-align: center;">Dialogue</td>
<td style="text-align: center;">DailyDialog</td>
<td style="text-align: center;">87,170</td>
<td style="text-align: center;">8,069</td>
<td style="text-align: center;">7,740</td>
</tr>
</tbody>
</table>
<h2>B Self Memory Details</h2>
<p>For machine translation tasks, following [93, 8, 17] we use randomly initialize Transformer base architecture [84] as $G_{\xi}$. We use the joint-bpe algorithm [72] and share the parameters between the memory encoder and source encoder for dual encoder architecture. The hyper-parameter setting follows [17] with dropout 0.1 , label smoothing 0.1 , gradient clipping 1.0, Adafactor [74], warm-up steps 4000, maximum learning rate $4.4 \mathrm{e}-2$ and training epochs 30 for total. The evaluation metrics are BLEU, TER and chrF++ from SACREBLEU [66]. The backbone of memory selector $S_{\theta}$ is XLM-R ${ }<em _theta="\theta">{\text {base }}$ [22] with BLEU as $\Delta(\cdot, \cdot)$. The hyper-parameter setting for $S</em>-5$ and polynomial decay scheduler, and classifier dropout 0.2 .
For Summarization, we init the $G_{\xi}$ with BART ${ }}$ follows [39] with $\tau 0.5$, minmax normalization for candidates ranking, Adam optimizer with max learning rate $5 \mathrm{e<em _base="{base" _text="\text">{\text {base }}$ [40] for BigPatent following [87] and state-of-theart BRIO [55] for XSum. Optimization is based on Adafactor with a maximum learning rate of $5 \mathrm{e}-3$, warm-up steps 10000 and gradient clipping value 1.0. The maximum input length is 512 for XSum and 1024 for BigPatent. The evaluation metric is Rouge (R-1/2/L) [47].
For Dialogue Generation, we use BART ${ }</em>}}$ as the backbone for $G_{\xi}$ on DailyDialog. We tune the hyper-parameters from learning rate ${5 \mathrm{e}-3,1 \mathrm{e}-3,4 \mathrm{e}-4}$ and set dropout 0.1 , batch size 64 , label smoothing factor 0.1 , maximum input length 120 for DailyDialog. Following [4, 13], we evaluate our dialogue system with BLEU (B-1/2) and Distinct (D-1,2) [43]. For both Summarization and Dialogue Generation task, we follow [54, 26] and adopt RoBERTa ${ <em _theta="\theta">{\text {base }}$ [52] as the backbone for $S</em>$ is 512 and we truncate tokens from the longer input of source and candidate.}$. We choose the linear combination of B-1/2 as $\Delta(\cdot, \cdot)$ for Dialogue Generation and R-1/2/L for Summarization following [76]. We tune the hyper-parameters $\tau$ from ${0.08,0.2,0.5,0.8}$, learning rate from ${5 \mathrm{e}-5,7 \mathrm{e}-5,2 \mathrm{e}-4}$. The maximum input length for $S_{\theta</p>
<h2>C Evaluation Details</h2>
<p>Machine Translation We evaluate our MT system with BLEU, TER and chrF++ from SACREBLEU $^{3}$ [66]. The signatures for BLEU, TER and chrF++ are shown in Table 8.</p>
<p>Table 8: Signature from SACREBLEU.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Signature</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">nrefs:1lcase:mixedleff:noltok:13alsmooth:explversion:2.0.0</td>
</tr>
<tr>
<td style="text-align: left;">nrefs:1lcase:lcltok:tercomlnorm:nolpunct:yeslasian:nolversion:2.0.0</td>
</tr>
<tr>
<td style="text-align: left;">nrefs:1lcase:mixedleff:yeslnc:6lnw:2lspace:nolversion:2.0.0</td>
</tr>
</tbody>
</table>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>Summarization We evaluate our Summarization system with standard ROUGE [47] Perl package ${ }^{4}$ for evaluation. Following [55], we use PTB tokenizer ${ }^{5}$ for tokenization. And the parameters for ROUGE are "-c 95 -r 1000 -n 2 -m".</p>
<p>Dialogue Generation Following [27], we evaluate our dialogue system with NLTK BLEU ${ }^{6}$ with space as tokenizer and smoothing method1. The Distinction score is from [42].</p>
<h1>D More results on translation tasks</h1>
<p>Table 9: Evaluation results on JRC-Acquis En $\rightarrow$ De measured by BLEU, TER and chrF++.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">System</th>
<th style="text-align: center;">Memory</th>
<th style="text-align: center;">BLEU $\uparrow$</th>
<th style="text-align: center;">chrF++ $\uparrow$</th>
<th style="text-align: center;">TER $\downarrow$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Transformer</td>
<td style="text-align: center;">None</td>
<td style="text-align: center;">55.43</td>
<td style="text-align: center;">70.31</td>
<td style="text-align: center;">36.35</td>
</tr>
<tr>
<td style="text-align: left;">Transformer $_{\text {dual }}$</td>
<td style="text-align: center;">Retrieval</td>
<td style="text-align: center;">58.06</td>
<td style="text-align: center;">71.58</td>
<td style="text-align: center;">35.41</td>
</tr>
<tr>
<td style="text-align: left;">Transformer $_{\text {joint }}$</td>
<td style="text-align: center;">Retrieval</td>
<td style="text-align: center;">58.58</td>
<td style="text-align: center;">72.22</td>
<td style="text-align: center;">34.39</td>
</tr>
<tr>
<td style="text-align: left;">Transformer $_{\text {dual }}$</td>
<td style="text-align: center;">Self</td>
<td style="text-align: center;">$\underline{59.49}$</td>
<td style="text-align: center;">$\underline{72.62}$</td>
<td style="text-align: center;">$\underline{34.04}$</td>
</tr>
<tr>
<td style="text-align: left;">Transformer $_{\text {joint }}$</td>
<td style="text-align: center;">Self</td>
<td style="text-align: center;">$\mathbf{6 0 . 1 1}$</td>
<td style="text-align: center;">$\mathbf{7 3 . 2 5}$</td>
<td style="text-align: center;">$\mathbf{3 2 . 6 2}$</td>
</tr>
</tbody>
</table>
<h2>E More Summarization Baselines</h2>
<p>In this Table 10, we include more baselines on the benchmark dataset XSum and BigPatent. We also report the confidence region of SOTA model for XSum and BigPatent as shown in Table 11.</p>
<p>Table 10: More baselines on XSum and BigPatent.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">System</th>
<th style="text-align: center;">R-1</th>
<th style="text-align: center;">R-2</th>
<th style="text-align: center;">R-L</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">XSum</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">[51]</td>
<td style="text-align: center;">38.8</td>
<td style="text-align: center;">16.5</td>
<td style="text-align: center;">31.3</td>
</tr>
<tr>
<td style="text-align: center;">[40]</td>
<td style="text-align: center;">45.1</td>
<td style="text-align: center;">22.3</td>
<td style="text-align: center;">37.3</td>
</tr>
<tr>
<td style="text-align: center;">[100]</td>
<td style="text-align: center;">47.2</td>
<td style="text-align: center;">24.6</td>
<td style="text-align: center;">39.3</td>
</tr>
<tr>
<td style="text-align: center;">[54]</td>
<td style="text-align: center;">47.6</td>
<td style="text-align: center;">24.6</td>
<td style="text-align: center;">39.4</td>
</tr>
<tr>
<td style="text-align: center;">[55]</td>
<td style="text-align: center;">49.1</td>
<td style="text-align: center;">25.6</td>
<td style="text-align: center;">40.4</td>
</tr>
<tr>
<td style="text-align: center;"><a href="PG">87</a></td>
<td style="text-align: center;">48.2</td>
<td style="text-align: center;">26.0</td>
<td style="text-align: center;">40.2</td>
</tr>
<tr>
<td style="text-align: center;"><a href="B">87</a></td>
<td style="text-align: center;">43.1</td>
<td style="text-align: center;">21.0</td>
<td style="text-align: center;">35.5</td>
</tr>
<tr>
<td style="text-align: center;"><a href="L">87</a></td>
<td style="text-align: center;">46.5</td>
<td style="text-align: center;">24.1</td>
<td style="text-align: center;">38.6</td>
</tr>
<tr>
<td style="text-align: center;">[68]</td>
<td style="text-align: center;">48.1</td>
<td style="text-align: center;">25.0</td>
<td style="text-align: center;">40.0</td>
</tr>
<tr>
<td style="text-align: center;">[69]</td>
<td style="text-align: center;">47.1</td>
<td style="text-align: center;">24.1</td>
<td style="text-align: center;">38.8</td>
</tr>
<tr>
<td style="text-align: center;">[16]</td>
<td style="text-align: center;">47.8</td>
<td style="text-align: center;">25.0</td>
<td style="text-align: center;">39.7</td>
</tr>
<tr>
<td style="text-align: center;">Selfmem</td>
<td style="text-align: center;">50.3</td>
<td style="text-align: center;">26.7</td>
<td style="text-align: center;">41.6</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;">System</th>
<th style="text-align: center;">R-1</th>
<th style="text-align: center;">R-2</th>
<th style="text-align: center;">R-L</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">BigPatent</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">[100]</td>
<td style="text-align: center;">53.6</td>
<td style="text-align: center;">33.1</td>
<td style="text-align: center;">42.3</td>
</tr>
<tr>
<td style="text-align: center;">[40]</td>
<td style="text-align: center;">44.4</td>
<td style="text-align: center;">21.3</td>
<td style="text-align: center;">31.0</td>
</tr>
<tr>
<td style="text-align: center;">[98]</td>
<td style="text-align: center;">60.6</td>
<td style="text-align: center;">42.5</td>
<td style="text-align: center;">50.0</td>
</tr>
<tr>
<td style="text-align: center;">[65]</td>
<td style="text-align: center;">38.7</td>
<td style="text-align: center;">12.3</td>
<td style="text-align: center;">34.1</td>
</tr>
<tr>
<td style="text-align: center;">[90]</td>
<td style="text-align: center;">45.0</td>
<td style="text-align: center;">20.3</td>
<td style="text-align: center;">39.2</td>
</tr>
<tr>
<td style="text-align: center;">[1]</td>
<td style="text-align: center;">52.3</td>
<td style="text-align: center;">33.5</td>
<td style="text-align: center;">42.8</td>
</tr>
<tr>
<td style="text-align: center;">[87] (B)</td>
<td style="text-align: center;">59.5</td>
<td style="text-align: center;">42.6</td>
<td style="text-align: center;">50.6</td>
</tr>
<tr>
<td style="text-align: center;">[87] (L)</td>
<td style="text-align: center;">60.7</td>
<td style="text-align: center;">43.3</td>
<td style="text-align: center;">51.3</td>
</tr>
<tr>
<td style="text-align: center;">[87] (PG)</td>
<td style="text-align: center;">44.6</td>
<td style="text-align: center;">21.5</td>
<td style="text-align: center;">33.3</td>
</tr>
<tr>
<td style="text-align: center;">Selfmem</td>
<td style="text-align: center;">62.9</td>
<td style="text-align: center;">48.1</td>
<td style="text-align: center;">59.6</td>
</tr>
</tbody>
</table>
<h2>F Empirical analysis of latency</h2>
<p>In Table 12, we present empirical results of Selfmem latency, measured in seconds. We compare Selfmem with a retrieval-augmented baseline model across various datasets and computational platforms, including CPU and CUDA. The number of iterations for Selfmem is set to one. All experiments are conducted on the same device, equipped with one NVIDIA A100 GPU and one AMD EPYC 7V13 64-Core Processor.</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>Table 11: Confidence region for SOTA model in XSum and BigPatent.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">System</th>
<th style="text-align: center;">ROUGE-1/2/L</th>
<th style="text-align: center;">95\%-conf.int</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">XSum</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">BRIO $_{\text {joint }}$</td>
<td style="text-align: center;">50.3</td>
<td style="text-align: center;">0.49986 - 0.50602</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">26.7</td>
<td style="text-align: center;">0.26300 - 0.26989</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">41.6</td>
<td style="text-align: center;">0.41231 - 0.41900</td>
</tr>
<tr>
<td style="text-align: center;">BigPatent</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">BART $_{\text {joint }}$</td>
<td style="text-align: center;">62.9</td>
<td style="text-align: center;">0.62664 - 0.63080</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">48.1</td>
<td style="text-align: center;">0.47783 - 0.48333</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">59.6</td>
<td style="text-align: center;">0.59401 - 0.59847</td>
</tr>
</tbody>
</table>
<p>Table 12: Generation Latency analysis.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">NMT</th>
<th style="text-align: center;">XSum</th>
<th style="text-align: center;">BigPatent</th>
<th style="text-align: center;">DailyDialog</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Average Input Length</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">87</td>
<td style="text-align: center;">512</td>
<td style="text-align: center;">1024</td>
<td style="text-align: center;">71</td>
</tr>
<tr>
<td style="text-align: center;">Average Output Length</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">44</td>
<td style="text-align: center;">75</td>
<td style="text-align: center;">127</td>
<td style="text-align: center;">16</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">CPU</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Retrieval-augmented Baseline</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">0.97</td>
<td style="text-align: center;">1.79</td>
<td style="text-align: center;">3.16</td>
<td style="text-align: center;">0.32</td>
</tr>
<tr>
<td style="text-align: center;">Selfmem</td>
<td style="text-align: center;">Candidate Generation</td>
<td style="text-align: center;">3.20</td>
<td style="text-align: center;">7.50</td>
<td style="text-align: center;">15.00</td>
<td style="text-align: center;">1.02</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Memory Selection</td>
<td style="text-align: center;">0.50</td>
<td style="text-align: center;">0.52</td>
<td style="text-align: center;">0.95</td>
<td style="text-align: center;">0.14</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Hypothesis Generation</td>
<td style="text-align: center;">0.97</td>
<td style="text-align: center;">1.79</td>
<td style="text-align: center;">3.00</td>
<td style="text-align: center;">0.32</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">$\times 4.80$</td>
<td style="text-align: center;">$\times 5.47$</td>
<td style="text-align: center;">$\times 6.04$</td>
<td style="text-align: center;">$\times 4.63$</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">CUDA</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Retrieval-augmented Baseline</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">0.29</td>
<td style="text-align: center;">0.44</td>
<td style="text-align: center;">0.75</td>
<td style="text-align: center;">0.10</td>
</tr>
<tr>
<td style="text-align: center;">Selfmem</td>
<td style="text-align: center;">Candidate Generation</td>
<td style="text-align: center;">0.51</td>
<td style="text-align: center;">1.00</td>
<td style="text-align: center;">1.72</td>
<td style="text-align: center;">0.18</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Memory Selection</td>
<td style="text-align: center;">0.01</td>
<td style="text-align: center;">0.01</td>
<td style="text-align: center;">0.01</td>
<td style="text-align: center;">0.01</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Hypothesis Generation</td>
<td style="text-align: center;">0.29</td>
<td style="text-align: center;">0.44</td>
<td style="text-align: center;">0.75</td>
<td style="text-align: center;">0.10</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">$\times 2.76$</td>
<td style="text-align: center;">$\times 2.99$</td>
<td style="text-align: center;">$\times 3.35$</td>
<td style="text-align: center;">$\times 2.91$</td>
</tr>
</tbody>
</table>
<h1>G Human and GPT-4 Evaluation</h1>
<p>We employ both human annotators and GPT-4 (gpt-4-0314) annotators to perform pairwise ranking of the output generated by Selfmem and baseline systems. For GPT-4 annotators, we utilize the prompt from Alpaca Eval ${ }^{1}$. We randomly select 50 samples for translation tasks and 20 samples for summarization and dialogue tasks. The win rate of Selfmem versus retrieval-augmented baselines is depicted in Figure 1.
<img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 5: Human and GPT-4 evaluation results.</p>
<p><sup id="fnref5:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{1}$ https://github.com/tatsu-lab/alpaca_eval/blob/main/src/alpaca_eval/evaluators_ configs/alpaca_eval_gpt4/alpaca_eval.txt&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref5:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>