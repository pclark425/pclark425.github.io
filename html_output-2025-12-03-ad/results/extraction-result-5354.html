<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-5354 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-5354</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-5354</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-111.html">extraction-schema-111</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for converting graphs into text for language model training, including details of the representation, properties, evaluation tasks, performance, and comparisons to other methods.</div>
                <p><strong>Paper ID:</strong> paper-afc1824a051f686e18ad87e1244bb0926a361021</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/afc1824a051f686e18ad87e1244bb0926a361021" target="_blank">Modeling Graph Structure in Transformer for Better AMR-to-Text Generation</a></p>
                <p><strong>Paper Venue:</strong> Conference on Empirical Methods in Natural Language Processing</p>
                <p><strong>Paper TL;DR:</strong> This paper proposes a novel structure-aware self-attention approach to better model the relations between indirectly connected concepts in the state-of-the-art seq2seq model, i.e. the Transformer.</p>
                <p><strong>Paper Abstract:</strong> Recent studies on AMR-to-text generation often formalize the task as a sequence-to-sequence (seq2seq) learning problem by converting an Abstract Meaning Representation (AMR) graph into a word sequences. Graph structures are further modeled into the seq2seq framework in order to utilize the structural information in the AMR graphs. However, previous approaches only consider the relations between directly connected concepts while ignoring the rich structure in AMR graphs. In this paper we eliminate such a strong limitation and propose a novel structure-aware self-attention approach to better model the relations between indirectly connected concepts in the state-of-the-art seq2seq model, i.e. the Transformer. In particular, a few different methods are explored to learn structural representations between two concepts. Experimental results on English AMR benchmark datasets show that our approach significantly outperforms the state-of-the-art with 29.66 and 31.82 BLEU scores on LDC2015E86 and LDC2017T10, respectively. To the best of our knowledge, these are the best results achieved so far by supervised models on the benchmarks.</p>
                <p><strong>Cost:</strong> 0.013</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e5354.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e5354.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for converting graphs into text for language model training, including details of the representation, properties, evaluation tasks, performance, and comparisons to other methods.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>DFS-linearization</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Depth-first traversal linearization (AMR linearization)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A method that converts an AMR graph into a token sequence by depth-first traversal after removing variables, wiki links, and sense tags; used as the standard seq2seq input representation in AMR-to-text work.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Neural AMR: Sequence-to-sequence models for parsing and generation</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>linearization (depth-first traversal)</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Traverse the AMR graph in depth-first order to produce a flat sequence of concept tokens and edge labels; variables, wiki links and sense tags are removed before traversal; reentrancies become duplicated tokens in the sequence (no explicit reentrancy marker).</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>AMR (Abstract Meaning Representation) graph</td>
                        </tr>
                        <tr>
                            <td><strong>representation_properties</strong></td>
                            <td>Compact sequence form compatible with seq2seq models; easy to feed into standard sequence encoders; loses explicit reentrancy information and some structural relations; susceptible to data sparsity because reentrant nodes may be duplicated as separate tokens.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_task</strong></td>
                            <td>AMR-to-text generation on LDC2015E86 and LDC2017T10</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Used in baseline seq2seq models; baseline reported BLEU 25.50 (LDC2015E86) and 27.43 (LDC2017T10); other metrics reported for baseline: Meteor 33.16/34.62 and CHRF++ 59.88/61.85 (table 3).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_representations</strong></td>
                            <td>Compared to graph-aware encoders in this paper, linearization baseline is weaker (structure-aware models improve BLEU by up to +4.16 and +4.39 on the two benchmarks). Prior seq2seq work (Konstas et al., 2017) used this linearization successfully but suffers from loss of reentrancy and indirect-connection structure.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Loses explicit graph structure (especially reentrancies and long-distance relations); ambiguous duplicated tokens (same concept appears multiple times); hurts generation for graphs with many reentrancies or large graphs; no explicit mechanism to represent multi-parent nodes.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Modeling Graph Structure in Transformer for Better AMR-to-Text Generation', 'publication_date_yy_mm': '2019-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e5354.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e5354.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for converting graphs into text for language model training, including details of the representation, properties, evaluation tasks, performance, and comparisons to other methods.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>BPE-subword-graph</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Sub-word extension of AMR graphs with Byte Pair Encoding (BPE)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Apply BPE to split words into sub-word units and extend the AMR graph topology to include nodes/edges for sub-word units so that graph structure aligns with BPE-tokenized sequence inputs.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Neural machine translation of rare words with subword units</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>sub-word graph extension with BPE</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Segment surface tokens with BPE and, when a graph node's corresponding token is split into sub-word pieces, create multiple connected graph nodes (one per sub-word) with an edge linking them; the incoming edge label of the original node is attached to the first sub-word node.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>AMR graphs adapted to sub-word tokenization</td>
                        </tr>
                        <tr>
                            <td><strong>representation_properties</strong></td>
                            <td>Improves handling of rare words and reduces data sparsity by operating at sub-word level; preserves graph connectivity by splitting nodes into connected sub-word nodes; increases alignment compatibility between graph nodes and sub-word vocabularies.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_task</strong></td>
                            <td>AMR-to-text generation (same benchmarks LDC2015E86 and LDC2017T10); used as preprocessing for model training</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>The paper reports that applying BPE and sharing vocabulary are critical to a strong baseline (ablation: BPE + shared vocab improves BLEU from 18.77 to 24.93 in development ablation), and BPE was applied (10K ops on LDC2015E86, 20K on LDC2017T10).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_representations</strong></td>
                            <td>Compared in ablation to baseline without BPE (and without vocabulary sharing); BPE+shared vocab substantially improved baseline performance. Other prior approaches used anonymization or copy mechanisms; authors prefer BPE+shared vocab.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Requires graph topology modification and special handling of labels for sub-word nodes; may slightly increase graph size and complexity; decisions about which edge/label to attach to which sub-word are heuristic (attach incoming edge to first sub-word).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Modeling Graph Structure in Transformer for Better AMR-to-Text Generation', 'publication_date_yy_mm': '2019-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e5354.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e5354.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for converting graphs into text for language model training, including details of the representation, properties, evaluation tasks, performance, and comparisons to other methods.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Transformer-baseline</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Transformer seq2seq baseline for AMR-to-text</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A standard Transformer encoder-decoder seq2seq model (multi-layer self-attention) applied to linearized AMR sequences (with BPE and shared vocabulary) serving as a strong baseline.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Attention is all you need</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>seq2seq Transformer on linearized AMR</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Encode the depth-first linearized AMR sequence with a multi-layer Transformer encoder and decode natural language with a Transformer decoder; uses shared source-target vocabulary and BPE sub-word units.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>AMR (linearized into sequence)</td>
                        </tr>
                        <tr>
                            <td><strong>representation_properties</strong></td>
                            <td>Encodes global/implicit structural information via multi-head attention without explicit graph structure; compact and high-capacity; sensitive to data sparsity without BPE/shared vocab; does not explicitly encode reentrancies or multi-hop structural labels.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_task</strong></td>
                            <td>AMR-to-text generation on LDC2015E86 and LDC2017T10</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Reported as a strong baseline: BLEU 25.50 (LDC2015E86) and 27.43 (LDC2017T10); Meteor 33.16/34.62; CHRF++ 59.88/61.85; model size ~49.1M parameters (table 3).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_representations</strong></td>
                            <td>Outperforms most prior graph-to-sequence models and is comparable with Guo et al. (2019); but structure-aware extensions presented in this paper further improve performance by up to ~4 BLEU points.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Implicitly models structure but cannot explicitly represent indirect relations and reentrancies; tends to underperform when AMR graphs are large or contain many reentrancies; relies on large supervised data or unlabeled data to match graph-aware methods.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Modeling Graph Structure in Transformer for Better AMR-to-Text Generation', 'publication_date_yy_mm': '2019-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e5354.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e5354.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for converting graphs into text for language model training, including details of the representation, properties, evaluation tasks, performance, and comparisons to other methods.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Struct-attn (r_ij)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Structure-aware self-attention (relation-aware self-attention with learned path vectors)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An extension of Transformer self-attention that augments attention computation with learned vector representations r_ij encoding the structured path (edge-label sequence with direction) between each concept pair so arbitrary (including indirect) graph relations are used.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>structure-aware self-attention (path-label augmented attention)</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Replace standard dot-product attention score e_ij with e_ij = ((x_i W^Q)((x_j W^K + r_ij W^R)^T))/sqrt(d_z) and similarly add r_ij W^F into value projections so the attention both scores and aggregates information conditioned on a learned vector r_ij that encodes the sequence of edge labels (with direction arrows) along the shortest path between concepts i and j.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>AMR (explicit pairwise concept-pair structure derived from graph paths)</td>
                        </tr>
                        <tr>
                            <td><strong>representation_properties</strong></td>
                            <td>Explicitly encodes arbitrary (multi-hop) relations between concept pairs, including reentrancies; r_ij provides continuous, trainable structural signals; scales with O(n^2) pair representations but paper reports only small parameter-size increase (~0.1-0.3M). Can integrate sub-word-extended graphs.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_task</strong></td>
                            <td>AMR-to-text generation on LDC2015E86 and LDC2017T10; ablations testing effect of including/excluding indirect concept-pair information and graph size/reentrancy counts.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Using structure-aware attention with the best path representation yields strong results: SA-based path encoding gives BLEU 29.66 (LDC2015E86) and 31.54 (LDC2017T10); CNN-based path encoding yields BLEU 29.10/31.82 respectively; compared to baseline BLEU improvements up to +4.16 (2015) and +4.39 (2017). Table 3 reports full metrics (BLEU/Meteor/CHRF++).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_representations</strong></td>
                            <td>Outperforms the vanilla Transformer baseline and previous graph-to-sequence approaches that only model one-hop relations; modeling indirect concept pairs improves BLEU (e.g., on LDC2017T10: full model 31.82 vs mapping indirect pairs to None 29.92). Continuous path encodings (SA, CNN) outperform discrete feature-based encoding.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Requires learning/lookup of r_ij for every pair (practical limits: paper truncates label sequence length to 4 for efficiency); if multiple shortest paths exist, method uses one (no multi-path aggregation); AMR lacks tense/number making generation errors unrelated to structure; small added parameter cost but quadratic pairwise computation can increase compute.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Modeling Graph Structure in Transformer for Better AMR-to-Text Generation', 'publication_date_yy_mm': '2019-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e5354.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e5354.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for converting graphs into text for language model training, including details of the representation, properties, evaluation tasks, performance, and comparisons to other methods.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Path-label encodings</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Path-label sequence representation methods (feature-based, avg-based, sum-based, SA-based, CNN-based)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Five alternative methods to convert the sequence of edge labels (with direction markers) along the shortest path between two AMR concepts into a fixed-size vector r used by structure-aware attention.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>path-label sequence representations (feature / avg / sum / SA / CNN)</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Given a label sequence s = s1...sk representing the edge-label path (labels augmented with ↑/↓ for direction), methods are: (1) feature-based: treat the joined label-sequence as a discrete string feature (top 20K kept, others UNK) mapped to embeddings; (2) avg-based: elementwise average of label embeddings; (3) sum-based: sum of label embeddings; (4) SA-based: apply a self-attention encoder over label embeddings and weighted-pool hidden states to produce r; (5) CNN-based: apply 1D conv (kernel size 4) + ReLU to label embedding sequence to produce r.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>AMR (edge-label path sequences between concept pairs)</td>
                        </tr>
                        <tr>
                            <td><strong>representation_properties</strong></td>
                            <td>Feature-based is discrete and sparse (large feature vocab, data sparsity); avg/sum are simple, cheap continuous aggregations but lose order sensitivity (avg loses length info); SA-based encodes order and interactions and uses positional information; CNN-based captures local n-gram label patterns and order sensitivity; paper limits path length to 4 for efficiency (longer labels ignored).</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_task</strong></td>
                            <td>Used inside structure-aware self-attention for AMR-to-text generation; evaluated on LDC2015E86 and LDC2017T10 (same tasks/benchmarks).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Reported results (Table 3): On LDC2015E86 BLEU: feature 27.23, avg 28.37, sum 28.69, SA 29.66, CNN 29.10. On LDC2017T10 BLEU: feature 30.18, avg 29.56, sum 29.92, SA 31.54, CNN 31.82. Meteor and CHRF++ also reported per-method in Table 3. Model-size (#P) minimally affected (49.1-49.4M).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_representations</strong></td>
                            <td>Continuous learned encodings (SA-based and CNN-based) outperform discrete feature-based and simple avg/sum aggregations; SA and CNN are top-performing variants (SA best on 2015, CNN best on 2017 test set in this paper). All five variants outperform the Transformer baseline substantially.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Feature-based: data sparsity and large vocab; avg/sum: lose order and finer interactions; SA/CNN: higher compute and parameters; authors cap path length to 4, truncating longer paths and potentially losing long-range path information; when multiple paths exist between nodes, only the shortest path is used.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Modeling Graph Structure in Transformer for Better AMR-to-Text Generation', 'publication_date_yy_mm': '2019-08'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Neural AMR: Sequence-to-sequence models for parsing and generation <em>(Rating: 2)</em></li>
                <li>A graph-to-sequence model for AMR-to-text generation <em>(Rating: 2)</em></li>
                <li>Graph-to-sequence learning using gated graph neural networks <em>(Rating: 2)</em></li>
                <li>Structural neural encoders for AMR-to-text generation <em>(Rating: 2)</em></li>
                <li>Densely connected graph convolutional networks for graph-to-sequence learning <em>(Rating: 2)</em></li>
                <li>Self-attention with relative position representations <em>(Rating: 2)</em></li>
                <li>Text generation from knowledge graphs with graph transformers <em>(Rating: 2)</em></li>
                <li>Neural machine translation of rare words with subword units <em>(Rating: 1)</em></li>
                <li>Attention is all you need <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-5354",
    "paper_id": "paper-afc1824a051f686e18ad87e1244bb0926a361021",
    "extraction_schema_id": "extraction-schema-111",
    "extracted_data": [
        {
            "name_short": "DFS-linearization",
            "name_full": "Depth-first traversal linearization (AMR linearization)",
            "brief_description": "A method that converts an AMR graph into a token sequence by depth-first traversal after removing variables, wiki links, and sense tags; used as the standard seq2seq input representation in AMR-to-text work.",
            "citation_title": "Neural AMR: Sequence-to-sequence models for parsing and generation",
            "mention_or_use": "use",
            "representation_name": "linearization (depth-first traversal)",
            "representation_description": "Traverse the AMR graph in depth-first order to produce a flat sequence of concept tokens and edge labels; variables, wiki links and sense tags are removed before traversal; reentrancies become duplicated tokens in the sequence (no explicit reentrancy marker).",
            "graph_type": "AMR (Abstract Meaning Representation) graph",
            "representation_properties": "Compact sequence form compatible with seq2seq models; easy to feed into standard sequence encoders; loses explicit reentrancy information and some structural relations; susceptible to data sparsity because reentrant nodes may be duplicated as separate tokens.",
            "evaluation_task": "AMR-to-text generation on LDC2015E86 and LDC2017T10",
            "performance_metrics": "Used in baseline seq2seq models; baseline reported BLEU 25.50 (LDC2015E86) and 27.43 (LDC2017T10); other metrics reported for baseline: Meteor 33.16/34.62 and CHRF++ 59.88/61.85 (table 3).",
            "comparison_to_other_representations": "Compared to graph-aware encoders in this paper, linearization baseline is weaker (structure-aware models improve BLEU by up to +4.16 and +4.39 on the two benchmarks). Prior seq2seq work (Konstas et al., 2017) used this linearization successfully but suffers from loss of reentrancy and indirect-connection structure.",
            "limitations_or_challenges": "Loses explicit graph structure (especially reentrancies and long-distance relations); ambiguous duplicated tokens (same concept appears multiple times); hurts generation for graphs with many reentrancies or large graphs; no explicit mechanism to represent multi-parent nodes.",
            "uuid": "e5354.0",
            "source_info": {
                "paper_title": "Modeling Graph Structure in Transformer for Better AMR-to-Text Generation",
                "publication_date_yy_mm": "2019-08"
            }
        },
        {
            "name_short": "BPE-subword-graph",
            "name_full": "Sub-word extension of AMR graphs with Byte Pair Encoding (BPE)",
            "brief_description": "Apply BPE to split words into sub-word units and extend the AMR graph topology to include nodes/edges for sub-word units so that graph structure aligns with BPE-tokenized sequence inputs.",
            "citation_title": "Neural machine translation of rare words with subword units",
            "mention_or_use": "use",
            "representation_name": "sub-word graph extension with BPE",
            "representation_description": "Segment surface tokens with BPE and, when a graph node's corresponding token is split into sub-word pieces, create multiple connected graph nodes (one per sub-word) with an edge linking them; the incoming edge label of the original node is attached to the first sub-word node.",
            "graph_type": "AMR graphs adapted to sub-word tokenization",
            "representation_properties": "Improves handling of rare words and reduces data sparsity by operating at sub-word level; preserves graph connectivity by splitting nodes into connected sub-word nodes; increases alignment compatibility between graph nodes and sub-word vocabularies.",
            "evaluation_task": "AMR-to-text generation (same benchmarks LDC2015E86 and LDC2017T10); used as preprocessing for model training",
            "performance_metrics": "The paper reports that applying BPE and sharing vocabulary are critical to a strong baseline (ablation: BPE + shared vocab improves BLEU from 18.77 to 24.93 in development ablation), and BPE was applied (10K ops on LDC2015E86, 20K on LDC2017T10).",
            "comparison_to_other_representations": "Compared in ablation to baseline without BPE (and without vocabulary sharing); BPE+shared vocab substantially improved baseline performance. Other prior approaches used anonymization or copy mechanisms; authors prefer BPE+shared vocab.",
            "limitations_or_challenges": "Requires graph topology modification and special handling of labels for sub-word nodes; may slightly increase graph size and complexity; decisions about which edge/label to attach to which sub-word are heuristic (attach incoming edge to first sub-word).",
            "uuid": "e5354.1",
            "source_info": {
                "paper_title": "Modeling Graph Structure in Transformer for Better AMR-to-Text Generation",
                "publication_date_yy_mm": "2019-08"
            }
        },
        {
            "name_short": "Transformer-baseline",
            "name_full": "Transformer seq2seq baseline for AMR-to-text",
            "brief_description": "A standard Transformer encoder-decoder seq2seq model (multi-layer self-attention) applied to linearized AMR sequences (with BPE and shared vocabulary) serving as a strong baseline.",
            "citation_title": "Attention is all you need",
            "mention_or_use": "use",
            "representation_name": "seq2seq Transformer on linearized AMR",
            "representation_description": "Encode the depth-first linearized AMR sequence with a multi-layer Transformer encoder and decode natural language with a Transformer decoder; uses shared source-target vocabulary and BPE sub-word units.",
            "graph_type": "AMR (linearized into sequence)",
            "representation_properties": "Encodes global/implicit structural information via multi-head attention without explicit graph structure; compact and high-capacity; sensitive to data sparsity without BPE/shared vocab; does not explicitly encode reentrancies or multi-hop structural labels.",
            "evaluation_task": "AMR-to-text generation on LDC2015E86 and LDC2017T10",
            "performance_metrics": "Reported as a strong baseline: BLEU 25.50 (LDC2015E86) and 27.43 (LDC2017T10); Meteor 33.16/34.62; CHRF++ 59.88/61.85; model size ~49.1M parameters (table 3).",
            "comparison_to_other_representations": "Outperforms most prior graph-to-sequence models and is comparable with Guo et al. (2019); but structure-aware extensions presented in this paper further improve performance by up to ~4 BLEU points.",
            "limitations_or_challenges": "Implicitly models structure but cannot explicitly represent indirect relations and reentrancies; tends to underperform when AMR graphs are large or contain many reentrancies; relies on large supervised data or unlabeled data to match graph-aware methods.",
            "uuid": "e5354.2",
            "source_info": {
                "paper_title": "Modeling Graph Structure in Transformer for Better AMR-to-Text Generation",
                "publication_date_yy_mm": "2019-08"
            }
        },
        {
            "name_short": "Struct-attn (r_ij)",
            "name_full": "Structure-aware self-attention (relation-aware self-attention with learned path vectors)",
            "brief_description": "An extension of Transformer self-attention that augments attention computation with learned vector representations r_ij encoding the structured path (edge-label sequence with direction) between each concept pair so arbitrary (including indirect) graph relations are used.",
            "citation_title": "here",
            "mention_or_use": "use",
            "representation_name": "structure-aware self-attention (path-label augmented attention)",
            "representation_description": "Replace standard dot-product attention score e_ij with e_ij = ((x_i W^Q)((x_j W^K + r_ij W^R)^T))/sqrt(d_z) and similarly add r_ij W^F into value projections so the attention both scores and aggregates information conditioned on a learned vector r_ij that encodes the sequence of edge labels (with direction arrows) along the shortest path between concepts i and j.",
            "graph_type": "AMR (explicit pairwise concept-pair structure derived from graph paths)",
            "representation_properties": "Explicitly encodes arbitrary (multi-hop) relations between concept pairs, including reentrancies; r_ij provides continuous, trainable structural signals; scales with O(n^2) pair representations but paper reports only small parameter-size increase (~0.1-0.3M). Can integrate sub-word-extended graphs.",
            "evaluation_task": "AMR-to-text generation on LDC2015E86 and LDC2017T10; ablations testing effect of including/excluding indirect concept-pair information and graph size/reentrancy counts.",
            "performance_metrics": "Using structure-aware attention with the best path representation yields strong results: SA-based path encoding gives BLEU 29.66 (LDC2015E86) and 31.54 (LDC2017T10); CNN-based path encoding yields BLEU 29.10/31.82 respectively; compared to baseline BLEU improvements up to +4.16 (2015) and +4.39 (2017). Table 3 reports full metrics (BLEU/Meteor/CHRF++).",
            "comparison_to_other_representations": "Outperforms the vanilla Transformer baseline and previous graph-to-sequence approaches that only model one-hop relations; modeling indirect concept pairs improves BLEU (e.g., on LDC2017T10: full model 31.82 vs mapping indirect pairs to None 29.92). Continuous path encodings (SA, CNN) outperform discrete feature-based encoding.",
            "limitations_or_challenges": "Requires learning/lookup of r_ij for every pair (practical limits: paper truncates label sequence length to 4 for efficiency); if multiple shortest paths exist, method uses one (no multi-path aggregation); AMR lacks tense/number making generation errors unrelated to structure; small added parameter cost but quadratic pairwise computation can increase compute.",
            "uuid": "e5354.3",
            "source_info": {
                "paper_title": "Modeling Graph Structure in Transformer for Better AMR-to-Text Generation",
                "publication_date_yy_mm": "2019-08"
            }
        },
        {
            "name_short": "Path-label encodings",
            "name_full": "Path-label sequence representation methods (feature-based, avg-based, sum-based, SA-based, CNN-based)",
            "brief_description": "Five alternative methods to convert the sequence of edge labels (with direction markers) along the shortest path between two AMR concepts into a fixed-size vector r used by structure-aware attention.",
            "citation_title": "here",
            "mention_or_use": "use",
            "representation_name": "path-label sequence representations (feature / avg / sum / SA / CNN)",
            "representation_description": "Given a label sequence s = s1...sk representing the edge-label path (labels augmented with ↑/↓ for direction), methods are: (1) feature-based: treat the joined label-sequence as a discrete string feature (top 20K kept, others UNK) mapped to embeddings; (2) avg-based: elementwise average of label embeddings; (3) sum-based: sum of label embeddings; (4) SA-based: apply a self-attention encoder over label embeddings and weighted-pool hidden states to produce r; (5) CNN-based: apply 1D conv (kernel size 4) + ReLU to label embedding sequence to produce r.",
            "graph_type": "AMR (edge-label path sequences between concept pairs)",
            "representation_properties": "Feature-based is discrete and sparse (large feature vocab, data sparsity); avg/sum are simple, cheap continuous aggregations but lose order sensitivity (avg loses length info); SA-based encodes order and interactions and uses positional information; CNN-based captures local n-gram label patterns and order sensitivity; paper limits path length to 4 for efficiency (longer labels ignored).",
            "evaluation_task": "Used inside structure-aware self-attention for AMR-to-text generation; evaluated on LDC2015E86 and LDC2017T10 (same tasks/benchmarks).",
            "performance_metrics": "Reported results (Table 3): On LDC2015E86 BLEU: feature 27.23, avg 28.37, sum 28.69, SA 29.66, CNN 29.10. On LDC2017T10 BLEU: feature 30.18, avg 29.56, sum 29.92, SA 31.54, CNN 31.82. Meteor and CHRF++ also reported per-method in Table 3. Model-size (#P) minimally affected (49.1-49.4M).",
            "comparison_to_other_representations": "Continuous learned encodings (SA-based and CNN-based) outperform discrete feature-based and simple avg/sum aggregations; SA and CNN are top-performing variants (SA best on 2015, CNN best on 2017 test set in this paper). All five variants outperform the Transformer baseline substantially.",
            "limitations_or_challenges": "Feature-based: data sparsity and large vocab; avg/sum: lose order and finer interactions; SA/CNN: higher compute and parameters; authors cap path length to 4, truncating longer paths and potentially losing long-range path information; when multiple paths exist between nodes, only the shortest path is used.",
            "uuid": "e5354.4",
            "source_info": {
                "paper_title": "Modeling Graph Structure in Transformer for Better AMR-to-Text Generation",
                "publication_date_yy_mm": "2019-08"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Neural AMR: Sequence-to-sequence models for parsing and generation",
            "rating": 2
        },
        {
            "paper_title": "A graph-to-sequence model for AMR-to-text generation",
            "rating": 2
        },
        {
            "paper_title": "Graph-to-sequence learning using gated graph neural networks",
            "rating": 2
        },
        {
            "paper_title": "Structural neural encoders for AMR-to-text generation",
            "rating": 2
        },
        {
            "paper_title": "Densely connected graph convolutional networks for graph-to-sequence learning",
            "rating": 2
        },
        {
            "paper_title": "Self-attention with relative position representations",
            "rating": 2
        },
        {
            "paper_title": "Text generation from knowledge graphs with graph transformers",
            "rating": 2
        },
        {
            "paper_title": "Neural machine translation of rare words with subword units",
            "rating": 1
        },
        {
            "paper_title": "Attention is all you need",
            "rating": 1
        }
    ],
    "cost": 0.01265825,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Modeling Graph Structure in Transformer for Better AMR-to-Text Generation</h1>
<p>Jie Zhu ${ }^{1}$<br>Longhua Qian ${ }^{1}$<br>Junhui $\mathrm{Li}^{1 *}$<br>Min Zhang ${ }^{1}$<br>Muhua Zhu ${ }^{2}$<br>Guodong Zhou ${ }^{1}$<br>${ }^{1}$ School of Computer Science and Technology, Soochow University, Suzhou, China<br>${ }^{2}$ Alibaba Group, Hangzhou, China<br>zhujie951121@gmail.com, {lijunhui, qianlonghua, minzhang, gdzhou}@suda.edu.cn<br>muhua.zmh@alibaba-inc.com</p>
<h4>Abstract</h4>
<p>Recent studies on AMR-to-text generation often formalize the task as a sequence-tosequence (seq2seq) learning problem by converting an Abstract Meaning Representation (AMR) graph into a word sequence. Graph structures are further modeled into the seq2seq framework in order to utilize the structural information in the AMR graphs. However, previous approaches only consider the relations between directly connected concepts while ignoring the rich structure in AMR graphs. In this paper we eliminate such a strong limitation and propose a novel structure-aware selfattention approach to better modeling the relations between indirectly connected concepts in the state-of-the-art seq2seq model, i.e., the Transformer. In particular, a few different methods are explored to learn structural representations between two concepts. Experimental results on English AMR benchmark datasets show that our approach significantly outperforms the state of the art with 29.66 and 31.82 BLEU scores on LDC2015E86 and LDC2017T10, respectively. To the best of our knowledge, these are the best results achieved so far by supervised models on the benchmarks.</p>
<h2>1 Introduction</h2>
<p>AMR-to-text generation is a task of automatically generating a natural language sentence from an Abstract Meaning Representation (AMR) graph. Due to the importance of AMR as a widely adopted semantic formalism in representing the meaning of a sentence (Banarescu et al., 2013), AMR has become popular in semantic representation and AMR-to-text generation has been drawing more and more attention in the last decade. As the example in Figure 1(a) shows, nodes, such as he and convict-01, represent semantic concepts</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup>and edges, such as ":ARG1" and ":quant", refer to semantic relations between the concepts. Since two concepts close in an AMR graph may map into two segments that are distant in the corresponding sentence, AMR-to-text generation is challenging. For example in Figure 1, the neighboring concepts he and convict-01 correspond to the words he and convicted which locate at the different ends of the sentence.</p>
<p>To address the above mentioned challenge, recent studies on AMR-to-text generation regard the task as a sequence-to-sequence (seq2seq) learning problem by properly linearizing an AMR graph into a sequence (Konstas et al., 2017). Such an input representation, however, is apt to lose useful structural information due to the removal of reentrant structures for linearization. To better model graph structures, previous studies propose various graph-based seq2seq models to incorporate graphs as an additional input representation (Song et al., 2018; Beck et al., 2018; Damonte and Cohen, 2019). Although such graph-to-sequence models can achieve the state-of-the-art results, they focus on modeling one-hop relations only. That is, they only model concept pairs connected directly by an edge (Song et al., 2018; Beck et al., 2018), and as a result, ignore explicit structural information of indirectly connected concepts in AMR graphs, e.g. the relation between concepts he and possible in Figure 1.</p>
<p>To make better use of structural information in an AMR graph, we attempt to model arbitrary concept pairs no matter whether directly connected or not. To this end, we extend the encoder in the state-of-the-art seq2seq model, i.e., the Transformer (Vaswani et al., 2017) and propose structure-aware self-attention encoding approach. In particular, several distinct methods are proposed to learn structure representations for the new self-attention mechanism.</p>
<p>Empirical studies on two English benchmarks show that our approach significantly advances the state of the art for AMR-to-text generation, with the performance improvement of 4.16 BLEU score on LDC2015E86 and 4.39 BLEU score on LDC2017T10 respectively over the strong baseline. Overall, this paper makes the following contributions.</p>
<ul>
<li>To the best of our knowledge, this is the first work that applies the Transformer to the task of AMR-to-text generation. On the basis of the Transformer, we build a strong baseline that reaches the state of the art.</li>
<li>We propose a new self-attention mechanism to incorporate richer structural information in AMR graphs. Experimental results on two benchmarks demonstrate the effectiveness of the proposed approach.</li>
<li>Benefiting from the strong baseline and the structure-aware self-attention mechanism, we greatly advance the state of the art in the task.</li>
</ul>
<h2>2 AMR-to-Text Generation with Graph Structure Modeling</h2>
<p>We start by describing the implementation of our baseline system, a state-of-the-art seq2seq model which is originally used for neural machine translation and syntactic parsing (Vaswani et al., 2017). Then we detail the proposed approach to incorporating structural information from AMR graphs.</p>
<h3>2.1 Transformer-based Baseline</h3>
<p>Transformer: Our baseline system builds on the Transformer which employs an encoder-decoder framework, consisting of stacked encoder and decoder layers. Each encoder layer has two sublayers: self-attention layer followed by a positionwise feed forward layer. Self-attention layer employs multiple attention heads and the results from each attention head are concatenated and transformed to form the output of the self-attention layer. Each attention head uses scaled dotproduct attention which takes a sequence $x=$ $\left(x_{1}, \cdots, x_{n}\right)$ of $n$ elements as input and computes a new sequence $z=\left(z_{1}, \cdots, z_{n}\right)$ of the same length:</p>
<p>$$
z=\operatorname{Attention}(x)
$$</p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" />
(b)
( possible :arg1 ( sentence :arg1 he :arg2 ( temporalquantity :quant 7 :unit year :location prison ) :condition ( convict :arg1 he ) ) )
(c)
possible sentence he temporal-quantity 7 year prison convict
<img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 1: (a) An example of AMR graph for the sentence of He could be sentenced to 7 years in prison if convicted. (b) input to our baseline system, the seq2seq Transformer. (c) input to our proposed system based on structure-aware self-attention. (d) An example of graph structure extensions to sub-word units.</p>
<p>where $x_{i} \in \mathbb{R}^{d_{x}}$ and $z \in \mathbb{R}^{n \times d_{z}}$. Each output element $z_{i}$ is a weighted sum of a linear transformation of input elements:</p>
<p>$$
z_{i}=\sum_{j=1}^{n} \alpha_{i j}\left(x_{j} W^{V}\right)
$$</p>
<p>where $W^{V} \in \mathbb{R}^{d_{x} \times d_{z}}$ is matrix of parameters. The vectors $\alpha_{i}=\left(\alpha_{i 1}, \cdots, \alpha_{i n}\right)$ in Equation 2 are obtained by the self-attention model, which captures the correspondences between $x_{i}$ and others. Specifically, the attention weight $\alpha_{i j}$ of each element $x_{j}$ is computed using a softmax function:</p>
<p>$$
\alpha_{i j}=\frac{\exp \left(e_{i j}\right)}{\sum_{k=1}^{n} \exp \left(e_{i k}\right)}
$$</p>
<p>where</p>
<p>$$
e_{i j}=\frac{\left(x_{i} W^{Q}\right)\left(x_{j} W^{K}\right)^{T}}{\sqrt{d_{z}}}
$$</p>
<p>is an alignment function which measures how well the input elements $x_{i}$ and $x_{j}$ match. $W^{Q}, W^{K} \in$ $\mathbb{R}^{d_{x} \times d_{z}}$ are parameters to be learned.
Input Representation: We use the depth-first traversal strategy as in Konstas et al. (2017) to linearize AMR graphs and to obtain simplified AMRs. We remove variables, wiki links and sense tags before linearization. Figure 1(b) shows an example linearization result for the AMR graph in Figure 1(a). Note that the reentrant concept he in Figure 1 (a) maps to two different tokens in the linearized sequence.
Vocabulary: Training AMR-to-text generation systems solely on labeled data may suffer from data sparseness. To attack this problem, previous works adopt techniques like anonymization to remove named entities and rare words (Konstas et al., 2017), or apply a copy mechanism (Gulcehre et al., 2016) such that the models can learn to copy rare words from the input sequence. In this paper we instead use two simple yet effective techniques. One is to apply Byte Pair Encoding (BPE) (Sennrich et al., 2016) to split words into smaller, more frequent sub-word units. The other is to use a shared vocabulary for both source and target sides. Experiments in Section 3.2 demonstrate the necessity of the techniques in building a strong baseline.</p>
<h3>2.2 Modeling Graph Structures in Transformer</h3>
<p>Input Representation: We also use the depthfirst traversal strategy to linearize AMR graphs
and to obtain simplified AMRs which only consist of concepts. As shown in Figure 1 (c), the input sequence is much shorter than the input sequence in the baseline. Besides, we also obtain a matrix which records the graph structure between every concept pair, which implies their semantic relationship (Section2.3).
Vocabulary: To be compatible with sub-words, we extend the original AMR graph, if necessary, to include the structures of sub-words. As sentence01 in Figure 1(a) is segmented into sent@ @ ence01, we split the original node into two connected ones with an edge labeled as the incoming edge of the first unit. Figure 1(d) shows the graph structure for sub-words sent@ @ ence-01.
Structure-Aware Self-Attention: Motivated by Shaw et al. (2018), we extend the conventional self-attention architecture to explicitly encode the relation between an element pair $\left(x_{i}, x_{j}\right)$ in the alignment model by replacing Equation 4 with Equation 5. Note that the relation $r_{i j} \in \mathbb{R}^{d_{z}}$ is the vector representation for element pair $\left(x_{i}, x_{j}\right)$, and will be learned in Section 2.3.</p>
<p>$$
e_{i j}=\frac{\left(x_{i} W^{Q}\right)\left(x_{j} W^{K}+r_{i j} W^{R}\right)^{T}}{\sqrt{d_{z}}}
$$</p>
<p>where $W^{R} \in \mathbb{R}^{d_{z} \times d_{z}}$ is a parameter matrix. Then, we update Equation 2 accordingly to propagate structure information to the sublayer output by:</p>
<p>$$
z_{i}=\sum_{j=1}^{n} \alpha_{i j}\left(x_{j} W^{V}+r_{i j} W^{F}\right)
$$</p>
<p>where $W^{F} \in \mathbb{R}^{d_{z} \times d_{z}}$ is a parameter matrix.</p>
<h3>2.3 Learning Graph Structure Representation for Concept Pairs</h3>
<p>The above structure-aware self-attention is capable of incorporating graph structure between concept pairs. In this section, we explore a few methods to learn the representation for concept pairs. We use a sequence of edge labels, along the path from $x_{i}$ to $x_{j}$ to indicate the AMR graph structure between concepts $x_{i}$ and $x_{j} .{ }^{1}$ In order to distinguish the edge direction, we add a direction symbol to each label with $\uparrow$ for climbing up along the path, and $\downarrow$ for going down. Specifically, for the special case of $i==j$, we use None as the path. Table 1 demonstrates structural label sequences between a few concept pairs in Figure 1.</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<table>
<thead>
<tr>
<th style="text-align: left;">$x_{i}$</th>
<th style="text-align: center;">$x_{j}$</th>
<th style="text-align: center;">Structural label sequence</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">he</td>
<td style="text-align: center;">convict-01</td>
<td style="text-align: center;">:ARG1 $\uparrow$</td>
</tr>
<tr>
<td style="text-align: left;">he</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">:ARG1 $\uparrow$ :ARG2 $\downarrow:$ quant $\downarrow$</td>
</tr>
<tr>
<td style="text-align: left;">he</td>
<td style="text-align: center;">he</td>
<td style="text-align: center;">None</td>
</tr>
</tbody>
</table>
<p>Table 1: Examples of structural path between a few concept pairs in Figure 1.</p>
<p>Now, given a structural path with a label sequence $s=s_{1}, \cdots, s_{k}$ and its $d_{x}$-sized corresponding label embedding sequence $l=$ $l_{1}, \cdots, l_{k}$, we use the following methods to obtain its representation vector $r$, which maps to $r_{i j}$ in Equation 5 and Equation 6.</p>
<h2>Feature-based</h2>
<p>A natural way to represent the structural path is to view it as a string feature. To this end, we combine the labels in the structural path into a string. Unsurprisingly, this will end up with a large number of features. We keep the most frequent ones (i.e., 20 K in our experiments) in the feature vocabulary and map all others into a special feature $U N K$. Each feature in the vocabulary will be mapped into a randomly initialized vector.</p>
<h2>Avg-based</h2>
<p>To overcome the data sparsity in the above featurebased method, we view the structural path as a label sequence. Then we simply use the averaged label embedding as the representation vector of the sequence, i.e.,</p>
<p>$$
r=\frac{\sum_{i=1}^{k} l_{i}}{k}
$$</p>
<h2>Sum-based</h2>
<p>Sum-based method simply returns the sum of all label embeddings in the sequence, i.e.,</p>
<p>$$
r=\sum_{i=1}^{k} l_{i}
$$</p>
<h2>Self-Attention-based (SA-based for short)</h2>
<p>As shown in Figure 2, given the label sequence $s=s_{1}, \cdots, s_{k}$, we first obtain the sequence $e$, whose element is the addition of a word embedding and the corresponding position embedding. Then we use the self-attention, as presented in Eq. 1 to obtain its hidden states $h$, i.e, $h=\operatorname{Attention}(e)$, where $h_{i} \in \mathbb{R}^{d_{z}}$. Our aim is to encode a variable length sentence into a $d_{z^{-}}$ sized vector. Motivated by (Lin et al., 2017), we achieve this by choosing a linear combination of
<img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 2: Self-Attention-based method.
the $k$ vectors in $h$. Computing the linear combination requires an attention mechanism which takes the whole hidden states $h$ as input, and outputs a vector of weights $\alpha$ :</p>
<p>$$
\alpha=\operatorname{softmax}\left(W^{2} \tanh \left(W^{1} h^{T}\right)\right)
$$</p>
<p>where $W^{1} \in \mathbb{R}^{d_{w} \times d_{z}}$ and $W^{2} \in \mathbb{R}^{d_{w}}$. Then the label sequence representation vector is the weighted sum of its hidden states:</p>
<p>$$
r=\sum_{i=1}^{k} \alpha_{i} h_{i}
$$</p>
<h2>CNN-based</h2>
<p>Motivated by (Kalchbrenner et al., 2014), we use convolutional neural network (CNN) to convolute the label sequence $l$ into a vector $r$, as follow:</p>
<p>$$
\begin{aligned}
\operatorname{conv}=\operatorname{Conv} 1 D(\text { kernel_size } &amp; =(m) \
\text { strides } &amp; =1 \
\text { filters } &amp; =d_{z} \
\text { input_shape } &amp; =d_{z} \
\text { activation } &amp; =^{\prime} \operatorname{relu}^{\prime} \
r=\operatorname{conv}(l)
\end{aligned}
$$</p>
<p>where kernel size $m$ is set to 4 in our experiments.</p>
<h2>3 Experimentation</h2>
<h3>3.1 Experimental Settings</h3>
<p>For evaluation of our approach, we use the sentences annotated with AMRs from the LDC release LDC2015E86 and LDC2017T10. The two datasets contain 16,833 and 36,521 training AMRs, respectively, and share 1,368 development AMRs and 1,371 testing AMRs. We segment words into sub-word units by BPE (Sennrich et al., 2016) with 10K operations on LDC2015E86 and 20K operations on LDC2017T10.</p>
<p>For efficiently learning graph structure representation for concept pairs (except the featurebased method), we limit the maximum label sequence length to 4 and ignore the labels exceeding the maximum. In SA-based method, we set the filter size $d_{w}$ as 128 .</p>
<p>We use OpenNMT (Klein et al., 2017) as the implementation of the Transformer seq2seq model. ${ }^{2}$ In parameter setting, we set the number of layers in both the encoder and decoder to 6 . For optimization we use Adam with $\beta 1=0.1$ (Kingma and $\mathrm{Ba}, 2015$ ). The number of heads is set to 8 . In addition, we set the embedding and the hidden sizes to 512 and the batch token-size to 4096 . Accordingly, the $d_{x}$ and $d_{z}$ in Section 2 are 64. In all experiments, we train the models for 300 K steps on a single K40 GPU.</p>
<p>For performance evaluation, we use BLEU (Papineni et al., 2002), Meteor (Banerjee and Lavie, 2005; Denkowski and Lavie, 2014), and CHRF++ (Popovi, 2017) as metrics. We report results of single models that are tuned on the development set.</p>
<p>We make our code available at https://github.com/Amazing-J/ structural-transformer.</p>
<h3>3.2 Experimental Results</h3>
<p>We first show the performance of our baseline system. As mentioned before, BPE and sharing vocabulary are two techniques we applied to relieving data sparsity. Table 2 presents the results of the ablation test on the development set of LDC2015E86 by either removing BPE, or vocabulary sharing, or both of them from the baseline system. From the results we can see that BPE and vocabulary sharing are critical to building our base-</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup>Table 2: Ablation results of our baseline system on the LDC2015E86 development set.
line system (an improvement from 18.77 to 24.93 in BLEU), revealing the fact that they are two effective ways to address the issue of data sparseness for AMR-to-text generation.</p>
<p>Table 3 presents the comparison of our approach and related works on the test sets of LDC2015E86 and LDC2017T10. From the results we can see that the Transformer-based baseline outperforms most of graph-to-sequence models and is comparable with the latest work by Guo et al. (2019). The strong performance of the baseline is attributed to the capability of the Transformer to encode global and implicit structural information in AMR graphs. By comparing the five methods of learning graph structure representations, we have the following observations.</p>
<ul>
<li>All of them achieve significant improvements over the baseline: the biggest improvements are 4.16 and 4.39 BLEU scores on LDC2015E86 and LDC2017T10, respectively.</li>
<li>Methods using continuous representations (such as SA-based and CNN-based) outperform the methods using discrete representations (such as feature-based).</li>
<li>Compared to the baseline, the methods have very limited affect on the sizes of model parameters (see the column of $# P(M)$ in Table 3).</li>
</ul>
<p>Finally, our best-performing models are the best among all the single and supervised models.</p>
<h2>4 Analysis</h2>
<p>In this section, we use LDC2017T10 as our benchmark dataset to demonstrate how our proposed approach achieves higher performance than the baseline. As representative, we use CNN-based method to obtain structural representation.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">System</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">LDC2015E86</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">LDC2017T10</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">BLEU</td>
<td style="text-align: center;">Meteor</td>
<td style="text-align: center;">CHRF++</td>
<td style="text-align: center;">#P (M)</td>
<td style="text-align: center;">BLEU</td>
<td style="text-align: center;">Meteor</td>
<td style="text-align: center;">CHRF++</td>
</tr>
<tr>
<td style="text-align: center;">Baseline</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">25.50</td>
<td style="text-align: center;">33.16</td>
<td style="text-align: center;">59.88</td>
<td style="text-align: center;">49.1</td>
<td style="text-align: center;">27.43</td>
<td style="text-align: center;">34.62</td>
<td style="text-align: center;">61.85</td>
</tr>
<tr>
<td style="text-align: center;">Our Approach</td>
<td style="text-align: center;">feature-based</td>
<td style="text-align: center;">27.23</td>
<td style="text-align: center;">34.53</td>
<td style="text-align: center;">61.55</td>
<td style="text-align: center;">49.4</td>
<td style="text-align: center;">30.18</td>
<td style="text-align: center;">35.83</td>
<td style="text-align: center;">63.20</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">avg-based</td>
<td style="text-align: center;">28.37</td>
<td style="text-align: center;">35.10</td>
<td style="text-align: center;">62.29</td>
<td style="text-align: center;">49.1</td>
<td style="text-align: center;">29.56</td>
<td style="text-align: center;">35.24</td>
<td style="text-align: center;">62.86</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">sum-based</td>
<td style="text-align: center;">28.69</td>
<td style="text-align: center;">34.97</td>
<td style="text-align: center;">62.05</td>
<td style="text-align: center;">49.1</td>
<td style="text-align: center;">29.92</td>
<td style="text-align: center;">35.68</td>
<td style="text-align: center;">63.04</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">SA-based</td>
<td style="text-align: center;">29.66</td>
<td style="text-align: center;">35.45</td>
<td style="text-align: center;">63.00</td>
<td style="text-align: center;">49.3</td>
<td style="text-align: center;">31.54</td>
<td style="text-align: center;">36.02</td>
<td style="text-align: center;">63.84</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">CNN-based</td>
<td style="text-align: center;">29.10</td>
<td style="text-align: center;">35.00</td>
<td style="text-align: center;">62.10</td>
<td style="text-align: center;">49.2</td>
<td style="text-align: center;">31.82</td>
<td style="text-align: center;">36.38</td>
<td style="text-align: center;">64.05</td>
</tr>
<tr>
<td style="text-align: center;">Previous works with single models</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Konstas et al. (2017)*</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">22.00</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">Cao and Clark (2019)*</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">23.5</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">26.8</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">Song et al. (2018) ${ }^{\ddagger}$</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">23.30</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">Beck et al. (2018) ${ }^{\ddagger}$</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">23.3</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">50.4</td>
</tr>
<tr>
<td style="text-align: center;">Damonte and Cohen (2019) ${ }^{\ddagger}$</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">24.40</td>
<td style="text-align: center;">23.60</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">24.54</td>
<td style="text-align: center;">24.07</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">Guo et al. (2019) ${ }^{\ddagger}$</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">25.7</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">27.6</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">57.3</td>
</tr>
<tr>
<td style="text-align: center;">Song et al. (2016) ${ }^{\ddagger}$</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">22.44</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">Previous works with either ensemble models or unlabelled data, or both</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Konstas et al. (2017)*</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">33.8</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">Song et al. (2018) ${ }^{\ddagger}$</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">33.0</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: center;">Beck et al. (2018) ${ }^{\ddagger}$</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">27.5</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">53.5</td>
</tr>
<tr>
<td style="text-align: center;">Guo et al. (2019) ${ }^{\ddagger}$</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">35.3</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
</tbody>
</table>
<p>Table 3: Comparison results of our approaches and related studies on the test sets of LDC2015E86 and LDC2017T10. #P indicates the size of parameters in millions. * indicates seq2seq-based systems while ${ }^{\dagger}$ for graph-based models, and ${ }^{\ddagger}$ for other models. All our proposed systems are significant over the baseline at 0.01 , tested by bootstrap resampling (Koehn, 2004).</p>
<table>
<thead>
<tr>
<th style="text-align: center;">System</th>
<th style="text-align: center;">BLEU</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Baseline</td>
<td style="text-align: center;">27.43</td>
</tr>
<tr>
<td style="text-align: center;">Our approach</td>
<td style="text-align: center;">31.82</td>
</tr>
<tr>
<td style="text-align: center;">No indirectly connected concept pairs</td>
<td style="text-align: center;">29.92</td>
</tr>
</tbody>
</table>
<p>Table 4: Performance on the test set of our approach with or without modeling structural information of indirectly connected concept pairs.</p>
<h3>4.1 Effect of Modeling Structural Information of Indirectly Connected Concept Pairs</h3>
<p>Our approach is capable of modeling arbitrary concept pairs no matter whether directly connected or not. To investigate the effect of modeling structural information of indirectly connected concept pairs, we ignore their structural information by mapping all structural label sequences between two indirectly connected concept pairs into None. In this way, the structural label sequence for he and 7 in Table 1, for example, will be None.</p>
<p>Table 4 compares the performance of our approach with or without modeling structural information of indirectly connected concept pairs. It
shows that by modeling structural information of indirectly connected concept pairs, our approach improves the performance on the test set from 29.92 to 31.82 in BLEU scores. It also shows that even without modeling structural information of indirectly connected concept pairs, our approach achieves better performance than the baseline.</p>
<h3>4.2 Effect on AMR Graphs with Different Sizes of Reentrancies</h3>
<p>Linearizing an AMR graph into a sequence unavoidably loses information about reentrancies (nodes with multiple parents). This poses a challenge for the baseline since there exists on obvious sign that the first he and the second he, as shown in Figure 1 (b), refer to the same person. By contrast, our approach models reentrancies explicitly. Therefore, it is expected that the benefit of our approach is more evident for those AMR graphs containing more reentrancies. To test this hypothesis, we partition source AMR graphs to different groups by their numbers of reentrancies and evaluate their performance respectively. As shown in Figure 3, the performance gap be-</p>
<p><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 3: Performance (in BLEU) on the test set with respect to the reentrancy numbers of the input AMR graphs.
tween our approach and the baseline goes widest for AMR graphs with more than 5 reentrancies, on which our approach outperforms the baseline by 6.61 BLEU scores.</p>
<h3>4.3 Effect on AMR Graphs with Different Sizes</h3>
<p>When we encode an AMR graph with plenty concepts, linearizing it into a sequence tends to lose great amount of structural information. In order to test the hypothesis that graphs with more concepts contribute more to the improvement, we partition source AMR graphs to different groups by their sizes (i.e., numbers of concepts) and evaluate their performance respectively. Figure 4 shows the results which indicate that modeling graph structures significantly outperforms the baseline over all AMR lengths. We also observe that the performance gap between the baseline and our approach increases when AMR graphs become big, revealing that the baseline seq2seq model is far from capturing deep structural details of big AMR graphs. Figure 4 also indicates that text generation becomes difficult for big AMR graphs. We think that the low performance on big AMR graphs is mainly attributed to two reasons:</p>
<ul>
<li>Big AMR graphs are usually mapped into long sentences while seq2seq model tends to stop early for long inputs. As a result, the length ratio ${ }^{3}$ for AMRs with more than 40 concepts is 0.906 , much lower than that for AMRs with less concepts.</li>
</ul>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup><img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 4: Performance (in BLEU) on the test set with respect to the size of the input AMR graphs.</p>
<ul>
<li>Big AMR graphs are more likely to have reentrancies, which makes the generation more challenging.</li>
</ul>
<h3>4.4 Case Study</h3>
<p>In order to better understand the model performance, Figure 5 presents a few examples studied in Song et al. (2018) (Example (1)) and Damonte and Cohen (2019) (Examples (2) - (5)).</p>
<p>In Example (1), though our baseline recovers a propositional phrase for the noun staff and another one for the noun funding, it fails to recognize the anaphora and antecedent relation between the two propositional phrases. In contrast, our approach successfully recognizes :prep-for $c$ as a reentrancy node and generates one propositional phrase shared by both nouns staff and funding. In Example (2), we note that although AMR graphs lack tense information, the baseline generates output with inconsistent tense (i.e., do and found) while our approach consistently prefers past tense for the two clauses. In Example (3), only our approach correctly uses people as the subject of the predicate can. In Example (4), the baseline fails to predict the direct object you for predicate recommend. Finally in Example (5), the baseline fails to recognize the subject-predicate relation between noun communicate and verb need. Overall, we note that compared to the baseline, our approach produces more accurate output and deal with reentrancies more properly.</p>
<p>Comparing the generation of our approach and graph-based models in Song et al. (2018) and Damonte and Cohen (2019), we observe that our generation is more close to the reference in sentence structure. Due to the absence of tense informa-</p>
<p><img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>Figure 5: Examples of generation from AMR graphs. (1) is from Song et al. (2018), (2) - (5) are from Damonte and Cohen (2019). REF is the reference sentence. SEQ1 and G2S are the outputs of the seq2seq and the graph2seq models in Song et al. (2018), respectively. SEQ2 and GRAPH are the outputs of the seq2seq and the graph models in Damonte and Cohen (2019), respectively.
tion in AMR graphs, our model tends to use past tense, as provided and did in Example (1) and (2). Similarly, without information concerning singular form and plural form, our model is more likely to use plural nouns, as centers and lawyers in Example (1) and (5).</p>
<h2>5 Related Work</h2>
<p>Most studies in AMR-to-text generation regard it as a translation problem and are motivated by the recent advances in both statistical machine translation (SMT) and neural machine translation (NMT). Flanigan et al. (2016) first transform an AMR graph into a tree, then specify a number of tree-to-string transduction rules based on align-
ments that are used to drive a tree-based SMT model (Graehl and Knight, 2004). Pourdamghani et al. (2016) develop a method that learns to linearize AMR graphs into AMR strings, and then feed them into a phrase-based SMT model (Koehn et al., 2003). Song et al. (2017) use synchronous node replacement grammar (SNRG) to generate text. Different from synchronous context-free grammar in hierarchical phrase-based SMT (Chiang, 2007), SNRG is a grammar over graphs.</p>
<p>Moving to neural seq2seq approaches, Konstas et al. (2017) successfully apply seq2seq model together with large-scale unlabeled data for both text-to-AMR parsing and AMR-to-text generation. With special interest in the target side syn-</p>
<p>tax, Cao and Clark (2019) use seq2seq models to generate target syntactic structure, and then the surface form. To prevent the information loss in linearizing AMR graphs into sequences, (Song et al., 2018; Beck et al., 2018) propose graph-to-sequence models to encode graph structure directly. Focusing on reentrancies, Damonte and Cohen (2019) propose stacking encoders which consist of BiLSTM (Graves et al., 2013), TreeLSTMs (Tai et al., 2015), and Graph Convolutional Network (GCN) (Duvenaud et al., 2015; Kipf and Welling, 2016). Guo et al. (2019) propose densely connected GCN to better capture both local and non-local features. However, all the aforementioned graph-based models only consider the relations between nodes that are directly connected, thus lose the structural information between nodes that are indirectly connected via an edge path.</p>
<p>Recent studies also extend the Transformer to encode structural information for other NLP applications. Shaw et al. (2018) propose relationaware self-attention to capture relative positions of word pairs for neural machine translation. Ge et al. (2019) extend the relation-aware selfattention to capture syntactic and semantic structures. Our model is inspired by theirs but aims to encode structural label sequences of concept pairs. Koncel-Kedziorski et al. (2019) propose graph Transformer to encode graph structure. Similar to the GCN, it focuses on the relations between directly connected nodes.</p>
<h2>6 Conclusion and Future Work</h2>
<p>In this paper we proposed a structure-aware selfattention for the task of AMR-to-text generation. The major idea of our approach is to encode long-distance relations between concepts in AMR graphs into the self-attention encoder in the Transformer. In the setting of supervised learning, our models achieved the best experimental results ever reported on two English benchmarks.</p>
<p>Previous studies have shown the effectiveness of using large-scale unlabelled data. In future work, we would like to do semi-supervised learning and use silver data to test how much improvements could be further achieved.</p>
<h2>Acknowledgments</h2>
<p>We thank the anonymous reviewers for their insightful comments and suggestions. We are grateful to Linfeng Song for fruitful discussions. This
work is supported by the National Natural Science Foundation of China (Grant No. 61876120, 61673290, 61525205), and the Priority Academic Program Development of Jiangsu Higher Education Institutions.</p>
<h2>References</h2>
<p>Laura Banarescu, Claire Bonial, Shu Cai, Madalina Georgescu, Kira Griffitt, Ulf Hermjakob, Kevin Knight, Philipp Koehn, Martha Palmer, and Nathan Schneider. 2013. Abstract meaning representation for sembanking. In Proceedings of 7th Linguistic Annotation Workshop \&amp; Interoperability with Discourse, pages 178-186.</p>
<p>Satanjeev Banerjee and Alon Lavie. 2005. Meteor: An automatic metric for mt evaluation with improved correlation with human judgments. In Proceedings of $A C L$, pages $65-72$.</p>
<p>Daniel Beck, Gholamreza Haffari, and Trevor Cohn. 2018. Graph-to-sequence learning using gated graph neural networks. In Proceedings of ACL, pages 273-283.</p>
<p>Kris Cao and Stephen Clark. 2019. Factorising amr generation through syntax. In Proceedings of NAACL, pages 2157-2163.</p>
<p>David Chiang. 2007. Hierarchical phrase-based translation. Computational Linguistics, 33:201-228.</p>
<p>Marco Damonte and Shay B. Cohen. 2019. Structural neural encoders for AMR-to-text generation. In Proceedings of NAACL, pages 3649-3658.</p>
<p>Michael Denkowski and Alon Lavie. 2014. Meteor universal: Language specific translation evaluation for any target language. In Proceedings of WMT, pages 376-380.</p>
<p>David K Duvenaud, Dougal Maclaurin, Jorge Iparraguirre, Rafael Bombarell, Timonthy Hirzel, Alan Aspuru-Guzik, and Ryan P Adams. 2015. Convolutional networks on graphs for learning molecular fingerprints. In Proceedings of NIPS, pages 22242232.</p>
<p>Jeffrey Flanigan, Chris Dyer, Noah A. Smith, and Jaime Carbonell. 2016. Generation from abstract meaning representation using tree transducers. In Proceedings of NAACL, pages 731-739.</p>
<p>DongLai Ge, Junhui Li, Muhua Zhu, and Shoushan Li. 2019. Modeling source syntax and semantics for neural amr parsing. In Proceedings of IJCAI, pages 4975-4981.</p>
<p>Jonathan Graehl and Kevin Knight. 2004. Training tree transducers. In Proceedings of NAACL, pages 105112 .</p>
<p>Alex Graves, Abdel rahman Mohamed, and Geoffrey Hinton. 2013. Speech recognition with deep recurrent neural networks. In Proceedings of ICASSP, pages 6645-6649.</p>
<p>Caglar Gulcehre, Sungjin Ahn, Ramesh Nallapati, Bowen Zhou, and Yoshua Bengio. 2016. Pointing the unknown words. In Proceedings of ACL, pages $140-149$.</p>
<p>Zhijiang Guo, Yan Zhang, Zhiyang Teng, and Wei Lu. 2019. Densely connected graph convolutional networks for graph-to-sequence learning. Transactions of the Association of Computational Linguistics, 7:297-312.</p>
<p>Nal Kalchbrenner, Edward Grefenstette, and Phil Blunsom. 2014. A convolutional neural network for modelling sentences. In Proceedings of ACL, pages $655-665$.</p>
<p>Diederik P. Kingma and Jimmy Ba. 2015. Adam: A method for stochastic optimization. In Proceedings of $I C L R$.</p>
<p>Thomas N Kipf and Max Welling. 2016. Semisupervised classification with graph convolutional networks. In Proceedings of $I C L R$.</p>
<p>Guillaume Klein, Yoon Kim, Yuntian Deng, Jean Senellart, and Alexander M. Rush. 2017. Opennmt: Open-source toolkit for neural machine translation. In Proceedings of ACL, System Demonstrations, pages 67-72.</p>
<p>Philipp Koehn. 2004. Statistical significance tests for machine translation evaluation. In Proceedings of EMNLP, pages 388-395.</p>
<p>Philipp Koehn, Franz J. Och, and Daniel Marcu. 2003. Statistical phrase-based translation. In Proceedings of NAACL, pages 127-133.</p>
<p>Rik Koncel-Kedziorski, Dhanush Bekal, Yi Luan, Mirella Lapata, and Hannaneh Hajishirzi. 2019. Text generation from knowledge graphs with graph transformers. In Proceedings of NAACL, pages 2284-2293.</p>
<p>Ioannis Konstas, Srinivasan Iyer, Mark Yatskar, Yejin Choi, and Luke Zettlemoyer. 2017. Neural AMR: Sequence-to-sequence models for parsing and generation. In Proceedings of ACL, pages 146-157.</p>
<p>Zhouhan Lin, Minwei Feng, Cicero Nogueira dos Santos, Mo Yu, Bing Xiang, Bowen Zhou, and Yoshua Bengio. 2017. A structured self-attentive sentence embedding. In Proceedings of $I C L R$.</p>
<p>Kishore Papineni, Salim Roukos, Ward Todd, and WeiJing Zhu. 2002. Bleu: a method for automatic evaluation of machine translation. In Proceedings of $A C L$, pages 311-318.</p>
<p>Maja Popovi. 2017. chrf++: words helping character n-grams. In Proceedings of WMT, pages 612-618.</p>
<p>Nima Pourdamghani, Kevin Knight, and Ulf Hermjakob. 2016. Generating english from abstract meaning representations. In Proceedings of the 9th International Natural Language Generation conference, pages 21-25.</p>
<p>Rico Sennrich, Barry Haddow, and Alexandra Birch. 2016. Neural machine translation of rare words with subword units. In Proceedings of ACL, pages 17151725.</p>
<p>Peter Shaw, Jakob Uszkoreit, and Ashish Vaswani. 2018. Self-attention with relative position representations. In Proceedings of NAACL, pages 464-468.</p>
<p>Linfeng Song, Xiaochang Peng, Yue Zhang, Zhiguo Wang, and Daniel Gildea. 2017. Amr-to-text generation with synchronous node replacement grammar. In Proceedings of $A C L$, pages 7-13.</p>
<p>Linfeng Song, Yue Zhang, Xiaochang Peng, Zhiguo Wang, and Daniel Gildea. 2016. Amr-to-text generation as a traveling salesman problem. In Proceedings of EMNLP, pages 2084-2089.</p>
<p>Linfeng Song, Yue Zhang, Zhiguo Wang, and Daniel Gildea. 2018. A graph-to-sequence model for AMR-to-text generation. In Proceedings of ACL, pages 1616-1626.</p>
<p>Kai Sheng Tai, Richard Socher, and Christopher D. Manning. 2015. Improved semantic representations from tree-structured long short-term memory networks. In Proceedings of ACL, pages 1556-1566.</p>
<p>Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N.Gomez, Lukasz Kaiser, and Illia Polosukhin. 2017. Attention is all you need. In Proceedings of NIPS, pages 59986008.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{3}$ Length ratio is the length of generation output, divided by the length of reference.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>