<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-591 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-591</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-591</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-19.html">extraction-schema-19</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of variability, reproducibility, or stochasticity in language model-driven scientific experiments, including sources of variability, reproducibility metrics, and methods to improve reproducibility.</div>
                <p><strong>Paper ID:</strong> paper-1464776f20e2bccb6182f183b5ff2e15b0ae5e56</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/1464776f20e2bccb6182f183b5ff2e15b0ae5e56" target="_blank">Benchmarking Deep Reinforcement Learning for Continuous Control</a></p>
                <p><strong>Paper Venue:</strong> International Conference on Machine Learning</p>
                <p><strong>Paper TL;DR:</strong> This work presents a benchmark suite of continuous control tasks, including classic tasks like cart-pole swing-up, tasks with very high state and action dimensionality such as 3D humanoid locomotion, task with partial observations, and tasks with hierarchical structure.</p>
                <p><strong>Paper Abstract:</strong> Recently, researchers have made significant progress combining the advances in deep learning for learning feature representations with reinforcement learning. Some notable examples include training agents to play Atari games based on raw pixel data and to acquire advanced manipulation skills using raw sensory inputs. However, it has been difficult to quantify progress in the domain of continuous control due to the lack of a commonly adopted benchmark. In this work, we present a benchmark suite of continuous control tasks, including classic tasks like cart-pole swing-up, tasks with very high state and action dimensionality such as 3D humanoid locomotion, tasks with partial observations, and tasks with hierarchical structure. We report novel findings based on the systematic evaluation of a range of implemented reinforcement learning algorithms. Both the benchmark and reference implementations are released at this https URL in order to facilitate experimental reproducibility and to encourage adoption by other researchers.</p>
                <p><strong>Cost:</strong> 0.011</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e591.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e591.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of variability, reproducibility, or stochasticity in language model-driven scientific experiments, including sources of variability, reproducibility metrics, and methods to improve reproducibility.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>rllab_benchmark_repro</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Benchmarking Deep Reinforcement Learning for Continuous Control (reproducibility & variability findings)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Systematic evaluation of multiple reinforcement-learning algorithms on a 31-task continuous-control benchmark with explicit reporting and analysis of run-to-run variability, stochasticity sources, and interventions to improve experimental stability and reproducibility.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Benchmarking Deep Reinforcement Learning for Continuous Control</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>scientific_domain</strong></td>
                            <td>Reinforcement learning / continuous control (robotics simulation)</td>
                        </tr>
                        <tr>
                            <td><strong>experimental_task</strong></td>
                            <td>Benchmark and comparative evaluation of many RL algorithms (REINFORCE, TNPG, TRPO, RWR, REPS, CEM, CMA-ES, DDPG, recurrent variants) across 31 continuous-control tasks (basic, locomotion, partially observable, hierarchical) to measure performance, variability, and stability.</td>
                        </tr>
                        <tr>
                            <td><strong>variability_sources</strong></td>
                            <td>Random initialization and random seeds (policy and environment RNG), stochastic policies and action sampling, on-policy rollout sampling noise, perturbed policy parameter sampling (CEM/CMA-ES), simulator nondeterminism and contact/physics variation, hyperparameter choices (step sizes δ_KL, learning rates, initial noise/std), reward scaling (noted for DDPG), recurrent vs feedforward architectures (recurrent policies produce larger changes in policy distribution for small parameter changes), variation in environment parameters (system identification tasks), memory/implementation constraints (CMA-ES failing on high-dimensional tasks).</td>
                        </tr>
                        <tr>
                            <td><strong>variability_measured</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>variability_metrics</strong></td>
                            <td>Per-algorithm/task mean and standard deviation of cumulative returns reported as mean ± std (computed across 5 random seeds); selection metric mean(returns) - std(returns) used for hyperparameter tuning; Welch's t-test (p<0.05) used to identify algorithms not statistically significantly different; mean KL-divergence between successive policies used to measure change in policy distribution over updates (plotted); shaded error regions of mean ± std over seeds shown in learning curves.</td>
                        </tr>
                        <tr>
                            <td><strong>variability_results</strong></td>
                            <td>All reported performance entries are given as mean ± standard deviation over five random seeds (example: REINFORCE on Cart-Pole Balancing 4693.7 ± 14.0). Grid search of hyperparameters used 5 seeds per hyperparameter setting and selected settings maximizing mean - std. The paper shows KL-divergence traces (mean KL) demonstrating that REINFORCE can produce large KL jumps while TNPG/TRPO constrain KL, and notes larger step sizes (TRPO δ_KL=0.1 vs TNPG δ_KL=0.05 on Swimmer) produced faster learning; DDPG reward rescaling by factor 0.1 improved stability (qualitative). No global numeric reduction-of-variance statistics across interventions are reported beyond the per-task mean±std table entries.</td>
                        </tr>
                        <tr>
                            <td><strong>reproducibility_assessed</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>reproducibility_metrics</strong></td>
                            <td>Reproducibility / comparability facilitated by: open-source release of benchmark and reference implementations; reporting per-task per-algorithm mean ± std over 5 seeds; use of consistent random seeds across algorithms for the table; use of Welch's t-test (p<0.05) to assess statistical significance between algorithms. Hyperparameter search protocol documented (search ranges, best found values) and grid search executed with 5 seeds per configuration.</td>
                        </tr>
                        <tr>
                            <td><strong>reproducibility_results</strong></td>
                            <td>Authors provide the benchmark and reference implementations (https://github.com/rllab/rllab) to enable reproduction; experimental results are reported as mean ± std over 5 seeds and significance via Welch's t-test. They do not present a formal independent replication study; instead, they provide code, task specifications, and hyperparameter grids to aid reproducibility. No numeric replication-success rate is reported.</td>
                        </tr>
                        <tr>
                            <td><strong>reproducibility_challenges</strong></td>
                            <td>High sensitivity to hyperparameters and step sizes leading to early convergence or collapse; stochasticity of on-policy rollouts; large fluctuations in performance for some algorithms (e.g., REINFORCE) causing premature convergence to local optima; recurrent policies being harder to train and more sensitive (small parameter changes → big distributional changes); algorithm-specific stability issues (DDPG less stable, sensitive to reward scaling; CMA-ES memory/compute limits on high-dimensional problems); non-stationary / transient behavior in many tasks undermining assumptions of some algorithms (e.g., REPS assumption of stationary distribution).</td>
                        </tr>
                        <tr>
                            <td><strong>mitigation_methods</strong></td>
                            <td>Open-source release of benchmark and reference implementations; running multiple independent seeds (5) and reporting mean ± std; hyperparameter grid search with selection metric mean - std to prefer robust settings; baseline subtraction to reduce gradient variance (linear baseline with time-varying features); algorithmic constraints that limit distributional shift (TNPG / TRPO use Fisher/KL constraints, TRPO employs line search); conservative step sizes chosen by grid search; target networks and reward rescaling for DDPG to improve stability; use of conjugate gradient to compute natural gradients without forming FIM explicitly (scalability/stability); recommending reporting of shaded mean ± std learning curves; using statistical tests (Welch's t-test) to mark significance.</td>
                        </tr>
                        <tr>
                            <td><strong>mitigation_effectiveness</strong></td>
                            <td>Mitigations are reported qualitatively and via example outcomes: TNPG/TRPO's KL constraints correlate with more stable learning and less collapse; TRPO allowed a larger δ_KL (0.1) than TNPG (0.05) on Swimmer and produced slightly faster learning (reported qualitatively and visible in learning curves); hyperparameter selection using mean - std penalizes high-variance settings (protocol described but no global quantitative reduction of std reported); DDPG reward rescaling (factor 0.1) improved stability in practice according to authors (qualitative statement). No comprehensive quantitative before/after variance-reduction numbers are provided beyond the task-level mean±std table.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_without_controls</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>number_of_runs</strong></td>
                            <td>5 random seeds per reported algorithm/task entry; grid-search hyperparameter evaluations also executed under 5 seeds per setting; learning curves show mean ± std over 5 seeds.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>The paper demonstrates and quantifies run-to-run variability by reporting mean ± std across five seeds and shows that constraining policy-distribution change (TNPG/TRPO) yields more stable learning than unconstrained methods (REINFORCE); hyperparameter sensitivity is a major source of variability and is mitigated in part by grid search and selecting hyperparameters that optimize mean - std. The authors emphasize releasing code + task specs to facilitate reproducibility, but note persistent challenges (sensitivity to initialization/hyperparameters, instability of some algorithms like DDPG, difficulty training recurrent and hierarchical policies).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Benchmarking Deep Reinforcement Learning for Continuous Control', 'publication_date_yy_mm': '2016-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Continuous control with deep reinforcement learning <em>(Rating: 2)</em></li>
                <li>Trust region policy optimization <em>(Rating: 2)</em></li>
                <li>Human-level control through deep reinforcement learning <em>(Rating: 1)</em></li>
                <li>High-dimensional continuous control using generalized advantage estimation <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-591",
    "paper_id": "paper-1464776f20e2bccb6182f183b5ff2e15b0ae5e56",
    "extraction_schema_id": "extraction-schema-19",
    "extracted_data": [
        {
            "name_short": "rllab_benchmark_repro",
            "name_full": "Benchmarking Deep Reinforcement Learning for Continuous Control (reproducibility & variability findings)",
            "brief_description": "Systematic evaluation of multiple reinforcement-learning algorithms on a 31-task continuous-control benchmark with explicit reporting and analysis of run-to-run variability, stochasticity sources, and interventions to improve experimental stability and reproducibility.",
            "citation_title": "Benchmarking Deep Reinforcement Learning for Continuous Control",
            "mention_or_use": "use",
            "model_name": null,
            "model_size": null,
            "scientific_domain": "Reinforcement learning / continuous control (robotics simulation)",
            "experimental_task": "Benchmark and comparative evaluation of many RL algorithms (REINFORCE, TNPG, TRPO, RWR, REPS, CEM, CMA-ES, DDPG, recurrent variants) across 31 continuous-control tasks (basic, locomotion, partially observable, hierarchical) to measure performance, variability, and stability.",
            "variability_sources": "Random initialization and random seeds (policy and environment RNG), stochastic policies and action sampling, on-policy rollout sampling noise, perturbed policy parameter sampling (CEM/CMA-ES), simulator nondeterminism and contact/physics variation, hyperparameter choices (step sizes δ_KL, learning rates, initial noise/std), reward scaling (noted for DDPG), recurrent vs feedforward architectures (recurrent policies produce larger changes in policy distribution for small parameter changes), variation in environment parameters (system identification tasks), memory/implementation constraints (CMA-ES failing on high-dimensional tasks).",
            "variability_measured": true,
            "variability_metrics": "Per-algorithm/task mean and standard deviation of cumulative returns reported as mean ± std (computed across 5 random seeds); selection metric mean(returns) - std(returns) used for hyperparameter tuning; Welch's t-test (p&lt;0.05) used to identify algorithms not statistically significantly different; mean KL-divergence between successive policies used to measure change in policy distribution over updates (plotted); shaded error regions of mean ± std over seeds shown in learning curves.",
            "variability_results": "All reported performance entries are given as mean ± standard deviation over five random seeds (example: REINFORCE on Cart-Pole Balancing 4693.7 ± 14.0). Grid search of hyperparameters used 5 seeds per hyperparameter setting and selected settings maximizing mean - std. The paper shows KL-divergence traces (mean KL) demonstrating that REINFORCE can produce large KL jumps while TNPG/TRPO constrain KL, and notes larger step sizes (TRPO δ_KL=0.1 vs TNPG δ_KL=0.05 on Swimmer) produced faster learning; DDPG reward rescaling by factor 0.1 improved stability (qualitative). No global numeric reduction-of-variance statistics across interventions are reported beyond the per-task mean±std table entries.",
            "reproducibility_assessed": true,
            "reproducibility_metrics": "Reproducibility / comparability facilitated by: open-source release of benchmark and reference implementations; reporting per-task per-algorithm mean ± std over 5 seeds; use of consistent random seeds across algorithms for the table; use of Welch's t-test (p&lt;0.05) to assess statistical significance between algorithms. Hyperparameter search protocol documented (search ranges, best found values) and grid search executed with 5 seeds per configuration.",
            "reproducibility_results": "Authors provide the benchmark and reference implementations (https://github.com/rllab/rllab) to enable reproduction; experimental results are reported as mean ± std over 5 seeds and significance via Welch's t-test. They do not present a formal independent replication study; instead, they provide code, task specifications, and hyperparameter grids to aid reproducibility. No numeric replication-success rate is reported.",
            "reproducibility_challenges": "High sensitivity to hyperparameters and step sizes leading to early convergence or collapse; stochasticity of on-policy rollouts; large fluctuations in performance for some algorithms (e.g., REINFORCE) causing premature convergence to local optima; recurrent policies being harder to train and more sensitive (small parameter changes → big distributional changes); algorithm-specific stability issues (DDPG less stable, sensitive to reward scaling; CMA-ES memory/compute limits on high-dimensional problems); non-stationary / transient behavior in many tasks undermining assumptions of some algorithms (e.g., REPS assumption of stationary distribution).",
            "mitigation_methods": "Open-source release of benchmark and reference implementations; running multiple independent seeds (5) and reporting mean ± std; hyperparameter grid search with selection metric mean - std to prefer robust settings; baseline subtraction to reduce gradient variance (linear baseline with time-varying features); algorithmic constraints that limit distributional shift (TNPG / TRPO use Fisher/KL constraints, TRPO employs line search); conservative step sizes chosen by grid search; target networks and reward rescaling for DDPG to improve stability; use of conjugate gradient to compute natural gradients without forming FIM explicitly (scalability/stability); recommending reporting of shaded mean ± std learning curves; using statistical tests (Welch's t-test) to mark significance.",
            "mitigation_effectiveness": "Mitigations are reported qualitatively and via example outcomes: TNPG/TRPO's KL constraints correlate with more stable learning and less collapse; TRPO allowed a larger δ_KL (0.1) than TNPG (0.05) on Swimmer and produced slightly faster learning (reported qualitatively and visible in learning curves); hyperparameter selection using mean - std penalizes high-variance settings (protocol described but no global quantitative reduction of std reported); DDPG reward rescaling (factor 0.1) improved stability in practice according to authors (qualitative statement). No comprehensive quantitative before/after variance-reduction numbers are provided beyond the task-level mean±std table.",
            "comparison_with_without_controls": true,
            "number_of_runs": "5 random seeds per reported algorithm/task entry; grid-search hyperparameter evaluations also executed under 5 seeds per setting; learning curves show mean ± std over 5 seeds.",
            "key_findings": "The paper demonstrates and quantifies run-to-run variability by reporting mean ± std across five seeds and shows that constraining policy-distribution change (TNPG/TRPO) yields more stable learning than unconstrained methods (REINFORCE); hyperparameter sensitivity is a major source of variability and is mitigated in part by grid search and selecting hyperparameters that optimize mean - std. The authors emphasize releasing code + task specs to facilitate reproducibility, but note persistent challenges (sensitivity to initialization/hyperparameters, instability of some algorithms like DDPG, difficulty training recurrent and hierarchical policies).",
            "uuid": "e591.0",
            "source_info": {
                "paper_title": "Benchmarking Deep Reinforcement Learning for Continuous Control",
                "publication_date_yy_mm": "2016-04"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Continuous control with deep reinforcement learning",
            "rating": 2
        },
        {
            "paper_title": "Trust region policy optimization",
            "rating": 2
        },
        {
            "paper_title": "Human-level control through deep reinforcement learning",
            "rating": 1
        },
        {
            "paper_title": "High-dimensional continuous control using generalized advantage estimation",
            "rating": 1
        }
    ],
    "cost": 0.0113685,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Benchmarking Deep Reinforcement Learning for Continuous Control</h1>
<p>Yan Duan ${ }^{\dagger}$<br>Xi Chen ${ }^{\dagger}$<br>Rein Houthooft ${ }^{\ddagger}$<br>John Schulman ${ }^{\dagger \S}$<br>Pieter Abbeel ${ }^{\dagger}$<br>ROCKYDUAN@EECS.BERKELEY.EDU<br>C.XI@EECS.BERKELEY.EDU<br>REIN.HOUTHOOFT@UGENT.BE<br>JOSCHU@EECS.BERKELEY.EDU<br>PABBEEL@CS.BERKELEY.EDU<br>${ }^{\dagger}$ University of California, Berkeley, Department of Electrical Engineering and Computer Sciences<br>${ }^{\ddagger}$ Ghent University - iMinds, Department of Information Technology<br>§ OpenAI</p>
<h4>Abstract</h4>
<p>Recently, researchers have made significant progress combining the advances in deep learning for learning feature representations with reinforcement learning. Some notable examples include training agents to play Atari games based on raw pixel data and to acquire advanced manipulation skills using raw sensory inputs. However, it has been difficult to quantify progress in the domain of continuous control due to the lack of a commonly adopted benchmark. In this work, we present a benchmark suite of continuous control tasks, including classic tasks like cart-pole swing-up, tasks with very high state and action dimensionality such as 3D humanoid locomotion, tasks with partial observations, and tasks with hierarchical structure. We report novel findings based on the systematic evaluation of a range of implemented reinforcement learning algorithms. Both the benchmark and reference implementations are released at https://github.com/ rllab/rllab in order to facilitate experimental reproducibility and to encourage adoption by other researchers.</p>
<h2>1. Introduction</h2>
<p>Reinforcement learning addresses the problem of how agents should learn to take actions to maximize cumulative reward through interactions with the environment. The traditional approach for reinforcement learning algorithms requires carefully chosen feature representations, which are</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup>usually hand-engineered. Recently, significant progress has been made by combining advances in deep learning for learning feature representations (Krizhevsky et al., 2012; Hinton et al., 2012) with reinforcement learning, tracing back to much earlier work of Tesauro (1995) and Bertsekas \&amp; Tsitsiklis (1995). Notable examples are training agents to play Atari games based on raw pixels (Guo et al., 2014; Mnih et al., 2015; Schulman et al., 2015a) and to acquire advanced manipulation skills using raw sensory inputs (Levine et al., 2015; Lillicrap et al., 2015; Watter et al., 2015). Impressive results have also been obtained in training deep neural network policies for 3D locomotion and manipulation tasks (Schulman et al., 2015a;b; Heess et al., 2015b).</p>
<p>Along with this recent progress, the Arcade Learning Environment (ALE) (Bellemare et al., 2013) has become a popular benchmark for evaluating algorithms designed for tasks with high-dimensional state inputs and discrete actions. However, these algorithms do not always generalize straightforwardly to tasks with continuous actions, leading to a gap in our understanding. For instance, algorithms based on Q-learning quickly become infeasible when naive discretization of the action space is performed, due to the curse of dimensionality (Bellman, 1957; Lillicrap et al., 2015). In the continuous control domain, where actions are continuous and often high-dimensional, we argue that the existing control benchmarks fail to provide a comprehensive set of challenging problems (see Section 7 for a review of existing benchmarks). Benchmarks have played a significant role in other areas such as computer vision and speech recognition. Examples include MNIST (LeCun et al., 1998), Caltech101 (Fei-Fei et al., 2006), CIFAR (Krizhevsky \&amp; Hinton, 2009), ImageNet (Deng et al., 2009), PASCAL VOC (Everingham et al., 2010), BSDS500 (Martin et al., 2001), SWITCHBOARD (Godfrey et al., 1992), TIMIT (Garofolo et al., 1993), Aurora (Hirsch \&amp; Pearce, 2000), and VoiceSearch (Yu et al., 2007). The lack</p>
<p>of a standardized and challenging testbed for reinforcement learning and continuous control makes it difficult to quantify scientific progress. Systematic evaluation and comparison will not only further our understanding of the strengths of existing algorithms, but also reveal their limitations and suggest directions for future research.</p>
<p>We attempt to address this problem and present a benchmark consisting of 31 continuous control tasks. These tasks range from simple tasks, such as cart-pole balancing, to challenging tasks such as high-DOF locomotion, tasks with partial observations, and hierarchically structured tasks. Furthermore, a range of reinforcement learning algorithms are implemented on which we report novel findings based on a systematic evaluation of their effectiveness in training deep neural network policies. The benchmark and reference implementations are available at https: //github.com/rllab/rllab, allowing for the development, implementation, and evaluation of new algorithms and tasks.</p>
<h2>2. Preliminaries</h2>
<p>In this section, we define the notation used in subsequent sections.</p>
<p>The implemented tasks conform to the standard interface of a finite-horizon discounted Markov decision process (MDP), defined by the tuple $(\mathcal{S}, \mathcal{A}, P, r, \rho_{0}, \gamma, T)$, where $\mathcal{S}$ is a (possibly infinite) set of states, $\mathcal{A}$ is a set of actions, $P: \mathcal{S} \times \mathcal{A} \times \mathcal{S} \rightarrow \mathbb{R}<em 0="0">{\geq 0}$ is the transition probability distribution, $r: \mathcal{S} \times \mathcal{A} \rightarrow \mathbb{R}$ is the reward function, $\rho</em>$ is the initial state distribution, $\gamma \in(0,1]$ is the discount factor, and $T$ is the horizon.}: \mathcal{S} \rightarrow \mathbb{R}_{\geq 0</p>
<p>For partially observable tasks, which conform to the interface of a partially observable Markov decision process (POMDP), two more components are required, namely $\Omega$, a set of observations, and $\mathcal{O}: \mathcal{S} \times \Omega \rightarrow \mathbb{R}_{\geq 0}$, the observation probability distribution.</p>
<p>Most of our implemented algorithms optimize a stochastic policy $\pi_{\theta}: \mathcal{S} \times \mathcal{A} \rightarrow \mathbb{R}<em _tau="\tau">{\geq 0}$. Let $\eta(\pi)$ denote its expected discounted reward: $\eta(\pi)=\mathbb{E}</em>\right)$.
For deterministic policies, we use the notation $\mu_{\theta}: \mathcal{S} \rightarrow \mathcal{A}$ to denote the policy instead. The objective for it has the same form as above, except that now we have $a_{t}=\mu\left(s_{t}\right)$.}\left[\sum_{t=0}^{T} \gamma^{t} r\left(s_{t}, a_{t}\right)\right]$, where $\tau=\left(s_{0}, a_{0}, \ldots\right)$ denotes the whole trajectory, $s_{0} \sim \rho_{0}\left(s_{0}\right)$, $a_{t} \sim \pi\left(a_{t} \mid s_{t}\right)$, and $s_{t+1} \sim P\left(s_{t+1} \mid s_{t}, a_{t</p>
<h2>3. Tasks</h2>
<p>The tasks in the presented benchmark can be divided into four categories: basic tasks, locomotion tasks, partially observable tasks, and hierarchical tasks. We briefly describe them in this section. More detailed specifications are given
in the supplementary materials and in the source code.
We choose to implement all tasks using physics simulators rather than symbolic equations, since the former approach is less error-prone and permits easy modification of each task. Tasks with simple dynamics are implemented using Box2D (Catto, 2011), an open-source, freely available 2D physics simulator. Tasks with more complicated dynamics, such as locomotion, are implemented using MuJoCo (Todorov et al., 2012), a 3D physics simulator with better modeling of contacts.</p>
<h3>3.1. Basic Tasks</h3>
<p>We implement five basic tasks that have been widely analyzed in reinforcement learning and control literature: Cart-Pole Balancing (Stephenson, 1908; Donaldson, 1960; Widrow, 1964; Michie \&amp; Chambers, 1968), Cart-Pole Swing Up (Kimura \&amp; Kobayashi, 1999; Doya, 2000), Mountain Car (Moore, 1990), Acrobot Swing Up (DeJong \&amp; Spong, 1994; Murray \&amp; Hauser, 1991; Doya, 2000), and Double Inverted Pendulum Balancing (Furuta et al., 1978). These relatively low-dimensional tasks provide quick evaluations and comparisons of RL algorithms.</p>
<h3>3.2. Locomotion Tasks</h3>
<p>In this category, we implement six locomotion tasks of varying dynamics and difficulty: Swimmer (Purcell, 1977; Coulom, 2002; Levine \&amp; Koltun, 2013; Schulman et al., 2015a), Hopper (Murthy \&amp; Raibert, 1984; Erez et al., 2011; Levine \&amp; Koltun, 2013; Schulman et al., 2015a), Walker (Raibert \&amp; Hodgins, 1991; Erez et al., 2011; Levine \&amp; Koltun, 2013; Schulman et al., 2015a), Half-Cheetah (Wawrzyński, 2007; Heess et al., 2015b), Ant (Schulman et al., 2015b), Simple Humanoid (Tassa et al., 2012; Schulman et al., 2015b), and Full Humanoid (Tassa et al., 2012). The goal for all the tasks is to move forward as quickly as possible. These tasks are more challenging than the basic tasks due to high degrees of freedom. In addition, a great amount of exploration is needed to learn to move forward without getting stuck at local optima. Since we penalize for excessive controls as well as falling over, during the initial stage of learning, when the robot is not yet able to move forward for a sufficient distance without falling, apparent local optima exist including staying at the origin or diving forward slowly.</p>
<h3>3.3. Partially Observable Tasks</h3>
<p>In real-life situations, agents are often not endowed with perfect state information. This can be due to sensor noise, sensor occlusions, or even sensor limitations that result in partial observations. To evaluate algorithms in more realistic settings, we implement three variations of partially ob-</p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1. Illustration of locomotion tasks: (a) Swimmer; (b) Hopper; (c) Walker; (d) Half-Cheetah; (e) Ant; (f) Simple Humanoid; and (g) Full Humanoid.
servable tasks for each of the five basic tasks described in Section 3.1, leading to a total of 15 additional tasks. These variations are described below.</p>
<p>Limited Sensors: For this variation, we restrict the observations to only provide positional information (including joint angles), excluding velocities. An agent now has to learn to infer velocity information in order to recover the full state. Similar tasks have been explored in Gomez \&amp; Miikkulainen (1998); Schäfer \&amp; Udluft (2005); Heess et al. (2015a); Wierstra et al. (2007).</p>
<p>Noisy Observations and Delayed Actions: In this case, sensor noise is simulated through the addition of Gaussian noise to the observations. We also introduce a time delay between taking an action and the action being in effect, accounting for physical latencies (Hester \&amp; Stone, 2013). Agents now need to learn to integrate both past observations and past actions to infer the current state. Similar tasks have been proposed in Bakker (2001).</p>
<p>System Identification: For this category, the underlying physical model parameters are varied across different episodes (Szita et al., 2003). The agents must learn to generalize across different models, as well as to infer the model parameters from its observation and action history.</p>
<h3>3.4. Hierarchical Tasks</h3>
<p>Many real-world tasks exhibit hierarchical structure, where higher level decisions can reuse lower level skills (Parr \&amp; Russell, 1998; Sutton et al., 1999; Dietterich, 2000). For instance, robots can reuse locomotion skills when exploring the environment. We propose several tasks where both lowlevel motor controls and high-level decisions are needed. These two components each operates on a different time scale and calls for a natural hierarchy in order to efficiently learn the task.
<img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2. Illustration of hierarchical tasks: (a) Locomotion + Food Collection; and (b) Locomotion + Maze.</p>
<p>Locomotion + Food Collection: For this task, the agent needs to learn to control either the swimmer or the ant robot to collect food and avoid bombs in a finite region. The agent receives range sensor readings about nearby food and bomb units. It is given a positive reward when it reaches a food unit, or a negative reward when it reaches a bomb.</p>
<p>Locomotion + Maze: For this task, the agent needs to learn to control either the swimmer or the ant robot to reach a goal position in a fixed maze. The agent receives range sensor readings about nearby obstacles as well as its goal (when visible). A positive reward is given only when the robot reaches the goal region.</p>
<h2>4. Algorithms</h2>
<p>In this section, we briefly summarize the algorithms implemented in our benchmark, and note any modifications made to apply them to general parametrized policies. We implement a range of gradient-based policy search methods, as well as two gradient-free methods for comparison with the gradient-based approaches.</p>
<h3>4.1. Batch Algorithms</h3>
<p>Most of the implemented algorithms are batch algorithms. At each iteration, $N$ trajectories $\left{\tau_{i}\right}<em i="i">{i=1}^{N}$ are generated, where $\tau</em>$ contains data collected along the $i$ th trajectory. For on-policy gradient-based methods, all the trajectories are sampled under the current policy. For gradient-free methods, they are sampled under perturbed versions of the current policy.}=\left{\left(s_{t}^{i}, a_{t}^{i}, r_{t}^{i}\right)\right}_{t=0}^{T</p>
<p>REINFORCE (Williams, 1992): This algorithm estimates the gradient of expected return $\nabla_{\theta} \eta\left(\pi_{\theta}\right)$ using the likelihood ratio trick:</p>
<p>$$
\widehat{\nabla_{\theta} \eta\left(\pi_{\theta}\right)}=\frac{1}{N T} \sum_{i=1}^{N} \sum_{t=0}^{T} \nabla_{\theta} \log \pi\left(a_{t}^{i} \mid s_{t}^{i} ; \theta\right)\left(R_{t}^{i}-b_{t}^{i}\right)
$$</p>
<p>where $R_{t}^{i}=\sum_{t^{\prime}=t}^{T} \gamma^{t^{\prime}-t} r_{t^{\prime}}^{i}$ and $b_{t}^{i}$ is a baseline that only depends on the state $s_{t}^{i}$ to reduce variance. Hereafter, an as-</p>
<p>cent step is taken in the direction of the estimated gradient. This process continues until $\theta_{k}$ converges.</p>
<p>Truncated Natural Policy Gradient (TNPG) (Kakade, 2002; Peters et al., 2003; Bagnell \&amp; Schneider, 2003; Schulman et al., 2015a): Natural Policy Gradient improves upon REINFORCE by computing an ascent direction that approximately ensures a small change in the policy distribution. This direction is derived to be $I(\theta)^{-1} \nabla_{\theta} \eta\left(\pi_{\theta}\right)$, where $I(\theta)$ is the Fisher information matrix (FIM). We use the step size suggested by Peters \&amp; Schaal (2008): $\alpha=\sqrt{\delta_{\mathrm{KL}}\left(\nabla_{\theta} \eta\left(\pi_{\theta}\right)^{T} I(\theta)^{-1} \nabla_{\theta} \eta\left(\pi_{\theta}\right)\right)^{-1}}$. Finally, we replace $\nabla_{\theta} \eta\left(\pi_{\theta}\right)$ and $I(\theta)$ by their empirical estimates.</p>
<p>For neural network policies with tens of thousands of parameters or more, generic Natural Policy Gradient incurs prohibitive computation cost by forming and inverting the empirical FIM. Instead, we study Truncated Natural Policy Gradient (TNPG) in this paper, which computes the natural gradient direction without explicitly forming the matrix inverse, using a conjugate gradient algorithm that only requires computing $I(\theta) v$ for arbitrary vector $v$. TNPG makes it practical to apply natural gradient in policy search setting with high-dimensional parameters, and we refer the reader to Schulman et al. (2015a) for more details.</p>
<p>Reward-Weighted Regression (RWR) (Peters \&amp; Schaal, 2007; Kober \&amp; Peters, 2009): This algorithm formulates the policy optimization as an Expectation-Maximization problem to avoid the need to manually choose learning rate, and the method is guaranteed to converge to a locally optimal solution. At each iteration, this algorithm optimizes a lower bound of the log-expected return: $\theta=$ $\arg \max _{\theta^{\prime}} \mathcal{L}\left(\theta^{\prime}\right)$, where</p>
<p>$$
\mathcal{L}(\theta)=\frac{1}{N T} \sum_{i=1}^{N} \sum_{t=0}^{T} \log \pi\left(a_{t}^{i} \mid s_{t}^{i} ; \theta\right) \rho\left(R_{t}^{i}-b_{t}^{i}\right)
$$</p>
<p>Here, $\rho: \mathbb{R} \rightarrow \mathbb{R}<em _min="\min">{\geq 0}$ is a function that transforms raw returns to nonnegative values. Following Deisenroth et al. (2013), we choose $\rho$ to be $\rho(R)=R-R</em>$ is the minimum return among all trajectories collected in the current iteration.}$, where $R_{\min </p>
<p>Relative Entropy Policy Search (REPS) (Peters et al., 2010): This algorithm limits the loss of information per iteration and aims to ensure a smooth learning progress (Deisenroth et al., 2013). At each iteration, we collect all trajectories into a dataset $\mathcal{D}=\left{\left(s_{i}, a_{i}, r_{i}, s_{i}^{\prime}\right)\right}<em _eta_prime="\eta^{\prime">{i=1}^{M}$, where $M$ is the total number of samples. Then, we first solve for the dual parameters $\left[\eta^{<em>}, \nu^{</em>}\right]=\arg \min </em>\right)$ s.t. $\eta&gt;0$, where}, \nu^{\prime}} g\left(\eta^{\prime}, \nu^{\prime</p>
<p>$$
g(\eta, \nu)=\eta \delta_{\mathrm{KL}}+\eta \log \left(\frac{1}{M} \sum_{i=1}^{M} e^{\delta_{i}(\nu) / \eta}\right)
$$</p>
<p>Here $\delta_{\mathrm{KL}}&gt;0$ controls the step size of the policy, and $\delta_{i}(\nu)=r_{i}+\nu^{T}\left(\phi\left(s_{i}^{\prime}\right)-\phi\left(s_{i}\right)\right)$ is the sample Bellman error. We then solve for the new policy parameters:</p>
<p>$$
\theta_{k+1}=\underset{\theta}{\arg \max } \frac{1}{M} \sum_{i=1}^{M} e^{\delta_{i}\left(\nu^{<em>}\right) / \eta^{</em>}} \log \pi\left(a_{i} \mid s_{i} ; \theta\right)
$$</p>
<p>Trust Region Policy Optimization (TRPO) (Schulman et al., 2015a): This algorithm allows more precise control on the expected policy improvement than TNPG through the introduction of a surrogate loss. At each iteration, we solve the following constrained optimization problem (replacing expectations with samples):</p>
<p>$$
\begin{array}{ll}
\underset{\text { s.t. }}{\operatorname{maximize}<em _rho__theta__k="\rho_{\theta_{k" _sim="\sim" s="s">{\theta}} &amp; \mathbb{E}</em>(s, a)\right] \
&amp; E_{s \sim \rho_{\theta_{k}}}\left[D_{\mathrm{KL}}\left(\pi_{\theta_{k}}(\cdot \mid s) | \pi_{\theta}(\cdot \mid s)\right)\right] \leq \delta_{\mathrm{KL}}
\end{array}
$$}}, a \sim \pi_{\theta_{k}}}\left[\frac{\pi_{\theta}(a \mid s)}{\pi_{\theta_{k}}(a \mid s)} A_{\theta_{k}</p>
<p>where $\rho_{\theta}=\rho_{\pi_{\theta}}$ is the discounted state-visitation frequencies induced by $\pi_{\theta}, A_{\theta_{k}}(s, a)$, known as the advantage function, is estimated by the empirical return minus the baseline, and $\delta_{\mathrm{KL}}$ is a step size parameter which controls how much the policy is allowed to change per iteration. We follow the procedure described in the original paper for solving the optimization, which results in the same descent direction as TNPG with an extra line search in the objective and KL constraint.</p>
<p>Cross Entropy Method (CEM) (Rubinstein, 1999; Szita \&amp; Lőrincz, 2006): Unlike previously mentioned methods, which perform exploration through stochastic actions, CEM performs exploration directly in the policy parameter space. At each iteration, we produce $N$ perturbations of the policy parameter: $\theta_{i} \sim \mathcal{N}\left(\mu_{k}, \Sigma_{k}\right)$, and perform a rollout for each sampled parameter. Then, we compute the new mean and diagonal covariance using the parameters that correspond to the top $q$-quantile returns.</p>
<p>Covariance Matrix Adaption Evolution Strategy (CMA-ES) (Hansen \&amp; Ostermeier, 2001): Similar to CEM, CMA-ES is a gradient-free evolutionary approach for optimizing nonconvex objective functions. In our case, this objective function equals the average sampled return. In contrast to CEM, CMA-ES estimates the covariance matrix of a multivariate normal distribution through incremental adaption along evolution paths, which contain information about the correlation between consecutive updates.</p>
<h3>4.2. Online Algorithms</h3>
<p>Deep Deterministic Policy Gradient (DDPG) (Lillicrap et al., 2015): Compared to batch algorithms, the DDPG algorithm continuously improves the policy as it explores the environment. It applies gradient descent to the policy</p>
<p>with minibatch data sampled from a replay pool, where the gradient is computed via</p>
<p>$$
\widehat{\nabla_{\theta} \eta\left(\mu_{\theta}\right)}=\left.\sum_{i=1}^{B} \nabla_{a} Q_{\phi}\left(s_{i}, a\right)\right|<em _theta="\theta">{a=\mu</em>\right)
$$}\left(s_{i}\right)} \nabla_{\theta} \mu_{\theta}\left(s_{i</p>
<p>where $B$ is the batch size. The critic $Q$ is trained via gradient descent on the $\ell^{2}$ loss of the Bellman error $L=\frac{1}{B} \sum_{i=1}^{B}\left(y_{i}-Q_{\phi}\left(s_{i}, a_{i}\right)\right)^{2}$, where $y_{i}=r_{i}+$ $\gamma Q_{\phi^{\prime}}^{\prime}\left(s_{i}^{\prime}, \mu_{\theta^{\prime}}^{\prime}\left(s_{i}^{\prime}\right)\right)$. To improve stability of the algorithm, we use target networks for both the critic and the policy when forming the regression target $y_{i}$. We refer the reader to Lillicrap et al. (2015) for a more detailed description of the algorithm.</p>
<h3>4.3. Recurrent Variants</h3>
<p>We implement direct applications of the aforementioned batch-based algorithms to recurrent policies. The only modification required is to replace $\pi\left(a_{t}^{i} \mid s_{t}^{i}\right)$ by $\pi\left(a_{t}^{i} \mid o_{1: t}^{i}, a_{1: t-1}^{i}\right)$, where $o_{1: t}^{i}$ and $a_{1: t-1}$ are the histories of past and current observations and past actions. Recurrent versions of reinforcement learning algorithms have been studied in many existing works, such as Bakker (2001), Schäfer \&amp; Udluft (2005), Wierstra et al. (2007), and Heess et al. (2015a).</p>
<h2>5. Experiment Setup</h2>
<p>In this section, we elaborate on the experimental setup used to generate the results.</p>
<p>Performance Metrics: For each report unit (a particular algorithm running on a particular task), we define its performance as $\frac{1}{\sum_{t=1}^{I} N_{i}} \sum_{i=1}^{I} \sum_{n=1}^{N_{i}} R_{i n}$, where $I$ is the number of training iterations, $N_{i}$ is the number of trajectories collected in the $i$ th iteration, and $R_{i n}$ is the undiscounted return for the $n$th trajectory of the $i$ th iteration,</p>
<p>Hyperparameter Tuning: For the DDPG algorithm, we used the hyperparametes reported in Lillicrap et al. (2015). For the other algorithms, we follow the approach in (Mnih et al., 2015), and we select two tasks in each category, on which a grid search of hyperparameters is performed. Each choice of hyperparameters is executed under five random seeds. The criterion for the best hyperparameters is defined as mean(returns) - std(returns). This metric selects against large fluctuations of performance due to overly large step sizes.</p>
<p>For the other tasks, we try both of the best hyperparameters found in the same category, and report the better performance of the two. This gives us insights into both the maximum possible performance when extensive hyperparameter tuning is performed, and the robustness of the best hyperparameters across different tasks.</p>
<p>Policy Representation: For basic, locomotion, and hierarchical tasks and for batch algorithms, we use a feedforward neural network policy with 3 hidden layers, consisting of 100, 50, and 25 hidden units with tanh nonlinearity at the first two hidden layers, which map each state to the mean of a Gaussian distribution. The log-standard deviation is parameterized by a global vector independent of the state, as done in Schulman et al. (2015a). For all partially observable tasks, we use a recurrent neural network with a single hidden layer consisting of 32 LSTM hidden units (Hochreiter \&amp; Schmidhuber, 1997).</p>
<p>For the DDPG algorithm which trains a deterministic policy, we follow Lillicrap et al. (2015). For both the policy and the $Q$ function, we use the same architecture of a feedforward neural network with 2 hidden layers, consisting of 400 and 300 hidden units with relu activations.</p>
<p>Baseline: For all gradient-based algorithms except REPS, we can subtract a baseline from the empirical return to reduce variance of the optimization. We use a linear function as the baseline with a time-varying feature vector.</p>
<h2>6. Results and Discussion</h2>
<p>The main evaluation results are presented in Table 1. The tasks on which the grid search is performed are marked with (*). In each entry, the pair of numbers shows the mean and standard deviation of the normalized cumulative return using the best possible hyperparameters.</p>
<p>REINFORCE: Despite its simplicity, REINFORCE is an effective algorithm in optimizing deep neural network policies in most basic and locomotion tasks. Even for highDOF tasks like Ant, REINFORCE can achieve competitive results. However we observe that REINFORCE sometimes suffers from premature convergence to local optima as noted by Peters \&amp; Schaal (2008), which explains the performance gaps between REINFORCE and TNPG on tasks such as Walker (Figure 3(a)). By visualizing the final policies, we can see that REINFORCE results in policies that tend to jump forward and fall over to maximize short-term return instead of acquiring a stable walking gait to maximize long-term return. In Figure 3(b), we can observe that even with a small learning rate, steps taken by REINFORCE can sometimes result in large changes to policy distribution, which may explain the fast convergence to local optima.</p>
<p>TNPG and TRPO: Both TNPG and TRPO outperform other batch algorithms by a large margin on most tasks, confirming that constraining the change in the policy distribution results in more stable learning (Peters \&amp; Schaal, 2008).</p>
<p>Compared to TNPG, TRPO offers better control over each</p>
<p>Table 1. Performance of the implemented algorithms in terms of average return over all training iterations for five different random seeds (same across all algorithms). The results of the best-performing algorithm on each task, as well as all algorithms that have performances that are not statistically significantly different (Welch’s t-test with $p&lt;0.05$ ), are highlighted in boldface. ${ }^{a}$ In the tasks column, the partially observable variants of the tasks are annotated as follows: LS stands for limited sensors, NO for noisy observations and delayed actions, and SI for system identifications. The notation N/A denotes that an algorithm has failed on the task at hand, e.g., CMA-ES leading to out-of-memory errors in the Full Humanoid task.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Task</th>
<th style="text-align: center;">Random</th>
<th style="text-align: center;">REINFORCE</th>
<th style="text-align: center;">TNPG</th>
<th style="text-align: center;">RWR</th>
<th style="text-align: center;">REPS</th>
<th style="text-align: center;">TRPO</th>
<th style="text-align: center;">CEM</th>
<th style="text-align: center;">CMA-ES</th>
<th style="text-align: center;">DDPG</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Cart-Pole Balancing</td>
<td style="text-align: center;">$77.1 \pm 0.0$</td>
<td style="text-align: center;">$4693.7 \pm 14.0$</td>
<td style="text-align: center;">3986.4 $\pm$</td>
<td style="text-align: center;">748.9 4861.5 $\pm$</td>
<td style="text-align: center;">12.3</td>
<td style="text-align: center;">$565.6 \pm 137.6$</td>
<td style="text-align: center;">4869.8 $\pm$</td>
<td style="text-align: center;">37.6</td>
<td style="text-align: center;">$4815.4 \pm 4.8$</td>
</tr>
<tr>
<td style="text-align: center;">Inverted Pendulum ${ }^{a}$</td>
<td style="text-align: center;">$-153.4 \pm 0.2$</td>
<td style="text-align: center;">$13.4 \pm 18.0$</td>
<td style="text-align: center;">269.7 $\pm$</td>
<td style="text-align: center;">55.5 84.7 $\pm$</td>
<td style="text-align: center;">13.8</td>
<td style="text-align: center;">$-113.3 \pm 4.6$</td>
<td style="text-align: center;">247.2 $\pm$</td>
<td style="text-align: center;">76.1</td>
<td style="text-align: center;">$38.2 \pm 25.7$</td>
</tr>
<tr>
<td style="text-align: center;">Mountain Car</td>
<td style="text-align: center;">$-415.4 \pm 0.0$</td>
<td style="text-align: center;">$-67.1 \pm 1.0$</td>
<td style="text-align: center;">$-46.5 \pm 4.5$</td>
<td style="text-align: center;">$-79.4 \pm 1.1$</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">$-275.6 \pm 166.3$</td>
<td style="text-align: center;">$-61.7 \pm$</td>
<td style="text-align: center;">0.9</td>
<td style="text-align: center;">$-66.0 \pm 2.4$</td>
</tr>
<tr>
<td style="text-align: center;">Acrobot</td>
<td style="text-align: center;">$-1904.5 \pm 1.0$</td>
<td style="text-align: center;">$-508.1 \pm 91.0$</td>
<td style="text-align: center;">$-395.8 \pm 121.2$</td>
<td style="text-align: center;">$-352.7 \pm 35.9$</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">$-1001.5 \pm 10.8$</td>
<td style="text-align: center;">$-326.0 \pm$</td>
<td style="text-align: center;">24.4</td>
<td style="text-align: center;">$-436.8 \pm 14.7$</td>
</tr>
<tr>
<td style="text-align: center;">Double Inverted Pendulum ${ }^{a}$</td>
<td style="text-align: center;">$149.7 \pm 0.1$</td>
<td style="text-align: center;">$4116.5 \pm 65.2$</td>
<td style="text-align: center;">4455.4 $\pm$</td>
<td style="text-align: center;">37.6 3614.8 $\pm$</td>
<td style="text-align: center;">368.1</td>
<td style="text-align: center;">$446.7 \pm 114.8$</td>
<td style="text-align: center;">4412.4 $\pm$</td>
<td style="text-align: center;">50.4</td>
<td style="text-align: center;">$2566.2 \pm 178.9$</td>
</tr>
<tr>
<td style="text-align: center;">Swimmer*</td>
<td style="text-align: center;">$-1.7 \pm 0.1$</td>
<td style="text-align: center;">$92.3 \pm 0.1$</td>
<td style="text-align: center;">96.0 $\pm$</td>
<td style="text-align: center;">0.2 60.7 $\pm$</td>
<td style="text-align: center;">5.5</td>
<td style="text-align: center;">$3.8 \pm 3.3$</td>
<td style="text-align: center;">96.0 $\pm$</td>
<td style="text-align: center;">0.2</td>
<td style="text-align: center;">$68.8 \pm 2.4$</td>
</tr>
<tr>
<td style="text-align: center;">Hopper</td>
<td style="text-align: center;">$8.4 \pm 0.0$</td>
<td style="text-align: center;">$714.0 \pm 29.3$</td>
<td style="text-align: center;">1155.1 $\pm$</td>
<td style="text-align: center;">57.9 553.2 $\pm$</td>
<td style="text-align: center;">71.0</td>
<td style="text-align: center;">$86.7 \pm 17.6$</td>
<td style="text-align: center;">1183.3 $\pm$</td>
<td style="text-align: center;">150.0</td>
<td style="text-align: center;">$63.1 \pm 7.8$</td>
</tr>
<tr>
<td style="text-align: center;">2D Walker</td>
<td style="text-align: center;">$-1.7 \pm 0.0$</td>
<td style="text-align: center;">$506.5 \pm 78.8$</td>
<td style="text-align: center;">1382.6 $\pm$</td>
<td style="text-align: center;">108.2 136.0 $\pm$</td>
<td style="text-align: center;">15.9</td>
<td style="text-align: center;">$-37.0 \pm 38.1$</td>
<td style="text-align: center;">1353.8 $\pm$</td>
<td style="text-align: center;">85.0</td>
<td style="text-align: center;">$84.5 \pm 19.2$</td>
</tr>
<tr>
<td style="text-align: center;">Half-Cheetah</td>
<td style="text-align: center;">$-90.8 \pm 0.3$</td>
<td style="text-align: center;">$1183.1 \pm 69.2$</td>
<td style="text-align: center;">1729.5 $\pm$</td>
<td style="text-align: center;">184.6 1376.1 $\pm$</td>
<td style="text-align: center;">376.1 $\pm$</td>
<td style="text-align: center;">28.2 34.5 $\pm$</td>
<td style="text-align: center;">38.0 1914.0 $\pm$</td>
<td style="text-align: center;">120.1</td>
<td style="text-align: center;">$330.4 \pm 274.8$</td>
</tr>
<tr>
<td style="text-align: center;">Ant*</td>
<td style="text-align: center;">$13.4 \pm 0.7$</td>
<td style="text-align: center;">$548.3 \pm 55.5$</td>
<td style="text-align: center;">706.0 $\pm$</td>
<td style="text-align: center;">127.7 37.6 $\pm$</td>
<td style="text-align: center;">3.1</td>
<td style="text-align: center;">$39.0 \pm 9.8$</td>
<td style="text-align: center;">730.2 $\pm$</td>
<td style="text-align: center;">61.3</td>
<td style="text-align: center;">$49.2 \pm 5.9$</td>
</tr>
<tr>
<td style="text-align: center;">Simple Humanoid</td>
<td style="text-align: center;">$41.5 \pm 0.2$</td>
<td style="text-align: center;">$128.1 \pm 34.0$</td>
<td style="text-align: center;">255.0 $\pm$</td>
<td style="text-align: center;">24.5 93.3 $\pm$</td>
<td style="text-align: center;">17.4</td>
<td style="text-align: center;">$28.3 \pm 4.7$</td>
<td style="text-align: center;">269.7 $\pm$</td>
<td style="text-align: center;">40.3</td>
<td style="text-align: center;">$60.6 \pm 12.9$</td>
</tr>
<tr>
<td style="text-align: center;">Full Humanoid</td>
<td style="text-align: center;">$13.2 \pm 0.1$</td>
<td style="text-align: center;">$262.2 \pm 10.5$</td>
<td style="text-align: center;">208.4 $\pm$</td>
<td style="text-align: center;">25.2 46.7 $\pm$</td>
<td style="text-align: center;">5.6</td>
<td style="text-align: center;">$41.7 \pm 6.1$</td>
<td style="text-align: center;">287.0 $\pm$</td>
<td style="text-align: center;">23.4</td>
<td style="text-align: center;">$36.9 \pm 2.9$</td>
</tr>
<tr>
<td style="text-align: center;">Cart-Pole Balancing (LS)*</td>
<td style="text-align: center;">$77.1 \pm 0.0$</td>
<td style="text-align: center;">$420.9 \pm 265.5$</td>
<td style="text-align: center;">945.1 $\pm$</td>
<td style="text-align: center;">27.8 68.9 $\pm$</td>
<td style="text-align: center;">1.5</td>
<td style="text-align: center;">$898.1 \pm 22.1$</td>
<td style="text-align: center;">960.2 $\pm$</td>
<td style="text-align: center;">46.0</td>
<td style="text-align: center;">$227.0 \pm 223.0$</td>
</tr>
<tr>
<td style="text-align: center;">Inverted Pendulum (LS)</td>
<td style="text-align: center;">$-122.1 \pm 0.1$</td>
<td style="text-align: center;">$-13.4 \pm 3.2$</td>
<td style="text-align: center;">0.7 $\pm$</td>
<td style="text-align: center;">6.1 $-107.4 \pm$</td>
<td style="text-align: center;">0.2</td>
<td style="text-align: center;">$-87.2 \pm 8.0$</td>
<td style="text-align: center;">4.5 $\pm$</td>
<td style="text-align: center;">4.1</td>
<td style="text-align: center;">$-81.2 \pm 33.2$</td>
</tr>
<tr>
<td style="text-align: center;">Mountain Car (LS)</td>
<td style="text-align: center;">$-83.0 \pm 0.0$</td>
<td style="text-align: center;">$-81.2 \pm 0.6$</td>
<td style="text-align: center;">$-45.7 \pm 9.0$</td>
<td style="text-align: center;">$-81.7 \pm 0.1$</td>
<td style="text-align: center;">$-82.6 \pm 0.4$</td>
<td style="text-align: center;">$-44.2 \pm$</td>
<td style="text-align: center;">9.5 9.5</td>
<td style="text-align: center;">$-46.9 \pm 1.3$</td>
<td style="text-align: center;">$-73.2 \pm 0.6$</td>
</tr>
<tr>
<td style="text-align: center;">Acrobot (LS)*</td>
<td style="text-align: center;">$-393.2 \pm 0.0$</td>
<td style="text-align: center;">$-128.9 \pm 11.6$</td>
<td style="text-align: center;">$-84.6 \pm 2.9$</td>
<td style="text-align: center;">$-235.9 \pm 5.3$</td>
<td style="text-align: center;">$-379.5 \pm 1.4$</td>
<td style="text-align: center;">$-83.3 \pm$</td>
<td style="text-align: center;">9.9</td>
<td style="text-align: center;">$-149.5 \pm 15.3$</td>
<td style="text-align: center;">$-159.9 \pm$</td>
</tr>
<tr>
<td style="text-align: center;">Cart-Pole Balancing (NO)*</td>
<td style="text-align: center;">$101.4 \pm 0.1$</td>
<td style="text-align: center;">$616.0 \pm 210.8$</td>
<td style="text-align: center;">916.3 $\pm$</td>
<td style="text-align: center;">23.0 93.8 $\pm$</td>
<td style="text-align: center;">1.2</td>
<td style="text-align: center;">$99.6 \pm 7.2$</td>
<td style="text-align: center;">$606.2 \pm 122.2$</td>
<td style="text-align: center;">181.4 $\pm$</td>
<td style="text-align: center;">32.1 104.4 $\pm$</td>
</tr>
<tr>
<td style="text-align: center;">Inverted Pendulum (NO)</td>
<td style="text-align: center;">$-122.2 \pm 0.1$</td>
<td style="text-align: center;">$6.5 \pm 1.1$</td>
<td style="text-align: center;">11.5 $\pm$</td>
<td style="text-align: center;">0.5 $-110.0 \pm$</td>
<td style="text-align: center;">1.4</td>
<td style="text-align: center;">$-119.3 \pm 4.2$</td>
<td style="text-align: center;">10.4 $\pm$</td>
<td style="text-align: center;">2.2</td>
<td style="text-align: center;">$-55.6 \pm 16.7$</td>
</tr>
<tr>
<td style="text-align: center;">Mountain Car (NO)</td>
<td style="text-align: center;">$-83.0 \pm 0.0$</td>
<td style="text-align: center;">$-74.7 \pm 7.8$</td>
<td style="text-align: center;">$-44.5 \pm 8.6$</td>
<td style="text-align: center;">$-81.7 \pm 0.1$</td>
<td style="text-align: center;">$-82.9 \pm 0.1$</td>
<td style="text-align: center;">$-40.2 \pm$</td>
<td style="text-align: center;">2.0 2.0</td>
<td style="text-align: center;">$-67.4 \pm 1.4$</td>
<td style="text-align: center;">$-73.5 \pm 0.5$</td>
</tr>
<tr>
<td style="text-align: center;">Acrobot (NO)*</td>
<td style="text-align: center;">$-393.5 \pm 0.0$</td>
<td style="text-align: center;">$-186.7 \pm 31.3$</td>
<td style="text-align: center;">$-164.5 \pm 13.4$</td>
<td style="text-align: center;">$-233.1 \pm 0.4$</td>
<td style="text-align: center;">$-258.5 \pm 14.0$</td>
<td style="text-align: center;">$-149.6 \pm$</td>
<td style="text-align: center;">8.6</td>
<td style="text-align: center;">$-213.4 \pm 6.3$</td>
<td style="text-align: center;">$-236.6 \pm 6.2$</td>
</tr>
<tr>
<td style="text-align: center;">Cart-Pole Balancing (SI)*</td>
<td style="text-align: center;">$76.3 \pm 0.1$</td>
<td style="text-align: center;">$431.7 \pm 274.1$</td>
<td style="text-align: center;">980.5 $\pm$</td>
<td style="text-align: center;">7.3 69.0 $\pm$</td>
<td style="text-align: center;">2.8</td>
<td style="text-align: center;">$702.4 \pm 196.4$</td>
<td style="text-align: center;">980.3 $\pm$</td>
<td style="text-align: center;">5.1</td>
<td style="text-align: center;">$746.6 \pm 93.2$</td>
</tr>
<tr>
<td style="text-align: center;">Inverted Pendulum (SI)</td>
<td style="text-align: center;">$-121.8 \pm 0.2$</td>
<td style="text-align: center;">$-5.3 \pm 5.6$</td>
<td style="text-align: center;">14.8 $\pm$</td>
<td style="text-align: center;">1.7 $-108.7 \pm$</td>
<td style="text-align: center;">4.7</td>
<td style="text-align: center;">$-92.8 \pm 23.9$</td>
<td style="text-align: center;">14.1 $\pm$</td>
<td style="text-align: center;">0.9</td>
<td style="text-align: center;">$-51.8 \pm 10.6$</td>
</tr>
<tr>
<td style="text-align: center;">Mountain Car (SI)</td>
<td style="text-align: center;">$-82.7 \pm 0.0$</td>
<td style="text-align: center;">$-63.9 \pm 0.2$</td>
<td style="text-align: center;">$-61.8 \pm 0.4$</td>
<td style="text-align: center;">$-81.4 \pm 0.1$</td>
<td style="text-align: center;">$-80.7 \pm 2.3$</td>
<td style="text-align: center;">$-61.6 \pm$</td>
<td style="text-align: center;">0.4</td>
<td style="text-align: center;">$-63.9 \pm 1.0$</td>
<td style="text-align: center;">$-66.9 \pm 0.6$</td>
</tr>
<tr>
<td style="text-align: center;">Acrobot (SI)*</td>
<td style="text-align: center;">$-387.8 \pm 1.0$</td>
<td style="text-align: center;">$-169.1 \pm 32.3$</td>
<td style="text-align: center;">$-156.6 \pm 38.9$</td>
<td style="text-align: center;">$-233.2 \pm 2.6$</td>
<td style="text-align: center;">$-216.1 \pm 7.7$</td>
<td style="text-align: center;">$-170.9 \pm$</td>
<td style="text-align: center;">40.3</td>
<td style="text-align: center;">$-250.2 \pm 13.7$</td>
<td style="text-align: center;">$-245.0 \pm 5.5$</td>
</tr>
<tr>
<td style="text-align: center;">Swimmer + Gathering</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
</tr>
<tr>
<td style="text-align: center;">Ant + Gathering</td>
<td style="text-align: center;">$-5.8 \pm 5.0$</td>
<td style="text-align: center;">$-0.1 \pm 0.1$</td>
<td style="text-align: center;">$-0.4 \pm 0.1$</td>
<td style="text-align: center;">$-5.5 \pm 0.5$</td>
<td style="text-align: center;">$-6.7 \pm 0.7$</td>
<td style="text-align: center;">$-0.4 \pm 0.0$</td>
<td style="text-align: center;">$-4.7 \pm 0.7$</td>
<td style="text-align: center;">N/A $\pm$ N/A</td>
<td style="text-align: center;">$-0.3 \pm 0.3$</td>
</tr>
<tr>
<td style="text-align: center;">Swimmer + Maze</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
</tr>
<tr>
<td style="text-align: center;">Ant + Maze</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
<td style="text-align: center;">N/A $\pm$ N/A</td>
<td style="text-align: center;">$0.0 \pm 0.0$</td>
</tr>
</tbody>
</table>
<p>${ }^{a}$ Except for the hierarchical tasks</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3. Performance as a function of the number of iterations; the shaded area depicts the mean ± the standard deviation over five different random seeds: (a) Performance comparison of all algorithms in terms of the average reward on the Walker task; (b) Comparison between REINFORCE, TNPG, and TRPO in terms of the mean KL-divergence on the Walker task; (c) Performance comparison on TNPG and TRPO on the Swimmer task; (d) Performance comparison of all algorithms in terms of the average reward on the Half-Cheetah task.</p>
<p>policy update by performing a line search in the natural gradient direction to ensure an improvement in the surrogate loss function. We observe that hyperparameter grid search tends to select conservative step sizes (δ_KL) for TNPG, which alleviates the issue of performance collapse caused by a large update to the policy. By contrast, TRPO can robustly enforce constraints with larger δ_KL value and hence speeds up learning in some cases. For instance, grid search on the Swimmer task reveals that the best step size for TNPG is δ_KL = 0.05, whereas TRPO's best step-size is larger: δ_KL = 0.1. As shown in Figure 3(c), this larger step size enables slightly faster learning.</p>
<p><strong>RWR:</strong> RWR is the only gradient-based algorithm we implemented that does not require any hyperparameter tuning. It can solve some basic tasks to a satisfactory degree, but fails to solve more challenging tasks such as locomotion. We observe empirically that RWR shows fast initial improvement followed by significant slow-down, as shown in Figure 3(d).</p>
<p><strong>REPS:</strong> Our main observation is that REPS is especially prone to early convergence to local optima in case of continuous states and actions. Its final outcome is greatly affected by the performance of the initial policy, an observation that is consistent with the original work of Peters et al. (2010). This leads to a bad performance on average, although under particular initial settings the algorithm can perform on par with others. Moreover, the tasks presented here do not assume the existence of a stationary distribution, which is assumed in Peters et al. (2010). In particular, for many of our tasks, transient behavior is of much greater interest than steady-state behavior, which agrees with previous observation by van Hoof et al. (2015).</p>
<p><strong>Gradient-free methods:</strong> Surprisingly, even when training deep neural network policies with thousands of parameters, CEM achieves very good performance on certain basic tasks such as Cart-Pole Balancing and Mountain Car, suggesting that the dimension of the searching parameter is not always the limiting factor of the method. However, the performance degrades quickly as the system dynamics becomes more complicated. We also observe that CEM outperforms CMA-ES, which is remarkable as CMA-ES estimates the full covariance matrix. For higher-dimensional policy parameterizations, the computational complexity and memory requirement for CMA-ES become noticeable. On tasks with high-dimensional observations, such as the Full Humanoid, the CMA-ES algorithm runs out of memory and fails to yield any results, denoted as N/A in Table 1.</p>
<p><strong>DDPG:</strong> Compared to batch algorithms, we found that DDPG was able to converge significantly faster on certain tasks like Half-Cheetah due to its greater sample efficiency. However, it was less stable than batch algorithms, and the performance of the policy can degrade significantly during training. We also found it to be more susceptible to scaling of the reward. In our experiment for DDPG, we rescaled the reward of all tasks by a factor of 0.1, which seems to improve the stability.</p>
<p><strong>Partially Observable Tasks:</strong> We experimentally verify that recurrent policies can find better solutions than feedforward policies in Partially Observable Tasks but recurrent policies are also more difficult to train. As shown in Table 1, derivative-free algorithms like CEM and CMA-ES work considerably worse with recurrent policies. Also we note that the performance gap between REINFORCE and TNPG widens when they are applied to optimize recurrent policies, which can be explained by the fact that a small change in parameter space can result in a bigger change in policy distribution with recurrent policies than with feedforward policies.</p>
<p><strong>Hierarchical Tasks:</strong> We observe that all of our implementation</p>
<p>mented algorithms achieve poor performance on the hierarchical tasks, even with extensive hyperparameter search and 500 iterations of training. It is an interesting direction to develop algorithms that can automatically discover and exploit the hierarchical structure in these tasks.</p>
<h2>7. Related Work</h2>
<p>In this section, we review existing benchmarks of continuous control tasks. The earliest efforts of evaluating reinforcement learning algorithms started in the form of individual control problems described in symbolic form. Some widely adopted tasks include the inverted pendulum (Stephenson, 1908; Donaldson, 1960; Widrow, 1964), mountain car (Moore, 1990), and Acrobot (DeJong \&amp; Spong, 1994). These problems are frequently incorporated into more comprehensive benchmarks.</p>
<p>Some reinforcement learning benchmarks contain lowdimensional continuous control tasks, such as the ones introduced above, including RLLib (Abeyruwan, 2013), MMLF (Metzen \&amp; Edgington, 2011), RL-Toolbox (Neumann, 2006), JRLF (Kochenderfer, 2006), Beliefbox (Dimitrakakis et al., 2007), Policy Gradient Toolbox (Peters, 2002), and ApproxRL (Busoniu, 2010). A series of RL competitions has also been held in recent years (Dutech et al., 2005; Dimitrakakis et al., 2014), again with relatively low-dimensional actions. In contrast, our benchmark contains a wider range of tasks with high-dimensional continuous state and action spaces.</p>
<p>Previously, other benchmarks have been proposed for highdimensional control tasks. Tdlearn (Dann et al., 2014) includes a 20 -link pole balancing task, DotRL (Papis \&amp; Wawrzyński, 2013) includes a variable-DOF octopus arm and a 6-DOF planar cheetah model, PyBrain (Schaul et al., 2010) includes a 16-DOF humanoid robot with standing and jumping tasks, RoboCup Keepaway (Stone et al., 2005) is a multi-agent game which can have a flexible dimension of actions by varying the number of agents, and SkyAI (Yamaguchi \&amp; Ogasawara, 2010) includes a 17-DOF humanoid robot with crawling and turning tasks. Other libraries such as CL-Square (Riedmiller et al., 2012) and RLPark (Degris et al., 2013) provide interfaces to actual hardware, e.g., Bioloid and iRobot Create. In contrast to these aforementioned testbeds, our benchmark makes use of simulated environments to reduce computation time and to encourage experimental reproducibility. Furthermore, it provides a much larger collection of tasks of varying difficulty.</p>
<h2>8. Conclusion</h2>
<p>In this work, a benchmark of continuous control problems for reinforcement learning is presented, covering a wide
variety of challenging tasks. We implemented several reinforcement learning algorithms, and presented them in the context of general policy parameterizations. Results show that among the implemented algorithms, TNPG, TRPO, and DDPG are effective methods for training deep neural network policies. Still, the poor performance on the proposed hierarchical tasks calls for new algorithms to be developed. Implementing and evaluating existing and newly proposed algorithms will be our continued effort. By providing an open-source release of the benchmark, we encourage other researchers to evaluate their algorithms on the proposed tasks.</p>
<h2>Acknowledgements</h2>
<p>We thank Emo Todorov and Yuval Tassa for providing the MuJoCo simulator, and Sergey Levine, Aviv Tamar, Chelsea Finn, and the anonymous ICML reviewers for insightful comments. We also thank Shixiang Gu and Timothy Lillicrap for helping us diagnose the DDPG implementation. This work was supported in part by DARPA, the Berkeley Vision and Learning Center (BVLC), the Berkeley Artificial Intelligence Research (BAIR) laboratory, and Berkeley Deep Drive (BDD). Rein Houthooft is supported by a Ph.D. Fellowship of the Research Foundation - Flanders (FWO).</p>
<h2>References</h2>
<p>Abeyruwan, S. RLLib: Lightweight standard and on/off policy reinforcement learning library (C++). http://web.cs.miami. edu/home/saminda/rilib.html, 2013.
Bagnell, J. A. and Schneider, J. Covariant policy search. pp. 1019-1024. IJCAI, 2003.
Bakker, B. Reinforcement learning with long short-term memory. In NIPS, pp. 1475-1482, 2001.
Bellemare, M. G., Naddaf, Y., Veness, J., and Bowling, M. The Arcade Learning Environment: An evaluation platform for general agents. J. Artif. Intell. Res., 47:253-279, 2013.
Bellman, R. Dynamic Programming. Princeton University Press, 1957.</p>
<p>Bertsekas, Dimitri P and Tsitsiklis, John N. Neuro-dynamic programming: an overview. In $C D C$, pp. 560-564, 1995.
Busoniu, L. ApproxRL: A Matlab toolbox for approximate RL and DP. http://busoniu.net/files/repository/ readme-approxrl.html, 2010.
Catto, E. Box2D: A 2D physics engine for games, 2011.
Coulom, Rémi. Reinforcement learning using neural networks, with applications to motor control. PhD thesis, Institut National Polytechnique de Grenoble-INPG, 2002.
Dann, C., Neumann, G., and Peters, J. Policy evaluation with temporal differences: A survey and comparison. J. Mach. Learn. Res., 15(1):809-883, 2014.
Degris, T., Béchu, J., White, A., Modayil, J., Pilarski, P. M., and Denk, C. RLPark. http://rlpark.github.io, 2013.</p>
<p>Deisenroth, M. P., Neumann, G., and Peters, J. A survey on policy search for robotics, foundations and trends in robotics. Found. Trends Robotics, 2(1-2):1-142, 2013.
DeJong, G. and Spong, M. W. Swinging up the Acrobot: An example of intelligent control. In ACC, pp. 2158-2162, 1994.
Deng, J., Dong, W., Socher, R., Li, L.-J., Li, K., and Fei-Fei, L. ImageNet: A large-scale hierarchical image database. In CVPR, pp. 248-255, 2009.
Dietterich, T. G. Hierarchical reinforcement learning with the MAXQ value function decomposition. J. Artif. Intell. Res, 13: 227-303, 2000.
Dimitrakakis, C., Tziortziotis, N., and Tossou, A. Beliefbox: A framework for statistical methods in sequential decision making. http://code.google.com/p/beliefbox/, 2007.
Dimitrakakis, Christos, Li, Guangliang, and Tziortziotis, Nikoalos. The reinforcement learning competition 2014. AI Magazine, 35(3):61-65, 2014.
Donaldson, P. E. K. Error decorrelation: a technique for matching a class of functions. In Proc. 3th Intl. Conf. Medical Electronics, pp. 173-178, 1960.
Doya, K. Reinforcement learning in continuous time and space. Neural Comput., 12(1):219-245, 2000.
Dutech, Alain, Edmunds, Timothy, Kok, Jelle, Lagoudakis, Michail, Littman, Michael, Riedmiller, Martin, Russell, Bryan, Scherrer, Bruno, Sutton, Richard, Timmer, Stephan, et al. Reinforcement learning benchmarks and bake-offs ii. Advances in Neural Information Processing Systems (NIPS), 17, 2005.
Erez, Tom, Tassa, Yuval, and Todorov, Emanuel. Infinite horizon model predictive control for nonlinear periodic tasks. Manuscript under review, 4, 2011.
Everingham, M., Van Gool, L., Williams, C. K. I., Winn, J., and Zisserman, A. The pascal visual object classes (VOC) challenge. Int. J. Comput. Vision, 88(2):303-338, 2010.
Fei-Fei, L., Fergus, R., and Perona, P. One-shot learning of object categories. IEEE Trans. Pattern Anal. Mach. Intell., 28(4):594611, 2006.
Furuta, K., Okutani, T., and Sone, H. Computer control of a double inverted pendulum. Comput. Electr. Eng., 5(1):67-84, 1978.</p>
<p>Garofolo, J. S., Lamel, L. F., Fisher, W. M., Fiscus, J. G., and Pallett, D. S. DARPA TIMIT acoustic-phonetic continuous speech corpus CD-ROM. NIST speech disc 1-1.1. NASA STI/Recon Technical Report N, 93, 1993.
Godfrey, J. J., Holliman, E. C., and McDaniel, J. SWITCHBOARD: Telephone speech corpus for research and development. In ICASSP, pp. 517-520, 1992.
Gomez, F. and Miikkulainen, R. 2-d pole balancing with recurrent evolutionary networks. In ICANN, pp. 425-430. 1998.
Guo, X., Singh, S., Lee, H., Lewis, R. L., and Wang, X. Deep learning for real-time Atari game play using offline montecarlo tree search planning. In NIPS, pp. 3338-3346. 2014.
Hansen, N. and Ostermeier, A. Completely derandomized selfadaptation in evolution strategies. Evol. Comput., 9(2):159195, 2001.
Heess, N., Hunt, J., Lillicrap, T., and Silver, D. Memory-based control with recurrent neural networks. arXiv:1512.04455, 2015a.</p>
<p>Heess, N., Wayne, G., Silver, D., Lillicrap, T., Erez, T., and Tassa, T. Learning continuous control policies by stochastic value gradients. In NIPS, pp. 2926-2934. 2015b.
Hester, T. and Stone, P. The open-source TEXPLORE code release for reinforcement learning on robots. In RoboCup 2013: Robot World Cup XVII, pp. 536-543. 2013.
Hinton, G., Deng, L., Yu, D., Mohamed, A.-R., Jaitly, N., Senior, A., Vanhoucke, V., Nguyen, P., Dahl, T. S. G., and Kingsbury, B. Deep neural networks for acoustic modeling in speech recognition. IEEE Signal Process. Mag, 29(6):82-97, 2012.
Hirsch, H.-G. and Pearce, D. The Aurora experimental framework for the performance evaluation of speech recognition systems under noisy conditions. In ASR2000-Automatic Speech Recognition: Challenges for the new Millenium ISCA Tutorial and Research Workshop (ITRW), 2000.
Hochreiter, S. and Schmidhuber, J. Long short-term memory. Neural Comput., 9(8):1735-1780, 1997.
Kakade, S. M. A natural policy gradient. In NIPS, pp. 1531-1538. 2002.</p>
<p>Kimura, H. and Kobayashi, S. Stochastic real-valued reinforcement learning to solve a nonlinear control problem. In IEEE SMC, pp. 510-515, 1999.
Kober, J. and Peters, J. Policy search for motor primitives in robotics. In NIPS, pp. 849-856, 2009.
Kochenderfer, M. JRLF: Java reinforcement learning framework. http://mykel.kochenderfer.com/jrlf, 2006.
Krizhevsky, A. and Hinton, G. Learning multiple layers of features from tiny images. Technical report, 2009.
Krizhevsky, A., Sutskever, I., and Hinton, G. ImageNet classification with deep convolutional neural networks. In NIPS, pp. 1097-1105. 2012.
LeCun, Y., Cortes, C., and Burges, C. The MNIST database of handwritten digits, 1998.
Levine, S. and Koltun, V. Guided policy search. In ICML, pp. $1-9,2013$.
Levine, S., Finn, C., Darrell, T., and Abbeel, P. End-to-end training of deep visuomotor policies. arXiv:1504.00702, 2015.
Lillicrap, T., Hunt, J., Pritzel, A., Heess, N., Erez, T., Tassa, Y., Silver, D., and Wierstra, D. Continuous control with deep reinforcement learning. arXiv:1509.02971, 2015.
Martin, D., C. Fowlkes, D. Tal, and Malik, J. A database of human segmented natural images and its application to evaluating segmentation algorithms and measuring ecological statistics. In ICCV, pp. 416-423, 2001.
Metzen, J. M. and Edgington, M. Maja machine learning framework. http://mloss.org/software/view/220/, 2011.
Michie, D. and Chambers, R. A. BOXES: An experiment in adaptive control. Machine Intelligence, 2:137-152, 1968.
Mnih, V., Kavukcuoglu, K., Silver, D., Rusu, A. A., Veness, J., Bellemare, M. G., Graves, A., Riedmiller, M., Fidjeland, A. K., Ostrovski, G., Petersen, S., Beattie, C., Sadik, A., Antonoglou, I., King, H., Kumaran, D., Wierstra, D., Legg, S., and Hassabis, D. Human-level control through deep reinforcement learning. Nature, 518(7540):529-533, 2015.
Moore, A. Efficient memory-based learning for robot control. Technical report, University of Cambridge, Computer Laboratory, 1990.</p>
<p>Murray, R. M. and Hauser, J. A case study in approximate linearization: The Acrobot example. Technical report, UC Berkeley, EECS Department, 1991.
Murthy, S. S. and Raibert, M. H. 3D balance in legged locomotion: modeling and simulation for the one-legged case. ACM SIGGRAPH Computer Graphics, 18(1):27-27, 1984.
Neumann, G. A reinforcement learning toolbox and RL benchmarks for the control of dynamical systems. Dynamical principles for neuroscience and intelligent biomimetic devices, pp. $113,2006$.
Papis, B. and Wawrzyński, P. dotrl: A platform for rapid reinforcement learning methods development and validation. In FedCSIS, pp. pages 129-136., 2013.
Parr, Ronald and Russell, Stuart. Reinforcement learning with hierarchies of machines. Advances in neural information processing systems, pp. 1043-1049, 1998.
Peters, J. Policy Gradient Toolbox. http://www.ausy. tu-darmstadt.de/Research/PolicyGradientToolbox, 2002.
Peters, J. and Schaal, S. Reinforcement learning by rewardweighted regression for operational space control. In ICML, pp. 745-750, 2007.
Peters, J. and Schaal, S. Reinforcement learning of motor skills with policy gradients. Neural networks, 21(4):682-697, 2008.
Peters, J., Vijaykumar, S., and Schaal, S. Policy gradient methods for robot control. Technical report, 2003.
Peters, J., Mülling, K., and Altün, Y. Relative entropy policy search. In AAAI, pp. 1607-1612, 2010.
Purcell, E. M. Life at low Reynolds number. Am. J. Phys, 45(1): $3-11,1977$.
Raibert, M. H. and Hodgins, J. K. Animation of dynamic legged locomotion. In ACM SIGGRAPH Computer Graphics, volume 25, pp. 349-358, 1991.
Riedmiller, M., Blum, M., and Lampe, T. CLS2: Closed loop simulation system. http://ml.informatik.uni-freiburg.de/ research/clsquare, 2012.
Rubinstein, R. The cross-entropy method for combinatorial and continuous optimization. Methodol. Comput. Appl. Probab., 1 (2):127-190, 1999.</p>
<p>Schäfer, A. M. and Udluft, S. Solving partially observable reinforcement learning problems with recurrent neural networks. In ECML Workshops, pp. 71-81, 2005.
Schaul, T., Bayer, J., Wierstra, D., Sun, Y., Felder, M., Sehnke, F., Rückstieß, T., and Schmidhuber, J. PyBrain. J. Mach. Learn. Res., 11:743-746, 2010.
Schulman, J., Levine, S., Abbeel, P., Jordan, M. I., and Moritz, P. Trust region policy optimization. In ICML, pp. 1889-1897, 2015a.
Schulman, J., Moritz, P., Levine, S., Jordan, M. I., and Abbeel, P. High-dimensional continuous control using generalized advantage estimation. arXiv:1506.02438, 2015b.
Stephenson, A. On induced stability. Philos. Mag., 15(86):233236, 1908.
Stone, Peter, Kuhlmann, Gregory, Taylor, Matthew E, and Liu, Yaxin. Keepaway soccer: From machine learning testbed to benchmark. In RoboCup 2005: Robot Soccer World Cup IX, pp. 93-105. Springer, 2005.
Sutton, Richard S, Precup, Doina, and Singh, Satinder. Between
mdps and semi-mdps: A framework for temporal abstraction in reinforcement learning. Artificial intelligence, 112(1):181211, 1999.
Szita, I. and Lőrincz, A. Learning Tetris using the noisy crossentropy method. Neural Comput., 18(12):2936-2941, 2006.
Szita, I., Takács, B., and Lörincz, A. $\varepsilon$-MDPs: Learning in varying environments. J. Mach. Learn. Res., 3:145-174, 2003.
Tassa, Yuval, Erez, Tom, and Todorov, Emanuel. Synthesis and stabilization of complex behaviors through online trajectory optimization. In Intelligent Robots and Systems (IROS), 2012 IEEE/RSJ International Conference on, pp. 4906-4913. IEEE, 2012.</p>
<p>Tesauro, G. Temporal difference learning and TD-Gammon. Commun. ACM, 38(3):58-68, 1995.
Todorov, E., Erez, T., and Tassa, Y. MuJoCo: A physics engine for model-based control. In IROS, pp. 5026-5033, 2012.
van Hoof, H., Peters, J., and Neumann, G. Learning of nonparametric control policies with high-dimensional state features. In AISTATS, pp. 995-1003, 2015.
Watter, M., Springenberg, J., Boedecker, J., and Riedmiller, M. Embed to control: A locally linear latent dynamics model for control from raw images. In NIPS, pp. 2728-2736, 2015.
Wawrzyński, P. Learning to control a 6-degree-of-freedom walking robot. In IEEE EUROCON, pp. 698-705, 2007.
Widrow, B. Pattern recognition and adaptive control. IEEE Trans. Ind. Appl., 83(74):269-277, 1964.
Wierstra, D., Foerster, A., Peters, J., and Schmidhuber, J. Solving deep memory POMDPs with recurrent policy gradients. In ICANN, pp. 697-706. 2007.
Williams, R. J. Simple statistical gradient-following algorithms for connectionist reinforcement learning. Mach. Learn., 8: 229-256, 1992.
Yamaguchi, A. and Ogasawara, T. SkyAI: Highly modularized reinforcement learning library. In IEEE-RAS Humanoids, pp. $118-123,2010$.
Yu, D., Ju, Y.-C., Wang, Y.-Y., Zweig, G., and Acero, A. Automated directory assistance system - from theory to practice. In Interspeech, pp. 2709-2712, 2007.</p>
<h1>Supplementary Material</h1>
<h2>1. Task Specifications</h2>
<p>Below we provide some specifications for the task observations, actions, and rewards. Please refer to the benchmark source code (https://github.com/rllab/rllab) for complete specification of physics parameters.</p>
<h3>1.1. Basic Tasks</h3>
<p>Cart-Pole Balancing: In this task, an inverted pendulum is mounted on a pivot point on a cart. The cart itself is restricted to linear movement, achieved by applying horizontal forces. Due to the system's inherent instability, continuous cart movement is needed to keep the pendulum upright. The observation consists of the cart position $x$, pole angle $\theta$, the cart velocity $\dot{x}$, and the pole velocity $\dot{\theta}$. The 1D action consists of the horizontal force applied to the cart body. The reward function is given by $r(s, a):=10-(1-\cos (\theta))-10^{-5}|a|_{2}^{2}$. The episode terminates when $|x|&gt;2.4$ or $|\theta|&gt;0.2$.</p>
<p>Cart-Pole Swing Up: This is a more complicated version of the previous task, in which the system should not only be able to balance the pole, but first succeed in swinging it up into an upright position. This task extends the working range of the inverted pendulum to $360^{\circ}$. This is a nonlinear extension of the previous task. It has the same observation and action as in balancing. The reward function is given by $r(s, a):=\cos (\theta)$. The episode terminates when $|x|&gt;3$, with a penalty of -100 .</p>
<p>Mountain Car: In this task, a car has to escape a valley by repetitive application of tangential forces. Because the maximal tangential force is limited, the car has to alternately drive up along the two slopes of the valley in order to build up enough inertia to overcome gravity. This brings a challenge of exploration, since before first reaching the goal among all trials, a locally optimal solution exists, which is to drive to the point closest to the target and stay there for the rest of the episode. The observation is given by the horizontal position $x$ and the horizontal velocity $\dot{x}$ of the car. The reward is given by $r(s, a):=-1+$ height, with height the car's vertical offset. The episode terminates when the car reaches a target height of 0.6 . Hence the goal is to reach the target as soon as possible.</p>
<p>Acrobot Swing Up: In this task, an under-actuated, two-link robot has to swing itself into an upright position. It consists of two joints of which the first one has a fixed position and only the second one can exert torque. The goal is to swing the robot into an upright position and stabilize around that position. The controller not only has to swing the pendulum in order to build up inertia, similar to the Mountain Car task, but also has to decelerate it in order to prevent it from tipping over. The observation includes the two joint angles, $\theta_{1}$ and $\theta_{2}$, and their velocities, $\dot{\theta}<em 2="2">{1}$ and $\dot{\theta}</em>}$. The action is the torque applied at the second joint. The reward is defined as $r(s, a):=-\left|\operatorname{tip}(s)-\operatorname{tip<em 2="2">{\text {target }}\right|</em>(s)$ computes the Cartesian position of the tip of the robot given the joint angles. No termination condition is applied.}$, where $\operatorname{tip</p>
<p>Double Inverted Pendulum Balancing: This task extends the Cart-Pole Balancing task by replacing the single-link pole by a two-link rigid structure. As in the former task, the goal is to stabilize the two-link pole near the upright position. This task is more difficult than single-pole balancing, since the system is even more unstable and requires the controller to actively maintain balance. The observation includes the cart position $x$, joint angles $\left(\theta_{1}\right.$ and $\left.\theta_{2}\right)$, and joint velocities $\left(\dot{\theta}<em 2="2">{1}\right.$ and $\left.\dot{\theta}</em>}\right)$. We encode each joint angle as its sine and cosine values. The action is the same as in cart-pole tasks. The reward is given by $r(s, a)=10-0.01 x_{\text {tip }}^{2}-\left(y_{\text {tip }}-2\right)^{2}-10^{-3} \cdot \dot{\theta<em 2="2">{1}^{2}-5 \cdot 10^{-3} \cdot \dot{\theta}</em> \leq 1$.}^{2}$, where $x_{\text {tip }}, y_{\text {tip }}$ are the coordinates of the tip of the pole. No termination condition is applied. The episode is terminated when $y_{\text {tip }</p>
<h3>1.2. Locomotion Tasks</h3>
<p>Swimmer: The swimmer is a planar robot with 3 links and 2 actuated joints. Fluid is simulated through viscosity forces, which apply drag on each link, allowing the swimmer to move forward. This task is the simplest of all locomotion tasks, since there are no irrecoverable states in which the swimmer can get stuck, unlike other robots which may fall down or flip over. This places less burden on exploration. The 13-dim observation includes the joint angles, joint velocities, as well as</p>
<p>the coordinates of the center of mass. The reward is given by $r(s, a)=v_{x}-0.005|a|<em x="x">{2}^{2}$, where $v</em>$ is the forward velocity. No termination condition is applied.</p>
<p>Hopper: The hopper is a planar monopod robot with 4 rigid links, corresponding to the torso, upper leg, lower leg, and foot, along with 3 actuated joints. More exploration is needed than the swimmer task, since a stable hopping gait has to be learned without falling. Otherwise, it may get stuck in a local optimum of diving forward. The 20-dim observation includes joint angles, joint velocities, the coordinates of center of mass, and constraint forces. The reward is given by $r(s, a):=v_{x}-0.005 \cdot|a|<em _body="{body" _text="\text">{2}^{2}+1$, where the last term is a bonus for being "alive." The episode is terminated when $z</em>$ is the forward pitch of the body.}}&lt;0.7$ where $z_{\text {body }}$ is the $z$-coordinate of the body, or when $\left|\theta_{y}\right|&lt;0.2$, where $\theta_{y</p>
<p>Walker: The walker is a planar biped robot consisting of 7 links, corresponding to two legs and a torso, along with 6 actuated joints. This task is more challenging than hopper, since it has more degrees of freedom, and is also prone to falling. The 21-dim observation includes joint angles, joint velocities, and the coordinates of center of mass. The reward is given by $r(s, a):=v_{x}-0.005 \cdot|a|<em _body="{body" _text="\text">{2}^{2}$. The episode is terminated when $z</em>\right|&gt;1.0$.}}&lt;0.8, z_{\text {body }}&gt;2.0$, or when $\left|\theta_{y</p>
<p>Half-Cheetah: The half-cheetah is a planar biped robot with 9 rigid links, including two legs and a torso, along with 6 actuated joints. The 20-dim observation includes joint angles, joint velocities, and the coordinates of the center of mass. The reward is given by $r(s, a)=v_{x}-0.05 \cdot|a|_{2}^{2}$. No termination condition is applied.</p>
<p>Ant: The ant is a quadruped with 13 rigid links, including four legs and a torso, along with 8 actuated joints. This task is more challenging than the previous tasks due to the higher degrees of freedom. The 125-dim observation includes joint angles, joint velocities, coordinates of the center of mass, a (usually sparse) vector of contact forces, as well as the rotation matrix for the body. The reward is given by $r(s, a)=v_{x}-0.005 \cdot|a|<em _contact="{contact" _text="\text">{2}^{2}-C</em>\right|}}+0.05$, where $C_{\text {contact }}$ penalizes contacts to the ground, and is given by $5 \cdot 10^{-4} \cdot\left|F_{\text {contact }<em _contact="{contact" _text="\text">{2}^{2}$, where $F</em>&gt;1.0$.}}$ is the contact force vector clipped to values between -1 and 1 . The episode is terminated when $z_{\text {body }}&lt;0.2$ or when $z_{\text {body }</p>
<p>Simple Humanoid: This is a simplified humanoid model with 13 rigid links, including the head, body, arms, and legs, along with 10 actuated joints. The increased difficulty comes from the increased degrees of freedom as well as the need to maintain balance. The 102-dim observation includes the joint angles, joint velocities, vector of contact forces, and the coordinates of the center of mass. The reward is given by $r(s, a)=v_{x}-5 \cdot 10^{-4}|a|<em _contact="{contact" _text="\text">{2}^{2}-C</em>&gt;2.0$.}}-C_{\text {deviation }}+0.2$, where $C_{\text {contact }}=5 \cdot 10^{-6} \cdot\left|F_{\text {contact }}\right|$, and $C_{\text {deviation }}=5 \cdot 10^{-3} \cdot\left(v_{y}^{2}+v_{z}^{2}\right)$ to penalize deviation from the forward direction. The episode is terminated when $z_{\text {body }}&lt;0.8$ or when $z_{\text {body }</p>
<p>Full Humanoid: This is a humanoid model with 19 rigid links and 28 actuated joints. It has more degrees of freedom below the knees and elbows, which makes the system higher-dimensional and harder for learning. The 142-dim observation includes the joint angles, joint velocities, vector of contact forces, and the coordinates of the center of mass. The reward and termination condition is the same as in the Simple Humanoid model.</p>
<h1>1.3. Partially Observable Tasks</h1>
<p>Limited Sensors: The full description is included in the main text.
Noisy Observations and Delayed Actions: For all tasks, we use a Gaussian noise with $\sigma=0.1$. The time delay is as follows: Cart-Pole Balancing 0.15 sec , Cart-Pole Swing Up 0.15 sec , Mountain Car 0.15 sec , Acrobot Swing Up 0.06 sec , and Double Inverted Pendulum Balancing 0.06 sec . This corresponds to 3 discretization frames for each task.</p>
<p>System Identifications: For Cart-Pole Balancing and Cart-Pole Swing Up, the pole length is varied uniformly between, $50 \%$ and $150 \%$. For Mountain Car, the width of the valley varies uniformly between $75 \%$ and $125 \%$. For Acrobot Swing Up, each of the pole length varies uniformly between $50 \%$ and $150 \%$. For Double Inverted Pendulum Balancing, each of the pole length varies uniformly between $83 \%$ and $167 \%$. Please refer to the benchmark source code for reference values.</p>
<h3>1.4. Hierarchical Tasks</h3>
<p>Locomotion + Food Collection: During each episode, 8 food units and 8 bombs are placed in the environment. Collecting a food unit gives +1 reward, and collecting a bomb gives -1 reward. Hence the best cumulative reward for a given episode is 8 .</p>
<p>Locomotion + Maze: During each episode, a +1 reward is given when the robot reaches the goal. Otherwise, the robot receives a zero reward throughout the episode.</p>
<h1>2. Experiment Parameters</h1>
<p>For all batch gradient-based algorithms, we use the same time-varying feature encoding for the linear baseline:</p>
<p>$$
\phi_{s, t}=\operatorname{concat}\left(s, s \odot s, 0.01 t,(0.01 t)^{2},(0.01 t)^{3}, 1\right)
$$</p>
<p>where $s$ is the state vector and $\odot$ represents element-wise product.
Table 2 shows the experiment parameters for all four categories. We will then detail the hyperparameter search range for the selected tasks and report best hyperparameters, shown in Tables 3, 4, 5, 6, 7, and 8.</p>
<p>Table 2. Experiment Setup</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;">Basic \&amp; Locomotion</th>
<th style="text-align: left;">Partially Observable</th>
<th style="text-align: left;">Hierarchical</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Sim. steps per Iter.</td>
<td style="text-align: left;">50,000</td>
<td style="text-align: left;">50,000</td>
<td style="text-align: left;">50,000</td>
</tr>
<tr>
<td style="text-align: left;">Discount( $\lambda$ )</td>
<td style="text-align: left;">0.99</td>
<td style="text-align: left;">0.99</td>
<td style="text-align: left;">0.99</td>
</tr>
<tr>
<td style="text-align: left;">Horizon</td>
<td style="text-align: left;">500</td>
<td style="text-align: left;">100</td>
<td style="text-align: left;">500</td>
</tr>
<tr>
<td style="text-align: left;">Num. Iter.</td>
<td style="text-align: left;">500</td>
<td style="text-align: left;">300</td>
<td style="text-align: left;">500</td>
</tr>
</tbody>
</table>
<p>Table 3. Learning Rate $\alpha$ for REINFORCE</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;">Search Range</th>
<th style="text-align: left;">Best</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Cart-Pole Swing Up</td>
<td style="text-align: left;">$\left[1 \times 10^{-4}, 1 \times 10^{-1}\right]$</td>
<td style="text-align: left;">$5 \times 10^{-3}$</td>
</tr>
<tr>
<td style="text-align: left;">Double Inverted Pendulum</td>
<td style="text-align: left;">$\left[1 \times 10^{-4}, 1 \times 10^{-1}\right]$</td>
<td style="text-align: left;">$5 \times 10^{-3}$</td>
</tr>
<tr>
<td style="text-align: left;">Swimmer</td>
<td style="text-align: left;">$\left[1 \times 10^{-4}, 1 \times 10^{-1}\right]$</td>
<td style="text-align: left;">$1 \times 10^{-2}$</td>
</tr>
<tr>
<td style="text-align: left;">Ant</td>
<td style="text-align: left;">$\left[1 \times 10^{-4}, 1 \times 10^{-1}\right]$</td>
<td style="text-align: left;">$5 \times 10^{-3}$</td>
</tr>
</tbody>
</table>
<p>Table 4. Step Size $\delta_{\text {KL }}$ for TNPG</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;">Search Range</th>
<th style="text-align: left;">Best</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Cart-Pole Swing Up</td>
<td style="text-align: left;">$\left[1 \times 10^{-3}, 5 \times 10^{0}\right]$</td>
<td style="text-align: left;">$5 \times 10^{-2}$</td>
</tr>
<tr>
<td style="text-align: left;">Double Inverted Pendulum</td>
<td style="text-align: left;">$\left[1 \times 10^{-3}, 5 \times 10^{0}\right]$</td>
<td style="text-align: left;">$3 \times 10^{-2}$</td>
</tr>
<tr>
<td style="text-align: left;">Swimmer</td>
<td style="text-align: left;">$\left[1 \times 10^{-3}, 5 \times 10^{0}\right]$</td>
<td style="text-align: left;">$1 \times 10^{-1}$</td>
</tr>
<tr>
<td style="text-align: left;">Ant</td>
<td style="text-align: left;">$\left[1 \times 10^{-3}, 5 \times 10^{0}\right]$</td>
<td style="text-align: left;">$3 \times 10^{-1}$</td>
</tr>
</tbody>
</table>
<p>Table 5. Step Size $\delta_{\text {KL }}$ for TRPO</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;">Search Range</th>
<th style="text-align: left;">Best</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Cart-Pole Swing Up</td>
<td style="text-align: left;">$\left[1 \times 10^{-3}, 5 \times 10^{0}\right]$</td>
<td style="text-align: left;">$5 \times 10^{-2}$</td>
</tr>
<tr>
<td style="text-align: left;">Double Inverted Pendulum</td>
<td style="text-align: left;">$\left[1 \times 10^{-3}, 5 \times 10^{0}\right]$</td>
<td style="text-align: left;">$1 \times 10^{-3}$</td>
</tr>
<tr>
<td style="text-align: left;">Swimmer</td>
<td style="text-align: left;">$\left[1 \times 10^{-3}, 5 \times 10^{0}\right]$</td>
<td style="text-align: left;">$5 \times 10^{-2}$</td>
</tr>
<tr>
<td style="text-align: left;">Ant</td>
<td style="text-align: left;">$\left[1 \times 10^{-3}, 5 \times 10^{0}\right]$</td>
<td style="text-align: left;">$8 \times 10^{-2}$</td>
</tr>
</tbody>
</table>
<p>Table 6. Step Size $\delta_{\text {KL }}$ for REPS</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;">Search Range</th>
<th style="text-align: left;">Best</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Cart-Pole Swing Up</td>
<td style="text-align: left;">$\left[1 \times 10^{-3}, 5 \times 10^{0}\right]$</td>
<td style="text-align: left;">$1 \times 10^{-2}$</td>
</tr>
<tr>
<td style="text-align: left;">Double Inverted Pendulum</td>
<td style="text-align: left;">$\left[1 \times 10^{-3}, 5 \times 10^{0}\right]$</td>
<td style="text-align: left;">$8 \times 10^{-1}$</td>
</tr>
<tr>
<td style="text-align: left;">Swimmer</td>
<td style="text-align: left;">$\left[1 \times 10^{-3}, 5 \times 10^{0}\right]$</td>
<td style="text-align: left;">$3 \times 10^{-1}$</td>
</tr>
<tr>
<td style="text-align: left;">Ant</td>
<td style="text-align: left;">$\left[1 \times 10^{-3}, 5 \times 10^{0}\right]$</td>
<td style="text-align: left;">$8 \times 10^{-1}$</td>
</tr>
</tbody>
</table>
<p>Table 7. Initial Extra Noise for CEM</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;">Search Range</th>
<th style="text-align: left;">Best</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Cart-Pole Swing Up</td>
<td style="text-align: left;">$\left[1 \times 10^{-3}, 1\right]$</td>
<td style="text-align: left;">$1 \times 10^{-2}$</td>
</tr>
<tr>
<td style="text-align: left;">Double Inverted Pendulum</td>
<td style="text-align: left;">$\left[1 \times 10^{-3}, 1\right]$</td>
<td style="text-align: left;">$1 \times 10^{-1}$</td>
</tr>
<tr>
<td style="text-align: left;">Swimmer</td>
<td style="text-align: left;">$\left[1 \times 10^{-3}, 1\right]$</td>
<td style="text-align: left;">$1 \times 10^{-1}$</td>
</tr>
<tr>
<td style="text-align: left;">Ant</td>
<td style="text-align: left;">$\left[1 \times 10^{-3}, 1\right]$</td>
<td style="text-align: left;">$1 \times 10^{-1}$</td>
</tr>
</tbody>
</table>
<p>Table 8. Initial Standard Deviation for CMA-ES</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;">Search Range</th>
<th style="text-align: left;">Best</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Cart-Pole Swing Up</td>
<td style="text-align: left;">$\left[1 \times 10^{-3}, 1 \times 10^{3}\right]$</td>
<td style="text-align: left;">$1 \times 10^{3}$</td>
</tr>
<tr>
<td style="text-align: left;">Double Inverted Pendulum</td>
<td style="text-align: left;">$\left[1 \times 10^{-3}, 1 \times 10^{3}\right]$</td>
<td style="text-align: left;">$3 \times 10^{-1}$</td>
</tr>
<tr>
<td style="text-align: left;">Swimmer</td>
<td style="text-align: left;">$\left[1 \times 10^{-3}, 1 \times 10^{3}\right]$</td>
<td style="text-align: left;">$1 \times 10^{-1}$</td>
</tr>
<tr>
<td style="text-align: left;">Ant</td>
<td style="text-align: left;">$\left[1 \times 10^{-3}, 1 \times 10^{3}\right]$</td>
<td style="text-align: left;">$1 \times 10^{-1}$</td>
</tr>
</tbody>
</table>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>Proceedings of the $33^{\text {rd }}$ International Conference on Machine Learning, New York, NY, USA, 2016. JMLR: W\&amp;CP volume 48. Copyright 2016 by the author(s).</p>
<p>Also available at https://arxiv.org/abs/1604.06778&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>