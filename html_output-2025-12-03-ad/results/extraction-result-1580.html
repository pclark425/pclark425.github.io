<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-1580 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-1580</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-1580</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-31.html">extraction-schema-31</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <p><strong>Paper ID:</strong> paper-252070483</p>
                <p><strong>Paper Title:</strong> <a href="https://export.arxiv.org/pdf/2209.01020v1.pdf" target="_blank">EvolvingBehavior: Towards Co-Creative Evolution of Behavior Trees for Game NPCs</a></p>
                <p><strong>Paper Abstract:</strong> To assist game developers in crafting game NPCs, we present EvolvingBehavior, a novel tool for genetic programming to evolve behavior trees in Unreal Engine 4. In an initial evaluation, we compare evolved behavior to hand-crafted trees designed by our researchers, and to randomly-grown trees, in a 3D survival game. We find that EvolvingBehavior is capable of producing behavior approaching the designer's goals in this context. Finally, we discuss implications and future avenues of exploration for co-creative game AI design tools, as well as challenges and difficulties in behavior tree evolution.</p>
                <p><strong>Cost:</strong> 0.017</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e1580.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e1580.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>EvolvingBehavior</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>EvolvingBehavior (genetic programming plugin for Unreal Engine)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A genetic-programming tool implemented as an Unreal Engine 4 plugin that evolves behavior tree programs for game NPCs using subtree crossover, multiple point mutation operators (including property perturbation), tournament selection, and designer-defined fitness functions with a tree-complexity penalty.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>EvolvingBehavior</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>EvolvingBehavior is a genetic programming system that represents Unreal Engine behavior trees as serializable chromosomes composed of mapped nodes (references to existing behavior-tree nodes) and generated node templates (nodes with property ranges). It evolves populations of behavior-tree chromosomes by iterated selection (tournament selection with k=4), elitism (12%), reproduction by copying a primary parent and then applying crossover (subtree swap with depth-selected crossover point) and multiple point-mutator operations (each with independent probability). Fitness is computed via designer-specified, event-driven measures combined by a linear weighted sum by default, with an explicit penalty term proportional to tree size (number of nodes) to combat bloat. The tool is intended for co-creative workflows where designers supply the initial tree, node library, mutator settings, and fitness signals; evolution runs in simulated gameplay to evaluate behavior.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs (behavior trees)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Subtree crossover: after copying the primary parent into a child, the operator may select a random subtree from the child and replace it with a random subtree drawn from the second parent. The system selects crossover points by choosing a tree depth uniformly at random (depth-dependent crossover), rather than uniformly over nodes; subtrees need not match in size or position.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Multiple point mutations with independent probabilities per mutation type. Implementations include: (a) structural point mutations that replace, add, or delete a single randomly selected node; (b) property mutators for generated-node variables: Gaussian perturbation for float and integer properties (designer-specified std. dev. as percentage of current value; 10% used in tests), and random re-selection for boolean and blackboard-variable properties. Multiple mutation types may be applied to a child (not limited to at most one), and the system also supports an initial 'random modification' phase with elevated mutation and crossover probabilities.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Designer-defined, event-driven fitness: multiple named fitness measures (e.g., moving/patrolling, chasing, damage dealt, searching near last-known location, penalties for failing to move or repeatedly losing/starting chases) are updated by in-game events; final fitness is a linear combination of these measures with designer-set weights. Additionally, tree complexity (node count) is included as a negative fitness component to penalize bloat.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>Aggregate fitness statistics reported: evolved trees median fitness 434 (IQR 590) across conditions, random baseline median -598 (IQR 1026). Example condition results: Medium Map 50v6 averaged Evolved = 521 vs ManualR3 = 262 and ManualR2 = 397; Medium Map 50v3 averaged Evolved = 356 vs ManualR1 = 127. Individual evolutionary runs (1000 generations) typically completed in ~2–3 hours.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>No explicit formal novelty/diversity metric used; diversity discussed qualitatively and via population statistics (distributional descriptors such as median and IQR of fitness); algorithmic levers to affect diversity include tournament size (k=4) and mutation/crossover rates; authors propose quality-diversity (MAP-Elites) and subtree-growth mutators for future work.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td>No quantitative diversity score reported. Indirect evidence: spread of fitness (IQRs above) and differing outcomes across 3 runs per condition; authors note cases of low chromosome diversity in small-population/small-map settings and suggest larger populations or alternative algorithms.</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Discussed qualitatively: the system penalizes tree complexity to reduce bloat (favoring executability/readability) which can reduce exploration of novel but large solutions; mutation-rate and elitism tradeoffs were tuned to balance stability (low mutation -> fine-tuning) vs innovation (higher mutation -> more novel behaviors). Authors explicitly note that higher mutation rates increased innovation at some cost to stability and that subtree-growth mutators or quality-diversity approaches might improve exploration without sacrificing executability.</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Program synthesis for game AI — evolving behavior trees for NPCs in a 3D Unreal Engine survival game (zombie agents) using simulated gameplay as fitness evaluation.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Manual hand-designed behavior trees (three human-designed trees), Random Baseline (reproduce-and-mutate without fitness-based parent selection).</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>EvolvingBehavior can produce behavior trees that in many conditions approximate the behavior of human-designed trees and outperform a random baseline. Subtree crossover with depth-selected crossover points and a suite of point mutations (including property Gaussian perturbation) produced effective behavior in 6 of 9 conditions; evolved trees had a higher median fitness (434) than the random baseline (-598). The authors found sensitivity to mutation/crossover rates, population size, and fitness-function design: higher mutation rates (they increased from initial grid-search values) sped discovery but reduced stability; small population sizes reduced diversity and sometimes trapped evolution in local optima. Tree-complexity penalties helped control bloat but may suppress novel, complex but useful behaviors. No explicit novelty metric was used; authors recommend exploring subtree-growth mutators and quality-diversity (MAP-Elites) approaches to increase diversity and novelty while retaining executability.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1580.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e1580.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>RandomBaseline</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Random Baseline (reproduce-and-mutate without selection)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A control system implemented for comparison that reproduces and mutates all trees from the previous generation without fitness-based parent selection, using the same mutation and crossover operators and other parameters as the evolutionary condition.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Random Baseline</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>The Random Baseline mirrors EvolvingBehavior's reproduction mechanics (copying, crossover, point mutations, property mutators) and experimental parameters (mutation/crossover probabilities, population sizes, elitism, generation count), but removes fitness-proportionate parent selection: instead, every tree is reproduced and possibly mutated oblivious to fitness. The rest of the pipeline (simulation-based fitness testing used only for final comparison) stays the same, enabling a direct test of the role of selection in producing useful behavior.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs (behavior trees)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Same subtree crossover operator as EvolvingBehavior: random subtree substitution with depth-selected crossover points, applied per reproduction according to the same configured probability.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Same point mutation operators as EvolvingBehavior: replace/add/delete node mutations, Gaussian perturbation of numeric properties (10% std. dev. used in tests), and random re-selection for booleans/blackboard vars; multiple mutation types may be applied with independent probabilities.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>No selection-driven fitness used during generation; executability/functionality assessed post-hoc using the same designer-defined event-driven fitness functions (linear combination) and qualitative observation.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>Random Baseline median fitness across conditions was -598 (IQR 1026), substantially lower than the Evolved median. In qualitative playtests the Random Baseline trees mostly produced zombies that stood still until seeing a player and generally lacked patrolling behavior; they also contained many irrelevant nodes (e.g., 8–12 irrelevant nodes in small-map samples). There were no cases where the Random Baseline outperformed the Evolved trees.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Not directly analyzed; as a baseline it highlighted that selection (versus pure mutation/crossover) is necessary to produce functional/executable behavior in this domain despite the same mutation/crossover operators being present.</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Program synthesis for game AI (behavior trees in Unreal Engine) — serves as a null-selection control.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Compared against EvolvingBehavior (fitness-driven GP) and three Manual hand-designed behavior trees.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Maintaining the same mutation/crossover operators but removing fitness-based selection yields substantially worse functional behavior: Random Baseline results had markedly lower median fitness and qualitatively inferior, often non-patrolling, behavior. This demonstrates that crossover+mutation alone (without selection pressure from a fitness function) is insufficient for generating useful, executable behavior in this setup.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1580.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e1580.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Genetic Programming (Koza)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Genetic Programming (as in Koza, 1992)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A class of evolutionary algorithms that evolve tree-structured programs by applying biologically inspired operators such as subtree crossover and point/subtree mutation, driven by a fitness function to synthesize programs.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Genetic programming: on the programming of computers by means of natural selection</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Genetic Programming (Koza-style)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Canonical genetic programming operates on populations of tree-structured programs, evaluating each individual using a problem-specific fitness function, selecting parents (various schemes), and generating offspring by subtree crossover and various mutation operators; Koza's work also discusses node-selection biases and issues such as bloat.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs (tree-structured programs)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Typical subtree crossover: select a random subtree from parent A and a random subtree from parent B and swap them to create offspring. Koza observed biases due to node types and node-count distributions; depth/node-selection biases have been proposed to address this.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Typical point mutations include replacing a node or subtree with a randomly generated node/subtree, or perturbing constants; many variants apply probabilistic per-node mutations across the tree.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Koza and follow-on work discuss bloat and complexity-management tradeoffs; this paper references those issues when motivating tree-size penalties.</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Program synthesis and automated program generation across domains (general GP literature).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Referenced as the foundation for evolving behavior trees; issues from GP literature (bloat, selection/crossover biases) directly informed EvolvingBehavior's design choices such as tree-size penalties, depth-selected crossover, and discussion of subtree-growth mutators as future work.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1580.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e1580.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Grammatical Evolution</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Grammatical Evolution (applied to behavior-tree generation)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An evolutionary approach that evolves integer/genotype sequences mapped via a grammar to generate structured programs or trees (used by prior work to constrain behavior-tree structure, e.g., Perez et al. for Mario).</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Evolving Behaviour Trees for the Mario AI Competition Using Grammatical Evolution</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Grammatical Evolution</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Grammatical Evolution evolves genotypes (integer arrays) which are mapped through a formal grammar to produce syntactically-correct programs or tree structures (e.g., constrained 'and/or' trees for behavior). It constrains structure and can reduce search over invalid programs.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs/behavior trees (via grammar mappings)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Typically standard GA crossover on genotype representations (e.g., one-point or two-point crossover on integer arrays); structural effects on phenotype follow from grammar mapping.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Genotype point mutation altering integer codons, affecting subsequent grammar expansions; may include insertion/deletion on genotype.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Behavior tree generation for games (Mario AI benchmark cited).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Mentioned as an alternative approach that constrains generated tree structure (and-or trees) and can influence granularity of representable behaviors; cited as prior work demonstrating grammatical constraints can be effective for game-AI behavior synthesis.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1580.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e1580.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Depth-Dependent Crossover</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Depth-dependent crossover (tree-depth selection strategy)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A crossover strategy that selects crossover points based on tree depth (often uniformly over depth) to bias how much of each parent is swapped, cited as more effective than uniform-node selection in some GP contexts.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Depth-dependent crossover for genetic programming</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Depth-dependent crossover</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Rather than selecting crossover points uniformly over all nodes, the operator selects a tree depth according to some distribution (e.g., uniform over depths) and then chooses a node at that depth to perform subtree crossover, controlling average swapped subtree size and the magnitude of behavioral changes.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs (trees)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Select a depth d according to a depth distribution (uniform in the referenced approach) and then select a node at that depth uniformly to serve as the crossover point; swap subtrees between parents at these points.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Tree-based genetic programming crossover strategies (general GP literature).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>EvolvingBehavior uses a depth-selected crossover operator (uniform over depth) citing this work as justification; authors noted this can be more effective than Koza's original node-selection bias.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1580.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e1580.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>MAP-Elites / Quality-Diversity</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>MAP-Elites / Quality-Diversity algorithms</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A family of evolutionary search methods that aim to produce a diverse set of high-quality solutions by explicitly optimizing across user-defined feature dimensions (used for encouraging diversity and exploring tradeoffs between novelty and performance).</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Illuminating search spaces by mapping elites</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Quality-Diversity (e.g., MAP-Elites)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Quality-Diversity algorithms maintain a repertoire of solutions across behavioral/feature dimensions (the 'map') and aim to fill it with high-performing, behaviorally diverse solutions rather than a single optimum; MAP-Elites is a representative algorithm that discretizes feature dimensions and preserves the best solution found per cell.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs/behaviors/agents</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Typically uses variation operators from evolutionary algorithms (mutation and crossover) to generate offspring that are mapped into feature cells; exact operators depend on encoding.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Typical mutation and crossover operators appropriate to the genotype (e.g., subtree mutation for trees or parameter perturbations) applied to produce new individuals for consideration in the archive.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td>Implicit: behavioral/feature diversity measured by coverage of feature map and quality per cell (MAP-Elites uses feature dimensions to quantify novelty/diversity).</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Quality is measured per-cell by the problem-specific fitness (performance) metric used to decide whether an individual replaces the incumbent in that cell.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Behavioral diversity / feature-space coverage (cells filled in the map).</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Quality-Diversity explicitly explores the tradeoff by maintaining a set of diverse behaviors while optimizing quality per behavior; paper suggests this as a future direction to preserve varied trees while retaining high fitness.</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Suggested as an alternate approach for evolving behavior trees and procedural content in games.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Cited by authors as a promising family of methods to maintain varied, high-fitness behavior trees and ameliorate population diversity loss; not used in experiments but recommended for future work.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Genetic programming: on the programming of computers by means of natural selection <em>(Rating: 2)</em></li>
                <li>Depth-dependent crossover for genetic programming <em>(Rating: 2)</em></li>
                <li>Evolving Behaviour Trees for the Mario AI Competition Using Grammatical Evolution <em>(Rating: 2)</em></li>
                <li>Illuminating search spaces by mapping elites <em>(Rating: 2)</em></li>
                <li>Behaviour Tree Evolution by Genetic Programming <em>(Rating: 1)</em></li>
                <li>Behaviour Tree Evolution:-Automatic Generation of AI Opponents for Real-Time Strategy Games <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-1580",
    "paper_id": "paper-252070483",
    "extraction_schema_id": "extraction-schema-31",
    "extracted_data": [
        {
            "name_short": "EvolvingBehavior",
            "name_full": "EvolvingBehavior (genetic programming plugin for Unreal Engine)",
            "brief_description": "A genetic-programming tool implemented as an Unreal Engine 4 plugin that evolves behavior tree programs for game NPCs using subtree crossover, multiple point mutation operators (including property perturbation), tournament selection, and designer-defined fitness functions with a tree-complexity penalty.",
            "citation_title": "here",
            "mention_or_use": "use",
            "system_name": "EvolvingBehavior",
            "system_description": "EvolvingBehavior is a genetic programming system that represents Unreal Engine behavior trees as serializable chromosomes composed of mapped nodes (references to existing behavior-tree nodes) and generated node templates (nodes with property ranges). It evolves populations of behavior-tree chromosomes by iterated selection (tournament selection with k=4), elitism (12%), reproduction by copying a primary parent and then applying crossover (subtree swap with depth-selected crossover point) and multiple point-mutator operations (each with independent probability). Fitness is computed via designer-specified, event-driven measures combined by a linear weighted sum by default, with an explicit penalty term proportional to tree size (number of nodes) to combat bloat. The tool is intended for co-creative workflows where designers supply the initial tree, node library, mutator settings, and fitness signals; evolution runs in simulated gameplay to evaluate behavior.",
            "input_type": "programs (behavior trees)",
            "crossover_operation": "Subtree crossover: after copying the primary parent into a child, the operator may select a random subtree from the child and replace it with a random subtree drawn from the second parent. The system selects crossover points by choosing a tree depth uniformly at random (depth-dependent crossover), rather than uniformly over nodes; subtrees need not match in size or position.",
            "mutation_operation": "Multiple point mutations with independent probabilities per mutation type. Implementations include: (a) structural point mutations that replace, add, or delete a single randomly selected node; (b) property mutators for generated-node variables: Gaussian perturbation for float and integer properties (designer-specified std. dev. as percentage of current value; 10% used in tests), and random re-selection for boolean and blackboard-variable properties. Multiple mutation types may be applied to a child (not limited to at most one), and the system also supports an initial 'random modification' phase with elevated mutation and crossover probabilities.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Designer-defined, event-driven fitness: multiple named fitness measures (e.g., moving/patrolling, chasing, damage dealt, searching near last-known location, penalties for failing to move or repeatedly losing/starting chases) are updated by in-game events; final fitness is a linear combination of these measures with designer-set weights. Additionally, tree complexity (node count) is included as a negative fitness component to penalize bloat.",
            "executability_results": "Aggregate fitness statistics reported: evolved trees median fitness 434 (IQR 590) across conditions, random baseline median -598 (IQR 1026). Example condition results: Medium Map 50v6 averaged Evolved = 521 vs ManualR3 = 262 and ManualR2 = 397; Medium Map 50v3 averaged Evolved = 356 vs ManualR1 = 127. Individual evolutionary runs (1000 generations) typically completed in ~2–3 hours.",
            "diversity_metric": "No explicit formal novelty/diversity metric used; diversity discussed qualitatively and via population statistics (distributional descriptors such as median and IQR of fitness); algorithmic levers to affect diversity include tournament size (k=4) and mutation/crossover rates; authors propose quality-diversity (MAP-Elites) and subtree-growth mutators for future work.",
            "diversity_results": "No quantitative diversity score reported. Indirect evidence: spread of fitness (IQRs above) and differing outcomes across 3 runs per condition; authors note cases of low chromosome diversity in small-population/small-map settings and suggest larger populations or alternative algorithms.",
            "novelty_executability_tradeoff": "Discussed qualitatively: the system penalizes tree complexity to reduce bloat (favoring executability/readability) which can reduce exploration of novel but large solutions; mutation-rate and elitism tradeoffs were tuned to balance stability (low mutation -&gt; fine-tuning) vs innovation (higher mutation -&gt; more novel behaviors). Authors explicitly note that higher mutation rates increased innovation at some cost to stability and that subtree-growth mutators or quality-diversity approaches might improve exploration without sacrificing executability.",
            "frontier_characterization": null,
            "benchmark_or_domain": "Program synthesis for game AI — evolving behavior trees for NPCs in a 3D Unreal Engine survival game (zombie agents) using simulated gameplay as fitness evaluation.",
            "comparison_baseline": "Manual hand-designed behavior trees (three human-designed trees), Random Baseline (reproduce-and-mutate without fitness-based parent selection).",
            "key_findings": "EvolvingBehavior can produce behavior trees that in many conditions approximate the behavior of human-designed trees and outperform a random baseline. Subtree crossover with depth-selected crossover points and a suite of point mutations (including property Gaussian perturbation) produced effective behavior in 6 of 9 conditions; evolved trees had a higher median fitness (434) than the random baseline (-598). The authors found sensitivity to mutation/crossover rates, population size, and fitness-function design: higher mutation rates (they increased from initial grid-search values) sped discovery but reduced stability; small population sizes reduced diversity and sometimes trapped evolution in local optima. Tree-complexity penalties helped control bloat but may suppress novel, complex but useful behaviors. No explicit novelty metric was used; authors recommend exploring subtree-growth mutators and quality-diversity (MAP-Elites) approaches to increase diversity and novelty while retaining executability.",
            "uuid": "e1580.0"
        },
        {
            "name_short": "RandomBaseline",
            "name_full": "Random Baseline (reproduce-and-mutate without selection)",
            "brief_description": "A control system implemented for comparison that reproduces and mutates all trees from the previous generation without fitness-based parent selection, using the same mutation and crossover operators and other parameters as the evolutionary condition.",
            "citation_title": "here",
            "mention_or_use": "use",
            "system_name": "Random Baseline",
            "system_description": "The Random Baseline mirrors EvolvingBehavior's reproduction mechanics (copying, crossover, point mutations, property mutators) and experimental parameters (mutation/crossover probabilities, population sizes, elitism, generation count), but removes fitness-proportionate parent selection: instead, every tree is reproduced and possibly mutated oblivious to fitness. The rest of the pipeline (simulation-based fitness testing used only for final comparison) stays the same, enabling a direct test of the role of selection in producing useful behavior.",
            "input_type": "programs (behavior trees)",
            "crossover_operation": "Same subtree crossover operator as EvolvingBehavior: random subtree substitution with depth-selected crossover points, applied per reproduction according to the same configured probability.",
            "mutation_operation": "Same point mutation operators as EvolvingBehavior: replace/add/delete node mutations, Gaussian perturbation of numeric properties (10% std. dev. used in tests), and random re-selection for booleans/blackboard vars; multiple mutation types may be applied with independent probabilities.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "No selection-driven fitness used during generation; executability/functionality assessed post-hoc using the same designer-defined event-driven fitness functions (linear combination) and qualitative observation.",
            "executability_results": "Random Baseline median fitness across conditions was -598 (IQR 1026), substantially lower than the Evolved median. In qualitative playtests the Random Baseline trees mostly produced zombies that stood still until seeing a player and generally lacked patrolling behavior; they also contained many irrelevant nodes (e.g., 8–12 irrelevant nodes in small-map samples). There were no cases where the Random Baseline outperformed the Evolved trees.",
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": "Not directly analyzed; as a baseline it highlighted that selection (versus pure mutation/crossover) is necessary to produce functional/executable behavior in this domain despite the same mutation/crossover operators being present.",
            "frontier_characterization": null,
            "benchmark_or_domain": "Program synthesis for game AI (behavior trees in Unreal Engine) — serves as a null-selection control.",
            "comparison_baseline": "Compared against EvolvingBehavior (fitness-driven GP) and three Manual hand-designed behavior trees.",
            "key_findings": "Maintaining the same mutation/crossover operators but removing fitness-based selection yields substantially worse functional behavior: Random Baseline results had markedly lower median fitness and qualitatively inferior, often non-patrolling, behavior. This demonstrates that crossover+mutation alone (without selection pressure from a fitness function) is insufficient for generating useful, executable behavior in this setup.",
            "uuid": "e1580.1"
        },
        {
            "name_short": "Genetic Programming (Koza)",
            "name_full": "Genetic Programming (as in Koza, 1992)",
            "brief_description": "A class of evolutionary algorithms that evolve tree-structured programs by applying biologically inspired operators such as subtree crossover and point/subtree mutation, driven by a fitness function to synthesize programs.",
            "citation_title": "Genetic programming: on the programming of computers by means of natural selection",
            "mention_or_use": "mention",
            "system_name": "Genetic Programming (Koza-style)",
            "system_description": "Canonical genetic programming operates on populations of tree-structured programs, evaluating each individual using a problem-specific fitness function, selecting parents (various schemes), and generating offspring by subtree crossover and various mutation operators; Koza's work also discusses node-selection biases and issues such as bloat.",
            "input_type": "programs (tree-structured programs)",
            "crossover_operation": "Typical subtree crossover: select a random subtree from parent A and a random subtree from parent B and swap them to create offspring. Koza observed biases due to node types and node-count distributions; depth/node-selection biases have been proposed to address this.",
            "mutation_operation": "Typical point mutations include replacing a node or subtree with a randomly generated node/subtree, or perturbing constants; many variants apply probabilistic per-node mutations across the tree.",
            "uses_literature": null,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": "Koza and follow-on work discuss bloat and complexity-management tradeoffs; this paper references those issues when motivating tree-size penalties.",
            "frontier_characterization": null,
            "benchmark_or_domain": "Program synthesis and automated program generation across domains (general GP literature).",
            "comparison_baseline": null,
            "key_findings": "Referenced as the foundation for evolving behavior trees; issues from GP literature (bloat, selection/crossover biases) directly informed EvolvingBehavior's design choices such as tree-size penalties, depth-selected crossover, and discussion of subtree-growth mutators as future work.",
            "uuid": "e1580.2"
        },
        {
            "name_short": "Grammatical Evolution",
            "name_full": "Grammatical Evolution (applied to behavior-tree generation)",
            "brief_description": "An evolutionary approach that evolves integer/genotype sequences mapped via a grammar to generate structured programs or trees (used by prior work to constrain behavior-tree structure, e.g., Perez et al. for Mario).",
            "citation_title": "Evolving Behaviour Trees for the Mario AI Competition Using Grammatical Evolution",
            "mention_or_use": "mention",
            "system_name": "Grammatical Evolution",
            "system_description": "Grammatical Evolution evolves genotypes (integer arrays) which are mapped through a formal grammar to produce syntactically-correct programs or tree structures (e.g., constrained 'and/or' trees for behavior). It constrains structure and can reduce search over invalid programs.",
            "input_type": "programs/behavior trees (via grammar mappings)",
            "crossover_operation": "Typically standard GA crossover on genotype representations (e.g., one-point or two-point crossover on integer arrays); structural effects on phenotype follow from grammar mapping.",
            "mutation_operation": "Genotype point mutation altering integer codons, affecting subsequent grammar expansions; may include insertion/deletion on genotype.",
            "uses_literature": null,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Behavior tree generation for games (Mario AI benchmark cited).",
            "comparison_baseline": null,
            "key_findings": "Mentioned as an alternative approach that constrains generated tree structure (and-or trees) and can influence granularity of representable behaviors; cited as prior work demonstrating grammatical constraints can be effective for game-AI behavior synthesis.",
            "uuid": "e1580.3"
        },
        {
            "name_short": "Depth-Dependent Crossover",
            "name_full": "Depth-dependent crossover (tree-depth selection strategy)",
            "brief_description": "A crossover strategy that selects crossover points based on tree depth (often uniformly over depth) to bias how much of each parent is swapped, cited as more effective than uniform-node selection in some GP contexts.",
            "citation_title": "Depth-dependent crossover for genetic programming",
            "mention_or_use": "mention",
            "system_name": "Depth-dependent crossover",
            "system_description": "Rather than selecting crossover points uniformly over all nodes, the operator selects a tree depth according to some distribution (e.g., uniform over depths) and then chooses a node at that depth to perform subtree crossover, controlling average swapped subtree size and the magnitude of behavioral changes.",
            "input_type": "programs (trees)",
            "crossover_operation": "Select a depth d according to a depth distribution (uniform in the referenced approach) and then select a node at that depth uniformly to serve as the crossover point; swap subtrees between parents at these points.",
            "mutation_operation": null,
            "uses_literature": null,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Tree-based genetic programming crossover strategies (general GP literature).",
            "comparison_baseline": null,
            "key_findings": "EvolvingBehavior uses a depth-selected crossover operator (uniform over depth) citing this work as justification; authors noted this can be more effective than Koza's original node-selection bias.",
            "uuid": "e1580.4"
        },
        {
            "name_short": "MAP-Elites / Quality-Diversity",
            "name_full": "MAP-Elites / Quality-Diversity algorithms",
            "brief_description": "A family of evolutionary search methods that aim to produce a diverse set of high-quality solutions by explicitly optimizing across user-defined feature dimensions (used for encouraging diversity and exploring tradeoffs between novelty and performance).",
            "citation_title": "Illuminating search spaces by mapping elites",
            "mention_or_use": "mention",
            "system_name": "Quality-Diversity (e.g., MAP-Elites)",
            "system_description": "Quality-Diversity algorithms maintain a repertoire of solutions across behavioral/feature dimensions (the 'map') and aim to fill it with high-performing, behaviorally diverse solutions rather than a single optimum; MAP-Elites is a representative algorithm that discretizes feature dimensions and preserves the best solution found per cell.",
            "input_type": "programs/behaviors/agents",
            "crossover_operation": "Typically uses variation operators from evolutionary algorithms (mutation and crossover) to generate offspring that are mapped into feature cells; exact operators depend on encoding.",
            "mutation_operation": "Typical mutation and crossover operators appropriate to the genotype (e.g., subtree mutation for trees or parameter perturbations) applied to produce new individuals for consideration in the archive.",
            "uses_literature": null,
            "uses_code": true,
            "novelty_metric": "Implicit: behavioral/feature diversity measured by coverage of feature map and quality per cell (MAP-Elites uses feature dimensions to quantify novelty/diversity).",
            "novelty_results": null,
            "executability_metric": "Quality is measured per-cell by the problem-specific fitness (performance) metric used to decide whether an individual replaces the incumbent in that cell.",
            "executability_results": null,
            "diversity_metric": "Behavioral diversity / feature-space coverage (cells filled in the map).",
            "diversity_results": null,
            "novelty_executability_tradeoff": "Quality-Diversity explicitly explores the tradeoff by maintaining a set of diverse behaviors while optimizing quality per behavior; paper suggests this as a future direction to preserve varied trees while retaining high fitness.",
            "frontier_characterization": null,
            "benchmark_or_domain": "Suggested as an alternate approach for evolving behavior trees and procedural content in games.",
            "comparison_baseline": null,
            "key_findings": "Cited by authors as a promising family of methods to maintain varied, high-fitness behavior trees and ameliorate population diversity loss; not used in experiments but recommended for future work.",
            "uuid": "e1580.5"
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Genetic programming: on the programming of computers by means of natural selection",
            "rating": 2,
            "sanitized_title": "genetic_programming_on_the_programming_of_computers_by_means_of_natural_selection"
        },
        {
            "paper_title": "Depth-dependent crossover for genetic programming",
            "rating": 2,
            "sanitized_title": "depthdependent_crossover_for_genetic_programming"
        },
        {
            "paper_title": "Evolving Behaviour Trees for the Mario AI Competition Using Grammatical Evolution",
            "rating": 2,
            "sanitized_title": "evolving_behaviour_trees_for_the_mario_ai_competition_using_grammatical_evolution"
        },
        {
            "paper_title": "Illuminating search spaces by mapping elites",
            "rating": 2,
            "sanitized_title": "illuminating_search_spaces_by_mapping_elites"
        },
        {
            "paper_title": "Behaviour Tree Evolution by Genetic Programming",
            "rating": 1,
            "sanitized_title": "behaviour_tree_evolution_by_genetic_programming"
        },
        {
            "paper_title": "Behaviour Tree Evolution:-Automatic Generation of AI Opponents for Real-Time Strategy Games",
            "rating": 1,
            "sanitized_title": "behaviour_tree_evolutionautomatic_generation_of_ai_opponents_for_realtime_strategy_games"
        }
    ],
    "cost": 0.0165345,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>EvolvingBehavior: Towards Co-Creative Evolution of Behavior Trees for Game NPCs
ACMCopyright ACMSeptember 5-8, 2022</p>
<p>Nathan Partlan partlan.n@northeastern.edu 
Luis Soto soto.lu@northeastern.edu 
Jim Howe 
Sarthak Shrivastava shrivastava.sa@northeastern.edu 
Magy Seif El-Nasr 
Stacy Marsella s.marsella@northeastern.edu 
Nathan Partlan 
Luis Soto 
Jim Howe 
Sarthak Shrivastava 
Magy Seif El-Nasr 
Stacy Marsella </p>
<p>Northeastern University Boston
MAUSA</p>
<p>Northeastern University Boston
MAUSA</p>
<p>Northeastern University Boston
MAUSA</p>
<p>Northeastern University Boston
MAUSA</p>
<p>University of California
Santa Cruz Santa CruzCAUSA</p>
<p>Northeastern University Boston
MAUSA</p>
<p>EvolvingBehavior: Towards Co-Creative Evolution of Behavior Trees for Game NPCs</p>
<p>FDG '22: Proceedings of the 17th International Conference on the Foundations of Digital Games (FDG '22)
Athens, Greece; New York, NY, USAACM132022September 5-8, 202210.1145/3555858.3555896ACM Reference Format:CCS CONCEPTS • Applied computing → Computer games• Computing method- ologies → Intelligent agentsGenetic programming• Human- centered computing → Interactive systems and tools KEYWORDS games, artificial intelligence, genetic programming, computational co-creativity
To assist game developers in crafting game NPCs, we present Evolv-ingBehavior, a novel tool for genetic programming to evolve behavior trees in Unreal®Engine 4. In an initial evaluation, we compare evolved behavior to hand-crafted trees designed by our researchers, and to randomly-grown trees, in a 3D survival game. We find that EvolvingBehavior is capable of producing behavior approaching the designer's goals in this context. Finally, we discuss implications and future avenues of exploration for co-creative game AI design tools, as well as challenges and difficulties in behavior tree evolution.</p>
<p>INTRODUCTION</p>
<p>Game developers carefully craft non-player characters (NPCs) to support their game design goals, focusing on creating a specific player experience. But they may not always have specific training, technical knowledge, or access to dedicated support for implementing their desired NPC behavior. They may also find that players interact in unexpected ways with their games, and may want help developing NPCs that can handle unusual or emergent gameplay situations. Game developers, especially those working alone or with small teams and limited resources, may not have expertise in developing robust and effective game AI. Tools that could generate or suggest agent behavior might support designers in this work.</p>
<p>We should consider, then, whether it is possible to make an AI-enabled, computationally co-creative tool that could aid and collaborate with game developers in crafting and refining NPC behavior. As a prerequisite, however, such a tool must be able to produce NPC behavior to meet particular design goals. It must also work with existing game engines and game AI frameworks.</p>
<p>These problems can be considered a form of "program synthesis, " the automated creation of programs, an active area of research [17]. Synthesizing NPC behavior presents some unique challenges: it requires simulation to determine fitness (rather than having a direct mapping from input to desired output, as in many programs), and that evaluation must relate to the designer's goals for the behavior. It is important to investigate, then, how program synthesis methods can generate NPC behavior -with the guidance, and meeting the goals, of a human designer -within a reasonable amount of time.</p>
<p>To approach this problem, we choose to focus on behavior trees, a popular game AI design architecture [6,23], in the professional and commonly-used Unreal®Engine 4 game engine 1 . Specifically, we explore the combination of behavior trees and genetic programming, a tree-structured program synthesis technique that maps naturally to the behavior tree architecture and that has shown promise in creating behavior trees for simple 2D games [8,55].</p>
<p>In this work, we present EvolvingBehavior 2 , a novel tool that employs genetic programming to evolve modifications to handcrafted behavior trees as part of a co-creative game design process. As an initial evaluation of the tool, we describe an experiment that compares evolved behavior trees to trees hand-designed by our researchers and to randomly-grown trees for zombies in a 3D survival game, exploring the results through quantitative evaluation and in-depth discussion. We find that the evolved trees exhibit clearly stronger similarities to hand-designed trees than randomly-grown trees. Finally, we discuss implications for co-creative game AI design tools, challenges in automatic evolution of behavior trees, and potential future research to empower game designers to use these tools to achieve their NPC design visions.</p>
<p>RELATED WORK 2.1 Program Synthesis and Evolving Game AI</p>
<p>We can think of generating AI behavior for agents in games as a form of program synthesis. Program synthesis is a hard problem, requiring search over a large space of possible program designs [17]. Stochastic techniques, such as genetic algorithms, are often helpful in navigating these very large decision spaces [17], and can often generate relatively concise solutions.</p>
<p>Genetic programming comprises a class of evolutionary algorithms for program synthesis, operating on populations of treestructured programs [27]. These algorithms measure the fitness of each population member by some specified metric(s), aiming to re-combine, modify, and improve the performance of population members over multiple generations. The name relates the technique vaguely to biological evolution, though many differences apply; i.e., selection is entirely artificial, mutation is intentional and simplistic, etc. We note ethical concerns with this comparison in Section 6.2.</p>
<p>Researchers have long sought to automatically evolve AI in games. Luke [32] applied genetic programming to evolve AI agents for a robot soccer competition. They used a custom-designed set of functions and operators, requiring a strongly-typed genetic programming approach. This was followed by similar efforts for other simple games [1,15,28], and more recently for high-level strategies in the popular RTS StarCraft [16]. Some researchers evolved linear lists of instructions or rules [43,52]. Most other early efforts were focused on parameter tuning of pre-defined behaviors, rather than generating behavior directly [3,7,49]. More recent attempts have focused mostly on neuroevolution, which evolves the structure and parameters of neural networks [5,18,44,50], or, in one case, on combining reactive planning with search using an evolving evaluation function [35]. Because they used custom instruction sets, parameters, or neural networks designed for a specific game, it would require significant effort to translate these techniques to other games, and the results may not be human-interpretable.</p>
<p>Behavior Trees</p>
<p>Behavior trees are a popular architecture for game AI [6], stemming from the system developed by Isla for the Halo game series [23]. They are tree-structured, making them suitable for visual editing. They provide clear hierarchy and control flow, with internal composite nodes controlling execution, and leaf task nodes to perform the selected behavior. For example, a "Selector" is a composite that runs each of its children in turn, stopping after the first successful child, and "Move to location" might be an example of a task. In many implementations, such as in Unreal Engine 4, decorator nodes attach to other individual nodes and modify their execution or results. For example, a decorator might check for a particular condition, preventing execution of the child otherwise.</p>
<p>2.2.1 Learning from Demonstration. Some researchers have begun to explore learning behavior trees from demonstration [45,47,51]. This has the advantage of requiring less manual specification of objective functions than general search, because demonstrations serve to provide the objective. These methods tend to generate very complex trees that mimic each demonstration, however, and have yet to overcome the difficulty of simplifying the results to a compact and human-interpretable form. Research has shown that designers need detailed control over the final AI behaviors [39], which requires the trees to be concise enough for hand-modification.</p>
<p>Generating</p>
<p>Behavior Trees by Evolution. We are not the first to try building behavior trees automatically using genetic algorithms, though most prior efforts have focused on generating behavior for specific, 2D games with simple and clear goals, rather than on creating a flexible tool for game designers to define their own design goals. Lim et al. [30] evolved small behavior trees to control specific strategic decisions, combining them manually to build an AI to play DEFCON, a strategy game. Perez et al. [40] evolved behavior trees to play Mario. Rather than evolving trees directly, they used grammatical evolution, constraining the structure to "and-or" trees. In continued research, they explored a potential advantage of using behavior trees in evolution: namely, choice over the level of granularity at which to represent conditions and actions [36]. Our work seeks to investigate whether a genetic-programming-based approach can enable evolution in varying 3D environments, with a larger variety of states, actions, and design goals.</p>
<p>Building on this work, several researchers have explored genetic programming for behavior trees in 2D games with simple objectives, such as Mario [8,55] and Pac-Man [12,33], a simple 2D shooter [14], and -with mixed results -for the strategy games Zero-K [19] and a simplified Battle for Wesnoth [37]. Colledanchise, Parasuraman, and Ögren developed a hybrid greedy search and genetic programming-based approach to create an agent for Super Mario [8]. They used genetic programming only to develop sub-trees when greedy search for a single action could not improve fitness. Zhang et al. investigated genetic programming with a modified crossover mutation operator, finding it effective on the Mario benchmark [55] and, with the addition of constraints on the structure (similar to and-or trees [40]), on Pac-Man [56]. Outside of games, researchers have also tested genetic programming for evolving behavior trees to control robots [22,25,48], finding that they can create robust behavior despite uncertainty in action results. These efforts inspire our work to create a tool for evolving behavior trees for varied 3D games in Unreal Engine.</p>
<p>Perhaps the most similar work to ours is by Paduraru and Paduraru [38], who created a framework to evolve behavior trees for 3D games for automated difficulty adjustment. They showed that their framework can develop varied trees, and they used human-in-theloop testing to filter the resulting trees. They did not, however, aim to create a tool for designer-driven, iterative co-creation -focusing instead on player-centric difficulty tuning -and they did not evaluate their results with comparison to hand-designed trees.</p>
<p>Our work differs from these prior efforts in that its intent is not to evolve behavior trees to play a specific game as effectively as possible, but rather to enable co-creative, iterative, design-driven tool support for a flexible exploration of behavior. We aim to put designers in control of the fitness functions, the behavior tree nodes and building blocks, and whether and how the output of the tool is incorporated into the final AI. We also contribute an investigation of the experiential qualities of the resulting behavior, revealing insights on the challenges and opportunities for integrating this approach into modern game engine tools. </p>
<p>EvolvingBehavior Plugin Game</p>
<p>First Trial Setup (First trial) Figure 1: An overview of the process and data flow for evolving behavior trees using the EvolvingBehavior tool. Green nodes represent data configured by the designer, pink represent game-specific steps, and orange represent functionality and data provided by the EvolvingBehavior plugin. Grey arrows depict the flow of data within the plugin, whereas black arrows depict the flow related to the game.</p>
<p>THE EVOLVINGBEHAVIOR TOOL</p>
<p>We created a tool (EvolvingBehavior) for evolving behavior trees, using genetic programming, in Unreal Engine 4. In EvolvingBehavior, a designer sets up and controls an experiment to evolve a behavior tree from a specific, hand-defined starting tree. An overview of this process is shown in Figure 1.</p>
<p>The designer controls the material with which the genetic programming algorithm will build modified trees by providing the initial tree, a library of additional pre-defined nodes, and templates for generating even more unique nodes with variable properties. The designer also controls other parameters and settings for mutation and the evolutionary process. These designer-controlled inputs are shown in green in Figure 1. Note that the initial tree need not be complete or functional -it could even be empty -as the tool will mutate and change it over time, seeking to improve its capabilities.</p>
<p>Though the designer must manage many parameters and decisions, we provide detailed documentation and plan to provide various default configurations to assist them. We also recognize the need for future work to test and improve the usability of the tool, which we discuss in more detail in Section 6.4. To enable a deep integration with the Unreal Engine user interface and allow for such future usability improvements, we chose to implement our own genetic programming system rather than to use an existing implementation. We now describe the technical implementation of the genetic programming process.</p>
<p>Representation</p>
<p>Internally, we translate the built-in Unreal behavior trees into a compact and manipulable tree structure, a "chromosome." This chromosome can flexibly store references to specific, pre-defined nodes (mapped nodes) or to templates for generating nodes with properties that may range over various values (generated nodes). We can then store, copy, and manipulate these chromosomes using the mutators to build a new generation.</p>
<p>The designer provides "mapped" nodes using Unreal's built-in behavior tree editor. The system translates these into chromosome form by simply tracking each as a unique identifier.</p>
<p>We also provide the ability to specify "generated" nodes, which are templates for creating a particular type of behavior tree node with random values for specific properties (variables). For each type of property -integer, floating point number, boolean, and blackboard variable -the tool provides an interface for specifying the range of possible values. (A "blackboard, " in this context, refers to a set of variables of various types that the behavior tree can access and modify to track its state for a specific agent.) When generating a new node, the tool stores in the chromosome a serializable representation of the names and associated values for that node's properties. These can then be translated back into properties of Unreal behavior tree nodes using reflection.</p>
<p>Measuring Fitness, Flexibly</p>
<p>Another area in which our system must provide designer control and flexibility is in measuring fitness. This is perhaps the most critical part of the system, the aspect that determines whether the results are helpful. After all, if the genetic programming is optimizing towards, say, ensuring that the agent survives, but the designer wants the agent to disregard its own safety in favor of attacking the player, the resulting behavior trees will be ill-suited for their task. Thus, no single fitness measure will suit every game, and each game must define its own.</p>
<p>Rather than prescribing a set fitness function, we provide developers with an event-driven architecture for defining their own. They define a key for each desired fitness measurement. Then, they send events to update the value of that fitness measure for each agent. At the end of the simulation, we compute a linear combination of the fitness measures with designer-defined weights. Moreover, this linear combination is only the default method of measuring fitness; it can be replaced, if necessary, to suit the needs of a particular game.</p>
<p>One important aspect of fitness that most games will share is a negative modifier for the complexity of the tree. Using tree size as a fitness penalty is one of the simplest ways to control "bloat:" growth of unnecessarily complex, often unused structures in the genetic program over many generations [42]. Bloat makes the resulting output less human-readable, which is clearly a problem if our goal is to suggest improvements to hand-built systems. We therefore give designers easy access to tree complexity, measured by the number of nodes, as a component of fitness.</p>
<p>Selecting Parents</p>
<p>After measuring each agent's fitness, we must select parents for the next generation. Specifically, we should select high-fitness parents more often, a process known as fitness-proportionate selection. We use a well-known selection scheme called "tournament selection. " Tournament selection is simple to implement, and it works with any fitness values, including negative fitness [41].</p>
<p>To perform tournament selection, we first choose k members of the population at random. Then, we select the one with the best fitness as the final parent. The tournament size, k (4, in our experiments), determines how strongly the tournament selects for higher-fitness members of the population, and thus how much diversity will be lost in the next generation [4]. The combination of simplicity, tunability, and input range resilience makes tournament selection a strong choice for a behavior tree evolution system, because it puts designers in control of the system without restricting them to a particular range for fitness scores.</p>
<p>Though some genetic programming systems separate parent selection from pruning the population, we chose to combine these two steps by replacing the entire population for each new generation. We do, however, retain a few of the most promising agents from the prior generation by elitism, which means copying the top-n% most fit individuals directly to the next generation, unmodified. We hope, in this way, to avoid losing information about the most successful individuals due to random mutation, and to help reduce bloat.</p>
<p>Reproduction and Mutation</p>
<p>Once we have selected two parents, we produce a new child for the next generation. We begin by copying the primary parent exactly. Next, we may perform crossover and/or one or more point mutations to modify the child. In many genetic programming systems, the system performs at most one type of mutation per child, chosen probabilistically. Often, there is a significant probability of performing no mutation at all [41]. In our system, we instead chose to allow multiple mutation types to be applied, with a separate probability for each. We wanted to give designers more control over the mutation rates, without requiring them to worry about the precise total probability.</p>
<p>3.4.1 Crossover. Crossover, in its most basic form, simply takes any random subtree from the child and replaces it with a random subtree from the second parent. Unlike in genetic algorithms with linear genetic codes, it is difficult to find a corresponding point on both individuals, so we do not require the subtrees to be related in position, or even size [41]. Koza suggests that, because there are many more leaf nodes than internal nodes, there should be a bias towards selecting internal nodes as crossover points. This will increase the average amount of the tree that is swapped, causing a larger effect on behavior [27]. In this work, we chose to use a crossover operator that chooses a node from a specific tree depth, where the depth is selected with uniform probability. This has been argued to be more effective than Koza's original crossover strategy [24], though there may be even more effective options we can explore in the future for crossover with non-uniform probability over the various tree depths [54].</p>
<p>Point Mutation.</p>
<p>Among the many possible mutation operators, we chose to implement several types of point mutation: replacing, adding, or deleting a randomly selected node. In traditional genetic programming, these are often applied in a walk through the entire tree, where each node is mutated with some small probability [41]. In the current version of our system, we instead apply a random point mutation to a single node in the tree, if this mutation type is probabilistically selected.</p>
<p>We also provide point mutation operators for individual properties of generated nodes. Currently, we provide Gaussian perturbation mutators for floats and integers, with designer-specified standard deviation as a percentage of the current value (10% in our tests). For boolean and blackboard variable properties, the mutator randomly selects a new value from among the available options.</p>
<p>EXPERIMENTS</p>
<p>We performed a test of EvolvingBehavior by integrating it with the "Epic Survival Game" sample game by Tom Looman [31], and using it to evolve AI functionality for the simple zombie-like enemies. In this sample game, the player controls a 3D character using an over-the-shoulder style standard for the 3rd-person shooter genre. The player must survive for as long as they can in a level populated with simple zombie-like enemies. The enemies, in the standard game, can patrol a pre-set route, notice the player through sound or vision, and chase the player. If they get near the player, they cause damage. If they do 100 damage, they cause the player to "die" -in our tests, we set the players to then re-spawn after 2 seconds in a new random location. The player can shoot the zombies, and if they do enough damage, the zombie will "die. "</p>
<p>Outside the behavior tree, the zombies' code tracks the nearest detected player using the blackboard. Thus, the tree needs only to determine actions, not to perform perception or target selection.</p>
<p>Modifications to EpicSurvivalGame</p>
<p>We created a simple "human character" behavior tree to stand in for the player characters. Approximately every half a second, it randomly selects a point near the character to move to, preferring points further away from zombies, visible to the character but not to the zombies, and closer to the current heading of the character. In this way, the characters randomly wander and avoid enemies. We also added the concept of stamina, which allows the player stand-in characters to run more quickly for a brief time when first being chased, before needing to slow down and recover. This requires the zombies to chase persistently in order to catch players.</p>
<p>To test EvolvingBehavior, we modified two maps included in "Epic Survival Game, " one a small and walled-in space with many obstacles shaped like boxes and shipping containers (the "small map"), the other a larger and more open "outdoor" setting (the "large map"), with only a few large rocks and buildings, as well as some trees, as obstacles. We created a third "medium map" by duplicating the small map, copying the space and obstacles four times, and removing the walls between the copies.</p>
<p>Experiment Setup and Parameters</p>
<p>For the initial behavior tree, to simulate the process of improving on a partial tree created by a human designer, we intentionally removed functionality from the zombie behavior tree originally included with "Epic Survival Game." Specifically, we removed all nodes that allowed the characters to patrol and to chase the player, leaving some of the structure of the tree intact, but not enough for the characters to move in any way.</p>
<p>We set the initial population to use 10 iterations of random modification, such that at least one point mutation would occur with approximately 40% probability, and crossover with 40% probability. We provided the same mutators for the normal reproduction for each following generation, but halved to 20% probability (specifically, 1.84% for each point mutator, creating approximately a 20% chance of at least one of the 12 point mutators being selected:
(1 − ) 12 = 0.8 =⇒ ≈ 0.0184).
To determine these, we first tried a grid search over crossover and point mutation rates of 10%, 20%, 40%, and 80%, finding that 10% created the most stable results. Additional experimentation, however, revealed that 20% tended to generate improvements faster with acceptable stability. We use an "elitism" rate of 12%, determined by preliminary experiments to provide a reasonable tradeoff between preserving strong agents versus retaining population variety.</p>
<p>We set fitness functions as shown in Figure 2. These piece-wise weighted linear fitness functions were determined by preliminary experimentation to reward zombies for moving and patrolling around the map, for chasing and doing damage to humans, and for searching near the last-known target location if they lose track of them. The fitness functions were also designed to penalize the zombies for failing to move, and for rapidly losing and re-starting a chase too many times (we detected the start and ending of chases based on consistent movement at an angle towards and within a short distance of a player, or the lack thereof). This latter penalty was based on research that found that designers would intentionally prevent NPCs from repeatedly chasing a player too frequently [39]. We also added a penalty for too complex or too simple a tree, to help reduce both bloat and the likelihood of trivial trees that would take too long to re-build into more complex behavior. The full calculations of these functions can be found in supplementary material 3 .</p>
<p>Next, we evolved agents using the above parameters, on each of the three maps, each with three different numbers of human characters (3, 6, and 12), for a total of nine experimental conditions. We set the number of zombies in the population as follows: Small had 20 zombies, Medium had 50, and Large had 40. These conditions were chosen to provide a variety of densities and conditions in which to evolve zombie behavior. Note that we used the same fitness function across all experimental conditions, whereas a game designer might choose in practice to tailor the fitness function more specifically to the map and number of agents involved -we discuss the results and importance of these choices in Section 6.</p>
<p>We provided a variety of behavior tree nodes, both mapped and generated, for the evolution to use -nodes from the original zombie behavior tree from "Epic Survival Game," such as nodes that would select random patrol points and move to them using Unreal's built-in pathfinding logic; as well as variations on other built-in Unreal behavior tree nodes, such as wait timers, decorators and actions for rotation or angle between objects, and movement directly towards a specified object or location (rather than full pathfinding). We intentionally included some less-effective nodes in order to test the evolution's ability to improve on partially-working behavior. To support the additional fitness rewards for searching near the last known location of a player after losing track of them, we also provided nodes to find a location near that point, and to intentionally forget that location. In total, we provided 8 mapped and 4 generated decorators, 13 mapped and 5 generated tasks, and the standard 2 types of composite nodes (selectors and sequences). We did not use service nodes in this experiment, though they are supported by the tool. The full set of nodes and detailed parameter settings can be found in supplementary material.</p>
<p>We chose to run evolution for 1000 generations, twice the number in the initial grid search, because this was generally past the point where fitness improvement plateaued in preliminary testing. We used 15x game speed and 90 seconds of simulated in-game time (6 seconds of real time), which was the same as the grid search and provided a reasonable trade-off between computation time and fidelity of gameplay. We chose to select a single resulting behavior tree from the many options created during evolution by finding the generation with highest average fitness, and selecting the highestfitness behavior tree from that generation. We chose this strategy based on its general success in finding high-performing trees in our preliminary experimentation, but other strategies would certainly be possible -for instance, selecting the highest-fitness tree from the last generation. Future research on co-creative tools could explore various strategies, such as enabling the designer to test various high-fitness trees to find one that meets their design goals.</p>
<p>We performed three runs of the evolution with different initial conditions, and averaged the results of the fitness comparisons between the three resulting trees for each condition. We chose to use this small number of runs due to the significant time required for each, and to limit the number of resulting trees so that we could manually inspect and qualitatively evaluate them over all nine experimental conditions. We believe this is also consistent with how a designer might use the tool -they would not likely choose to re-run the evolution process many times, as this would lengthen iteration times and increase the complexity of sorting through the resulting behavior trees. We further discuss the limitations of this experimental design in Section 6.3 below.</p>
<p>Comparison With Manual Design and Random Baseline</p>
<p>For comparison, three researchers created behavior trees manually, attempting to create behavior to meet the design goals as expressed by the fitness function. One researcher (R1) had experience creating game AI as a programmer at a game studio; the other two (R2 and R3) had no significant prior experience creating behavior trees. R1 briefly explained to R2 and R3 the general concepts and specific operation of behavior trees in Unreal Engine. We also created behavior trees using a "random baseline" algorithm, which was the same as the standard evolution, except that parent selection was replaced with reproducing and mutating all trees from the previous generation, without any regard for fitness. All other settings were the same as for the evolved trees, as was the selection procedure to choose the final "best" tree from each run. Thus, the random baseline starts with and acts on the partial initial trees in the same manner as the evolutionary algorithm, but without the direction provided by a fitness function, enabling direct comparison of the results of the two algorithms.</p>
<p>We compared the fitness for the trees in each experimental condition, comparing the manual behavior trees, and the random baselines and evolved trees from the specific condition. We created the population of zombies using only the specified tree, and ran 100 trials without any changes to the trees (each trial being similar to fitness testing for a single generation in the original evolution), then averaged the results over all individuals and trials. We chose to run these fitness tests at 10x game speed to allow more computation time and thus provide a more accurate estimate of the fitness.</p>
<p>The code is written in C++ and Unreal Engine Blueprints, and compiled with the Unreal Build System. To evolve the trees, we used a single computer with an Intel i7 4810MQ procesor, 32 GB of RAM, and an NVidia GeForce 980M graphics card, running Windows 10. For the fitness tests, we used a separate computer with an Intel i7 8700K processor, 32 GB of RAM, and an NVidia GeForce 2070 graphics card, running Linux. Because the fitness testing was independent from the evolution, performance differences between the two computers have no impact on the results. Each evolutionary process of 1000 generations completed in approximately 2-3 hours, and fitness tests within 20 minutes.</p>
<p>Qualitative Evaluation Method</p>
<p>This experiment has a relatively small sample size compared to many evolutionary algorithm experiments. Moreover, the goal is to show that evolution can produce similarly-capable behavior trees to human designers, rather than superior trees. Finally, we can only quantitatively measure the performance on a defined fitness function, which may not precisely match the human perception of behavior -creating a fitness function that precisely encapsulates design goals is known to be a difficult problem [11,29]. This all combines to challenge the relevance of standard statistical comparison techniques for evolutionary computation for this work. Thus, we chose to also perform a qualitative evaluation.</p>
<p>For our qualitative evaluation, two researchers (R1 and R4, one of whom had created a behavior tree for manual comparison, and one who had not) observed the zombies using the manual, random baseline, and evolved behavior trees in action against the human character AI, in the same scenarios in which the fitness comparisons were performed, but at normal game speed. We chose three conditions for this evaluation, such that each map and each density of human characters was represented. The researchers also played against the zombies directly. They wrote journals about their experiences and observations during and after these sessions.</p>
<p>Finally, R1 manually examined the behavior tree code, attempting to understand the reasons for the behavior. The two researchers then discussed their observations, and collaboratively summarized the results. We recognize the limitations of researchers acting as the game designers for this study and the need for future study with external designers, as discussed below in Section 6.3.</p>
<p>RESULTS</p>
<p>Quantitative Fitness Comparisons</p>
<p>In Figure 3, graphs show the average fitness over time for all runs of the Evolved and Random Baseline on the Medium Map, with 50 zombies and 6 humans, experiment setting. Due to space limitations, we provide the full fitness data from all runs in supplementary material 4 . The average fitness over time ceases to show further improvement well before the end of the 1000 generations.</p>
<p>We performed a quantitative analysis to compare the fitness results for each algorithm. Descriptive statistics for the algorithms are shown as box plots in Figure 4. Because evolutionary algorithms do not generally result in scores that are normally distributed, we chose to use non-parametric statistics as recommended by the literature [10], specifically the Friedman signed-ranks test, which found significant differences among the algorithms ( = 28, = 4, &lt; .0001), with a large effect size (Kendall's W = 0.778). Therefore, we performed an all-pairs post-hoc test to determine which pairs of algorithms showed statistically-significant separation in fitness (because of its precise p-value calculation, we chose to use the test by Eisinga et al. [13]). To adjust the post-hoc test for multiple comparisons, we used a Hommel correction (as discussed by Derrac et al. [10]). The results of the post-hoc test are shown in Table 1.</p>
<p>Some statistically significant pairwise differences are shown by the post-hoc tests: between the Random Baseline and ManualR1 (p &lt; 0.05), ManualR2 (p &lt; 1 − 07), and ManualR3 (p &lt; 0.01), and between ManualR2 and Evolved (p &lt; 0.05). As a note, ManualR2 used a custom behavior tree node that was not available to the evolved behavior trees, as it combined selecting and moving to a random point nearby. We chose not to provide this node to the evolving behavior trees because it combined two functions (selecting a random location and moving there using full pathfinding) that would trivialize the implementation of random wandering behavior.</p>
<p>Qualitative Evaluation</p>
<p>Two researchers (R1 and R4) evaluated the behavior trees for three of the nine conditions (Medium Map 50v3, Large Map 40v6, and Small Map 20v12), selected for variety, as described in Section  </p>
<p>4.4.</p>
<p>We present a summary of their findings, with relevant quotes. Figure 5 shows some of the trees discussed below. Note that there are only three Manual behavior trees in total, but there are separate Evolved and Random trees for each condition. When we refer to, e.g., "Evolved0," in Medium Map 50v3, we mean the evolved tree  Table 1: Results of the all-pairs post-hoc test, showing the probabilities that the trees generated by each pair of algorithms have significantly different fitness. Asterisks indicate level of significance: * significant with p &lt; 0.05, ** significant with p &lt; 0.01, *** significant with p &lt; 0.001 selected from the first run of that specific condition, and it is a different tree from, e.g., the "Evolved0" in Large Map 40v6.</p>
<p>In all three conditions, the three Manual trees exhibited mostly similar behavior. With all three, all zombies randomly walked around (sometimes walking, sometimes jogging) until they observed a player. When they spotted a human character, they immediately stopped wandering and chased that character. If they lost track of the human character, they resumed wandering. All were able to avoid static obstacles, though they sometimes ran into other zombies, especially in tight passages.</p>
<p>There were two noticeable differences between the specific behaviors of the three Manual behavior trees: in the distance and  rapidity of wandering, and in their behavior when losing track of a player. ManualR1 zombies would "stay near the place where they lost track, moving in a small radius and changing direction frequently (with a second's pause between each direction change), for 5-10 seconds" (R1), after which "they return to longer-distance random wandering" (R1). ManualR2 and ManualR3 (Figure 5b) zombies, on the other hand, would "immediately turn around and move away (walking speed) in another direction" (R1). ManualR1 and ManualR3 zombies tended to wander "fairly long distances before changing direction" (R1), whereas ManualR2 zombies would move a more variable distance before pausing and changing direction. ManualR1 and ManualR2 paused between direction changes when wandering (ManualR2 tended to pause longer); ManualR3 did not.</p>
<p>Inspection of the code showed that ManualR2's wandering behavior was controlled by a custom node, which used a random radius for selecting points to wander to, whereas the other trees used "find waypoint" and "find patrol location" nodes to find random hand-placed points on the map to move to, explaining the behavioral differences. Only ManualR1 used the "find point near last known player location" to wander near the last place a player was seen after losing track of them, which explains the difference in behavior in that instance.</p>
<p>Medium Map 50v3.</p>
<p>In this condition, all Random Baseline zombies stood completely still until they observed a human character. In two cases, Random0 ( Figure 5a) and Random1, they would chase humans after noticing them in a manner fairly similar to the Manual trees (though Random1 would more easily get stuck on obstacles). Zombies using the Random2 tree were much less effective in chasing -they would move towards a location relatively close to the human, but usually stop before reaching them. R1 wrote, "If I made even a little effort to move away, they would fail to follow (but would slowly walk around a little where I left them)," noting that they moved intermittently after losing track of a player. R4 wrote, "There was very little patrolling behavior exhibited in the randomly generated tree and zombies seemed to only move in the presence of humans, but would remain stationary otherwise. " Random0 and Random1 ceased moving as soon as they lost track of a human.</p>
<p>All three of the Evolved trees exhibited behavior fairly similar to the Manual trees: the zombies would wander randomly through the map, immediately turning to chase any humans they noticed. In two cases (Evolved1 and Evolved2, which is shown in Figure 5c), the zombies would often run into obstacles while chasing: R1 wrote, "I could lose zombies by getting them stuck on obstacles. " Evolved0 did not have this problem, and were very similar to ManualR3 in their behavior. R1 noted a difference from ManualR1's behavior, in that after losing track of the human "they did not stick around as long -seemed to lose interest immediately after." R4 agreed that the Evolved trees were similar to ManualR3, saying, "The behaviors between the evolved tree and this [ManualR3] tree were very similar", the only difference being that "there is no fixed patrol area for [the Evolved] zombies, it seems as though in their patrol state, they simply move from spot to spot instead of revisiting an area that has been checked already." This latter difference might be explained by the presence of nodes to "find patrol location" and "move to" that location in the ManualR3 code, which adds a random offset to the manually-placed waypoints, whereas the Evolved trees moved to the waypoints directly.</p>
<p>Inspection of the code revealed that all three trees had evolved structures that effectively switched between chasing (as the top priority) and moving to a random waypoint, though Evolved1 and Evolved2 used the less effective "move toward" node to chase (which does not pathfind to avoid obstacles), and none used the "last known enemy location" to patrol near the last place they saw a human.</p>
<p>Large Map 40v6.</p>
<p>As in Medium Map 50v3, all Random Baseline zombies only moved when chasing a human. R4 wrote, "Similar to the observations in the medium map, the evolved trees led to zombies constantly patrolling areas in search of humans, while the random baseline trees again would chase enemies that made noise around them." The Random zombies were less effective in chasing than the Manual ones: "[Random0] Zombies sometimes get stuck behind an obstacle while chasing, just running into it" (R1). Random1 and Random2 also appeared to lose track of humans more easily, even if the human just changed angles abruptly. R1 wrote, "When chasing, [Random1 zombies] appear to stop/pause slightly before reaching the human character, or go to where the character recently was rather than chasing to where it is now. " Inspection of the code revealed that Random1 and Random2 used a node to move to the "last known enemy location" as their primary mode of chase, rather than moving to the currently observed enemy position, and Random0 used the "move toward" (non-pathfinding) node type.</p>
<p>In two of the three cases (Evolved0 and Evolved2), the Evolved trees were clearly more effective than the Random trees, exhibiting fairly similar behavior to the ManualR1 and ManualR3 trees. Evolved1, however, only patrolled randomly, with no chasing: "The zombies totally ignore me" (R1). Evolved0 was more likely to get stuck on obstacles, but Evolved2 was not: "It's very hard to lose them, even if I go around a corner or obstacle, they often follow me effectively [...] They feel very similar to ManualR3 to play against" (R1). R4 noted that the Evolved2 zombies "tended to keep moving forward in a straight line until either they find a new player to chase or they end up near the very outskirts of the map," a difference from ManualR2, which changed directions more often.</p>
<p>R4 noticed that the evolved trees tended to lose track of the human if they crouched. This was notably different from the random trees, which would simply stop moving and continue attacking if the human was still nearby -but the detection logic and the logic for dealing damage (which just checks if they are close to the human) are both handled outside the behavior tree entirely. We further discuss this question of division of responsibility between behavior trees and other parts of the NPC logic in Section 6. Inspection of the code showed that Evolved0 used a "move toward" node for chasing, whereas Evolved2 used a "move to, " and Evolved1 only used nodes that find and move to random waypoints.</p>
<p>Small Map 20v12.</p>
<p>In this condition, none of the Random nor Evolved trees exhibited any patrolling behavior. They all focused solely on chasing. There were only a few minor differences in behavior: Random0 "get stuck behind a barrier while chasing me sometimes" whereas Random1 and Random2 are better at avoiding obstacles. Inspecting the code, Random1 and Random2 used "move to" nodes (which perform pathfinding), whereas Random0 used a "move toward" (which does not). The Random trees had only 2-3 relevant nodes in their behavior trees (a selector or sequence, and chasing node), with 8, 11, and 12 nodes that appeared irrelevant to the behavior, respectively.</p>
<p>Evolved0 exhibited the only notable movement when not in sight of a human: they "appear to move slowly around the last place they saw a player sometimes" (R1). R1 wrote that Evolved1 "get stuck behind obstacles fairly often," whereas Evolved2 "feel better at avoiding obstacles and chasing me around corners. " R4 also noticed that Evolved2 was more similar to the Random1 and Random2 in avoiding obstacles, and that the Evolved2 zombies would attempt to haltingly move around the obstacles even if they did get stuck. Inspecting the code, Evolved1 and Evolved2 were less wasteful, with 4 and 5 apparently irrelevant nodes respectively. Evolved0 had only 3 relevant nodes of 15 (10 irrelevant nodes were decorators on the root node that did not appear to affect the behavior). However, Evolved0 used a "move to last known enemy location" node, which caused its aforementioned unique movement behavior.</p>
<p>DISCUSSION</p>
<p>The quantitative results are not sufficient to understand the performance of the evolution by themselves. Though the tests did not find a significant difference between the Evolved trees and the Random Baseline, they also did not differentiate the Evolved trees and the human-designed ManualR1 and ManualR3 trees. This indicates that the non-parametric statistics (which rely only on the ordering of the results, not the magnitude of the differences) were not powerful enough to truly differentiate the algorithms with a sample size of 9 experimental conditions, so we explored the data and trees in more detail to determine whether there were, in fact, clear differences.</p>
<p>Inspection of the boxplots shows that the evolved trees had a clearly higher median score (434, IQR 590) than the random baseline (-598, IQR 1026). In fact, one IQR below the Evolved median is still higher than the Random Baseline median. This gives us some confidence from the summary results alone that there is a clear difference between the Evolved trees and the Random Baseline.</p>
<p>In 6 of the 9 conditions (Large Map 40v3 and 40v6; Medium Map 50v3, 50v6, 50v12; and Small Map 20v6), the Evolved trees have much higher fitness than the Random Baseline -in them, the gap in average fitness between the Evolved and Random Baseline trees ranges between 559 and 1912 (mean 1464, std. dev. 541). This indicates that in these 6 conditions, the Evolved trees developed clearly better behavior in at least one of the runs, and often more.</p>
<p>There are no cases where the Random Baseline outperformed the Evolved trees. One of the conditions where the difference is less clear, Small Map 20v12, had the highest ratio of human AI to zombies, and fitness results for the Random Baseline were relatively close to those of the human-designed trees. Due to this small fitness difference and the stochasticity of the evaluation, it is likely that evolution had trouble differentiating behavior trees. This indicates that a single, static fitness function may not be sufficient for all conditions -in practice, a designer would likely choose to tailor their fitness function to the specific map and scenario.</p>
<p>The other two conditions that did not show clear differences were Large Map 40v12 and Small Map 20v3. It is somewhat less clear why these did not produce clearly effective trees -aside from the fitness function, another possibility is that population sizes were not large enough to maintain diversity, or the behavior settled in a local maximum. It is possible that more mutators might help -perhaps a subtree-growth mutator, which creates an entire random subtree at once, rather than relying on individual nodes being added by point mutations (which might have no immediate effect by themselves, and thus their genes may fail to reproduce before their use can be discovered). We suggest other ideas in subsection 6.4.</p>
<p>In one condition (Medium Map 50v6), the Evolved behavior trees had higher fitness (avg. 521) than both the ManualR3 (262) and ManualR2 (397) trees. In one other condition (Medium Map 50v3), the Evolved trees (avg. 356) outperformed the ManualR1 tree (127). Though these differences are much smaller than those between the Evolved trees and the Random Baseline, so we cannot claim that they represent clearly better behavior, this does indicate that either the Evolved trees were sometimes equivalently successful to the human-designed trees, or that our fitness function did not capture our precise design goals sufficiently to differentiate them. To determine which, we turn to the qualitative evaluation.</p>
<p>Our qualitative evaluation supports the quantitative evidence that the Evolved trees were more effective than the Random Baseline -and that the best Evolved trees were similar in many ways to the Manual trees, especially to ManualR3. It also illuminates particular behavioral differences (in both directions) that are relevant to the design goals. Specifically, in Medium Map 50v3, all three evolved trees exhibited intelligent transitioning between random patrolling and targeted chasing of players in a similar manner to the Manual trees, as did two of three in Large Map 40v6. None of the Random trees achieved such complex behavior, in any condition investigated -they could only chase (or in the case of MediumMap 50v3's Random2, move slowly around the last seen player location).</p>
<p>While the Evolved trees were not perfectly efficient (usually including a few nodes not clearly relevant to the behavior), they were all manually inspectable, using a manageable number of nodes. In practice, the best Evolved trees could be further pruned, tweaked, and iterated upon by a designer (by hand and/or by being used as a starting point for further evolution). Even in the less successful Small Map 20v12 condition, the Evolved trees were mostly more parsimonious than the Random Baseline trees.</p>
<p>In Small Map 20v12, neither the Evolved nor Random trees exhibited random patrolling, but this was the condition where there were so many humans to chase that patrolling was unnecessary for high fitness. We expect that, in practice, a designer would choose to use a different ratio of humans to zombies, or to adjust the fitness function appropriately, making this condition the least representative of real use of the tool. This does further support, however, the observation that defining an effective fitness function is important and potentially difficult for designers. In this and other Small Map conditions, the small population size may also have led to low chromosome diversity. Replicating maps to allow larger populations, or testing many individuals over time rather than spawning all members simultaneously, might improve diversity. Quality-diversity algorithms [34], or other non-population-based methods, could also be explored in future work to ameliorate this.</p>
<p>This difficulty of fitness function definition is further supported by the fact that none of the most successful Evolved trees replicated ManualR1's patrolling near the last known player location. However, ManualR1 was less effective (by median fitness over all conditions) than ManualR2, and was not clearly more effective than ManualR3 -and the latter two only used random patrolling. Therefore, we posit that our fitness function was not tuned effectively to encourage patrolling near the last known enemy location (despite our attempt to reward that behavior). If we, as researchers creating the tool, have trouble defining the fitness function to match our design goals, we expect designers may likely have similar trouble. We expect this to be an important avenue for future research.</p>
<p>Implications for Co-Creative AI Design</p>
<p>This study also illuminates specific implications for developing co-creative AI design tools and raises questions for future research. First, the qualitative evaluation provides some insight on potential methods for choosing behavior trees from the results of the evolution. We used the strategy of selecting, from each run, the highest-fitness behavior tree from the generation with the highest average fitness. This produced several trees which exhibited reasonably similar behavior to our manually-designed trees but implemented that behavior in several different ways.</p>
<p>As researchers, we were able to manually evaluate these trees, understand their differences in behavior, and compare to our design goals. By presenting several options for designers to test, modify, and iteratively evolve, we believe we can build a mixed-initiative AI tool that retains full designer control over the resulting behavior -though further user testing is necessary to determine the most effective modes of interaction for game designers. Speed of iteration is one particular concern that will require future study, as simulating gameplay over many generations can be very time-consuming.</p>
<p>Additionally, some evolved trees had more extraneous nodes, some fewer -comparing fitness relative to tree size might allow us to filter to the most parsimonious trees, or post-processing (perhaps using static analysis for unnecessary nodes, similar to [8]) might allow further improvement of the trees before presenting them to the designer. We could also explore alternative methods of selection, such as using tree difference algorithms to search for varied (but high-fitness) trees, manual testing of a variety of trees (as in [38]), or quality-diversity based approaches [34].</p>
<p>This study further reinforces the known challenge of finding appropriate parameter settings for the evolutionary process -Poli, Langdon, and McPhee note that, while genetic programming is often fairly robust, it does require tuning for each individual application [41]. These parameters, such as mutation rates, number and size of generations, tournament size for parent selection, elitism, and the like, were not always obvious. Mutation rates, for instance, were not necessarily correctly selected by a grid search -we ended up doubling them for the final experiment after further testing, due to the initial grid search being biased towards stability over innovation. Co-creativity will likely further complicate this, but may also provide new opportunities for addressing these difficulties. Designers have expressed the need for "sensible defaults" and hiding of unnecessary complexity in prior research [39], which indicates the need to provide various default parameter settings, contextualized with the designer's goals. For example, a co-creative AI design tool could provide settings with low mutation rates designed for "finetuning," and suggest those when the designer indicates that they are already mostly satisfied with a behavior tree, whereas it would suggest higher mutation rates for initial exploratory work.</p>
<p>Beyond parameter settings, the study also shows the importance of selecting component parts (e.g. nodes and mutators). One significant difference between the behavior of the ManualR2 and Evolved trees was the manual tree's use of a custom node that combined selection of and movement towards a random nearby destination. By controlling the level of granularity of the behavior tree nodes and the parameters to be tuned inside them, and iterating on the set of available behaviors, designers may be able to further improve and customize their NPCs. This may require some specific AI design knowledge, however, which a co-creative tool may need to help the designer acquire. Selecting specific mutators may be another area in which this expertise will need to be taught -and there are mutator types in the genetic programming literature, such as subtree-growth mutators [41], that we have not yet explored.</p>
<p>Finally, there are some aspects of non-player character behavior that, depending on the game, may not be included in a behavior tree at all, or that could be better handled in other architectures. For example, in "Epic Survival Game," the perception, tracking, and selection of a target to chase was handled entirely in code outside of the behavior tree, as was damaging the player. In other games, attacks might be triggered by task nodes in the behavior tree. High-level decision-making logic for choosing behavior may also be handled outside the behavior tree in some games, e.g. [35]. This may mean that co-creative AI design tools cannot rely purely on genetic programming to evolve behavior trees if they wish to assist the designer with all aspects of the NPC design process. It may be necessary to apply genetic programming to additional architectures such as finite state machines, or to add other techniques more appropriate to those other control structures and types of logic.</p>
<p>Ethical Considerations</p>
<p>While studying tools for AI in games may seem relatively benign at first glance, there are several areas for ethical concern related to this work. First, behavior trees are also used in robotics and simulation applications, some of which have been applied in military contexts [21]. EvolvingBehavior, however, is expressly created for application only to games, and we have not investigated any ethical controls nor considerations concerning its use in any serious real-world context -nor especially in life-or-death situations. As a first effort towards preventing such misuse, the published version of this tool includes a statement that it may not be used for military, intelligence agency, and law enforcement uses. We also recognize the need for more comprehensive discussion and action to prevent misapplying games research (as per Cook [9]).</p>
<p>Additionally, we propose AI tools that directly impact how game designers work. We must consider the context of that work: game developers are often over-worked, laid off, and otherwise abusedespecially developers of marginalized identities [46,53]. Our goal is to create a tool that does not replace game designers, nor reduce their agency. Intentions, however, are not enough -we must design features in collaboration with designers, empowering them to decide how the tool should improve their work. We should ensure that our tools specifically require and support designer creativity, and without promoting surveillance of designers, nor misuse of their outputs or data. We should also join with game developers to collectively advocate for better, safer, and healthier working conditions, more stability and support, and the end of abusive practices.</p>
<p>Finally, we should be careful to separate the metaphor of evolutionary algorithms from real evolution in nature (i.e., parent selection is entirely artificial and arbitrary, genes and mutation are simplistic and not directly informed by natural mechanisms, etc.). In this work, we artificially select and modify AI agents based on a "fitness" function, using common metaphors from genetic programming. This must not, however, be confused to condone application of artificial selection to people, especially as evolutionary algorithms research has, in fact, occasionally used eugenics as a metaphor (e.g. [20]). We do not have space here to fully explore this topic, but we call for future work to further clarify the separation between evolutionary algorithms and real evolution, and to push back against eugenicist metaphor in genetic algorithms research.</p>
<p>Limitations</p>
<p>There are several limitations of this study. First, and most importantly, we as researchers acted as designers in this study. Though at least one researcher has significant game development experience, our primary day-to-day work is not as game designers. The researchers also have significant prior knowledge of the tool, its capabilities, and its limitations. This prior knowledge impacted our design goals and expectations for the trees. This was important for this preliminary study, as it allowed us to deeply interrogate the capabilities of the tool and underlying evolution technology. However, it leaves for future work a true user study with independent game designers to determine the tool's usability and capability of working with them in a co-creative design process. Of particular concern are the modes of interaction with the tool: understanding and tweaking parameters, defining and tuning fitness functions, setting up and iterating on test environments, etc. It will be especially important to include in future study designers who have less experience directly implementing game logic in code.</p>
<p>Additionally, our experiments comprised a relatively small sample size of three runs each of nine experimental conditions, all of which were partially related to each other (in that they shared goals and game design, and the medium map was modified from the small map). We therefore could not establish statistical significance of the difference in several treatments' average fitness function scores using non-parametric statistics. However, as noted in Section 4.2, these experimental design choices enabled the qualitative evaluation, which provides a more detailed analysis of the results.</p>
<p>The tested game itself was also relatively simple, and was designed as an example, not for widespread play. This limited the complexity of the behavior trees: the agents did not need to engage with some common mechanics in 3D action games, such as finding or using items, or being distracted or hampered by players. Even within this limited gameplay, our qualitative evaluation does reveal clear differences between algorithms and behavior trees. However, future work should expand the variety of game environments and design goals tested, to further support the utility of this tool and discover any limitations as behavior tree complexity increases.</p>
<p>Future Work</p>
<p>We discussed the potential for exploring the addition of new types of mutators, such as subtree-growth mutators, to potentially improve the diversity of the population and avoid local maxima. Another option for avoiding local maxima might be quality-diversity algorithms, which could potentially keep more varied trees in the population [34]. These algorithms have been used for procedural content generation in games [2,26], and might well be applicable to this problem as well.</p>
<p>Above, we discussed the importance and difficulty of defining effective fitness functions to match the design goals for the game. We believe this will be an important question for future research, requiring careful user interface and/or domain-specific language design, and potentially benefiting from further visualization support. For this problem specifically, and for the general utility of the tool more broadly, we believe it will be crucial to involve designers directly in the design of the tool through participatory design, codesign, and usability testing methods. Relatedly, we noted the need for future research on defaults and tradeoffs for various parameters, inputs and behavior tree design choices, and types of evolution.</p>
<p>We also call for future work that explores the combination of behavior tree evolution with other architectures, generative methods, and AI techniques, to provide flexibility and support to designers in defining perception, decision-making, and action for NPCs outside of behavior trees. There may also be opportunity for testing the generalizability of evolved behavior trees across contexts: between multiple maps or levels, or -perhaps with additional evolution for fine-tuning -even across game modes or similar games. It will be particularly important to investigate all of these in the context of solo or small-team game development, where designers may not have access to sufficient game AI engineering support.</p>
<p>CONCLUSION</p>
<p>In this work, we have described EvolvingBehavior, a novel tool for evolving behavior trees in Unreal Engine. Through experimentation, with researchers acting as game designers, we explored in detail the capability of this tool to modify and generate behavior trees that acted to meet specific game design goals. We found that, in appropriate conditions, the tool was capable of evolving NPC behavior that was noticeably similar to our hand-designed behavior, though with some differences and variability. By performing a detailed qualitative evaluation of these results, we explored the specific reasons for this variability, finding several important considerations for future work in co-creative game AI design tools. EvolvingBehavior represents a first step towards AI-enabled tools that empower game designers to achieve their NPC design goals.</p>
<p>Figure 2 :
2The identifiers and weight settings for the piecewise linear fitness function used in our experiments.</p>
<p>Figure 3 :
3Graph of the average fitness per generation of the evolved vs. the random baseline zombies, on the Medium Map, with 50 zombies and 6 humans.</p>
<p>Figure 4 :
4Box plots of the average fitness results for each algorithm across all problem configurations.</p>
<p>Figure 5 :
5Examples of behavior trees discussed in the qualitative evaluation: Random0 and Evolved2 from the Medium Map 50v3 condition, and the ManualR3 hand-designed tree.
Unreal®is a trademark or registered trademark of Epic Games, Inc. in the United States of America and elsewhere.2 EvolvingBehavior and its code are available at https://evolvingbehavior.npc.codes
Archived at http://hdl.handle.net/2047/D20450406, or the up-to-date code repository can be accessed through https://evolvingbehavior.npc.codes
At http://hdl.handle.net/2047/D20450406
ACKNOWLEDGMENTSSpecial thanks to Alex Grundwerg and Isha Srivastava for contributing code to an early prototype of the tool used in this work, and to Erica Kleinman, Muhammad Ali, and Sabbir Ahmad for collaboration on research related to this project. Many thanks to Tom Looman for allowing us to use the "Epic Survival Game Series" code, on which the testbed game code is built.
Evolving diverse Ms. Pac-Man playing agents using genetic programming. M Atif, Alhejali, M Simon, Lucas, 2010 UK Workshop on Computational Intelligence (UKCI). IEEEAtif M. Alhejali and Simon M. Lucas. 2010. Evolving diverse Ms. Pac-Man playing agents using genetic programming. In 2010 UK Workshop on Computational Intelligence (UKCI). IEEE.</p>
<p>Interactive Constrained MAP-Elites: Analysis and Evaluation of the Expressiveness of the Feature Dimensions. Alberto Alvarez, Steve Dahlskog, Jose Font, Julian Togelius, 10.1109/TG.2020.3046133arXiv:2003.03377IEEE Transactions on Games. Alberto Alvarez, Steve Dahlskog, Jose Font, and Julian Togelius. 2020. Interactive Constrained MAP-Elites: Analysis and Evaluation of the Expressiveness of the Feature Dimensions. IEEE Transactions on Games (2020). https://doi.org/10.1109/ TG.2020.3046133 arXiv: 2003.03377.</p>
<p>Team: The team-oriented evolutionary adaptability mechanism. Sander Bakkes, Pieter Spronck, Eric Postma, International Conference on Entertainment Computing. SpringerSander Bakkes, Pieter Spronck, and Eric Postma. 2004. Team: The team-oriented evolutionary adaptability mechanism. In International Conference on Entertain- ment Computing. Springer, 273-282.</p>
<p>A Comparison of Selection Schemes Used in Evolutionary Algorithms. Tobias Blickle, Lothar Thiele, 10.1162/evco.1996.4.4.361Evolutionary Computation. 4Tobias Blickle and Lothar Thiele. 1996. A Comparison of Selection Schemes Used in Evolutionary Algorithms. Evolutionary Computation 4, 4 (Dec. 1996), 361-394. https://doi.org/10.1162/evco.1996.4.4.361</p>
<p>A-life Evolution with Human Proxies. Vadim Bulitko, Kacy Doucet, Daniel Evans, Hope Docking, Mac Walters, Marilene Oliver, Julian Chow, Shelby Carleton, Natali Kendal-Freedman, ALIFE 2019: The 2019 Conference on Artificial Life. MIT PressVadim Bulitko, Kacy Doucet, Daniel Evans, Hope Docking, Mac Walters, Marilene Oliver, Julian Chow, Shelby Carleton, and Natali Kendal-Freedman. 2019. A-life Evolution with Human Proxies. In ALIFE 2019: The 2019 Conference on Artificial Life. MIT Press, 465-466.</p>
<p>The Behavior Tree Starter Kit. Alex J Champandard, Philip Dunstan, Game AI Pro: Collected Wisdom of Game AI Professionals. A. K. Peters, Ltd. Natick, MA, USAAlex J. Champandard and Philip Dunstan. 2013. The Behavior Tree Starter Kit. In Game AI Pro: Collected Wisdom of Game AI Professionals. A. K. Peters, Ltd., Natick, MA, USA.</p>
<p>Using a Genetic Algorithm to Tune First-Person Shooter Bots. Nicholas Cole, J Sushi, Chris Louis, Miles, Proceedings of the International Congress on Evolutionary Computation. the International Congress on Evolutionary ComputationNicholas Cole, Sushi J. Louis, and Chris Miles. 2004. Using a Genetic Algorithm to Tune First-Person Shooter Bots. In Proceedings of the International Congress on Evolutionary Computation, 2004. 139-145.</p>
<p>Learning of Behavior Trees for Autonomous Agents. Michele Colledanchise, Petter Ramviyas Nattanmai Parasuraman, Ogren, 10.1109/TG.2018.2816806IEEE Transactions on Games. Michele Colledanchise, Ramviyas Nattanmai Parasuraman, and Petter Ogren. 2018. Learning of Behavior Trees for Autonomous Agents. IEEE Transactions on Games (2018). https://doi.org/10.1109/TG.2018.2816806</p>
<p>The Social Responsibility of Game AI. Michael Cook, 2021 IEEE Conference on Games (CoG). IEEEMichael Cook. 2021. The Social Responsibility of Game AI. In 2021 IEEE Conference on Games (CoG). IEEE.</p>
<p>A practical tutorial on the use of nonparametric statistical tests as a methodology for comparing evolutionary and swarm intelligence algorithms. Joaquín Derrac, Salvador García, Daniel Molina, Francisco Herrera, 10.1016/j.swevo.2011.02.002Swarm and Evolutionary Computation. 11Joaquín Derrac, Salvador García, Daniel Molina, and Francisco Herrera. 2011. A practical tutorial on the use of nonparametric statistical tests as a methodology for comparing evolutionary and swarm intelligence algorithms. Swarm and Evolutionary Computation 1, 1 (March 2011), 3-18. https://doi.org/10.1016/j. swevo.2011.02.002</p>
<p>What is game AI?. Kevin Dill, Game AI Pro: Collected Wisdom of Game AI Professionals. CRC PressKevin Dill. 2013. What is game AI? In Game AI Pro: Collected Wisdom of Game AI Professionals. CRC Press, 3-10.</p>
<p>Combining cooperative and adversarial coevolution in the context of pac-man. Alexander Dockhorn, Rudolf Kruse, 2017 IEEE Conference on Computational Intelligence and Games (CIG). IEEEAlexander Dockhorn and Rudolf Kruse. 2017. Combining cooperative and ad- versarial coevolution in the context of pac-man. In 2017 IEEE Conference on Computational Intelligence and Games (CIG). IEEE, 60-67.</p>
<p>Exact p-values for pairwise comparison of Friedman rank sums, with application to comparing classifiers. Rob Eisinga, Tom Heskes, Ben Pelzer, Manfred Te Grotenhuis, 10.1186/s12859-017-1486-2BMC Bioinformatics. 1868Rob Eisinga, Tom Heskes, Ben Pelzer, and Manfred Te Grotenhuis. 2017. Exact p-values for pairwise comparison of Friedman rank sums, with application to comparing classifiers. BMC Bioinformatics 18, 1 (Dec. 2017), 68. https://doi.org/ 10.1186/s12859-017-1486-2</p>
<p>Behaviour Tree Evolution by Genetic Programming. Martin Estgren, Erik Sv Jansson, Linköping UniversityTechnical reportMartin Estgren and Erik SV Jansson. 2017. Behaviour Tree Evolution by Genetic Programming. Technical Report. Technical report, Linköping University.</p>
<p>A self-learning evolutionary chess program. David B Fogel, Timothy J Hays, Sarah L Hahn, James Quon, Proc. IEEE. 92David B. Fogel, Timothy J. Hays, Sarah L. Hahn, and James Quon. 2004. A self-learning evolutionary chess program. Proc. IEEE 92, 12 (2004), 1947-1954.</p>
<p>Towards automatic StarCraft strategy generation using genetic programming. Pablo Garćıa-Sánchez, Alberto Tonda, Antonio M Mora, Giovanni Squillero, J J Merelo, 2015 IEEE Conference on Computational Intelligence and Games (CIG). IEEEPablo Garćıa-Sánchez, Alberto Tonda, Antonio M. Mora, Giovanni Squillero, and J. J. Merelo. 2015. Towards automatic StarCraft strategy generation using genetic programming. In 2015 IEEE Conference on Computational Intelligence and Games (CIG). IEEE, 284-291.</p>
<p>. Sumit Gulwani, Alex Polozov, Rishabh Singh, Program Synthesis. Now Foundations and Trends. 4Sumit Gulwani, Alex Polozov, and Rishabh Singh. 2017. Program Synthesis. Now Foundations and Trends 4 (Oct. 2017). https://www.microsoft.com/en- us/research/publication/program-synthesis/</p>
<p>Evolving content in the galactic arms race video game. Erin J Hastings, Ratan K Guha, Kenneth O Stanley, 2009 IEEE Symposium on Computational Intelligence and Games. IEEEErin J. Hastings, Ratan K. Guha, and Kenneth O. Stanley. 2009. Evolving content in the galactic arms race video game. In 2009 IEEE Symposium on Computational Intelligence and Games. IEEE, 241-248.</p>
<p>Evolving Behaviour Trees:-Automatic Generation of AI Opponents for Real-Time Strategy Games. Master's thesis. Wilhelm Jonatan, Hallvard Jore Hoff, Christensen, NTNUJonatan Wilhelm Hoff and Hallvard Jore Christensen. 2016. Evolving Behaviour Trees:-Automatic Generation of AI Opponents for Real-Time Strategy Games. Mas- ter's thesis. NTNU.</p>
<p>Harmonious Genetic Clustering. Faliang Huang, Xuelong Li, Shichao Zhang, Jilian Zhang, 10.1109/TCYB.2016.2628722Conference Name: IEEE Transactions on Cybernetics. 48Faliang Huang, Xuelong Li, Shichao Zhang, and Jilian Zhang. 2018. Harmonious Genetic Clustering. IEEE Transactions on Cybernetics 48, 1 (Jan. 2018), 199-214. https://doi.org/10.1109/TCYB.2016.2628722 Conference Name: IEEE Transactions on Cybernetics.</p>
<p>Matteo Iovino, Edvards Scukins, Jonathan Styrud, arXiv:2005.05842Petter Ögren, and Christian Smith. 2020. A survey of behavior trees in robotics and ai. arXiv preprintMatteo Iovino, Edvards Scukins, Jonathan Styrud, Petter Ögren, and Christian Smith. 2020. A survey of behavior trees in robotics and ai. arXiv preprint arXiv:2005.05842 (2020).</p>
<p>Learning behavior trees with genetic programming in unpredictable environments. Matteo Iovino, Jonathan Styrud, Pietro Falco, Christian Smith, 2021 IEEE International Conference on Robotics and Automation (ICRA). IEEEMatteo Iovino, Jonathan Styrud, Pietro Falco, and Christian Smith. 2021. Learning behavior trees with genetic programming in unpredictable environments. In 2021 IEEE International Conference on Robotics and Automation (ICRA). IEEE, 4591- 4597.</p>
<p>Handling Complexity in the Halo 2 AI. Damian Isla, Game Developers Conference. Damian Isla. 2005. Handling Complexity in the Halo 2 AI. In Game Developers Conference, Vol. 2005.</p>
<p>Depth-dependent crossover for genetic programming. Takuya Ito, Hitoshi Iba, Satoshi Sato, 10.1109/ICEC.1998.7001501998 IEEE International Conference on Evolutionary Computation Proceedings. IEEE World Congress on Computational Intelligence (Cat. No.98TH8360. Takuya Ito, Hitoshi Iba, and Satoshi Sato. 1998. Depth-dependent crossover for genetic programming. In 1998 IEEE International Conference on Evolutionary Computation Proceedings. IEEE World Congress on Computational Intelligence (Cat. No.98TH8360). 775-780. https://doi.org/10.1109/ICEC.1998.700150</p>
<p>A Two Teraflop Swarm. Simon Jones, Matthew Studley, Sabine Hauert, Alan Frank Thomas Winfield, https:/www.frontiersin.org/article/10.3389/frobt.2018.00011Frontiers in Robotics and AI. 5Simon Jones, Matthew Studley, Sabine Hauert, and Alan Frank Thomas Winfield. 2018. A Two Teraflop Swarm. Frontiers in Robotics and AI 5 (2018). https: //www.frontiersin.org/article/10.3389/frobt.2018.00011</p>
<p>Talakat: Bullet hell generation through constrained map-elites. Ahmed Khalifa, Scott Lee, Andy Nealen, Julian Togelius, Proceedings of The Genetic and Evolutionary Computation Conference. The Genetic and Evolutionary Computation ConferenceAhmed Khalifa, Scott Lee, Andy Nealen, and Julian Togelius. 2018. Talakat: Bullet hell generation through constrained map-elites. In Proceedings of The Genetic and Evolutionary Computation Conference. 1047-1054.</p>
<p>Genetic programming: on the programming of computers by means of natural selection. R John, Koza, MIT press1John R. Koza. 1992. Genetic programming: on the programming of computers by means of natural selection. Vol. 1. MIT press.</p>
<p>Evolutionary Solo Pong players. B William, Riccardo Langdon, Poli, 10.1109/CEC.2005.1555023Proceedings of the 2005 IEEE Congress on Evolutionary Computation. 2621-2628. the 2005 IEEE Congress on Evolutionary Computation. 2621-2628William B. Langdon and Riccardo Poli. 2005. Evolutionary Solo Pong players.. In Proceedings of the 2005 IEEE Congress on Evolutionary Computation. 2621-2628. https://doi.org/10.1109/CEC.2005.1555023</p>
<p>. Joel Lehman, Jeff Clune, Dusan Misevic, Christoph Adami, Lee Altenberg, Julie Beaulieu, Peter J Bentley, Samuel Bernard, Guillaume Beslon, M David, Bryson, Nick Cheney, Patryk Chrabaszcz, Antoine Cully, Stephane Doncieux, Fred CJoel Lehman, Jeff Clune, Dusan Misevic, Christoph Adami, Lee Altenberg, Julie Beaulieu, Peter J. Bentley, Samuel Bernard, Guillaume Beslon, David M. Bryson, Nick Cheney, Patryk Chrabaszcz, Antoine Cully, Stephane Doncieux, Fred C.</p>
<p>The Surprising Creativity of Digital Evolution: A Collection of Anecdotes from the Evolutionary Computation and Artificial Life Research Communities. Kai Olav Dyer, Robert Ellefsen, Stephan Feldt, Stephanie Fischer, Antoine Forrest, Christian Fŕenoy, Leni Le Gagńe, Laura M Goff, Babak Grabowski, Frank Hodjat, Laurent Hutter, Carole Keller, Peter Knibbe, Richard E Krcah, Hod Lenski, Robert Lipson, Carlos Maccurdy, Risto Maestre, Sara Miikkulainen, David E Mitri, Jean-Baptiste Moriarty, Mouret, 10.1162/artl_a_00319Artificial Life. Anh Nguyen, Charles Ofria, Marc Parizeau, David Parsons, Robert T. Pennock, William F. Punch, Thomas S. Ray, Marc Schoenauer, Eric Schulte, Karl Sims, Kenneth O. Stanley, François Taddei, Danesh Tarapore, Simon Thibault, Richard Watson, Westley Weimer, and Jason Yosinski. 2020262Dyer, Kai Olav Ellefsen, Robert Feldt, Stephan Fischer, Stephanie Forrest, Antoine Fŕenoy, Christian Gagńe, Leni Le Goff, Laura M. Grabowski, Babak Hodjat, Frank Hutter, Laurent Keller, Carole Knibbe, Peter Krcah, Richard E. Lenski, Hod Lipson, Robert MacCurdy, Carlos Maestre, Risto Miikkulainen, Sara Mitri, David E. Mori- arty, Jean-Baptiste Mouret, Anh Nguyen, Charles Ofria, Marc Parizeau, David Parsons, Robert T. Pennock, William F. Punch, Thomas S. Ray, Marc Schoenauer, Eric Schulte, Karl Sims, Kenneth O. Stanley, François Taddei, Danesh Tarapore, Simon Thibault, Richard Watson, Westley Weimer, and Jason Yosinski. 2020. The Surprising Creativity of Digital Evolution: A Collection of Anecdotes from the Evolutionary Computation and Artificial Life Research Communities. Artificial Life 26, 2 (May 2020), 274-306. https://doi.org/10.1162/artl_a_00319</p>
<p>Evolving Behaviour Trees for the Commercial Game DEFCON. Chong-U Lim, Robin Baumgarten, Simon Colton, 10.1007/978-3-642-12239-2_11Applications of Evolutionary Computation. Berlin, HeidelbergSpringer6024Chong-U Lim, Robin Baumgarten, and Simon Colton. 2010. Evolving Be- haviour Trees for the Commercial Game DEFCON. In Applications of Evolu- tionary Computation, Vol. 6024. Springer, Berlin, Heidelberg, 100-110. https: //doi.org/10.1007/978-3-642-12239-2_11</p>
<p>EpicSurvivalGameSeries: Third person survival game (tutorial) series for Unreal Engine 4. Tom Looman, date: 2015-03-20T15:19:26ZTom Looman. 2017. EpicSurvivalGameSeries: Third person survival game (tutorial) series for Unreal Engine 4. https://github.com/tomlooman/ EpicSurvivalGameSeries original-date: 2015-03-20T15:19:26Z.</p>
<p>Genetic Programming Produced Competitive Soccer Softbot Teams for RoboCup97. Sean Luke , Genetic Programming: Proceedings of the 3rd Annual Conference. Sean Luke. 1998. Genetic Programming Produced Competitive Soccer Softbot Teams for RoboCup97. In Genetic Programming: Proceedings of the 3rd Annual Conference.</p>
<p>Effect of constraints on evolving behavior trees for game AI. Paul Mcclarron, Robert Ollington, Ian Lewis, 9th Annual International Conference on Computer Games Multimedia &amp; Allied Technologies (CGAT 2016. Paul McClarron, Robert Ollington, and Ian Lewis. 2016. Effect of constraints on evolving behavior trees for game AI. In 9th Annual International Conference on Computer Games Multimedia &amp; Allied Technologies (CGAT 2016). 1-6.</p>
<p>Illuminating search spaces by mapping elites. Jean-Baptiste Mouret, Jeff Clune, arXiv:1504.04909arXiv: 1504.04909cs, q-bioJean-Baptiste Mouret and Jeff Clune. 2015. Illuminating search spaces by mapping elites. arXiv:1504.04909 [cs, q-bio] (April 2015). http://arxiv.org/abs/1504.04909 arXiv: 1504.04909.</p>
<p>Evolving game state evaluation functions for a hybrid planning approach. Xenija Neufeld, Sanaz Mostaghim, Diego Perez-Liebana, 2019 IEEE Conference on Games (CoG). IEEEXenija Neufeld, Sanaz Mostaghim, and Diego Perez-Liebana. 2019. Evolving game state evaluation functions for a hybrid planning approach. In 2019 IEEE Conference on Games (CoG). IEEE.</p>
<p>Evolutionary Behavior Tree Approaches for Navigating Platform Games. Miguel Nicolau, Diego Perez, O&apos; Michael, Anthony Neill, Brabazon, 10.1109/TCIAIG.2016.2543661IEEE Transactions on Computational Intelligence and AI in Games. 9Miguel Nicolau, Diego Perez, Michael O'Neill, and Anthony Brabazon. 2017. Evolutionary Behavior Tree Approaches for Navigating Platform Games. IEEE Transactions on Computational Intelligence and AI in Games 9 (Sept. 2017), 227-238. https://doi.org/10.1109/TCIAIG.2016.2543661</p>
<p>Practical and theoretical issues of evolving behaviour trees for a turn-based game. Master's thesis. Bentley Oakes, Montreal QC, CanadaMcGill UniversityBentley Oakes. 2013. Practical and theoretical issues of evolving behaviour trees for a turn-based game. Master's thesis. McGill University, Montreal QC, Canada.</p>
<p>Automatic difficulty management and testing in games using a framework based on behavior trees and genetic algorithms. Ciprian Paduraru, Miruna Paduraru, 24th International Conference on Engineering of Complex Computer Systems (ICECCS). IEEECiprian Paduraru and Miruna Paduraru. 2019. Automatic difficulty management and testing in games using a framework based on behavior trees and genetic algorithms. In 2019 24th International Conference on Engineering of Complex Computer Systems (ICECCS). IEEE, 170-179.</p>
<p>Design-Driven Requirements for Computationally Co-Creative Game AI Design Tools. Nathan Partlan, Erica Kleinman, Jim Howe, Sabbir Ahmad, Stacy Marsella, Magy Seif El-Nasr, arXiv:2107.13738In Foundations of Digital Games. ACM, Montreal QC. 12CanadaNathan Partlan, Erica Kleinman, Jim Howe, Sabbir Ahmad, Stacy Marsella, and Magy Seif El-Nasr. 2021. Design-Driven Requirements for Computationally Co- Creative Game AI Design Tools. In Foundations of Digital Games. ACM, Montreal QC, Canada, 12. http://arxiv.org/abs/2107.13738 arXiv: 2107.13738.</p>
<p>Evolving Behaviour Trees for the Mario AI Competition Using Grammatical Evolution. Diego Perez, Miguel Nicolau, O&apos; Michael, Anthony Neill, Brabazon, 10.1007/978-3-642-20525-5_13Applications of Evolutionary Computation. Berlin, HeidelbergSpringer6624Diego Perez, Miguel Nicolau, Michael O'Neill, and Anthony Brabazon. 2011. Evolving Behaviour Trees for the Mario AI Competition Using Grammatical Evolution. In Applications of Evolutionary Computation, Vol. 6624. Springer, Berlin, Heidelberg, 123-132. https://doi.org/10.1007/978-3-642-20525-5_13</p>
<p>A Field Guide to Genetic Programming. Riccardo Poli, William B Langdon, Nicholas Freitag Mcphee, Lulu Enterprises, UK LtdRiccardo Poli, William B. Langdon, and Nicholas Freitag McPhee. 2008. A Field Guide to Genetic Programming. Lulu Enterprises, UK Ltd.</p>
<p>Elitism reduces bloat in genetic programming. Riccardo Poli, Nicholas Freitag Mcphee, Leonardo Vanneschi, 10.1145/1389095.1389355GECCO '08. Riccardo Poli, Nicholas Freitag McPhee, and Leonardo Vanneschi. 2008. Elitism reduces bloat in genetic programming. In GECCO '08. https://doi.org/10.1145/ 1389095.1389355</p>
<p>Evolution of human-competitive agents in modern computer games. Steffen Priesterjahn, Oliver Kramer, Er Weimer, Andreas Goebels, Proceedings of the IEEE Congress on Evolutionary Computation. the IEEE Congress on Evolutionary ComputationSteffen Priesterjahn, Oliver Kramer, Er Weimer, and Andreas Goebels. 2007. Evo- lution of human-competitive agents in modern computer games. In Proceedings of the IEEE Congress on Evolutionary Computation.</p>
<p>Neuroevolution in games: State of the art and open challenges. Sebastian Risi, Julian Togelius, IEEE Transactions on Computational Intelligence and AI in Games. 9Sebastian Risi and Julian Togelius. 2015. Neuroevolution in games: State of the art and open challenges. IEEE Transactions on Computational Intelligence and AI in Games 9, 1 (2015), 25-41.</p>
<p>Building behavior trees from observations in real-time strategy games. Glen Robertson, Ian Watson, 10.1109/INISTA.2015.72767742015 International Symposium on Innovations in Intelligent SysTems and Applications (INISTA). 1-7. Glen Robertson and Ian Watson. 2015. Building behavior trees from observations in real-time strategy games. In 2015 International Symposium on Innovations in Intelligent SysTems and Applications (INISTA). 1-7. https://doi.org/10.1109/ INISTA.2015.7276774</p>
<p>The queer games avant-garde: How LGBTQ game makers are reimagining the medium of video games. Bo Ruberg, Duke University PressBo Ruberg. 2020. The queer games avant-garde: How LGBTQ game makers are reimagining the medium of video games. Duke University Press.</p>
<p>Trained behavior trees: Programming by demonstration to support ai game designers. Ismael Sagredo-Olivenza, Pedro Pablo Gómez-Martín, Marco Antonio Gómez-Martín, Pedro Antonio González-Calero, IEEE Transactions on Games. 11Ismael Sagredo-Olivenza, Pedro Pablo Gómez-Martín, Marco Antonio Gómez- Martín, and Pedro Antonio González-Calero. 2017. Trained behavior trees: Pro- gramming by demonstration to support ai game designers. IEEE Transactions on Games 11, 1 (2017), 5-14.</p>
<p>Behavior trees for evolutionary robotics. Y W Kirk, Sjoerd Scheper, Tijmons, C Cornelis, Guido Che De Visser, De Croon, Artificial life. 22Kirk YW Scheper, Sjoerd Tijmons, Cornelis C. de Visser, and Guido CHE de Croon. 2016. Behavior trees for evolutionary robotics. Artificial life 22, 1 (2016), 23-48.</p>
<p>Darwin's Demons: Does Evolution Improve the Game?. Terence Soule, Samantha Heck, Thomas E Haynes, Nicholas Wood, Barrie D Robison, In Applications of Evolutionary Computation. Giovanni Squillero and Kevin SimTerence Soule, Samantha Heck, Thomas E. Haynes, Nicholas Wood, and Barrie D. Robison. 2017. Darwin's Demons: Does Evolution Improve the Game?. In Appli- cations of Evolutionary Computation, Giovanni Squillero and Kevin Sim (Eds.).</p>
<p>. 10.1007/978-3-319-55849-3_29Springer International PublishingChamSpringer International Publishing, Cham, 435-451. https://doi.org/10.1007/978- 3-319-55849-3_29</p>
<p>Evolving neural network agents in the NERO video game. Kenneth O Stanley, Proceedings of the IEEE 2005 Symposium on Computational Intelligence and Games. the IEEE 2005 Symposium on Computational Intelligence and GamesKenneth O. Stanley. 2005. Evolving neural network agents in the NERO video game. In Proceedings of the IEEE 2005 Symposium on Computational Intelligence and Games. 182-189.</p>
<p>Adapting in-game agent behavior by observation of players using learning behavior trees. Emmett Tomai, Roberto Flores, Proceedings of the 9th International Conference on the Foundations of Digital Games. Society for the Advancement of the Science of Digital Games. the 9th International Conference on the Foundations of Digital Games. Society for the Advancement of the Science of Digital GamesFt. Lauderdale, FloridaEmmett Tomai and Roberto Flores. 2014. Adapting in-game agent behavior by observation of players using learning behavior trees. In Proceedings of the 9th International Conference on the Foundations of Digital Games. Society for the Advancement of the Science of Digital Games, Ft. Lauderdale, Florida.</p>
<p>An Evolutionary Approach Generates Human Competitive Corewar Programs. Artificial Chemistry and its Applications, part of ALIFE IX. Barkley Vowk, Christian Schmidt, Alexander Sasha Wait, Barkley Vowk, Christian Schmidt, and Alexander Sasha Wait. 2004. An Evolu- tionary Approach Generates Human Competitive Corewar Programs. Artificial Chemistry and its Applications, part of ALIFE IX (Sept. 2004).</p>
<p>The sobering reality of sexism in the video game industry. Stanislav Vysotsky, Jennifer Helen Allaway, Woke gaming: Digital challenges to oppression and social injustice. Kishonna Gray and David J. LeonardStanislav Vysotsky and Jennifer Helen Allaway. 2018. The sobering reality of sexism in the video game industry. In Woke gaming: Digital challenges to oppression and social injustice, Kishonna Gray and David J. Leonard (Eds.). 101- 118.</p>
<p>Depth-control strategies for crossover in tree-based genetic programming. Huayang Xie, Mengjie Zhang, 10.1007/s00500-011-0700-9Soft Computing. 15Huayang Xie and Mengjie Zhang. 2011. Depth-control strategies for crossover in tree-based genetic programming. Soft Computing 15, 9 (Sept. 2011), 1865-1878. https://doi.org/10.1007/s00500-011-0700-9</p>
<p>Behavior Modeling for Autonomous Agents Based on Modified Evolving Behavior Trees. Qi Zhang, Kai Xu, Peng Jiao, Quanjun Yin, 2018 IEEE 7th Data Driven Control and Learning Systems Conference (DDCLS). IEEEQi Zhang, Kai Xu, Peng Jiao, and Quanjun Yin. 2018. Behavior Modeling for Autonomous Agents Based on Modified Evolving Behavior Trees. In 2018 IEEE 7th Data Driven Control and Learning Systems Conference (DDCLS). IEEE, 1140-1145.</p>
<p>Learning behavior trees for autonomous agents with hybrid constraints evolution. Qi Zhang, Jian Yao, Quanjun Yin, Yabing Zha, Applied Sciences. 871077Publisher: Multidisciplinary Digital Publishing InstituteQi Zhang, Jian Yao, Quanjun Yin, and Yabing Zha. 2018. Learning behavior trees for autonomous agents with hybrid constraints evolution. Applied Sciences 8, 7 (2018), 1077. Publisher: Multidisciplinary Digital Publishing Institute.</p>            </div>
        </div>

    </div>
</body>
</html>