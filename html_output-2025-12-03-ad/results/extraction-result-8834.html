<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-8834 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-8834</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-8834</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-158.html">extraction-schema-158</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for representing or converting graphs into text for language model training, including details of the representation, the type of graph, the conversion process, downstream tasks, performance metrics, comparisons to other methods, and any reported advantages, disadvantages, or failure cases.</div>
                <p><strong>Paper ID:</strong> paper-210981845</p>
                <p><strong>Paper Title:</strong> <a href="https://www.aclweb.org/anthology/2020.tacl-1.2.pdf" target="_blank">AMR-To-Text Generation with Graph Transformer</a></p>
                <p><strong>Paper Abstract:</strong> Abstract meaning representation (AMR)-to-text generation is the challenging task of generating natural language texts from AMR graphs, where nodes represent concepts and edges denote relations. The current state-of-the-art methods use graph-to-sequence models; however, they still cannot significantly outperform the previous sequence-to-sequence models or statistical approaches. In this paper, we propose a novel graph-to-sequence model (Graph Transformer) to address this task. The model directly encodes the AMR graphs and learns the node representations. A pairwise interaction function is used for computing the semantic relations between the concepts. Moreover, attention mechanisms are used for aggregating the information from the incoming and outgoing neighbors, which help the model to capture the semantic information effectively. Our model outperforms the state-of-the-art neural approach by 1.5 BLEU points on LDC2015E86 and 4.8 BLEU points on LDC2017T10 and achieves new state-of-the-art performances.</p>
                <p><strong>Cost:</strong> 0.02</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e8834.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e8834.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for representing or converting graphs into text for language model training, including details of the representation, the type of graph, the conversion process, downstream tasks, performance metrics, comparisons to other methods, and any reported advantages, disadvantages, or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>linearization (Konstas)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Linearization of AMR (as used by Konstas et al., 2017)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A method that serializes an AMR graph into a token sequence which can be fed to sequence models (e.g., LSTMs or Transformers) for text generation; the paper uses the same linearization as Konstas et al. (2017) as a baseline.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Neural amr: Sequence-to-sequence models for parsing and generation.</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>linearization / serialized AMR</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>The AMR rooted directed graph is converted to a linear token sequence (a serialized representation) that encodes nodes, edge labels and structure markers in a traversal order; this serialized sequence is treated as input to sequence encoders.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>AMR graphs (rooted, directed, possibly with reentrancies)</td>
                        </tr>
                        <tr>
                            <td><strong>conversion_method</strong></td>
                            <td>Linearization/serialization of the AMR graph following Konstas et al. (2017) (the paper states it uses the same linearization but does not re-specify traversal details).</td>
                        </tr>
                        <tr>
                            <td><strong>downstream_task</strong></td>
                            <td>AMR-to-text generation (text generation from AMR graphs) and used as baseline input for Transformer and sequence-to-sequence models.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Transformer baseline using this linearization: BLEU 17.7 (gold-only training, LDC2015E86). With 2M auto-labeled Gigaword data, Transformer (linearized input) achieved BLEU 35.1 (LDC2015E86 pretrain+fine-tune). Other sequence-to-sequence baselines using linearization: S2S+Anon BLEU 22.0 (gold-only), S2S+Anon (2M) BLEU 32.3, S2S+Anon (20M) BLEU 33.8.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_others</strong></td>
                            <td>Linearization lets off-the-shelf sequence models be applied but the paper finds it loses structural information; Transformer on linearized AMR underperforms graph encoders on small gold data and is much worse (BLEU 17.7) than Graph Transformer (BLEU 25.9) when trained only on gold data. When very large external auto-labeled data is available, linearized-input Transformers improve dramatically (up to BLEU 35.1 with 2M).</td>
                        </tr>
                        <tr>
                            <td><strong>advantages</strong></td>
                            <td>Enables use of standard sequence models and existing sequence-to-sequence toolkits; simple and straightforward to implement; supports pretraining on large serial data.</td>
                        </tr>
                        <tr>
                            <td><strong>disadvantages</strong></td>
                            <td>May lose explicit graph structure and reentrancy information; linearized sequences can be very long causing self-attention difficulty (especially with limited training data), which harms Transformer performance.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>Performs poorly when training data is small (Transformer with linearized AMR scored low). Long linearized sequences make context modeling hard; omission/mistranslation errors due to lost structural cues and distance between related nodes in sequence.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8834.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e8834.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for representing or converting graphs into text for language model training, including details of the representation, the type of graph, the conversion process, downstream tasks, performance metrics, comparisons to other methods, and any reported advantages, disadvantages, or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Tree conversion (Tree2Str / spanning tree)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Conversion of AMR graphs to trees (spanning/tree-splitting methods, e.g., Flanigan et al., 2016 - Tree2Str)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Methods that convert AMR graphs into trees by splitting reentrancies or producing spanning trees so that tree-to-string or tree transducers can be applied for generation.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Generation from abstract meaning representation using tree transducers.</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>tree conversion / spanning-tree + tree-transducer</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>AMR graph reentrancies are split to produce a tree (or a spanning tree) representation; the resulting tree is used with tree-to-string transducers or synchronous grammars to produce text.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>AMR graphs (converted to trees by splitting reentrancies)</td>
                        </tr>
                        <tr>
                            <td><strong>conversion_method</strong></td>
                            <td>Split reentrancies and derive a tree or spanning tree of the AMR, then apply tree-to-string or synchronous grammar based transducers to convert structure to text.</td>
                        </tr>
                        <tr>
                            <td><strong>downstream_task</strong></td>
                            <td>AMR-to-text generation via tree-to-string transduction.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Tree2Str reported BLEU 23.0 (trained on LDC2015E86 with additional Gigaword LM data used by prior work).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_others</strong></td>
                            <td>Tree conversion allows use of tree transduction methods, but the paper notes that splitting reentrancies (to form trees) can require alignments and may lose the original graph information; Graph Transformer (graph encoder) outperforms Tree2Str in reported experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>advantages</strong></td>
                            <td>Leverages existing tree-based generation machinery; avoids implementing graph encoders.</td>
                        </tr>
                        <tr>
                            <td><strong>disadvantages</strong></td>
                            <td>Splitting reentrancies loses graph structure (co-reference/control) information; requires alignments and may accumulate alignment errors; may not represent true graph semantics faithfully.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>Complex graphs with many reentrancies are not faithfully represented after splitting; generates worse fidelity for structures relying on reentrancy.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8834.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e8834.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for representing or converting graphs into text for language model training, including details of the representation, the type of graph, the conversion process, downstream tasks, performance metrics, comparisons to other methods, and any reported advantages, disadvantages, or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Fragmentation + TSP ordering</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>AMR-to-text as fragment translation plus traveling salesman problem ordering (Song et al., 2016 - TSP)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Approach partitions an AMR graph into fragments, generates text for fragments, and finds an ordering of fragments by solving an asymmetric generalized traveling salesman problem to produce a final sentence.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Amr-to-text generation as a traveling salesman problem.</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>fragmentation + TSP ordering</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>AMR graph is partitioned into small semantically coherent fragments; texts are generated per-fragment and an optimization (asymmetric generalized TSP) determines fragment ordering to form full sentence.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>AMR graphs (partitioned into fragments)</td>
                        </tr>
                        <tr>
                            <td><strong>conversion_method</strong></td>
                            <td>Graph partition into fragments, per-fragment generation (e.g., phrase or subtree-to-string), then ordering solved via traveling salesman formulation.</td>
                        </tr>
                        <tr>
                            <td><strong>downstream_task</strong></td>
                            <td>AMR-to-text generation.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>TSP baseline BLEU 22.4 (LDC2015E86, prior work).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_others</strong></td>
                            <td>The paper treats TSP as a statistical baseline; Graph Transformer (direct graph encoder + Transformer decoder) reports higher BLEU than TSP.</td>
                        </tr>
                        <tr>
                            <td><strong>advantages</strong></td>
                            <td>Breaks a complex graph into smaller generation problems which can be easier to translate locally.</td>
                        </tr>
                        <tr>
                            <td><strong>disadvantages</strong></td>
                            <td>Requires a separate global ordering optimization; errors in fragmentation or ordering can reduce fluency and semantic fidelity.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>Complex cross-fragment dependencies (reentrancies/control) can be lost or misordered, hurting overall sentence correctness.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8834.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e8834.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for representing or converting graphs into text for language model training, including details of the representation, the type of graph, the conversion process, downstream tasks, performance metrics, comparisons to other methods, and any reported advantages, disadvantages, or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>PBMT on linearized AMR</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Phrase-Based Machine Translation on linearized AMR (Pourdamghani et al., 2016)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A phrase-based statistical machine translation approach that treats a linearized AMR as the source language and translates it into text using PBMT; often augmented with external language model trained on Gigaword.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Generating English from abstract meaning representations.</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>linearized AMR as PBMT source</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Linearize the AMR into a sequence and use a phrase-based SMT system to translate the sequence into natural language, optionally using large external LMs.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>AMR graphs (serialized to sequence)</td>
                        </tr>
                        <tr>
                            <td><strong>conversion_method</strong></td>
                            <td>Linearization of AMR followed by phrase-based MT pipeline (alignments, phrase extraction, decoding), plus LM trained on external corpus.</td>
                        </tr>
                        <tr>
                            <td><strong>downstream_task</strong></td>
                            <td>AMR-to-text generation.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>PBMT reported BLEU 26.9 (note: PBMT used additional Gigaword corpus to train language model).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_others</strong></td>
                            <td>PBMT with external LM performed competitively with neural models when external resources are used; Graph Transformer outperforms PBMT when trained with similar/available external resources (Graph Transformer with 2M auto-labeled data achieves BLEU 36.4).</td>
                        </tr>
                        <tr>
                            <td><strong>advantages</strong></td>
                            <td>Effective when large external text corpora are available for language modeling; robust to limited labeled graph-text pairs.</td>
                        </tr>
                        <tr>
                            <td><strong>disadvantages</strong></td>
                            <td>Requires careful alignment and phrase extraction; brittle to domain mismatch; relies on linearization.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>Quality depends heavily on the additional language model and phrase alignments; may miss fine-grained graph semantics.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8834.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e8834.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for representing or converting graphs into text for language model training, including details of the representation, the type of graph, the conversion process, downstream tasks, performance metrics, comparisons to other methods, and any reported advantages, disadvantages, or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>S2S+Anon / S2S+Copy</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Sequence-to-Sequence AMR-to-text variants (Konstas et al., 2017; Song et al., 2018)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Sequence-to-sequence models that operate on linearized AMRs; anonymization (S2S+Anon) or copy mechanisms (S2S+Copy) are used to handle low-frequency tokens like named entities and numbers.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Neural amr: Sequence-to-sequence models for parsing and generation.</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>sequence-to-sequence on linearized AMR (with anonymization or copy)</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Linearized AMR sequences are encoded by LSTM-based encoders; anonymization replaces rare tokens with placeholders (S2S+Anon) whereas copy models allow copying tokens from input graphs to output (S2S+Copy).</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>AMR graphs (serialized into sequences)</td>
                        </tr>
                        <tr>
                            <td><strong>conversion_method</strong></td>
                            <td>Linearization of AMR; optional anonymization step; sequence encoder-decoder with attention and optional copy mechanism.</td>
                        </tr>
                        <tr>
                            <td><strong>downstream_task</strong></td>
                            <td>AMR-to-text generation.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>S2S+Anon BLEU 22.0 (gold-only LDC2015E86); S2S+Anon (2M) BLEU 32.3; S2S+Anon (20M) BLEU 33.8; S2S+Copy (2M) BLEU 31.7.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_others</strong></td>
                            <td>Graph-to-sequence models (GraphLSTM, GGNN, Graph Transformer) typically outperform pure S2S when training data is limited; however with large auto-labeled corpora S2S performance approaches but still lags the Graph Transformer (Graph Transformer 36.4 with 2M).</td>
                        </tr>
                        <tr>
                            <td><strong>advantages</strong></td>
                            <td>Simple to implement and train; benefits from copy/anonymization to handle rare tokens; scales well with large labeled/pretrained data.</td>
                        </tr>
                        <tr>
                            <td><strong>disadvantages</strong></td>
                            <td>Loses explicit graph structure; suffers when linearized sequences are long and when gold training data is limited.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>Produces unreadable or ungrammatical outputs and omits nodes in complex graphs (case studies show S2S often misses concepts and yields low fluency).</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8834.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e8834.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for representing or converting graphs into text for language model training, including details of the representation, the type of graph, the conversion process, downstream tasks, performance metrics, comparisons to other methods, and any reported advantages, disadvantages, or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>GraphLSTM</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Graph State LSTM encoder for AMR-to-text (Song et al., 2018)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A graph-state LSTM that directly encodes AMR graphs by propagating and aggregating node states via LSTM-like gated units; used with a decoder (and copy mechanism) for generation.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>A graph-to-sequence model for AMR-to-text generation.</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>graph-state LSTM (GraphLSTM)</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Nodes carry hidden states updated recurrently through gated units based on neighbor messages; graph structure is explicitly used to propagate information across nodes.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>AMR graphs (direct graph encoding with reentrancies)</td>
                        </tr>
                        <tr>
                            <td><strong>conversion_method</strong></td>
                            <td>Graph is directly encoded without linearization; information aggregated via graph LSTM transitions across edges (graph-to-sequence pipeline).</td>
                        </tr>
                        <tr>
                            <td><strong>downstream_task</strong></td>
                            <td>AMR-to-text generation.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>GraphLSTM BLEU 23.3 (gold-only LDC2015E86); GraphLSTM (2M) BLEU 33.6.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_others</strong></td>
                            <td>GraphLSTM outperforms plain sequence models on many graphs, but Graph Transformer outperforms GraphLSTM by 2.6 BLEU points on gold-only training (25.9 vs. 23.3). Graph Transformer also scales better with encoder depth than GraphLSTM in experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>advantages</strong></td>
                            <td>Directly uses graph structure and can model graph-local interactions; performs better than S2S on many inputs, especially small-to-medium graphs.</td>
                        </tr>
                        <tr>
                            <td><strong>disadvantages</strong></td>
                            <td>May be less effective at capturing long-distance/global context compared to stacked attention-based graph encoders; performance gains saturate with increasing transition steps less effectively than Graph Transformer.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>Struggles on very deep graphs and on graphs with many reentrancies (performance gap to sequence models narrows on extremely deep or highly reentrant graphs). Case studies show GraphLSTM sometimes omits concepts or produces confused outputs in complex examples.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8834.6">
                <h3 class="extraction-instance">Extracted Data Instance 6 (e8834.6)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for representing or converting graphs into text for language model training, including details of the representation, the type of graph, the conversion process, downstream tasks, performance metrics, comparisons to other methods, and any reported advantages, disadvantages, or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>GGNN</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Gated Graph Neural Network encoder applied to AMR-to-text (Beck et al., 2018 adaptation)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A gated graph neural network (GGNN) aggregates neighbor messages using gated recurrent updates per node (GRU-like) and is followed by an RNN decoder to generate text.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Graph-to-sequence learning using gated graph neural networks.</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>GGNN (gated message-passing graph encoder)</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Edges and neighbor nodes provide messages; node states are updated via gated recurrent updates (e.g., GRU) over multiple propagation steps; final node representations feed into a sequence decoder.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>AMR graphs (direct graph encoding)</td>
                        </tr>
                        <tr>
                            <td><strong>conversion_method</strong></td>
                            <td>Direct graph encoding via gated iterative propagation (GGNN); no linearization required.</td>
                        </tr>
                        <tr>
                            <td><strong>downstream_task</strong></td>
                            <td>AMR-to-text generation.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>GGNN BLEU 23.3, CHRF++ 50.4 (trained on LDC2017T10 in reported comparisons); GGNN (ensemble) BLEU 27.5, CHRF++ 53.5.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_others</strong></td>
                            <td>GGNN is a strong graph-to-sequence baseline; Graph Transformer substantially outperforms single GGNN (improves BLEU by ~6.0 on LDC2017T10 according to the paper).</td>
                        </tr>
                        <tr>
                            <td><strong>advantages</strong></td>
                            <td>Explicitly models edge-conditioned propagation and gated updates across graph structure.</td>
                        </tr>
                        <tr>
                            <td><strong>disadvantages</strong></td>
                            <td>Can suffer parameter explosion if naive edge-specific transforms used; may be less effective at modeling long-range interactions than stacked attention encoders.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>Ensemble needed to approach strong performance; reported weaker than Graph Transformer especially on larger training sets or deeper graphs.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8834.7">
                <h3 class="extraction-instance">Extracted Data Instance 7 (e8834.7)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for representing or converting graphs into text for language model training, including details of the representation, the type of graph, the conversion process, downstream tasks, performance metrics, comparisons to other methods, and any reported advantages, disadvantages, or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>GCN / t-GCNSEQ / g-GCNSEQ</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Graph Convolutional Network based encoders and their hybrids (Damonte & Cohen, 2019: t-GCNSEQ/g-GCNSEQ)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Graph convolutional networks (GCNs) encode graph structure via convolutional aggregation over neighbors; t-GCNSEQ/g-GCNSEQ are hybrid variants stacking GCNs with BiLSTMs to capture both structure and sequential information.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Structural neural encoders for amr-to-text generation.</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>GCN / tree-GCNSEQ (t-GCNSEQ) / graph-GCNSEQ (g-GCNSEQ)</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>GCN aggregates neighbor representations with learned linear transforms; t-GCNSEQ converts graph to a tree (splitting reentrancies) and stacks encoders; g-GCNSEQ encodes graph directly with GCN and stacks BiLSTM on top to incorporate sequential cues.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>AMR graphs (both tree-transformed and direct graph variants)</td>
                        </tr>
                        <tr>
                            <td><strong>conversion_method</strong></td>
                            <td>Either convert graph to tree (t-GCNSEQ) or directly apply GCN to the graph (g-GCNSEQ); BiLSTM stacked on outputs in hybrids.</td>
                        </tr>
                        <tr>
                            <td><strong>downstream_task</strong></td>
                            <td>AMR-to-text generation.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>t-GCNSEQ BLEU 23.9; g-GCNSEQ BLEU 24.4 (gold-only LDC2015E86 reported in Table 1). On LDC2017T10, t-GCNSEQ BLEU 24.1, g-GCNSEQ BLEU 24.5 (paper reports Graph Transformer is 4.8 BLEU higher on LDC2017T10).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_others</strong></td>
                            <td>g-GCNSEQ and t-GCNSEQ are strong graph-aware baselines; Graph Transformer outperforms both (Graph Transformer 25.9 gold-only vs. 24.4 g-GCNSEQ).</td>
                        </tr>
                        <tr>
                            <td><strong>advantages</strong></td>
                            <td>GCNs are efficient neighborhood aggregators; hybrids leverage sequential encoders to capture ordering.</td>
                        </tr>
                        <tr>
                            <td><strong>disadvantages</strong></td>
                            <td>GCN-based methods may not fully exploit labeled directed edges and directionality differences; hybrids can be sensitive to combination mismatch (mixing Transformer and RNN decoders produced worse results according to the paper).</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>Limited improvements with more encoder depth compared to Graph Transformer; hybrid stacking can underperform if encoder-decoder paradigms mismatch.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8834.8">
                <h3 class="extraction-instance">Extracted Data Instance 8 (e8834.8)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for representing or converting graphs into text for language model training, including details of the representation, the type of graph, the conversion process, downstream tasks, performance metrics, comparisons to other methods, and any reported advantages, disadvantages, or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Graph Transformer (this paper)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Graph Transformer (Graph-to-sequence model with graph attention and Transformer decoder)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An attention-only graph-to-sequence model that directly encodes AMR graphs with stacked multi-head graph-attention layers, separate incoming/outgoing attentions, a pairwise triple interaction to include edge labels, and a Transformer-style decoder with a copy mechanism.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>Graph Transformer graph encoding</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Nodes represented by concatenation of head (outgoing-role) and tail (incoming-role) vectors; neighbor triples (source node representation + edge-label embedding + target node representation) are projected via a pairwise interaction function and input to multi-head scaled-dot-product graph-attention separately over incoming and outgoing relations; a sigmoid fusion layer merges incoming/outgoing aggregated information followed by feed-forward and residual connections; final node vectors fed to a Transformer decoder with copy gate.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>AMR graphs (rooted, directed, labeled, with reentrancies)</td>
                        </tr>
                        <tr>
                            <td><strong>conversion_method</strong></td>
                            <td>No linearization â€” the graph encoder directly operates on nodes and labeled directed edges using pairwise-interaction representations r_ij (concatenation of source node, edge-label embedding, and target node) and multi-head graph attention over incoming and outgoing neighborhoods. Final node representations are concatenated head/tail vectors and passed to the decoder which may copy tokens from graph nodes.</td>
                        </tr>
                        <tr>
                            <td><strong>downstream_task</strong></td>
                            <td>AMR-to-text generation (primary); intended for text generation tasks that require preserving graph semantics.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Gold-only (LDC2015E86) Graph Transformer BLEU 25.9 (best neural model in table). With 2M auto-labeled Gigaword pretraining + fine-tune, Graph Transformer BLEU 36.4 on LDC2015E86 (state-of-the-art reported). On LDC2017T10 Graph Transformer outperforms GGNN by +6.0 BLEU and CHRF++ by +8.6 (exact BLEU on LDC2017T10 not explicitly listed in main table excerpt but described as 4.8 BLEU higher than prior SOTA g-GCNSEQ on that set when gold-only vs. prior).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_others</strong></td>
                            <td>Outperforms sequence-to-sequence linearization baselines and prior graph encoders (GraphLSTM, GGNN, GCN-based hybrids) on benchmark datasets; especially effective with limited gold training data and when encoding deep graphs. The paper reports +1.5 BLEU over previous best neural approach on LDC2015E86 and +4.8 BLEU on LDC2017T10 (compared to g-GCNSEQ).</td>
                        </tr>
                        <tr>
                            <td><strong>advantages</strong></td>
                            <td>Directly models labeled directed edges and distinguishes incoming vs. outgoing relations via separate attentions; pairwise triple interaction encodes receiver node, sender node and edge label jointly without parameter explosion; stacked attention layers propagate global context efficiently; robust when gold training data is small; effective at capturing long-distance dependencies.</td>
                        </tr>
                        <tr>
                            <td><strong>disadvantages</strong></td>
                            <td>Model complexity and number of attention layers require tuning; larger models can overfit on small datasets; still degrades on highly complex graphs with many reentrancies compared to simpler trees.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>All models including Graph Transformer suffer as number of reentrancies increases (performance drops); generated output errors include missing information, mistranslation of nodes/edges, and fluency problems on very complex graphs. Overfitting observed if encoder depth L1 > 8 on limited data. Some case-study examples show remaining omissions or fluency deficits for very complex inputs.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8834.9">
                <h3 class="extraction-instance">Extracted Data Instance 9 (e8834.9)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for representing or converting graphs into text for language model training, including details of the representation, the type of graph, the conversion process, downstream tasks, performance metrics, comparisons to other methods, and any reported advantages, disadvantages, or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>GAT (related mention)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Graph Attention Networks (Velickovic et al., 2018) - related architecture</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Graph attention networks apply attention mechanisms to aggregate neighbor representations in undirected graphs; the authors compare and adapt GAT ideas but extend to directed labeled AMRs with separate incoming/outgoing attentions and scaled dot-product attention.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Graph attention networks.</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>graph attention (GAT-like)</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Use attention to weight neighbor contributions when aggregating node representations; the paper adapts the idea to directed labeled graphs using scaled dot-product attention and two separate attentions for incoming and outgoing edges.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>Graph-structured data; in this paper applied to AMR graphs.</td>
                        </tr>
                        <tr>
                            <td><strong>conversion_method</strong></td>
                            <td>Direct graph encoding via attention over neighbor relations (adapted from GAT but extended for directed labeled edges).</td>
                        </tr>
                        <tr>
                            <td><strong>downstream_task</strong></td>
                            <td>AMR-to-text generation (in this paper using adapted GAT concepts inside Graph Transformer).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>GAT itself is mentioned as prior work; the adapted graph-attention approach in Graph Transformer contributes to BLEU gains (Graph Transformer BLEU 25.9 gold-only).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_others</strong></td>
                            <td>GAT originally designed for undirected graphs without explicit edge labels or direction; Graph Transformer extends GAT by modeling directionality and edge labels and by using scaled dot-product attention instead of additive attention.</td>
                        </tr>
                        <tr>
                            <td><strong>advantages</strong></td>
                            <td>Attention allows flexible, learned weighting of neighbor contributions; adaptation permits directed, labeled edge handling.</td>
                        </tr>
                        <tr>
                            <td><strong>disadvantages</strong></td>
                            <td>Original GAT lacks label/direction modeling; naive adoption would miss important AMR information â€” motivates Graph Transformer design choices.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>Not explicitly tested in original GAT form on AMR within this paper; direct GAT without edge labels/direction would likely underperform on AMR.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8834.10">
                <h3 class="extraction-instance">Extracted Data Instance 10 (e8834.10)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for representing or converting graphs into text for language model training, including details of the representation, the type of graph, the conversion process, downstream tasks, performance metrics, comparisons to other methods, and any reported advantages, disadvantages, or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>JAMR auto-parsing (data augmentation)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>JAMR AMR parser used to auto-label Gigaword (Song et al., 2018 usage)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An AMR parser used to automatically parse large corpora (Gigaword) into AMR graphs to produce additional paired training data (auto-labeled), which is then used for pretraining/fine-tuning models.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>auto-parsed AMR pairs (Gigaword via JAMR)</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Large text corpus (Gigaword) is parsed by a pre-trained AMR parser (JAMR) to create (AMR graph, sentence) pairs that supplement scarce gold AMR data for training graph-to-text models.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>Automatically parsed AMR graphs from raw text</td>
                        </tr>
                        <tr>
                            <td><strong>conversion_method</strong></td>
                            <td>Use JAMR parser to convert raw sentences into AMR graphs; resulting pairs used as additional training data (pretrain on auto-labeled then fine-tune on gold).</td>
                        </tr>
                        <tr>
                            <td><strong>downstream_task</strong></td>
                            <td>AMR-to-text generation training (data augmentation / semi-supervised learning).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Using 2M auto-labeled Gigaword instances with pretrain+fine-tune: Graph Transformer BLEU improves to 36.4 on LDC2015E86 (vs. 25.9 gold-only), indicating large gains when auto-labeled data used.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_others</strong></td>
                            <td>Pretraining on auto-labeled Gigaword improves all models; Transformer with linearized input benefits greatly (was 17.7 gold-only, 35.1 with 2M), but Graph Transformer remains best (36.4 with 2M).</td>
                        </tr>
                        <tr>
                            <td><strong>advantages</strong></td>
                            <td>Substantially increases effective training data and performance; especially helpful for models that can benefit from large-scale pretraining.</td>
                        </tr>
                        <tr>
                            <td><strong>disadvantages</strong></td>
                            <td>Quality depends on parser accuracy (noisy labels); mismatches between parser errors and generation targets can introduce noise.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>May propagate parser errors into generation model; model reliance on large, auto-labeled corpora may mask deficiencies in modeling structure from small gold datasets.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Neural amr: Sequence-to-sequence models for parsing and generation. <em>(Rating: 2)</em></li>
                <li>Generation from abstract meaning representation using tree transducers. <em>(Rating: 2)</em></li>
                <li>Amr-to-text generation as a traveling salesman problem. <em>(Rating: 2)</em></li>
                <li>Generating English from abstract meaning representations. <em>(Rating: 2)</em></li>
                <li>Graph-to-sequence learning using gated graph neural networks. <em>(Rating: 2)</em></li>
                <li>A graph-to-sequence model for AMR-to-text generation. <em>(Rating: 2)</em></li>
                <li>Structural neural encoders for amr-to-text generation. <em>(Rating: 2)</em></li>
                <li>Graph attention networks. <em>(Rating: 1)</em></li>
                <li>Gated graph sequence neural networks. <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-8834",
    "paper_id": "paper-210981845",
    "extraction_schema_id": "extraction-schema-158",
    "extracted_data": [
        {
            "name_short": "linearization (Konstas)",
            "name_full": "Linearization of AMR (as used by Konstas et al., 2017)",
            "brief_description": "A method that serializes an AMR graph into a token sequence which can be fed to sequence models (e.g., LSTMs or Transformers) for text generation; the paper uses the same linearization as Konstas et al. (2017) as a baseline.",
            "citation_title": "Neural amr: Sequence-to-sequence models for parsing and generation.",
            "mention_or_use": "use",
            "representation_name": "linearization / serialized AMR",
            "representation_description": "The AMR rooted directed graph is converted to a linear token sequence (a serialized representation) that encodes nodes, edge labels and structure markers in a traversal order; this serialized sequence is treated as input to sequence encoders.",
            "graph_type": "AMR graphs (rooted, directed, possibly with reentrancies)",
            "conversion_method": "Linearization/serialization of the AMR graph following Konstas et al. (2017) (the paper states it uses the same linearization but does not re-specify traversal details).",
            "downstream_task": "AMR-to-text generation (text generation from AMR graphs) and used as baseline input for Transformer and sequence-to-sequence models.",
            "performance_metrics": "Transformer baseline using this linearization: BLEU 17.7 (gold-only training, LDC2015E86). With 2M auto-labeled Gigaword data, Transformer (linearized input) achieved BLEU 35.1 (LDC2015E86 pretrain+fine-tune). Other sequence-to-sequence baselines using linearization: S2S+Anon BLEU 22.0 (gold-only), S2S+Anon (2M) BLEU 32.3, S2S+Anon (20M) BLEU 33.8.",
            "comparison_to_others": "Linearization lets off-the-shelf sequence models be applied but the paper finds it loses structural information; Transformer on linearized AMR underperforms graph encoders on small gold data and is much worse (BLEU 17.7) than Graph Transformer (BLEU 25.9) when trained only on gold data. When very large external auto-labeled data is available, linearized-input Transformers improve dramatically (up to BLEU 35.1 with 2M).",
            "advantages": "Enables use of standard sequence models and existing sequence-to-sequence toolkits; simple and straightforward to implement; supports pretraining on large serial data.",
            "disadvantages": "May lose explicit graph structure and reentrancy information; linearized sequences can be very long causing self-attention difficulty (especially with limited training data), which harms Transformer performance.",
            "failure_cases": "Performs poorly when training data is small (Transformer with linearized AMR scored low). Long linearized sequences make context modeling hard; omission/mistranslation errors due to lost structural cues and distance between related nodes in sequence.",
            "uuid": "e8834.0"
        },
        {
            "name_short": "Tree conversion (Tree2Str / spanning tree)",
            "name_full": "Conversion of AMR graphs to trees (spanning/tree-splitting methods, e.g., Flanigan et al., 2016 - Tree2Str)",
            "brief_description": "Methods that convert AMR graphs into trees by splitting reentrancies or producing spanning trees so that tree-to-string or tree transducers can be applied for generation.",
            "citation_title": "Generation from abstract meaning representation using tree transducers.",
            "mention_or_use": "mention",
            "representation_name": "tree conversion / spanning-tree + tree-transducer",
            "representation_description": "AMR graph reentrancies are split to produce a tree (or a spanning tree) representation; the resulting tree is used with tree-to-string transducers or synchronous grammars to produce text.",
            "graph_type": "AMR graphs (converted to trees by splitting reentrancies)",
            "conversion_method": "Split reentrancies and derive a tree or spanning tree of the AMR, then apply tree-to-string or synchronous grammar based transducers to convert structure to text.",
            "downstream_task": "AMR-to-text generation via tree-to-string transduction.",
            "performance_metrics": "Tree2Str reported BLEU 23.0 (trained on LDC2015E86 with additional Gigaword LM data used by prior work).",
            "comparison_to_others": "Tree conversion allows use of tree transduction methods, but the paper notes that splitting reentrancies (to form trees) can require alignments and may lose the original graph information; Graph Transformer (graph encoder) outperforms Tree2Str in reported experiments.",
            "advantages": "Leverages existing tree-based generation machinery; avoids implementing graph encoders.",
            "disadvantages": "Splitting reentrancies loses graph structure (co-reference/control) information; requires alignments and may accumulate alignment errors; may not represent true graph semantics faithfully.",
            "failure_cases": "Complex graphs with many reentrancies are not faithfully represented after splitting; generates worse fidelity for structures relying on reentrancy.",
            "uuid": "e8834.1"
        },
        {
            "name_short": "Fragmentation + TSP ordering",
            "name_full": "AMR-to-text as fragment translation plus traveling salesman problem ordering (Song et al., 2016 - TSP)",
            "brief_description": "Approach partitions an AMR graph into fragments, generates text for fragments, and finds an ordering of fragments by solving an asymmetric generalized traveling salesman problem to produce a final sentence.",
            "citation_title": "Amr-to-text generation as a traveling salesman problem.",
            "mention_or_use": "mention",
            "representation_name": "fragmentation + TSP ordering",
            "representation_description": "AMR graph is partitioned into small semantically coherent fragments; texts are generated per-fragment and an optimization (asymmetric generalized TSP) determines fragment ordering to form full sentence.",
            "graph_type": "AMR graphs (partitioned into fragments)",
            "conversion_method": "Graph partition into fragments, per-fragment generation (e.g., phrase or subtree-to-string), then ordering solved via traveling salesman formulation.",
            "downstream_task": "AMR-to-text generation.",
            "performance_metrics": "TSP baseline BLEU 22.4 (LDC2015E86, prior work).",
            "comparison_to_others": "The paper treats TSP as a statistical baseline; Graph Transformer (direct graph encoder + Transformer decoder) reports higher BLEU than TSP.",
            "advantages": "Breaks a complex graph into smaller generation problems which can be easier to translate locally.",
            "disadvantages": "Requires a separate global ordering optimization; errors in fragmentation or ordering can reduce fluency and semantic fidelity.",
            "failure_cases": "Complex cross-fragment dependencies (reentrancies/control) can be lost or misordered, hurting overall sentence correctness.",
            "uuid": "e8834.2"
        },
        {
            "name_short": "PBMT on linearized AMR",
            "name_full": "Phrase-Based Machine Translation on linearized AMR (Pourdamghani et al., 2016)",
            "brief_description": "A phrase-based statistical machine translation approach that treats a linearized AMR as the source language and translates it into text using PBMT; often augmented with external language model trained on Gigaword.",
            "citation_title": "Generating English from abstract meaning representations.",
            "mention_or_use": "mention",
            "representation_name": "linearized AMR as PBMT source",
            "representation_description": "Linearize the AMR into a sequence and use a phrase-based SMT system to translate the sequence into natural language, optionally using large external LMs.",
            "graph_type": "AMR graphs (serialized to sequence)",
            "conversion_method": "Linearization of AMR followed by phrase-based MT pipeline (alignments, phrase extraction, decoding), plus LM trained on external corpus.",
            "downstream_task": "AMR-to-text generation.",
            "performance_metrics": "PBMT reported BLEU 26.9 (note: PBMT used additional Gigaword corpus to train language model).",
            "comparison_to_others": "PBMT with external LM performed competitively with neural models when external resources are used; Graph Transformer outperforms PBMT when trained with similar/available external resources (Graph Transformer with 2M auto-labeled data achieves BLEU 36.4).",
            "advantages": "Effective when large external text corpora are available for language modeling; robust to limited labeled graph-text pairs.",
            "disadvantages": "Requires careful alignment and phrase extraction; brittle to domain mismatch; relies on linearization.",
            "failure_cases": "Quality depends heavily on the additional language model and phrase alignments; may miss fine-grained graph semantics.",
            "uuid": "e8834.3"
        },
        {
            "name_short": "S2S+Anon / S2S+Copy",
            "name_full": "Sequence-to-Sequence AMR-to-text variants (Konstas et al., 2017; Song et al., 2018)",
            "brief_description": "Sequence-to-sequence models that operate on linearized AMRs; anonymization (S2S+Anon) or copy mechanisms (S2S+Copy) are used to handle low-frequency tokens like named entities and numbers.",
            "citation_title": "Neural amr: Sequence-to-sequence models for parsing and generation.",
            "mention_or_use": "mention",
            "representation_name": "sequence-to-sequence on linearized AMR (with anonymization or copy)",
            "representation_description": "Linearized AMR sequences are encoded by LSTM-based encoders; anonymization replaces rare tokens with placeholders (S2S+Anon) whereas copy models allow copying tokens from input graphs to output (S2S+Copy).",
            "graph_type": "AMR graphs (serialized into sequences)",
            "conversion_method": "Linearization of AMR; optional anonymization step; sequence encoder-decoder with attention and optional copy mechanism.",
            "downstream_task": "AMR-to-text generation.",
            "performance_metrics": "S2S+Anon BLEU 22.0 (gold-only LDC2015E86); S2S+Anon (2M) BLEU 32.3; S2S+Anon (20M) BLEU 33.8; S2S+Copy (2M) BLEU 31.7.",
            "comparison_to_others": "Graph-to-sequence models (GraphLSTM, GGNN, Graph Transformer) typically outperform pure S2S when training data is limited; however with large auto-labeled corpora S2S performance approaches but still lags the Graph Transformer (Graph Transformer 36.4 with 2M).",
            "advantages": "Simple to implement and train; benefits from copy/anonymization to handle rare tokens; scales well with large labeled/pretrained data.",
            "disadvantages": "Loses explicit graph structure; suffers when linearized sequences are long and when gold training data is limited.",
            "failure_cases": "Produces unreadable or ungrammatical outputs and omits nodes in complex graphs (case studies show S2S often misses concepts and yields low fluency).",
            "uuid": "e8834.4"
        },
        {
            "name_short": "GraphLSTM",
            "name_full": "Graph State LSTM encoder for AMR-to-text (Song et al., 2018)",
            "brief_description": "A graph-state LSTM that directly encodes AMR graphs by propagating and aggregating node states via LSTM-like gated units; used with a decoder (and copy mechanism) for generation.",
            "citation_title": "A graph-to-sequence model for AMR-to-text generation.",
            "mention_or_use": "mention",
            "representation_name": "graph-state LSTM (GraphLSTM)",
            "representation_description": "Nodes carry hidden states updated recurrently through gated units based on neighbor messages; graph structure is explicitly used to propagate information across nodes.",
            "graph_type": "AMR graphs (direct graph encoding with reentrancies)",
            "conversion_method": "Graph is directly encoded without linearization; information aggregated via graph LSTM transitions across edges (graph-to-sequence pipeline).",
            "downstream_task": "AMR-to-text generation.",
            "performance_metrics": "GraphLSTM BLEU 23.3 (gold-only LDC2015E86); GraphLSTM (2M) BLEU 33.6.",
            "comparison_to_others": "GraphLSTM outperforms plain sequence models on many graphs, but Graph Transformer outperforms GraphLSTM by 2.6 BLEU points on gold-only training (25.9 vs. 23.3). Graph Transformer also scales better with encoder depth than GraphLSTM in experiments.",
            "advantages": "Directly uses graph structure and can model graph-local interactions; performs better than S2S on many inputs, especially small-to-medium graphs.",
            "disadvantages": "May be less effective at capturing long-distance/global context compared to stacked attention-based graph encoders; performance gains saturate with increasing transition steps less effectively than Graph Transformer.",
            "failure_cases": "Struggles on very deep graphs and on graphs with many reentrancies (performance gap to sequence models narrows on extremely deep or highly reentrant graphs). Case studies show GraphLSTM sometimes omits concepts or produces confused outputs in complex examples.",
            "uuid": "e8834.5"
        },
        {
            "name_short": "GGNN",
            "name_full": "Gated Graph Neural Network encoder applied to AMR-to-text (Beck et al., 2018 adaptation)",
            "brief_description": "A gated graph neural network (GGNN) aggregates neighbor messages using gated recurrent updates per node (GRU-like) and is followed by an RNN decoder to generate text.",
            "citation_title": "Graph-to-sequence learning using gated graph neural networks.",
            "mention_or_use": "mention",
            "representation_name": "GGNN (gated message-passing graph encoder)",
            "representation_description": "Edges and neighbor nodes provide messages; node states are updated via gated recurrent updates (e.g., GRU) over multiple propagation steps; final node representations feed into a sequence decoder.",
            "graph_type": "AMR graphs (direct graph encoding)",
            "conversion_method": "Direct graph encoding via gated iterative propagation (GGNN); no linearization required.",
            "downstream_task": "AMR-to-text generation.",
            "performance_metrics": "GGNN BLEU 23.3, CHRF++ 50.4 (trained on LDC2017T10 in reported comparisons); GGNN (ensemble) BLEU 27.5, CHRF++ 53.5.",
            "comparison_to_others": "GGNN is a strong graph-to-sequence baseline; Graph Transformer substantially outperforms single GGNN (improves BLEU by ~6.0 on LDC2017T10 according to the paper).",
            "advantages": "Explicitly models edge-conditioned propagation and gated updates across graph structure.",
            "disadvantages": "Can suffer parameter explosion if naive edge-specific transforms used; may be less effective at modeling long-range interactions than stacked attention encoders.",
            "failure_cases": "Ensemble needed to approach strong performance; reported weaker than Graph Transformer especially on larger training sets or deeper graphs.",
            "uuid": "e8834.6"
        },
        {
            "name_short": "GCN / t-GCNSEQ / g-GCNSEQ",
            "name_full": "Graph Convolutional Network based encoders and their hybrids (Damonte & Cohen, 2019: t-GCNSEQ/g-GCNSEQ)",
            "brief_description": "Graph convolutional networks (GCNs) encode graph structure via convolutional aggregation over neighbors; t-GCNSEQ/g-GCNSEQ are hybrid variants stacking GCNs with BiLSTMs to capture both structure and sequential information.",
            "citation_title": "Structural neural encoders for amr-to-text generation.",
            "mention_or_use": "mention",
            "representation_name": "GCN / tree-GCNSEQ (t-GCNSEQ) / graph-GCNSEQ (g-GCNSEQ)",
            "representation_description": "GCN aggregates neighbor representations with learned linear transforms; t-GCNSEQ converts graph to a tree (splitting reentrancies) and stacks encoders; g-GCNSEQ encodes graph directly with GCN and stacks BiLSTM on top to incorporate sequential cues.",
            "graph_type": "AMR graphs (both tree-transformed and direct graph variants)",
            "conversion_method": "Either convert graph to tree (t-GCNSEQ) or directly apply GCN to the graph (g-GCNSEQ); BiLSTM stacked on outputs in hybrids.",
            "downstream_task": "AMR-to-text generation.",
            "performance_metrics": "t-GCNSEQ BLEU 23.9; g-GCNSEQ BLEU 24.4 (gold-only LDC2015E86 reported in Table 1). On LDC2017T10, t-GCNSEQ BLEU 24.1, g-GCNSEQ BLEU 24.5 (paper reports Graph Transformer is 4.8 BLEU higher on LDC2017T10).",
            "comparison_to_others": "g-GCNSEQ and t-GCNSEQ are strong graph-aware baselines; Graph Transformer outperforms both (Graph Transformer 25.9 gold-only vs. 24.4 g-GCNSEQ).",
            "advantages": "GCNs are efficient neighborhood aggregators; hybrids leverage sequential encoders to capture ordering.",
            "disadvantages": "GCN-based methods may not fully exploit labeled directed edges and directionality differences; hybrids can be sensitive to combination mismatch (mixing Transformer and RNN decoders produced worse results according to the paper).",
            "failure_cases": "Limited improvements with more encoder depth compared to Graph Transformer; hybrid stacking can underperform if encoder-decoder paradigms mismatch.",
            "uuid": "e8834.7"
        },
        {
            "name_short": "Graph Transformer (this paper)",
            "name_full": "Graph Transformer (Graph-to-sequence model with graph attention and Transformer decoder)",
            "brief_description": "An attention-only graph-to-sequence model that directly encodes AMR graphs with stacked multi-head graph-attention layers, separate incoming/outgoing attentions, a pairwise triple interaction to include edge labels, and a Transformer-style decoder with a copy mechanism.",
            "citation_title": "here",
            "mention_or_use": "use",
            "representation_name": "Graph Transformer graph encoding",
            "representation_description": "Nodes represented by concatenation of head (outgoing-role) and tail (incoming-role) vectors; neighbor triples (source node representation + edge-label embedding + target node representation) are projected via a pairwise interaction function and input to multi-head scaled-dot-product graph-attention separately over incoming and outgoing relations; a sigmoid fusion layer merges incoming/outgoing aggregated information followed by feed-forward and residual connections; final node vectors fed to a Transformer decoder with copy gate.",
            "graph_type": "AMR graphs (rooted, directed, labeled, with reentrancies)",
            "conversion_method": "No linearization â€” the graph encoder directly operates on nodes and labeled directed edges using pairwise-interaction representations r_ij (concatenation of source node, edge-label embedding, and target node) and multi-head graph attention over incoming and outgoing neighborhoods. Final node representations are concatenated head/tail vectors and passed to the decoder which may copy tokens from graph nodes.",
            "downstream_task": "AMR-to-text generation (primary); intended for text generation tasks that require preserving graph semantics.",
            "performance_metrics": "Gold-only (LDC2015E86) Graph Transformer BLEU 25.9 (best neural model in table). With 2M auto-labeled Gigaword pretraining + fine-tune, Graph Transformer BLEU 36.4 on LDC2015E86 (state-of-the-art reported). On LDC2017T10 Graph Transformer outperforms GGNN by +6.0 BLEU and CHRF++ by +8.6 (exact BLEU on LDC2017T10 not explicitly listed in main table excerpt but described as 4.8 BLEU higher than prior SOTA g-GCNSEQ on that set when gold-only vs. prior).",
            "comparison_to_others": "Outperforms sequence-to-sequence linearization baselines and prior graph encoders (GraphLSTM, GGNN, GCN-based hybrids) on benchmark datasets; especially effective with limited gold training data and when encoding deep graphs. The paper reports +1.5 BLEU over previous best neural approach on LDC2015E86 and +4.8 BLEU on LDC2017T10 (compared to g-GCNSEQ).",
            "advantages": "Directly models labeled directed edges and distinguishes incoming vs. outgoing relations via separate attentions; pairwise triple interaction encodes receiver node, sender node and edge label jointly without parameter explosion; stacked attention layers propagate global context efficiently; robust when gold training data is small; effective at capturing long-distance dependencies.",
            "disadvantages": "Model complexity and number of attention layers require tuning; larger models can overfit on small datasets; still degrades on highly complex graphs with many reentrancies compared to simpler trees.",
            "failure_cases": "All models including Graph Transformer suffer as number of reentrancies increases (performance drops); generated output errors include missing information, mistranslation of nodes/edges, and fluency problems on very complex graphs. Overfitting observed if encoder depth L1 &gt; 8 on limited data. Some case-study examples show remaining omissions or fluency deficits for very complex inputs.",
            "uuid": "e8834.8"
        },
        {
            "name_short": "GAT (related mention)",
            "name_full": "Graph Attention Networks (Velickovic et al., 2018) - related architecture",
            "brief_description": "Graph attention networks apply attention mechanisms to aggregate neighbor representations in undirected graphs; the authors compare and adapt GAT ideas but extend to directed labeled AMRs with separate incoming/outgoing attentions and scaled dot-product attention.",
            "citation_title": "Graph attention networks.",
            "mention_or_use": "mention",
            "representation_name": "graph attention (GAT-like)",
            "representation_description": "Use attention to weight neighbor contributions when aggregating node representations; the paper adapts the idea to directed labeled graphs using scaled dot-product attention and two separate attentions for incoming and outgoing edges.",
            "graph_type": "Graph-structured data; in this paper applied to AMR graphs.",
            "conversion_method": "Direct graph encoding via attention over neighbor relations (adapted from GAT but extended for directed labeled edges).",
            "downstream_task": "AMR-to-text generation (in this paper using adapted GAT concepts inside Graph Transformer).",
            "performance_metrics": "GAT itself is mentioned as prior work; the adapted graph-attention approach in Graph Transformer contributes to BLEU gains (Graph Transformer BLEU 25.9 gold-only).",
            "comparison_to_others": "GAT originally designed for undirected graphs without explicit edge labels or direction; Graph Transformer extends GAT by modeling directionality and edge labels and by using scaled dot-product attention instead of additive attention.",
            "advantages": "Attention allows flexible, learned weighting of neighbor contributions; adaptation permits directed, labeled edge handling.",
            "disadvantages": "Original GAT lacks label/direction modeling; naive adoption would miss important AMR information â€” motivates Graph Transformer design choices.",
            "failure_cases": "Not explicitly tested in original GAT form on AMR within this paper; direct GAT without edge labels/direction would likely underperform on AMR.",
            "uuid": "e8834.9"
        },
        {
            "name_short": "JAMR auto-parsing (data augmentation)",
            "name_full": "JAMR AMR parser used to auto-label Gigaword (Song et al., 2018 usage)",
            "brief_description": "An AMR parser used to automatically parse large corpora (Gigaword) into AMR graphs to produce additional paired training data (auto-labeled), which is then used for pretraining/fine-tuning models.",
            "citation_title": "",
            "mention_or_use": "use",
            "representation_name": "auto-parsed AMR pairs (Gigaword via JAMR)",
            "representation_description": "Large text corpus (Gigaword) is parsed by a pre-trained AMR parser (JAMR) to create (AMR graph, sentence) pairs that supplement scarce gold AMR data for training graph-to-text models.",
            "graph_type": "Automatically parsed AMR graphs from raw text",
            "conversion_method": "Use JAMR parser to convert raw sentences into AMR graphs; resulting pairs used as additional training data (pretrain on auto-labeled then fine-tune on gold).",
            "downstream_task": "AMR-to-text generation training (data augmentation / semi-supervised learning).",
            "performance_metrics": "Using 2M auto-labeled Gigaword instances with pretrain+fine-tune: Graph Transformer BLEU improves to 36.4 on LDC2015E86 (vs. 25.9 gold-only), indicating large gains when auto-labeled data used.",
            "comparison_to_others": "Pretraining on auto-labeled Gigaword improves all models; Transformer with linearized input benefits greatly (was 17.7 gold-only, 35.1 with 2M), but Graph Transformer remains best (36.4 with 2M).",
            "advantages": "Substantially increases effective training data and performance; especially helpful for models that can benefit from large-scale pretraining.",
            "disadvantages": "Quality depends on parser accuracy (noisy labels); mismatches between parser errors and generation targets can introduce noise.",
            "failure_cases": "May propagate parser errors into generation model; model reliance on large, auto-labeled corpora may mask deficiencies in modeling structure from small gold datasets.",
            "uuid": "e8834.10"
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Neural amr: Sequence-to-sequence models for parsing and generation.",
            "rating": 2,
            "sanitized_title": "neural_amr_sequencetosequence_models_for_parsing_and_generation"
        },
        {
            "paper_title": "Generation from abstract meaning representation using tree transducers.",
            "rating": 2,
            "sanitized_title": "generation_from_abstract_meaning_representation_using_tree_transducers"
        },
        {
            "paper_title": "Amr-to-text generation as a traveling salesman problem.",
            "rating": 2,
            "sanitized_title": "amrtotext_generation_as_a_traveling_salesman_problem"
        },
        {
            "paper_title": "Generating English from abstract meaning representations.",
            "rating": 2,
            "sanitized_title": "generating_english_from_abstract_meaning_representations"
        },
        {
            "paper_title": "Graph-to-sequence learning using gated graph neural networks.",
            "rating": 2,
            "sanitized_title": "graphtosequence_learning_using_gated_graph_neural_networks"
        },
        {
            "paper_title": "A graph-to-sequence model for AMR-to-text generation.",
            "rating": 2,
            "sanitized_title": "a_graphtosequence_model_for_amrtotext_generation"
        },
        {
            "paper_title": "Structural neural encoders for amr-to-text generation.",
            "rating": 2,
            "sanitized_title": "structural_neural_encoders_for_amrtotext_generation"
        },
        {
            "paper_title": "Graph attention networks.",
            "rating": 1,
            "sanitized_title": "graph_attention_networks"
        },
        {
            "paper_title": "Gated graph sequence neural networks.",
            "rating": 1,
            "sanitized_title": "gated_graph_sequence_neural_networks"
        }
    ],
    "cost": 0.0204075,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>AMR-To-Text Generation with Graph Transformer</p>
<p>Tianming Wang wangtm@pku.edu.cn 
The MOE Key Laboratory of Computational Linguistics
Wangxuan Institute of Computer Technology
Peking University
Peking University</p>
<p>Xiaojun Wan wanxiaojun@pku.edu.cn 
The MOE Key Laboratory of Computational Linguistics
Wangxuan Institute of Computer Technology
Peking University
Peking University</p>
<p>Hanqi Jin jinhanqi@pku.edu.cn 
The MOE Key Laboratory of Computational Linguistics
Wangxuan Institute of Computer Technology
Peking University
Peking University</p>
<p>AMR-To-Text Generation with Graph Transformer
10.1162/tacl
meaning representation (AMR)-totext generation is the challenging task of generating natural language texts from AMR graphs, where nodes represent concepts and edges denote relations. The current state-of-the-art methods use graph-to-sequence models; however, they still cannot significantly outperform the previous sequence-to-sequence models or statistical approaches. In this paper, we propose a novel graph-to-sequence model (Graph Transformer) to address this task. The model directly encodes the AMR graphs and learns the node representations. A pairwise interaction function is used for computing the semantic relations between the concepts. Moreover, attention mechanisms are used for aggregating the information from the incoming and outgoing neighbors, which help the model to capture the semantic information effectively. Our model outperforms the state-of-the-art neural approach by 1.5 BLEU points on LDC2015E86 and 4.8 BLEU points on LDC2017T10 and achieves new state-of-the-art performances.</p>
<p>Introduction</p>
<p>Abstract meaning representation (AMR) is a semantic formalism that abstracts away from the syntactic realization of a sentence, and encodes its definition as a rooted, directed, and acyclic graph. In the graph, the nodes represent the concepts, and edges denote the relations between the concepts. The root of an AMR binds its contents to a single traversable graph and serves as a rudimentary representation of the overall focus. The existence of co-references and control structures results in nodes with multiple incoming edges, called reentrancies, and causes an AMR to possess a graph structure, instead of a tree structure. Numerous natural language processing (NLP) tasks can benefit from using AMR, such as machine translation (Jones et al., 2012;Song et al., 2019), question answering (Mitra and Baral, 2016), summarization (Liu et al., 2015;Takase et al., 2016), and event extraction (Huang et al., 2016).</p>
<p>AMR-to-text generation is the task of recovering a text representing the same definition as a given AMR graph. Because the function words and structures are abstracted away, the AMR graph can correspond to multiple realizations. Numerous important details are underspecified, including tense, number, and definiteness, which makes this task extremely challenging (Flanigan et al., 2016). Figure 1 shows an example AMR graph and its corresponding sentence.</p>
<p>Early works relied on grammar-based or statistical approaches (Flanigan et al., 2016;Pourdamghani et al., 2016;Lampouras and Vlachos, 2017;Gruzitis et al., 2017). Such approaches generally require alignments between the graph nodes and surface tokens, which are automatically generated and can lead to error accumulation. In recent research, the graphs are first transformed into linear sequences, and then the text is generated from the inputs (Konstas et al., 2017). Such a method may lose information from the graph structure. The current state-of-theart neural methods are graph-to-sequence models and hybrid variants (Beck et al., 2018;Song et al., 2018;Damonte and Cohen, 2019). These methods use a graph state long short-term memory (LSTM) network, gated graph neural network (GGNN), or graph convolution network (GCN) to encode AMR graphs directly, and they can explicitly utilize the information provided by the graph structure. However, these graph encoders still cannot significantly outperform sequence encoders. The AMR-to-text generation task can be regarded as a distinct translation task, and basing it on the concepts of off-the-shelf methods Figure 1: An example AMR graph and its corresponding sentence. The graph is rooted by ''expect-01'', which means the AMR is about the expecting. The node ''create'' is a reentrance and it plays two roles simultaneously (i.e., ''ARG1'' of ''accelerate'' and ''ARG1'' of ''slow-down'').</p>
<p>for neural machine translation can be helpful. The Transformer model (Vaswani et al., 2017) is a stacked attention architecture and has shown its effectiveness in translation tasks; however, applying it to AMR-to-text generation has a major problem: It can only deal with sequential inputs.</p>
<p>To address these issues, we propose a novel graph network (Graph Transformer) for AMRto-text generation. Graph Transformer is an adaptation of the Transformer model, and it has a stacked attention-based encoder-decoder architecture. The encoder considers the AMR graph as the input and learns the node representations from the node attributes by the aggregation of the neighborhood information. The global semantic information is captured by stacked graph attention layers, which allow a node to deal with the hidden states of the neighbor nodes and their corresponding relations. Multiple stacked graph attention layers enable the nodes to utilize the information of those nodes that are not directly adjacent, allowing the global information to propagate. We consider that the AMR graph is a directed graph in which the directions hold extremely important information. Therefore, for encoding the information from the incoming and outgoing edges, we use two individual graph attentions in each layer. Then we utilize a fusion layer to incorporate the information from the incoming and outgoing relations, followed by a feed-forward network. Residual connections are used for connecting adjacent layers. The final node representations are formed by concatenating the two individual representations encoded by multiple layers. The decoder is similar to the original decoder in Transformer, performing multi-head attentions and self-attentions over the representations of the nodes in the encoder and over the hidden states of the decoder, respectively. For the decoder stack, we adopt a copy mechanism to generate the texts, which can help copy low-frequency tokens, such as named entities and numbers.</p>
<p>We perform experiments on two benchmark datasets (LDC2015E86 and LDC2017T10). Our model significantly outperforms the prior methods and achieves a new state-of-the-art performance. Without external data, our model improves the BLEU scores of the state-of-the-art and a mostly recently proposed neural model (i.e., g-GCNSEQ [Damonte and Cohen, 2019]) by 1.5 points on LDC2015E86 and 4.8 points on LDC2017T10. When using the Gigaword corpus as the additional training data, which is automatically labeled by a pre-trained AMR parser, our model achieves a BLEU score of 36.4 on LDC2015E86, which is the highest result on the dataset. The experimental result also shows that the improved structural representation encoding by our proposed graph encoder is most useful when the amount of training data is small. The variations in our model are evaluated to verify its robustness as well as the importance of the proposed modules. In addition, we study the performances of our model and baselines under different structures of the input graphs.</p>
<p>Our contributions can be summarized as follows:</p>
<p>â€¢ For AMR-to-text generation, we propose Graph Transformer, a novel graph-tosequence model based on the attention mechanism. Our model uses a pairwise interaction function to compute the semantic relations and uses separate graph attentions on the incoming and outgoing neighbors, which help in enhanced capturing of the semantic information provided in the graph. The code is available at https://github. com/sodawater/GraphTransformer.</p>
<p>â€¢ The experimental results show that our model achieves a new state-of-the-art performance on benchmark datasets. 20</p>
<p>AMR-to-Text Generation</p>
<p>Early work on AMR-to-text generation focused on statistical methods. Flanigan et al. (2016) transformed AMR graphs to appropriate spanning trees and applied tree-to-string transducers to generate texts. Song et al. (2016) partitioned an AMR graph into small fragments and generated the translations for all the fragments, whose order was finally decided by solving an asymmetric generalized traveling salesman problem. Song et al. (2017) used synchronous node replacement grammar to parse AMR graphs and generate output sentences. Pourdamghani et al. (2016) adopted a phrase-based machine translation model on the input of a linearized graph. Recent works propose using neural networks for generation. Konstas et al. (2017) used a sequence-to-sequence model to generate texts, leveraging an LSTM for encoding a linearized AMR structure. Graph-to-sequence models outperform sequence-to-sequence models, including a graph state LSTM (Song et al., 2018) and GGNN (Beck et al., 2018). A most recently developed hybrid neural model achieved the stateof-the-art performance by applying a BiLSTM on the output of a graph encoder GCN, to utilize both structural and sequential information (Damonte and Cohen, 2019).</p>
<p>Neural Networks for Graphs</p>
<p>Neural network methods for processing the data represented in graph domains have been studied for several years. Graph neural networks (GNNs) have also been proposed, which are an extension of recursive neural networks and can be applied to most of the practically useful types of graphs (Gori et al., 2005;Scarselli et al., 2009). GCNs are the main alternatives for neural-based graph representations, and are widely used to address various problems (Bruna et al., 2014;Duvenaud et al., 2015;Kipf and Welling, 2017). Li et al. (2015) further extended a GNN and modified it to use gated recurrent units for processing the data represented in graphs; this method is known as a GGNN. Beck et al. (2018) followed their concept and applied a GGNN to string generation. Another neural architecture based on gated units is the graph state LSTM (Song et al., 2018), which uses an LSTM structure for encoding graph-level semantics. Our model is most similar to graph attention networks (GATs) (Velickovic et al., 2018); it incorporates the attention mechanism in the information aggregation.</p>
<p>Transformer Network</p>
<p>Recurrent neural networks (RNNs) and convolution neural networks (CNNs) have been widely used in NLP tasks because of their advantages of capturing long-term and local dependencies, respectively. Compared with these networks, models based solely on the attention mechanism show superiority in terms of the parallelism and flexibility in the modeling dependencies. </p>
<p>Graph Transformer</p>
<p>The overall architecture of Graph Transformer is shown in Figure 2, with an example AMR graph and its corresponding sentence. We begin by providing the formal definition of the AMRto-text generation and the notations we use, and then reviewing the Transformer model. Then we introduce the graph encoder and sentence decoder used in our model. Finally, we describe the training and decoding procedures.</p>
<p>Problem Formulation and Notations</p>
<p>Given an AMR graph, G, our goal is to generate a natural language sentence that represents the same definition as G. Our model is trained to maximize the probability, P (S|G), where S is the gold sentence.</p>
<p>In the following, we define the notations used in this study. We assume a directed graph, G = (V, E), where V is a set of N nodes, E is a set of M edges, and N and M are the numbers of nodes and edges, respectively. Each edge in E can be represented as (i, j, l), where i and j are the indices of the source and target nodes, respectively, and l is the edge label. We further denote the incoming neighborhoods (i.e., reached by an incoming edge) of node v i âˆˆ V Figure 2: Left: Graph attention mechanism. We take the node ''accelerate'' in Figure 1 as an example. Head representation is marked with yellow and tail representation is marked with blue. The node ''accelerate'' has one incoming relation and two outgoing relations to be attend respectively; Right: The overall architecture of our proposed Graph Transformer.</p>
<p>as N in i and outgoing neighborhoods (i.e., reached by an outgoing edge) as N out i . The corresponding sentence is S = {s 1 , s 2 , ..., s T }, where s i is the i-th token of the sentence and T is the number of the tokens.</p>
<p>Transformer</p>
<p>Our model is adapted from the Transformer model, and here, we briefly review this model. The original Transformer network uses an encoderdecoder architecture, with each layer consisting of a multi-head attention mechanism and a feedforward network. Both the components are described here.</p>
<p>The multi-head attention mechanism builds on scaled dot-product attention, which operates on a package of queries Q and keys K of dimension
d k and values V of dimension d v , Attention(Q, K, V ) = softmax( QK âˆš d k )V (1)
The multi-head attention linearly projects d model -dimensional queries, keys, and values d h times with different projections, and it performs scaled dot-product attention on each projected pair. The outputs of the attention are concatenated and again projected, resulting in the final output,
head x = Attention(QW x q , KW x k , V W x v ) MultiHead(Q, K, V ) = d h x=1 head x W o (2) where denotes the concatenation of the d h attention heads. Projection matrices W x q âˆˆ R d k Ã—d model , W x k âˆˆ R d k Ã—d model , W x v âˆˆ R d v Ã—d model , and W o âˆˆ R d h * d v Ã—d model . d k = d v = d model /d h .
The other component of each layer is a feed-forward network. It consists of two linear transformations, with a ReLU activation in between.
FFN(x) = max(0, xW 1 + b 1 )W 2 + b 2(3)
For constructing a deep network and regularization, a residual connection and layer normalization are used to connect adjacent layers.</p>
<p>Graph Encoder</p>
<p>Our model also has an encoder-decoder architecture. In our model, the graph encoder is composed of a stack of L 1 identical graph layers that use different parameters from layer to layer. Each layer has three sub-layers: a graph attention mechanism, fusion layer, and feed-forward network. The encoder takes the nodes as the input and learns the node representations by aggregating the neighborhood information. Considering that an AMR graph is a directed graph, our model learns two distinct representations for each node. The first is a head representation, which represents a node when it works as a head node (i.e., a source node) in a semantic relation and only aggregates the information from the outgoing edges and corresponding nodes. The second is a tail representation, which represents a node when it works as a tail node (i.e., a target node) and only aggregates the information from the outgoing edges and corresponding nodes. Specifically, we denote âˆ’ â†’ h t i and â† âˆ’ h t i as the head representation and tail representation of each node v i at the t-th layer, respectively. The embedding of each node (i.e., the word embedding of the concept) is fed to the graph encoder as the initial hidden state of the node,
âˆ’ â†’ h 0 i = â† âˆ’ h 0 i = e i W e + b e(4)
where e i is the embedding of node v i , W e âˆˆ R d emb Ã—d model and b e âˆˆ R d model are the parameters, and d emb is the dimension of the embedding. Different from previous methods, we propose using graph attention as the aggregator, instead of a gated unit or pooling layer. In an AMR graph, the semantic representation of a node is determined by its own concept definition and relations to other concepts. Graph attention is used for capturing such global semantic information in a graph. Specifically, it allows each node to deal with the triples that are composed of the embeddings of the neighbor nodes, embeddings of the corresponding edges, and its own embedding. We represent the triple of two adjacent nodes connected by edge (i, j, l) as
r t ij = âˆ’ â†’ h tâˆ’1 i e l â† âˆ’ h tâˆ’1 j W r + b r (5) r t ij = âˆ’ â†’ h tâˆ’1 i e l â† âˆ’ h tâˆ’1 j W r + b r , (6) where e l âˆˆ R d model is the embedding of edge label l and âˆ’ â†’ h tâˆ’1 i e l â† âˆ’ h tâˆ’1 j
is the concatenation of these three representations. W r âˆˆ R 3d model Ã—d model and b r âˆˆ R d model are the parameters. r t ij is the representations of the triple, which will be deal with both source node v i and target node v j .</p>
<p>Using such a pairwise-interaction function to compute a relation has three advantages: 1) it does not encounter the parameter explosion problem (Beck et al., 2018) because the linear transformation for the triple is independent of the edge label, 2) the edge information is encoded by edge embedding so that there is no loss of information, and 3) the representation incorporates the context information of the nodes. Then we perform graph attentions over the incoming and outgoing relations (i.e., incoming and outgoing edges and the corresponding nodes). The multihead graph attentions for node v i are computed as
âˆ’ â†’ g t i = d h x=1 âŽ› âŽ jâˆˆN out i Î± x ij r t ij W x v âŽž âŽ  W o Î± x ij = exp âˆ’ â†’ h tâˆ’1 i W x q Â·(r t ij W x k ) âˆš d k zâˆˆN out i exp âˆ’ â†’ h tâˆ’1 i W x q Â·(r t iz W x k ) âˆš d k (7)
where âˆ’ â†’ g t i is the output of the graph attention on the outgoing relations for node v i . Similarly, â† âˆ’ g t i is computed over all the incoming relations.</p>
<p>Following the graph attention sub-layer, we use a fusion layer to incorporate the information aggregated from the incoming and outgoing relations.
s t i = sigmoid âˆ’ â†’ g t i â† âˆ’ g t i W s + b s g t i = s t i * âˆ’ â†’ g t i + (1 âˆ’ s t i ) * â† âˆ’ g t i (8) where W s âˆˆ R 2 * d model Ã—1 and b s âˆˆ R 1 are the parameters.
The last sub-layer is a fully connected feedforward network, which is applied to each node separately and identically. We use a GeLU activation function instead of the standard ReLU activation. The dimensions of the input, inner layer, and output are d model , 4 * d model , and 2 * d model , respectively. The output is divided into two parts to obtain the head and tail representations, respectively. In addition, a residual connection is used to connect adjacent layers.</p>
<p>âˆ’ â†’
O t â† âˆ’ O t = F F N(G t ) âˆ’ â†’ H t = LayerNorm( âˆ’ â†’ O t + âˆ’ â†’ H tâˆ’1 ) â† âˆ’ H t = LayerNorm( â† âˆ’ O t + â† âˆ’ H tâˆ’1 ) (9) where G t i is the package of outputs g t i . âˆ’ â†’ H t and â† âˆ’ H t are the packages of head representation âˆ’ â†’ h t i and tail representation â† âˆ’ h t i , respectively.
LayerN orm is the layer normalization. Note that using a residual connection and layer normalization around each layer in the graph encoder is more effective than using them around each of the three sub-layers for our model.</p>
<p>The final node representation is obtained by concatenating the forward and backward representations. A linear transformation layer is also used for compressing the dimension. For convenience, we denote h i as the final representation of node v i ,
h i = âˆ’ â†’ h L 1 i â† âˆ’ h L 1 i W h(10)
where W h âˆˆ R 2d model Ã—d emb is a parameter and L 1 is the number of layers of the encoder stack.</p>
<p>Sentence Decoder</p>
<p>In our model, the decoder has an architecture similar to that in the original Transformer model, which is composed of L 2 identical layers. Each layer has three sub-layers: a multi-head self-attention mechanism, multi-head attention mechanism over the output of the encoder stack, and position-wise feed-forward network. A residual connection is used for connecting adjacent sub-layers. The decoder generates the natural language sentence, and we denote the hidden state at position i of the t-th layer in the decoder stack asÄ¥ t i . Different from the input representation of the encoder, the position information is added and the sum of the embedding and position encoding is fed as the input,
h 0 i = e i W e + b e + pe i(11)
where e i and pe i âˆˆ R d model are the embedding and positional encoding of the token at position i, respectively. The self-attention sub-layer is used for encoding the information of the decoded subsequences. We use masking to ensure that the attention and prediction for position i depend only on the known words at positions preceding i,
A t = MultiHead(Ä¤ tâˆ’1 ,Ä¤ tâˆ’1 ,Ä¤ tâˆ’1 ) B t = LayerNorm(A t +Ä¤ tâˆ’1 )(12)
whereÄ¤ tâˆ’1 is the package of hidden statesÄ¥ tâˆ’1 i in the decoder. Next, the output of the self-attention is further fed into the multi-head attention and feed-forward network, expressed as follows:
A t = MultiHead(B t , H, H) B t = LayerNorm(Ã‚ t + B t ) O t = FFN(B t ) H t = LayerNorm(Ã” t +B t )(13)
where H is the package of final node representations h i encoded by the graph encoder.</p>
<p>For convenience, we denote the final hidden state of the decoder at position i asÄ¥ i . Considering that numerous low-frequency open-class tokens such as named entities and numbers in an AMR graph appear in the corresponding sentence, we adopt the copy mechanism (Gu et al., 2016) to solve the problem. A gate is used over the decoder stack for controlling the generation of words from the vocabulary or directly copying them from the graph, expressed as
Î¸ i = Ïƒ(Ä¥ i W Î¸ + b Î¸ )(14)
where W Î¸ âˆˆ R d model Ã—1 and b Î¸ âˆˆ R 1 are the parameters. Probability distribution p g i of the words to be directly generated at time-step i is computed as
p g i = softmax(Ä¥ i W g + b g )(15)
where W g âˆˆ R d model Ã—d vocab and b g âˆˆ R d vocab are the parameters and d vocab is the vocabulary size. Probability distribution p c i of the words to be copied at time-step i is computed as
p c i = N i * =1 exp Ä¥ i Â· h i * N j * =1 exp Ä¥ i Â· h j * z i *(16)
where z i * is the one-hot vector of node v i * . The final probability distribution of the words at time-step i is the interpolation of two probabilities,
p i = Î¸ i * p g i + (1 âˆ’ Î¸ i ) * p c i(17)</p>
<p>Training and Decoding</p>
<p>For the training, we aim to maximize the likelihood of each gold-standard output sequence, S, given the graph, G.
l(S|G) = T i=1 log P (s i |s iâˆ’1 , ..., s 1 , G, Î¸) (18)
whereÎ¸is the model parameter. P (s i |s iâˆ’1 , ..., s 1 , G, Î¸) corresponds to the probability score of word s i in p i computed by Eq. (16). We use the beam search to generate the target sentence during the decoding stage.</p>
<p>Comparison to Prior Graph Encoders</p>
<p>In this section, we compare our proposed graph encoders with the existing ones presented in prior works.</p>
<p>Most models, including a GCN (Damonte and Cohen, 2019), GGNN (Beck et al., 2018), and GraphLSTM (Song et al., 2018), use a nonpairwise interaction function to represent the information to be aggregated from the neighborhoods. Specifically, they ignore the receiver node (i.e., the node to be updated), operating only on the sender node (i.e., the neighbor node) and the edge attribute (Battaglia et al., 2018). They add a self-loop edge for each node so that its own information can be considered. In our model, we compute the pairwise interactions using Eq. (5); hence, no self-loop edge is required.</p>
<p>In our model, the graph attention mechanism is similar to GAT (Velickovic et al., 2018). The main differences are that GAT is designed for undirected graphs and neither directions nor labels of edges are considered. We propose using two distinct representations (i.e., head representation and tail representation) for each node and utilizing graph attentions on the incoming and outgoing relations. Accordingly, the model can consider the differences in the incoming and outgoing relations, and the results presented in the next section verify the effectiveness of this proposed modification. In addition, GAT adopts additive attention and uses averages of the outputs of the multi-head attention in the final layer. In our model, we use a scaled dot-product attention for all the attention layers.</p>
<p>Experiment</p>
<p>Data and Preprocessing</p>
<p>We used two standard AMR corpora (LDC2015E86 and LDC2017T10) as our experiment datasets. The LDC2015E86 dataset contains 16,833 instances for the training, 1,368 for the development, and 1,371 for the test. The LDC2017T10 dataset is the latest AMR corpus release, which contains 36,521 instances for the training and the same instances for the development and test as in LDC2015E86. Most prior works evaluate their models on the former dataset. Because prior approaches during the same period achieve the state-of-the-art performances on LDC2015E86 and LDC2017T10, respectively, we performed experiments on both the datasets.</p>
<p>Following Konstas et al. (2017), we supplemented the gold data with large-scale external data. We used the Gigaword corpus 1 released by Song et al. (2018) as the external data, which was automatically parsed by the JAMR. For the training on both the gold data and automatically labeled data, the same training strategy as that of Konstas et al. (2017) was adopted, which was fine-tuning the model on the gold data after each epoch of the pre-training on the Gigaword data.</p>
<p>Parameter Settings and Training Details</p>
<p>We set our model parameters based on preliminary experiments on the development set. d model is set to 256 and d emb is set to 300. The head number of attention is set to 2. The numbers (L 1 and L 2 ) of layers of the encoder and decoder are set to 8 and 6, respectively. The batch size is set to 64. We extract a vocabulary from the training set, which is shared by both the encoder and the decoder. The word embeddings are initialized from GloVe word embeddings (Pennington et al., 2014). We use the Adam optimizer (Kingma and Ba, 2015) with lr = 0.0002, Î² 1 = 0.9, Î² 2 = 0.98, and = 10 âˆ’9 . Learning rate is halved every time perplexity on the development set does not improve for two epochs. We apply dropout to the output of each attention sub-layer and the input embeddings, and use a rate of P drop = 0.3. Beam search with beam size to 6 is used for decoding. During training, we filter out instances with more than 100 nodes in graph or 100 words in sentence for speeding up. Note that d model is set to 512, the head number is set to 4, and the learning rate is set to 0.0001 when training on both gold data and automatically labeled data.</p>
<p>Metrics and Baselines</p>
<p>Following existing works, we evaluate the results with the BLEU metric (Papineni et al., 2002). We also report the results using CHRF++ (PopoviÄ‡, 2017), similar to Beck et al. (2018).</p>
<p>Our direct baseline is the original Transformer, which takes a linearized graph as the input. We use the same linearization as that by Konstas et al. (2017). We also compare our model with prior statistical approaches (PBMT, Tree2Str, and TSP), sequence-to-sequence approaches (S2S+Anon and S2S+Copy), the current state-of-the-art Methods BLEU PBMT (Pourdamghani et al., 2016) 26.9 Tree2Str (Flanigan et al., 2016) 23.0 TSP (Song et al., 2016) 22.4 S2S+Anon (Konstas et al., 2017) 22.0 GraphLSTM (Song et al., 2018) 23.3 t-GCNSEQ (Damonte and Cohen, 2019) 23.9 g-GCNSEQ (Damonte and Cohen, 2019) 24.4 Transformer 17.7 Graph Transformer 25.9 S2S+Anon (2M) (Konstas et al., 2017) 32.3 S2S+Anon (20M) (Konstas et al., 2017) 33.8 S2S+Copy (2M) (Song et al., 2018) 31.7 GraphLSTM (2M) (Song et al., 2018) 33.6 Transformer (2M) 35.1 Graph Transformer (2M) 36.4 Table 1: Test results of models. ''(2M)'' / ''(20M)'' denotes using the corresponding number of automatically labeled Gigaword data instances as additional training data.</p>
<p>graph-to-sequence approaches (GraphLSTM and GGNN), and hybrid approaches (t-GCNSEQ and g-GCNSEQ). PBMT (Pourdamghani et al., 2016) adopts a phrased-based machine translation model with the input of a linearized AMR graph. Tree2Str (Flanigan et al., 2016) converts AMR graphs into trees by splitting the reentrants and applies a treeto-string transducer to generate text. TSP (Song et al., 2016) solves the generation problem as a traveling salesman problem. S2S+Anon (Konstas et al., 2017) is a multi-layer attention-based bidirectional LSTM model, which is trained with anonymized data. S2S+Copy (Song et al., 2018) is also an attention-based LSTM model, but it instead uses the copy mechanism. GGNN (Beck et al., 2018) uses a gated graph neural network to encode the AMR graph and an RNN-based decoder to generate the text. GraphLSTM (Song et al., 2018) utilizes a graph state LSTM as the graph encoder and uses the copy mechanism instead of anonymization. T-GCNSEQ (Damonte and Cohen, 2019) also splits the reentrancies and applies stacking of the encoders to encode the tree, in which BiLSTM networks are used on top of the GCN for utilizing both the structure and sequential information. G-GCNSEQ has the same architecture as t-GCNSEQ, but it directly encodes the graph rather than the tree. Tree2Str, TSP, S2S+Anon, S2S+Copy, and GraphLSTM have been trained on LDC2015E86. PBMT has been trained on a previous release of the corpus (LDC2014T12). 2 Note that PBMT, Tree2Str, and TSP also train and use a language model based on an additional Gigaword corpus. GGNN has been trained on LDC2017T10. T-GCNSEQ and g-GCNSEQ have been trained on both LDC2015E86 and LDC2017T10. Table 1 summarizes the results of the models using LDC2015E86 as the gold training data. When trained only on the gold training data, our model achieves the best BLEU score of 25.9 among all the neural models and outperforms S2S+Anon by 3.9 BLEU points. Compared with the graph-tosequence model, GraphLSTM, our model is 2.6 BLEU points higher, which shows the superiority of our proposed architecture. Our model also outperforms hybrid models t-GCNSEQ and g-GCNSEQ by 2.0 points and 1.5 points, respectively. Comparing the two sequence-to-sequence neural models, Transformer underperforms the RNN-based model (S2S+Anon). This is in plain contrast to their performances in machine translation. The reason is attributed to the possible extreme length of the linearized AMR graph and difficulty in performing self-attention to obtain a good context representation of each token with a small training data. Our proposed Graph Transformer does not encounter this problem, which is significantly better than Transformer, and improves the BLEU score by more than 8 points. It also shows that our proposed deep architecture is even effective with a small training data. The results of statistical approaches PBMT, Tree2Str, and TSP are not strictly comparable because they use an additional Gigaword corpus to train the language model. Our model still outperforms the Tree2Str and TSP and performs close to the PBMT. Following the approach of Konstas et al. (2017), we also evaluate our model using automatically labeled Gigaword data as additional training data. When using external data, the performance of our model is improved significantly. Utilizing 2M gigaword data, the performance of our model improves by 10.5. With the 2M additional data, our model achieves the new state-of-the-art BLEU score of 36.4 points, which is 4.7 and 2.8 points</p>
<p>Comparison Results</p>
<p>Methods</p>
<p>BLEU CHRF++</p>
<p>GGNN (Beck et al., 2018) 23.3 50.4 GGNN(ensemble) (Beck et al., 2018) 27.5 53.5 t-GCNSEQ (Damonte and Cohen, 2019) 24.1 âˆ’ g-GCNSEQ (Damonte and Cohen, 2019) 24.5 âˆ’  higher than those of S2S+Copy and GraphLSTM using the same training data, respectively. Transformer achieves a BLEU score of 35.1, which is much higher compared with that achieved with the one trained on the gold data. This verifies the effectiveness of a deep neural model when the training dataset is sufficiently big. With 20M external data, the S2S+Anon obtains a BLEU score of 33.8, which is much worse than our model score. We speculate the performance can be further improved with a relatively larger number of external data; however, we do not attempt this owing to hardware limitations. Note that the CHRF++ score is not reported for these approaches in previous works; therefore, we do not compare it in this experiment. Table 2 lists the results of the models trained on LDC2017T10. Our model strongly outperforms GGNN, and improves the BLEU score by 6.0 points and the CHRF++ score by 8.6 points. Hybrid models t-GCNSEQ and g-GCNSEQ achieve BLEU scores of 24.1 and 24.5, which are 5.2 and 4.8 points lower than those of our model, respectively. Compared with the same model with smaller gold training data in Table 1, the BLEU score of our model is also improved by 3.4 points and the scores of t-GCNSEQ and g-GCNSEQ are improved by only 0.2 and 0.1 points, respectively. This indicates that the performance of our model can easily benefit from more gold training data. Beck et al. (2018) also reported the scores of GGNN ensemble, which achieves a BLEU score of 27.5 and a CHRF++ score of 53.5; these scores are even much worse than those of our single model.</p>
<p>Model Variations</p>
<p>To evaluate the importance of the different components of our proposed Graph Transformer, we vary our model and perform both hyper-parameter and ablation studies. We train the models on both LDC2015E86 and LDC2017T10 and measure the performance changes on the development set, and the results are listed in Table 3.</p>
<p>Hyper-Parameter Tuning</p>
<p>In Table 3 (A), we vary the number of transition steps (i.e., number of layers), L 1 , in the graph encoder. As we can see, the performance of our model increases as L 1 increases; however, it starts decreasing gradually when L 1 becomes larger than 8. Our model achieves the best performance when L 1 equals 8. This shows that incorporating the information from the nodes with a long distance can help improve capture of the global semantic information. The reason for this performance drop when L 1 is larger than 8 may be attributed to the over-fitting because the amount of training data is not large. In addition, we also compare the BLEU scores of our model and GraphLSTM with the same number of transition steps. These models are only trained on LDC2015E86. Results on the development set are shown in Figure 3. Compared with the performance of the GraphLSTM, our model performs consistently and significantly better when L 1 , which varies from 1 to 10. This indicates that our proposed graph encoder has a stronger ability of utilizing both local and global semantic information.</p>
<p>In Table 3 (B), we vary the number of layers in the decoder, L 2 . Our model achieves the best performance when L 2 equals 6, and its performance drops significantly when L 2 decreases. With few layers, the decoder might not be able to utilize the information provided by the graph encoder and generate fluent sentences. An extremely large  L 2 also adversely affects the performance, particularly when training on the smaller dataset.</p>
<p>In Table 3 (C), we observe that larger models do not lead to better performance. We attribute the reason to the number of training pairs being quite small. In Table 3 (D), we observe that the models, trained on a small dataset, are extremely sensitive to the number of heads, d h . The singlehead attention is 1.9 BLEU points worse than the best setting. The performance also deceases with too many heads. Using more training data, our model becomes more stable and insensitive to d h . In Table 3 (E), we can see that a suitable rate of dropout is extremely helpful for avoiding over-fitting.</p>
<p>Ablation Study</p>
<p>We further perform an ablation study on two datasets to investigate the influence of the modules in the graph encoder. We fix the sentence decoder of our model because it is similar to the original one in Transformer. The modules in the graph encoder are tested by two methods: using a single representation for each node (i.e., the head representation and tail representation are updated with shared parameters), and using a single representation and performing the inseparate graph attention over the incoming and outgoing relations simultaneously (i.e., the output of the attention in Eq. (7) 
is g t i = d h x=1 ( jâˆˆN in i N out i Î± x ij r t ij W x v )
W o and the fusion layer is discarded). These modifications test the effectiveness of the separate graph attentions.</p>
<p>The results are presented in Table 3 (F). We can see that using a single representation for each node results in a loss of 0.4 and 0.5 BLEU points on the two datasets, respectively. It indicates that learning the head representation and tail representation for each node is helpful. We further observe that without separated graph attentions (i.e., in inseparate graphattention), the performance of our model drops, suffering a loss of 2.4 BLEU points on the LDC2015E86 dataset and 1.2 on LDC2017T10. We consider that the relations represented by the incoming edges and outgoing edges are different. Moreover, projecting them into the same space for the graph attentions might cause confusion, particularly when the number of training data is small. Separate graph attentions can help the model better capture the semantics.</p>
<p>Compared with the prior methods, there are two changes in our model: the graph encoder and the Transformer decoder. To study the influences of the different encoders and decoders, we implement three encoders (RNN encoder, Transformer   encoder, and our graph encoder) and two decoders (RNN decoder and Transformer decoder). We also perform a study of their combinations. Table 4 presents the results. We find an interesting phenomenon that simply mixing Transformer-based networks with RNNs can lead to a large decrease in the performance. Irrespective of replacing the RNN decoder with the Transformer decoder in S2S or replacing the Transformer decoder with the RNN decoder in Transformer and Graph Transformer, the replaced models perform much worse than the original ones. This indicates that there is a mismatch in using an RNN (or Transformer) to decode a sentence from the representations encoded by Transformer-based networks (or RNNs). The superior performance of our model is owing to the interplay of the Transformer-based graph encoder and the Transformer decoder.</p>
<p>Performance Against Size and Structure of AMR Graph</p>
<p>To study the advantages of our proposed model against prior sequence-to-sequence models and   graph models further, we compare the results of the models on different sizes and structures of the AMR graphs. All the models are trained on LDC2015E86. We consider the size and structure of a graph in three approaches: depth, number of edges, and number of reentrancies. The depth of an AMR graph is defined as the longest distance between the AMR node and its root. The deeper the graph, the longer the dependency. Table 5 lists the counts of the AMR graphs with different depths for the test split and the results of different models on these graphs. We can see that the graph models outperform the sequence-to-sequence model, but the gap narrows when the depth increases. GraphLSTM outperforms the S2S by 3.9 points when the depth is less than 6, and the gap is only 0.7 points when the depth is larger than 10. Compared with GraphLSTM, Graph Transformer returns better performance on deeper graphs, which shows that our model is more powerful for capturing long-term dependencies.</p>
<p>The edges in an AMR graph represent the semantic relations of the concepts. The more the edges in the graph, the more semantic information is represented and usually the larger the graph. Table 6 lists the counts of the AMR graphs with different number of edges for the test split and  the corresponding BLEU scores of the different models. We observe that all the models have much better performances on small graphs than on large ones. Similar to the phenomena based on Table 4, our model shows a stronger ability in dealing with more semantic relations than GraphLSTM.</p>
<p>Following Damonte and Cohen (2019), we also study the influence of the reentrancies in the graph. Reentrancies represent the co-references and control structures in AMR and make it a graph rather than a tree. A graph with more reentrancies is typically more complex. From Table 7, we can see that the performance of all the models drop significantly when the number of reentrancies increases. With more reentrancies, the lead of the graph-to-sequence models over the sequenceto-sequence model also narrows. We consider that this is because the reentrancies increase the complexity of the graph structure and make the graph models difficult to learn the semantic representation. Our model exhibits an extremely strong performance when the input degrades into a tree. This is because we use two graph attentions over the incoming and outgoing edges, respectively, and only one incoming edge makes the model easy to learn and train. In addition, our model outperforms S2S by 2.9 points when the input graphs have more than 3 reentrancies. In comparison, GraphLSTM achieves nearly an identical result to that of S2S, which indicates that our proposed encoder is also better in dealing with complex graphs than GraphLSTM.</p>
<p>Case Study</p>
<p>We perform case studies to provide a better understanding of the model performance. We compare the outputs of S2S, GraphLSTM, and our Graph Transformer trained on the gold data of LDC2015E86. We observe that there are several common error types in the outputs of these systems: 1) generating unnatural language or unreadable sentences; 2) missing information from the input graph; 3) generating words or tokens inconsistent with the given semantic representation (i.e., mistranslation of the nodes in the graph); 4) mixing the semantic relations between the entities (i.e., mistranslation of the edges in the graph).</p>
<p>To exhibit how systematic these errors are explicitly, we manually evaluate 50 randomly sampled outputs from each compared system, and count the ratio of the outputs with each error type. Note that these four types of errors are not mutually exclusive. Table 8 lists the results. We can clearly see that these four types of errors occur in all the three systems, and Graph Transformer performs the best by comparison. Compared with S2S and GraphLSTM, our model Graph Transformer significantly covers more information from the input graph. All the models make more mistakes on the fluency aspect than on other three aspects. This is because both the missing information from the input graph and the mistranslation of the nodes and edges can cause a generated sentence to be unnatural or unreadable.</p>
<p>In addition, we present several example outputs in Table 9. AMR denotes the input graph and Ref denotes the reference output sentence.</p>
<p>In the first case, we can see that S2S fails to generate a fluent sentence. It also omits the concept, work, and therefore, adversely affects the semantic relation between you and hard. GraphLSTM omits the adverb hard and generates an adverb really for verb work, which is only supposed to modify verb want. Graph Transformer generates a basically correct answer.</p>
<p>In the second case, the AMR graph is more complex. S2S mistranslates the concept, stand, as take away and omits adjective passive. The verb, plant, is also omitted, which might be caused by the long distance between plant and pressure in the linearized input. Moreover, the entire sentence is unreadable owing to numerous grammar mistakes. GraphLSTM also omits the concept, passive, and fails to generate the clause headed by stand. In addition, it makes a mistake at the conjunction between the pressure and Table 9: Example outputs of different systems are compared, including S2S, GraphLSTM, and Graph Transformer.</p>
<p>f armers. Our model does not omit any concept in the graph, but the generated sentence is not highly fluent. It treats the stand and pressure as predicates and fails to generate take and put because they are explicitly given in the graph.</p>
<p>In the last case, all three models fail to capture the concept, employ, and disturbs the relations between person, employ, and company. S2S omits the adjective, oil, and mistranslates the concept, participate, as part of. GraphLSTM is completely confused in this case and even fails to generate the word, June, from the relation, :month 6. Our Graph Transformer correctly generates the sentence constituents other than the subject.</p>
<p>Specifically, the four types of errors occur in all the three models, particularly when the input graph is complex. Compared with S2S and GraphLSTM, our model is less likely to miss the information from the input, and it can generate sentences with high quality, in terms of the fluency and fidelity to the input semantics.</p>
<p>Conclusion</p>
<p>In this study, we present a novel graph network (Graph Transformer) for AMR-to-text generation. Our model is solely based on the attention mechanism. Our proposed graph attentions over the neighbor nodes, and the corresponding edges are used for learning the representations of the nodes and capturing global information. The experimental results shows that our model significantly outperforms the prior neural models and achieves a new state-of-the-art performance on benchmark datasets.</p>
<p>In future work, we will incorporate BERT embeddings and multi-task learnings to improve the performance further. We will also apply Graph Transformer to other related text generation tasks like MRS-to-text generation, data-to-text generation, and image captioning.</p>
<p>Recently, RNN/CNN-free networks have attracted increasing interests. Vaswani et al. (2017) proposed a stacked attention architecture, the Transformer model, for neural machine translation. Gu et al. (2018) introduced a non-autoregressive translation model based on the transformer. Zhang et al. (2018) integrated the paraphrase rules and the Transformer model, for sentence simplification. Devlin et al. (2018) proposed a language representation model called BERT, which achieved new state-of-the-art results on 11 NLP tasks.</p>
<p>Figure 3 :
3Development results of Graph Transformer and GraphLSTM against transition steps in the graph encoder.</p>
<p>Table 2 :
2Test results of models trained on LDC2017T10.</p>
<p>Table 3 :
3Development results of the variations on Graph Transformer. Unlisted values are 
identical to those of the base model. Both models trained on LDC2015E86 and LDC2017T10 
are evaluated. </p>
<p>Table 4 :
4Development results of models with three 
different encoders and two different decoders. 
A+B represents the model with A encoder and 
B decoder. RNN encoder and decoder are abbre-
viated to RNN, Transformer encoder and decoder 
are abbreviated to TFM and our Graph encoder are 
abbreviated to Graph. </p>
<p>Model 
Depth 
1âˆ’5 6âˆ’10 11âˆ’ </p>
<h1>count</h1>
<p>278 
828 
265 </p>
<p>S2S 
37.2 21.2 19.3 
GraphLSTM 
+3.9 +2.1 +0.7 
Graph Transformer +6.0 +4.5 +3.7 </p>
<p>Table 5 :
5Counts of AMR graphs with different depth for the test split and the BLEU scores of different models on these graphs.</p>
<p>Table 6 :
6Counts of AMR graphs with different number of edges for the test split and the BLEU scores of different models on these graphs.Model 
Number of reentrancies 
0 
1âˆ’3 
4âˆ’ </p>
<h1>count</h1>
<p>624 566 
181 
S2S 
26.6 21.2 
15.3 
GraphLSTM 
+2.9 +2.4 
+0.1 
Graph Transformer +7.1 +4.0 
+2.9 </p>
<p>Table 7 :
7Counts of AMR graphs with different number of reentrancies for the test split and the BLEU scores of different models on these graphs.</p>
<p>Table 8 :
8The ratio of outputs with each error type for each compared system. Lower percentage is better.
https://www.cs.rochester.edu/âˆ¼lsong10/ downloads/2m.json.gz.
The LDC2014T12 dataset contains 10,313 instances for the training and the same instances for the development and test as in case of LDC2015E86.
AcknowledgmentsThis work was supported by National Natural Science Foundation of China (61772036) and Key Laboratory of Science, Technology and Standard in Press Industry (Key Laboratory of Intelligent Press Media Technology). We thank the anonymous reviewers for their helpful comments. Xiaojun Wan is the corresponding author.AMR:(h / have-condition-91:ARG1 (w / work-01 :ARG0 (y / you) :ARG1-of (h2 / hard-02)) :ARG2 (w2 / want-01 :ARG0 y :ARG2 (o / out) :mod (r / really))) :mod (t2 / this))) :op2 (p2 / pressure-01 :ARG0 c :ARG1 (p5 / person :mod (c3 / country :wiki ''Afghanistan'' :name (n2 / name :op1 ''Afghanistan'')) :ARG0-of (f / farm-01)) :ARG2 (p3 / plant-01 :ARG0 p5 :ARG1 (p4 / poppy :mod (o / opium))) :degree (l / less))) Ref:The Taliban this year are taking a passive stance toward cultivation and putting less pressure on Afghan farmers to plant opium poppy. S2S: the Taliban will take away with cultivation of cultivate this year and pressure on Afghan farmers less with opium poppy in them. GraphLSTM: The Taliban has been standing in the cultivation this year and less pressure from the Afghan farmers to plant opium poppies. Graph Transformer: The Taliban has stood passive in cultivation this year and has less pressured Afghan farmers to plant opium poppies.
Peter Battaglia, Jessica B Hamrick, Victor Bapst, Alvaro Sanchezgonzalez, Mateusz Vinicius Flores Zambaldi, Andrea Malinowski, David Tacchetti, Adam Raposo, Ryan Santoro, Faulkner, arXiv preprint: 1806.01261Relational inductive biases, deep learning, and graph networks. and othersPeter Battaglia, Jessica B. Hamrick, Victor Bapst, Alvaro Sanchezgonzalez, Vinicius Flores Zambaldi, Mateusz Malinowski, Andrea Tacchetti, David Raposo, Adam Santoro, Ryan Faulkner, and others. 2018. Relational induc- tive biases, deep learning, and graph networks. arXiv preprint: 1806.01261.</p>
<p>Graph-to-sequence learning using gated graph neural networks. Daniel Beck, Gholamreza Haffari, Trevor Cohn, Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics. the 56th Annual Meeting of the Association for Computational Linguistics1Daniel Beck, Gholamreza Haffari, and Trevor Cohn. 2018. Graph-to-sequence learning using gated graph neural networks. In Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), volume 1, pages 273-283.</p>
<p>Joan Bruna, Wojciech Zaremba, Arthur Szlam, Yann Lecun, Spectral networks and locally connected networks on graphs. International Conference on Learning Representations. Joan Bruna, Wojciech Zaremba, Arthur Szlam, and Yann Lecun. 2014. Spectral networks and locally connected networks on graphs. International Conference on Learning Repre- sentations.</p>
<p>Marco Damonte, Shay B Cohen, arXiv:1903.11410v1Structural neural encoders for amr-to-text generation. arXiv preprintMarco Damonte and Shay B. Cohen. 2019. Struc- tural neural encoders for amr-to-text generation. arXiv preprint arXiv:1903.11410v1.</p>
<p>Jacob Devlin, Ming-Wei Chang, Kenton Lee, Kristina Toutanova, arXiv:1810.04805Bert: Pretraining of deep bidirectional transformers for language understanding. arXiv preprintJacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2018. Bert: Pre- training of deep bidirectional transformers for language understanding. arXiv preprint arXiv:1810.04805.</p>
<p>Convolutional networks on graphs for learning molecular fingerprints. David K Duvenaud, Dougal Maclaurin, Jorge Iparraguirre, Rafael Bombarell, Timothy Hirzel, AlÃ¡n Aspuru-Guzik, Ryan P Adams, Advances in Neural Information Processing Systems. David K. Duvenaud, Dougal Maclaurin, Jorge Iparraguirre, Rafael Bombarell, Timothy Hirzel, AlÃ¡n Aspuru-Guzik, and Ryan P. Adams. 2015. Convolutional networks on graphs for learning molecular fingerprints. In Advances in Neural Information Processing Systems, pages 2224-2232.</p>
<p>Generation from abstract meaning representation using tree transducers. Jeffrey Flanigan, Chris Dyer, Noah A Smith, Jaime Carbonell, Proceedings of the 2016 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies. the 2016 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language TechnologiesJeffrey Flanigan, Chris Dyer, Noah A. Smith, and Jaime Carbonell. 2016. Generation from abstract meaning representation using tree transducers. In Proceedings of the 2016 Con- ference of the North American Chapter of the Association for Computational Linguistics: Hu- man Language Technologies, pages 731-739.</p>
<p>A new model for learning in graph domains. Marco Gori, Gabriele Monfardini, Franco Scarselli, Proceedings. 2005 IEEE International Joint Conference on Neural Networks. 2005 IEEE International Joint Conference on Neural NetworksIEEE2Marco Gori, Gabriele Monfardini, and Franco Scarselli. 2005. A new model for learning in graph domains. In Proceedings. 2005 IEEE International Joint Conference on Neural Networks, 2005., volume 2, pages 729-734. IEEE.</p>
<p>Rigotrio at SemEval-2017 task 9: combining machine learning and grammar engineering for amr parsing and generation. Normunds Gruzitis, Didzis Gosko, Guntis Barzdins, Proceedings of the 11th International Workshop on Semantic Evaluation. the 11th International Workshop on Semantic EvaluationAssociation for Computational LinguisticsNormunds Gruzitis, Didzis Gosko, and Guntis Barzdins. 2017. Rigotrio at SemEval-2017 task 9: combining machine learning and grammar engineering for amr parsing and generation. In Proceedings of the 11th International Work- shop on Semantic Evaluation (SemEval-2017). Association for Computational Linguistics.</p>
<p>Jiatao Gu, James Bradbury, Caiming Xiong, O K Victor, Richard Li, Socher, Non-autoregressive neural machine translation. International Conference on Learning Representations. Jiatao Gu, James Bradbury, Caiming Xiong, Victor O. K. Li, and Richard Socher. 2018. Non-autoregressive neural machine transla- tion. International Conference on Learning Representations.</p>
<p>Incorporating copying mechanism in sequence-to-sequence learning. Jiatao Gu, Zhengdong Lu, Hang Li, O K Victor, Li, arXiv:1603.06393arXiv preprintJiatao Gu, Zhengdong Lu, Hang Li, and Victor O. K. Li. 2016. Incorporating copying mechanism in sequence-to-sequence learning. arXiv preprint arXiv:1603.06393.</p>
<p>Liberal event extraction and event schema induction. Lifu Huang, Taylor Cassidy, Xiaocheng Feng, Heng Ji, Clare R Voss, Jiawei Han, Avirup Sil, Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics. the 54th Annual Meeting of the Association for Computational Linguistics1Lifu Huang, Taylor Cassidy, Xiaocheng Feng, Heng Ji, Clare R. Voss, Jiawei Han, and Avirup Sil. 2016. Liberal event extraction and event schema induction. In Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), volume 1, pages 258-268.</p>
<p>Semantics-based machine translation with hyperedge replacement grammars. Bevan Jones, Jacob Andreas, Daniel Bauer, Karl Moritz Hermann, Kevin Knight, Proceedings of COLING 2012. COLING 2012Bevan Jones, Jacob Andreas, Daniel Bauer, Karl Moritz Hermann, and Kevin Knight. 2012. Semantics-based machine translation with hyperedge replacement grammars. Proceedings of COLING 2012, pages 1359-1376.</p>
<p>Adam: A method for stochastic optimization. P Diederik, Jimmy Kingma, Ba, International Conference on Learning Representations. Diederik P. Kingma and Jimmy Ba. 2015. Adam: A method for stochastic optimization. Interna- tional Conference on Learning Representations.</p>
<p>Semisupervised classification with graph convolutional networks. N Thomas, Max Kipf, Welling, International Conference on Learning Representations. Thomas N. Kipf and Max Welling. 2017. Semi- supervised classification with graph convolu- tional networks. International Conference on Learning Representations.</p>
<p>Neural amr: Sequence-to-sequence models for parsing and generation. Ioannis Konstas, Srinivasan Iyer, Mark Yatskar, Yejin Choi, Luke Zettlemoyer, Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics. the 55th Annual Meeting of the Association for Computational Linguistics1Ioannis Konstas, Srinivasan Iyer, Mark Yatskar, Yejin Choi, and Luke Zettlemoyer. 2017. Neural amr: Sequence-to-sequence models for parsing and generation. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), volume 1, pages 146-157.</p>
<p>Sheffield at SemEval-2017 task 9: Transition-based language generation from AMR. Gerasimos Lampouras, Andreas Vlachos, Proceedings of the 11th International Workshop on Semantic Evaluation. the 11th International Workshop on Semantic EvaluationGerasimos Lampouras and Andreas Vlachos. 2017. Sheffield at SemEval-2017 task 9: Transition-based language generation from AMR. In Proceedings of the 11th International Workshop on Semantic Evaluation (SemEval- 2017), pages 586-591.</p>
<p>Yujia Li, Daniel Tarlow, Marc Brockschmidt, Richard Zemel, arXiv:1511.05493Gated graph sequence neural networks. arXiv preprintYujia Li, Daniel Tarlow, Marc Brockschmidt, and Richard Zemel. 2015. Gated graph sequence neural networks. arXiv preprint arXiv:1511.05493.</p>
<p>Toward abstractive summarization using semantic representations. Fei Liu, Jeffrey Flanigan, Sam Thomson, Norman M Sadeh, Noah A Smith, North American Chapter of the Association for Computational Linguistics. Fei Liu, Jeffrey Flanigan, Sam Thomson, Norman M. Sadeh, and Noah A. Smith. 2015. Toward abstractive summarization using se- mantic representations. North American Chapter of the Association for Computational Lin- guistics, pages 1077-1086.</p>
<p>Addressing a question answering challenge by combining statistical methods with inductive rule learning and reasoning. Arindam Mitra, Chitta Baral, Thirtieth AAAI Conference on Artificial Intelligence. Arindam Mitra and Chitta Baral. 2016. Addressing a question answering challenge by combining statistical methods with inductive rule learning and reasoning. In Thirtieth AAAI Conference on Artificial Intelligence.</p>
<p>BLEU: A method for automatic evaluation of machine translation. Kishore Papineni, Salim Roukos, Todd Ward, Wei-Jing Zhu, Proceedings of the 40th Annual Meeting of the Association for Computational Linguistics. the 40th Annual Meeting of the Association for Computational LinguisticsAssociation for Computational LinguisticsKishore Papineni, Salim Roukos, Todd Ward, and Wei-Jing Zhu. 2002. BLEU: A method for automatic evaluation of machine translation. In Proceedings of the 40th Annual Meeting of the Association for Computational Linguistics, pages 311-318. Association for Computational Linguistics.</p>
<p>GloVe: Global vectors for word representation. Jeffrey Pennington, Richard Socher, Christopher Manning, Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP). the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP)Jeffrey Pennington, Richard Socher, and Christopher Manning. 2014. GloVe: Global vectors for word representation. In Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), pages 1532-1543.</p>
<p>CHRF++: Words helping character n-grams. Maja PopoviÄ‡, Proceedings of the Second Conference on Machine Translation. the Second Conference on Machine TranslationMaja PopoviÄ‡. 2017. CHRF++: Words helping character n-grams. In Proceedings of the Second Conference on Machine Translation, pages 612-618.</p>
<p>Generating English from abstract meaning representations. Nima Pourdamghani, Kevin Knight, Ulf Hermjakob, Proceedings of the 9th International Natural Language Generation Conference. the 9th International Natural Language Generation ConferenceNima Pourdamghani, Kevin Knight, and Ulf Hermjakob. 2016. Generating English from abstract meaning representations. In Proceed- ings of the 9th International Natural Language Generation Conference, pages 21-25.</p>
<p>The graph neural network model. Franco Scarselli, Marco Gori, Ah Chung Tsoi, Markus Hagenbuchner, Gabriele Monfardini, IEEE Transactions on Neural Networks. 201Franco Scarselli, Marco Gori, Ah Chung Tsoi, Markus Hagenbuchner, and Gabriele Monfardini. 2009. The graph neural network model. IEEE Transactions on Neural Networks, 20(1):61-80.</p>
<p>Semantic neural machine translation using AMR. Linfeng Song, Daniel Gildea, Yue Zhang, Zhiguo Wang, Jinsong Su, Transactions of the Association for Computational Linguistics. 7Linfeng Song, Daniel Gildea, Yue Zhang, Zhiguo Wang, and Jinsong Su. 2019. Semantic neural machine translation using AMR. Transactions of the Association for Compu- tational Linguistics, 7:19-31.</p>
<p>AMR-to-text generation with synchronous node replacement grammar. Linfeng Song, Xiaochang Peng, Yue Zhang, Zhiguo Wang, Daniel Gildea, Meeting of the Association for Computational Linguistics. 2Linfeng Song, Xiaochang Peng, Yue Zhang, Zhiguo Wang, and Daniel Gildea. 2017. AMR-to-text generation with synchronous node replacement grammar. Meeting of the Association for Computational Linguistics, 2:7-13.</p>
<p>Amrto-text generation as a traveling salesman problem. Linfeng Song, Yue Zhang, Xiaochang Peng, Zhiguo Wang, Daniel Gildea, Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing. the 2016 Conference on Empirical Methods in Natural Language ProcessingLinfeng Song, Yue Zhang, Xiaochang Peng, Zhiguo Wang, and Daniel Gildea. 2016. Amr- to-text generation as a traveling salesman problem. In Proceedings of the 2016 Confer- ence on Empirical Methods in Natural Lan- guage Processing, pages 2084-2089.</p>
<p>A graph-to-sequence model for AMR-to-text generation. Linfeng Song, Yue Zhang, Zhiguo Wang, Daniel Gildea, Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics. the 56th Annual Meeting of the Association for Computational Linguistics1Linfeng Song, Yue Zhang, Zhiguo Wang, and Daniel Gildea. 2018. A graph-to-sequence model for AMR-to-text generation. In Proceed- ings of the 56th Annual Meeting of the Asso- ciation for Computational Linguistics (Volume 1: Long Papers), volume 1, pages 1616-1626.</p>
<p>Neural headline generation on abstract meaning representation. Jun Sho Takase, Naoaki Suzuki, Tsutomu Okazaki, Masaaki Hirao, Nagata, Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing. the 2016 Conference on Empirical Methods in Natural Language ProcessingSho Takase, Jun Suzuki, Naoaki Okazaki, Tsutomu Hirao, and Masaaki Nagata. 2016. Neural headline generation on abstract meaning representation. In Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing, pages 1054-1059.</p>
<p>Attention is all you need. Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Åukasz Kaiser, Illia Polosukhin, Advances in Neural Information Processing Systems. Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Åukasz Kaiser, and Illia Polosukhin. 2017. Attention is all you need. In Advances in Neural Information Processing Systems, pages 5998-6008.</p>
<p>Petar Velickovic, Guillem Cucurull, Arantxa Casanova, Adriana Romero, Pietro Lio, Yoshua Bengio, Graph attention networks. International Conference on Learning Representations. Petar Velickovic, Guillem Cucurull, Arantxa Casanova, Adriana Romero, Pietro Lio, and Yoshua Bengio. 2018. Graph attention net- works. International Conference on Learn- ing Representations.</p>
<p>Improving the transformer translation model with document-level context. Jiacheng Zhang, Huanbo Luan, Maosong Sun, Feifei Zhai, Jingfang Xu, Min Zhang, Yang Liu, Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing. the 2018 Conference on Empirical Methods in Natural Language ProcessingJiacheng Zhang, Huanbo Luan, Maosong Sun, Feifei Zhai, Jingfang Xu, Min Zhang, and Yang Liu. 2018. Improving the transformer translation model with document-level context. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 533-542.</p>            </div>
        </div>

    </div>
</body>
</html>