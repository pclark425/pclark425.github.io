<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-7969 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-7969</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-7969</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-145.html">extraction-schema-145</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods, metrics, frameworks, datasets, or criteria used to evaluate scientific theories or hypotheses generated by large language models.</div>
                <p><strong>Paper ID:</strong> paper-e9155ac8786f12c26cd7653804cec17fd1475359</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/e9155ac8786f12c26cd7653804cec17fd1475359" target="_blank">PyCharge: An open-source Python package for self-consistent electrodynamics simulations of Lorentz oscillators and moving point charges</a></p>
                <p><strong>Paper Venue:</strong> Computer Physics Communications</p>
                <p><strong>Paper TL;DR:</strong> PyCharge includes a parallelized version of the dipole simulation method to enable the parallel execution of computationally demanding simulations on high performance computing environments to significantly improve run time.</p>
                <p><strong>Cost:</strong> 0.006</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <p class="empty-note">No extracted data.</p>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <p class="empty-note">No potentially relevant new papers extracted.</p>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-7969",
    "paper_id": "paper-e9155ac8786f12c26cd7653804cec17fd1475359",
    "extraction_schema_id": "extraction-schema-145",
    "extracted_data": [],
    "potentially_relevant_new_papers": [],
    "cost": 0.00592025,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>PyCharge: An open-source Python package for self-consistent electrodynamics simulations of Lorentz oscillators and moving point charges</h1>
<p>Matthew J. Filipovich*, Stephen Hughes<br>Department of Physics, Engineering Physics and Astronomy, Queen's University, Kingston, ON K7L 3N6, Canada</p>
<h4>Abstract</h4>
<p>PyCharge is a computational electrodynamics Python simulator that can calculate the electromagnetic fields and potentials generated by moving point charges and can self-consistently simulate dipoles modeled as Lorentz oscillators. To calculate the total fields and potentials along a discretized spatial grid at a specified time, PyCharge computes the retarded time of the point charges at each grid point, which are subsequently used to compute the analytical solutions to Maxwell's equations for each point charge. The Lorentz oscillators are driven by the electric field in the system and PyCharge self-consistently determines the reaction of the radiation on the dipole moment at each time step. PyCharge treats the two opposite charges in the dipole as separate point charge sources and calculates their individual contributions to the total electromagnetic fields and potentials. The expected coupling that arises between dipoles is captured in the PyCharge simulation, and the modified radiative properties of the dipoles (radiative decay rate and frequency shift) can be extracted using the dipole's energy at each time step throughout the simulation. The modified radiative properties of two dipoles separated in the near-field, which require a full dipole response to yield the correct physics, are calculated by PyCharge and shown to be in excellent agreement with the analytical Green's function results ( $&lt;0.2 \%$ relative error, over a wide range of spatial separations). Moving dipoles can also be modeled by specifying the dipole's origin position as a function of time. PyCharge includes a parallelized version of the dipole simulation method to enable the parallel execution of computationally demanding simulations on high performance computing environments to significantly improve run time.</p>
<p>Keywords:
Computational Electrodynamics, Nano-Optics, Electromagnetic Field Solver, Open Source, Python.</p>
<h2>PROGRAM SUMMARY</h2>
<p>Program Title: PyCharge
CPC Library link to program files: (to be added by Technical Editor)
Developer's repository link:
github.com/MatthewFilipovich/pycharge
Code Ocean capsule: (to be added by Technical Editor)
Licensing provisions: GPLv3
Programming language: Python 3.7 or newer
Supplementary material:
Documentation is available at pycharge.readthedocs.io. The PyCharge package and its dependencies can be installed from PyPI: pypi.org/project/pycharge
Nature of problem:
Calculating the electromagnetic fields and potentials generated by complex geometries of point charges, as well as the self-consistent simulation of Lorentz oscillators.
Solution method:
PyCharge calculates the individual contributions from each point charge in the system to calculate the total electromagnetic fields and potentials, and computes the dipole moment of the Lorentz oscillators at each time step by solving their governing equation of motion.
Additional comments including restrictions and unusual features:
The parallel simulation method is implemented using the mpi4py package [1].</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<h2>References</h2>
<p>[1] L. D. Dalcin, R. R. Paz, P. A. Kler, A. Cosimo, Parallel distributed computing using python, Advances in Water Resources 34 (9) (2011) 1124-1139.</p>
<h2>1. Introduction</h2>
<p>The majority of electrodynamics problems can be divided into two distinct classes: ${ }^{1}$ (i) one in which the goal is to solve for the electromagnetic (EM) fields generated by specified sources of charge and current (e.g., antennas, radiation from multipole sources), and (ii) one in which the motion of the charges and currents are to be determined based on the known fields in the system (e.g., motion of charges in electric and magnetic fields, energy-loss phenomena) [1]. However, there exists another class of electrodynamics problems where the solution requires that the fields and sources are treated self-consistently. That is, a correct treatment of the problem must include the reaction of the radiation on the motion of the sources. The selfconsistent treatment of sources and fields is an old and difficult</p>
<p><sup id="fnref:1"><a class="footnote-ref" href="#fn:1">2</a></sup></p>
<p>problem that stems from one of the most fundamental aspects of physics: the nature of an elementary particle. This problem of self-consistency is not only limited to classical electrodynamics, as these difficulties also arise in quantum-mechanical discussions and modelings of these systems [2].</p>
<p>Motivated by the need for an electrodynamics simulator that self-consistently treats the reaction of the radiation on the realtime motion of the point charge sources, we developed the open-source Python package PyCharge. PyCharge can calculate the EM fields and potentials generated by sources in a system at specified grid points in space and time, which can then be visualized using a plotting library such as Matplotlib [3]. To calculate these fields and potentials, PyCharge exploits the principle of superposition in classical electrodynamics by determining the individual contributions from each source and then calculating the sum. The equations describing the scalar and vector potentials generated by a single moving point charge in a vacuum are given by the Liénard-Wiechert potentials, and the complete and relativistically correct equations for the timevarying electric and magnetic fields can be derived from these potentials [4].</p>
<p>PyCharge currently supports two types of sources: point charges that have predefined trajectories (specified as parametric equations of motion in the $x, y$, and $z$ directions as functions of time), and Lorentz oscillators (i.e., oscillating electric dipoles). The Lorentz oscillators (LOs) consist of two equal and opposite point charges that oscillate around the origin position (center of mass) along the axis of polarization, with a dipole moment that is dynamically calculated at each time step by solving the governing harmonic oscillator differential equation. The LOs are driven by the electric field component along the direction of polarization generated by the other sources in the system (which includes its own scattered field). As well, the LOs are naturally damped since they radiate energy as they oscillate, which dissipates kinetic energy (classically caused by radiation reaction) and decreases the dipole moment [5]. This damping allows PyCharge to calculate the self-consistent radiative decay rates from LOs in arbitrary motion and also in the presence of interactions with other LOs, including collective effects such as superradiance and subradiance.</p>
<p>The scattering of EM waves by LOs can be solved using a closed scalar and dyadic Green's function approach, where the LOs are treated as point-like objects such that their structure cannot be resolved on the scale of the wavelength of light [6]. However, this method requires a full dipole response and cannot account for certain LO configurations (e.g., moving LOs). PyCharge simulations provide an alternative numerical method to this standard approach that yield highly accurate results and can model systems that cannot be solved analytically. Our approach also has notable advantages over other self-consistent EM solvers such as the finite-difference time-domain (FDTD) method [7], which require a very careful treatment of the LO's divergent nature when treated as a point dipole, which leads to (unphysical) frequency shifts that are dependent on the gridsize.</p>
<p>PyCharge was designed to be accessible for a wide range of use cases: first, it can be used as a pedagogical tool for under-
graduate and graduate-level EM theory courses to provide an intuitive understanding of the EM waves generated by moving point charges, and second, it can also be used by researchers in the field of nano-optics to investigate the complex interactions of light in nanoscale environments, including interactions with moving point charges and chains of resonant LOs.</p>
<p>We have also implemented a parallelized version of the PyCharge simulation method, using the standard Message Passing Interface (MPI) for Python package (mpi4py) [8], which can be executed on high performance computing environments to significantly improve the run time of computationally demanding simulations (e.g., involving multiple dipoles). The PyCharge package can be installed directly from PyPI on systems running Python 3.7 or newer. Further documentation, including Python script examples and the API reference, is available at pycharge.readthedocs.io.</p>
<p>The rest of our paper is organized as follows: in Sec. 2, we discuss the relevant theoretical background and the applied numerical methods for calculating the EM fields and potentials generated by moving point charges; as well, we introduce the LO model for simulating dipoles and review the known effects of coupling between LOs using a photonic Green's function theory. In Sec. 3, we present the general framework of the PyCharge package including the relevant classes and methods, as well as the MPI implementation. In Sec. 4, we demonstrate several electrodynamics simulations that can be performed with PyCharge and provide minimal Python listings that demonstrate PyCharge's user interface. We also verify the accuracy of simulating two coupled dipoles by comparing the calculated radiative properties and dipole energies with the known analytical solutions. Finally, we present our conclusions in Sec. 5.</p>
<p>In addition, we provide three appendices: Appendix A presents the Green's function for a free-space medium and the master equation for coupled point dipoles in a Born-Markov approximation. From these, we obtain the key quantum electrodynamics (QED) expressions for the radiative decay rates and coupling parameters of point dipoles. We then provide an explicit solution to the master equation for initially excited dipoles treated as two level systems (TLSs), as these solutions demonstrate equivalence in the limit of weak excitation (linear response) with the decay dynamics of coupled LOs simulated with PyCharge. Appendix B presents the derivation of the freespace spontaneous emission (SE) rate from the standard Fermi's golden rule approach. Appendix C presents the exact EM fields generated by an oscillating electric dipole as functions of space and time, which we use to benchmark the accuracy of our code.</p>
<h2>2. Background and methods</h2>
<h3>2.1. Moving point charges</h3>
<p>The charge and current densities of a point charge $q$ at the position $\mathbf{r}_{p}(t)$ with velocity $c \boldsymbol{\beta}(t)$ are, respectively,</p>
<p>$$
\rho(\mathbf{r}, t)=q \delta\left[\mathbf{r}-\mathbf{r}_{p}\right]
$$</p>
<p>and</p>
<p>$$
\mathbf{J}(\mathbf{r}, t)=q c \boldsymbol{\beta} \delta\left[\mathbf{r}-\mathbf{r}_{p}\right]
$$</p>
<p>where $c$ is the vacuum speed of light.
The scalar and vector potentials of a moving point charge in the Lorenz gauge, known as the Liénard-Wiechert potentials [9], are derived from Maxwell's equations as</p>
<p>$$
\Phi(\mathbf{r}, t)=\frac{q}{4 \pi \epsilon_{0}}\left[\frac{1}{\kappa R}\right]_{\mathrm{ret}}
$$</p>
<p>and</p>
<p>$$
\mathbf{A}(\mathbf{r}, t)=\frac{\mu_{0} q}{4 \pi}\left[\frac{\not \beta}{\kappa R}\right]_{\mathrm{ret}}
$$</p>
<p>where $\epsilon_{0}$ and $\mu_{0}$ are the vacuum permittivity and permeability, respectively, $R=\left|\mathbf{r}-\mathbf{r}<em p="p">{p}\left(t^{\prime}\right)\right|$, and $\kappa=1-\mathbf{n}\left(t^{\prime}\right) \cdot \not \partial\left(t^{\prime}\right)$ such that $\mathbf{n}=\left(\mathbf{r}-\mathbf{r}</em>$, given by}\left(t^{\prime}\right)\right) / R$ is a unit vector from the position of the charge to the field point, and the quantity in brackets is to be evaluated at the retarded time $t^{\prime</p>
<p>$$
t^{\prime}=t-\frac{R\left(t^{\prime}\right)}{c}
$$</p>
<p>The physical (gauge-invariant) relativistically-correct, timevarying electric and magnetic fields generated by a moving point charge are, respectively,</p>
<p>$$
\mathbf{E}(\mathbf{r}, t)=\frac{q}{4 \pi \epsilon_{0}}\left[\frac{(\mathbf{n}-\boldsymbol{\beta})\left(1-\beta^{2}\right)}{\kappa^{3} R^{2}}+\frac{\mathbf{n}}{c \kappa^{3} R} \times[(\mathbf{n}-\boldsymbol{\beta}) \times \hat{\boldsymbol{\beta}}]\right]_{\mathrm{ret}}
$$</p>
<p>and</p>
<p>$$
\mathbf{B}(\mathbf{r}, t)=\frac{1}{c}[\mathbf{n} \times \mathbf{E}]_{\mathrm{ret}}
$$</p>
<p>where $\hat{\boldsymbol{\beta}}$ is the derivative of $\boldsymbol{\beta}$ with respect to $t^{\prime}$ [1].
The first term in Eq. (6) is known as the electric Coulomb field and is independent of acceleration, while the second term is known as the electric radiation field and is linearly dependent on $\hat{\boldsymbol{\beta}}$ :</p>
<p>$$
\mathbf{E}<em 0="0">{\mathrm{Coul}}(\mathbf{r}, t)=\frac{q}{4 \pi \epsilon</em>
$$}}\left[\frac{(\mathbf{n}-\boldsymbol{\beta})\left(1-\beta^{2}\right)}{\kappa^{3} R^{2}}\right]_{\mathrm{ret}</p>
<p>and</p>
<p>$$
\mathbf{E}<em 0="0">{\mathrm{rad}}(\mathbf{r}, t)=\frac{q}{4 \pi \epsilon</em>
$$} c}\left[\frac{\mathbf{n}}{\kappa^{3} R} \times[(\mathbf{n}-\boldsymbol{\beta}) \times \hat{\boldsymbol{\beta}}]\right]_{\mathrm{ret}</p>
<p>The magnetic Coulomb and radiation field terms can be determined by substituting Eqs. (8) and (9) into Eq. (7). Notably, the Coulomb field falls off as $1 / R^{2}$, similar to the static field, while the radiation field decreases as $1 / R[4] .^{2}$</p>
<h3>2.2. Computing the fields and potentials</h3>
<p>PyCharge can directly calculate the EM fields and potentials generated by a moving point charge along a discretized spatial grid at a specified time. At each point on the spatial grid, the retarded time of the moving point charge, which is determined by the point charge's trajectory, is calculated using the secant method (from the SciPy package [10]) to find the approximate</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup>solution of Eq. (5). Then, the retarded position, velocity, and acceleration of the point charge at each grid point are determined. Finally, the scalar and vector potentials are calculated from Eqs. (3) and (4), and the total, Coulomb, and radiation fields are computed using Eqs. (6), (8), and (9) for the respective electric fields; the corresponding magnetic fields are calculated from Eq. (7).</p>
<p>In systems with multiple point charges, PyCharge exploits the superposition principle for electrodynamics simulations: the fields and potentials generated by each source are calculated using the previously described approach, and the total fields and potentials are given by the sum of the individual point charge contributions. A continuous charge density $\rho$ can be approximated in PyCharge using many point charges within the volume, where the charge value of each point charge depends on $\rho$. Similarly, a continuous current density, described by $\mathbf{J}=\rho \mathbf{v}$, can be approximated using evenly spaced point charges traveling along a path, where the charge value of each point charge depends on $\mathbf{J}$. The accuracy of the calculated fields and potentials generated by these approximated continuous densities is dependent on both the number of point charges used in the simulation and the distance at the field point from the sources [11].</p>
<p>As previously discussed, PyCharge can simulate point charges that have specified trajectories defined by a parametric equation $\mathbf{r}(t)=(x(t), y(t), z(t))$, as well as dipoles (which consist of two point charges) that are modeled as LOs with a dipole moment that is dynamically determined at each time step. In previous work [11], we simulated several interesting systems of point charges with predefined trajectories using a similar computational approach, including magnetic dipoles, oscillating and linearly accelerating point charges, synchrotron radiation, and Bremsstrahlung. The simulation of LOs in PyCharge is discussed in the next section.</p>
<h3>2.3. Lorentz oscillator model</h3>
<p>The optical interactions between light and matter at the nanometer scale are important phenomena for a variety of research fields, and a rigorous understanding of these interactions requires the use of QED theory. However, nanometerscale structures are often too complex to be solved rigorously using only QED; in these cases, a classical approach that invokes the results of QED in a phenomenological way can be applied [5]. PyCharge uses the LO model, which is an approximation from quantum theory that can be derived (e.g., from the time-dependent Schrödinger equation or a quantum master equation, see Appendix A) to simulate the interaction of a bound charge (e.g., an electron) with light [12].</p>
<p>In the classical model, an oscillating dipole produces EM radiation which dissipates energy and modifies the self-consistent dipole moment. The recoil force, $\mathbf{F}_{r}$, acting on the accelerating point charges in the dipole is called the radiation reaction or radiation damping force. The equation of motion for an undriven LO (e.g., in a vacuum) that includes the radiation reaction force is given by</p>
<p>$$
m \ddot{\mathbf{r}}<em 0="0">{\mathrm{dip}}(t)+\omega</em>}^{2} m \mathbf{r<em r="r">{\mathrm{dip}}(t)=\mathbf{F}</em>(t)
$$</p>
<p>where $\mathbf{r}<em _dip="{dip" _text="\text">{\text {dip }}$ is the displacement from the LO's negative charge to positive charge and $\ddot{\mathbf{r}}</em>$ is its second derivative with respect}</p>
<p>to time, $m$ is the effective mass of the LO (further discussed below), and $\omega_{0}$ is the natural angular frequency of the LO [5].</p>
<p>The radiation reaction force, $\mathbf{F}_{\mathrm{r}}$, acting on the accelerating point charges in the dipole is described by the Abraham-Lorentz formula for non-relativistic velocities:</p>
<p>$$
\mathbf{F}<em 0="0">{\mathrm{r}}(t)=\frac{q^{2}}{6 \pi \epsilon</em>(t)
$$} c^{3}} \ddot{\mathbf{r}}_{\mathrm{dip}</p>
<p>where $\dddot{\mathbf{r}}<em _dip="{dip" _text="\text">{\text {dip }}$ is the third derivative of the displacement between the two charges [4]. We can perform the approximation $\dddot{\mathbf{r}}</em>}} \approx-\omega_{0}^{2} \mathbf{r<em _mathrm_r="\mathrm{r">{\text {dip }}$ in Eq. (11) if the damping on the point charges introduced by the radiation reaction force is negligible (i.e., $\left|\mathbf{F}</em>\right|$ ), such that the following condition is satisfied:}}\right| \ll \omega_{0}^{2} m\left|\mathbf{r}_{\text {dip }</p>
<p>$$
\frac{q^{2} \omega_{0}}{m} \ll 6 \pi \epsilon_{0} c^{3}
$$</p>
<p>In an inhomogeneous environment, an oscillating electric dipole will experience the external electric field $\mathbf{E}_{\mathrm{d}}$ as a driving force, which is the component of the total electric field in the polarization direction at the dipole's origin (center of mass) position $\mathbf{R}$ generated by the other sources in the system and its own scattered field. If the condition in Eq. (12) is satisfied, the equation of motion for a driven LO is</p>
<p>$$
\ddot{\mathbf{d}}(t)+\gamma_{0} \dot{\mathbf{d}}(t)+\omega_{0}^{2} \mathbf{d}(t)=\frac{q^{2}}{m} \mathbf{E}_{\mathrm{d}}(\mathbf{R}, t)
$$</p>
<p>where $\mathbf{d}=q \mathbf{r}<em 0="0">{\text {dip }}$ is the dipole moment, $\dot{\mathbf{d}}$ and $\ddot{\mathbf{d}}$ are the first and second derivatives of $\mathbf{d}$, and $\gamma</em>$ is the free-space energy decay rate given by</p>
<p>$$
\gamma_{0}=\frac{q^{2} \omega_{0}^{2}}{6 \pi \epsilon_{0} c^{3} m}
$$</p>
<p>This equation of motion for an LO corresponds to a Lorentzian atom model with transition frequency $\omega_{0}$ and linewidth $\gamma_{0}$ (where $\gamma_{0} \ll \omega_{0}$ ), and is limited to non-relativistic velocities as it does not account for relativistic mass [5].</p>
<p>The effective mass $m$ (also called the reduced mass) of the dipole is given by</p>
<p>$$
m=\frac{m_{1} m_{2}}{m_{1}+m_{2}}
$$</p>
<p>where $m_{1}$ and $m_{2}$ are the masses of the two point charges in the dipole [12]. These charges oscillate around the center of mass position $\mathbf{R}$, defined by</p>
<p>$$
\mathbf{R}=\frac{m_{1} \mathbf{r}<em 2="2">{1}+m</em>} \mathbf{r<em 1="1">{2}}{m</em>
$$}+m_{2}</p>
<p>where $\mathbf{r}<em 2="2">{1}$ and $\mathbf{r}</em>$ :}$ are the positions of the two point charges. The point charge positions can therefore be defined in terms of the displacement between the two charges $\mathbf{r}_{\text {dip }</p>
<p>$$
\mathbf{r}<em 2="2">{1}=\mathbf{R}+\frac{m</em>
$$}}{m_{1}+m_{2}} \mathbf{r}_{\text {dip }</p>
<p>and</p>
<p>$$
\mathbf{r}<em 1="1">{2}=\mathbf{R}-\frac{m</em>
$$}}{m_{1}+m_{2}} \mathbf{r}_{\text {dip }</p>
<p>It is also useful to discuss how the decay dynamics of LOs are related to those of a quantum TLS, in certain limits. Specifically, in the limit of weak excitation (linear response), we can
connect the quantum mechanical equations of motion for a TLS to the classical equations of motion by replacing $q^{2} / m$ with $q^{2} f / m$, where $f$ is the oscillator strength, defined by</p>
<p>$$
f=\frac{2 m \omega_{0} d_{0}^{3}}{\hbar q^{2}}
$$</p>
<p>where $d_{0}=|\mathbf{d}(t=0)|$. We thus recover the usual expression for the SE rate $\gamma_{0, \text { TLS }}$ from an excited TLS,</p>
<p>$$
\gamma_{0, \mathrm{TLS}}=\frac{\omega_{0}^{3} d_{0}^{2}}{3 \pi \epsilon_{0} \hbar c^{3}}
$$</p>
<p>An alternative argument to relate the dipole moment with the radiative decay rate is to connect the total mean energy of the LO to the ground state energy of a quantized harmonic oscillator, so that</p>
<p>$$
\frac{m \omega_{0}^{2} d_{0}^{3}}{q^{2}}=\frac{\hbar \omega_{0}}{2}
$$</p>
<p>yielding $q^{2} / m=2 \omega_{0} d_{0}^{2} / \hbar$, as expected from Eq. (19). As well, the decay rate can be derived using a Fermi's golden rule approach (see Appendix B) from the interaction Hamiltonian $H_{\text {int }}=-\mathbf{d} \cdot \hat{\mathbf{E}}$, which leads to the following rate equations for the populations of an isolated TLS in a vacuum: ${ }^{3}$</p>
<p>$$
\dot{n}<em 0="0">{\mathrm{e}}(t)=-\gamma</em>(t)
$$} n_{\mathrm{e}</p>
<p>and</p>
<p>$$
\dot{n}<em 0="0">{\mathrm{g}}(t)=\gamma</em>(t)
$$} n_{\mathrm{e}</p>
<p>where $n_{g}$ and $n_{e}$ are the populations of the ground and excited states $\left(n_{g}+n_{e}=1\right)$, respectively, and we neglect all other processes. In this picture, $\gamma_{0}$ is also identical to the well known Einstein A coefficient [12]. Therefore, the energy decay rate is equivalent to the population decay rate. We stress again that we can only make the connection between LO dynamics and populations of TLS states in a regime of weak excitation.</p>
<p>The total energy $\mathcal{E}$ of a dipole, which is the sum of its kinetic and potential energies, is calculated by PyCharge using</p>
<p>$$
\mathcal{E}(t)=\frac{m \omega_{0}^{2}}{2 q^{2}} d^{2}(t)+\frac{m}{2 q^{2}} d^{2}(t)
$$</p>
<p>where $d=|\dot{\mathbf{d}}|$. Since the total energy of a dipole $\mathcal{E}$ is proportional to $n_{e}$, the population of the excited state using the normalized total energy can be determined by PyCharge from</p>
<p>$$
n_{e}(t)=\frac{\mathcal{E}(t)}{\max (\mathcal{E})}
$$</p>
<h3>2.4. Coupled Lorentz oscillators</h3>
<p>It is well known that an atom's surrounding environment modifies its radiative properties. In the classical model, the modification of the SE rate is generated by the scattering of</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>the atomic field (as the LO is driven by the electric field at its origin position), while in QED theory the SE rate is stimulated by vacuum field fluctuations or radiation reaction, which partly depends on the ordering of the quantum field operators [2]. Regardless, in the weak coupling regime (where the atom-field coupling constant is much less than the photon decay rate inside the cavity), the interactions can be treated perturbatively such that QED and classical theory yield the same results for the modification of the SE rate [5]. An exception is when the surrounding medium contains gain [13]. The modification of radiative properties for two coupled LOs in close vicinity is given in A by invoking QED theory and using the dyadic Green's function for a dipole.</p>
<p>The classical analogs of the superradiant and subradiant states of two coupled TLSs (where the dipoles are quantized) occur when they are polarized along the same axis and begin either in phase (direction of the two dipole moments are equal) or out of phase (direction of the two dipole moments are reversed), respectively. PyCharge can calculate the frequency shift $\delta_{12}$ and SE rate $\gamma^{*}$ of two coupled LOs in either collective state by curve fitting the discretized kinetic energy (KE) values, which are calculated by PyCharge at each time step, to the expected harmonic equation (which also connects to the master equation solutions shown in A)</p>
<p>$$
\mathrm{KE}=A e^{-(\gamma^{*} t)} \sin \left(\left(\omega_{0} \pm \delta_{12}\right) t+\phi\right)^{2}
$$</p>
<p>where $A$ and $\phi$ are constants necessary to accurately fit the function and are dependent on the initial conditions of the simulation. The curve fit should be performed using the kinetic energy values after a number of time steps have elapsed in the simulation to allow the scattered fields to propagate back to the LO's origin position. When the two coupled LOs are in the superradiant or subradiant states, the population of their excited state and their total energy $\mathcal{E}$ (related by Eq. (25)) are exponentially decaying functions with a decay rate of $\gamma^{*}$ or $\gamma^{-}$, respectively.</p>
<p>It is also useful to note that the total EM power radiated by an accelerating point charge in a vacuum (at non-relativistic speeds) can be calculated using the Larmor formula [14]:</p>
<p>$$
P(t)=\frac{q^{2} a^{2}(t)}{6 \pi \epsilon_{0} c^{3}}
$$</p>
<p>The power radiated by a dipole can also be calculated using the above equation by replacing $q^{2} a^{2}$ with $|\vec{d}|^{2}$. Assuming that the dipoles begin oscillating at $t=0 \mathrm{~s}$, the radiated energy at time $t^{\prime}$ can be calculated by integrating the radiated power from $t=0 \mathrm{~s}$ to $t=t^{\prime}$ (which can be approximated with PyCharge using a discrete integration). As well, if there are two or more dipoles in a system that interact, then each dipole will 'absorb' a certain amount of energy $W_{\text {abs }}$ radiated from the other dipoles. The total (constant) energy of a system that contains $N$ dipoles is the sum of the energy gains and losses of all the dipoles, given by</p>
<p>$$
W_{\text {total }}=\sum_{i=1}^{N}\left(\mathcal{E}<em _abs="{abs" _text="\text">{i}\left(t^{\prime}\right)-W</em>(t) d t\right)
$$}, i}\left(t^{\prime}\right)+\int_{0}^{t^{\prime}} P_{i</p>
<p>where $\mathcal{E}_{i}$ is the total energy (sum of the kinetic and potential energies) of the $i$ th dipole in the system, defined by Eq. (24).
<img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: The Simulation object is instantiated with a list of the sources in the system (i.e., Dipole and subclasses of Charge). The Simulation object can calculate the EM fields and potentials at points along a spatial grid at a specified time $t$. The Simulation object can also run (parallel) simulations to calculate the trajectory of the Dipole objects over a range of time steps.</p>
<h2>3. PyCharge package overview</h2>
<p>PyCharge uses an object-oriented framework for representing the sources in the system and for executing simulations. All of the sources present in the system must be instantiated as objects, which include point charges with predefined trajectories and LOs (i.e., oscillating dipoles) which have dipole moments that are determined dynamically at each time step. An overview of the classes and methods implemented in the PyCharge package is shown in Fig. 1.</p>
<h3>3.1. Electromagnetic sources</h3>
<p>Point charge objects with predefined trajectories are instantiated from subclasses of the Charge abstract parent class, which contains the charge $q$ as an attribute and abstract methods for the position in the $x, y$, and $z$ directions as functions of time. The Charge class also has methods for the velocity and acceleration as functions of time which return the respective derivatives using finite difference approximations; however, the user can specify the exact velocity and acceleration equations in the subclasses if desired. The Charge class also contains the method solve_time which returns Eq. (5) in a modified form and is used by PyCharge to calculate the retarded time at</p>
<p>specified spatial points using the secant method, as discussed in Sec. 2.2. Several point charge classes are included with PyCharge (e.g., StationaryCharge, OscillatingCharge), where features of these charge trajectories (e.g., angular frequency, radius) can be modified when instantiated. Users can also create their own custom subclasses of Charge to specify unique point charge trajectories.</p>
<p>The LO sources are instantiated from the Dipole class, which represents a pair of oscillating point charges with a dipole moment that is dynamically determined at each time step from Eq. (13); the positions of the point charges are then calculated using the dipole moment (Eqs. (17) and (18)). In PyCharge, the positive and negative charge pair are represented as <em 0="0">DipoleCharge objects (which is a subclass of the Charge class); however, they are not directly accessed by the user. The Dipole objects are instantiated with the natural angular frequency $\omega</em>}$, the origin position, the initial displacement $\mathbf{r<em 1="1">{\text {dip }}(t=0)$ between the two point charges in the dipole, the charge magnitude $q$ (default is $e=1.602 \times 10^{-19} \mathrm{C}$ ) of the charges, and the mass of each charge ( $m</em> / 2$ (see Eq. (15)).}$ and $m_{2}$ ); the default mass for both charges is $m_{e}$ (with $m_{e}=9.109 \times 10^{-31} \mathrm{~kg}$ ) such that the dipole has an effective mass of $m_{e</p>
<p>The origin position (center of mass) of the dipole can either be stationary or specified as a function of time. The Dipole object also contains the dipole moment and its derivatives as attributes (stored as NumPy arrays), which are calculated and saved at each time step during the simulation. The dipole moment and origin position determine the motion of its two _DipoleCharge objects, which are also updated at each time step. Unlike the point charge objects that have predefined trajectories (implemented as continuous functions), the position and related derivatives of the _DipoleCharge objects are stored as discrete values at each time step; linear interpolation is used to calculate the values between the discrete time steps.</p>
<h3>3.2. Simulations</h3>
<p>The core features of the PyCharge package, including calculating the EM fields and potentials and running simulations with Dipole objects, are executed using the Simulation class. The Simulation object is instantiated with the source objects that are present in the system. The Simulation object can calculate the electric and magnetic fields, as well as the scalar and vector potentials generated by the sources at specified spatial points at time $t$ using the methods calculate_E, calculate_B, calculate_V, and calculate_A. Addition-</p>
<div class="codehilite"><pre><span></span><code>Algorithm 1 Simulation.run
    Initialize sources in simulation
    for \(t\) in range \(\left(0, t_{\max }, d t\right)\) : do
        for dipole in sources: do
            Calculate \(\mathbf{E}_{\mathrm{d}}\)}\) and solve Eq. (13) using RK4 at \(t+d t\)
            Update trajectory arrays of dipole at \(t+d t\)
        end for
    end for
    Save Simulation and Dipole objects with trajectories
</code></pre></div>

<p>ally, the specific EM field type (Coulomb, radiation, or total field) to be calculated by the calculate_E and calculate_B methods can be specified. These calculations are performed using the numerical approach described in Sec. 2.2, and have a time complexity of $\mathcal{O}(N)$ with respect to both the number of sources in the simulation and the number of spatial points in the grid. However, the trajectories of all the sources must be defined at time $t$; therefore, the dipole moments of any Dipole objects in the system must be known at $t$.</p>
<p>Dipole objects can be simulated in a system over a specified period of time using the run method from the Simulation object. The run method calculates the dipole moment and corresponding derivatives at each time step by solving the equation of motion given in Eq. (13) using the Runge-Kutta (RK4) method. The dipoles only begin oscillating after the first time step, and have stationary dipole moments for $t \leq 0 \mathrm{~s}$. To calculate the driving field $\mathbf{E}<em _mathrm_d="\mathrm{d">{\mathrm{d}}$ of each Dipole object at a given time, the electric field generated by all of the other sources in the system is calculated at the dipole's origin position using the calculate_E method. Since the electric field generated by the Dipole object must be excluded in the total field calculation to determine its own driving field $\mathbf{E}</em>$, the Dipole object is passed as a parameter to the calculate_E method, which ensures that it does not contribute to the total field. Once the simulation is complete and the dipole trajectories are calculated at each time step, the Simulation object and its instantiated source objects can optionally be saved using Python object serialization into an external file. The objects in the file can then be loaded by the Simulation object for future analysis. An overview of the run method is given in Algorithm 1.}</p>
<p>When the run method is called, the number of time steps and size of the time steps ( $d t$ ) must be specified. The size of $d t$ must be appropriate for the simulation being performed: the minimum requirement is that $d t$ must be small enough such that the generated radiation does not reach the other dipoles in a single time step, and in general a smaller $d t$ value reduces the amount of error in the simulation. Other optional arguments include the name of the external file where the Simulation object is saved after the simulation is complete (alternatively where the Simulation object is loaded from if the simulation has already been performed), a boolean indicating whether the driving field $\mathbf{E}_{\mathrm{d}}$ at each time step is saved (which increases memory usage), and the maximum possible velocity achieved by the dipole's charges as the LO model does not account for relativistic effects (PyCharge raises an error if the velocity becomes larger; default is $c / 100$ ). The run time over 100 time steps as a function of the number of simulated Dipole objects is shown in Fig. 2.</p>
<h3>3.3. MPI implementation</h3>
<p>Simulating the LOs using the previously described approach is embarrassingly parallelizable, as the task of solving the equation of motion (Eq. (13)) for the dipoles at each time step can be distributed across multiple processes. Ideally, each process will be tasked to calculate the trajectory of a single Dipole object at each time step. However, if there are more Dipole objects in the simulation than available processes, the set of Dipole objects can be evenly distributed among the processes;</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: The average run time of the run method over 100 time steps with respect to the number of Dipole objects in the simulation. Simulations were performed using an Intel Xeon Processor E7-4800 v3 CPU.</p>
<p>In this case, the trajectories of the Dipole objects are calculated sequentially. Once the processes have finished calculating the trajectories of their assigned Dipole object(s), the trajectories are broadcasted to all of the other processes. The trajectories of the other dipoles, received from the other processes, are then updated for the given time step. A description of this MPI implementation is provided in Algorithm 2.</p>
<p>The original implementation of the simulation using the run method is executed in O(N<sup>2</sup>) time for N Dipole objects, since the driving electric field E<sub>d</sub> of each dipole requires the calculation of the field contributions from the other N − 1 dipoles. By taking advantage of the parallel computations, the ideal time complexity of our MPI implementation (using N processes for N Dipole object) is O(N). However, since each process must store the trajectory arrays of the N dipoles, the MPI implementation has a space complexity of O(N<sup>2</sup>), while the space complexity of the original implementation is O(N). The average speedup offered by the MPI method using up to 128 processes is shown in Fig. 3.</p>
<p>Future improvements to the MPI implementation could po-</p>
<table>
<thead>
<tr>
<th>Algorithm 2 Simulation.run.mpi</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1: Initialize sources in simulation</td>
<td></td>
</tr>
<tr>
<td>2: process_dipoles = []</td>
<td></td>
</tr>
<tr>
<td>3: for i in range(MPI.rank, len(dipoles), MPI.size) do</td>
<td></td>
</tr>
<tr>
<td>4: process_dipoles.append(dipoles[i])</td>
<td></td>
</tr>
<tr>
<td>5: end for</td>
<td></td>
</tr>
<tr>
<td>6: for t in range(0, t<sub>max</sub>, dt): do</td>
<td></td>
</tr>
<tr>
<td>7: for dipole in process_dipoles: do</td>
<td></td>
</tr>
<tr>
<td>8: Calculate E<sub>d</sub> and solve Eq. (13) using RK4 at t + dt</td>
<td></td>
</tr>
<tr>
<td>9: Update trajectory arrays of dipole at t + dt</td>
<td></td>
</tr>
<tr>
<td>10: end for</td>
<td></td>
</tr>
<tr>
<td>11: Broadcast process_dipoles trajectories at t + dt</td>
<td></td>
</tr>
<tr>
<td>12: Receive and update trajectories from other dipoles</td>
<td></td>
</tr>
<tr>
<td>13: end for</td>
<td></td>
</tr>
<tr>
<td>14: Save Simulation and Dipole objects with trajectories</td>
<td></td>
</tr>
</tbody>
</table>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: The average speedup of the run.mpi method simulating 128 Dipole objects as a function of the number of MPI processes. Simulations were performed using an Intel Xeon Processor E7-4800 v3 CPU.</p>
<p>Estimating the time complexity of the dipole object, the time step for the dipole trajectory arrays is a single location. However, this could significantly increase the time required to fetch these trajectory values from memory. As well, the number of broadcast operations could be reduced since it is not necessary to send the trajectory information to the other processes at each time step; instead, the trajectory values could be broadcast in batches only when they are required by the other processes, which would improve run time.</p>
<h3>3.4. Performance and accuracy</h3>
<p>There are two main sources of numerical error in the PyCharge package: calculating the retarded time of the sources at a given position (for determining the EM fields and potentials) by solving Eq. (5) using the secant method, and determining the dipole moment at each time step for the Dipole objects by solving Eq. (13) using the RK4 method.</p>
<p>The tolerance of the secant method (from the SciPy package) can be set as an initialization argument of the Simulation object. However, the default value should be satisfactory for most simulations, typically yielding a relative error less than 10<sup>−6</sup>% for the fields and potentials (see Fig. 6). Extra consideration is required if the point charges are moving at relativistic velocities, as the secant method could yield a significant error. The compute time required by the calculate_E, calculate_B, calculate_V, and calculate_A methods is dependent on several factors: as previously mentioned, the methods have a time complexity O(N) with respect to both the number of sources in the simulation and the number of spatial points in the grid, and also depend on the spacing of the spatial points in the grid and the trajectory of the point charges. In general, the computation time for these methods using a grid with 10<sup>6</sup> spatial points and a single Charge object is 0.5–2 s.<sup>4</sup></p>
<p>The RK4 numerical method used by the run method introduces fourth order convergence with time step size. For calculating the modified radiative properties of two coupled dipoles,</p>
<p>^{4}Compute times recorded using an Intel Xeon Processor E7-4800 v3 CPU.</p>
<p><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 4: The scalar potential and electric field components (shown as arrows) generated by two stationary, opposite point charges (shown as red dots). The sources (with charge magnitude <em>e</em>) are separated by 20 nm along the <em>x</em> axis. The scalar potential is plotted on a symmetrical logarithmic scale that is linear between −10<sup>−2</sup> V and 10<sup>−2</sup> V.</p>
<p>We found that choosing a time step value <em>dt</em> such that there are at least 10,000 time steps per dipole period yields relative errors less than 0.2% (see Fig. 7). In general, the choice of γ<sub>0</sub> (which is dependent on <em>q</em>, <em>m</em>, and ω<sub>0</sub>) must satisfy γ<sub>0</sub> ≪ ω<sub>0</sub> (see Eq. (12)), and the simulation error increases with respect to the ratio γ<sub>0</sub>/ω<sub>0</sub>. To accurately curve fit the kinetic energy values to the expected harmonic motion, as shown in Listing 2, we ran simulations for four dipole periods (40,000 time steps) and used the energy values after a single dipole period (10,000 time steps) had elapsed. Using the run method, this simulation had a run time of approximately ten minutes. Saving the simulation data into a file requires approximately 2.1 kB of memory per time step for each Dipole object in the simulation.</p>
<h2>4. Example simulations</h2>
<p>In this section, we demonstrate three different electrodynamics simulations performed using PyCharge: calculating the EM fields and potentials generated by moving point charges with predefined trajectories, simulating two coupled dipoles and determining their modified radiative properties, and instantiating moving dipoles for use in simulations. We also provide minimal Python listings that showcase the succinctness of the PyCharge interface. The Python scripts used to create the following figures can be found in the PyCharge package repository, and further examples and tutorials are available in the documentation.</p>
<h3>4.1. Point charges with predefined trajectories</h3>
<p>The EM fields and potentials generated by time-dependent point charge geometries can be complex and counterintuitive compared to their static counterparts. The calculation of the analytical solution, if one exists, often requires sophisticated vector calculus techniques that can obscure an individual's understanding and appreciation of the final result. However, using</p>
<p><img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 5: The magnitude of the Poynting vector of the EM fields generated by two harmonically oscillating, opposite point charges (shown as red dots). The sources (with charge magnitude <em>e</em>) oscillate around the origin with an amplitude of 2 nm and an angular frequency ω<sub>0</sub> of 7 × 10<sup>16</sup> rad/s.</p>
<p>only a few lines of code, the PyCharge package allows users to calculate and visualize the full solutions to Maxwell's equations for complicated point charge geometries.</p>
<p>In the first example, we calculate the total electric field and scalar potential generated by two <em>stationary, opposite point charges</em> (i.e., a stationary electric dipole). The corresponding program code is shown in Listing 1. The sources (two StationaryCharge objects) are separated by 20 nm along the <em>x</em> axis and have equal and opposite charges of magnitude <em>e</em>. The program code calculates the electric field components and scalar potential (at <em>t</em> ≈ 0 s) at each point on a 1001×1001 spatial grid, which is generated using the NumPy meshgrid method. The grid is centered at the origin and extends 50 nm along the <em>x</em> and <em>y</em> axes. A plot of the calculated electric field components (shown as arrows) and scalar potential is shown in Fig. 4.</p>
<div class="codehilite"><pre><span></span><code><span class="n">import</span><span class="w"> </span><span class="n">pycharge</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">pc</span>
<span class="n">from</span><span class="w"> </span><span class="n">numpy</span><span class="w"> </span><span class="n">import</span><span class="w"> </span><span class="n">linspace</span><span class="p">,</span><span class="w"> </span><span class="n">meshgrid</span>
<span class="n">from</span><span class="w"> </span><span class="n">scipy</span><span class="p">.</span><span class="n">constants</span><span class="w"> </span><span class="n">import</span><span class="w"> </span><span class="n">e</span>
<span class="n">sources</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">pc</span><span class="p">.</span><span class="n">StationaryCharge</span><span class="p">((</span><span class="mf">10e-9</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">e</span><span class="p">),</span>
<span class="n">pc</span><span class="p">.</span><span class="n">StationaryCharge</span><span class="p">((</span><span class="err">−</span><span class="mf">10e-9</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="err">−</span><span class="n">e</span><span class="p">))</span>
<span class="n">simulation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pc</span><span class="p">.</span><span class="n">Simulation</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span>
<span class="n">coord</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linspace</span><span class="p">(</span><span class="err">−</span><span class="mf">50e-9</span><span class="p">,</span><span class="w"> </span><span class="mf">50e-9</span><span class="p">,</span><span class="w"> </span><span class="mi">1001</span><span class="p">)</span>
<span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">meshgrid</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span><span class="w"> </span><span class="n">coord</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">indexing</span><span class="o">=</span><span class="err">&#39;</span><span class="n">ij</span><span class="err">&#39;</span><span class="p">)</span>
<span class="n">Ex</span><span class="p">,</span><span class="w"> </span><span class="n">Ey</span><span class="p">,</span><span class="w"> </span><span class="n">Ez</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">simulation</span><span class="p">.</span><span class="n">calculate_E</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">)</span>
<span class="n">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">simulation</span><span class="p">.</span><span class="n">calculate_V</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">)</span>
</code></pre></div>

<p>Listing 1: Calculates the electric field components and scalar potential generated by two stationary point charges along a 2D spatial grid.</p>
<p>The fields and potentials generated by different charge configurations can be simulated using the same code by instantiating other types of sources. For example, we can simulate a harmonically oscillating electric dipole by instantiating two</p>
<p><img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>Figure 6: The <em>x</em> component of the numerically computed electric field (top) and the respective relative error (bottom) generated by an oscillating dipole located at the origin as a function of <em>z</em>, which is scaled by the dipole's wavelength (<em>λ</em>₀). The theoretical values are given in Eq. (C.1). The electric dipole has an angular frequency <em>ω</em>₀ of 7×10¹⁴ rad/s and an initial dipole moment <em>d</em>₀ of 4<em>e</em>×10⁻⁹ C·m.</p>
<p>OscillatingCharge objects with opposite charge values (<em>q</em>) in the simulation. Users can also instantiate point charges with custom trajectories by creating a subclass of the Charge class and defining its motion along the <em>x</em>, <em>y</em>, and <em>z</em> directions as functions of time.</p>
<p>Once the electric and magnetic fields in the system have been determined by PyCharge, we can calculate the Poynting vector <strong>S</strong> (the directional energy flux of the EM fields), defined by</p>
<p>$$
\mathbf{S} = \frac{1}{\mu_0} \mathbf{E} \times \mathbf{B}. \tag{29}
$$</p>
<p>The magnitude of the Poynting vector from the EM fields generated by an oscillating electric dipole with an initial dipole moment <em>d</em>₀ of 4<em>e</em> × 10⁻⁹ C·m and an angular frequency <em>ω</em>₀ of 7×10¹⁴ rad/s is shown in Fig. 5.</p>
<p>Additionally, the <em>x</em> component of the electric field generated by the oscillating electric dipole along the <em>z</em> axis, and its relative error compared to the known analytical solution (given in Eq. (C.1)), are shown in Fig. 6. The analytical solution describes an idealized electric dipole where the separation between the charges is infinitesimal; thus, to reduce the relative error in the near-field, the PyCharge simulation uses a separation of 4<em>e</em> × 10¹⁴ m and a charge value <em>q</em> of <em>e</em> × 10⁵ C, which recovers the initial dipole moment <em>d</em>₀ of 4<em>e</em> × 10⁻⁹ C·m. Using these separation values, the relative error remains less than 10⁻⁶% but diverges in the very near-field of the dipole; this is expected since PyCharge is simulating a physical dipole with a non-infinitesimal separation.</p>
<h3>4.2. Two coupled dipoles</h3>
<p>In this section, we simulate two coupled dipoles (modeled as LOs) in a system and calculate their modified radiative properties.</p>
<p><img alt="img-6.jpeg" src="img-6.jpeg" /></p>
<p>Figure 7: The simulated and theoretical frequency shift <em>δ</em>₁₂ (top) and SE rate <em>γ</em><em> (bottom) of superradiant s and p dipoles as functions of separation. The frequency shift and SE rate are scaled by the free-space decay rate </em>γ<em>₀, and the separation is scaled by the dipole's wavelength </em>λ<em>₀. The value of </em>γ<em>₀ for the dipoles is 19.791 MHz (</em>q<em> = </em>e<em>, </em>m<em> = </em>m<em>e/2, and </em>ω<em>₀ = 200</em>π<em> × 10¹² rad/s). The frequency shift is plotted on a symmetrical logarithmic scale that is linear between ~10⁻¹</em>γ<em>₀ and 10¹</em>γ<em>₀. The theoretical values for </em>γ<strong> and <em>δ</em>₁₂ are calculated by PyCharge using Eqs. (A.4) and (A.6). The average relative errors of the <em>δ</em>₁₂ and *γ</strong> values for the p dipoles are 0.15% and 0.04%, and for the s dipoles are 0.19% and 0.13%.</p>
<p>The erties. An example program code for simulating two s dipoles (transverse), which are polarized along the <em>y</em> axis and separated by 80 nm along the <em>x</em> axis, is shown in Listing 2. The two dipoles have a natural angular frequency <em>ω</em>₀ of 200<em>π</em>×10¹² rad/s and are simulated over 40,000 time steps (with a time step <em>dt</em> of 10⁻¹⁸ s). The two charges in the dipole both have a mass of <em>me</em> (the effective mass of the dipole is <em>me</em>/2) and a charge magnitude of <em>e</em>. Once the simulation is complete, the Simulation and related source objects are saved into the file s_dipoles.dat, which can be accessed for analyses. The dipoles begin oscillating in phase with an initial charge displacement <strong>r</strong>₀₀₀ of 1 nm, resulting in superradiance and a modified SE rate <em>γ</em><strong>. The rate *γ</strong> and frequency shift <em>δ</em>₁₂ are then calculated in PyCharge by curve fitting the kinetic energy of the dipole (using the kinetic energy values after the 10,000 time step), as discussed in Sec. 2.4. As well, the theoretical values for <em>γ</em>₁₂ (related to <em>γ</em><em> by Eq. (A.5)) and </em>δ*₁₂ are calculated by PyCharge using Eqs. (A.4) and (A.6).</p>
<p>The radiative properties of two coupled dipoles as a function of separation can be calculated by repeatedly running the previous simulation while sweeping across a range of dipole separation values. Using this technique, the modified rate <em>γ</em><em> and frequency shift </em>δ<em>₁₂ for in phase (superradiant) s and p dipoles, scaled by the free-space emission rate </em>γ*₀, are plotted in Fig. 7. The theoretical results from QED theory are also shown in the figure, and the relative errors values (&lt; 0.2%) are provided.</p>
<p><img alt="img-7.jpeg" src="img-7.jpeg" /></p>
<p>Figure 8: The normalized populations of the excited states of two dipoles $a$ and $b$, where dipole $a$ is initially excited $\left(\rho_{a a} / 0\right)=1$ ) and dipole $b$ is not $\left(\rho_{b b} / 0\right)=0$ ). The dipoles are separated by $80 \mathrm{~nm}(0.053 \lambda_{0})$ and have a natural angular frequency $\omega_{0}$ of $400 \pi \times 10^{12} \mathrm{rad} / \mathrm{s}$. The free-space decay rate $\gamma_{0}$ of the dipoles is $7.916 \mathrm{GHz}(q=20 e$ and $m=m_{e} / 2)$. The total energy is calculated using Eq. (24), and the analytical solutions for the excited state populations are given in Eqs. (A.13) and (A.14).</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">pycharge</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pc</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">pi</span>
<span class="n">timesteps</span> <span class="o">=</span> <span class="mi">40000</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">1e-18</span>
<span class="n">omega_0</span> <span class="o">=</span> <span class="mf">100e12</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span>
<span class="n">origins</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mf">80e-9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">init_r</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1e-9</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">sources</span> <span class="o">=</span> <span class="p">(</span><span class="n">pc</span><span class="o">.</span><span class="n">Dipole</span><span class="p">(</span><span class="n">omega_0</span><span class="p">,</span> <span class="n">origins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">init_r</span><span class="p">),</span>
    <span class="n">pc</span><span class="o">.</span><span class="n">Dipole</span><span class="p">(</span><span class="n">omega_0</span><span class="p">,</span> <span class="n">origins</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">init_r</span><span class="p">))</span>
<span class="n">simulation</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span>
<span class="n">simulation</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">timesteps</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="s1">&#39;s_dipoles.dat&#39;</span><span class="p">)</span>
<span class="n">d_12</span><span class="p">,</span> <span class="n">g_plus</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">calculate_dipole_properties</span><span class="p">(</span>
    <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">first_index</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">d_12_th</span><span class="p">,</span> <span class="n">g_12_th</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">s_dipole_theory</span><span class="p">(</span>
    <span class="n">r</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">,</span> <span class="n">d_12</span><span class="o">=</span><span class="mf">80e-9</span><span class="p">,</span> <span class="n">omega_0</span><span class="o">=</span><span class="n">omega_0</span><span class="p">)</span>
</code></pre></div>

<p>Listing 2: Runs the simulation of two coupled (in phase) $s$ dipoles and calculates their radiative properties, as well as the theoretical radiative results from QED theory. From the code: $\delta_{12}=156.919, \delta_{12, \mathrm{th}}=156.926, \gamma^{*}=1.997$, and $\gamma_{12, \mathrm{th}}=0.994$ (scaled in units of $\gamma_{0}$ ).</p>
<p>We can also plot the normalized populations of the excited states of two coupled dipoles, $\rho_{a a}(t)$ and $\rho_{b b}(t)$, using the normalized total energy of the dipoles at each time step (Eqs. (24) and (25)). This yields particularly interesting results for coupled dipoles with small separations when one dipole is initially excited $\left(\rho_{a a} / 0\right)=1$ ) and the other is not $\left(\rho_{b b} / 0\right)=0$ ). In this scenario, the populations are a linear combination of the superradiant and subraddiant states, which leads to the observed energy transfer between dipoles known as Förster cou-
<img alt="img-8.jpeg" src="img-8.jpeg" /></p>
<p>Figure 9: The dipole moment in the frequency domain for one isolated LO (free-space decay) and two coupled LOs in free-space, where the latter response clearly shows the subradiant (lower energy resonance) and supperradiant states (higher energy resonance). The two LOs are separated by 80 nm and both have angular frequencies of $400 \pi \times 10^{12} \mathrm{rad} / \mathrm{s}$, and the theoretical (scaled) frequency shift $\delta_{12}$ is $18.86 \gamma_{0}$.
pling, ${ }^{5}$ as further discussed in Appendix A. This phenomenon can be simulated in PyCharge by initializing the excited dipole with a much larger dipole moment (and total energy) than the other. The simulation results and analytical solution, given in Eqs. (A.13) and (A.14), are shown in Fig. 8. Additionally, the dipole moment of dipole $a$ in the frequency domain is shown in Fig. 9, which clearly shows the frequency peaks of the subradiant and supperradiant states. ${ }^{6}$ The dipole moment of an isolated LO in the frequency domain is also shown for comparison.</p>
<h3>4.3. Moving dipoles</h3>
<p>In addition to stationary dipoles, PyCharge can selfconsistently simulate moving dipoles (e.g., oscillating) with a time-dependent origin (center of mass) position. Other direct EM simulation approaches (e.g., the FDTD method) cannot accurately model moving dipoles, which can have practical importance for nano-scale interactions as real atoms are rarely stationary. Thus, PyCharge can be used to explore new physics phenomena that arise from this additional dipole motion (e.g., phonons in dipole chains). Simulations with moving dipoles are performed in PyCharge by creating a function that accepts the time $t$ as a parameter and returns the position of the dipole's origin position at $t$ as a three element array $(x, y, z)$. This function is then passed as a parameter when instantiating the Dipole object. An example of instantiating a Dipole object with a time-dependent origin is given in Listing 3. A detailed analysis of moving dipoles using the PyCharge package will appear in future work.</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="kp">cos</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pycharge</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pc</span>
<span class="k">def</span><span class="w"> </span><span class="nf">fun_origin</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="o">*</span><span class="kp">cos</span><span class="p">(</span><span class="mf">1e12</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">omega_0</span> <span class="o">=</span> <span class="mf">100e12</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span>
<span class="n">init_d</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1e-9</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="kp">source</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">Dipole</span><span class="p">(</span><span class="n">omega_0</span><span class="p">,</span> <span class="n">fun_origin</span><span class="p">,</span> <span class="n">init_d</span><span class="p">)</span>
</code></pre></div>

<p>Listing 3: Instantiates a Dipole object with a time-dependent origin position that oscillates along the $x$ axis with an amplitude of 0.1 nm and an angular frequency of $2 \pi \times 10^{12} \mathrm{rad} / \mathrm{s}$.</p>
<h2>5. Conclusions</h2>
<p>PyCharge was developed as an open-source simulation package to allow both novice and experienced users model a wide range of classical electrodynamics systems using point charges. PyCharge can calculate the time-dependent, relativistically correct EM fields and potentials generated by moving point charges with predefined trajectories. The user can create custom point charge objects in PyCharge by defining the $x, y$, and $z$ charge positions as functions of time. PyCharge can also self-consistently simulate the motion of LOs (dipoles), which are driven by the electric field generated by the other sources in the system. With only a few lines of code to set up the simulation, PyCharge can return the calculated modified radiative properties of the LOs (SE rates and frequency shift) in the system.</p>
<p>Simulating multiple LOs in PyCharge is numerically exact and does not rely on a Markov approximation, which has clear advantages for scaling to multiple dipoles where analytically solving chains of atoms via coupling rates and master equations becomes tedious and eventually intractable. As well, the origin position of the LOs can be stationary or time-dependent, and the latter is often very difficult to calculate analytically. We hope that PyCharge will prove useful as a novel simulator in the rapidly advancing field of computational electrodynamics, and expect that future versions of PyCharge will be improved by implementing new ideas from the open-source research community.</p>
<h2>Acknowledgements</h2>
<p>This work was supported by the Natural Sciences and Engineering Research Council of Canada, Queen's University, and the Canadian Foundation for Innovation. We also acknowledge support from CMC Microsystems, Xanadu Quantum Technologies, and Mitacs, as well as from the Centre for Advanced Computing (CAC) at Queen's University.</p>
<h2>Appendix A. Green's functions, quantum master equations, and analytical expressions for the radiative decay rates and coupling parameters</h2>
<h2>Appendix A.1. Green's function for free-space</h2>
<p>To describe the general theory of light emission, we first define the dyadic Green's function $\mathbf{G}\left(\mathbf{r}, \mathbf{r}^{\prime} ; \omega\right)$, which describes
the field response at $\mathbf{r}$ to an oscillating polarization dipole at $\mathbf{r}^{\prime}$ as a function of frequency. The Green's function is the solution to the wave equation $[6,16,17]$</p>
<p>$$
\left[\nabla \times \nabla \times-\frac{\omega^{2}}{c^{2}} \epsilon(\mathbf{r})\right] \mathbf{G}\left(\mathbf{r}, \mathbf{r}^{\prime}, \omega\right)=\frac{\omega^{2}}{c^{2}} \mathbf{I} \delta\left(\mathbf{r}-\mathbf{r}^{\prime}\right)
$$</p>
<p>where $\mathbf{I}$ is the unit dyadic, and $\epsilon=n^{2}$ is the dielectric constant that we will assume is lossless (real), and we also assume a non-magnetic material. For a homogeneous dielectric with a refractive index $n$ (where $n=1$ in a free-space medium), the homogeneous Green's function can be written analytically given the wavevector in the background medium $k=\omega n / c$ :</p>
<p>$$
\begin{aligned}
\mathbf{G}<em 0="0">{\text {hom }}(R ; \omega) &amp; =\left(\mathbf{I}+\frac{\nabla \nabla}{k^{2}}\right) \frac{k</em> \
&amp; =\frac{\mu_{0} k_{0}^{2} \exp (i k R)}{4 \pi R}\left[\left(1+\frac{i k R-1}{k^{2} R^{2}}\right) \mathbf{I}\right. \
&amp; \left.+\left(\frac{3-3 i k R-k^{2} R^{2}}{k^{2} R^{2}}\right) \frac{\mathbf{R} \otimes \mathbf{R}}{R^{2}}\right]+\frac{\delta(R)}{3 n^{2}} \mathbf{I}
\end{aligned}
$$}^{2} e^{i k R}}{4 \pi R</p>
<p>where $R=|\mathbf{R}|=\left|\mathbf{r}-\mathbf{r}^{\prime}\right|$ and $k_{0}=\omega / c$.
Although it is possible to analytically define the exact timedependent solution from a Fourier transform of an exact Dyson solution in the presence of a finite number of quantum emitters (treated as quantized harmonic oscillators), and thus obtain an exact solution to the emitted spectrum [18, 19], below we present a simpler and more common solution (by invoking a Markov approximation) that immediately connects to the main physics regimes studied in this paper.</p>
<h2>Appendix A.2. Quantum master equation for coupled two level systems and the coupling rates</h2>
<p>In QED, treating the atoms as TLSs, one can use a BornMarkov approximation to derive the master equation for the reduced density $\rho$, where the decay rates $\gamma_{i j}$ appear directly as Lindblad superoperators, and $\delta_{12}$ is a simple frequency shift $\omega_{i} \rightarrow \omega_{i}+\delta_{i j}$. For two coupled TLSs, $a$ and $b$, the resulting master equation (in the interaction picture) is [20, 21, 22]</p>
<p>$$
\begin{aligned}
\frac{d \rho}{d t} &amp; =\sum_{a, \beta=a, b} \frac{\gamma_{\alpha \beta}\left(\omega_{a}\right)}{2}\left[2 \sigma_{\alpha}^{-} \rho \sigma_{\beta}^{+}-\sigma_{\alpha}^{+} \sigma_{\beta}^{-} \rho-\rho \sigma_{\alpha}^{+} \sigma_{\beta}^{-}\right] \
&amp; -i\left[\left(\delta_{a b}\left(\omega_{b}\right) \sigma_{a}^{+} \sigma_{b}^{-}+\delta_{b a}\left(\omega_{a}\right) \sigma_{b}^{+} \sigma_{a}^{-}\right), \rho\right]
\end{aligned}
$$</p>
<p>where $\sigma_{\alpha}^{ \pm}$and $\sigma_{\beta}^{+}$are the Pauli operators for the TLSs (i.e., $\sigma_{\alpha}^{+}=\left|e_{\alpha}\right\rangle\left\langle g_{\alpha}\right|$ and $\sigma_{\alpha}^{-}=\left|g_{\alpha}\right\rangle\left\langle e_{\alpha}\right|$ ). The master equation accounts for the interactions between the quantum emitters and the surrounding environment, and we have also used a rotating wave approximation.</p>
<p>For two coupled TLSs (which recover the same model as two quantized harmonic oscillators in the weak excitation approximation), $a$ and $b$, in close vicinity with equal resonance frequencies $\left(\omega_{0}=\omega_{a}=\omega_{b}\right)$, the self $\left(\gamma_{a a, b b}\right)$ and cross $\left(\gamma_{a b, b a}\right)$ decay rates are obtained from [20, 21, 23]</p>
<p>$$
\gamma_{\alpha \beta}=\frac{2 \mathbf{d}<em _alpha="\alpha">{\alpha}^{\dagger} \cdot \operatorname{Im} \mathbf{G}\left(\mathbf{r}</em>}, \mathbf{r<em 0="0">{\beta}, \omega</em>}\right) \cdot \mathbf{d<em 0="0">{\beta}}{\epsilon</em>
$$} \hbar</p>
<p>Assuming the two TLSs are identical ( $\mathbf{d}<em b="b">{a}=\mathbf{d}</em>\right\rangle\right)$, respectively, which decay with the modified rates}$ and $\omega_{a}=$ $\omega_{b}$ ), we define the on-resonance Markovian decay rates as $\gamma_{0} \equiv$ $\gamma_{a a}=\gamma_{b b}$ and $\gamma_{12} \equiv \gamma_{a b}=\gamma_{b a}$. The hybrid system (in the presence of coupling) can then form superradiant or subradiant states [24], defined from $\left|\psi^{+}\right\rangle=1 / \sqrt{2}\left(\left|e_{a}, g_{b}\right\rangle+\left|g_{a}, e_{b}\right\rangle\right)$ and $\left|\psi^{-}\right\rangle=1 / \sqrt{2}\left(\left|e_{a}, g_{b}\right\rangle-\left|g_{a}, e_{b</p>
<p>$$
\gamma^{h}=\gamma_{0} \pm \gamma_{12}
$$</p>
<p>The so-called virtual photon transfer rate (or dipole-dipole induced frequency shift) between two TLSs with equal resonance frequencies is</p>
<p>$$
\left.\delta_{\alpha \beta}\right|<em _alpha="\alpha">{\alpha \neq \beta}=-\frac{\mathbf{d}</em>}^{\dagger} \cdot \operatorname{Re} \mathbf{G}\left(\mathbf{r<em _beta="\beta">{\alpha}, \mathbf{r}</em>}, \omega_{0}\right) \cdot \mathbf{d<em 0="0">{\beta}}{\epsilon</em>
$$} \hbar</p>
<p>This "exchange" term fully recovers Förster coupling and can yield superradiant and subradiant states (Dicke states) for two coupled TLSs at small separation distances [24].</p>
<p>Although the expressions in terms of the photonic Green's function are general for any medium, to recover the free-space dipole problem in the main text, we simply replace $\mathbf{G}$ by $\mathbf{G}_{\text {hom }}$ and obtain these rates analytically (within a Markov approximation, i.e., evaluated at a single frequency). We can rewrite the quantum master equation for two coupled TLSs with equal resonance frequencies as</p>
<p>$$
\begin{aligned}
\frac{d \rho}{d t}= &amp; \sum_{\alpha, \beta=a, b} \frac{\gamma_{\alpha \beta}}{2}\left[2 \sigma_{\alpha}^{+} \rho \sigma_{\beta}^{-}-\sigma_{\alpha}^{+} \sigma_{\beta}^{-} \rho-\rho \sigma_{\alpha}^{+} \sigma_{\beta}^{-}\right] \
&amp; -i \delta_{12}\left[\left(\sigma_{a}^{+} \sigma_{b}^{-}+\sigma_{b}^{+} \sigma_{a}^{-}\right), \rho\right]
\end{aligned}
$$</p>
<p>From the master equation, we can easily derive the equation of motion for any observable of interest, i.e., from $\langle\ddot{O}\rangle=$ $\langle\dot{\rho} O\rangle=\operatorname{Tr}(\dot{\rho} O)$. For example, the population equation of motion for the two coupled dipoles are</p>
<p>$$
\begin{aligned}
&amp; \dot{\rho}<em a="a">{a a}=-\gamma</em> \
&amp; \dot{\rho}} \rho_{a a}-\gamma_{a b} \rho_{a b}-i \delta_{a b} \rho_{a b<em b="b">{b b}=-\gamma</em>
\end{aligned}
$$} \rho_{b b}-\gamma_{b a} \rho_{b a}+i \delta_{b a} \rho_{b a</p>
<p>where the density matrix elements are $\rho_{\alpha \beta}=\langle\alpha \mid \rho \mid \beta\rangle$.
The coherence between the TLSs, accounted for by the terms $\rho_{a b}$ and $\rho_{b a}$ (whose equations can be derived similarly), can significant affect the radiative decay rates, allowing various collective solutions such as superradiant and subradiant decays. For example, given the initial conditions $\rho_{a a}(0)=1$ and $\rho_{b b}(0)=\rho_{a b}(0)=\rho_{b a}(0)=0$, and assuming the dipoles are identical, the excited state populations have a non-trivial time dependence with oscillatory dynamics, as shown in Eqs. (A.13) and (A.14).</p>
<p>In the next section, we will solve the density matrix equations in a different basis (using the dressed states), which both simplifies their solution and clearly shows the collective modified decay rates for the superradiant and subradiant states - which decay with the rates $\gamma^{+}$and $\gamma^{-}$, respectively.</p>
<h2>Appendix A.3. Time-dependent solution to the master equation for initially excited atoms</h2>
<p>With no initial driving field included, the reduced master equation (Eq. (A.7)) can be solved analytically. To make this
clear, we can restrict the size of the basis to include the following four states: $|I\rangle=\left|g_{a}, g_{b}\right\rangle,|II\rangle=\left|e_{a}, e_{b}\right\rangle$, and $|\pm\rangle=$ $1 / \sqrt{2}\left(\left|e_{a}, g_{b}\right\rangle \pm\left|g_{a}, e_{b}\right\rangle\right)$, where $g$ and $e$ label the ground and excited states of the TLSs. If the initial excitation only involves the density matrix elements $\rho_{++}, \rho_{--}, \rho_{+-}$, and $\rho_{-+}$(so only the atoms are excited, i.e., the fields are in a vacuum state, $\left.|\phi\rangle_{\text {fields }}=|10\rangle\right|$ ), with $\rho_{\alpha \beta}=|\alpha\rangle\langle\beta|$, then we have the following density matrix equations for two identical TLSs:</p>
<p>$$
\begin{aligned}
&amp; \dot{\rho}<em 0="0">{++}=-\left(\gamma</em> \
&amp; \dot{\rho}}+\gamma_{12}\right) \rho_{++<em 0="0">{--}=-\left(\gamma</em> \
&amp; \dot{\rho}}-\gamma_{12}\right) \rho_{--<em 0="0">{+-}=-\left(\gamma</em> \
&amp; \dot{\rho}}+i 2 \delta_{12}\right) \rho_{+-<em 0="0">{-+}=-\left(\gamma</em>
\end{aligned}
$$}-i 2 \delta_{12}\right) \rho_{-+</p>
<p>which have the explicit solutions</p>
<p>$$
\begin{aligned}
&amp; \rho_{++}(t)=\rho_{++}(0) e^{-\left(\gamma_{0}+\gamma_{12}\right) t} \
&amp; \rho_{--}(t)=\rho_{--}(0) e^{-\left(\gamma_{0}-\gamma_{12}\right) t} \
&amp; \rho_{+-}(t)=\rho_{+-}(0) e^{-\left(\gamma_{0}+2 i \delta_{12}\right) t} \
&amp; \rho_{--}(t)=\rho_{-+}(0) e^{-\left(\gamma_{0}-2 i \delta_{12}\right) t}
\end{aligned}
$$</p>
<p>which is a particular case of weak excitation, so the two quantum state $(|I I\rangle)$ is decoupled. Consequently, this coupled TLS solution recovers the solution of coupled quantized harmonic oscillators, and this is also why the radiative decay of classical LOs are then identical in this limit.</p>
<p>These decay solutions are precisely the cases of superradiant decay, subradiant decay, and a linear combination of superradiant and subradiant decay. The latter case will cause population beatings that oscillate with a beating time of $T_{\text {beat }}=\pi / \delta_{12}$. Although we have derived these equations in a Markov approximation, we note that this is not necessary in general, and the full time-dependent quantum dynamics can also be worked out analytically in a weak excitation approximation [19]. The PyCharge simulations are also numerically exact and do not rely on a Markov approximation, and have clear advantages for scaling to multiple dipoles, where analytically solving chains of atoms via coupling rates and master equations becomes tedious and eventually intractable.</p>
<p>The expectation values for observables in the original basis are derived in the usual way, e.g., for the excited population in the TLS $a$, we have</p>
<p>$$
\rho_{a a}=\left\langle\sigma_{a}^{+} \sigma_{a}^{-}\right\rangle=\sum_{i, j}\langle j| \sigma_{a}^{+} \sigma_{a}^{-}|i\rangle \rho_{j i}
$$</p>
<p>where $i, j$ sums over states $|I\rangle,|I I\rangle$, and $|\pm\rangle$, and similarly for $\rho_{b b}$. For an initial condition of $\rho_{a a}(0)=1$ and $\rho_{b b}(0)=$ $\rho_{b a}(0)=\rho_{a b}(0)=0$, this is equivalent to having $\rho_{++}(0)=$ $\rho_{+-}(0)+\rho_{-+}(0)=\rho_{--}(0)=1 / 4$. The explicit time-dependent solutions for the population decays, from Eq. (A.11), is</p>
<p>$$
\rho_{a a}(t)=\frac{1}{4}\left(e^{-\left(\gamma_{0}-\gamma_{12}\right) t}+e^{-\left(\gamma_{0}+\gamma_{12}\right) t}+2 \cos \left(2 \delta_{12} t\right) e^{-\gamma_{0} t}\right)
$$</p>
<p>and</p>
<p>$$
\rho_{b b}(t)=\frac{1}{4}\left(e^{-\left(\gamma_{0}-\gamma_{12}\right) t}+e^{-\left(\gamma_{0}+\gamma_{12}\right) t}-2 \cos \left(2 \delta_{12} t\right) e^{-\gamma_{0} t}\right)
$$</p>
<p>Finally, in the limit of very small dipole separations, where $\gamma_{12} \approx \gamma_{0}$, we have the approximate solutions</p>
<p>$$
\rho_{\text {int }}(t) \approx \frac{1}{4}\left(1+e^{-2 \gamma_{0} t}+2 \cos \left(2 \delta_{12} t\right) e^{-\gamma_{0} t}\right)
$$</p>
<p>and</p>
<p>$$
\rho_{b}(t) \approx \frac{1}{4}\left(1+e^{-2 \gamma_{0} t}-2 \cos \left(2 \delta_{12} t\right) e^{-\gamma_{0} t}\right)
$$</p>
<h2>Appendix B. Fermi's Golden Rule for the Free-Space Spontaneous Emission Rate</h2>
<p>Here, we briefly show the standard Fermi's golden rule approach for calculating the free-space SE rate. Fermi's golden rule is written as</p>
<p>$$
\gamma_{i \rightarrow f}\left(\omega_{f}\right)=\frac{2 \pi}{\hbar}\left|\langle i| H_{\mathrm{int}}| f\right\rangle\left.\right|^{2} D\left(\omega_{f}\right)
$$</p>
<p>where $D$ is the density of states (assumed to be approximately constant over the region of emission), and $i$ and $f$ are the initial and final states, respectively. Consistent with the Markov approximation in the density matrix approach, this is also a long time Markovian "rate".</p>
<p>The dipole interaction Hamiltonian $H_{\text {int }}$ has the usual form</p>
<p>$$
H_{\mathrm{int}}=-\sum_{\mathbf{k}, \eta} \sqrt{\frac{\hbar \omega_{\mathbf{k}}}{2 \varepsilon_{0}}}\left(\sigma^{+}+\sigma^{-}\right) \mathbf{d}<em _mathbf_k="\mathbf{k">{g e} \cdot\left(\mathbf{f}</em>}, \eta} \hat{a<em _mathbf_k="\mathbf{k">{\mathbf{k}, \eta}+\mathbf{f}</em>\right)
$$}, \eta}^{*} \hat{a}_{\mathbf{k}, \eta}^{\dagger</p>
<p>where $\hat{a}<em _mathbf_k="\mathbf{k">{\mathbf{k}, \eta}^{\dagger}$ and $\hat{a}</em>$ with polarization $\eta$. The classical normal modes can be written as}, \eta}$ are the creation and annihilation operators for the fields at wave vector $\mathbf{k</p>
<p>$$
\mathbf{f}<em _mathbf_k="\mathbf{k">{\mathbf{k}, \eta}=\frac{1}{\sqrt{V}} \hat{\varepsilon}</em>
$$}, \eta} e^{i \mathbf{k} \cdot \mathbf{r}</p>
<p>where $V$ is an arbitrary volume.
Beginning in the excited state, $|\tilde{\imath}\rangle=|e,|0|\rangle$ and evolving to the final state $|f\rangle=|g, \mathbf{1}_{\mathbf{k}, \eta}\rangle$, the relevant matrix element for photon emission is</p>
<p>$$
\langle e,| 0\left|\left|H_{\mathrm{int}}\right| g, \mathbf{1}<em _mathbf_k="\mathbf{k">{\mathbf{k}, \eta}\right\rangle=\sqrt{\frac{\hbar \omega</em>}}}{2 \epsilon_{0} V}}\left(\hat{\varepsilon<em e="e" g="g">{\mathbf{k}, \eta} \cdot \mathbf{d}</em>
$$}\right) e^{i \mathbf{k} \cdot \mathbf{r}</p>
<p>Computing the free-space density of states in the usual way, namely with periodic boundary conditions, we have</p>
<p>$$
D\left(\omega_{0}\right)=\frac{\omega_{0}^{2} V}{\pi^{2} \hbar c^{3}}
$$</p>
<p>Finally, using $\omega_{\mathbf{k}} \approx \omega_{0}$ and $\left|\hat{\varepsilon}<em e="e" g="g">{\mathbf{k}, \eta} \cdot \mathbf{d}</em> / 3$ (isotropic averaging), the SE rate is given by}\right|^{2}=\left|d_{g e}\right|^{2</p>
<p>$$
\gamma_{0}=\frac{\omega_{0}^{3}\left|\mathbf{d}<em 0="0">{g e}\right|^{2}}{3 \pi \epsilon</em>
$$} \hbar c^{3}</p>
<p>which is identical to the $\gamma_{0}$ expressions in the main text (Eq. (20)), and also with Eq. (A.4) when using the free-space Green's function. Note in the quantum case, the dipole matrix element is formally defined from $\mathbf{d}_{g e}=\langle g| \hat{\mathbf{d}}|e\rangle$.</p>
<h2>Appendix C. Electromagnetic fields generated by an oscillating electric dipole</h2>
<p>The exact equations that define the electric and magnetic fields generated by an idealized oscillating electric dipole located at the origin are given by</p>
<p>$$
\begin{aligned}
\mathbf{E}(\mathbf{r}, t)=\frac{1}{4 \pi \epsilon_{0}} &amp; {\left[k^{2}(\hat{\mathbf{r}} \times \mathbf{d}) \times \hat{\mathbf{r}} \frac{e^{i k r}}{r}\right.} \
&amp; \left.+[3(\hat{\mathbf{r}} \cdot \mathbf{d}) \hat{\mathbf{r}}-\mathbf{d}]\left(\frac{1}{r^{3}}-\frac{i k}{r^{2}}\right) e^{i k r}\right]
\end{aligned}
$$</p>
<p>and</p>
<p>$$
\mathbf{B}(\mathbf{r}, t)=\frac{\mu_{0}}{4 \pi}\left[c k^{2}(\hat{\mathbf{r}} \times \mathbf{d}) \frac{e^{i k r}}{r}\left(1-\frac{1}{i k r}\right)\right]
$$</p>
<p>where $k=\omega / c$ and $\omega$ is the angular frequency of the oscillating dipole, $\mathbf{d}=d_{0} e^{-i \omega t}$ is the time-dependent dipole moment, $r=|\mathbf{r}|$, and $\hat{\mathbf{r}}=\mathbf{r} / r[1]$.</p>
<h2>References</h2>
<p>[1] J. D. Jackson, Classical electrodynamics, 3rd Edition, Wiley, 1999.
[2] P. Milonni, Semiclassical and quantum-electrodynamical approaches in nonrelativistic radiation theory, Physics Reports 25 (1) (1976) 1-81. URL https://doi.org/10.1016/0370-1573(76)90037-5
[3] J. D. Hunter, Matplotlib: A 2d graphics environment, Computing in Science \&amp; Engineering 9 (3) (2007) 90-95. doi:10.1109/MCSE. 2007.55.
[4] D. J. Griffiths, Introduction to Electrodynamics, 4th Edition, Cambridge University Press, 2017.
[5] L. Novotny, B. Hecht, Principles of nano-optics, Cambridge University Press, 2006.
URL http://www.books24x7.com/marc.asp?bookid=44009
[6] P. de Vries, D. V. van Coevorden, A. Lagendijk, Point scatterers for classical waves, Rev. Mod. Phys. 70 (1998) 447-466. doi:10.1103/ RevModPhys.70.447.
URL https://link.aps.org/doi/10.1103/RevModPhys.70.447
[7] E. Schelew, R.-C. Ge, S. Hughes, J. Pond, J. F. Young, Self-consistent numerical modeling of radiatively damped lorentz oscillators, Phys. Rev. A 95 (2017) 063853. doi:10.1103/PhysRevA.95.063853. URL https://link.aps.org/doi/10.1103/PhysRevA.95. 063853
[8] L. D. Dalcin, R. R. Paz, P. A. Kler, A. Cosimo, Parallel distributed computing using python, Advances in Water Resources 34 (9) (2011) 1124-1139. doi:10.1016/j.adwvatres.2011.04.013.
[9] E. Wiechert, Elektrodynamische elementargesetze, Annalen der Physik 309 (4) (1901) 667-689. doi:10.1002/andp. 19013090403.
[10] P. Virtanen, R. Gommers, T. E. Oliphant, M. Haberland, T. Reddy, D. Cournapeau, E. Burovski, P. Peterson, W. Weckesser, J. Bright, et al., Scipy 1.0: fundamental algorithms for scientific computing in python, Nature Methods 17 (3) (2020) 261-272. doi:10.1038/ s41592-019-0686-2.
[11] M. J. Filipovich, S. Hughes, Space-time computation and visualization of the electromagnetic fields and potentials generated by moving point charges, American Journal of Physics 89 (5) (2021) 482-489. URL https://aapt.scitation.org/doi/10.1119/10.0003207
[12] P. W. Milonni, J. H. Eberly, Lasers physics, John Wiley \&amp; Sons, 2010.
[13] S. Franke, J. Ren, M. Richter, A. Knorr, S. Hughes, Fermi's golden rule for spontaneous emission in absorptive and amplifying media, Phys. Rev. Lett. 127 (2021) 013602. doi:10.1103/PhysRevLett.127.013602. URL https://link.aps.org/doi/10.1103/PhysRevLett.127. 013602
[14] J. Larmor, LXIII. On the theory of the magnetic influence on spectra; and on the radiation from moving ions, The London, Edinburgh, and Dublin Philosophical Magazine and Journal of Science 44 (271) (1897) 503-512. doi:10.1080/14786449708621095.</p>
<p>[15] D. S. Citrin, Coherent transport of excitons in quantum-dot chains: role of retardation, Optics Letters 20 (8) (1995) 901. doi:10.1364/ol.20. 000901 .
URL https://doi.org/10.1364/ol.20.000901
[16] P. Yao, V. S. C. Manga Rao, S. Hughes, On-chip single photon sources using planar photonic crystals and single quantum dots: On-chip single photon sources using planar photonic crystals, Laser \&amp; Photonics Reviews 4 (4) (2010) 499-516. doi:10.1002/lpor. 200810081.
[17] C. P. Van Vlack, Dyadic Green functions and their applications, Ph.D. thesis, Queen's University Canada (2012).
[18] M. Wubs, L. G. Suttorp, A. Lagendijk, Multiple-scattering approach to interatomic interactions and superradiance in inhomogeneous dielectrics, Physical Review A 70 (5) (2004) 053823. doi:10.1103/PhysRevA. 70.053823 .
[19] P. Yao, S. Hughes, Macroscopic entanglement and violation of Bell's inequalities between two spatially separated quantum dots in a planar photonic crystal system, Optics Express 17 (14) (2009) 11505. doi: 10.1364/oe.17.011505.
URL https://doi.org/10.1364/oe.17.011505
[20] G. S. Agarwal, Quantum electrodynamics in the presence of dielectrics and conductors. iv. general theory for spontaneous emission in finite geometries, Phys. Rev. A 12 (1975) 1475-1497. doi:10.1103/ PhysRevA.12.1475.
URL https://link.aps.org/doi/10.1103/PhysRevA.12.1475
[21] G. Angelatos, S. Hughes, Entanglement dynamics and Mollow nonuplets between two coupled quantum dots in a nanowire photonic-crystal system, Phys. Rev. A 91 (2015) 051803. doi:10.1103/PhysRevA.91.051803.
URL https://link.aps.org/doi/10.1103/PhysRevA.91. 051803
[22] S. A. H. Gangaraj, A. Nemilentsau, G. W. Hanson, S. Hughes, Transient and steady-state entanglement mediated by three-dimensional plasmonic waveguides, Optics Express 23 (17) (2015) 22330. doi:10.1364/oe. 23.022330.</p>
<p>URL https://doi.org/10.1364/oe.23.022330
[23] H. T. Dung, L. Knöll, D.-G. Welsch, Resonant dipole-dipole interaction in the presence of dispersing and absorbing surroundings, Phys. Rev. A 66 (2002) 063810. doi:10.1103/PhysRevA.66.063810.
URL https://link.aps.org/doi/10.1103/PhysRevA.66. 063810
[24] R. H. Dicke, Coherence in spontaneous radiation processes, Phys. Rev. 93 (1954) 99-110. doi:10.1103/PhysRev.93.99.
URL https://link.aps.org/doi/10.1103/PhysRev.93.99</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{5}$ The solution calculated by PyCharge is more general as we also include dynamical coupling terms beyond the usual $1 / \mid r^{5}$ static coupling regime, but the Förster coupling is fully recovered. Indeed for chains of coupled dipoles, the retardation effects become essential to include [15].
${ }^{6}$ An identical frequency plot could also be created using the dipole moment of dipole $b$.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:1">
<p>${ }^{1}$ There are other classes of electrodynamics problems without sources, used to obtain the underlying modes, which we are not concerned with here.&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>