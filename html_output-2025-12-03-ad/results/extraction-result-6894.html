<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-6894 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-6894</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-6894</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-133.html">extraction-schema-133</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of the representational format of conceptual knowledge in the brain at a functional level, including theoretical models, their descriptions, claimed representational formats, supporting or contradictory empirical evidence, experimental paradigms, key findings, and citation information.</div>
                <p><strong>Paper ID:</strong> paper-2ee00192a11fd13786f3a68df881a41de46a614d</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/2ee00192a11fd13786f3a68df881a41de46a614d" target="_blank">Conceptual Knowledge Markup Language: An introduction</a></p>
                <p><strong>Paper Venue:</strong> arXiv.org</p>
                <p><strong>Paper TL;DR:</strong> The new version of CKML continues to follow the philosophy of Conceptual Knowledge Processing, but also incorporates various principles, insights and techniques from Information Flow (IF), the logical design of distributed systems.</p>
                <p><strong>Paper Abstract:</strong> Conceptual Knowledge Markup Language (CKML) is an application of XML. Earlier versions of CKML followed rather exclusively the philosophy of Conceptual Knowledge Processing (CKP), a principled approach to knowledge representation and data analysis that “advocates methods and instruments of conceptual knowledge processing which support people in their rational thinking, judgment and acting and promote critical discussion”. The new version of CKML continues to follow this approach, but also incorporates various principles, insights and techniques from Information Flow (IF), the logical design of distributed systems. Among other things, this allows diverse communities of discourse to compare their own information structures, as coded in logical theories, with that of other communities that share a common generic ontology. CKML incorporates the CKP ideas of concept lattice and formal context, along with the IF ideas of classification (= formal context), infomorphism, theory, interpretation and local logic. Ontology Markup Language (OML), a subset of CKML that is a self-sufficient markup language in its own right, follows the principles and ideas of Conceptual Graphs (CG). OML is used for structuring the specifications and axiomatics of metadata into ontologies. OML incorporates the CG ideas of concept, conceptual relation, conceptual graph, conceptual context, participants and ontology. The link from OML to CKML is the process of conceptual scaling, which is the interpretive transformation of ontologically structured knowledge to conceptual structured knowledge.</p>
                <p><strong>Cost:</strong> 0.012</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e6894.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e6894.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of the representational format of conceptual knowledge in the brain at a functional level, including theoretical models, their descriptions, claimed representational formats, supporting or contradictory empirical evidence, experimental paradigms, key findings, and citation information.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>FCA / Concept Lattice</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Formal Concept Analysis (Concept Lattice)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A mathematical framework representing conceptual knowledge as a lattice of formal concepts, each concept defined by an extent (set of objects) and an intent (set of attributes); formal contexts (object-attribute incidence matrices) are equivalent to concept lattices.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>theory_name</strong></td>
                            <td>Formal Concept Analysis / Concept Lattice</td>
                        </tr>
                        <tr>
                            <td><strong>theory_type</strong></td>
                            <td>relational network / lattice (symbolic-structural)</td>
                        </tr>
                        <tr>
                            <td><strong>theory_description</strong></td>
                            <td>Conceptual knowledge is represented as formal concepts (pairs of extents and intents) ordered in a lattice; objects label nodes downward (extent) and attributes label nodes upward (intent); the structure is derived from an object×attribute incidence relation (formal context).</td>
                        </tr>
                        <tr>
                            <td><strong>functional_claims</strong></td>
                            <td>Represents hierarchical relationships among concepts, supports transparent composition of content and type hierarchies, enables computation of joins/meets (generalization/specialization), and gives a principled faceted organization of information.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_source</strong></td>
                            <td>theoretical/formal demonstration and applied examples</td>
                        </tr>
                        <tr>
                            <td><strong>experimental_paradigm</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>key_result</strong></td>
                            <td>Formal contexts (incidence matrices) and concept lattices are equivalent data structures; formal concepts correspond to maximal rectangles of 1s in the incidence matrix, and lattice operations compute specialization/generalization.</td>
                        </tr>
                        <tr>
                            <td><strong>supports_theory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>counter_evidence</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>citation</strong></td>
                            <td>Robert E. Kent (unknown year)</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Conceptual Knowledge Markup Language: An introduction', 'publication_date_yy_mm': '2000-06'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6894.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e6894.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of the representational format of conceptual knowledge in the brain at a functional level, including theoretical models, their descriptions, claimed representational formats, supporting or contradictory empirical evidence, experimental paradigms, key findings, and citation information.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Conceptual Graphs (CG)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Conceptual Graphs</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A graph-based semantic representation using concepts (nodes) and conceptual relations (edges), supporting quantifiers, nested contexts, and assertions for complex propositions.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>theory_name</strong></td>
                            <td>Conceptual Graphs</td>
                        </tr>
                        <tr>
                            <td><strong>theory_type</strong></td>
                            <td>symbolic relational graph</td>
                        </tr>
                        <tr>
                            <td><strong>theory_description</strong></td>
                            <td>Concepts and relations form graph structures that represent propositions; contextual nesting represents propositions-about-propositions; conceptual graphs provide a complete semantic model for assertions and contexts.</td>
                        </tr>
                        <tr>
                            <td><strong>functional_claims</strong></td>
                            <td>Allows representation of complex propositions (including nested assertions and quantification), supports mapping to logical formulas and use in ontology specification and conceptual scaling.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_source</strong></td>
                            <td>theoretical/formal correspondences and examples</td>
                        </tr>
                        <tr>
                            <td><strong>experimental_paradigm</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>key_result</strong></td>
                            <td>OML/CKML corresponds closely to conceptual graphs; conceptual contexts in CG map to assertion/description mechanisms in OML allowing quotations (statements about statements) without reification.</td>
                        </tr>
                        <tr>
                            <td><strong>supports_theory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>counter_evidence</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>citation</strong></td>
                            <td>Robert E. Kent (unknown year)</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Conceptual Knowledge Markup Language: An introduction', 'publication_date_yy_mm': '2000-06'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6894.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e6894.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of the representational format of conceptual knowledge in the brain at a functional level, including theoretical models, their descriptions, claimed representational formats, supporting or contradictory empirical evidence, experimental paradigms, key findings, and citation information.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Information Flow (IF)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Barwise & Seligman's Information Flow (classification and infomorphisms)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A formal theory of distributed systems and information that models classifications (formal contexts), infomorphisms (structure-preserving mappings between classifications), theories and interpretations.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>theory_name</strong></td>
                            <td>Information Flow</td>
                        </tr>
                        <tr>
                            <td><strong>theory_type</strong></td>
                            <td>relational/ categorical / mapping-based formalism</td>
                        </tr>
                        <tr>
                            <td><strong>theory_description</strong></td>
                            <td>Conceptual knowledge is modeled as classifications (instances typed by types) with infomorphisms and theory/interpretation mappings capturing information channels and translations between ontologies; local logics represent realized scales.</td>
                        </tr>
                        <tr>
                            <td><strong>functional_claims</strong></td>
                            <td>Supports principled interoperability between different communities' information structures, formalizes how types and instances relate across mappings, and underlies conceptual scaling and apposition operations.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_source</strong></td>
                            <td>formal theory and mappings (mathematical)</td>
                        </tr>
                        <tr>
                            <td><strong>experimental_paradigm</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>key_result</strong></td>
                            <td>The classification-projection semantics asserts that if a relation instance r is classified by relation type t, then source/target instances are classified by source/target types of t; IF concepts map directly to CKML/OML constructs (classifications, infomorphisms, theories).</td>
                        </tr>
                        <tr>
                            <td><strong>supports_theory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>counter_evidence</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>citation</strong></td>
                            <td>Robert E. Kent (unknown year)</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Conceptual Knowledge Markup Language: An introduction', 'publication_date_yy_mm': '2000-06'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6894.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e6894.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of the representational format of conceptual knowledge in the brain at a functional level, including theoretical models, their descriptions, claimed representational formats, supporting or contradictory empirical evidence, experimental paradigms, key findings, and citation information.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>CKML / OML</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Conceptual Knowledge Markup Language (CKML) / Ontology Markup Language (OML)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An XML-based markup language and its ontology-subset designed to encode ontologies, conceptual graphs, formal contexts and concept lattices, supporting conceptual scaling, local logics and classification-projection semantics.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>theory_name</strong></td>
                            <td>CKML / OML as representational format</td>
                        </tr>
                        <tr>
                            <td><strong>theory_type</strong></td>
                            <td>symbolic / structured-XML ontology serialization</td>
                        </tr>
                        <tr>
                            <td><strong>theory_description</strong></td>
                            <td>CKML/OML encode conceptual knowledge constructs (types, instances, relations, theories, interpretations, sequents) so that abstract scales (theories), concrete scales (interpretations), and realized scales (local logics) can be represented and compositionally combined (e.g., apposition) to form faceted conceptual spaces.</td>
                        </tr>
                        <tr>
                            <td><strong>functional_claims</strong></td>
                            <td>Provides an interoperable, composable, machine-readable format to represent ontologies, formal contexts, concept lattices and conceptual scales; maps theoretical constructs (CG, IF, FCA) into XML elements enabling exchange and computation.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_source</strong></td>
                            <td>language specification, worked examples (Intel press releases), and formal correspondences</td>
                        </tr>
                        <tr>
                            <td><strong>experimental_paradigm</strong></td>
                            <td>applied data-structuring example (conceptual scaling of Intel press releases)</td>
                        </tr>
                        <tr>
                            <td><strong>key_result</strong></td>
                            <td>CKML encodes abstract/concrete/realized conceptual scales (theory/interpretation/local logic), expresses lattice constraints via sequents, supports reification and conceptual contexts, and interoperates with RDF/S, Ontolingua, CGIF and databases.</td>
                        </tr>
                        <tr>
                            <td><strong>supports_theory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>counter_evidence</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>citation</strong></td>
                            <td>Robert E. Kent (unknown year)</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Conceptual Knowledge Markup Language: An introduction', 'publication_date_yy_mm': '2000-06'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6894.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e6894.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of the representational format of conceptual knowledge in the brain at a functional level, including theoretical models, their descriptions, claimed representational formats, supporting or contradictory empirical evidence, experimental paradigms, key findings, and citation information.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Conceptual Scaling / Faceted Spaces</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Conceptual Scaling (faceted conceptual spaces)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A process that transforms ontologically structured metadata into faceted conceptual spaces by applying conceptual scales (facets) that produce realized scales (facets) for use in a concept lattice.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>theory_name</strong></td>
                            <td>Conceptual Scaling / Faceted Conceptual Spaces</td>
                        </tr>
                        <tr>
                            <td><strong>theory_type</strong></td>
                            <td>feature-faceted (vector of facets) / structured-lattice</td>
                        </tr>
                        <tr>
                            <td><strong>theory_description</strong></td>
                            <td>Each facet is computed by a conceptual scale (abstract, concrete, realized): abstract scales define attribute terms and constraints; concrete scales bind queries to terms respecting abstract constraints; realized scales are the facet concept spaces resulting from applying concrete scales to instances; the full conceptual space is the apposition (disjoint union) of facets.</td>
                        </tr>
                        <tr>
                            <td><strong>functional_claims</strong></td>
                            <td>Enables faceted, composable representations of multi-dimensional information; supports client customization, transparent composition of dimensions, and conversion from ontologies to conceptual lattices.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_source</strong></td>
                            <td>methodological description and applied example (Intel press releases)</td>
                        </tr>
                        <tr>
                            <td><strong>experimental_paradigm</strong></td>
                            <td>applied metadata scaling and apposition to generate faceted conceptual spaces</td>
                        </tr>
                        <tr>
                            <td><strong>key_result</strong></td>
                            <td>Demonstrated construction of a press-release conceptual space with four facets (type, date, reference, keyword) by applying concrete scales and apposing the resulting facets into a combined lattice.</td>
                        </tr>
                        <tr>
                            <td><strong>supports_theory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>counter_evidence</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>citation</strong></td>
                            <td>Robert E. Kent (unknown year)</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Conceptual Knowledge Markup Language: An introduction', 'publication_date_yy_mm': '2000-06'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6894.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e6894.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of the representational format of conceptual knowledge in the brain at a functional level, including theoretical models, their descriptions, claimed representational formats, supporting or contradictory empirical evidence, experimental paradigms, key findings, and citation information.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Classification-Projection Semantics</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Classification-Projection Semantics</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A semantic axiom linking instances of binary relations to their relation types such that the source/target instances are classified by the source/target types of the relation type; a foundational typing constraint in CKML/OML.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>theory_name</strong></td>
                            <td>Classification-Projection Semantics</td>
                        </tr>
                        <tr>
                            <td><strong>theory_type</strong></td>
                            <td>type-theoretic / categorical semantics</td>
                        </tr>
                        <tr>
                            <td><strong>theory_description</strong></td>
                            <td>Asserts that if a binary relational instance r is classified by relation type t, then the source and target instances of r must be classified by source and target types of t respectively; formalized within a category-inspired diagram and forms the backbone of mapping between RDF-like notions and CKML types.</td>
                        </tr>
                        <tr>
                            <td><strong>functional_claims</strong></td>
                            <td>Ensures type-soundness of relation instances, supports embedding of RDF/S semantics into CKML, and formalizes the relation between higher-order types and instances.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_source</strong></td>
                            <td>formal semantic specification</td>
                        </tr>
                        <tr>
                            <td><strong>experimental_paradigm</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>key_result</strong></td>
                            <td>Provides the core typing axiom used to relate binary relation instances and their type-level source/target constraints; clarifies correspondences to RDF/S constructs.</td>
                        </tr>
                        <tr>
                            <td><strong>supports_theory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>counter_evidence</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>citation</strong></td>
                            <td>Robert E. Kent (unknown year)</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Conceptual Knowledge Markup Language: An introduction', 'publication_date_yy_mm': '2000-06'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6894.6">
                <h3 class="extraction-instance">Extracted Data Instance 6 (e6894.6)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of the representational format of conceptual knowledge in the brain at a functional level, including theoretical models, their descriptions, claimed representational formats, supporting or contradictory empirical evidence, experimental paradigms, key findings, and citation information.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Reification vs Conceptual Contexts</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Reification and Conceptual Contexts (models for quotations/statements-about-statements)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Two representational alternatives: reification elevates relations to objects with participant functions, while conceptual contexts represent nested assertions (propositions) allowing propositions to be objects of other propositions without reifying relations.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>theory_name</strong></td>
                            <td>Reification vs Conceptual Contexts</td>
                        </tr>
                        <tr>
                            <td><strong>theory_type</strong></td>
                            <td>symbolic representation alternatives</td>
                        </tr>
                        <tr>
                            <td><strong>theory_description</strong></td>
                            <td>Reification transforms a relation into an object (with thematic participant functions) so it can be asserted about; conceptual contexts use nested assertion objects (propositions with description pointers) to represent statements about statements directly within the assertion/context machinery (preferred for quotations in CKML/OML).</td>
                        </tr>
                        <tr>
                            <td><strong>functional_claims</strong></td>
                            <td>Conceptual contexts better separate propositional content from meta-statements and avoid conflation that reification can cause; both approaches are supported but contexts give a cleaner mapping to conceptual graphs for quotations.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_source</strong></td>
                            <td>worked encoding examples (WWW quotation example) and language design argumentation</td>
                        </tr>
                        <tr>
                            <td><strong>experimental_paradigm</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>key_result</strong></td>
                            <td>OML/CKML supports both reification and conceptual contexts, with conceptual contexts recommended for modeling quotations because they avoid conflating propositional content and meta-statements and integrate with assertions.</td>
                        </tr>
                        <tr>
                            <td><strong>supports_theory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>counter_evidence</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>citation</strong></td>
                            <td>Robert E. Kent (unknown year)</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Conceptual Knowledge Markup Language: An introduction', 'publication_date_yy_mm': '2000-06'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e6894.7">
                <h3 class="extraction-instance">Extracted Data Instance 7 (e6894.7)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of the representational format of conceptual knowledge in the brain at a functional level, including theoretical models, their descriptions, claimed representational formats, supporting or contradictory empirical evidence, experimental paradigms, key findings, and citation information.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Scale Types Mapping</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Abstract / Concrete / Realized Scale Mapping (theory → interpretation → local logic)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A mapping from conceptual scale types to CKML elements: abstract scales (theory) define terms and constraints, concrete scales (interpretation) bind queries to terms, realized scales (local logic) are the applied facets.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>theory_name</strong></td>
                            <td>Abstract/Concrete/Realized Scale Mapping</td>
                        </tr>
                        <tr>
                            <td><strong>theory_type</strong></td>
                            <td>representational pipeline (symbolic → operational → extensional)</td>
                        </tr>
                        <tr>
                            <td><strong>theory_description</strong></td>
                            <td>Conceptual scaling works along an intentional-extensional axis: abstract scales introduce attribute terms and constraints (a theory), concrete scales implement those terms as queries or filters (an interpretation), and realized scales are the result of applying interpretations to instance collections producing local logics (facets).</td>
                        </tr>
                        <tr>
                            <td><strong>functional_claims</strong></td>
                            <td>Provides a principled workflow for converting ontological specifications into extensional facets ready for composition into a conceptual space; enforces consistency between term definitions and their data-level realizations.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_source</strong></td>
                            <td>methodological/formal specification and examples</td>
                        </tr>
                        <tr>
                            <td><strong>experimental_paradigm</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>key_result</strong></td>
                            <td>CKML maps abstract scales to <Theory>, concrete scales to <Interpretation>, and realized scales to local logic constructs; used in the Intel press-release example to realize facets.</td>
                        </tr>
                        <tr>
                            <td><strong>supports_theory</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>counter_evidence</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>citation</strong></td>
                            <td>Robert E. Kent (unknown year)</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Conceptual Knowledge Markup Language: An introduction', 'publication_date_yy_mm': '2000-06'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Information Flow: The Logic of Distributed Systems <em>(Rating: 2)</em></li>
                <li>Formal Concept Analysis: Mathematical Foundations <em>(Rating: 2)</em></li>
                <li>Conceptual Structures: Information Processing in Mind and Machine <em>(Rating: 2)</em></li>
                <li>A translation approach to portable ontology specifications <em>(Rating: 1)</em></li>
                <li>Colon Classification <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-6894",
    "paper_id": "paper-2ee00192a11fd13786f3a68df881a41de46a614d",
    "extraction_schema_id": "extraction-schema-133",
    "extracted_data": [
        {
            "name_short": "FCA / Concept Lattice",
            "name_full": "Formal Concept Analysis (Concept Lattice)",
            "brief_description": "A mathematical framework representing conceptual knowledge as a lattice of formal concepts, each concept defined by an extent (set of objects) and an intent (set of attributes); formal contexts (object-attribute incidence matrices) are equivalent to concept lattices.",
            "citation_title": "",
            "mention_or_use": "use",
            "theory_name": "Formal Concept Analysis / Concept Lattice",
            "theory_type": "relational network / lattice (symbolic-structural)",
            "theory_description": "Conceptual knowledge is represented as formal concepts (pairs of extents and intents) ordered in a lattice; objects label nodes downward (extent) and attributes label nodes upward (intent); the structure is derived from an object×attribute incidence relation (formal context).",
            "functional_claims": "Represents hierarchical relationships among concepts, supports transparent composition of content and type hierarchies, enables computation of joins/meets (generalization/specialization), and gives a principled faceted organization of information.",
            "evidence_source": "theoretical/formal demonstration and applied examples",
            "experimental_paradigm": null,
            "key_result": "Formal contexts (incidence matrices) and concept lattices are equivalent data structures; formal concepts correspond to maximal rectangles of 1s in the incidence matrix, and lattice operations compute specialization/generalization.",
            "supports_theory": true,
            "counter_evidence": null,
            "citation": "Robert E. Kent (unknown year)",
            "uuid": "e6894.0",
            "source_info": {
                "paper_title": "Conceptual Knowledge Markup Language: An introduction",
                "publication_date_yy_mm": "2000-06"
            }
        },
        {
            "name_short": "Conceptual Graphs (CG)",
            "name_full": "Conceptual Graphs",
            "brief_description": "A graph-based semantic representation using concepts (nodes) and conceptual relations (edges), supporting quantifiers, nested contexts, and assertions for complex propositions.",
            "citation_title": "",
            "mention_or_use": "use",
            "theory_name": "Conceptual Graphs",
            "theory_type": "symbolic relational graph",
            "theory_description": "Concepts and relations form graph structures that represent propositions; contextual nesting represents propositions-about-propositions; conceptual graphs provide a complete semantic model for assertions and contexts.",
            "functional_claims": "Allows representation of complex propositions (including nested assertions and quantification), supports mapping to logical formulas and use in ontology specification and conceptual scaling.",
            "evidence_source": "theoretical/formal correspondences and examples",
            "experimental_paradigm": null,
            "key_result": "OML/CKML corresponds closely to conceptual graphs; conceptual contexts in CG map to assertion/description mechanisms in OML allowing quotations (statements about statements) without reification.",
            "supports_theory": true,
            "counter_evidence": null,
            "citation": "Robert E. Kent (unknown year)",
            "uuid": "e6894.1",
            "source_info": {
                "paper_title": "Conceptual Knowledge Markup Language: An introduction",
                "publication_date_yy_mm": "2000-06"
            }
        },
        {
            "name_short": "Information Flow (IF)",
            "name_full": "Barwise & Seligman's Information Flow (classification and infomorphisms)",
            "brief_description": "A formal theory of distributed systems and information that models classifications (formal contexts), infomorphisms (structure-preserving mappings between classifications), theories and interpretations.",
            "citation_title": "",
            "mention_or_use": "use",
            "theory_name": "Information Flow",
            "theory_type": "relational/ categorical / mapping-based formalism",
            "theory_description": "Conceptual knowledge is modeled as classifications (instances typed by types) with infomorphisms and theory/interpretation mappings capturing information channels and translations between ontologies; local logics represent realized scales.",
            "functional_claims": "Supports principled interoperability between different communities' information structures, formalizes how types and instances relate across mappings, and underlies conceptual scaling and apposition operations.",
            "evidence_source": "formal theory and mappings (mathematical)",
            "experimental_paradigm": null,
            "key_result": "The classification-projection semantics asserts that if a relation instance r is classified by relation type t, then source/target instances are classified by source/target types of t; IF concepts map directly to CKML/OML constructs (classifications, infomorphisms, theories).",
            "supports_theory": true,
            "counter_evidence": null,
            "citation": "Robert E. Kent (unknown year)",
            "uuid": "e6894.2",
            "source_info": {
                "paper_title": "Conceptual Knowledge Markup Language: An introduction",
                "publication_date_yy_mm": "2000-06"
            }
        },
        {
            "name_short": "CKML / OML",
            "name_full": "Conceptual Knowledge Markup Language (CKML) / Ontology Markup Language (OML)",
            "brief_description": "An XML-based markup language and its ontology-subset designed to encode ontologies, conceptual graphs, formal contexts and concept lattices, supporting conceptual scaling, local logics and classification-projection semantics.",
            "citation_title": "here",
            "mention_or_use": "use",
            "theory_name": "CKML / OML as representational format",
            "theory_type": "symbolic / structured-XML ontology serialization",
            "theory_description": "CKML/OML encode conceptual knowledge constructs (types, instances, relations, theories, interpretations, sequents) so that abstract scales (theories), concrete scales (interpretations), and realized scales (local logics) can be represented and compositionally combined (e.g., apposition) to form faceted conceptual spaces.",
            "functional_claims": "Provides an interoperable, composable, machine-readable format to represent ontologies, formal contexts, concept lattices and conceptual scales; maps theoretical constructs (CG, IF, FCA) into XML elements enabling exchange and computation.",
            "evidence_source": "language specification, worked examples (Intel press releases), and formal correspondences",
            "experimental_paradigm": "applied data-structuring example (conceptual scaling of Intel press releases)",
            "key_result": "CKML encodes abstract/concrete/realized conceptual scales (theory/interpretation/local logic), expresses lattice constraints via sequents, supports reification and conceptual contexts, and interoperates with RDF/S, Ontolingua, CGIF and databases.",
            "supports_theory": true,
            "counter_evidence": null,
            "citation": "Robert E. Kent (unknown year)",
            "uuid": "e6894.3",
            "source_info": {
                "paper_title": "Conceptual Knowledge Markup Language: An introduction",
                "publication_date_yy_mm": "2000-06"
            }
        },
        {
            "name_short": "Conceptual Scaling / Faceted Spaces",
            "name_full": "Conceptual Scaling (faceted conceptual spaces)",
            "brief_description": "A process that transforms ontologically structured metadata into faceted conceptual spaces by applying conceptual scales (facets) that produce realized scales (facets) for use in a concept lattice.",
            "citation_title": "",
            "mention_or_use": "use",
            "theory_name": "Conceptual Scaling / Faceted Conceptual Spaces",
            "theory_type": "feature-faceted (vector of facets) / structured-lattice",
            "theory_description": "Each facet is computed by a conceptual scale (abstract, concrete, realized): abstract scales define attribute terms and constraints; concrete scales bind queries to terms respecting abstract constraints; realized scales are the facet concept spaces resulting from applying concrete scales to instances; the full conceptual space is the apposition (disjoint union) of facets.",
            "functional_claims": "Enables faceted, composable representations of multi-dimensional information; supports client customization, transparent composition of dimensions, and conversion from ontologies to conceptual lattices.",
            "evidence_source": "methodological description and applied example (Intel press releases)",
            "experimental_paradigm": "applied metadata scaling and apposition to generate faceted conceptual spaces",
            "key_result": "Demonstrated construction of a press-release conceptual space with four facets (type, date, reference, keyword) by applying concrete scales and apposing the resulting facets into a combined lattice.",
            "supports_theory": true,
            "counter_evidence": null,
            "citation": "Robert E. Kent (unknown year)",
            "uuid": "e6894.4",
            "source_info": {
                "paper_title": "Conceptual Knowledge Markup Language: An introduction",
                "publication_date_yy_mm": "2000-06"
            }
        },
        {
            "name_short": "Classification-Projection Semantics",
            "name_full": "Classification-Projection Semantics",
            "brief_description": "A semantic axiom linking instances of binary relations to their relation types such that the source/target instances are classified by the source/target types of the relation type; a foundational typing constraint in CKML/OML.",
            "citation_title": "",
            "mention_or_use": "use",
            "theory_name": "Classification-Projection Semantics",
            "theory_type": "type-theoretic / categorical semantics",
            "theory_description": "Asserts that if a binary relational instance r is classified by relation type t, then the source and target instances of r must be classified by source and target types of t respectively; formalized within a category-inspired diagram and forms the backbone of mapping between RDF-like notions and CKML types.",
            "functional_claims": "Ensures type-soundness of relation instances, supports embedding of RDF/S semantics into CKML, and formalizes the relation between higher-order types and instances.",
            "evidence_source": "formal semantic specification",
            "experimental_paradigm": null,
            "key_result": "Provides the core typing axiom used to relate binary relation instances and their type-level source/target constraints; clarifies correspondences to RDF/S constructs.",
            "supports_theory": true,
            "counter_evidence": null,
            "citation": "Robert E. Kent (unknown year)",
            "uuid": "e6894.5",
            "source_info": {
                "paper_title": "Conceptual Knowledge Markup Language: An introduction",
                "publication_date_yy_mm": "2000-06"
            }
        },
        {
            "name_short": "Reification vs Conceptual Contexts",
            "name_full": "Reification and Conceptual Contexts (models for quotations/statements-about-statements)",
            "brief_description": "Two representational alternatives: reification elevates relations to objects with participant functions, while conceptual contexts represent nested assertions (propositions) allowing propositions to be objects of other propositions without reifying relations.",
            "citation_title": "",
            "mention_or_use": "use",
            "theory_name": "Reification vs Conceptual Contexts",
            "theory_type": "symbolic representation alternatives",
            "theory_description": "Reification transforms a relation into an object (with thematic participant functions) so it can be asserted about; conceptual contexts use nested assertion objects (propositions with description pointers) to represent statements about statements directly within the assertion/context machinery (preferred for quotations in CKML/OML).",
            "functional_claims": "Conceptual contexts better separate propositional content from meta-statements and avoid conflation that reification can cause; both approaches are supported but contexts give a cleaner mapping to conceptual graphs for quotations.",
            "evidence_source": "worked encoding examples (WWW quotation example) and language design argumentation",
            "experimental_paradigm": null,
            "key_result": "OML/CKML supports both reification and conceptual contexts, with conceptual contexts recommended for modeling quotations because they avoid conflating propositional content and meta-statements and integrate with assertions.",
            "supports_theory": true,
            "counter_evidence": null,
            "citation": "Robert E. Kent (unknown year)",
            "uuid": "e6894.6",
            "source_info": {
                "paper_title": "Conceptual Knowledge Markup Language: An introduction",
                "publication_date_yy_mm": "2000-06"
            }
        },
        {
            "name_short": "Scale Types Mapping",
            "name_full": "Abstract / Concrete / Realized Scale Mapping (theory → interpretation → local logic)",
            "brief_description": "A mapping from conceptual scale types to CKML elements: abstract scales (theory) define terms and constraints, concrete scales (interpretation) bind queries to terms, realized scales (local logic) are the applied facets.",
            "citation_title": "",
            "mention_or_use": "use",
            "theory_name": "Abstract/Concrete/Realized Scale Mapping",
            "theory_type": "representational pipeline (symbolic → operational → extensional)",
            "theory_description": "Conceptual scaling works along an intentional-extensional axis: abstract scales introduce attribute terms and constraints (a theory), concrete scales implement those terms as queries or filters (an interpretation), and realized scales are the result of applying interpretations to instance collections producing local logics (facets).",
            "functional_claims": "Provides a principled workflow for converting ontological specifications into extensional facets ready for composition into a conceptual space; enforces consistency between term definitions and their data-level realizations.",
            "evidence_source": "methodological/formal specification and examples",
            "experimental_paradigm": null,
            "key_result": "CKML maps abstract scales to &lt;Theory&gt;, concrete scales to &lt;Interpretation&gt;, and realized scales to local logic constructs; used in the Intel press-release example to realize facets.",
            "supports_theory": true,
            "counter_evidence": null,
            "citation": "Robert E. Kent (unknown year)",
            "uuid": "e6894.7",
            "source_info": {
                "paper_title": "Conceptual Knowledge Markup Language: An introduction",
                "publication_date_yy_mm": "2000-06"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Information Flow: The Logic of Distributed Systems",
            "rating": 2,
            "sanitized_title": "information_flow_the_logic_of_distributed_systems"
        },
        {
            "paper_title": "Formal Concept Analysis: Mathematical Foundations",
            "rating": 2,
            "sanitized_title": "formal_concept_analysis_mathematical_foundations"
        },
        {
            "paper_title": "Conceptual Structures: Information Processing in Mind and Machine",
            "rating": 2,
            "sanitized_title": "conceptual_structures_information_processing_in_mind_and_machine"
        },
        {
            "paper_title": "A translation approach to portable ontology specifications",
            "rating": 1,
            "sanitized_title": "a_translation_approach_to_portable_ontology_specifications"
        },
        {
            "paper_title": "Colon Classification",
            "rating": 1,
            "sanitized_title": "colon_classification"
        }
    ],
    "cost": 0.012360499999999998,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Conceptual Knowledge Markup Language: An Introduction</h1>
<p>Robert E. Kent<br>School of EECS<br>Washington State University</p>
<h4>Abstract</h4>
<p>Conceptual Knowledge Markup Language (CKML) is an application of XML. Earlier versions of CKML followed rather exclusively the philosophy of Conceptual Knowledge Processing (CKP), a principled approach to knowledge representation and data analysis that "advocates methods and instruments of conceptual knowledge processing which support people in their rational thinking, judgment and acting and promote critical discussion." The new version of CKML continues to follow this approach, but also incorporates various principles, insights and techniques from Information Flow (IF), the logical design of distributed systems. Among other things, this allows diverse communities of discourse to compare their own information structures, as coded in logical theories, with that of other communities that share a common generic ontology. CKML incorporates the CKP ideas of concept lattice and formal context, along with the IF ideas of classification (= formal context), infomorphism, theory, interpretation and local logic. Ontology Markup Language (OML), a subset of CKML that is a self-sufficient markup language in its own right, follows the principles and ideas of Conceptual Graphs (CG). OML is used for structuring the specifications and axiomatics of metadata into ontologies. OML incorporates the CG ideas of concept, conceptual relation, conceptual graph, conceptual context, participants and ontology. The link from OML to CKML is the process of conceptual scaling, which is the interpretive transformation of ontologically structured knowledge to conceptual structured knowledge.</p>
<h2>Keywords</h2>
<p>ontology, concept lattice, conceptual scaling, theory, interpretation, classification, logic, interoperability</p>
<h2>Diagram 1: OML/CKML Architecture</h2>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<h2>Introduction</h2>
<p>Conceptual Knowledge Markup Language (CKML) provides a specification standard for the conceptual representation and analysis of networked resources. Although hypertext links enable organization in the small, resource discovery systems, using content-based access to documents,</p>
<p>enable organization in the large [2]. Content-based access requires a good representation for document content and the natural hierarchies associated with documents and related entities [5]. Ideally, such document content and natural hierarchies would be transparently composable. Concept lattices allow such transparent composability by representing both content and entity type hierarchies as facets of document information.</p>
<p>A concept lattice is a lattice with bound objects and attributes. Any arbitrary lattice is a concept lattice, where the objects and attributes bound to it are defined mathematically - they are the atomic (irreducible) elements with respect to joins and meets. Object-attribute incidence relations, called formal contexts (CKP) or classifications (IF), and concept lattices are equivalent structures. Either provides for the conceptual representation of networked resources. When applying conceptual knowledge processing to networked resources, objects are represented as abstracted ontologically structured metadata and attributes are defined by logical queries. The process of conceptual scaling constructs concept lattices, and their equivalent formal contexts. Conceptual scaling transforms ontologically structured collections of objects to faceted conceptual space by applying conceptual scales. Figure 1 illustrates conversion of the intuition behind the ontological knowledge model into the formalism of CKML.</p>
<p>Figure 1: From Ontological Intuition to Conceptual Formalism
<img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>The goal of this paper is to introduce the reader to CKML. The first section on the CKML knowledge model covers the semantics of CKML. The discussion of semantics ranges over ontologies and conceptual knowledge processing. Illustrative examples also introduce the syntax of CKML. In the second section the pragmatics of CKML is made with a real world example the online press releases of Intel Corporation. The third section on CKML interoperability is an argument for the position that CKML provides a generic solution for structuring online information. The final section discusses a recent and extensive evaluation of the CKML language for use as an interchange language in the life sciences community.</p>
<h1>The CKML Knowledge Model</h1>
<h2>OML/CKML AT A GLANCE</h2>
<p>As justified by the following points, CKML is in various senses both a description logic based language and a frame-based language.</p>
<ul>
<li>CKML: Being based upon conceptual graphs, formal concept analysis, and information flow, the CKML extension of OML is closely related to a description logic based approach for modeling ontologies. Conceptual scaling and concept lattice algorithms correspond to subsumption.</li>
<li>OML: How and how well a knowledge representation language expresses constraints is a very important issue. OML has three levels for constraint expression:</li>
<li>top - sequents</li>
<li>intermediate - calculus of binary relations</li>
<li>bottom - logical expressions</li>
</ul>
<p>The top level models the theory constraints of information flow, the middle level arises both from the practical importance of binary relation constraints and the category theory orientation to the classification-projection semantics of Diagram 3, and the bottom level corresponds to conceptual graphs. Indeed, OML assertions (closed expressions) correspond exactly to conceptual graphs.</p>
<ul>
<li>Simple OML: The semantic core of CKML is captured in a subset of OML called Simple OML. Because Simple OML is based upon the fundamental classification-projection semantics of Diagram 3, the normal expression of types and instances is very frame-like. A core aspect of Open Knowledge Base Connectivity (OKBC) is closely related to Simple OML.</li>
</ul>
<h2>ONTOLOGIES</h2>
<p>Ontologies provide a knowledge model for expressing the structured metadata of both concrete and abstract distributed objects. They have proven to be an excellent basis on which to build facilities for conceptual knowledge processing. As such, the ontology-based knowledge models are well suited to the goal of CKML to provide a foundational framework for the specification of conceptual knowledge. In facet, ontologically structured information has been used as a challenge to OML/CKML during its continuing development. This includes ontologies for: corporations, movies, television, gene function in molecular biology, medical informatics, etc. Most of these are accessible through the links at the site ontologos.org.
The notion of ontology is widely used in the fields of knowledge representation and artificial intelligence. The notion of ontology used in OML/CKML closely follows Gruber's definition that "an ontology is an explicit specification of a conceptualization." In CKML the conceptualization being specified is the mathematical notion of a concept lattice or the more practical notion of a conceptual space. An ontological specification consists of a set of entities structured a taxonomic hierarchy of types, relationships between those entities, and appropriate semantic constraints involving those entities and relationships. The taxonomic hierarchy is a key feature of an ontology. As Luke [7] asserts, "The ability to establish relationships is important, but secondary to the ability to classify those entities." The important conceptual scaling link from OML to CKML converts both static taxonomic information and ontological relational information to the dynamic hierarchical structure of the concept lattice.</p>
<h2>CONCEPTUAL KNOWLEDGE REPRESENTATION</h2>
<p>The purpose for CKML is to provide a mechanism whereby people can conceptually organized their information. This conceptual approach to information organization is based upon certain principles and ideas from conceptual knowledge processing. The central structuring methodology in conceptual knowledge processing, called a concept lattice [11], is a lattice with objects and</p>
<h1>Figure 2: Fundamental Theorem of CKP</h1>
<p>attributes bound to its atomic (join or meet irreducible) elements. Elements of the concept lattice, which can be multiply labeled with objects or attributes, are called formal concepts.</p>
<p>Any formal concept is identified with the collection of objects below it in the lattice called its extent, and the collection of attributes above it called its intent. The intent of a formal concept contains exactly the attributes that are possessed by all objects in the
<img alt="img-2.jpeg" src="img-2.jpeg" />
extent, and vice-versa the extent of a formal concept contains exactly the objects that possess all the attributes in the intent. A concept $c_{l}$ is below another concept $c_{2}$ in the lattice when the extent of $c_{1}$ is contained in the extent of $c_{2}$, or dually the intent of $c_{1}$ contains the intent of $c_{2}$, indicating that $c_{1}$ is more specialized than $c_{2}$. We calculate the meet of two concepts by intersecting their extents (and then computing the resulting intent). Dually, we calculate the join of two concepts by intersecting their intents (and then computing the resulting extent).
Figure 2 illustrates the basic theorem of conceptual knowledge processing [11], that formal contexts (classifications) and concept lattices are equivalent data structures. The rectangular component in Figure 2 represents a formal context, whereas the diamond-shaped component represents a concept lattice. The central node within the concept lattice of Figure 2 represents an arbitrary formal concept. A formal context (or classification) is essentially an incidence relation (matrix) between a set of objects and a set of (single-valued) attributes. If we represent the fact "object $o$ in row $i$ has attribute $a$ in column $j$ " by a boolean " 1 " at entry $(i, j)$, with " 0 "s otherwise, then a formal concept in the associated concept lattice corresponds to a maximal rectangle of "1"s in the matrix (modulo change-of-basis permutations of either objects or attributes) with sides of the rectangle indexed by extent and intent.</p>
<h2>Example: The Living Concept Space</h2>
<p>The "living" concept space is a tiny dataset, which exists within a conceptual universe of living organisms. This space consists of eight organisms (plants and animals), and nine of their properties. The organisms are the objects of the space, and the properties are the attributes.</p>
<p>Objects</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Le</th>
<th style="text-align: left;">Leech</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Br</td>
<td style="text-align: left;">Bream</td>
</tr>
<tr>
<td style="text-align: left;">Fr</td>
<td style="text-align: left;">Frog</td>
</tr>
<tr>
<td style="text-align: left;">Dg</td>
<td style="text-align: left;">Dog</td>
</tr>
<tr>
<td style="text-align: left;">SW</td>
<td style="text-align: left;">Spike-Weed</td>
</tr>
<tr>
<td style="text-align: left;">Rd</td>
<td style="text-align: left;">Reed</td>
</tr>
<tr>
<td style="text-align: left;">Bn</td>
<td style="text-align: left;">Bean</td>
</tr>
<tr>
<td style="text-align: left;">Ma</td>
<td style="text-align: left;">Maize</td>
</tr>
</tbody>
</table>
<h2>Attributes</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">nw</th>
<th style="text-align: left;">needs water</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">lw</td>
<td style="text-align: left;">lives in water</td>
</tr>
<tr>
<td style="text-align: left;">ll</td>
<td style="text-align: left;">lives on land</td>
</tr>
<tr>
<td style="text-align: left;">nc</td>
<td style="text-align: left;">needs chlorophyll</td>
</tr>
<tr>
<td style="text-align: left;">2lg</td>
<td style="text-align: left;">2 leaf germination</td>
</tr>
<tr>
<td style="text-align: left;">1lg</td>
<td style="text-align: left;">1 leaf germination</td>
</tr>
<tr>
<td style="text-align: left;">mo</td>
<td style="text-align: left;">is motile</td>
</tr>
<tr>
<td style="text-align: left;">lb</td>
<td style="text-align: left;">has limbs</td>
</tr>
<tr>
<td style="text-align: left;">sk</td>
<td style="text-align: left;">suckles young</td>
</tr>
</tbody>
</table>
<p>The living concept space is illustrated in Diagram 2. On the left is the classification (formal context) between objects and attributes. The attributes of conceptual knowledge processing correspond to the types of information flow. On the right is the concept lattice with 19 formal concepts.</p>
<h1>Diagram 2: The Living Concept Space</h1>
<h2>classification (formal context)</h2>
<p><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Two of those formal concepts, along with their type ordering in the lattice, are described below.
concept #9 = {(Reed, Maize}, {needs water, lives on land, needs chlorophyll, 1 leaf germination}}
concept #4 = {(Spike-Weed, Reed, Maize}, {needs water, needs chlorophyll, 1 leaf germination}}
concept #9 $\leq$ concept #4</p>
<p>The structure of a concept lattice can be specified with theory constraints. A theory constraint (sequent) is a pair of type sets $\Gamma \vdash \Delta$ with the meaning "the conjunction (and) of the types in $\Gamma$ implies the disjunction (or) of the types in $\Delta$." Theory constraints allow the specification of disjointness, subtype-supertype and covering relationships.</p>
<ul>
<li>disjoint concepts (types)</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;">traditional formalism</th>
<th style="text-align: center;">sequent notation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">$\mathrm{nc} \perp \mathrm{mo}$</td>
<td style="text-align: center;">$\mathrm{nc}, \mathrm{mo} \vdash$</td>
</tr>
<tr>
<td style="text-align: center;">$2 \lg \perp 1 \mathrm{~g}$</td>
<td style="text-align: center;">$2 \mathrm{~g}, 1 \mathrm{lg} \vdash$</td>
</tr>
</tbody>
</table>
<ul>
<li>subconcepts</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;">traditional formalism</th>
<th style="text-align: center;">sequent notation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">$\mathrm{sk} \leq \mathrm{lb} \leq \mathrm{mo}$</td>
<td style="text-align: center;">$\mathrm{sk} \vdash \mathrm{lb} \vdash \mathrm{mo}$</td>
</tr>
<tr>
<td style="text-align: center;">$1 \mathrm{lg} \leq \mathrm{nc}$</td>
<td style="text-align: center;">$1 \mathrm{lg} \vdash \mathrm{nc}$</td>
</tr>
<tr>
<td style="text-align: center;">any $\leq \mathrm{nw}$</td>
<td style="text-align: center;">any $\vdash \mathrm{nw}$</td>
</tr>
</tbody>
</table>
<ul>
<li>covers</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;">traditional formalism</th>
<th style="text-align: center;">sequent notation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">ll $\mid$ mo</td>
<td style="text-align: center;">$\vdash$ ll, mo</td>
</tr>
<tr>
<td style="text-align: center;">mo $\mid$ nc</td>
<td style="text-align: center;">$\vdash$ mo, nc</td>
</tr>
</tbody>
</table>
<p>The CKML expression for disjointness follows closely the sequent notation. The fact " 'Needs Chlorophyll' and 'Is Motile' are disjoint" (nc, mo $\vdash$ ) is expressed as follows.</p>
<div class="codehilite"><pre><span></span><code><span class="nt">&lt;sequent&gt;</span>
<span class="w">    </span><span class="nt">&lt;li</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;Needs Chlorophyll&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span><span class="nt">&lt;li</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;Is Motile&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;entails/&gt;</span>
<span class="nt">&lt;/sequent&gt;</span>
</code></pre></div>

<p>The CKML expression for the subtype-supertype relationship is naturally expressed. The fact that " 'Has Limbs' is a subtype of 'Is Motile' " is expressed as follows.
<subtype specific="Has Limbs" generic="Is Motile" />
Subtyping, disjointness and covering define partition. Partition is also naturally expressed in CKML. The fact that " The types 'Needs Chlorophyll' and 'Is Motile' partition the root type 'Needs Water' " is expressed in CKML as follows.</p>
<div class="codehilite"><pre><span></span><code><span class="nt">&lt;partition</span><span class="w"> </span><span class="na">genus=</span><span class="s">&quot;Needs Water&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;li</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;Needs Chlorophyll&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span><span class="nt">&lt;li</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;Is Motile&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/partition&gt;</span>
</code></pre></div>

<p>The sequent notation is primitive, and other notations such as subtype and partition can be expressed in terms of the sequent notation. For example, the partition above can be expressed in CKML sequent notation as follows. Obviously, partition is a good and meaningful abbreviation.</p>
<div class="codehilite"><pre><span></span><code><span class="nt">&lt;sequent&gt;&lt;li</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;Needs Chlorophyll&quot;</span><span class="nt">/&gt;&lt;entails/&gt;&lt;li</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;Needs Water&quot;</span><span class="nt">/&gt;&lt;/sequent&gt;</span>
<span class="nt">&lt;sequent&gt;&lt;li</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;Is Motile&quot;</span><span class="nt">/&gt;&lt;entails/&gt;&lt;li</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;Needs Water&quot;</span><span class="nt">/&gt;&lt;/sequent&gt;</span>
<span class="nt">&lt;sequent&gt;</span>
<span class="w">    </span><span class="nt">&lt;li</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;Needs Water&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;entails/&gt;</span>
<span class="w">    </span><span class="nt">&lt;li</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;Needs Chlorophyll&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span><span class="nt">&lt;li</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;Is Motile&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/sequent&gt;</span>
<span class="nt">&lt;sequent&gt;</span>
<span class="w">    </span><span class="nt">&lt;li</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;Needs Chlorophyll&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span><span class="nt">&lt;li</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;Is Motile&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;entails/&gt;</span>
<span class="nt">&lt;/sequent&gt;</span>
</code></pre></div>

<p>New terminology can be introduced with type definitions. Named formal concepts are called conceptual views. Conceptual views are type definitions that are restricted to the lattice operations of meet and join. In general, conceptual knowledge is represented by: (1) the three partially ordered sets of objects, attributes and views; (2) the membership or instantiation relation between objects and views whose columns record the extent of all the conceptual views; (3) the abstraction relation between views and attributes whose rows record the intent of all the conceptual views; and (4) the incidence (classification) relation between objects and attributes. This aggregate of conceptual knowledge is represented by the notion of a concept space.</p>
<h1>THE PROCESS OF CONCEPTUAL SCALING</h1>
<p>The application of facets in the theory of library classification was first tested and developed by Ranganathan in his Colon classification system. Recognizing that a classification had to be able to grow organically, in order to keep up with an always-expanding growth in knowledge, the</p>
<p>Colon classification system breaks knowledge down into broad classes, which are further subdivided into single dimensions of information called "facets." Faceted analysis and classification provides a flexible means to classify complex, multi-concept subjects [9]. Complex subjects are divided into their component, single-concept subjects. Single-concept subjects are called isolates. Faceted analysis examines the literature of an area of knowledge and identifies its isolates. A facet is the sum total of isolates formed by the division of a subject by one characteristic of division. Some examples of facets in musical literature are: composer, instrument, form, etc. Isolates within facets are known as foci.</p>
<p>Comparing these ideas to ontologically structured metadata, facets are identified with conceptual scales or linguistic variables and are often associated with a composite description function, and isolate/foci are identified with scale attributes or linguistic values. A composite description function in the ontology may consist of one function with primitive image values, or a binary relation connecting two types of objects composable with such a function, or something more complex. In conceptual knowledge processing each facet is computed by a conceptual scale. A conceptual scale is an active filter or lens through which information is interpreted. Faceted analysis is conceptual scaling. It involves four steps.</p>
<ol>
<li>Gather ontologically structured metadata.</li>
<li>Identify conceptual scales of interest and specify attributes within them (abstract conceptual scale).</li>
<li>Specify the structure of conceptual scales (concrete conceptual scale).</li>
<li>Apply the conceptual scales to the metadata, producing a composable vector of facets (realized conceptual scales) that constitutes the conceptual space.</li>
</ol>
<p>The operation of apposition [11], as illustrated by the Intel Press Release conceptual space in Figure 4, combines concept lattices or formal contexts, which share a common collection of objects. This is a pasting or gluing operation with respect to formal contexts: just line up their matrices left to right using a disjoint union of the attribute sets. Apposition is used in conceptual scaling in order to combine dimensions of data. This is the basis for the faceted structure of conceptual space.</p>
<p>Figure 3: Conceptual Scaling
<img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Conceptual knowledge processing is a principled approach to the organization of knowledge. Use of previously developed ideas and techniques, such as apposition and conceptual scaling, offer a decided advantage over more ad hoc approaches for conceptualizing information. Conceptual scaling potentially allows for client-side customization of the organization, and apposition enables transparent composition of content and structure. Conceptual scales are structured by type, kind and method. As depicted in Figure 3, the languages OML and its extension CKML are distinguished by and connected through the process of conceptual scaling.</p>
<h1>Types of Conceptual Scales</h1>
<p>The three types of conceptual scales are: abstract, concrete and realized. These types are arrayed along an intentional-extensional dimension. Abstract conceptual scales introduce terms (attribute names), and abstractly specify attribute definitions via term-to-term relationships, as structured by a concept lattice. This lattice is defined, specifically by a set of term implications and term disjointnesses, and generically by propositional sequents. Concrete conceptual scales attach meaning and provide definition to the terms in abstract scales by binding a (single-variable) query to each term. These queries are required to respect the abstract term relationships (implications and disjointnesses). Concrete conceptual scales are conceptual filters or lenses. When applied to a collection of objects (ontologically structured metadata), concrete conceptual scales produce facets, which are known in conceptual knowledge processing as realized scales. Each facet is a concept space representing a single dimension of the metadata. A faceted conceptual space is a vector of facets, and conversely, facets are the components that underlie a faceted conceptual space.</p>
<p>Table 1: Representations for Types of Conceptual Scales</p>
<table>
<thead>
<tr>
<th style="text-align: left;">CKP Scale Type</th>
<th style="text-align: left;">CKML Element</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">abstract Scale</td>
<td style="text-align: left;">theory</td>
</tr>
<tr>
<td style="text-align: left;">concrete Scale</td>
<td style="text-align: left;">interpretation</td>
</tr>
<tr>
<td style="text-align: left;">realized Scale</td>
<td style="text-align: left;">local logic</td>
</tr>
</tbody>
</table>
<h2>Kinds of Conceptual Scales</h2>
<p>The process of conceptual scaling is of several kinds [3,6,8]: nominal, ordinal, hierarchical, etc. The most common kinds are "nominal" and "ordinal". Nominal scaling refers to names that are members of an unordered set, whereas ordinal scaling refers to subranges of a totally ordered set. Conceptual scaling kind is concentrated in the arguments of the various relations that are associated with the scale. Table 1 describes the various kinds of conceptual scales according to mathematical structure and purpose or use [3]. Mathematical types of scales represent intuitive ideas of design.</p>
<p>Table 2: Kinds of Conceptual Scales</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Kind</th>
<th style="text-align: left;">Mathematical Structure</th>
<th style="text-align: left;">Purpose/Use</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">nominal</td>
<td style="text-align: left;">set</td>
<td style="text-align: left;">partition/separateness</td>
</tr>
<tr>
<td style="text-align: left;">ordinal</td>
<td style="text-align: left;">(often total) order</td>
<td style="text-align: left;">ranking</td>
</tr>
<tr>
<td style="text-align: left;">interordinal</td>
<td style="text-align: left;">partial order of intervals</td>
<td style="text-align: left;">betweenness</td>
</tr>
<tr>
<td style="text-align: left;">hierarchical</td>
<td style="text-align: left;">tree structure</td>
<td style="text-align: left;">nesting</td>
</tr>
<tr>
<td style="text-align: left;">metrical</td>
<td style="text-align: left;">generalized metric space</td>
<td style="text-align: left;">similarity</td>
</tr>
</tbody>
</table>
<h2>Methods of Conceptual Scaling</h2>
<p>From the practice of conceptual scaling come several methods of conceptual scaling. These pragmatic methods are closely, but not completely, related to the mathematical structure. They are based primarily upon pragmatic considerations in the practice of conceptual scaling.</p>
<ul>
<li>Direct Scaling: The scales involved are always realized conceptual scales (facets), and usually are part of the specification of a specific ontology, either a theory [1] in that ontology or a collection (of</li>
</ul>
<p>attributes) controlled by that ontology. They are manifested as binary ontological relation instances, whose first argument is a particular instance (object) of a category (object type) in the generic ontology being specified, and whose second argument is a value in a controlled vocabulary. Examples include: the genre relation for movies, the keyword relation for press releases, etc. Elements of Dublin Core fit here.</p>
<ul>
<li>Simple Scaling: This is the classic method of conceptual scaling. Here two ingredients combine to form the state descriptions (rows) of the classification tables: a previously specified domain conceptual scale, either for a datatype or a controlled vocabulary; and a description function from an ontological category to this domain scale. The description function corresponds to a column in a database table. This can be the participant part of the bottom-up relational scaling discussed below. Examples include: time period scaled ordinally or interordinally, person's age scale, etc. Equivalence scaling is a special case.</li>
<li>Relational Scaling: Ontological relations and finite information channels are intimately involved with each other. On the one hand, underlying each finite information channel</li>
</ul>
<p>$$
\mathrm{C}=\left{f_{i}: A_{i} \rightarrow C\right}_{i \in I}
$$</p>
<p>where $I={1,2, \ldots, \mathrm{n}}$, is an ontological relation, whose relational type is the type set of the channel core, whose relational instances are the channel connections (tokens in the channel core), whose participants (argument domains) are the channel components, and whose argument functions are the token maps underlying the channel infomorphisms. On the other hand, any ontological relation</p>
<p>$$
R\left(A_{1}, A_{2}, \ldots, A_{n}\right)
$$</p>
<p>can be conceptually scaled by viewing it as an information channel.</p>
<h1>Example: Intel Press Releases</h1>
<p>Here an introduction to the pragmatics of CKML is made with a real world example - the online press releases of Intel Corporation. This example illustrates the process for conceptualizing information. Here we have gathered and extracted metadata for a series of around 500 press releases ranging over several years. This metadata has been conceptually scaled along four dimensions of information: object type hierarchy, release date order, reference and keyword. These four dimensions, called facets, are the building blocks for the press release conceptual space.
In order to promote good customer relations, many companies enhance their on-line presence with the addition of user interest profiles in either a push or pull modality. Intel has a facility in the pull mode called Custom News, which constructs user interest profiles. On request via a user's bookmark, by applying the user interest profile to Intel site information, a response is built in the form of a "personalized Intel news page." So far, a large part of the Custom News document space consists of Intel press releases.
Unfortunately, much as the Intel site in particular and most corporate sites in general, the structure of the user interest profile is a rather ad hoc affair. As a result, it will scale very poorly when a true Intel intranet is being constructed, and will scale even worse when extranets are being set up between the Intel intranet and other collaborating company intranets. The solution to this problem is to use a good conceptualization for both the Intel sites itself and the profile structure. The Intel conceptualization will be specified by an Intel ontology. When suitably conceptually scaled and view structured, the Intel ontology will become a faceted Intel press release conceptual space, and a user interest profile will be represented by a conceptual view definition.</p>
<p>The Intel press release concept space has four core facets: a object type facet as prescribed by the Intel pressroom archive, a release date facet related to release date and release age, a reference facet based upon the ontological reference relation which a robot produces, and a keyword facet also the result of the robot. Although the Intel ISA hierarchy provides an Intel-wide facet, we will not use this facet here (see the note below which discusses an explicit use of this facet), but instead will implicitly use the ISA hierarchy in the definition of standing queries with quantifiers. The full press release concept space will be composed as the apposition of these four individual facets. It has Intel press releases as its objects and the disjoint union (genus subtypes + release date types + Intel entities + keywords) as its attributes.</p>
<p>Figure 4: Press Release Faceted Conceptual Space</p>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">types</th>
<th style="text-align: center;">dates</th>
<th style="text-align: center;">references</th>
<th style="text-align: center;">keywords</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Genus Type <br> Facet</td>
<td style="text-align: center;">Release Date <br> Facet</td>
<td style="text-align: center;">References <br> Facet</td>
<td style="text-align: center;">Keyword <br> Facet</td>
</tr>
</tbody>
</table>
<h1>INSTANCE COLLECTIONS</h1>
<p>The Press Release object collection contains metadata for the nearly 500 online Intel press releases. The following markup displays one example of a Press Release object in detail - a press release about the "Infinite CD." In general, the genus category must be situated between the lowest categories within which the object declares membership and the top "Intel Entity" category.</p>
<div class="codehilite"><pre><span></span><code><span class="nt">&lt;Collection.Object</span><span class="w"> </span><span class="na">id =</span><span class="w"> </span><span class="s">&quot;intel-press-releases&quot;</span><span class="w"> </span><span class="na">genus=</span><span class="s">&quot;Press-Release&quot;</span>
<span class="w">    </span><span class="na">ontology =</span><span class="w"> </span><span class="s">&quot;http://www.intel.com/ontology/&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span>*<span class="w"> </span>*<span class="w"> </span>*
<span class="w">    </span><span class="nt">&lt;Press-Release</span><span class="w"> </span><span class="na">id =</span><span class="w"> </span><span class="s">&quot;cn022497&quot;</span>
<span class="w">        </span><span class="na">text =</span><span class="w"> </span><span class="s">&quot;Intel, Marimba And Macromedia To Create</span>
<span class="s">            Infinite CD For Public Broadcasting Service&quot;</span>
<span class="w">        </span><span class="na">about =</span><span class="w"> </span><span class="s">&quot;http://www.intel.com/pressroom/archive/releases/cn022497.htm&quot;</span>
<span class="w">        </span><span class="na">image =</span><span class="w"> </span><span class="s">&quot;infiniteCD.gif&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;comment&gt;</span>
<span class="w">            </span>An<span class="w"> </span>Intel<span class="w"> </span>Press<span class="w"> </span>Release:<span class="w"> </span>Technology<span class="w"> </span>will<span class="w"> </span>enable<span class="w"> </span>PBS<span class="w"> </span>ONLINE<span class="w"> </span>to<span class="w"> </span>deliver
<span class="w">            </span>Customized<span class="w"> </span>media-enhanced<span class="w"> </span>programming<span class="w"> </span>and<span class="w"> </span>products.
<span class="w">        </span><span class="nt">&lt;/comment&gt;</span>
<span class="w">        </span><span class="nt">&lt;classification</span><span class="w"> </span><span class="na">type =</span><span class="w"> </span><span class="s">&quot;Corporate News&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;city</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;San Francisco&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;state</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;California&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;date</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;1997/02/24&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;language</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;English&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;reference</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;Company#Intel&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;reference</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;Company#Marimba&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;reference</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;Company#Macromedia&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;reference</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;Company#PBS&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;reference</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;Person#&#39;John Hollar&#39;&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;reference</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;Person#&#39;Kim Polese&#39;&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;reference</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;Executive#&#39;Claude Leglise&#39;&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;reference</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;&#39;Web Site&#39;#&#39;Connected PC&#39;&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;reference</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;Product#Pentium&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;reference</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;Product#MMX&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;reference</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;Product#Intercast&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;keyword</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;Keyword#multimedia&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;keyword</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;Keyword#push&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;keyword</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;Keyword#cd-rom&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span><span class="nt">&lt;/Press-Release&gt;</span>
<span class="w">    </span>*<span class="w"> </span>*<span class="w"> </span>*<span class="w"> </span>*
<span class="nt">&lt;/Collection.Object&gt;</span>
</code></pre></div>

<h1>THEORIES</h1>
<p>The following CKML theories anchored at the Press Release type use only the most basic definition for conceptual scales. Object types defined by complex queries are not used here, although they could have been. The release date theory (conceptual scale) is a complete ordinal scale consisting of half-closed intervals. No closed intervals representing between-ness are used. As a result, the release date facet is a linear (total) order. The reference conceptual scale is partitioned into three subscales based upon subtypes of the root Intel Entity type: Executive, Product and Company. Each subscale is a complete nominal conceptual scale. As with all other conceptual spaces, the genus type facet is defined by the implicit hierarchical conceptual scale consisting of all object types at or below the Press Release type, the genus of the Press Release theory.</p>
<div class="codehilite"><pre><span></span><code><span class="nt">&lt;Theory</span><span class="w"> </span><span class="na">name =</span><span class="w"> </span><span class="s">&quot;Release Date&quot;</span><span class="w"> </span><span class="na">genus =</span><span class="w"> </span><span class="s">&quot;Press Release&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;Interpretation</span><span class="w"> </span><span class="na">name =</span><span class="w"> </span><span class="s">&quot;date ordinal&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;Foreach</span><span class="w"> </span><span class="na">var =</span><span class="w"> </span><span class="s">&quot;date&quot;</span><span class="w"> </span><span class="na">type =</span><span class="w"> </span><span class="s">&quot;Date&quot;</span><span class="nt">&gt;</span>
<span class="w">            </span><span class="nt">&lt;Where&gt;</span>
<span class="w">                </span><span class="nt">&lt;subrange</span><span class="w"> </span><span class="na">var =</span><span class="w"> </span><span class="s">&quot;date&quot;</span><span class="w"> </span><span class="na">begin =</span><span class="w"> </span><span class="s">&quot;1995/02/01&quot;</span><span class="w"> </span><span class="na">end =</span><span class="w"> </span><span class="s">&quot;1997/08/01&quot;</span><span class="nt">/&gt;</span>
<span class="w">            </span><span class="nt">&lt;/Where&gt;</span>
<span class="w">            </span><span class="nt">&lt;Object</span><span class="w"> </span><span class="na">var =</span><span class="w"> </span><span class="s">&quot;pr&quot;</span><span class="w"> </span><span class="na">type =</span><span class="w"> </span><span class="s">&quot;Press Release&quot;</span><span class="nt">&gt;</span>
<span class="w">                </span><span class="nt">&lt;comment&gt;</span>
<span class="w">                    </span>This<span class="w"> </span>press<span class="w"> </span>release<span class="w"> </span>was<span class="w"> </span>released<span class="w"> </span>on<span class="w"> </span>or<span class="w"> </span>after<span class="w"> </span>the<span class="w"> </span>specific<span class="w"> </span>date.
<span class="w">                </span><span class="nt">&lt;/comment&gt;</span>
<span class="w">            </span><span class="nt">&lt;date</span><span class="w"> </span><span class="na">order =</span><span class="w"> </span><span class="s">&quot;geq&quot;</span><span class="w"> </span><span class="na">source.Instance =</span><span class="w"> </span><span class="s">&quot;pr&quot;</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;date&quot;</span><span class="nt">/&gt;</span>
<span class="w">            </span><span class="nt">&lt;/Object&gt;</span>
<span class="w">        </span><span class="nt">&lt;/Foreach&gt;</span>
<span class="w">    </span><span class="nt">&lt;/Interpretation&gt;</span>
<span class="nt">&lt;/Theory&gt;</span>
<span class="nt">&lt;Theory</span><span class="w"> </span><span class="na">name =</span><span class="w"> </span><span class="s">&quot;Reference&quot;</span><span class="w"> </span><span class="na">genus =</span><span class="w"> </span><span class="s">&quot;Press Release&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;Interpretation</span><span class="w"> </span><span class="na">name =</span><span class="w"> </span><span class="s">&quot;reference nominal&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;Foreach</span><span class="w"> </span><span class="na">var =</span><span class="w"> </span><span class="s">&quot;entity&quot;</span><span class="w"> </span><span class="na">type =</span><span class="w"> </span><span class="s">&quot;Executive&quot;</span><span class="nt">&gt;</span>
<span class="w">            </span><span class="nt">&lt;Object</span><span class="w"> </span><span class="na">var =</span><span class="w"> </span><span class="s">&quot;pr&quot;</span><span class="w"> </span><span class="na">type =</span><span class="w"> </span><span class="s">&quot;Press Release&quot;</span><span class="nt">&gt;</span>
<span class="w">                </span><span class="nt">&lt;comment&gt;</span>
<span class="w">                    </span>This<span class="w"> </span>press<span class="w"> </span>release<span class="w"> </span>references<span class="w"> </span>the<span class="w"> </span>specific<span class="w"> </span>executive.
<span class="w">                </span><span class="nt">&lt;/comment&gt;</span>
<span class="w">            </span><span class="nt">&lt;reference</span><span class="w"> </span><span class="na">source.Instance =</span><span class="w"> </span><span class="s">&quot;pr&quot;</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;entity&quot;</span><span class="nt">/&gt;</span>
<span class="w">            </span><span class="nt">&lt;/Object&gt;</span>
<span class="w">        </span><span class="nt">&lt;/Foreach&gt;</span>
<span class="w">    </span><span class="nt">&lt;Foreach</span><span class="w"> </span><span class="na">var =</span><span class="w"> </span><span class="s">&quot;entity&quot;</span><span class="w"> </span><span class="na">type =</span><span class="w"> </span><span class="s">&quot;Product&quot;</span><span class="nt">&gt;</span>
<span class="w">            </span><span class="nt">&lt;Object</span><span class="w"> </span><span class="na">var =</span><span class="w"> </span><span class="s">&quot;pr&quot;</span><span class="w"> </span><span class="na">type =</span><span class="w"> </span><span class="s">&quot;Press Release&quot;</span><span class="nt">&gt;</span>
<span class="w">                </span><span class="nt">&lt;comment&gt;</span>
<span class="w">                    </span>This<span class="w"> </span>press<span class="w"> </span>release<span class="w"> </span>references<span class="w"> </span>the<span class="w"> </span>specific<span class="w"> </span>executive.
<span class="w">                </span><span class="nt">&lt;/comment&gt;</span>
<span class="w">            </span><span class="nt">&lt;reference</span><span class="w"> </span><span class="na">source.Instance =</span><span class="w"> </span><span class="s">&quot;pr&quot;</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;entity&quot;</span><span class="nt">/&gt;</span>
<span class="w">            </span><span class="nt">&lt;/Object&gt;</span>
<span class="w">        </span><span class="nt">&lt;/Foreach&gt;</span>
<span class="w">    </span><span class="nt">&lt;Foreach</span><span class="w"> </span><span class="na">var =</span><span class="w"> </span><span class="s">&quot;entity&quot;</span><span class="w"> </span><span class="na">type =</span><span class="w"> </span><span class="s">&quot;Company&quot;</span><span class="nt">&gt;</span>
<span class="w">            </span><span class="nt">&lt;Object</span><span class="w"> </span><span class="na">var =</span><span class="w"> </span><span class="s">&quot;pr&quot;</span><span class="w"> </span><span class="na">type =</span><span class="w"> </span><span class="s">&quot;Press Release&quot;</span><span class="nt">&gt;</span>
<span class="w">                </span><span class="nt">&lt;comment&gt;</span>
<span class="w">                    </span>This<span class="w"> </span>press<span class="w"> </span>release<span class="w"> </span>references<span class="w"> </span>the<span class="w"> </span>specific<span class="w"> </span>executive.
<span class="w">                </span><span class="nt">&lt;/comment&gt;</span>
<span class="w">            </span><span class="nt">&lt;reference</span><span class="w"> </span><span class="na">source.Instance =</span><span class="w"> </span><span class="s">&quot;pr&quot;</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;entity&quot;</span><span class="nt">/&gt;</span>
<span class="w">            </span><span class="nt">&lt;/Object&gt;</span>
<span class="w">        </span><span class="nt">&lt;/Foreach&gt;</span>
<span class="w">    </span><span class="nt">&lt;/Interpretation&gt;</span>
<span class="nt">&lt;/Theory&gt;</span>
<span class="nt">&lt;Theory</span><span class="w"> </span><span class="na">name =</span><span class="w"> </span><span class="s">&quot;Keyword&quot;</span><span class="w"> </span><span class="na">genus =</span><span class="w"> </span><span class="s">&quot;Press Release&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;Interpretation</span><span class="w"> </span><span class="na">name =</span><span class="w"> </span><span class="s">&quot;reference nominal&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;Foreach</span><span class="w"> </span><span class="na">var =</span><span class="w"> </span><span class="s">&quot;keyword&quot;</span><span class="w"> </span><span class="na">type =</span><span class="w"> </span><span class="s">&quot;Keyword&quot;</span><span class="nt">&gt;</span>
<span class="w">            </span><span class="nt">&lt;Object</span><span class="w"> </span><span class="na">var =</span><span class="w"> </span><span class="s">&quot;pr&quot;</span><span class="w"> </span><span class="na">type =</span><span class="w"> </span><span class="s">&quot;Press Release&quot;</span><span class="nt">&gt;</span>
<span class="w">                </span><span class="nt">&lt;comment&gt;</span>
<span class="w">                    </span>This<span class="w"> </span>press<span class="w"> </span>release<span class="w"> </span>uses<span class="w"> </span>the<span class="w"> </span>specific<span class="w"> </span>keyword.
<span class="w">                </span><span class="nt">&lt;/comment&gt;</span>
<span class="w">            </span><span class="nt">&lt;reference</span><span class="w"> </span><span class="na">source.Instance =</span><span class="w"> </span><span class="s">&quot;pr&quot;</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;keyword&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>

<h1>Interoperability with CKML</h1>
<p>Interoperability is very important for a language whose goal is to represent distributed information in a conceptual framework. The discussion in this section demonstrates how CKML is interoperable with many important alternative approaches touted as solutions to all or part of this goal: Resource Description Framework with Schemas (RDF/S), Ontolingua, conceptual graphs as codified in the Conceptual Graph Interchange Form (CGIF), and relational and objectoriented databases. Each of these is discussed in the following subsections.</p>
<h2>RESOURCE DESCRIPTION FRAMEWORK WITH SCHEMAS (RDF/S)</h2>
<p>RDF/Schemas has the structure of a semantic network. It corresponds to simple conceptual graphs [10], which are conceptual graphs without negations, universal quantifiers and nested conceptual contexts. To support metadata interoperability, the part of OML that corresponds to RDF with Schemas (expressions with no negations, implications, conceptual contexts, or universal quantifiers) will be demarcated as Simple OML.</p>
<p>At the core of Simple OML, OML and CKML is a classification-projection semantics. This classification-projection semantics, which is visualized in Diagram 3, asserts the axiom that "for any binary relational instance $r$ and binary relational type $t$, if $t$ is a binary relational type of $r$ then the source (target) type of $t$ is an entity type of the source (target) entity of $r$." Symbolically</p>
<p>$$
r \vDash t \text { implies both } \partial_{\emptyset}(r) \vDash \partial_{\emptyset}(t) \text { and } \partial_{1}(r) \vDash \partial_{1}(t)
$$</p>
<p>All type names in Diagram 3 denote higher order types (meta-types). The Entity type partitions</p>
<h2>Entity $=$ Object + Data</h2>
<p>into the Object type and the Data type. Here the plus denotes disjoint union or type sum. So data values are on a par with object instances, although of course less complex. The Data type includes all primitive types and enumerated types.</p>
<h2>Diagram 3: Classification Projection</h2>
<p><img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>The top subdiagram of Diagram 3 owes much to category theory and type theory. A category is defined to be a collection of objects and a collection of morphisms (arrows), which are connected by two functions called source (domain) and target (codomain). To complete the picture the composition and identity operators need to be added, along with suitable axioms. The partial orders on objects and arrows represent the type order on entities and binary relations. The bottom subdiagram extension gives a pointed version of category theory, a subject closely related to elementary topos theory. The classification relation connects the bottom subdiagram (instances) to the top subdiagram (types), and represents the classification relation of Barwise's Information Flow [1]. The shaded part of Diagram 3 corresponds to RDF without classes. Elements of this correspondence are listed in Table 3. The question mark in Table 3 reflects the current undeveloped state of RDF/S data types. These are being developed by the XML Schema working group of the W3C, and will be incorporated into CKML when finalized.</p>
<p>Table 3: RDF/S and Simple OML Correspondences</p>
<table>
<thead>
<tr>
<th style="text-align: left;">RDF/S <br> notion</th>
<th style="text-align: left;">Simple OML <br> notion</th>
<th style="text-align: left;">formalism</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">class</td>
<td style="text-align: left;">object type</td>
<td style="text-align: left;">type(Object)</td>
</tr>
<tr>
<td style="text-align: left;">????</td>
<td style="text-align: left;">data type</td>
<td style="text-align: left;">type(Data)</td>
</tr>
<tr>
<td style="text-align: left;">property</td>
<td style="text-align: left;">binary relation type</td>
<td style="text-align: left;">type(BinaryRelation)</td>
</tr>
<tr>
<td style="text-align: left;">subClassOf</td>
<td style="text-align: left;">subtype on objects</td>
<td style="text-align: left;">$\vdash_{\text {Entity }}$</td>
</tr>
<tr>
<td style="text-align: left;">subPropertyOf</td>
<td style="text-align: left;">subtype on binary relations</td>
<td style="text-align: left;">$\vdash_{\text {BinaryRelation }}$</td>
</tr>
<tr>
<td style="text-align: left;">domain</td>
<td style="text-align: left;">type source</td>
<td style="text-align: left;">type(source) $=\partial_{0}$</td>
</tr>
<tr>
<td style="text-align: left;">range</td>
<td style="text-align: left;">type target</td>
<td style="text-align: left;">type(target) $=\partial_{1}$</td>
</tr>
<tr>
<td style="text-align: left;">resource</td>
<td style="text-align: left;">object instance</td>
<td style="text-align: left;">instance(Object)</td>
</tr>
<tr>
<td style="text-align: left;">literal</td>
<td style="text-align: left;">data type value</td>
<td style="text-align: left;">instance(Data)</td>
</tr>
<tr>
<td style="text-align: left;">statement</td>
<td style="text-align: left;">binary relation instance</td>
<td style="text-align: left;">instance(BinaryRelation)</td>
</tr>
<tr>
<td style="text-align: left;">subject</td>
<td style="text-align: left;">instance source</td>
<td style="text-align: left;">instance(source) $=\partial_{0}$</td>
</tr>
<tr>
<td style="text-align: left;">object</td>
<td style="text-align: left;">instance target</td>
<td style="text-align: left;">instance(target) $=\partial_{1}$</td>
</tr>
<tr>
<td style="text-align: left;">predicate, type</td>
<td style="text-align: left;">classification</td>
<td style="text-align: left;">$\vDash_{\text {BinaryRelation, }}=$ Entity</td>
</tr>
</tbody>
</table>
<p>The fact that this simple structure for OML corresponds closely to the core structure of RDF/S, illustrates why the core part of the RDF/S syntax is embeddable into the Simple OML syntax. The Simple OML serialization syntax is the closest approach to the RDF/S serialization syntax. The most obvious difference is the lack of types in basic RDF - these are to be modeled with schemas. Types are not considered as essential in RDF as they are in OML/CKML, since schema classes are just special kinds of RDF resources. This is reasonable and is close to the frame system approach, but it is different from the conceptual framework of OML/CKML, which is based more on Sowa's conceptual graphs [10] (see Table 5) and particularly Barwise's theory of information flow [1]. Although RDF Schema classes are normally modeled as types, in order to model the RDF semantics that "properties are resources," they could be modeled in OML/CKML as special objects, with explicit models for the subclass partial order relation between classes, the classification relation between resources and classes, the domain and range functions, etc.</p>
<p>OML allows both free and embedded binary relations, whereas RDF properties are only embedded. The OML namespace mechanism is a bit different from the RDF namespace mechanism: any real-world object is represented by an OML object (surrogate) with a link to the real-world object and OML references to the real-world object are made through this surrogate, whereas web resources may be referenced in RDF without being described (represented); and the complete references for an OML object (instance) has the 3-fold syntax ontology: type#identifier. This is an extension of the XML namespace mechanism. Finally, OML collections are typed, in contrast with RDF bags, which are not.</p>
<h1>Quotations: Statements about Statements</h1>
<p>Quotations, which are statements about statements, are a basic component of Tim Berners-Lee's notion of a semantic web. The RDF model for quotations needs to use reification. In contrast, OML/CKML has two models for quotations: one using reification like RDF, and the other using conceptual contexts, an idea from conceptual graphs. The conceptual context model for quotations needs to use assertions, and the ability to nest assertions within objects using the description attribute. Being a complete semantic model for conceptual graphs, OML/CKML has conceptual contexts. RDF should have such a capability, but doesn't, and thereby is impoverished.</p>
<h2>Example: WWW Quotations</h2>
<p>Consider the following example from the RDF specification document of a "statement about a statement."
"Ralph Swick says that Ora Lassila is the creator of the resource http://www.w3.org/Home/Lassila."
This fact is expressed as follows in RDF, conceptual graphs and OML.</p>
<p>RDF (Resource Description Framework)</p>
<div class="codehilite"><pre><span></span><code><span class="nt">&lt;rdf:RDF</span>
<span class="w">    </span><span class="na">xmlns:rdf=</span><span class="w"> </span><span class="s">&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;</span>
<span class="w">    </span><span class="na">xmlns:a =</span><span class="w"> </span><span class="s">&quot;http://description.org/schema/&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;rdf:Description&gt;</span>
<span class="w">        </span><span class="nt">&lt;rdf:subject</span><span class="w"> </span><span class="na">resource =</span><span class="w"> </span><span class="s">&quot;http://www.w3.org/Home/Lassila&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;rdf:predicate</span><span class="w"> </span><span class="na">resource =</span><span class="w"> </span><span class="s">&quot;http://description.org/schema/Creator&quot;</span><span class="w"> </span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;rdf:object&gt;</span>Ora<span class="w"> </span>Lassila<span class="nt">&lt;/rdf:object&gt;</span>
<span class="w">        </span><span class="nt">&lt;rdf:type</span><span class="w"> </span><span class="na">resource =</span><span class="w"> </span><span class="s">&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#Statement&quot;</span><span class="w"> </span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;a:attributedTo&gt;</span>Ralph<span class="w"> </span>Swick<span class="nt">&lt;/a:attributedTo&gt;</span>
<span class="w">    </span><span class="nt">&lt;/rdf:Description&gt;</span>
<span class="nt">&lt;/rdf:RDF&gt;</span>
</code></pre></div>

<p>Conceptual Graph Display Form
The proposition concept contains a conceptual graph in its referent field. This is an example of a context in conceptual graphs.</p>
<h1>Diagram 4: Conceptual Context</h1>
<h2>Assertion:</h2>
<h2>Proposition:</h2>
<p>Person:
Ora Lassila
Document:
http://www.w3.org/Home/Lassila
<img alt="img-6.jpeg" src="img-6.jpeg" /></p>
<h2>OML (Ontology Markup Language)</h2>
<p>There are two ways of doing this: using reification, or using conceptual contexts.</p>
<h2>Reification</h2>
<div class="codehilite"><pre><span></span><code>/*<span class="w"> </span>types<span class="w"> </span>in<span class="w"> </span>an<span class="w"> </span>ontology<span class="w"> </span>*/
<span class="nt">&lt;Type.Object</span><span class="w"> </span><span class="na">name =</span><span class="w"> </span><span class="s">&quot;Document&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;Type.Object</span><span class="w"> </span><span class="na">name =</span><span class="w"> </span><span class="s">&quot;Person&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;Type.BinaryRelation</span><span class="w"> </span><span class="na">name =</span><span class="w"> </span><span class="s">&quot;create&quot;</span>
<span class="w">    </span><span class="na">source.Type =</span><span class="w"> </span><span class="s">&quot;Person&quot;</span><span class="w"> </span><span class="na">target.Type =</span><span class="w"> </span><span class="s">&quot;Document&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;Type.BinaryRelation</span><span class="w"> </span><span class="na">name =</span><span class="w"> </span><span class="s">&quot;attributedTo&quot;</span>
<span class="w">    </span><span class="na">source.Type =</span><span class="w"> </span><span class="s">&quot;Proposition&quot;</span><span class="w"> </span><span class="na">target.Type =</span><span class="w"> </span><span class="s">&quot;Person&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;Type.Relation</span><span class="w"> </span><span class="na">name =</span><span class="w"> </span><span class="s">&quot;Create&quot;</span><span class="w"> </span><span class="na">binrel =</span><span class="w"> </span><span class="s">&quot;create&quot;</span><span class="nt">&gt;</span><span class="w"> </span>/*<span class="w"> </span>reified<span class="w"> </span>relation<span class="w"> </span>*/
<span class="w">    </span><span class="nt">&lt;Type.Function</span><span class="w"> </span><span class="na">name =</span><span class="w"> </span><span class="s">&quot;agent&quot;</span><span class="w"> </span><span class="na">target.Type =</span><span class="w"> </span><span class="s">&quot;Person&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span><span class="nt">&lt;Type.Function</span><span class="w"> </span><span class="na">name =</span><span class="w"> </span><span class="s">&quot;theme&quot;</span><span class="w"> </span><span class="na">target.Type =</span><span class="w"> </span><span class="s">&quot;Document&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/Type.Relation&gt;</span>
/*<span class="w"> </span>instances<span class="w"> </span>in<span class="w"> </span>a<span class="w"> </span>collection<span class="w"> </span>*/
<span class="nt">&lt;Document</span><span class="w"> </span><span class="na">id =</span><span class="w"> </span><span class="s">&quot;ora-homepage&quot;</span><span class="w"> </span><span class="na">about =</span><span class="w"> </span><span class="s">&quot;http://www.w3.org/Home/Lassila&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;Person</span><span class="w"> </span><span class="na">id =</span><span class="w"> </span><span class="s">&quot;ora&quot;</span><span class="w"> </span><span class="na">text =</span><span class="w"> </span><span class="s">&quot;Ora Lassila&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;Person</span><span class="w"> </span><span class="na">id =</span><span class="w"> </span><span class="s">&quot;ralph&quot;</span><span class="w"> </span><span class="na">text =</span><span class="w"> </span><span class="s">&quot;Ralph Swick&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;Instance.ReifiedBinaryRelation</span><span class="w"> </span><span class="na">id =</span><span class="w"> </span><span class="s">&quot;ora-create-homepage&quot;</span>
<span class="w">    </span><span class="na">source.Instance =</span><span class="w"> </span><span class="s">&quot;ora-home-page&quot;</span><span class="w"> </span><span class="err">/*</span><span class="w"> </span><span class="err">subject</span><span class="w"> </span><span class="err">*/</span>
<span class="w">    </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;ora&quot;</span><span class="nt">/&gt;</span><span class="w"> </span>/*<span class="w"> </span>object<span class="w"> </span>*/
<span class="w">    </span><span class="nt">&lt;classification</span><span class="w"> </span><span class="na">type =</span><span class="w"> </span><span class="s">&quot;creator&quot;</span><span class="nt">/&gt;</span><span class="w"> </span>/*<span class="w"> </span>predicate<span class="w"> </span>*/
<span class="w">    </span><span class="nt">&lt;attributedTo</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;ralph&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/Instance.ReifiedBinaryRelation &gt;</span>
</code></pre></div>

<h2>Conceptual Context</h2>
<p>The part that is in OML, but not in Simple OML, is emphasized. Note how the description attribute for the Proposition instance defines a propositional context, by pointing to the contents of the context - the assertion.</p>
<div class="codehilite"><pre><span></span><code>/*<span class="w"> </span>types<span class="w"> </span>in<span class="w"> </span>an<span class="w"> </span>ontology<span class="w"> </span>*/
<span class="nt">&lt;Type.Object</span><span class="w"> </span><span class="na">name =</span><span class="w"> </span><span class="s">&quot;Document&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;Type.Object</span><span class="w"> </span><span class="na">name =</span><span class="w"> </span><span class="s">&quot;Person&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;Type.Object</span><span class="w"> </span><span class="na">name =</span><span class="w"> </span><span class="s">&quot;Proposition&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;Type.BinaryRelation</span><span class="w"> </span><span class="na">name =</span><span class="w"> </span><span class="s">&quot;create&quot;</span>
<span class="w">    </span><span class="na">source.Type =</span><span class="w"> </span><span class="s">&quot;Person&quot;</span><span class="w"> </span><span class="na">target.Type =</span><span class="w"> </span><span class="s">&quot;Document&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;Type.BinaryRelation</span><span class="w"> </span><span class="na">name =</span><span class="w"> </span><span class="s">&quot;attributedTo&quot;</span>
<span class="w">    </span><span class="na">source.Type =</span><span class="w"> </span><span class="s">&quot;Proposition&quot;</span><span class="w"> </span><span class="na">target.Type =</span><span class="w"> </span><span class="s">&quot;Person&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;Type.Relation</span><span class="w"> </span><span class="na">name =</span><span class="w"> </span><span class="s">&quot;Create&quot;</span><span class="w"> </span><span class="na">binrel =</span><span class="w"> </span><span class="s">&quot;create&quot;</span><span class="nt">&gt;</span><span class="w"> </span>/*<span class="w"> </span>reified<span class="w"> </span>relation<span class="w"> </span>*/
<span class="w">    </span><span class="nt">&lt;Type.Function</span><span class="w"> </span><span class="na">name =</span><span class="w"> </span><span class="s">&quot;agent&quot;</span><span class="w"> </span><span class="na">target.Type =</span><span class="w"> </span><span class="s">&quot;Person&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span><span class="nt">&lt;Type.Function</span><span class="w"> </span><span class="na">name =</span><span class="w"> </span><span class="s">&quot;theme&quot;</span><span class="w"> </span><span class="na">target.Type =</span><span class="w"> </span><span class="s">&quot;Document&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/Type.Relation&gt;</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>/*<span class="w"> </span>instances<span class="w"> </span>in<span class="w"> </span>a<span class="w"> </span>collection<span class="w"> </span>*/
<span class="nt">&lt;Document</span><span class="w"> </span><span class="na">id =</span><span class="w"> </span><span class="s">&quot;ora-homepage&quot;</span><span class="w"> </span><span class="na">about =</span><span class="w"> </span><span class="s">&quot;http://www.w3.org/Home/Lassila&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;Person</span><span class="w"> </span><span class="na">id =</span><span class="w"> </span><span class="s">&quot;ora&quot;</span><span class="w"> </span><span class="na">text =</span><span class="w"> </span><span class="s">&quot;Ora Lassila&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;Person</span><span class="w"> </span><span class="na">id =</span><span class="w"> </span><span class="s">&quot;ralph&quot;</span><span class="w"> </span><span class="na">text =</span><span class="w"> </span><span class="s">&quot;Ralph Swick&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;Proposition</span><span class="w"> </span><span class="na">id =</span><span class="w"> </span><span class="s">&quot;ora-create-homepage&quot;</span><span class="w"> </span><span class="na">description =</span><span class="w"> </span><span class="s">&quot;assertion-create&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;Assertion</span><span class="w"> </span><span class="na">id =</span><span class="w"> </span><span class="s">&quot;assertion-create&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;create</span><span class="w"> </span><span class="na">source.Instance =</span><span class="w"> </span><span class="s">&quot;ora&quot;</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;ora-homepage&quot;</span><span class="nt">&gt;</span>
<span class="nt">&lt;/Assertion&gt;</span>
<span class="nt">&lt;attributedTo</span><span class="w"> </span><span class="na">source.Instance =</span><span class="w"> </span><span class="s">&quot;ora-create-homepage&quot;</span><span class="w"> </span><span class="na">target.Instance =</span><span class="w"> </span><span class="s">&quot;ralph&quot;</span><span class="nt">/&gt;</span>
</code></pre></div>

<h1>Reification</h1>
<p>According to Webster, to reify means "to regard (something abstract) as a material or concrete thing." According to Winston [12], reification means "treating something abstract and difficult to talk about as though it were concrete and easy to talk about." Winston's technical definition of reification is the elevation of a link in a semantic network to the status of a describable node.</p>
<p>When reification of binary relations is done correctly, functions are needed. Reification introduces function types called participants or thematic roles of the original relation. As the example above illustrates, although the original relation might be binary, the reified relation may have additional participants defined. Some canonical participants are: the agent, a coagent, the beneficiary, the thematic object, the instrument, the time of the event, the location of the event, etc. The agent is the entity that causes the action. A coagent serves as partner to the principal agent. The beneficiary is the entity for whom the action is performed. The thematic object is the entity with which the relationship is concerned. The instrument is the tool used by the agent to realize the relationship.</p>
<p>CKML has two forms of reification: an implicit reification represented by the relation-object type ordering, and an explicit reification for binary relations. In describing the OML/CKML version of reification, all reified binary relations are instances of the CKML: Relation type, a subtype of the CKML: Object type. The fact that a multivalent relation is a special case of an object in CKML, represented by the fact that CKML: Relation type is a subtype of the CKML: Object type, is a form of reification that is built into OML/CKML.</p>
<p>Two apparent reasons for reification are: to analyze a statement in order to discover the thematic roles played by various objects (represented by noun phrases), or to make a statement about another statement (use a quotation). As pointed out by the rendering of the above example in OML/CKML, reification is not necessary for this. Instead, it may be better to model quotations using the idea of a conceptual context. The use of reification to model quotations may confuse the expression of the propositional content of one statement with a second statement that references the first statement. An automatic translator might have trouble separating the expressions of the two statements. The expression of the propositional content of a statement can be made in OML /CKML with an assertion (equivalent to a conceptual graph). For conceptual contexts, we need both relations and assertions in order to adequately express "statements about statements". For Simple OML we can ignore relations, and just use the supertype of objects. Apparently however, we cannot ignore assertions. Using contexts to model quotations requires full OML language.</p>
<h1>ONTOLINGUA</h1>
<p>Ontolingua and OML/CKML were developed independently, and it is remarkable how similar they are. The table below shows the correspondences between Ontolingua and OML/CKML.</p>
<p>Table 4: Ontolingua-CKML Correspondences</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Ontolingua</th>
<th style="text-align: left;">OML/CKML</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Class</td>
<td style="text-align: left;">Object type</td>
</tr>
<tr>
<td style="text-align: left;">Relation</td>
<td style="text-align: left;">Relation, BinaryRelation</td>
</tr>
<tr>
<td style="text-align: left;">Function</td>
<td style="text-align: left;">Function</td>
</tr>
<tr>
<td style="text-align: left;">Individual</td>
<td style="text-align: left;">Instance</td>
</tr>
<tr>
<td style="text-align: left;">Axiom</td>
<td style="text-align: left;">Assertion</td>
</tr>
<tr>
<td style="text-align: left;">=&gt;</td>
<td style="text-align: left;"><implies></td>
</tr>
<tr>
<td style="text-align: left;">$&lt;=&gt;$</td>
<td style="text-align: left;"><equiv></td>
</tr>
<tr>
<td style="text-align: left;">and</td>
<td style="text-align: left;"><and></td>
</tr>
<tr>
<td style="text-align: left;">Or</td>
<td style="text-align: left;"><or></td>
</tr>
<tr>
<td style="text-align: left;">Not</td>
<td style="text-align: left;"><not></td>
</tr>
<tr>
<td style="text-align: left;">Exist</td>
<td style="text-align: left;"><Exists></td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"><Forall></td>
</tr>
<tr>
<td style="text-align: left;">?someVar</td>
<td style="text-align: left;">var = "someVar"</td>
</tr>
<tr>
<td style="text-align: left;">Frame</td>
<td style="text-align: left;">Object type, Function, Assertion</td>
</tr>
<tr>
<td style="text-align: left;">Slot</td>
<td style="text-align: left;">BinaryRelation, Function</td>
</tr>
<tr>
<td style="text-align: left;">" ..."</td>
<td style="text-align: left;"><comment></td>
</tr>
</tbody>
</table>
<p>An example from the glossary of ontology terminology in the Ontolingua tutorial illustrates the use of these correspondences in the axiomatics of Ontolingua and OML/CKML.</p>
<p>Natural Language
"If any two animals are siblings, then there exists someone who is the mother of both of them."
Ontolingua Axiom</p>
<div class="codehilite"><pre><span></span><code>((?sib1 Animal)
    (?sib2 Animal))
(=&gt;
    (sibling ?sib1 ?sib2)
    (exists ((?mom Animal))
        (and
            (has-mother ?sib1 ?mom)
            (has-mother ?sib2 ?mom)
        )
    )
)
</code></pre></div>

<p>OML/CKML Assertion</p>
<div class="codehilite"><pre><span></span><code><span class="p">&lt;</span><span class="nx">Forall</span><span class="w"> </span><span class="kd">var</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;sib1&quot;</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;Animal&quot;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nx">Forall</span><span class="w"> </span><span class="kd">var</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;sib2&quot;</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;Animal&quot;</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nx">implies</span><span class="p">&gt;</span>
<span class="w">        </span><span class="p">&lt;</span><span class="nx">sibling</span><span class="w"> </span><span class="nx">source</span><span class="p">.</span><span class="nx">Instance</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;sib1&quot;</span><span class="w"> </span><span class="nx">target</span><span class="p">.</span><span class="nx">Instance</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;sib2&quot;</span><span class="p">&gt;</span>
<span class="w">            </span><span class="p">&lt;</span><span class="nx">Exists</span><span class="w"> </span><span class="kd">var</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;mom&quot;</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;Animal&quot;</span><span class="p">&gt;</span>
<span class="w">                </span><span class="p">&lt;</span><span class="k">and</span><span class="p">&gt;</span>
<span class="w">                    </span><span class="p">&lt;</span><span class="nx">has</span><span class="o">-</span><span class="nx">mother</span><span class="w"> </span><span class="nx">source</span><span class="p">.</span><span class="nx">Instance</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;sib1&quot;</span><span class="w"> </span><span class="nx">target</span><span class="p">.</span><span class="nx">Instance</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;mom&quot;</span><span class="p">&gt;</span>
<span class="w">                    </span><span class="p">&lt;</span><span class="nx">has</span><span class="o">-</span><span class="nx">mother</span><span class="w"> </span><span class="nx">source</span><span class="p">.</span><span class="nx">Instance</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;sib2&quot;</span><span class="w"> </span><span class="nx">target</span><span class="p">.</span><span class="nx">Instance</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;mom&quot;</span><span class="p">&gt;</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="nt">&lt;/and&gt;</span>
<span class="w">    </span><span class="nt">&lt;/Exists&gt;</span>
<span class="nt">&lt;/implies&gt;</span>
<span class="nt">&lt;/Forall&gt;</span>
<span class="nt">&lt;/Forall&gt;</span>
</code></pre></div>

<p>There are differences however. In particular, OML/CKML is strictly a two-tiered structure between types and instances (IF tokens), and does not have a correspondent to the Ontolingua instance. And a related idea is that Ontolingua classes-of-classes often corresponds to OML/CKML theories.</p>
<p>Figure 5: CKML Vehicle Ontology</p>
<p><img alt="img-7.jpeg" src="img-7.jpeg" /></p>
<p>The hierarchy in Figure 5 gives the OML/CKML representation of the Vehicle example in the Ontolingua online tutorial.</p>
<h1>CONCEPTUAL GRAPHS (CGIF)</h1>
<p>Table 5: CGIF-CKML Correspondences</p>
<table>
<thead>
<tr>
<th style="text-align: left;">CGIF</th>
<th style="text-align: left;">OML/CKML</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Conceptual Graph</td>
<td style="text-align: left;">Assertion element</td>
</tr>
<tr>
<td style="text-align: left;">Concept</td>
<td style="text-align: left;">object instance</td>
</tr>
<tr>
<td style="text-align: left;">Conceptual Relation</td>
<td style="text-align: left;">relation instance</td>
</tr>
<tr>
<td style="text-align: left;">Lambda Expression</td>
<td style="text-align: left;">Lambda element</td>
</tr>
<tr>
<td style="text-align: left;">Concept Type</td>
<td style="text-align: left;">Object element</td>
</tr>
<tr>
<td style="text-align: left;">Relation Type</td>
<td style="text-align: left;">Relation element</td>
</tr>
<tr>
<td style="text-align: left;">Referent</td>
<td style="text-align: left;">$\bullet \bullet \bullet$</td>
</tr>
<tr>
<td style="text-align: left;">Quantifier</td>
<td style="text-align: left;">Exists, Forall elements</td>
</tr>
<tr>
<td style="text-align: left;">Designator</td>
<td style="text-align: left;">$\bullet \bullet \bullet$</td>
</tr>
<tr>
<td style="text-align: left;">Literal</td>
<td style="text-align: left;">multimedia attributes</td>
</tr>
<tr>
<td style="text-align: left;">Locator</td>
<td style="text-align: left;">about attribute</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;">Conceptual Graph</th>
<th style="text-align: center;">Expression element</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Context</td>
<td style="text-align: center;">Assertion element referenced by description attribute in object instance</td>
</tr>
<tr>
<td style="text-align: center;">Coreference Set</td>
<td style="text-align: center;">・・・</td>
</tr>
<tr>
<td style="text-align: center;">defining label</td>
<td style="text-align: center;">id attribute (namespace)</td>
</tr>
<tr>
<td style="text-align: center;">bound labels</td>
<td style="text-align: center;">obj attributes (namespace)</td>
</tr>
<tr>
<td style="text-align: center;">Knowledge Base</td>
<td style="text-align: center;">OML element (bracket)</td>
</tr>
<tr>
<td style="text-align: center;">Type hierarchy</td>
<td style="text-align: center;">Ontology element</td>
</tr>
<tr>
<td style="text-align: center;">Relation hierarchy</td>
<td style="text-align: center;">Ontology element</td>
</tr>
<tr>
<td style="text-align: center;">Catalog of individuals</td>
<td style="text-align: center;">Collection elements (object kind)</td>
</tr>
<tr>
<td style="text-align: center;">Outermost context</td>
<td style="text-align: center;">Collection elements (relation kind)</td>
</tr>
</tbody>
</table>
<p>OML has an abbreviated form that, among other things, replaces lambda/quantifier brackets with lambda/quantifier attributes, eliminates function and argument elements, and replaces the function-star expressions in object type definitions by arbitrary expressions in the knowledge base catalogue of individuals. A grammar for Abbreviated OML is now under development. We have recommended to the conceptual graph community that the abbreviated form of OML serve as a base for the development of a Conceptual Graph Markup Language.</p>
<h1>DATABASE REPRESENTATION</h1>
<p><img alt="img-8.jpeg" src="img-8.jpeg" /></p>
<p>Figure 6: Database Ontology Hierarchy</p>
<p>CKML can be used to interrelate different kinds of databases. Relational databases are relation-centric and represent information in tables, whereas objectoriented databases are object-centric. Either kind of database can be translated to the other by suitable definitions in CKML. But such a translation is best defined in terms of a generic database ontology. As shown in the ontology extension hierarchy of Figure 6, in this CKML database representation there are three ontologies representing database schemas: a generic database ontology (DB), a specific object-oriented database ontology (OODB), and a specific relational database ontology (RDB). The arrows in the figure represent both type inclusion and type equivalence (synonymy). All the additional types in the object-oriented ontology and the relational ontology are defined in terms of the basic types in the generic ontology.</p>
<p>Figure 7: Block Structures
<img alt="img-9.jpeg" src="img-9.jpeg" /></p>
<h1>Example: Database Connectivity with CKML</h1>
<p>To illustrate how CKML is related to the knowledge represented in databases, we expand on a conceptual graph example from chapter 7 in the book Knowledge Representation by John Sowa [10] and rephrase it in terms of CKML ontologies and instance collections. This example, called block structures, consists of various kinds of blocks stacked on top of one another as in Figure 7.</p>
<h2>Generic Database</h2>
<p>The basic entity types are: Block, Color, Shape and Support. The basic binary relation and function types are: shape, color, thme and inst. Shape and Color, which represent database domains, are specified in CKML as data type definitions. The Support object type is reified from a support binary relation type. There is a generic classification relation type chrc, called characteristic, which connects object instances with higher order object types. The block notion is described by the two basic function types, shape and color. These are restrictions of chrc to the entity subtypes Shape and Color. The support notion is described by the two basic function types, inst and thme. These are restrictions of two generic participation relation types, inst and thme, called instrument and theme (or thematic object), which are used in the representation of the semantics of natural language.</p>
<p>The basic types are specified in the following generic ontology.
(located at http://www.database.org/ontology/db/)</p>
<div class="codehilite"><pre><span></span><code><span class="nt">&lt;Ontology</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;Generic Database&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;Type.Object</span><span class="w"> </span><span class="na">name=</span><span class="w"> </span><span class="s">&quot;Block&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;Type.Function</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;shape&quot;</span><span class="w"> </span><span class="na">target.Type=</span><span class="s">&quot;Shape&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;Type.Function</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;color&quot;</span><span class="w"> </span><span class="na">target.Type=</span><span class="s">&quot;Color&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span><span class="nt">&lt;/Type.Object&gt;</span>
<span class="w">    </span><span class="nt">&lt;Type.Data</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;Shape&quot;</span><span class="w"> </span><span class="na">ordered=</span><span class="s">&quot;no&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;value</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;cubical&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;value</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;prismatic&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;value</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;pyramidical&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;value</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;cylindrical&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;value</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;conical&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;value</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;spherical&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span><span class="nt">&lt;/Type.Data&gt;</span>
<span class="w">    </span><span class="nt">&lt;Type.Data</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;Color&quot;</span><span class="w"> </span><span class="na">ordered=</span><span class="s">&quot;no&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;value</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;red&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;value</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;orange&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;value</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;yellow&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;value</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;blue&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;value</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;indigo&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;value</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;violet&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;value</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;brown&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;value</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;gray&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;value</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;white&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;value</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;black&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span><span class="nt">&lt;/Type.Data&gt;</span>
<span class="w">    </span><span class="nt">&lt;Type.BinaryRelation</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;support&quot;</span>
<span class="w">        </span><span class="na">source.Type=</span><span class="s">&quot;Block&quot;</span><span class="w"> </span><span class="na">target.Type=</span><span class="s">&quot;Block&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span><span class="nt">&lt;Type.Object</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;Support&quot;</span><span class="nt">&gt;</span><span class="w"> </span>/*<span class="w"> </span>reified<span class="w"> </span>relation<span class="w"> </span>*/
<span class="w">        </span><span class="nt">&lt;Type.Function</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;inst&quot;</span><span class="w"> </span><span class="na">target.Type=</span><span class="s">&quot;Block&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;Type.Function</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;thme&quot;</span><span class="w"> </span><span class="na">target.Type=</span><span class="s">&quot;Block&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span><span class="nt">&lt;/Type.Object&gt;</span>
<span class="nt">&lt;/Ontology&gt;</span>
</code></pre></div>

<h1>Object-Oriented Database</h1>
<p>The additional object-oriented database types define new terminology for blocks. They are specified in terms of the basic types in the generic database ontology. These additional types, which are subtypes of the Block type, are defined in a theory interpretation via role restriction. This theory interpretation is an example of a concrete conceptual scale defined by the simple nominal conceptual scaling of the basic shape function.
(located at http://www.database.org/ontology/oodb/)</p>
<div class="codehilite"><pre><span></span><code><span class="o">&lt;</span><span class="n">Ontology</span><span class="w"> </span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Object-Oriented Database&quot;</span><span class="o">&gt;</span>
<span class="w">    </span><span class="o">&lt;</span><span class="k">extends</span><span class="w"> </span><span class="n">ontology</span><span class="o">=</span><span class="s2">&quot;http://www.database.org/ontology/db/&quot;</span><span class="w"> </span><span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;DB&quot;</span><span class="o">/&gt;</span>
<span class="w">    </span><span class="o">&lt;</span><span class="n">Interpretation</span><span class="w"> </span><span class="n">function</span><span class="o">.</span><span class="n">Type</span><span class="o">=</span><span class="s2">&quot;DB:shape&quot;</span><span class="o">&gt;</span>
<span class="w">        </span><span class="o">&lt;</span><span class="n">Type</span><span class="o">.</span><span class="n">Object</span><span class="w"> </span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Pyramid&quot;</span><span class="w"> </span><span class="k">var</span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;x&quot;</span><span class="w"> </span><span class="n">type</span><span class="o">=</span><span class="s2">&quot;DB:Block&quot;</span><span class="o">&gt;</span>
<span class="w">            </span><span class="o">&lt;</span><span class="n">DB</span><span class="p">:</span><span class="n">Block</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="w"> </span><span class="n">shape</span><span class="o">=</span><span class="s2">&quot;DB:Shape#pyramidical&quot;</span><span class="o">/&gt;</span>
<span class="w">        </span><span class="o">&lt;/</span><span class="n">Type</span><span class="o">.</span><span class="n">Object</span><span class="o">&gt;</span>
<span class="w">        </span><span class="o">&lt;</span><span class="n">Type</span><span class="o">.</span><span class="n">Object</span><span class="w"> </span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Cylinder&quot;</span><span class="w"> </span><span class="k">var</span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;x&quot;</span><span class="w"> </span><span class="n">type</span><span class="o">=</span><span class="s2">&quot;DB:Block&quot;</span><span class="o">&gt;</span>
<span class="w">            </span><span class="o">&lt;</span><span class="n">DB</span><span class="p">:</span><span class="n">Block</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="w"> </span><span class="n">shape</span><span class="o">=</span><span class="s2">&quot;DB:Shape#cylindrical&quot;</span><span class="o">/&gt;</span>
<span class="w">        </span><span class="o">&lt;/</span><span class="n">Type</span><span class="o">.</span><span class="n">Object</span><span class="o">&gt;</span>
<span class="w">        </span><span class="o">...</span>
<span class="w">    </span><span class="o">&lt;/</span><span class="n">Interpretation</span><span class="o">&gt;</span>
<span class="w">    </span><span class="o">&lt;</span><span class="n">Type</span><span class="o">.</span><span class="n">Set</span><span class="w"> </span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Set.Block&quot;</span><span class="w"> </span><span class="n">genus</span><span class="o">=</span><span class="s2">&quot;DB:Block&quot;</span><span class="o">/&gt;</span>
<span class="w">    </span><span class="o">&lt;</span><span class="n">Type</span><span class="o">.</span><span class="w"> </span><span class="n">Function</span><span class="w"> </span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;support&quot;</span>
<span class="w">        </span><span class="n">source</span><span class="o">.</span><span class="n">Type</span><span class="o">=</span><span class="s2">&quot;DB:Block&quot;</span><span class="w"> </span><span class="n">target</span><span class="o">.</span><span class="n">Type</span><span class="o">=</span><span class="s2">&quot;Set.Block&quot;</span><span class="o">/&gt;</span>
<span class="w">    </span><span class="o">&lt;</span><span class="n">Type</span><span class="o">.</span><span class="n">Collection</span><span class="w"> </span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Collection.OODB&quot;</span><span class="w"> </span><span class="n">genus</span><span class="o">=</span><span class="s2">&quot;CKML:Object&quot;</span><span class="o">/&gt;</span>
<span class="o">&lt;/</span><span class="n">Ontology</span><span class="o">&gt;</span>
</code></pre></div>

<p>There is an implicit theory behind the theory interpretation in the object-oriented database ontology, which puts no constraints on the subtypes. Constraints, such as partition of the genus type Block, could be specified a priori, in a more generic ontology, as the following explicit theory. This theory represents an abstract conceptual scale specifying a set of constraints that the concrete conceptual scale, represented by the theory interpretation, must satisfy.</p>
<div class="codehilite"><pre><span></span><code><span class="nt">&lt;Theory</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;Block&quot;</span><span class="w"> </span><span class="na">genus=</span><span class="s">&quot;DB:Block&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;Type.Object</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;Pyramid&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span><span class="nt">&lt;Type.Object</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;Cylinder&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span>...
<span class="w">    </span><span class="nt">&lt;partition&gt;</span>
<span class="w">        </span><span class="nt">&lt;li</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;Pyramid&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;li</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;Cylinder&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span>...
<span class="w">    </span><span class="nt">&lt;/partition&gt;</span>
<span class="nt">&lt;/Theory&gt;</span>
</code></pre></div>

<p>Diagram 4 is the representation of (part of ) the block structures of Figure 1 as an object-oriented database. Objects correspond to blocks. The set-valued support function is used.</p>
<p>The following table lists the CKML representation of the block structures as an object-oriented collection in specific style with function abbreviation.</p>
<div class="codehilite"><pre><span></span><code><span class="nt">&lt;Collection.OODB</span><span class="w"> </span><span class="na">ontology=</span><span class="w"> </span><span class="s">&quot;http://www.blockstructures.org/ontology/oodb/&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;Cylinder</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;a&quot;</span><span class="w"> </span><span class="na">color=</span><span class="s">&quot;Color#violet&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;support&gt;&lt;Set.Block&gt;&lt;li</span><span class="w"> </span><span class="na">instance=</span><span class="s">&quot;c&quot;</span><span class="nt">/&gt;&lt;/Set.Block&gt;&lt;/support&gt;</span>
<span class="w">    </span><span class="nt">&lt;/Cylinder&gt;</span>
<span class="nt">&lt;Pyramid</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;b&quot;</span><span class="w"> </span><span class="na">color=</span><span class="s">&quot;Color#red&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;support&gt;&lt;Set.Block&gt;&lt;li</span><span class="w"> </span><span class="na">instance=</span><span class="s">&quot;c&quot;</span><span class="nt">/&gt;&lt;/Set.Block&gt;&lt;/support&gt;</span>
<span class="w">    </span><span class="nt">&lt;/Pyramid&gt;</span>
<span class="w">    </span>...
<span class="w">    </span><span class="nt">&lt;Cylinder</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;f&quot;</span><span class="w"> </span><span class="na">color=</span><span class="s">&quot;Color#brown&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;support&gt;&lt;Set.Block&gt;&lt;li</span><span class="w"> </span><span class="na">instance=</span><span class="w"> </span><span class="s">&quot;g&quot;</span><span class="nt">/&gt;&lt;/Set.Block&gt;&lt;/support&gt;</span>
<span class="w">    </span><span class="nt">&lt;/Cylinder&gt;</span>
</code></pre></div>            </div>
        </div>

    </div>
</body>
</html>