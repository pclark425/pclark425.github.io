<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-8160 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-8160</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-8160</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-150.html">extraction-schema-150</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the memory mechanism, tasks, comparative results, ablations, and key findings.</div>
                <p><strong>Paper ID:</strong> paper-272423732</p>
                <p><strong>Paper Title:</strong> <a href="https://export.arxiv.org/pdf/2409.02977v1.pdf" target="_blank">Large Language Model-Based Agents for Software Engineering: A Survey</a></p>
                <p><strong>Paper Abstract:</strong> The recent advance in Large Language Models (LLMs) has shaped a new paradigm of AI agents, i.e., LLM-based agents. Compared to standalone LLMs, LLM-based agents substantially extend the versatility and expertise of LLMs by enhancing LLMs with the capabilities of perceiving and utilizing external resources and tools. To date, LLM-based agents have been applied and shown remarkable effectiveness in Software Engineering (SE). The synergy between multiple agents and human interaction brings further promise in tackling complex real-world SE problems. In this work, we present a comprehensive and systematic survey on LLM-based agents for SE. We collect 106 papers and categorize them from two perspectives, i.e., the SE and agent perspectives. In addition, we discuss open challenges and future directions in this critical domain. The repository of this survey is at https://github.com/FudanSELab/Agent4SE-Paper-List.</p>
                <p><strong>Cost:</strong> 0.025</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e8160.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e8160.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the memory mechanism, tasks, comparative results, ablations, and key findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>DROIDAGENT</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>DroidAgent</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A multi-agent framework for mobile GUI testing that uses embedding-based long-term memory and retrieval to support long-term planning and reuse of past task experiences.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>DroidAgent</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Multi-agent system with planner, actor, observer, and reflector agents coordinating through multiple memory modules to enable long-term planning and iterative testing of mobile apps.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Mobile GUI testing (iterative test generation and replay)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Agents perceive GUI page information (screenshots and widget state), plan action sequences (clicks, inputs, navigation), execute via device/emulator, observe results, and iteratively refine tests.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>system testing / interactive GUI testing</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>long-term memory (embeddings) and short-term summaries</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism</strong></td>
                            <td>Textual histories and task summaries are embedded and stored in an external embedding database for semantic similarity retrieval; planner also considers recent task summaries.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Embedded task summaries, previous widget interactions, and curated task knowledge items.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>Semantic search over embeddings (cosine similarity) combined with recency filtering (planner considers N most recent and M most similar items).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_with_without_memory</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_comparison</strong></td>
                            <td>No numerical ablation reported here in survey; described design uses retrieval+recency heuristics (e.g., 20 most recent summaries and 5 most similar) to guide planning.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Embedding-based memory enables retrieval of semantically-similar past GUI tasks and widget interactions, which supports coherent long-term testing strategies and improves planning/decision making for GUI workflows.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Costs and complexity of embedding storage and retrieval; need to manage how much past history to retrieve (tradeoff between recency and relevance); potential for irrelevant or stale memories to mislead planning.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Large Language Model-Based Agents for Software Engineering: A Survey', 'publication_date_yy_mm': '2024-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8160.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e8160.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the memory mechanism, tasks, comparative results, ablations, and key findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>GPTDroid</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>GPTDroid</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An LLM-based agent framework for automated Android GUI testing that keeps a long-term memory of testing knowledge to improve iterative test generation.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>GPTDroid</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Single or multi-agent loop that perceives GUI state, generates Q&A style test scripts, executes tests via emulation/tools, and retains a long-term memory of testing knowledge to improve subsequent reasoning.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Android GUI testing (test script generation and execution)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Generate and execute GUI test scripts from GUI screenshots/state, observe execution results, and iteratively refine tests.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>system testing / GUI testing</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>long-term memory (distilled testing knowledge) and short-term action-observation records</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism</strong></td>
                            <td>Keeps a long-term memory repository of testing knowledge (distilled trajectories) and uses it to inform future reasoning; short-term action-observation histories are preserved per session.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Summarized testing knowledge and action-observation trajectories (text summaries of prior tests and corrections).</td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>Retrieval of distilled summaries and contextual inclusion into prompts (similarity/relevance heuristics); planner checks if additional info is needed based on memory.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_with_without_memory</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_comparison</strong></td>
                            <td>No explicit ablation numbers in survey; memory is described as helpful to improve reasoning over long GUI test sequences and reduce repeated mistakes.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Keeping distilled long-term testing knowledge helps agents maintain coherence across multi-turn GUI testing tasks and reduces repeated information requests, supporting more autonomous test generation.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Memory distillation and selection are needed to manage prompt window limits; risk of storing low-quality or irrelevant test histories that could degrade future performance.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Large Language Model-Based Agents for Software Engineering: A Survey', 'publication_date_yy_mm': '2024-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8160.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e8160.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the memory mechanism, tasks, comparative results, ablations, and key findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>XUAT-Copilot</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>XUAT-Copilot</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A multi-agent system for automated user-acceptance testing that uses a working memory to store dialogue and action history summaries to support planning and state checking.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>XUAT-Copilot</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Consists of agents for action planning, state checking, and parameter selection plus modules for state awareness and case rewriting; uses summarized working memory for stateful decision making.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>User Acceptance Testing (UAT) for mobile/web apps</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Automate generation and execution of acceptance test cases from requirements, check states, and refine test cases iteratively.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>system testing / acceptance testing</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>short-term working memory (summarized dialog/action history)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism</strong></td>
                            <td>Stores dialog and action history in working memory as summarized texts that are retrieved/used in subsequent planning and state checking.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Summaries of dialog turns, action sequences, and state checks.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>Recency- and role-based retrieval of summarized history into prompts for planning and checking.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_with_without_memory</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_comparison</strong></td>
                            <td>No quantitative ablation reported in survey; described as improving stateful decisions and reducing repeated clarifications.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Summarized working memory helps agents maintain state and reduces redundant clarification queries, enabling more coherent multi-step testing and parameter selection.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Requires careful summarization to avoid prompt bloat; trade-offs between detail retention and prompt length constraints.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Large Language Model-Based Agents for Software Engineering: A Survey', 'publication_date_yy_mm': '2024-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8160.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e8160.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the memory mechanism, tasks, comparative results, ablations, and key findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>MetaGPT_shared_memory</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>MetaGPT (shared message pool)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>MetaGPT implements a shared memory/message pool where artifacts from multiple agent roles are stored as structured messages to support cross-role coordination.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>MetaGPT</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>A multi-agent framework for end-to-end software development where agents post artifacts (requirements, designs, docs) to a shared message pool and subscribe to role-relevant messages.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>End-to-end software development (waterfall-like multi-agent workflow)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Simulates a software team producing requirements, design, code, tests, and documentation with agents specialized by role communicating via a shared workspace.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>multi-agent collaboration / software development workflow</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>shared memory (structured message pool)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism</strong></td>
                            <td>Shared blackboard-like message pool that stores artifacts from different agent roles as structured messages (with metadata like sender, task, content).</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Structured messages/documents/diagrams (JSON-like artifacts containing content, sender, task name, and metadata).</td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>Subscription-based retrieval: agents subscribe to messages relevant to their role and obtain required artifacts without direct dialogue.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_with_without_memory</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_comparison</strong></td>
                            <td>No explicit ablation reported; shared memory is described as enabling efficient cross-role information exchange and reducing redundant communication.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Shared structured memory (message pool) improves traceability and allows agents in later stages to obtain intermediate artifacts easily, supporting coordinated multi-role workflows.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Designing message schemas and deciding what to store is nontrivial; shared memory can become noisy without filtering/subscription mechanisms.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Large Language Model-Based Agents for Software Engineering: A Survey', 'publication_date_yy_mm': '2024-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8160.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e8160.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the memory mechanism, tasks, comparative results, ablations, and key findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Reflexion_memory</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Reflexion (memory sliding window)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A mechanism where past agent experiences are stored in a sliding short-term memory window (e.g., last N experiences) to support iterative self-improvement.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Reflexion: Language agents with verbal reinforcement learning</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>Reflexion</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Language-agent framework that stores past experiences and reflections; uses a small sliding-window of past episodes to provide concise context for future steps and enable verbal reinforcement learning.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>General agent tasks requiring iterative self-reflection and improvement (generic benchmark tasks in original Reflexion work)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Agents solve multi-step tasks and learn from prior episodes by reflecting on past actions/outcomes stored in memory to adjust future behavior.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>multi-step reasoning and iterative problem solving</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>short-term episodic (sliding window of past experiences)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism</strong></td>
                            <td>Sliding-window buffer that stores a limited number of past experiences/reflections (example: max number = 3) and provides these as context to the model.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Past experiences and distilled reflections (textual summaries of episodes).</td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>Recency-based inclusion (sliding window) concatenated into prompts as context (prompt concatenation).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_with_without_memory</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_comparison</strong></td>
                            <td>Survey notes Reflexion uses a small fixed-size window to avoid exceeding prompt limits; no numeric ablation provided here.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>A bounded short-term memory (sliding window) helps avoid prompt-length issues while retaining useful recent experiences that support reflection-driven improvements.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Sliding-window memory may forget older but still-relevant experiences; choice of window size is a key tradeoff.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Large Language Model-Based Agents for Software Engineering: A Survey', 'publication_date_yy_mm': '2024-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8160.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e8160.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the memory mechanism, tasks, comparative results, ablations, and key findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Co-Learning_memory</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Co-Learning / Qian et al. (shortcut distillation & key-value DB)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A distilling-based memory approach that extracts shortcuts from task trajectories and constructs key-value databases for instruction-solution mapping to speed retrieval during reasoning.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>Co-Learning (as described by Qian et al.)</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Framework that distills execution trajectories into concise 'shortcuts' and builds two key-value databases (solution->instruction and instruction->solution) to support retrieval-augmented reasoning.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Repository-level code generation / multi-turn software development tasks</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Use past task execution shortcuts as exemplars to guide current reasoning and code generation decisions.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>multi-step reasoning / retrieval-augmented generation</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>long-term distilled memory stored as key-value databases</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism</strong></td>
                            <td>Trajectory distillation to extract shortcuts; stored in two keyed databases for fast retrieval during prompt construction.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Shortcuts (concise traces linking non-adjacent solution nodes), mapping of solutions to instructions and vice versa.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>Similarity-based retrieval from key-value DB using the current prompt as query (semantic/textual matching).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_with_without_memory</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_comparison</strong></td>
                            <td>Survey describes method but does not report quantitative ablation here; distillation aims to reduce memory usage while retaining useful examples.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Distilling trajectories into shortcuts and indexing them in key-value stores enables efficient reuse of prior solutions and improves reasoning efficiency under prompt-length constraints.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Extracting useful shortcuts and setting thresholds for retention are nontrivial; risk of discarding useful but infrequent experiences.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Large Language Model-Based Agents for Software Engineering: A Survey', 'publication_date_yy_mm': '2024-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8160.6">
                <h3 class="extraction-instance">Extracted Data Instance 6 (e8160.6)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the memory mechanism, tasks, comparative results, ablations, and key findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>RCAgent_memory</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>RCAgent (key-value observation store)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A root-cause analysis multi-agent system that uses a key-value store to memorize observations (logs, table entries) to help decision-making and to handle long context while debugging cloud systems.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>RCAgent</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Controller agent orchestrates expert agents, stores observations in a key-value memory for retrieval and context-length management, and uses memory to make decisions for root cause analysis.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Root cause analysis in industrial cloud settings</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Collect logs and system observations, analyze to identify root causes of failures across components, and propose remediation steps.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>diagnosis / multi-component analysis</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>short- and long-term observation store (key-value snapshot store)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism</strong></td>
                            <td>Stores full observation bodies keyed by snapshot keys that agents can query for detailed context; used to handle context-length constraints and to feed expert agents.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Logs, table entries, summarized observations, snapshot keys pointing to details.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>Key-based retrieval and relevance-based selection (agents request observation snapshots as needed).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_with_without_memory</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_comparison</strong></td>
                            <td>No explicit numeric ablation reported; memory used to manage context size and enable repeated lookups across agents.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Key-value observation stores help manage large observational data amounts while enabling targeted retrieval for decision-making under context constraints.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Requires careful indexing and snapshot management; potential stale observation retrieval if system state evolves.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Large Language Model-Based Agents for Software Engineering: A Survey', 'publication_date_yy_mm': '2024-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8160.7">
                <h3 class="extraction-instance">Extracted Data Instance 7 (e8160.7)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the memory mechanism, tasks, comparative results, ablations, and key findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>LATS_tree_memory</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>LATS (task tree memory with MCTS)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A multipath planning and memory mechanism that models task-solving states as a tree; memory is organized as nodes containing instruction, action, and observation and is used with Monte Carlo Tree Search.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>LATS</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Agent framework that simulates multiple generation paths as a tree and optimizes the plan using Monte Carlo Tree Search over stored state nodes.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Code generation / multi-path planning tasks</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Generate multiple possible plans/paths for code generation, simulate outcomes, and select or switch to better paths based on search over the state-tree.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>planning / search-guided generation</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>structured tree memory (state nodes retained across planning)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism</strong></td>
                            <td>Stores each simulated state as a tree node including instruction, action, and observation; MCTS explores nodes to select high-value plans.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Tree nodes representing states (instruction, action, observation) and path history.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>MCTS-driven exploration and selection; node expansion and backpropagation determine which memories guide future actions.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_with_without_memory</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_comparison</strong></td>
                            <td>Survey notes multi-path planning via tree memory as an approach to mitigate randomness of single-path planning; no numerical ablation reported here.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Tree-structured memory combined with MCTS enables simulation of multiple solution paths and more robust plan selection than single linear plans.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Computational cost of maintaining and searching a large tree; determining appropriate branching and pruning thresholds is challenging.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Large Language Model-Based Agents for Software Engineering: A Survey', 'publication_date_yy_mm': '2024-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8160.8">
                <h3 class="extraction-instance">Extracted Data Instance 8 (e8160.8)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the memory mechanism, tasks, comparative results, ablations, and key findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>SoA_individual_memory</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>SoA (Self-organized Agents) per-agent memory</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A hierarchical code generation framework where each agent owns specific memory storing its generated code fragments and unit tests to enable delayed execution and hierarchical collaboration.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>SoA</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>Self-organized multi-agent framework for large-scale code generation where mother/child agents each store and use their own local memory of code and tests during collaboration.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Ultra large-scale code generation and optimization (hierarchical repository-level codegen)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Divide repository-level tasks across many agents, each implementing and testing functions, then integrate submodules into a whole.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>multi-agent code generation / hierarchical coordination</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>specific/local per-agent memory (agent-owned storage)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism</strong></td>
                            <td>Each agent stores its own generated function code and unit tests in local memory for later retrieval, evaluation, and aggregation by other agents.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Generated code fragments, unit tests, and local intermediate outputs.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>Direct local access by the owner agent; aggregated access by higher-level agents during integration.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_with_without_memory</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_comparison</strong></td>
                            <td>No quantitative ablation reported in survey; per-agent memory described as enabling modular development and delayed validation.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Per-agent specific memory reduces irrelevant context exposure and supports modular testing and integration across hierarchical agents.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Requires mechanisms for consistency checking and merging across many local memories; risk of fragmentation and duplication.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Large Language Model-Based Agents for Software Engineering: A Survey', 'publication_date_yy_mm': '2024-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8160.9">
                <h3 class="extraction-instance">Extracted Data Instance 9 (e8160.9)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language model agents using memory to solve tasks, including details of the memory mechanism, tasks, comparative results, ablations, and key findings.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>E&V_intermediate_memory</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>E&V (pseudo-code execution with summarized intermediate outputs)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An agent that avoids hallucination by summarizing and storing only intermediate analysis results in memory (JSON) rather than full dialog histories.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>agent_name</strong></td>
                            <td>E&V</td>
                        </tr>
                        <tr>
                            <td><strong>agent_description</strong></td>
                            <td>LLM-based static analysis workflow that loops pseudo-code execution and verification; stores summarized intermediate analysis (not full raw trajectories) to reduce inconsistency and hallucination.</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Static analysis for Linux kernel bug localization / vulnerability detection</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Use LLM to analyze code via pseudo-execution and verification loop, retrieving necessary code snippets via static analysis tools and summarizing intermediate outputs.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>static code analysis / program understanding</td>
                        </tr>
                        <tr>
                            <td><strong>memory_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>memory_type</strong></td>
                            <td>short-term distilled intermediate-output memory (JSON summaries)</td>
                        </tr>
                        <tr>
                            <td><strong>memory_mechanism</strong></td>
                            <td>Summarizes intermediate analysis results into concise JSON-format artifacts which are stored and used for later verification and re-analysis.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_representation</strong></td>
                            <td>Summarized intermediate analysis results (JSON), not full raw dialogue or code dumps.</td>
                        </tr>
                        <tr>
                            <td><strong>memory_retrieval_method</strong></td>
                            <td>Structured retrieval of JSON summaries to feed back into the pseudo-execution/verification loop.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_with_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_without_memory</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>has_performance_with_without_memory</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_comparison</strong></td>
                            <td>No numeric ablation reported here; described as a mitigation against hallucination and inconsistency when full raw context is unavailable.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Storing distilled intermediate outputs (vs full raw history) reduces hallucination risks and supports stable re-analysis under incomplete code contexts.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_challenges</strong></td>
                            <td>Risk of losing detail when summarizing; tradeoff between conciseness and sufficient detail for verification.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Large Language Model-Based Agents for Software Engineering: A Survey', 'publication_date_yy_mm': '2024-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Reflexion: Language agents with verbal reinforcement learning <em>(Rating: 2)</em></li>
                <li>A survey on the memory mechanism of large language model based agents <em>(Rating: 2)</em></li>
                <li>DroidAgent: Autonomous large language model agents enabling intent-driven mobile GUI testing <em>(Rating: 2)</em></li>
                <li>MetaGPT: Meta programming for a multi-agent collaborative framework <em>(Rating: 2)</em></li>
                <li>Language agent tree search unifies reasoning acting and planning in language models <em>(Rating: 2)</em></li>
                <li>AgentFL: Scaling llm-based fault localization to project-level context <em>(Rating: 1)</em></li>
                <li>Co-Learning (Qian et al.) <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-8160",
    "paper_id": "paper-272423732",
    "extraction_schema_id": "extraction-schema-150",
    "extracted_data": [
        {
            "name_short": "DROIDAGENT",
            "name_full": "DroidAgent",
            "brief_description": "A multi-agent framework for mobile GUI testing that uses embedding-based long-term memory and retrieval to support long-term planning and reuse of past task experiences.",
            "citation_title": "",
            "mention_or_use": "mention",
            "agent_name": "DroidAgent",
            "agent_description": "Multi-agent system with planner, actor, observer, and reflector agents coordinating through multiple memory modules to enable long-term planning and iterative testing of mobile apps.",
            "model_name": null,
            "model_description": null,
            "task_name": "Mobile GUI testing (iterative test generation and replay)",
            "task_description": "Agents perceive GUI page information (screenshots and widget state), plan action sequences (clicks, inputs, navigation), execute via device/emulator, observe results, and iteratively refine tests.",
            "task_type": "system testing / interactive GUI testing",
            "memory_used": true,
            "memory_type": "long-term memory (embeddings) and short-term summaries",
            "memory_mechanism": "Textual histories and task summaries are embedded and stored in an external embedding database for semantic similarity retrieval; planner also considers recent task summaries.",
            "memory_representation": "Embedded task summaries, previous widget interactions, and curated task knowledge items.",
            "memory_retrieval_method": "Semantic search over embeddings (cosine similarity) combined with recency filtering (planner considers N most recent and M most similar items).",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_performance_with_without_memory": false,
            "ablation_or_comparison": "No numerical ablation reported here in survey; described design uses retrieval+recency heuristics (e.g., 20 most recent summaries and 5 most similar) to guide planning.",
            "key_findings": "Embedding-based memory enables retrieval of semantically-similar past GUI tasks and widget interactions, which supports coherent long-term testing strategies and improves planning/decision making for GUI workflows.",
            "limitations_or_challenges": "Costs and complexity of embedding storage and retrieval; need to manage how much past history to retrieve (tradeoff between recency and relevance); potential for irrelevant or stale memories to mislead planning.",
            "uuid": "e8160.0",
            "source_info": {
                "paper_title": "Large Language Model-Based Agents for Software Engineering: A Survey",
                "publication_date_yy_mm": "2024-09"
            }
        },
        {
            "name_short": "GPTDroid",
            "name_full": "GPTDroid",
            "brief_description": "An LLM-based agent framework for automated Android GUI testing that keeps a long-term memory of testing knowledge to improve iterative test generation.",
            "citation_title": "",
            "mention_or_use": "mention",
            "agent_name": "GPTDroid",
            "agent_description": "Single or multi-agent loop that perceives GUI state, generates Q&A style test scripts, executes tests via emulation/tools, and retains a long-term memory of testing knowledge to improve subsequent reasoning.",
            "model_name": null,
            "model_description": null,
            "task_name": "Android GUI testing (test script generation and execution)",
            "task_description": "Generate and execute GUI test scripts from GUI screenshots/state, observe execution results, and iteratively refine tests.",
            "task_type": "system testing / GUI testing",
            "memory_used": true,
            "memory_type": "long-term memory (distilled testing knowledge) and short-term action-observation records",
            "memory_mechanism": "Keeps a long-term memory repository of testing knowledge (distilled trajectories) and uses it to inform future reasoning; short-term action-observation histories are preserved per session.",
            "memory_representation": "Summarized testing knowledge and action-observation trajectories (text summaries of prior tests and corrections).",
            "memory_retrieval_method": "Retrieval of distilled summaries and contextual inclusion into prompts (similarity/relevance heuristics); planner checks if additional info is needed based on memory.",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_performance_with_without_memory": false,
            "ablation_or_comparison": "No explicit ablation numbers in survey; memory is described as helpful to improve reasoning over long GUI test sequences and reduce repeated mistakes.",
            "key_findings": "Keeping distilled long-term testing knowledge helps agents maintain coherence across multi-turn GUI testing tasks and reduces repeated information requests, supporting more autonomous test generation.",
            "limitations_or_challenges": "Memory distillation and selection are needed to manage prompt window limits; risk of storing low-quality or irrelevant test histories that could degrade future performance.",
            "uuid": "e8160.1",
            "source_info": {
                "paper_title": "Large Language Model-Based Agents for Software Engineering: A Survey",
                "publication_date_yy_mm": "2024-09"
            }
        },
        {
            "name_short": "XUAT-Copilot",
            "name_full": "XUAT-Copilot",
            "brief_description": "A multi-agent system for automated user-acceptance testing that uses a working memory to store dialogue and action history summaries to support planning and state checking.",
            "citation_title": "",
            "mention_or_use": "mention",
            "agent_name": "XUAT-Copilot",
            "agent_description": "Consists of agents for action planning, state checking, and parameter selection plus modules for state awareness and case rewriting; uses summarized working memory for stateful decision making.",
            "model_name": null,
            "model_description": null,
            "task_name": "User Acceptance Testing (UAT) for mobile/web apps",
            "task_description": "Automate generation and execution of acceptance test cases from requirements, check states, and refine test cases iteratively.",
            "task_type": "system testing / acceptance testing",
            "memory_used": true,
            "memory_type": "short-term working memory (summarized dialog/action history)",
            "memory_mechanism": "Stores dialog and action history in working memory as summarized texts that are retrieved/used in subsequent planning and state checking.",
            "memory_representation": "Summaries of dialog turns, action sequences, and state checks.",
            "memory_retrieval_method": "Recency- and role-based retrieval of summarized history into prompts for planning and checking.",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_performance_with_without_memory": false,
            "ablation_or_comparison": "No quantitative ablation reported in survey; described as improving stateful decisions and reducing repeated clarifications.",
            "key_findings": "Summarized working memory helps agents maintain state and reduces redundant clarification queries, enabling more coherent multi-step testing and parameter selection.",
            "limitations_or_challenges": "Requires careful summarization to avoid prompt bloat; trade-offs between detail retention and prompt length constraints.",
            "uuid": "e8160.2",
            "source_info": {
                "paper_title": "Large Language Model-Based Agents for Software Engineering: A Survey",
                "publication_date_yy_mm": "2024-09"
            }
        },
        {
            "name_short": "MetaGPT_shared_memory",
            "name_full": "MetaGPT (shared message pool)",
            "brief_description": "MetaGPT implements a shared memory/message pool where artifacts from multiple agent roles are stored as structured messages to support cross-role coordination.",
            "citation_title": "",
            "mention_or_use": "mention",
            "agent_name": "MetaGPT",
            "agent_description": "A multi-agent framework for end-to-end software development where agents post artifacts (requirements, designs, docs) to a shared message pool and subscribe to role-relevant messages.",
            "model_name": null,
            "model_description": null,
            "task_name": "End-to-end software development (waterfall-like multi-agent workflow)",
            "task_description": "Simulates a software team producing requirements, design, code, tests, and documentation with agents specialized by role communicating via a shared workspace.",
            "task_type": "multi-agent collaboration / software development workflow",
            "memory_used": true,
            "memory_type": "shared memory (structured message pool)",
            "memory_mechanism": "Shared blackboard-like message pool that stores artifacts from different agent roles as structured messages (with metadata like sender, task, content).",
            "memory_representation": "Structured messages/documents/diagrams (JSON-like artifacts containing content, sender, task name, and metadata).",
            "memory_retrieval_method": "Subscription-based retrieval: agents subscribe to messages relevant to their role and obtain required artifacts without direct dialogue.",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_performance_with_without_memory": false,
            "ablation_or_comparison": "No explicit ablation reported; shared memory is described as enabling efficient cross-role information exchange and reducing redundant communication.",
            "key_findings": "Shared structured memory (message pool) improves traceability and allows agents in later stages to obtain intermediate artifacts easily, supporting coordinated multi-role workflows.",
            "limitations_or_challenges": "Designing message schemas and deciding what to store is nontrivial; shared memory can become noisy without filtering/subscription mechanisms.",
            "uuid": "e8160.3",
            "source_info": {
                "paper_title": "Large Language Model-Based Agents for Software Engineering: A Survey",
                "publication_date_yy_mm": "2024-09"
            }
        },
        {
            "name_short": "Reflexion_memory",
            "name_full": "Reflexion (memory sliding window)",
            "brief_description": "A mechanism where past agent experiences are stored in a sliding short-term memory window (e.g., last N experiences) to support iterative self-improvement.",
            "citation_title": "Reflexion: Language agents with verbal reinforcement learning",
            "mention_or_use": "mention",
            "agent_name": "Reflexion",
            "agent_description": "Language-agent framework that stores past experiences and reflections; uses a small sliding-window of past episodes to provide concise context for future steps and enable verbal reinforcement learning.",
            "model_name": null,
            "model_description": null,
            "task_name": "General agent tasks requiring iterative self-reflection and improvement (generic benchmark tasks in original Reflexion work)",
            "task_description": "Agents solve multi-step tasks and learn from prior episodes by reflecting on past actions/outcomes stored in memory to adjust future behavior.",
            "task_type": "multi-step reasoning and iterative problem solving",
            "memory_used": true,
            "memory_type": "short-term episodic (sliding window of past experiences)",
            "memory_mechanism": "Sliding-window buffer that stores a limited number of past experiences/reflections (example: max number = 3) and provides these as context to the model.",
            "memory_representation": "Past experiences and distilled reflections (textual summaries of episodes).",
            "memory_retrieval_method": "Recency-based inclusion (sliding window) concatenated into prompts as context (prompt concatenation).",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_performance_with_without_memory": false,
            "ablation_or_comparison": "Survey notes Reflexion uses a small fixed-size window to avoid exceeding prompt limits; no numeric ablation provided here.",
            "key_findings": "A bounded short-term memory (sliding window) helps avoid prompt-length issues while retaining useful recent experiences that support reflection-driven improvements.",
            "limitations_or_challenges": "Sliding-window memory may forget older but still-relevant experiences; choice of window size is a key tradeoff.",
            "uuid": "e8160.4",
            "source_info": {
                "paper_title": "Large Language Model-Based Agents for Software Engineering: A Survey",
                "publication_date_yy_mm": "2024-09"
            }
        },
        {
            "name_short": "Co-Learning_memory",
            "name_full": "Co-Learning / Qian et al. (shortcut distillation & key-value DB)",
            "brief_description": "A distilling-based memory approach that extracts shortcuts from task trajectories and constructs key-value databases for instruction-solution mapping to speed retrieval during reasoning.",
            "citation_title": "",
            "mention_or_use": "mention",
            "agent_name": "Co-Learning (as described by Qian et al.)",
            "agent_description": "Framework that distills execution trajectories into concise 'shortcuts' and builds two key-value databases (solution-&gt;instruction and instruction-&gt;solution) to support retrieval-augmented reasoning.",
            "model_name": null,
            "model_description": null,
            "task_name": "Repository-level code generation / multi-turn software development tasks",
            "task_description": "Use past task execution shortcuts as exemplars to guide current reasoning and code generation decisions.",
            "task_type": "multi-step reasoning / retrieval-augmented generation",
            "memory_used": true,
            "memory_type": "long-term distilled memory stored as key-value databases",
            "memory_mechanism": "Trajectory distillation to extract shortcuts; stored in two keyed databases for fast retrieval during prompt construction.",
            "memory_representation": "Shortcuts (concise traces linking non-adjacent solution nodes), mapping of solutions to instructions and vice versa.",
            "memory_retrieval_method": "Similarity-based retrieval from key-value DB using the current prompt as query (semantic/textual matching).",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_performance_with_without_memory": false,
            "ablation_or_comparison": "Survey describes method but does not report quantitative ablation here; distillation aims to reduce memory usage while retaining useful examples.",
            "key_findings": "Distilling trajectories into shortcuts and indexing them in key-value stores enables efficient reuse of prior solutions and improves reasoning efficiency under prompt-length constraints.",
            "limitations_or_challenges": "Extracting useful shortcuts and setting thresholds for retention are nontrivial; risk of discarding useful but infrequent experiences.",
            "uuid": "e8160.5",
            "source_info": {
                "paper_title": "Large Language Model-Based Agents for Software Engineering: A Survey",
                "publication_date_yy_mm": "2024-09"
            }
        },
        {
            "name_short": "RCAgent_memory",
            "name_full": "RCAgent (key-value observation store)",
            "brief_description": "A root-cause analysis multi-agent system that uses a key-value store to memorize observations (logs, table entries) to help decision-making and to handle long context while debugging cloud systems.",
            "citation_title": "",
            "mention_or_use": "mention",
            "agent_name": "RCAgent",
            "agent_description": "Controller agent orchestrates expert agents, stores observations in a key-value memory for retrieval and context-length management, and uses memory to make decisions for root cause analysis.",
            "model_name": null,
            "model_description": null,
            "task_name": "Root cause analysis in industrial cloud settings",
            "task_description": "Collect logs and system observations, analyze to identify root causes of failures across components, and propose remediation steps.",
            "task_type": "diagnosis / multi-component analysis",
            "memory_used": true,
            "memory_type": "short- and long-term observation store (key-value snapshot store)",
            "memory_mechanism": "Stores full observation bodies keyed by snapshot keys that agents can query for detailed context; used to handle context-length constraints and to feed expert agents.",
            "memory_representation": "Logs, table entries, summarized observations, snapshot keys pointing to details.",
            "memory_retrieval_method": "Key-based retrieval and relevance-based selection (agents request observation snapshots as needed).",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_performance_with_without_memory": false,
            "ablation_or_comparison": "No explicit numeric ablation reported; memory used to manage context size and enable repeated lookups across agents.",
            "key_findings": "Key-value observation stores help manage large observational data amounts while enabling targeted retrieval for decision-making under context constraints.",
            "limitations_or_challenges": "Requires careful indexing and snapshot management; potential stale observation retrieval if system state evolves.",
            "uuid": "e8160.6",
            "source_info": {
                "paper_title": "Large Language Model-Based Agents for Software Engineering: A Survey",
                "publication_date_yy_mm": "2024-09"
            }
        },
        {
            "name_short": "LATS_tree_memory",
            "name_full": "LATS (task tree memory with MCTS)",
            "brief_description": "A multipath planning and memory mechanism that models task-solving states as a tree; memory is organized as nodes containing instruction, action, and observation and is used with Monte Carlo Tree Search.",
            "citation_title": "",
            "mention_or_use": "mention",
            "agent_name": "LATS",
            "agent_description": "Agent framework that simulates multiple generation paths as a tree and optimizes the plan using Monte Carlo Tree Search over stored state nodes.",
            "model_name": null,
            "model_description": null,
            "task_name": "Code generation / multi-path planning tasks",
            "task_description": "Generate multiple possible plans/paths for code generation, simulate outcomes, and select or switch to better paths based on search over the state-tree.",
            "task_type": "planning / search-guided generation",
            "memory_used": true,
            "memory_type": "structured tree memory (state nodes retained across planning)",
            "memory_mechanism": "Stores each simulated state as a tree node including instruction, action, and observation; MCTS explores nodes to select high-value plans.",
            "memory_representation": "Tree nodes representing states (instruction, action, observation) and path history.",
            "memory_retrieval_method": "MCTS-driven exploration and selection; node expansion and backpropagation determine which memories guide future actions.",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_performance_with_without_memory": false,
            "ablation_or_comparison": "Survey notes multi-path planning via tree memory as an approach to mitigate randomness of single-path planning; no numerical ablation reported here.",
            "key_findings": "Tree-structured memory combined with MCTS enables simulation of multiple solution paths and more robust plan selection than single linear plans.",
            "limitations_or_challenges": "Computational cost of maintaining and searching a large tree; determining appropriate branching and pruning thresholds is challenging.",
            "uuid": "e8160.7",
            "source_info": {
                "paper_title": "Large Language Model-Based Agents for Software Engineering: A Survey",
                "publication_date_yy_mm": "2024-09"
            }
        },
        {
            "name_short": "SoA_individual_memory",
            "name_full": "SoA (Self-organized Agents) per-agent memory",
            "brief_description": "A hierarchical code generation framework where each agent owns specific memory storing its generated code fragments and unit tests to enable delayed execution and hierarchical collaboration.",
            "citation_title": "",
            "mention_or_use": "mention",
            "agent_name": "SoA",
            "agent_description": "Self-organized multi-agent framework for large-scale code generation where mother/child agents each store and use their own local memory of code and tests during collaboration.",
            "model_name": null,
            "model_description": null,
            "task_name": "Ultra large-scale code generation and optimization (hierarchical repository-level codegen)",
            "task_description": "Divide repository-level tasks across many agents, each implementing and testing functions, then integrate submodules into a whole.",
            "task_type": "multi-agent code generation / hierarchical coordination",
            "memory_used": true,
            "memory_type": "specific/local per-agent memory (agent-owned storage)",
            "memory_mechanism": "Each agent stores its own generated function code and unit tests in local memory for later retrieval, evaluation, and aggregation by other agents.",
            "memory_representation": "Generated code fragments, unit tests, and local intermediate outputs.",
            "memory_retrieval_method": "Direct local access by the owner agent; aggregated access by higher-level agents during integration.",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_performance_with_without_memory": false,
            "ablation_or_comparison": "No quantitative ablation reported in survey; per-agent memory described as enabling modular development and delayed validation.",
            "key_findings": "Per-agent specific memory reduces irrelevant context exposure and supports modular testing and integration across hierarchical agents.",
            "limitations_or_challenges": "Requires mechanisms for consistency checking and merging across many local memories; risk of fragmentation and duplication.",
            "uuid": "e8160.8",
            "source_info": {
                "paper_title": "Large Language Model-Based Agents for Software Engineering: A Survey",
                "publication_date_yy_mm": "2024-09"
            }
        },
        {
            "name_short": "E&V_intermediate_memory",
            "name_full": "E&V (pseudo-code execution with summarized intermediate outputs)",
            "brief_description": "An agent that avoids hallucination by summarizing and storing only intermediate analysis results in memory (JSON) rather than full dialog histories.",
            "citation_title": "",
            "mention_or_use": "mention",
            "agent_name": "E&V",
            "agent_description": "LLM-based static analysis workflow that loops pseudo-code execution and verification; stores summarized intermediate analysis (not full raw trajectories) to reduce inconsistency and hallucination.",
            "model_name": null,
            "model_description": null,
            "task_name": "Static analysis for Linux kernel bug localization / vulnerability detection",
            "task_description": "Use LLM to analyze code via pseudo-execution and verification loop, retrieving necessary code snippets via static analysis tools and summarizing intermediate outputs.",
            "task_type": "static code analysis / program understanding",
            "memory_used": true,
            "memory_type": "short-term distilled intermediate-output memory (JSON summaries)",
            "memory_mechanism": "Summarizes intermediate analysis results into concise JSON-format artifacts which are stored and used for later verification and re-analysis.",
            "memory_representation": "Summarized intermediate analysis results (JSON), not full raw dialogue or code dumps.",
            "memory_retrieval_method": "Structured retrieval of JSON summaries to feed back into the pseudo-execution/verification loop.",
            "performance_with_memory": null,
            "performance_without_memory": null,
            "has_performance_with_without_memory": false,
            "ablation_or_comparison": "No numeric ablation reported here; described as a mitigation against hallucination and inconsistency when full raw context is unavailable.",
            "key_findings": "Storing distilled intermediate outputs (vs full raw history) reduces hallucination risks and supports stable re-analysis under incomplete code contexts.",
            "limitations_or_challenges": "Risk of losing detail when summarizing; tradeoff between conciseness and sufficient detail for verification.",
            "uuid": "e8160.9",
            "source_info": {
                "paper_title": "Large Language Model-Based Agents for Software Engineering: A Survey",
                "publication_date_yy_mm": "2024-09"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Reflexion: Language agents with verbal reinforcement learning",
            "rating": 2,
            "sanitized_title": "reflexion_language_agents_with_verbal_reinforcement_learning"
        },
        {
            "paper_title": "A survey on the memory mechanism of large language model based agents",
            "rating": 2,
            "sanitized_title": "a_survey_on_the_memory_mechanism_of_large_language_model_based_agents"
        },
        {
            "paper_title": "DroidAgent: Autonomous large language model agents enabling intent-driven mobile GUI testing",
            "rating": 2,
            "sanitized_title": "droidagent_autonomous_large_language_model_agents_enabling_intentdriven_mobile_gui_testing"
        },
        {
            "paper_title": "MetaGPT: Meta programming for a multi-agent collaborative framework",
            "rating": 2,
            "sanitized_title": "metagpt_meta_programming_for_a_multiagent_collaborative_framework"
        },
        {
            "paper_title": "Language agent tree search unifies reasoning acting and planning in language models",
            "rating": 2,
            "sanitized_title": "language_agent_tree_search_unifies_reasoning_acting_and_planning_in_language_models"
        },
        {
            "paper_title": "AgentFL: Scaling llm-based fault localization to project-level context",
            "rating": 1,
            "sanitized_title": "agentfl_scaling_llmbased_fault_localization_to_projectlevel_context"
        },
        {
            "paper_title": "Co-Learning (Qian et al.)",
            "rating": 1,
            "sanitized_title": "colearning_qian_et_al"
        }
    ],
    "cost": 0.024823249999999998,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>Large Language Model-Based Agents for Software Engineering: A Survey
SEPTEMBER 2024</p>
<p>Junwei Liu 
Kaixin Wang 
Yixuan Chen 
Xin Peng 
Zhenpeng Chen 
Lingming Zhang 
Yiling Lou 
Large Language Model-Based Agents for Software Engineering: A Survey
SEPTEMBER 20249F82B4E6ECE7874264AE78D6510F2DD0arXiv:2409.02977v1[cs.SE]Large Language ModelAI AgentSoftware Engineering Memory  5.1.2 Perception  5.1.3 Action  5.1.4 Multi-agent System  5.2 Agent Roles  5.2.1 Collaboration Mechanism  5.2.2
The recent advance in Large Language Models (LLMs) has shaped a new paradigm of AI agents, i.e., LLM-based agents.Compared to standalone LLMs, LLM-based agents substantially extend the versatility and expertise of LLMs by enhancing LLMs with the capabilities of perceiving and utilizing external resources and tools.To date, LLM-based agents have been applied and shown remarkable effectiveness in Software Engineering (SE).The synergy between multiple agents and human interaction brings further promise in tackling complex real-world SE problems.In this work, we present a comprehensive and systematic survey on LLM-based agents for SE.We collect 106 papers and categorize them from two perspectives, i.e., the SE and agent perspectives.In addition, we discuss open challenges and future directions in this critical domain.The repository of this survey is at https://github.com/FudanSELab/Agent4SE-Paper-List.</p>
<p>INTRODUCTION</p>
<p>Large Language Models (LLMs) [1] have achieved remarkable progress and demonstrated potential of human-like intelligence.In recent years, LLMs have been widely applied in Software Engineering (SE).As shown by recent surveys [2], [3], LLMs have been adopted and shown promising performance in various software development and maintenance tasks, such as program generation [4]- [8], software testing [9]- [11] and debugging [12]- [17], and program improvement [18]- [20].</p>
<p>AI Agents are artificial entities that can autonomously perceive and act on surrounding environments so as to achieve specific goals [21].The concept of AI agents has been evolving for a long time (e.g., early agents are constructed on symbolic logic or reinforcement learning [22]- [25]).Recently, the remarkable progress in LLMs has further shaped a new paradigm of AI agents, i.e., LLM-based agents, which leverage LLMs as the central agent controller.Different from standalone LLMs, LLM-based agents extend the versatility and expertise of LLMs by equipping LLMs with the capabilities of perceiving and utilizing external resources and tools, which can tackle more complex real-world goals via collaboration between multiple agents or involvement of human interaction.</p>
<p>In this work, we present a comprehensive and systematic survey on LLM-based agents for SE.We collect 106 papers and categorize them from two perspectives, i.e., both the SE and agent perspectives.Additionally, we discuss the open challenges and future directions in this domain.</p>
<p> J. Liu, K. Wang, Y. Chen, X. Peng, and Y. Lou are with the Department of Computer Science, Fudan University, China.E-mails: {jwliu24, kxwang23, yixuanchen23}@m.fudan.edu.cn,{pengxin, yilin-glou}@fudan.edu.cn Z. Chen is with the School of Computer Science and Engineering, Nanyang Technological University, Singapore.E-mail: zhenpeng.chen@ntu.edu.sg L. Zhang is with the Department of Computer Science, University of Illinois Urbana-Champaign, USA.E-mail: lingming@illinois.edu</p>
<p>From the SE perspective, we analyze how LLM-based agents are applied across different software development and improvement activities, including individual tasks (e.g., requirements engineering, code generation, static code checking, testing, and debugging) as well as the endto-end procedure of software development and improvement.From this perspective, we provide a comprehensive overview of how SE tasks are tackled by LLM-based agents.</p>
<p>From the agent perspective, we focus on the design of components in LLM-based agents for SE.Specifically, we analyze key components, including planning, memory, perception, and action, in these agents.Beyond basic agent construction, we also analyze multi-agent systems, including their agent roles, collaboration mechanisms, and humanagent collaboration.From this perspective, we summarize the characteristics of different components of LLM-based agents when applied to the SE domain.</p>
<p>In summary, this survey makes the following contributions:</p>
<p> It provides the first comprehensive survey of 106 papers that apply LLM-based agents to SE.  It analyzes how existing LLM-based agents are designed and applied for software development and maintenance from both the SE and agent perspectives.</p>
<p> It discusses research opportunities and future directions in this critical domain.Survey Structure.Figure 1 summarizes the structure of this survey.Section 2 introduces background knowledge, while Section 3 presents the methodology.Section 4 and Section 5 present the relevant work from the SE perspective and the agent perspective, respectively.Finally, Section 6 discusses the potential research opportunities.</p>
<p>BACKGROUND AND PRELIMINARY</p>
<p>In this section, we first introduce the background about the basic and advanced LLM-based agents, and then we discuss the related surveys.</p>
<p>Basic Framework of LLM-based Agents</p>
<p>LLM-based agents are typically composed of four key components: planning, memory, perception, and action [21].The planning and memory serve as the key components of the LLM-controlled brain, which interacts with the environment through the perception and action components to achieve specific goals.Figure 2 illustrates the basic framework of LLM-based agents.</p>
<p>Planning.The planning component decomposes complex tasks into multiple sub-tasks and schedules the subtasks to achieve final goals.In particular, agents can (i) generate a plan without adjustment by different reasoning strategies, or (ii) adjust a generated plan with the external feedback (e.g., environmental feedback or human feedback).</p>
<p>Memory.The memory component records the historical thoughts, actions, and environmental observations generated during the agent execution [21], [26], [27].Based on the accumulated memory, agents can revisit and utilize the previous records and experience, so as to tackle the complex tasks more effectively.The memory management (i.e., how to represent the memory) and utilization (i.e., how to read/write or retrieve the memory) are essential, which directly impact the efficiency and effectiveness of the agent system.</p>
<p>Perception.The perception component receives the information from the environment, which can facilitate better planning.In particular, agents can perceive multi-modal inputs, e.g., textual inputs, visual inputs, and auditory inputs.</p>
<p>Action.Based on the planning and decisions made by the brain, the action component conducts concrete actions to interact with and impact the environment.One essential mechanism in action is to control and utilize external tools, which can extend the inherent capabilities of LLMs by accessing more external resources and extending the action space beyond textual-alone interaction.</p>
<p>Fig. 2: Basic Framework of LLM-based Agents</p>
<p>Advanced LLM-based Agent Systems</p>
<p>Multi-agent Systems.While a single-agent system can be specialized to solve one certain task, enabling the collaboration between multiple agents (i.e., multi-agent systems) can further solve more complex tasks associated with diverse knowledge domains.In particular, in a multi-agent system, each agent is assigned a distinct role and relevant expertise, making it specifically responsible for different tasks; in addition, the agents can communicate with each other and share the progress/information as the task proceeds.Typically, agents can work collaboratively (i.e., by working on different sub-tasks to achieve a final goal) or competitively (i.e., by working on the same task while debating adversarially).</p>
<p>Human-Agent Coordination.Agent systems can further incorporate the instructions from humans and then proceed with tasks under human guidance.This human-agent coordination paradigm facilitates better alignment with human preference and uses human expertise.In particular, during human-agent interaction, humans can not only provide agents with task requirements and feedback on the current task status, but also cooperate with agents to achieve goals together.</p>
<p>Related Surveys</p>
<p>LLM-based agents in general domains have been widely discussed and surveyed [21], [26], [28]- [32].Different from these surveys, this survey focuses on the design and application of LLM-based agents specifically for the software engineering domain.In software engineering domain, there have been several surveys or literature reviews on the general application of LLMs in software engineering [2], [3], [10], [32], [33].Different from these surveys, this survey specifically focuses on the agent perspective and is more comprehensive on the application of LLM-based agents for software engineering.In addition, He et al. [34] present a vision paper on the potential applications and emerging challenges of multi-agent systems for software engineering.Different from the vision paper, this work focuses on conducting a comprehensive survey of existing agent systems (including both single agent and multi-agent systems).In summary, to the best of our knowledge, this is the first survey specifically focusing on the literature on LLM-based agents for software engineering.</p>
<p>SURVEY METHODOLOGY</p>
<p>This section defines the scope of the survey and describes our approach to collecting and analyzing papers within the scope.</p>
<p>Survey Scope</p>
<p>We focus on the papers that apply LLM-based agents to tackle SE tasks.In the following, we specify the terms.</p>
<p> SE tasks.Following previous surveys on the application of LLMs in SE [2], [3], we focus on all SE tasks along the software life cycle, including requirements engineering, software design, code generation, software quality assurance (i.e., static checking and testing), and software improvement.</p>
<p> LLM-based agents.A standalone LLM can work as a naive "agent" since it can take textual inputs and produce textual outputs, leaving it no clear boundary between LLMs and LLM-based agents.However, this could result in an overly broad scope and significant overlap with existing surveys on LLM applications in SE [2], [3].Based on the widely-adopted consensus about AI agents, the key characteristic of agents is their ability to autonomously and iteratively perceive feedback from, and act upon, a dynamic environment [21].To ensure a more focused discussion from the perspective of agents, this survey focuses on LLM-based agents that not only incorporate LLMs as the core of their "brains", but also have the capacity to iteratively interact with the environment, taking feedback and acting in real time.</p>
<p>More specifically, we apply the following inclusion and exclusion criteria for paper collection.</p>
<p> Inclusion criteria.A paper will be included in our survey if it meets any of the following criteria: (i) The paper proposes a technique, framework, or tool for addressing specific SE tasks using LLM-based agents; (ii) The paper presents a general technique, framework, or tool applicable across various domains, provided that its evaluation includes at least one SE task; (iii) The paper presents an empirical study evaluating LLM-based agents on specific SE tasks. Exclusion criteria.A paper will be excluded from our survey if it meets any of the following criteria: (i) The paper does not involve any SE tasks; (ii) The paper only discusses LLM-based agents in the context of discussion or future work, without integrating them into the main approach; (iii) The paper only uses a standalone LLM for processing textual inputs and generating textual outputs, without any iterative interaction with the environment.</p>
<p>Paper Collection</p>
<p>Our paper collection process includes two steps: keyword searching and snowballing.</p>
<p>Keyword Searching</p>
<p>We follow established practices in SE surveys [35]- [39] by using the DBLP database [40] for paper collection.Recent research [39] has demonstrated that papers gathered from other prominent publication databases are typically a subset of those available on DBLP, which encompasses over 7 million publications from more than 6,500 academic conferences and 1,850 journals in computer science [41].DBLP also covers arXiv [42], a widely adopted open-access repository.</p>
<p>We employ an iterative trial-and-error approach, which is widely adopted in SE surveys [35], [43], to determine search keywords.Initially, all authors, with relevant research experience/publication in LLM and SE, convene to suggest papers relevant to our scope, yielding an initial set of relevant papers.Subsequently, the first two authors review the titles, abstracts, and introductions of these papers to identify additional keywords.We then conduct brainstorming sessions to expand and refine our search strings, incorporating related terms, synonyms, and variations.This process enables iterative enhancement of our search keyword list.The final keywords include ("agent" OR "llm" OR "language model") AND ("api" OR "bug" OR "code" OR "coding" OR "debug" OR "defect" OR "deploy" OR "evolution" OR "fault" OR "fix" OR "maintenance" OR "program" OR "refactor" OR "repair" OR "requirement" OR "software" OR "test" OR "verification" OR "vulnerab").</p>
<p>Based on the keywords, we conduct 57 searches on DBLP on July 1st, 2024, and obtain 10,362 hits.Table 1 presents the statistics of papers collected through keyword searching.The first two authors manually review each paper to filter out those not within the scope of this survey.As a result, we identify 67 relevant papers through this process.</p>
<p>Snowballing</p>
<p>To enhance the comprehensiveness of our survey, we adopt snowballing approaches to identify papers that are transitively relevant and expand our paper collection [35].Specifically, between July 1 and July 10, 2024, we conduct both backward and forward snowballing.Backward snowballing involves examining references in each collected paper to identify relevant ones within our scope, while forward snowballing uses Google Scholar to find relevant papers citing the collected ones.This iterative process continues until no new relevant papers are found.In this process, we retrieve an additional 39 papers.</p>
<p>Statistics of Collected Papers</p>
<p>As shown in Table 1, we have collected a total of 106 papers for this survey.Figure 3 presents the cumulative number of papers published over time, up to July 10, 2024.We observe that there is a continuous increase of research interest in this field, highlighting the necessity and relevance of this survey.Additionally, Figure 4 shows the distribution of publication venues for the papers, covering diverse research communities such as software engineering, artificial intelligence, and human-computer interaction.In particular, the majority of the papers are from arXiv and have not yet undergone peer review.This is expected, as this field is emerging and still undergoing rapid development.</p>
<p>ANALYSIS FROM SE PERSPECTIVES</p>
<p>In this section, we organize the collected papers from the perspective of different SE tasks.Figure 5 presents the SE It is worth noting that, LLM-based agents can be designed not only to tackle individual SE tasks but also to support end-to-end software development or maintenance processes involving multiple SE activities.From the collected papers, we observe LLM-based agents designed for (i) end-to-end software development and (ii) end-toend software maintenance.Specifically, agents for end-to-end software development can generate a complete program based on requirements by performing multiple SE tasks, such as requirements engineering, design, code generation, and code quality assurance (e.g., verification, static checking, and testing); agents for end-to-end software maintenance can generate patches for user-reported issues by supporting multiple SE maintenance activities, such as debugging (e.g., fault localization and repair) and feature maintenance.As shown in previous papers [2], [3], standalone LLMs are primarily specialized in tackling single SE tasks and are generally inadequate for complex end-to-end software development and maintenance processes.In contrast, LLMbased agents, through their components (i.e., planning, memory, perception, and action), coordination among multiple agents, and human interaction, provide the autonomy Distribution of LLM-based agents in different SE activities.In Figure 5, the numbers in brackets indicate the count of collected papers in each category.Notably, if LLM-based agents are designed for end-to-end software development or maintenance, they are only reported at the end-to-end level rather than at the level of individual tasks.Overall, we observe that the majority of LLM-based agents focus on individual-level SE tasks, especially for code generation and code quality assurance (e.g., static checking and testing); in addition, a portion of agents are designed for end-toend software development or maintenance tasks, indicating the promise of LLM-based agents in tackling more complex real-world SE tasks.</p>
<p>Requirements Engineering</p>
<p>Requirements Engineering (RE) is a crucial phase for initializing the software development procedure.Generally, it can cover the following phases [44]- [46].</p>
<p> Elicitation: New requirements are elicited and collected.</p>
<p> Modeling: Abstract yet interpretable models are used to describe requirements, e.g., Unified Modeling Language (UML) [47] and Entity-Relationship-Attribute (ERA) model [48].In real-world software development, RE can take lots of manual efforts due to the strong demand for massive interactions with various stakeholders.Although researchers have leveraged deep learning models (including standalone LLMs) to boost requirements engineering activities, most of them still remain on individual tasks during RE, such as classification [49], specification [50], information retrieval [51], evaluation [52], and enhancement [53] of existing requirements.Recently, multi-agent systems are designed to automate individual phases or multiple phases.Table 2 summarizes existing LLM-based agents specifically designed for RE, and Figure 6 illustrates their common pipeline.</p>
<p>Fig. 6: Pipeline of LLM-based Agents for Requirements Engineering</p>
<p>A. LLM-based Agents for Individual RE Phases.Elicitation [54] is a multi-agent framework for the requirement elicitation phase, which aims at mining requirements as completely as possible.Elicitation first initializes multiple agents with different personas within the designed context to cover various user viewpoints, and then makes them simulate interactions with the target product while documenting records (i.e., action, observation, and challenge) in each step.The potential requirements are eventually identified through the agent interviews and filtered on the provided criteria.Experimental results indicate that Elicitation can uncover and categorize hidden needs while reducing costs compared with conventional methodologies such as user studies.</p>
<p>SpecGen [55] is a system designed for generating requirement specifications of a given program.It contains two stages: conversation-driven specification generation and mutation-based specification generation.In the first stage, an agent generates Java Modeling Language (JML) requirement specifications [58], which are further validated by the external OpenJML verifier [59].The feedback is integrated into the prompt and kicks off iterative generation.In the second stage, specifications that fail the validation are mutated and verified to generate more diverse specifications.Experimental results demonstrate that SpecGen outperforms state-of-the-art approaches.
  SpecGen [55]   Arora et al. [56]      MARE [57]     
propose a multi-agent system to cover four phases of RE: elicitation, specification, analysis (synonymous with negotiation), and validation.For each phase, they explore the roles that can be simulated by LLM-based agents and systemically analyze the strengths and weaknesses.In the elicitation phase, agents play the role of stakeholders or requirement engineers and collect preliminary requirements, which are then formatted into structured documentation by another agent in the specification phase.Then, the analysis phase involves multiple stakeholder agents, aiming to evaluate, prioritize, and refine requirements.The validation phase marks the final validation by the stakeholder agents, and then the requirement documentation is decided and ready for subsequent design/implementation.MARE [57] is another multi-agent framework that covers multiple RE phases, including elicitation, modeling, verification, and specification.In the elicitation phase, a set of stakeholder agents express their needs, which would then be organized into a draft by the collector agent.Subsequently, the modeler agent identifies entities and relationships in the draft and constructs a requirement model; In the verification phase, the checker agent assesses the quality of the current requirements draft on its criteria and hands it over to the documenter agent, which will write the requirement specifications or report errors.All of these agents are equipped with predefined actions and can communicate within a shared workspace, enabling the seamless exchange of intermediate information.</p>
<p>Code Generation</p>
<p>Code generation has been extensively explored with the development of AI technology [33].Due to being pre-trained on massive textual data (especially large code corpus), LLMs demonstrate promising effectiveness in generating code for given code contexts or natural language descriptions.Nevertheless, the code generated by LLMs can sometimes be unsatisfactory due to issues such as the notorious hallucination [60].Therefore, beyond simply leveraging standalone LLMs for code generation, researchers also build LLMbased agents that can enhance the capabilities of LLMs via planning and iterative refinement.Figure 7 illustrates how existing LLMs extend standalone LLMs in code generation.</p>
<p>Code Generation with Planning</p>
<p>LLM-based agents employ advanced planning methods to extend the code generation capabilities of LLMs.Chainof-thought (CoT) [99] is the most popular strategy, which decomposes the code generation task into sub-tasks and achieves higher generation correctness [61], [70], [76], [84], [86], [91]- [93], [95].For example, CodeCoT [84] leverages CoT to break down the given requirements into steps that are described in natural language and then convert them to code.Some works employ dynamic planning strategies, where observations of the current action determine the next step [62], [85], [87], [88].For example, CodePlan [88] employs an adaptive planning algorithm that dynamically detects the affected code snippets in the repository and adapts the plan.However, there is still a gap between the narrative-based steps and the final generated code.Therefore, some works propose different representations to describe the planning steps, including pseudocode [95], intermediate code [61], or code skeleton [93], [97].For example, Agent-Coder [95] prompts the agent to generate pseudocode after problem understanding and algorithm selection phases, which serves as a draft for the final code.In addition, some existing works explore multi-path planning strategies.For example, LATS [76] simulates all possible generation paths as a tree and optimizes the plan with the Monte Carlo Tree Search algorithm.In MapCoder [98], the planning agent generates multiple plans along with confidence scores for sorting.The highest-scoring plan is used to generate the target code.If the code is erroneous, the plan with the next highest confidence is selected to continue the iterative generation process.</p>
<p>Code Generation with Iterative Refinement</p>
<p>One essential capability of agents is to act on the feedback from the environment.In the code generation scenario, some agents dynamically refine the previously-generated code based on the feedback via multiple iterations.We organize the relevant research based on the feedback sources, including model feedback, tool feedback, human feedback, and hybrid feedback. Reflexion [62], Self-Repair [63], AutoGen [64],</p>
<p>INTERVENOR [65], TGen [66], AutoCoder [67]     CAMEL [68], Li et al. [69], DyLAN [70]   SELF-DEBUGGING [71], SEIDR [72], F iX [73],</p>
<p>AlphaCodium [74], LDB [75], LATS [76], RRR [77]    </p>
<p>ToolCoder [78], SELFEVOLVE [79], KPC [80],</p>
<p>LEMUR [81], CODEAGENT [82], LLM4TDD [83],</p>
<p>CodeCoT [84], CodeAct [85], CoCoST [86],</p>
<p>InterCode [87], CodePlan [88], TOOLGEN [89]  
Self-Refine [90]   Flows [91]      MINT [92]     CodeChain [93]    ClarifyGPT [94]
   AgentCoder [95], Gentopia [96],</p>
<p>SoA [97], MapCoder [98]  </p>
<p>A.1: Peer-reflection.Peer-reflection refers to information exchange and interaction between multiple models.The most common paradigm is collaboration in multi-agent systems through role specialization and structured communication (e.g., code review) [62], [64], [68].This approach underscores the specialized responsibilities of each role and how they exchange information based on these responsibilities.Besides, when generating initial code, some works produce multiple results at once [69].Thus, a selection mechanism is employed to retain the most suitable result.Li et al. [69] use Bilingual Evaluation Understudy (BLEU) to calculate and aggregate the similarity scores of each initial code with the rest, retaining the result with the highest score.Moreover, there is also a modality that involves treating each agent role equally in expressing their opinions or engaging in debates to solve problems.DyLAN [70] allows multiple agents to engage in dynamic interactions over multiple rounds, organized into a multi-layer feed-forward network.The network employs an additional LLM ranker to analyze the responses of agents from the previous layer and selects the bestperforming agent to continue in subsequent interactions.</p>
<p>A.2: Self-reflection.Apart from the interaction between models, there are works that conduct self-refinement of a single model [71], [73], [90].This means that the current modification is based on the previous output of the model, iteratively optimizing through this approach.Le et al. [93] guide LLMs to generate modularized code, leveraging cluster representatives from previously generated sub-modules in each iteration.SELF-DEBUGGING [71] draws inspiration from the rubber duck debugging method used by programmers.During the explanation phase, the model provides a line-by-line explanation of the generated initial code.As Wang et al. [92] mention in their work, all models benefit from natural language feedback, with absolute performance gains by 2-17% each additional turn of natural language feedback.</p>
<p>B: Tool Feedback.The code generated by models can be of limited quality with numerous uncertainties.One solution to address this challenge is to equip LLM-based agents with tools that can collect informative feedback and assist the agents to generate and refine code.</p>
<p>B.1: Dynamic Execution Tools.One common group is to invoke the compiler, interpreter, and execution engine to directly compile or execute the code.This approach leverages the outputs and run-time behaviors, such as test results or compilation errors, as feedback for code improvement [79], [81]- [87], [92]- [98].</p>
<p>B.2: Static Checking Tools.Agents can get more restricted knowledge on code constraints by applying code analysis tools.For example, some agents apply static analysis tools to obtain syntactically-valid program symbols/tokens [89] or dependencies between code during code generation [82], [88].Including the analyzed information into the prompt can guide LLMs towards generating valid code.</p>
<p>B.3: Retrieval Tools.Agents can get the access to rich external resources by applying retrieval or searching tools.For example, some agents retrieve local knowledge repositories [86] such as private API documentations [78], [82] to facilitate better code generation; in addition, some apply online search engines [78], [82], [86], [96] or web crawling [80] to collect information such as content from relevant websites (e.g., StackOverflow and datagy.io)[78], [82], [86], [96] and official online documentations [80], [86].Including the retrieved resources into the prompt can provide additional knowledge for language models.Notably, ToolCoder [78] integrates the agent with online search and local documentation search tools that provide helpful information for both public and private APIs, alleviating the hallucination of LLMs.</p>
<p>C: Human Feedback.Another approach involves incorporating human feedback into the process, as humans play a critical role in clarifying ambiguous requirements.For instance, in software development, humans can check whether the generated code aligns with their initial intent.</p>
<p>Any discrepancies are often attributed to vagueness or incompleteness in the requirements, prompting a revision of the requirement documents [91], [92].To further minimize human involvement, some methods enable the agent to handle the task of observing execution results.For example, ClarifyGPT [94] automatically identifies potential ambiguities in the manually-given requirements and proactively poses relevant questions for humans; then the responses from humans are further used to refine the requirements.</p>
<p>D: Hybrid Feedback.Agents can also incorporate multiple types of feedback and progressively enhance each other as hybrid feedback.For example, a common approach is to combine tool feedback and model feedback.Specifically, an LLM receives error messages returned after executing a program or test case, and utilizes its contextual understanding to provide corresponding feedback output (e.g., explanations, suggestions, instructions, etc.) [62]- [67], [71]- [77], [91], [97].For example, in the multi-agent system INTERVENOR [65], a teacher coder is designated to observe the program execution results and provide error explanations and bug-fixing plans for the student coder to understand and regenerate the code.Furthermore, to accurately pinpoint issues, some works provide more finegrained environment feedback for the subsequent processing of the model.LDB [75] constructs a control flow graph, which divides the program into multiple blocks.It uses breakpoints to obtain the runtime values of variables, and the model compares these values against the requirements, assessing each block for anomalies.</p>
<p>Static Code Checking</p>
<p>Static code checking refers to examining the quality of code without executing the code.In particular, static code checking has been essential in the modern continuous integration pipeline, as it is efficient to identify diverse categories of code quality issues (e.g., different bugs, vulnerabilities, or code smells) before extensively executing the tests.In practice, it is common to adopt static analysis techniques to automatically detect bugs/vulnerabilities (i.e., static bug detection) or involve peer reviews to check the quality of code (i.e., code review).</p>
<p>Static Bug Detection</p>
<p>Preliminary studies [2], [3] show that LLMs can help identify potential quality issues in the given code under inspection.For example, fine-tuning LLMs on existing buggy/correct code or simply prompting LLMs has demonstrated promising effectiveness in identifying the bugs, vulnerabilities, or code smells in the given code snippets [15], [100].However, given the diversity and complexity of the root causes of different code issues as well as the long code contexts under inspection, standalone LLMs exhibit limited accuracy and recall in the real-world static code checking scenario [101].Recently, researchers have built LLM-based agents to enhance the capabilities of standalone LLMs in bug or vulnerability detection.Table 4 summarizes these agents and Figure 8 illustrates their common pipeline.</p>
<p>A. Co-inspection with Multi-agent.One effective vulnerability detection strategy focuses on the perspective of  [111] propose an approach for vulnerability detection through mutual discussion and consensus among different LLMs representing the testers and developers respectively.It mimics the real-world code review process that involves the collaboration of various roles within a team, enhancing the detection effectiveness through the interaction and reflection between LLMs.Moreover, GPTLENS [104] is an adversarial yet synergic framework for detecting vulnerabilities in smart contracts.It is designed as a two-stage method involving several auditor agents and a critic agent, all adopting GPT-4 as the backend.The auditor agents randomly generate potential vulnerabilities and corresponding reasoning as thoroughly as possible, while the critic scrutinizes and scores the candidates based on specific criteria.Their evaluation on 13 real-world smart contract CVEs indicates the effectiveness by an improvement of up to 76.9% in the identification rate.Fan et al. [105] conceive the Intelligent Code Analysis Agent (ICAA) concept for static code analysis.ICAA is an integration of AI models (e.g., the LLMs), engineering process designs, and traditional non-AI components (e.g., static analysis tools).As a dynamic decision-making system, ICAA can be composed of multiple sub-agents to enhance its functionality.Two examples of ICAA implementations include bug detection and code-intention consistency checking, both of which rely on the collaboration of various subagents, such as the ReAct-based Analysis Agent and the Report Agent.</p>
<p>B. Additional Knowledge from Tool Execution.Other approaches concentrate on strengthening the capabilities of LLMs via tool invocation.ART [102] is a general framework that boosts LLMs for unseen tasks with multi-step planning and effective tool utilization.ART includes a tool library (e.g., search tools), which can facilitate task decomposition and the appropriate invocation of tools.In addition, ART accommodates the integration of human inputs, allowing for seamless updates to its libraries.ART is evaluated on the multiple downstream tasks such as bug detection, and outperforms both few-shot prompting and the automated generation of CoT reasoning.Sun et al. [110] propose LLM4Vuln to enhance the vulnerability reasoning capabilities of LLMs by decoupling and augmenting them.The agent improves in several aspects.It retrieves external knowledge from both the raw text of vulnerability reports and summarized key sentences, which include information about the functionality of the vulnerable code and its root cause.This information is stored in a vector database.Additionally, the agent invokes tools to actively seek further context about the C. Combined with Traditional Static Bug Detection.Some researchers have combined LLM-based agents with traditional static checking techniques to improve their static bug detection capability.For example, LLIFT [115] is an LLM-assisted Use-Before-Initialization (UBI) bug detection tool.Based on undecided bugs reported by the powerful static analysis tool UBITect, LLIFT further leverages the capability of LLMs in code comprehension and summarization to identify UBI bugs in the Linux kernel.However, LLMs have the inherent limitation in accepting and understanding long input context (e.g., numerous functions in the Linux kernel) as well as the hallucination and stochasticity issues.LLIFT addresses these issues by augmenting the basic LLM with some agentic techniques.For example, instead of flooding the LLMs with all possible related code, it only responds to the LLM's demand for specific function definitions through static analysis, achieving a balance between context length and information completeness.Besides, it employs in-context learning, task decomposition, self-validation, and majority voting strategies to further alleviate hallucination and stochasticity and guarantee detection accuracy.This framework identifies 13 UBI bugs from 1,000 potential UBI bug instances reported by UBI-Tect [116], with a precision rate of 50%.E&amp;V [107] is an agent designed for conducting static analysis of code in the Linux kernel.The high-level workflow of E&amp;V is a loop of employing an LLM-based agent for static analysis through pseudo-code execution, verifying the output of pseudocode, and providing feedback for re-analysis.To avoid fact hallucination caused by missing necessary code snippets (e.g., caller and callee functions in inter-procedural analysis), a source code retrieval component is introduced to fetch needed functions or structures through traditional static analysis tools (e.g., Clang [108]).E&amp;V has been evaluated against 170 Linux Kernel bugs and correctly pinpointed the blamed function in 81.2% of the cases.IRIS [113] is an agent augmented with CodeQL (a static analysis tool) [114] for vulnerability detection.IRIS first utilizes CodeQL to extract candidate APIs in the given repository.Then, it labels these APIs as potential sources or sinks of the given vulnerability via querying the LLM-based agent, which will be further handed over to CodeQL for detecting vulnerable paths.The final verdict is achieved by prompting the LLM agent to analyze the vulnerable paths and surrounding code of the source and sink.</p>
<p>Code Review</p>
<p>Developers review each other's code changes to ensure and improve the code quality before merging the changes into the branch.To mitigate the manual efforts in code review, researchers leverage learning approaches to automate the code review procedure.In particular, code review is formulated as a binary classification problem (i.e., code quality classification [117]) or a sequence-to-sequence generation problem (i.e., review comment generation [118]), which are tackled by fine-tuning or prompting deep learning models (including LLMs).Different from these works, LLM-based agents mimic the real-world peer review procedure by including multiple agents as different code reviewers.Table 5 summarizes existing agents for code review.</p>
<p>CodeAgent [119] is a multi-agent system that simulates a waterfall-like pipeline with four stages (i.e., basic information synchronization, code review, code alignment, and document) and set up a code review team with six agents of different characters (i.e., user, CEO, CPO, CTO, coder, and reviewer).In the basic information synchronization phase, CEO, CPO, and coder agents analyze the input modality and programming language.After that, the coder and reviewer agents collaborate to conduct code review and produce the analysis report.In the code alignment phase, the coder and reviewer agents continue to revise the code based on the analysis reports.Finally, in the document phase, the CEO, Different from CodeAgent which constructs a team that can conduct various code review tasks, Rasheed et al. [120] design an approach with each agent specialized for a single code review task individually.Notably, it proposes four agents including the code review agent, bug report agent, code smell agent, and code optimization agent.Each agent is trained on relevant Github data and evaluated on 10 AI-based projects.The results demonstrate the potential of applying multi-agent systems in the code review task.</p>
<p>ICAA [105] designs a multi-agent system to identify code-intention inconsistencies.It first uses the Context &amp; Prompt Incubation Agent to collect necessary information from the code repository through a thinking-decision-action loop.The Consistency Checking Agent will then analyze collected information and identify inconsistencies, which will be handed over to the Report Agent to form a final report.</p>
<p>CORE [121] designs a system with two agents along with traditional static analysis tools to fix code quality issues automatically.Specifically, the Proposer agent takes the static analysis report, the suspicious file, and the issue documentation from language-specific static analysis tools (e.g., CodeQL [114]) and the tool provider (e.g., the QA team, and proposes candidate revisions for each suspicious file.After that, static analysis tools will prune revisions that still have issues, while the rest will be scored and re-ranked based on their likelihood of acceptance by the Ranker agent.</p>
<p>Testing</p>
<p>Software testing is essential for software quality assurance.LLMs have demonstrated promising proficiency in test generation, including generating test code, test inputs, and test oracles.However, generating high-quality tests in practice can be challenging, as the generated tests should not only be syntactically and semantically correct (i.e., both the inputs and oracles should satisfy the specification of the software under test) but also be sufficient (i.e., the tests should cover as many states of the software under test as possible).As shown by previous work [122], the tests generated by standalone LLMs still exhibit correctness issues (i.e., compilation errors, run-time errors, and oracle issues) and unsatisfactory coverage.Therefore, researchers build LLM-based agents to extend the capabilities of standalone LLMs in test genera-tion.We organize these works based on the test levels (i.e., unit testing and system testing).Unit testing checks the isolated and small unit (e.g., method or class) in the software under test, which helps quickly identify and localize the bugs, especially for complicated software systems.Yuan et al. [122] perform a study showing the potentials of LLMs (e.g., ChatGPT) in generating unit tests with decent readability and usability.However, the unit tests generated by standalone LLMs still exhibit compilation/execution errors and limited coverage.Therefore, recent works have built LLM-based agents that primarily extend standalone LLMs by iteratively refining the generated unit tests towards better correctness, coverage, and fault detection capabilities.Table 6 summarizes the existing LLMbased agents for unit test generation, and Figure 9 illustrates their common pipeline.</p>
<p>A. Iterative Refinement to Fix Compilation/Execution Errors.The test cases directly generated by LLMs can exhibit compilation or execution errors.Therefore, inspired by program repair [128], LLM-based agents further eliminate such errors by iteratively collecting the error messages and fixing the buggy test code [122]- [124].For example, TestPilot [123] generates tests by constructing detailed prompts, including the function signature, implementation, documentation, and usage examples; it reflects on the feedback of failing tests and error messages to refine prompts and generate corrective tests iteratively.ChatTester [122] leverages LLMs to understand the intention of focal methods, and then generates a corresponding unit test; in addition, the iterative  [126] is an LLM-powered test generation system designed to achieve high coverage rates.It dissects the task by segmenting the source code and employs the SlipCover tool [129] to conduct a detailed coverage analysis.Using an iterative approach, CoverUp refines its prompts to focus on areas of the code that lack coverage, thereby enhancing the overall quality and comprehensiveness of the generated test suite.Yang et al. [125] propose TELPA to enhance the coverage of hard-to-reach branches in software testing.Its methodology involves a two-pronged program analysis: backward and forward method invocation analysis, for a better understanding of the methods with uncovered branches.TELPA also employs counter-example sampling to guide LLMs toward generating novel tests that diverge from ineffective ones.The feedback-based process refines these tests iteratively through a CoT strategy, further improving coverage.</p>
<p>C. Iterative Refinement to Increase Fault Detection Capabilities.MuTAP [127] is a single LLM-based agent system that aims at generating unit tests of better bug detection capabilities with the feedback of mutation testing.It employs prompt augmentation with surviving mutants and refining steps to correct syntax and intended behavior.During each iteration, the LLM first generates initial test cases and selfrefines their syntax errors and wrong behaviors, with the help of the Python parsing tool executing the tests.Then the tests run against the mutated programs, while the surviving mutants serve as feedback to direct the LLM in improving the test cases.</p>
<p>System Testing</p>
<p>System testing is a comprehensive process that assesses an integrated software system/component to guarantee that it fulfills its specification and operates as intended across diverse settings.For example, fuzzing testing and GUI (Graphical User Interface) testing are common testing paradigms at the system level.Leveraging LLMs for system testing can be challenging, as generating valid and effective system-level test cases should satisfy the constraints that are contained implicitly and explicitly in the specifications or domain knowledge of the software system under test.LLMbased agents are designed to better incorporate the domain knowledge of the software system under test compared to generating system-level tests via standalone LLMs.We then organize these works according to the software systems under test.Table 7 summarizes the existing agents for different software systems.</p>
<p>A. OS Kernel.KernelGPT [130] is an LLM-based agent for kernel fuzzing.The analysis agent serves as the brain to automatically generate driver syscall specifications.It identifies drivers first and iteratively completes each specification component, during which it can determine whether additional information is needed based on its previous memory.A code extractor (implemented using LLVM toolchain [132]) is invoked to parse the kernel codebase for the provision of source code information.KernelGPT finally invokes the Syzkaller tool [131] (e.g., syz-extract) and receives its feedback messages to validate and correct the generated syscall specifications iteratively.</p>
<p>B. Compiler.WhiteFox [133] encompasses two LLMbased agents working together, an analysis agent and a generation agent.The former examines the low-level optimization source code and produces requirements on the high-level test programs that can trigger the optimizations, while the latter crafts test programs based on summarized requirements.The generation agent further incorporates tests that have successfully triggered optimizations as feedback during the iterative process, thereby producing more satisfactory tests.LLM4CBI [134] is a single agent that aims at isolating compiler bugs by generating test cases of better fault detection capabilities.The agent utilizes tools to collect static information about the program (e.g., srcSlice [136] for data flow) to construct precise prompts to guide the LLM for program mutation.The memorized component records meaningful prompts and selects better ones to instruct LLMs to generate variants.The generated programs undergo validation by static analysis (e.g., the Frama-C tool [138]), and the feedback helps LLMs to avoid the same mistakes.The final test cases are used to identify suspicious files with spectrum-based fault localization techniques.</p>
<p>C. Mobile Applications.LLM-based agents are proposed to automate the testing process of mobile applications, including GUI testing, bug replay, and user acceptance testing.</p>
<p>C.1: GUI Testing.Some agents are developed to execute GUI testing for mobile applications.GUI testing is a commonly used software testing method aimed at verifying whether the user interface meets service specifications and user requirements.Previous LLM-based GUI testing approaches lack adequate autonomy, long-term planning, and coherence [154], [155].The emergence of LLM-based agents enables GUI testing to focus more on higher-level test objectives [139], [144], [145], such as clear task objectives, without  [139] propose a framework called GPTDroid, where the LLM iterates the entire process by perceiving GUI page information, generating test scripts in the form of Q&amp;A, executing these scripts through tools, and receiving feedback from the application.GPTDroid keeps a long-term memory to retain testing knowledge, which would help to improve the reasoning process.The DroidAgent [144] framework employs multiple LLM-based agents coordinating through different memory modules and can set its own tasks according to the functionalities of the apps under test.It is composed of four LLM-based agents: planner, actor, observer, and reflector, each with specific roles and supported by memory modules that enable long-term planning and interaction with external tools.AXNav [145] is another multi-agent system designed for replaying accessibility tests on mobile apps.It includes the planner agent, the action agent, and the evaluation agent, which together form the LLM-based UI navigation system.These agents translate test instructions into executable steps, conduct tests on a cloud-based iOS device, and summarize the test results in a chaptered video annotated with potential issues in the application, respectively.</p>
<p>C.2: Bug Replay.For automating Android bug replay, Feng et al. [15] introduce AdbGPT.Equipped with the knowledge of Step-to-Reproduce (S2R) entity specifications (i.e., predefined actions and action primitives), AdbGPT analyzes bug reports to translate identified entities into a sequence of actions for bug reproduction using the CoT strategy.It then perceives GUI states dynamically and maps the S2R entities to actual GUI events to replicate the reported bug.</p>
<p>C.3: User Acceptance Testing.To increase the automation of the user acceptance testing process, Wang et al. [148] propose XUAT-Copilot.The system is primarily comprised of three LLM-based agents responsible for action planning, state checking, and parameter selection, as well as two additional modules for state awareness and case rewriting.These agents interact with the testing equipment collaboratively, making human-like decisions and generating action commands.</p>
<p>D. Web Applications.RESTful APIs are popular among web applications as they provide a standardized, stateless, and easily integrable means of communication that enhances scalability and performance through a resourceoriented approach.RESTSpecIT [149] leverages LLMs to automatically infer RESTful API specifications and conduct black-box testing.Given an API name, RESTSpecIT generates and mutates HTTP requests through a reflection loop.By sending these requests to the API endpoint, it analyzes the HTTP responses for inference and testing.The LLM uses valid requests as feedback to refine the mutations in each iteration.Requests are validated based on the status code and message of the returned response.</p>
<p>E. Universal Software Categories.Some agent systems are not designed with a task-specific workflow, enabling them to be universally applicable across various target software systems.Xia et al. [150] present Fuzz4All, the first universal LLM-based fuzzer for general and targeted fuzzing across multiple programming languages.For a higher costeffectiveness ratio, Fuzz4All consists of two agents, (i) the distillation LLM for user input distillation and initial</p>
<p>Debugging</p>
<p>Software debugging typically includes two phases: fault localization [157] and program repair [158].In particular, fault localization techniques aim at identifying buggy elements (e.g., buggy statements or methods) of the program based on the buggy symptoms (e.g., test failure information); then, based on the buggy elements identified in the fault localization phase, program repair techniques generate patches to fix the buggy code.In addition, recent works also propose unified debugging to bridge fault localization and program repair in a bidirectional way [159].We then organize the works in LLM-based agents for debugging into three parts, i.e., fault localization, program repair, and unified debugging.Learning-based fault localization has been widely studied before the era of LLMs, which typically trains deep learning models to predict the probability of each code element being buggy or not [164].However, precisely identifying the buggy element in the software is challenging, given the large scale of the software systems as well as the massive and diverse error messages, which are often beyond the capabilities of standalone learning models including LLMs.Therefore, recent works build LLM-based agents, which incorporate multi-agents and tool usage to help LLMs tackle these challenges.Table 8 summarizes the existing LLMbased agents for fault localization, and Figure 10 illustrates their common pipeline.</p>
<p>A. Multi-agent Synergy.AgentFL [160] is a multi-agent system for project-level fault localization.The main insight of AgentFL is to scale up LLM-based fault localization to project-level code context via the synergy of multiple agents.The system consists of four distinct LLM-driven agents: test code reviewer, source code reviewer, software architect, and software test engineer.Each agent is customized with specialized tools and a unique set of expertise.With the four agents, AgentFL streamlines the project-level fault localization process by breaking it down into three phases: fault comprehension, codebase navigation, and fault confirmation.</p>
<p>RCAgent [162] is a multi-agent system for root cause analysis in industrial cloud settings.RCAgent includes two components: the controller agent and expert agents.The controller agent oversees the comprehensive thoughtaction-observation cycle, while the expert agents act for specialized tasks and can be utilized by the controller agent.A key-value store is employed for the controller agent to memorize the observation information (e.g., logs and table entries) to help the decision-making, as well as handling the context length constraint.The expert agents perform code analysis and log analysis tasks respectively, and their summarized results are fed back to the controller agent as observation.The agents can invoke tools for information collection (e.g., log data and repositories retrieval) or memory retrieval, through the function calling.Besides, a selfconsistency mechanism is built to enhance the performance.</p>
<p>B. Tool Invocation.AUTOFL [163] is a single-agent system, which enhances standalone LLMs with tool invocation (i.e., four specialized function calls) to better explore the repository.It first performs root cause explanation, invoking tools to oversee the source code repository for pertinent information, requiring only a single failing test and its failure stack.During this stage, it autonomously decides whether to continue function calling or to terminate with the production of root cause explanation.Subsequently, a post-processing step is used to correlate the outputs with exact code elements, aiming at bug localization.In addition, AgentFL [160] and RCAgent [162] also incorporate tool invocation (e.g., static analysis, dynamic instrument, and code base navigation) into their framework.</p>
<p>Program Repair</p>
<p>Fine-tuning and fixed prompting have been the most widely adopted paradigms for program repair techniques based on standalone LLMs.In particular, program repair is formulated as a translation problem [165] (i.e., translating the buggy code to correct code) or a generation problem [12] (e.g., infilling the correct code in the buggy code context).However, patches generated by LLMs in a single iteration are not always correct; they may fail to pass all the tests or may be overfitting to the test cases.Therefore, existing LLM-based agents all follow an iterative paradigm to refine patch generation based on the tool or model feedback in each iteration.Table 9 summarizes the existing LLM-based agents for program repair, and Figure 11 illustrates their common pipeline.ChatRepair [128], [166] is the first automated approach to iteratively refine patch or program generation based on environmental feedback.In each iteration, ChatRepair leverages tools to compile and execute the generated patches, and generates new patches based on the compilation/execution feedback and also earlier patch attempts in the same session.</p>
<p>CigaR [169] is a similar agent system for function-level program repair.CigaR leverages feedback to refine its outputs iteratively and decides to reboot the repair process when needed, ensuring the production of both plausible and diverse patches.</p>
<p>RepairAgent [171] adopts a more agentic design and improves the iterative refinement procedure by making the hard-coded feedback mechanism more flexible.In particular, RepairAgent allows the LLM itself to decide when or which tool to invoke.In addition to the basic tools (e.g., compilation tools and test execution tools) used in previous work, RepairAgent further includes tools for code reading, codebase searching, and hypotheses stating/discarding.</p>
<p>AutoSD [172] is a multi-agent system that iteratively fixes the buggy program via simulating the scientific debugging [179].AutoSD includes four components: LLM-based hypothesis generator, execution-based validator, LLM-based conclusion maker, and LLM-based fixer.In each iteration, the generator first generates a hypothesis about the bug, then invokes the debugger tool for hypothesis validation; the conclusion maker further identifies whether the hypothesis is rejected or not; and the fixer finally returns potential patches with explanations.</p>
<p>ACFIX [174] is a multi-agent system for fixing the access control vulnerabilities in smart contracts.By specializing LLMs with different roles, ACFIX includes a Rolebased Access Control (RBAC) mechanism identifier, a rolepermission pair identifier, a patch generator, and a validator.In particular, the validator checks the validity of the generated patches with both tool feedback (static grammar rule checking) and model feedback (multi-agent debate process).The feedback is further provided to iteratively refine the patch.</p>
<p>FlakyDoctor [175] is an agent to repair flaky tests.It takes into consideration test execution results and the location of test failures.Following this, the system generates targeted repairs and tests them for validation.This process is iterative, with the aim of continually refining the repairs until the issue of test flakiness is resolved.[190]  -Pre-defined Ordered Natural Language AISD [191]  Waterfall Pre-defined Ordered Natural Language LLM4PLC [192]  -Pre-defined Ordered Natural Language CodePori [193]  -Pre-defined Ordered Natural Language LCG Waterfall [194]  Waterfall Pre-defined Ordered Natural Language LCG Scrum [194]  Agile Pre-defined Debate Natural Language CodeS [195]  -Pre-defined Ordered Natural Language Qian et al. [196]  -Pre-defined Ordered Natural Language CTC [197]  Waterfall Pre-defined Dual-role Natural Language AgileCoder [198]  Agile Pre-defined Dual-role Natural Language comprehend, utilize, and unify the outputs of both fault localization and program repair.FixAgent [159], a multi-agent system for unified debugging, enables end-to-end fault localization, bug repair, and bug analysis.Based on manual debugging (e.g., rubber duck debugging), FixAgent uses agent specialization and synergy (i.e., LLM localizer, LLM repairer, LLM crafter, and LLM revisitor) to incorporate key variable tracking and program context comprehension.FixAgent can fix 79 out of 80 bugs in the QuixBugs [168] benchmark.</p>
<p>LDB [75] is an agent for end-to-end fault localization and program repair.LDB divides the buggy program into basic blocks according to a control-flow graph, and leverages LLMs to detect the incorrect blocks with run-time execution values and then to provide refinement suggestions.</p>
<p>End-to-end Software Development</p>
<p>Given the high autonomy and the flexibility from multiagent synergy, LLM-based agent systems can further tackle the end-to-end procedure of software development (e.g., developing a Snake Game application from scratch) beyond an individual phase of software development.In particular, alike the real-wold software development team, these agent systems can cover the entire software development life cycle (i.e., requirements engineering, architecture design, code generation, and software quality assurance) by incorporating the synergy between multiple agents that are specialized with different roles and relevant expertise.Table 10 summarizes the existing LLM-based agents for end-to-end software development.</p>
<p>Software Development Process Model</p>
<p>Real-world software teams often follow classic software process models (e.g., waterfall [199], incremental model [200], unified process model [201], and agile development [202]) to facilitate a more standardized software development life cycle.Existing LLM-based agents for end-to-end software development also design their workflows according to common software process models, e.g., waterfall process model and agile development.Figure 12 illustrates how existing LLM-based agents go through different process models.</p>
<p>A. Waterfall Process Model.The majority of existing LLM-based agent systems (e.g., AISD [191], LCG [194], Chat-Dev [186], CTC [197], and Self-Collaboration [4]) follow the classic waterfall process model for software development.</p>
<p>The traditional waterfall process model [199] is a linear and sequential software development workflow that divides the project into distinct phases, i.e., requirements engineering, design, code implementation, testing, deployment, and maintenance.Once a phase is finished, the project moves forward to the next phase without iteration.Based on this process, some end-to-end software development agents [4], [187], [191], [194] further extend the traditional waterfall process by including iterations in specific phases to ensure the high quality of the generated content.For example, the results of the testing phase might be fed back to the developer agent to revise the generated code; MetaGPT [187] further integrates the waterfall model with human-like Standardized Operating Procedures (SOPs), which assign responsibilities to each role and standardize the intermediate outputs, promoting collaboration among different team members.</p>
<p>B. Agile Development.Some works explore the potential of LLM-based agents with the agile development, including Test-Driven-Development (TDD) [194] and Scrum [194], [198].TDD prioritizes writing tests before the actual coding and fosters a cycle of writing test suites, implementing the code to pass the test suites, and concluding with a reflective phase to refinement.Scrum is an agile software development process model that breaks down software development into several sprints, achieving complex software systems through iterative updates.Experiments on function-level code generation benchmarks show that the Scrum model can achieve the best and most stable A. Role Categories.The roles in existing agents are primarily designed by simulating real-world software development teams or specialized by the workflow.</p>
<p>A.1: Simulating Real-world Software Teams.Most end-toend frameworks simulate the real-world software development teams and assign basic roles including managers (e.g., project managers or product managers), requirement analyzers, designers, developers, and quality assurance experts (e.g., software testers or code reviewers) to cover the entire pipeline of software development [4], [187], [191], [193], [194], [198].In addition to these common roles, there are some special roles that can be assigned to tackle fine-grained tasks.For example, a Scrum master role is also included into the requirements analysis and planning tasks for the agents with the Scrum workflow [194], [198]; and CEO/CTO roles are also included in some agents to complete the design task [186], [197]; in addition, there are special supervisor roles in some agents to ensure the smooth progress of the collaboration (e.g., providing coordination or critiques), such as the oracle roles in previous work [185] and the action observer in AutoAgents [189].The detailed categories of roles in existing agents are discussed in Section 5.2.1</p>
<p>A.2: Specialized by Workflow.Instead of simulating the real-world development teams, some agents break down roles according to the agent framework workflow.For example, CodeS [195] decomposes the complex code generation task into the implementation of repository, file, and method layers, and sets up the roles of RepoSketcher, FileSketcher, and SketchFiller.Co-Learning [190] and its subsequent work [196] abstract the code generation process into instruction-response pairs, thus only setting up the roles of instructor and assistant.</p>
<p>B. Role Creation.The roles in multi-agent systems are either created in a pre-defined way or in a dynamic way.</p>
<p>B.1: Pre-defined.The majority of specialized roles are predefined by the agent framework [4], [183], [186], [187], [190], [191], [193]- [198].In other words, the roles are fixed by the agent for each task.</p>
<p>B.2: Dynamic Creation.In addition to the pre-defined roles, some agents assign roles in a dynamic way, which can equip multi-agent systems with more flexibility.For example, AutoAgents [189] designs a drafting stage that aims at determining the roles of the multi-agent group via the communication between two meta agents: the planner and the agent observer; in addition, AgentVerse [188] sets up a group of different roles through an expert recruitment stage.Talebirad et al. [185] propose a novel framework and enable an agent to spawn additional agents to the system.Such dynamic strategies aim at creating roles in a more diverse and flexible way.</p>
<p>Collaboration Mechanism in Multi-agent</p>
<p>Within the multi-agent systems for end-to-end software development, it is essential to schedule how each agent is coordinating with each other.We then discuss the collaboration mode and the communication protocol adopted in existing agents.</p>
<p>A. Collaboration Mode.In particular, there are mainly two collaboration modes in multi-agent systems for end-toend software development, i.e., the ordered mode and the unordered mode.</p>
<p>A.1: Ordered Mode.It is a sequential mode wherein each agent makes decisions independently and uses optional feedback mechanisms to improve quality of their generated content.Ordered mode is the most prevalent collaboration mode adopted in existing agent systems [4], [186]- [193], [195]- [198].Previous research [188] suggests that this approach is more suitable for software development, as it focuses on producing only the final refined decision.</p>
<p>A.2: Unordered Mode.It primarily introduces an unordered debate mechanism, where multiple agents present their opinions separately and equally, with the ultimate decision reached via summarization.For example, LCG [194] involves the sprint meeting in the Scrum process model, wherein participating agents propose their opinions and share them with all other agents through a buffer.The Scrum master ultimately summarizes and extracts user stories.Besides, some works adopt a multi-role mechanism  [186], [190], [196], [197] CAASD [191] 72 Software Description (50 words) Multiple Files Python [186], [187], [191] SoftwareDev [187] 70 Software Description (30 words) Multiple Files Python [186]- [188] SketchEval [195] 19 README (421 words) Structured Multiple Files Python [186], [195] ProjectDev [198] 14 Software Description (262 words) Multiple Files Python [186], [187], [198] HumanEval [170] HumanEval-ET [203] 164 Function Description (68 words) Single Function Python [4], [187]- [189], [193], [194], [198] MBPP [204] MBPP-ET [203] 974 Function Description (15 words) Single Function Python [4], [187], [193], [194], [198]  #Errors [4], [186], [187] [188]- [190] [193], [194], [196] [197], [198] Similarity SketchBLEU [195] Cosine Distance [186], [190], [195] [196], [197] Costs Running Time Token Usage Expenses #Sprints [187], [198] Manual Efforts Human Revision Costs [187] Generated Code Scale Line of Code Code Files Completeness [186], [187], [190] [196], [197] to ensure the generation quality [186], [190], [196]- [198].Instead of passing intermediate results from one agent to another, these works assign two agents to work together to complete a sub-task in a communication way.For example, in ChatDev [186] and CTC [197], agents with different roles will collaborate to complete specific tasks (e.g., the system design is achieved through communication between the CEO and CTO).</p>
<p>B. Communication Protocol.</p>
<p>Within the multi-agent systems, agents communicate with other agents to exchange information.In particular, there are two communication protocols, i.e., the pure natural language and the structured communication.</p>
<p>B.1: Natural Language.The most common communication protocol is direct dialogue [4], [186], [188], [189], [191], [193], [194], which leverages natural language to exchange information.This approach allows for flexible expression of intent and is close to human communication.</p>
<p>B.2: Structured.Some agents (e.g., MetaGPT [187]) structure communication by having agents exchange documents and diagrams instead of relying solely on dialogue, as pure natural language may be insufficient for solving complex tasks due to distortion in multi-turn communication [187].</p>
<p>Agent Evaluation</p>
<p>Given the complexity of end-to-end software development, researchers further build diverse benchmarks and metrics for a comprehensive evaluation.</p>
<p>A. Benchmarks.Table 11 summarizes the benchmarks used for evaluating existing LLM-based agents for end-toend software development.In particular, we can observe that there are still a large number (e.g., 7) of papers using the classic code generation benchmarks (e.g., HumanEval [170] or MBPP [204]) for evaluating end-to-end software development.Although these traditional code benchmarks can represent end-to-end software development to some extent, they still involve simplified, small-scale development tasks (i.e., input of short function descriptions and output of a single function, as shown in Table 11).In addition, there are five more complicated benchmarks that aim at simulating the end-to-end software development, i.e., SRDD [186], [190], [196], [197], CAASD [191], SoftwareDev [187], SketchEval [195], and ProjectDev [198].The tasks in these benchmarks include more complicated and longer requirement description (e.g., the average length of software description in Pro-jectDev is 262 words), and their expected outputs are supposed to contain multiple files.In particular, the benchmark SketchEval is built upon the real-world GitHub repositories, and its input descriptions are extracted from the README file of the software while its output expects multiple files that are organized in a repository structure.</p>
<p>B. Metrics.Table 12 summarizes the metrics used for evaluating existing LLM-based agents for end-to-end software development.In fact, given the difficulty of generating complicated program, it can be possible that the generated program cannot perfectly pass the tests.Therefore, in addition to the common metrics (e.g., Pass Rate or Pass@K) that execute the generated program for validation, there are multiple dimensions for assessing how existing agents perform in end-to-end to software development.In particular, there are (i) the similarity metrics between the generated program and the ground truth (e.g., SketchBLEU [195] measures the structure similarity), (ii) the costs of executing or generating the program, (iii) the manual efforts to further refine the generated program, and (iv) the scale of the generated</p>
<p>End-to-end Software Maintenance</p>
<p>Software systems undergo maintenance as requirements continuously change (i.e., adding, deleting, or modifying features) or unexpected software behaviors arise.In practice, users report unsatisfactory behaviors that they encounter; developers then diagnose the reported issues and modify the software to fix them.Such an end-to-end software maintenance process can be time-consuming and labor-intensive in practice, as it involves multiple phases including understanding user-reported issues, localizing code for maintenance, and precisely editing code to address issues.Recently, there has been an increasing number of multi-agent systems aiming at automatically solving issues of real-world software projects.Table 13 summarizes the characteristics of these agents.</p>
<p>Common Pipeline</p>
<p>Figure 13 illustrates the pipeline of existing LLM-based agent systems for end-to-end software maintenance.Basically all of the existing agents follow a common pipeline of three phases, i.e., issue localization, patch generation, and patch verification, where different agents incorporate different strategies to tackle each phase.In addition, some agents further include additional phases, i.e., preprocessing, issue reproduction, issue localization, task decomposition, patch generation, patch verification, and patch ranking.</p>
<p>A. Preprocessing.To better understand the whole repository, some agents first perform preprocessing to prepare pre-knowledge before the entire procedure.The agent system RepoUnderstander [209] constructs a knowledge graph of the entire code repository to facilitate the subsequent process of issue localization.Meanwhile, Agentless [211], which is simplistic and less agentic, simply turns the whole project into a tree-like structure that demonstrates all directories and files of the repository in a hierarchical format, which facilitates the issue localization phase.In CODER [208], a manager agent first chooses a plan from several workflows pre-defined by human experts.In MASAI [210], the test template generator is used to analyze the testing setup of the repository and generate a test template with the running command, which further serves as an example for the following issue reproduction phase.</p>
<p>B. Issue Reproduction.A test script that triggers the unexpected behaviors users encounter is essential for issue resolution.It not only helps with issue localization but also serves as the verification criterion for patch correctness.However, in practice, users do not always provide such reproduction tests when they report issues; and such reproduction tests are often added by developers after they fix the buggy software.Therefore, some agents design the issue reproduction phase that aims at generating the test script that can trigger the unexpected behaviors encountered by users.For example, SWE-agent [207] and CodeR [208] directly leverage LLMs to generate reproduction tests based on issue descriptions when there is no existing reproduction script in issue descriptions.However, generating reproduction tests can be challenging, as the tests must be executable and ideally should fail on the buggy software version while passing on the fixed version.Therefore, to increase the success rate of issue reproduction, the multi-agent system MASAI [210] includes a two-stage approach for issue reproduction, which first investigates the test framework and existing tests for generating a sample test template (generated in the preprocessing phase) and then uses the template as a demonstration to create the reproduction script.</p>
<p>C. Issue Localization.Issue localization is one of the most important phases where the agents are supposed to precisely identify the code elements (e.g., classes, methods, or code blocks) that are related to issues and should be edited.We then summarize the common localization strategies used in existing LLM-based agents.</p>
<p>C.1: Retrieval-based Localization.All the existing agents use the retrieval-based strategy as the basis for issue localization, which identifies the relevant code elements based on their similarity with issue descriptions.For example, in MAGIS [205], all code files are compared to issue descriptions via BM25 [212], and the Top-K relevant code files are selected as the potential issue locations.However, only using retrieval-based strategy can be insufficient and often at coarse granularities (e.g., files).Therefore, some agents further extend the basic retrieval with other strategies, e.g., navigation-based localization, spectrum-based localization, and simulation-based localization.</p>
<p>C.2: Navigation-based Localization.This strategy provides agents with a set of code search actions that can navigate through the entire code repository to check all directories and files.For example, the issue localization phase of SWEagent [207] uses several pre-defined search-based interfaces to locate the target directories or files and then to view the code snippets in the target file through scrolling interfaces.Similarly, MASAI [210] assigns an edit localizer that can navigate the repository to find the related code snippets.AUTOCODEROVER [206] designs a stratified context retrieval process, which allows the LLM itself to decide whether to further refine the location based on the current context, thus forming an iterative navigation process.Agentless [211] provides the hierarchical structure of the target repository and instructs the LLM to gradually localize files, classes, functions, and concrete edit locations.</p>
<p>C.3 Spectrum-based Localization.Some agents integrate the traditional fault localization approaches, especially spectrum-based fault localization techniques [157], which calculate the suspiciousness score of code elements based on their coverage of failed tests and passing tests.For example, AUTOCODEROVER [206] explores spectrum-based techniques for issue localization by using the ground-truth reproduction tests provided in SWE-bench Lite, which improves issue resolution rate from 17.00% to 20.33%.While AUTOCODEROVER explores the spectrum-based fault localization in an ideal case (as the ground-truth reproduction tests are not always available in practice), CODER [208] investigates the improvement of the spectrum-based fault localization in a more practical setting by using tests generated in the issue reproduction phase.In particular, CODER calculates the suspiciousness scores based on the coverage of the reproduction tests, and then combines them with the basic retrieval-based strategy (i.e., BM25 similarity between code elements and issue descriptions) via weighted computation.</p>
<p>C.4 Simulation.Simulation is a special technique adopted by RepoUnderstander [209] for issue localization.It applies the classic Monte Carlo Tree Search algorithm.By recursively incorporating nodes of the high BM25 score with the issue, it evaluates and ranks the most relevant paths in the repository knowledge graph.The collected code is then summarized for issue localization.</p>
<p>D. Task Decomposition.Before generating patches, some agents decompose the task into more fine-grained sub-tasks.For instance, in MAGIS [205], its manager agent breaks down the issue into file-level tasks and delegates them to a newly-formed development team; similarly, in RepoUnderstander [209], its summary agent summarizes the collected code and issue description, and then outlines the fine-grained steps for issue resolution.</p>
<p>E. Patch Generation.In this phase, the agents generate patches for the localized suspicious code elements.The input context of this phase typically includes the issue/task description and the suspicious code elements for modification [205], [207], [210], [211].In addition, some agents (e.g., AUTOCODEROVER [206], CodeR [208], and RepoUnderstander [209]) further refine the input contexts by including relevant cross-file code contexts that are collected by retrieval APIs.</p>
<p>F. Patch Verification.Agents further verify the correctness of the generated patches, which is challenging as the reproduction tests are not always available in practice.Therefore, agents incorporate different verification strategies.</p>
<p>F.1: Code Review.Some agents (e.g., MAGIS [205]) design a quality assurance agent to review the quality of generated patches.</p>
<p>F.2: Static Checking.Some agents (e.g., AU-TOCODEROVER [206], RepoUnderstander [209], MASAI [210], Agentless [211], and SWE-agent [207]) use static checking approaches to assess the syntactic correctness, indentation, and compatibility of the generated patch with the repository environment.</p>
<p>F.3: Dynamic Checking.Since the static checking cannot find the semantic violation of the patches, some agents (e.g., CodeR [208] and MASAI [210]) further perform dynamic checking by executing the reproduction test on the patch.The patch that passes the reproduction test can be considered as effectively resolving the issue.In particular, existing reproduction tests are reused (if available); otherwise, reproduction tests generated during the issue reproduction phase are used.Agentless [211] also implements a dynamic checking approach by conducting regression testing to filter out incorrect candidate patches.</p>
<p>G. Patch Ranking.Since the patch verification phase can sometimes be insufficient for filtering out all the incorrect patches, some agents further include a patch ranking phase to identify the patch with the highest probability of being correct.For example, in MASAI [210], a ranker agent is responsible for ranking all potential patches based on the issue description and reproduction tests; In Agentless [211], all patches are normalized and re-ranked based on the number of occurrences with the majority voting strategy.</p>
<p>Benchmarks</p>
<p>To evaluate how LLM-based agents tackle end-to-end software maintenance, researchers build benchmarks from realworld Github issues, including SWE-bench [213], SWEbench Lite [214], SWE-bench Lite-S [211], and SWE-bench Verified [215].Table 14 summarizes the evolution timeline of existing benchmarks for end-to-end software maintenance.SWE-bench [213] is the first benchmark for end-to-end software maintenance, which consists of 2,294 real-world GitHub issues across 12 popular Python repositories.Each task in SWE-bench includes an original text from a GitHub issue (i.e., the issue description or problem statement), the entire code repository, the execution environment (i.e., Docker environment), and validation tests (i.e., tests that are hidden from the evaluated agents).However, the full SWE-bench benchmark can take too much evaluation costs and it contains particularly difficult or problematic tasks [211], which can underestimate the evaluation of LLM-based agents.Therefore, researchers have dedicated lots of manual efforts to identifying highquality tasks with reasonable difficulty, self-contained information, informative issue descriptions, and sufficient evaluation tests.For example, SWE-bench Lite [214] is a subset of SWE-bench that manually removes tasks requiring complicated edits (e.g., editing more than one file) or the tasks including images or hyperlinks; SWE-bench Lite-S [211] removes tasks that contain exact patches, misleading solutions, or insufficient information in the issue descriptions; similarly, SWE-bench Verified [215] removes cases with unspecified descriptions or insufficient tests.</p>
<p>ANALYSIS FROM AGENT PERSPECTIVE</p>
<p>This section organizes the collected papers from the perspective of agents.Specifically, Section 5.1 summarizes the components of existing LLM-based agents for SE; Section 5.2 focuses on existing multi-agent systems for SE by summarizing their roles and collaboration mechanisms; and Section 5.3 summarizes how humans coordinate with agents for SE.</p>
<p>Agent Framework</p>
<p>Based on the common framework of LLM-based agents [21], [26], [28], this section summarizes the common paradigms of the planning, perception, memory, and action components in existing LLM-based agents for SE.</p>
<p>Planning</p>
<p>In SE, intricate tasks such as development and maintenance activities necessitate the orchestrated efforts of various agents through multiple iterative cycles.Therefore, planning is an essential component for agent systems by meticulously delineating task sequences and strategically scheduling agents to ensure the seamless progression of the SE process.Figure 15 presents the taxonomy of the planning components in existing LLM-based agents for SE.</p>
<p>A. Single Planner vs. Multiple Planners.In LLMbased agent systems, planning is typically handled by a specialized agent [4], [61], [91], [98], [105], [144], [145], [183], [187], [191], [193] or as a core responsibility of an individual agent [76], [82], [85], [86], [148], [162], [192].Some works use the function-calling interface [216] provided by  or GPT-4 [218], handing over the planning task to high-performance models [82].However, given the pivotal role that planning plays in influencing subsequent action steps, some works incorporate a collaborative approach among several agents to further enhance the accuracy and practicality of the plans formulated [91], [186], [189], [195], [197], [198], [205].</p>
<p>B. Single-turn Planning vs. Multi-turn Planning.</p>
<p>The fundamental planning strategy is to craft a holistic plan from the very beginning meticulously and then proceed to implement it in successive rounds [4], [61], [82], [86], [91], [98], [105], [183], [186], [187], [191]- [193], [195], [197], [198], [205].Further, many SE agents have adopted a ReActlike [219] architecture, which implements a multi-turn planning mechanism wherein the next-round actions will not be determined until receiving the environmental feedback from the previous round.This form allows for dynamic revision and expansion of the plan, enabling it to adapt to more flexible task scenarios, such as issue resolution [76], [210], iterative code generation [82], [85], mobile app testing [144], [145], [148], among others [162].</p>
<p>C. Single-path Planning vs. Multi-path Planning.</p>
<p>Most LLM-based agents use single-path planning strategies, i.e., they plan and execute tasks in a linear manner [4], [61], [86], [105], [151], [186], [187], [191]- [195], [198], [205], [220].However, agents inherit the randomness from the backbone LLMs, leading to fluctuations in task decomposition.Some approaches improve upon single-path planning by using feedback from each round to dynamically plan the next round of actions [82], [85], [88], [97], [144], [145], [148], [162], [210].Although these dynamic strategies are still singlepath, they offer considerable flexibility due to their ability to be adjusted based on progress and execution outcomes.Another approach to address this issue is to design a multipath planning strategy, which instructs the agents to generate or simulate multiple plans, and select [76], switch [98], or aggregate [197] the optimal paths for execution.</p>
<p>D. Plan Representation.</p>
<p>The plan can be exhibited in different forms, including natural language descriptions, semi-structured representations, or graphs.</p>
<p> Natural Language.Most agents describe the plan in natural language, especially as a list of procedural steps [4], [86], [91], [98], [105], [183] or features to be implemented [187], [191], [194], [198].</p>
<p> Semi-structured.The agent system AXNav [145] represents the action list in JSON format; and some code-generating agent systems directly output the code skeleton [61], [97], [192], [195] or present the plan as executable code [205], which can be seen as a special plan form in SE tasks. Graph.Some agents model the plan as a graph to facilitate the expansion and traceability of execution paths [76], [88], [151].</p>
<p>Memory</p>
<p>The memory component is a pivotal mechanism responsible for storing the trajectories of historical thoughts, actions, and environmental observations, enabling agents to sustain coherent reasoning and address intricate tasks.In SE, complex development and maintenance tasks generally necessitate agents conducting iterative revisions, wherein historical intermediate information, e.g., generated code and testing reports, significantly impacts integrity and continuity.We then detail the implementation of memory mechanisms in SE from four perspectives: memory duration, ownership, format, and operation.Figure 16 presents the taxonomy of the memory components in existing LLM-based agents for SE.</p>
<p>A. Memory Duration.Inspired by human memory systems, agent memory can be classified into short-term memory and long-term memory based on the memory duration.</p>
<p>A.1: Short-term Memory.Short-term memory, also known as working memory [221], is integrated into agents to enhance their ability to sustain trajectories of the current ongoing task and is frequently used when multi-turn interactions are involved.In SE, there are some predominant patterns of short-term memory.</p>
<p> Dialog Records.This pattern is generally used to memorize the pure dialog history among agents and is typically in the form of history summary [148], [189] and multiturn instruction-response pairs [186], [197], [198].It is straightforward to implement and can offer a thorough and detailed historical record of the task-solving process.However, the weakness is that the dialog history can be lengthy and contain irrelevant and redundant information.</p>
<p> Action-Observation-Critique Records.While dialog history concentrates on the thoughts and responses among agents, some works highlight the interaction between agents and the environment by memorizing the actionobservation sequences.Moreover, the critique information is also retained in case certain reflection mechanisms are introduced [144].This pattern has been adopted in SE tasks that necessitate iterative feedback from the environment, e.g., mobile app testing [139], [144], [148], wherein operations on widgets in each turn should be memorized to facilitate the next-turn decision-making, and iterative code generation [62], [88], [187], [189], wherein the previous editing, execution, or debugging history serves as important information for code revision. Intermediate Outputs.Some agents store the outputs of previous turns in short-term memory to avoid overrunning the limited space as well as being overly influenced by irrelevant or inaccurate chat history.For example, in E&amp;V [107], only intermediate analysis results are summarized to avoid inconsistency with the previously generated outputs.In SoA [97], to implement a self-organized framework, each agent is equipped with memory that stores the self-generated code and unit tests.These intermediate results allow delayed test execution and code modification for agents in different layers, facilitating hierarchical collaborative code generation.</p>
<p>A.2: Long-term Memory.Long-term memory, on the other hand, is used to memorize valuable experiences of historical tasks, which can be recalled by agents when solving unseen tasks.Due to extensive trajectories, long-term memory commonly uses distilling techniques or only stores the pivotal information.</p>
<p> Distilled Trajectory.The entire task execution trajectory may involve extensive context, and given the limited memory space, it can be challenging to store it all completely.As a result, distilling techniques have been</p>
<p>Memory</p>
<p>Memory Duration</p>
<p>Short-term Memory</p>
<p>Dialog Records ChatDev [186], AGILE-CODER [198], CTC [197], etc.</p>
<p>Action-Observation-Critique Records</p>
<p>DROIDAGENT [144], GPTDroid [139], MetaGPT [187], AutoAgents [189], etc.</p>
<p>Intermediate output E&amp;V [107], SoA [97] Long-term Memory Distilled Trajectory DROIDAGENT [144], Qian et al. [190], [196], MetaGPT [187] Selective Storage ChatDev [186], AGILE-CODER [198], CTC [197], etc.</p>
<p>Memory Ownership</p>
<p>Specific Memory</p>
<p>XUAT-Copilort [148], SoA [97], GPTDroid [139], Reflexion [62], etc.</p>
<p>Shared Memory</p>
<p>MetaGPT [187], Self-Collaboration [4], MARE [57], AGILECODER [198], etc.</p>
<p>Memory Format Natural Languages</p>
<p>ChatDev [186], CTC [197], XUAT-Copilot [148], MAGIS [205],AG-ILECODER [198], etc.</p>
<p>Programming Languages CodePlan [88], SoA [97] Structured Messages MetaGPT [187], MARE [57], E&amp;V [107] Key-value Pairs Qian et al. [190], [196], RCAgent [162] Embeddings DROIDAGENT [144] Trees LATS [76], Olausson et al. [63] Memory Operations</p>
<p>Memory Writing</p>
<p>Preprocessing XUAT-Copilot [148], DROIDA-GENT [144], MAGIS [205], Qian et al. [190], [196], etc.</p>
<p>Eliminiation Reflexion [62], Qian et al. [190], [196] Memory Reading</p>
<p>Filtering Criteria</p>
<p>Recency ChatDev [186], AGILE-CODER [198], CTC [197], etc.</p>
<p>Relevance</p>
<p>MetaGPT [187], AGILE-CODER [198], CodePlan [88]</p>
<p>Similarity</p>
<p>Qian et al. [190], [196], DROIDAGENT [144] Reading Manners</p>
<p>Reflection LCG [194], AutoAgents [189] Retrieval DROIDAGENT [144], Qian et al. [190], [196] Subscription MetaGPT [187], AGILECODER [198] Fig. 16: Taxonomy of Memory Design in LLM-based Agents for SE proposed, e.g., trajectory summarization [144], [187] and shortcut extraction [190], [196].These distilled records retain the task execution process in a more concise manner, thereby alleviating the burden on limited memory and prompt windows. Selective Storage.Another manner to save long-term memory space is to store vital data of each task, e.g., the final results [186], [189], [197], [198], reflections [62], [189], and action-observations [76], [144], [162].Compared to complete historical trajectories, these data highlight the pivotal trace information, which can still retain the effects and feedback of previous tasks.</p>
<p>B. Memory Ownership.</p>
<p>In agent systems, the memory module can be designed to serve specific agents or to serve all agents.Based on its ownership, we categorize memory into Specific Memory and Shared Memory.</p>
<p>B.1: Specific Memory.Specific memory is an agent mechanism designed specifically for a limited group of agents.This type of memory has strict pre-defined usage regulations, only storing and serving specific agents in the workflow [62], [76], [88], [97], [98], [107], [139], [144], [148], [162], [186], [187], [189], [190], [196]- [198], [205].For example, in SoA [97], each agent is equipped with individual memory for storing its own generated code fragments and unit tests, which will be used to evaluate the correctness of the final code and provide feedback to the agent for modification.</p>
<p>B.2: Shared Memory.Shared memory, on the other hand, serves all agents by maintaining the record of their outputs and offering essential historical data.In most cases, shared memory serves as a dynamic information exchange hub in the intricate SE environment, which is akin to the traditional blackboard system [222].Generally, information stored in the shared memory is the intermediate results of previous phases, hence the agents from subsequent phases can obtain necessary information in a more convenient manner [4], [57], [160], [187], [198].Representative work like MetaGPT [187] introduces a shared message pool, which saves artifacts from different agent roles, e.g., the product requirement documents from the product manager.Another typical application of shared memory is to store comments in a decentralized debate scenario.Specifically, LCG scrum [194] simulates the Sprint Meeting by providing a shared buffer, storing the problem and the discussion comment of all participated agents from which the product manager could extract a list of user stories.</p>
<p>C. Memory Format.In this section, we elaborate on the format of data stored in the memory.In SE tasks, the most commonly used storage formats include natural languages, program languages, structured messages, key-value pairs, embeddings, and trees.</p>
<p>C.1: Natural Languages.LLM-based agents solve tasks specified in natural language, which is thus the most fundamental and prevalent data format in memory [4], [62], [139], [148], [186], [189], [194], [197], [198], [205].The advantage of raw natural language is that it allows for a more flexible storage of trajectories, thereby enhancing the universality.Moreover, raw natural language can better preserve the integrity of the original dialogue, which minimizes the loss and distortion of essential information.</p>
<p>C.2: Programming Languages.Some agents directly store the generated code for subsequent utilization [88], [97].For example, SoA [97] is a hierarchical code generation framework with each agent focusing on single function implementation.It stores the generated function code and unit tests in the memory for testing, modification, and aggregation.</p>
<p>C.3: Structured Messages.In this format, memory is organized as a list of messages with multiple attributes.The strength of this format is that it allows data to be stored in a structured manner, making it more convenient for indexing and processing.Moreover, it can store vital metadata of the message, e.g., message source and destination, task type, etc., so it is easier for agents to trace and subscribe to required messages, making it commonly used in shared memory.Representative works like MetaGPT [187] and MARE [57], both wrap the artifacts of each agent as informative messages, involving the original content, instruction, task name, sender, and receiver, etc.In E&amp;V [107], intermediate results of previous turns will be summarized and stored in JSON format.</p>
<p>C.4: Key-value Pairs.In this format, information received from the agents is stored in an external memory, with a key extracted for the agents to query required history memories [162], [190], [196].More specifically, in Co-Learning [190], shortcuts are extracted from the trajectories to construct two key-value databases: the solution-toinstruction database for the instructor, and the instructionto-solution database for the assistant.RCAgent [162] stores the whole observation body in a key-value store, remaining a snapshot key for agents for query details.</p>
<p>C.5: Embeddings.In this format, the memory is embedded into a vector, which can help retrieve the most relevant task experiences.Representative work like DROIDAGENT [144] embeds the textual history into vectors and stores them in an external embedding database.Compared to text similarity retrieval, it can further provide semantic similarity retrieval.</p>
<p>C.6: Trees.Some approaches construct a tree or graph for memorizing, especially in scenarios requiring flexible extension or path tracing.For example, in LATS [76], the task-solving process is modeled into a tree with each node representing a state with the instruction, the action, and the observation, and then an extended Monte Carlo Tree Search algorithm can be integrated.Similarly, Olausson et al. [63] propose a repair tree that stores multiple generationfeedback-repair paths.D. Memory Operations.We categorize operations on memory into two main sections: memory writing and memory reading.</p>
<p>D.1: Memory Writing.The purpose of memory writing is to store essential information in the memory.In SE, the most commonly considered problems include how to process the received information (memory preprocessing) and how to avoid memory overflow (memory overflow).</p>
<p> Memory Preprocessing.Information stored in memory is usually the raw task execution trajectories [186], [197], [198].However, considering that the raw task trajectories might be lengthy, distilling approaches have been proposed to retain a more informative summary in the memory [62], [107], [144], [148], [187], [190], [196], [205].</p>
<p>For instance, in XUAT-Copilot [148], dialog and action history are stored in working memory as summarized texts.Moreover, Co-Learning [190] proposes a novel distilling approach by first constructing a task execution graph and then extracting shortcuts linking non-adjacent solution nodes, which can serve as solution refinement paths for future tasks. Memory Elimination.The limited memory storage and prompt window size result in finite memory records.When overflow occurs, some records must be forgotten.For example, in Reflexion [62], the past experiences are stored in a sliding window with a maximum number of 3 to avoid exceeding the prompt window.Additionally, low-quality and rarely-used data also consume memory storage space.Previous research [190] sets a threshold to filter out experiences with limited information.Further, an elimination mechanism based on the usage frequency is introduced to exclude rarely-used experiences [196].</p>
<p>D.2: Memory Reading.Memory reading aims at obtaining the required task history and experiences from the memory module.We elaborate on the memory reading process from two perspectives: the filtering criteria required historical records and reading manners to obtain these records.</p>
<p>Filtering Criteria.The factors influencing whether a historical record should be integrated into the current task can be chiefly categorized into three parts: recency [88], [139], [144], [148], [186], [187], [197], [198], [205], relevance [88], [187], [198] and similarity [144], [190], [196].Agents integrate the most relevant and similar task experiences to provide the best reference for the current task.Additionally, the preference and weight of these factors vary across different works.In DROIDAGENT [144], the planner agent considers the 20 most recent task summaries and the 5 most similar task knowledge items.In MAGIS [205], the agent uses the most recent summary of a code file to identify differences.In MetaGPT [187] and AGILECODER [198], agents retrieve only relevant messages from shared memory based on their roles.</p>
<p>Reading Manners.In SE, instead of directly providing the raw memory to the agent [4], [139], [160], [186], [187], [197], [198], [205], researchers prefer using three manners for obtaining relevant memory: reflection, retrieval, and subscription.</p>
<p> Reflection.Reflection refers to extracting pivotal experiences from the extensive trajectory memory [189], [194].For example, in AutoAgents [189], the dynamic memory mechanism is designed to instruct an agent to extract in-sights from long-term memory that will serve the current action.In LCG scrum [194], the product manager summarizes the comments collected from all agents and extracts a list of user stories to implement. Retrieval.In this manner, the memory is retrieved based on its text or semantic similarity with the current tasks [144], [190], [196].For example, in Co-Learning [190], the reasoning module uses the prompt as a query to retrieve similar shortcuts from the constructed experience pool, which will serve as examples to facilitate future reasoning.</p>
<p>In DROIDAGENT [144], the past tasks and widgets with similar GUI state embeddings are retrieved by comparing the cosine similarity. Subscription.The subscription mechanism is chiefly used in shared memory.It permits agents to directly obtain required information according to their roles, without additional interaction costs with other agents, thus improving efficiency.Representative works include MetaGPT [187] and AGILECODER [198], both adopting this kind of publish-subscribe mechanism.</p>
<p>Perception</p>
<p>Existing LLM-based agents for SE primarily adopt two perception paradigms: textual input perception and visual input perception.</p>
<p>A. Textual Input.Text can flexibly express the intent, information, and knowledge.In SE, the majority of historical data, e.g., documentation, code, and issues, is stored in the textual form.This alignment with the strengths of LLMs in processing natural language makes textual input the predominant form of perception for agents for SE.Textual input in existing agents can be further categorized into natural language input (i.e., instructions and auxiliary information collected from the environment) and programming language input (i.e., the code context).For example, in NL2Code tasks [186], [187], user requirements and function descriptions are provided as the instruction to agents.But in some code-related tasks, e.g., software testing [126], [127] and debugging [159], [160], [171], [174], the target code can also be provided for analysis.Specifically, in repository-level tasks such as issue-resolution [206]- [208], repository-level fault localization [160], and code edits [88], only a portion of code snippets are provided due to context length limitations, with further inspections achieved through navigation in the code repository.</p>
<p>B. Visual Input.Images represent a two-dimensional medium for storing information.In traditional SE scenarios, there is also a portion of data presented in image form, e.g., UML diagrams [223] and UI pages.A small number of existing agents use this visual information to enhance their understanding of target tasks.For example, in MetaGPT [187], the product manager creates a competitive quadrant chart for the architect, who then provides system architecture and sequence flow diagrams to the engineer agents.</p>
<p>Visual input is more widely used in mobile app testing tasks, since the clickable widgets can be located easily in screenshots.Previous work [144] has also discovered that the widgets in some apps might be presented in raw pictures without any textual information [144].Therefore, in XUAT-Copilot [148] and AXNav [145], the screenshot of the current page is provided to the agent to visualize the accessible widgets.Just as humans use their eyes to interpret images, these agents integrate external visual models to process and understand image data.XUAT-Copilot [148] uses the SegLink++ model [224] for detecting bounding boxes and a ConvNeXts model [225] for text recognition.</p>
<p>Action</p>
<p>The action component of existing LLM-based agents for SE primarily involves using external tools to extend their capabilities beyond the interactive dialogue typical of standalone LLMs. Figure 17 summarizes the tools used in these agent systems.</p>
<p>A. Searching Tools.In SE, agents frequently use searching tools to retrieve relevant information (e.g., documentation or code snippets) that can be helpful for the task completion.</p>
<p>A.1: Web Searching.Online search engine tools use community and tutorial websites to offer programmers accurate and practical suggestions based on shared experiences and Q&amp;A.When faced with gaps in specific domain knowledge, programmers distill their needs into a query and use existing search engines (e.g., Google, Bing, WikiSearch) to find the necessary information, an approach that can also be employed by agents [78], [96], [105], [153], [187], [193].For example, some agents [78], [81], [82], [188] use Duck-Duckgo [228] to search the relative content such as APIs.Paranjape1 et al. [102] employ SerpAPI [229] and extract answer box snippets when they are available or combine the Top-2 search result snippets together.He et al. [230] query Google and then extract pertinent information to construct prompts for LLMs.Depending on the task at hand, the search space can be restricted to specific websites (e.g., as StackOverflow) or certain websites can be blocked to prevent data leakage.</p>
<p>A.2: Knowledge Base Searching.Besides using a web searching tool to externally collect the information from the wide, it is also common for existing agents to retrieve relevant knowledge from the self-established knowledge base (e.g., memory pool or code repository).In particular, similarity and string matching are two common retrieval strategies.Similarity-based retrieval approaches include sparse wordbag and dense text embedding.Both approaches vectorize codes or documents, calculating similarity between the query and the segment in knowledge base to obtain relevant information.The sparse word-bag approach (e.g., BM25 [78], [82]) vectorizes text while partially preserving its semantics.Dense text embedding model such as dual-encoder encodes the text into embedding vectors and calculates their cosine similarity [64], [77], [105], [110], [144], [151], [162], [190].String matching approaches directly split the given code element name and match it within the knowledge base [107], [171], which is used for locating files within a repository by the file name.</p>
<p>B. File Operation.As SE activities frequently access massive files especially for the code repository and documentation, it is common for agent systems [113], [153], [171], [172], [207], [210] to use file operations including shell commands (e.g., Linux shell) or the code utils (e.g., Python os package) for file browsing, file adding, file deleting, and file editing.For example, for file browsing, agents open files
Action Searching Tools Web Searching
MetaGPT [187], CodePori [193], ICAA [105], AgentVerse [188], etc.</p>
<p>Knowledge Base Searching</p>
<p>CodeAgent [82], ToolCoder [78], Co-Learning [190], EV [107], etc. File Operation SWE-agent [207], RepairAgent [171], MASAI [210], etc.</p>
<p>GUI Operation</p>
<p>GPTDroid [139], XUAT-Copilot [148], AXNav [145], AdbGPT [15] Static Program Analysis</p>
<p>Static Information Collection</p>
<p>Abstract Syntax Tree AutoCodeRover [206], TOOLGEN [89],</p>
<p>AdbGPT [15], TELPA [125], etc.</p>
<p>Control Flow Graph LDB [75], LLM4CBI [134] Call Graph TELPA [125], AutoSpec [226] Dynamic Analysis Method Call Trace AgentFL [160] Runtime Values AUTOSD [75], LDB [75] Coverage CoverUp [126], TELPA [125], LLM4CBI [134] Testing Tools Test Validation AUTOSD [172], LCG [194], AISD [191], ClarifyGPT [94], etc.</p>
<p>Test Generation</p>
<p>TELPA [125] Mutation Testing MuTAP [127] Fault Localization Tools RepairAgent [171], Au-toCodeRover [206] Version Control Tools RepoAgent [227] Fig. 17: Taxonomy of Action Components in LLM-based Agents for SE based on their paths, scroll through the contents, and jump to specific lines.</p>
<p>C. GUI Operation.For SE activities related to software with GUI, it is necessary to enable various GUI interaction operations for agent systems [15], [139], [145], [148], including clicking, text input, scrolling, swiping, returning, and termination.In particular, for UI element identification, they use visual and text recognition models (e.g., SegLink++ [231], Screen Recognition [232], and Con-vNeXts [233]), dump (e.g., Android UIAutomator [147]), or parse the UI view hierarchy [15], [139]; then they simulate the testing environment using virtual Android devices (e.g., Genymotion [146], VirtualBox [140], and pyvbox [141]) and autonomously execute or reply actions through tools such as Android Debug Bridge [143] to mimic user interactions.These actions enable agent systems to test in various GUI environments.</p>
<p>D. Static Program Analysis.</p>
<p>Static program analysis tools are widely used in agent systems for SE tasks, as they can provide more rigorous code features (e.g., data-flow and control-flow) for LLMs.Existing agents primarily use static program analysis tools for two purposes: collecting static program information and checking code quality.</p>
<p>D.1: Static Information Collection.Agents invoke static analysis tools to parse the program and to collect additional program information; and the collected information can further help agents better understand the program and thus tackle the relevant tasks.Existing agents primarily collect the following static information.</p>
<p> Abstract Syntax Tree (AST).AST is a common representation to describe the syntactic structure of the source code and is widely used by agents.In particular, the collected ASTs help agents extract syntactic elements (e.g., class names, method names, and variable names) [15], [77], [82], [88], [88], [89], [107], [125], [126], [198], [206], [210], [226] and identify dependency among these code elements [88], [125], [198], [226], [227].Tree-sitter [161] and ANTLR [234] are AST parsing tools that are widely used in existing agent systems [82], [88], [160], [171], [174], [198], [210]. Control Flow Graph (CFG).LDB [75] uses CFG to divide a program into multiple blocks, making it easier to track intermediate variables with the help of the debug-ger.LLM4CBI [134] calculates the cyclomatic complexity based on a CFG that represents failed tests and accurately identifies high-complexity blocks of the code.These complicated code blocks would be regarded as the targets for program mutation. Call Graph (CG).TELPA [125] constructs a method CG, extracting all call sequences that reach uncovered target methods.Based on these sequences, new test cases are generated to ensure comprehensive coverage of previously untested methods.AutoSpec [226] treats loops as nodes as well, constructing an extended call graph; and it then traverses the CG from the bottom up to generate specifications. Data Flow Graph (DFG).IRIS [113] constructs a data flow graph to assist taint analysis, which helps detect security vulnerabilities.LLM4CBI [134] performs data flow analysis to output a list of the most complex variables defined and used in the failed test, which guides test generation. Code Dependency Graph (CDG).Agents such as Agile-Coder [198] and CodePlan [88] build a Code Dependency Graph for the entire codebase.The graph represents complex relationships between code blocks (e.g., call relationships, inheritance, and import dependencies) and enables the accurate extraction of task-relevant context information (e.g., error trace-back path for repair) within constraints of a limited prompt length.In addition, by dynamically maintaining the CDG, agents can perform incremental analysis in a more efficient way. Code Completion Tokens.In code generation tasks, it is common for agents [77], [88], [89], [227] to use language servers (e.g., Jedi [235] and EclipseJDTLS [236]) to collect candidate tokens at the certain position.In particular, candidate tokens returned by language servers often pass the syntactic violation (e.g., only defined variable names are returned), which can effectively alleviate the hallucinations of standalone LLMs.</p>
<p>D.2: Code Quality Checking.Static analysis tools are also widely used by agent systems to check code quality, e.g., syntactic correctness checking, code format checking, code complexity checking, vulnerability detection, and specifications checking.The checked results can then provide feedback or additional hints for agents to further improve code quality.In particular, existing agents [77], [84], [197] use compilers or interpreter (e.g., GCC or Python) for syntactic correctness checking; existing agents [82], [192] use Black [237] and nuXmv [238] for code format checking; the agent in [134] uses OClint [135] and srcSlice [136] for code complexity checking; existing agents [134], [174] use static analysis tools such as Frama-C [138] and Slither [239] to detect vulnerabilities; the agent in [226] uses static tools (e.g., Frama-C) to verify the satisfiability and sufficiency of generated specifications.</p>
<p>E. Dynamic Analysis.In addition to static analysis, existing agents also use dynamic analysis tools to collect dynamic runtime information (i.e., method call trace, runtime values, and coverage) that can further provide runtime behaviors for agents.</p>
<p> Method Call Trace.AgentFL [160] uses the java.lang.instrumentpackage [240] to record all method call traces during the execution of failed tests, which can facilitate more accurate fault localization.</p>
<p> Runtime Values.Some agents [75], [172] mimic manual debugging to set breakpoints, so as to capture runtime values for variables.The runtime values can be integrated into the prompt along with requirements to aid in defect localization. Coverage.Coverage serves as important feedback for whether each code element is executed by tests or not.For example, some agents [125], [126], [134] leverage tools such as SlipCover [129], Pynguin [241], and Gcov [137] to collect the coverage information.F. Testing Tools.Test cases validate whether the software behaviors violate the specifications, and it is common for agents in SE to invoke testing tools, including tools for test validation, test generation, and mutation testing.</p>
<p>F.1: Test Validation.Validating the software with test execution frameworks (e.g., PyTest, unittest, or JUnit) can reveal the runtime errors and test failures, which are widely used in existing agent systems [62]- [67], [71]- [74], [79], [81]- [85], [87], [91], [92], [94], [95], [97], [98], [102], [122], [123], [125], [128], [133], [153], [159], [171], [172], [175], [187], [188], [191], [194], [198], [206], [210], [230].The revealed execution violations can further serve as feedback for agents to improve programs; otherwise, the absence of execution violation can serve as a signal for the correctness of programs (e.g., a plausible patch is found for program repair agents).</p>
<p>F.2: Test Generation Tools.Although an LLM itself has promising capabilities of directly generating test code, traditional test generation tools provide complementary benefits as they are good at generating high-coverage tests in a costefficient way.For example, some agents [125] use automated test case generation tools (e.g., Pynguin [241]) to generate an initial set of unit test cases.</p>
<p>F.3.Mutation Testing.Some agents [127] use mutation testing tools (e.g., MutPy [242]) to evaluate the sufficiency of test cases, as killing mutants (i.e., exhibiting different behaviors on the mutated program than the original program) indicates the fault detection capabilities of tests.The mutation testing results can further serve as the feedback for agents to iteratively enhance the tests.</p>
<p>G. Fault Localization Tools.Agent systems [171], [206] can invoke traditional fault localization techniques, especially spectrum-based fault localization tools (e.g., GZoltar [243]) to localize suspicious code elements.For example, RepairAgent [171] invokes GZoltar to get the suspiciousness score of each code element (i.e., the probability of being fault).</p>
<p>H. Version Control Tools.Version control systems manage the changes of various files in a repository such as changes in code, configuration files, or documentation throughout the software development process.Some agents [227] involving managing an entire repository often leverage version control tools.For example, RepoAgent [227] uses Git [244] to track changes in code files and promptly synchronize updates to project documentation.</p>
<p>Multi-agent System</p>
<p>Based on our statistics, 52.8% of existing agents for SE are multi-agent systems.These systems benefit from the division of specialized roles and coordination among agents, Agent Roles Manager Roles Task Decomposition Manager Bot [193], Planner [144], [145], Manager [205], Scrum Master [194], [198], Controller [162],</p>
<p>Planning Agent [98], Instructive Agent [196], Product Manager [187], Planning LLM [183] Decision Making CEO &amp; CTO [119], Instructor [190], AI User [68] Team Organization</p>
<p>Mother Agent [97], Planner &amp; Agent Observer [189] Requirement Analyzing Roles Product Manager [185], [187], [191], [198], Analyst [4], Task Interpretation and Planing LLM [105],</p>
<p>Requirement Engineer [194], Task Specifier Agent [68], User [54] Architect [187], [194], Software Architect [185], [191], CEO &amp; CTO [186] UI/UX Designer User Experience Designer [185], User Interface Designer [185],</p>
<p>UI/UX Designer [188] Developer Roles Dev-bot [193], Writer [64], Engineer [187], Programmer [67], [95], [186], [188], [191], Software Developer [185], SketchFiller [195], Coder Agent [66], Child Agent [97], Coding Agent [98],</p>
<p>AI assistant [68], Developer [194], [198], [205], Code Learner [65],</p>
<p>Code Model [63], Coder [4] Software Quality Assurance Roles</p>
<p>Code Reviewer</p>
<p>Reviewer [119], [186], [197], QA Engineer [205], Verification Bot [193],</p>
<p>Senior Developer [198] [160], Safeguard [64], Auditor &amp; Critic [104],</p>
<p>Consistency Checking Agent [105] Tester Crafter [159], Tester [194], [198], Test Designer [95], QA Engineer [187], Software Tester [185], Generation LLM [133], Action Agent &amp; Evaluation Agent [145], Actor &amp; Observer [144], Operation Agent [148] Debugging Roles Test Failure Analysis Remediation Agent [66], Feedback Model [63], Questioner [67], Reflector [144], Revisitor [159] Test Failure Reproduction Test Template Generator &amp; Issue Reproducer [210] Repair</p>
<p>Localizer &amp; Repairer [159], Generator [174], Fixer [210],</p>
<p>Debugging Agent [98] Assistant Roles</p>
<p>Repository Custodian [205], RepoSketcher [195], Edit Localizer [210], Retrieval Agent [98], Report Agent [105] Fig. 18: Taxonomy of Agent Roles in LLM-based Multi-agent Systems for SE which effectively addresses the complexity of SE tasks, particularly for end-to-end activities spanning multiple phases.This section provides an overview of existing multi-agent systems for SE, with a focus on their agent roles and coordination mechanisms.</p>
<p>Agent Roles</p>
<p>In a multi-agent system, each agent is typically assigned a specialized role designed to address specific tasks.This role assignment forms the foundation of the system, directly influencing task decomposition and agent coordination.Specifically, role assignment mainly delineates duties, available actions, attributes, and constraints of roles.It makes agents as experts of corresponding tasks.Figure 18 summarizes common agent roles in existing multi-agent systems for SE.</p>
<p>A: Manager Roles.Managerial roles, such as CEO, CTO, commander, and controller, serve as the leaders of a multiagent team.These roles are responsible for making decisions, planning, task decomposition and assignment, and overseeing team coordination.</p>
<p>A.1: Roles for Task Decomposition.To enhance the overall system performance, managers break down a project into manageable sub-tasks and draw up a guiding plan for developers or testers to execute [98], [144], [145], [162], [193], [196], [198], [205].They analyze problem statements, facilitate discussions on issues among various agent roles [194], review design documents submitted by designers [187], and incorporate related information gathered by assistants.Subsequently, they produce a specific task list or implementation blueprint, which may be presented in either natural language or as a structured workflow [183].</p>
<p>A.2: Roles for Decision Making.This role is designed for orchestrating collaboration within a team and providing further guidance for task execution.For example, CEO and CTO in CodeAgent [119] communicate with staff and make high-level decisions.Similarly, the instructor in the agent [190] and the AI user within the CAMEL system [68] issue directions to working agents.</p>
<p>A.3: Roles for Team Organization.This role is primarily designed for flexibly deciding the constitution of the agent team, i.e., what roles are included in the team.The main benefits of including such roles are to flexibly optimize costs and better meet project demands.For instance, SoA [97] sets the mother agent, which generates new mother or child agents and designates concrete tasks (e.g., unimplemented functions) to them.AutoAgents [189] includes a planner agent and an observer agent, which collaborate to assemble a team for particular tasks.The planner agent is responsible for assigning existing LLM agent roles or generating new ones, while the observer agent assesses and reviews the relevant roles.These roles are represented in a structured JSON format, encapsulating details such as name, description, available tools, suggestions, and prompts to guide agent behaviors.</p>
<p>B. Requirement Analyzing Roles.These roles are primarily responsible for analyzing software requirements, such as translating vague and preliminary user concepts into a coherent and structured format.Existing agents [4], [105], [185], [187], [194], [198] include such roles (e.g., product manager [191] or task specifier [68]) to identify key requirement elements and intended objectives for a precise and organized requirement document, which may range from an elaborated task or function description [68] to a formal software requirement specification [187].</p>
<p>In addition, some agents further design more finegrained roles for requirements analysis.For example, Elicitron [54] incorporates a set of User agents to identify diverse user requirements by mimicking user perspectives and conducting interviews for exploring potential user needs; MARE [57] uses a requirements engineering team (i.e., stakeholder, collector, modeler, checker, and documenter) to produce requirements specifications.The requirements engineering process is segmented into four sub-tasks corresponding to specific roles, seamlessly transitioning rough user ideas to precise requirement specifications.</p>
<p>C. Designer Roles.Designer roles take input information on requirements (such as detailed task descriptions and use cases) and shape the software architecture and system integration.</p>
<p>C.1: Software Architecture Designer.This role is responsible for conceptualizing and defining the high-level structure of software, e.g., the software architect role in agents [185]- [187], [191], [194].They create a design document that serves as a blueprint for the subsequent stages of development; and the design document can be presented in various forms, including natural language descriptions, structured formats (e.g., JSON for listing project architecture files), and graphical representations (e.g., class diagrams and sequence flowcharts [187]).</p>
<p>C.2: UI/UX Designer.This role primarily focuses on crafting the visual and interactive aspects of the software interface, such as user experience (UX) designer or user interface (UI) designer roles in agents [185], [188].</p>
<p>D: Developer Roles.Developers take a vital role in software development and maintenance activities, which is one of the most common roles (e.g., also called as programmer or coder) in existing agents [64], [66], [68], [97], [98], [185]- [188], [193], [195] for tasks involving code generation.In accordance with software design schemes, task plans provided by other agents, or user requirements, the developer roles generate or finalize code at various levels (i.e., from function to file and even project levels).In addition, the developer roles also engage in the code refinement process, which refines their previously generated code [4], [63], [65], [67], [95], [194], [205].Furthermore, the developer roles can be set to meet more customized standards, such as elucidating their work through supplementary docstrings or adhering to particular coding criteria [191], [198].</p>
<p>E: Software Quality Assurance Roles.Agent systems include roles dedicated to software quality assurance, similar to real-world QA teams.These roles typically encompass code reviewers, testers, and debuggers, each focused on checking and improving software quality.</p>
<p>E.1: Code Reviewer.This role is responsible for identifying potential software quality issues by statically inspecting the software without execution.For example, some agents [119], [186], [188], [193], [197], [205] include such roles to review generated code or patches; AgileCoder [198] and CAMEL [68] include the roles such as senior developer or critic agent to offer suggestions for enhancement; the agent in [120] sets up code review agent, bug report agent, code smell agent, and code optimization agent to access code quality from different aspects; AGENTFL [160] sets test code reviewer and source code reviewer to summarize code behaviour to help fault location; in addition, some agents [64], [104], [105] include such roles (e.g., the auditor agent and the critic agent in GPTLENS [104] and the consistency checking agent in [105]) to detect the vulnerability or implementation issues.</p>
<p>E.2: Tester.The tester roles are widely incorporated in multi-agent systems [95], [133], [144], [145], [148], [159], [185], [187], [194], [198] for software quality assurance, which are mainly responsible for writing new tests or generating testing action sequences.For example, the tester agent in multi-agent systems [95], [159], [194] generates test cases based on relevant code skeleton or patches, requirement documents, existing tests, or rationale for the test; the tester agent in multi-agent systems [144], [148] generates operational actions for GUI tests or systematic functional tests based on the specified requirements.</p>
<p>E.3: Debugging Roles.In multi-agent systems, debugging roles are responsible for diagnosing test failures or unexpected software behaviors.</p>
<p> Test Failure Analysis.Some multi-agent systems include debugging roles in analyzing test reports.For example, the remediation agent in TGen [66] and the feedback module in Self-repair [63] are similarly designed to analyze the test failure reports and relevant faulty code to provide explanations and suggestions; the questioner agent in AutoCoder [67] describes execution errors to help modify the generated code; the reflector agent in DROIDAGENT [144] reflects and summaries on the test results; and some agents [65], [159] further include debugging roles (e.g., the revisitor) to provide explanations for test failures. Test Failure Reproduction.MASAI [210] uses the test template generator to produce test templates based on the repository information, which further helps the issue reproducer reproduce behaviors described in the issue reports. Repair.Some multi-agent systems include such roles in fault localization and program repair.For example, agents [98], [159], [174], [210] include roles such as repairer and fixer to generate patches for bugs; F: Assistant Roles.Assistant roles primarily provide assistance for other agents.For example, the repository custodian in MAGIS [205], the RepoSketcher in CodeS [195], and the edit localizer in MASAI [210] are designed to enhance the comprehension of the target repository architecture for the team; in addition, MapCoder [98] uses the retrieval agent to facilitate memory recall; ICAA [105] introduces the report agent to convert natural language responses into formatted bug reports.</p>
<p>Collaboration Mechanism</p>
<p>The collaboration mechanism is essential for multi-agent systems, which can significantly impact the effectiveness and costs of the entire system.In particular, the collaborative mechanisms of existing multi-agent systems for SE tasks can be categorized into four types: layered structure, circular structure, tree-like structure, and star-like structure.Figure 19 illustrates each structure.It is a hierarchical structure, where tasks are decomposed into several sub-stages and each is assigned to a specific agent or a group of agents selected from the agent pool.Agents between different stages collaborate in a sequential manner, i.e., they receive intermediate results from agents in the previous stage as input and produce their processed data to agents in the next stage.For example, the workflow within agents of [105], [133], [160], [183], [191], [206] is a simple chain, where each agent focuses on its own sub-task and only interacts with adjacent agents.In addition, agents can also refer to the message produced by the previous non-adjacent agents [98], [187], [195].In the sequential workflow, each sub-task can also be handled by a group of agents [57], [91].In [119], [186], [197], each subtask is solved by the conversation between two agent roles.LCG [194] and AgileCoder [198] incorporate even more agents in a single stage.In addition to interactive collaboration, another scenario involves agents within the same layer working in parallel to offer their solutions.These solutions are then combined and passed down to the next layer.For example, GPTLENS [104] employs several auditors to present possible vulnerable functions individually in the generation stage.The work [69] incorporates the majority voting mechanism.DyLAN [70] formulates the LLM-agent collaboration structure into a multi-layered feed-forward network.</p>
<p>B. Circular Structure.This structure typically manifests as multi-turn dialogues or integrates the feedback mechanism within the overall collaborative processes among agents.The feedback loop facilitates the refinement of the agents' outputs through iterative cycles.The circular structure may consist of dual roles in a dialogue or extend to multiple roles, which results in a more complex iterative circle.</p>
<p>B.1: Dual Roles.On the one hand, some agents [63], [66], [67], [95], [174] implement a generation-validation style loop between two agents.In this setup, one agent is tasked with the primary function, such as generating code snippets or patches, while the other agent provides validation feedback, including static analysis results, test outcomes, and improvement suggestions.In the INTERVENOR framework [65], the code learner initiates the process by generating the initial code and subsequently engages in iterative repairs guided by the suggestions from the code teacher.On the other hand, some agents [68], [111], [190] adopt a dual-agent dialogue cooperative model to achieve objectives.The work [111] facilitates agreement through a discussion between the tester and the developer; and the agents [68], [190] progress through tasks in a step-wise manner, utilizing an instructor-assistant conversational approach.</p>
<p>B.2: Multiple Roles.When more agents are included, the collaborative loop will become more flexible.For example, some works [62], [145], [193] incorporate multiple agents in a larger feedback loop, further dismantling the tasks.DroidAgent [144] embeds an inner loop between the Actor and Observer in the overall loop between the Planner and the Reflector.</p>
<p>C. Tree-like Structure.Different from the layered structure, agents in the same layer of the tree-like structure do not cooperate with each other for the same sub-task but focus on their own work.For example, in SoA [97], the mother agent can dynamically spawn new mother or child agents for code generation, thereby forming a tree-like collaboration structure.In MASAI [210], the tests for reproducing issues and the possible patches are generated parallelly and finally aggregated to the ranker to select the best one.</p>
<p>D. Star-like Structure.This structure is a centralized structure, where a central agent serves as the pivot to interact with other agents.For example, the controller agent in the RCAgent [162] framework can invoke other expert agents as a kind of tool when necessary.The commander in AutoGen [64] coordinates with the writer and the safeguard separately, to craft code and ensure safety.XUAT-Copilot [148] adopts the operation agent as the core, to receive the judgment from the inspection agent and invoke the parameter selection agent to help the action planning.</p>
<p>Human-Agent Collaboration</p>
<p>While most agents aim to achieve maximum automation, where users only need to propose a request and wait for the agents to complete the task, previous studies [183], [191] show that LLM-based agents often encounter bottlenecks during the software development process.Therefore, some agents incorporate the human-agent cooperation paradigm to further align and enhance the agent performance with human preference and expertise.As summarized in Figure 20, existing agents primarily include the human participation in four phases: planning, requirements, development, and evaluation.</p>
<p>Fig. 20: Human-Agent Collaboration in SE</p>
<p>A. Planning Phase.Some agents include human intervention into the planning stage of the agent workflow.For example, the low-code LLM platform [183] offers users a selection of predefined actions to modify auto-generated workflows.The generated workflows can be checked and revised by users before execution.However, revising the system design requires a certain level of expertise, so it is optional in some agents such as AISD [191] and LLM4PLC [192].</p>
<p>B. Requirements Phase.The initial requirements (i.e., the task description) provided by users can be ambiguous, which can lead to a gap between the final outputs of the agent system and the user intention.Therefore, it is common for agent systems to further include manual refinement for the requirements.For example, ClarifyGPT [94] and CodeAct [85] employ a dialogue-based interaction with humans; similarly, Sapper IDE [184] and MARE [57] use human feedback to refine the requirements.AISD [191] enables users to assess and refine the generated use cases.In addition, HARA [245] produces a concise and readable summary table of the generated requirements for further manual expert review.</p>
<p>C. Development Phase.Human involvement can be included in the software development phase to guide agents to strategize solutions and overcome potential failures.Flows [91] leverages human-crafted solutions to produce better code for competitive programming challenges.Both AutoGen [64] and LLM4PLC [192] allow users to furnish feedback when necessary, directing the workflow as needed.</p>
<p>In CodeS [195], the repository is constructed from a tripartite sketch, assigning users the flexibility to edit each individual layer.</p>
<p>D. Evaluation Phase.Human participation also serves as a post-evaluation mechanism for the outcomes produced by the agent system, which can further ensure the outputs are aligned with user intention.For example, AISD [191] and Prompt Sapper [184] both include human intervention at the acceptance testing phase.Users can conduct manual testing of the final system and the test reports help with the necessary refinements.Similarly, in ART [102], users can enhance agent performance on particular tasks by offering feedback through the modification of the task and tool libraries.</p>
<p>RESEARCH OPPORTUNITIES</p>
<p>This section discusses promising research directions and open problems in LLM-based agents for SE.</p>
<p>Evaluation of Agents for SE.Given the emergence of LLM-based agents for SE, it is crucial to develop comprehensive and rigorous evaluation frameworks, including (i) designing more diverse metrics and (ii) constructing higherquality, more realistic benchmarks.</p>
<p>Metrics.Current evaluations of SE agents primarily focus on their ability to solve specific tasks, such as measuring the success rate of agents on benchmarks such as SWEbench.However, these evaluations often concentrate on the final success rate without delving into the intermediate states during the agent's workflow.This lack of fine-grained metrics makes it difficult to assess why agents fail in certain tasks or to what extent they fall short.Given the complexity of SE tasks, failures are common, and without deeper analysis, improving agent performance becomes challenging.Therefore, the design of fine-grained metrics is necessary, allowing researchers to move beyond "black-box" evaluations and gain insights into the agent's decision-making process and failure points.</p>
<p>Additionally, existing metrics heavily emphasize effectiveness, leaving trustworthy requirements such as robustness, security, and fairness underexplored.Given the flexibility and autonomy of LLM-based agents, they may exhibit unstable behavior, which can limit their practical application in real-world SE environments.Evaluating these attributes is essential for building trust in these systems.</p>
<p>Another critical consideration is the cost associated with these agents, particularly as they often involve lengthy workflows, frequent LLM invocations, and the management of large datasets.According to our analysis, only 44.3% of the papers we surveyed have explicitly considered the efficiency of agents in SE tasks, incorporating quantitative analyses of time, token consumption, monetary cost, and feedback loops (e.g., tool invocation frequency or inter-agent discussion frequency).These efficiency and computational costs are particularly important when applying agents to large-scale code repositories, complex documentation, or intricate workflows.</p>
<p>Benchmarks.LLM-based agents significantly extend the capabilities of standalone LLMs, showing great promise in tackling more complex, end-to-end SE tasks.However, existing benchmarks used for evaluating these agents often suffer from quality issues.For instance, prior research [211], [215] has identified that the SWE-bench benchmark includes tasks with vague or incomplete issue descriptions, reducing their relevance and applicability.</p>
<p>Moreover, many tasks in current benchmarks are far simpler than real-world SE challenges.As outlined in Table 11, the software generated by LLM-based agents for endto-end development tends to be relatively small in scale (e.g., consisting of a single function or a few files), which is not representative of the complexity of real-world software projects.In addition, previous work [215] reveals that the majority of tasks (77.8%) in the SWE-bench benchmark can be completed within an hour by an experienced software engineer, further highlighting the gap between benchmark tasks and real-world SE challenges.</p>
<p>To address these shortcomings, future research can focus on creating more realistic, high-quality benchmarks that better reflect the complexity and demands of real-world SE.These improved benchmarks will enable more accurate and meaningful evaluations of LLM-based agents' capabilities and potential.</p>
<p>Human-Agent Collaboration.Software development is inherently a creative process, transforming human requirements into executable software.As such, aligning agent systems with human preferences and intentions is a critical goal.While some existing agents incorporate human participation at various stages of the workflow (as discussed in Section 5.3), there has been limited exploration of how to more thoroughly integrate human involvement throughout the entire software development life cycle.Additionally, the interaction mechanisms between agents and humans remain underexplored.</p>
<p>Currently, agents mainly involve humans in tasks such as requirements clarification, planning adjustments, coding assistance, or evaluation.However, extending human participation to other phases, such as architecture design, test generation, code review, and the end-to-end software maintenance process, remains largely unexplored.A deeper integration of human input across these phases could significantly enhance both the quality and adaptability of the agent's output.</p>
<p>Moreover, designing effective interaction mechanisms is essential for human-agent collaboration.This includes creating user-friendly interfaces for (i) displaying relevant information, such as intermediate outputs from agents, and (ii) collecting user feedback in a streamlined way.Given the complexity of information produced during the agent's workflow, designing such interfaces presents challenges.For instance, when agents are tasked with generating or maintaining a software repository, simply presenting all code files in a flat format would be resource-intensive and inefficient.Therefore, more sophisticated methods of organizing and representing complex data are required to facilitate effective human-agent interaction.</p>
<p>Perception Modality.Most agents applied to SE tasks primarily rely on textual or visual perception.This is largely because software development and maintenance activities are heavily associated with processing large volumes of code, documentation, and images.However, there is still significant potential to explore and incorporate more diverse perception modalities into these agents.</p>
<p>For example, in the context of programming assistance, most LLM-powered coding agents predominantly use textual input, such as chat interfaces or integrated development environment (IDE) code contexts.Alternative input formats, such as voice commands or user gestures, remain underutilized.Expanding the range of perception modalities could significantly enhance the flexibility and accessibility of coding assistants, allowing users to interact with agents in ways that better suit their individual workflows and preferences.</p>
<p>Furthermore, exploring diverse perception modalities may shape the future of software development and maintenance, offering new opportunities to streamline interactions and improve the efficiency of agent-driven processes.</p>
<p>Applying Agents for More SE Tasks.While existing agents have been deployed across various software SE tasks, several critical phases remain underexplored.As highlighted by our analysis in Section 4, there is a lack of LLM-based agents specifically designed for tasks such as design, verification, and feature maintenance during software development and maintenance.</p>
<p>Developing agent systems tailored to these phases presents unique challenges.Tasks like design and verification require advanced reasoning and comprehension capabilities from the LLM-based agents, extending beyond basic code generation.These tasks demand a deeper understanding of architecture, system logic, and the ability to make informed decisions-skills that traditional LLM-controlled agents may not yet fully possess.</p>
<p>Training Software-oriented LLMs for SE Agents.LLMs are the central component controlling the "brain" of agent systems.Most existing agents for SE rely on LLMs trained on general-purpose data (e.g., ChatGPT [246]) or code-specific data (e.g., Deepseek-Coder [247] and Star-Coder [248]).While massive code from GitHub has been leveraged to train LLMs for code, addressing complex SE tasks requires more specialized data.The reason is that software is not just about code.For example, valuable data from the whole software development life cycle, such as design, architecture, developer discussions/communications, historical code changes, and even dynamic runtime information, remain largely untapped.Incorporating such data into training could lead to the development of more powerful LLMs for software (not just for code), better suited for the unique demands of SE.These enhanced models could form the foundation for more advanced and capable agent systems designed to tackle a wider range of SE tasks.SE Expertise in Building Agents.Incorporating wellestablished SE expertise into the design of agent systems is crucial.For instance, widely adopted SE techniques can be integrated as tools or sub-components of agent systems.As discussed in Section 5.1.4,some existing agents already leverage SE toolkits and techniques, but many other SE tools and techniques-such as advanced debugging and testing methods-remain underutilized.Further efforts are needed to comprehensively integrate these tools and techniques into agent systems to enhance their functionality.</p>
<p>In addition, SE domain knowledge can guide the workflow of agent systems.As noted in Section 4.6, some agents for end-to-end software development follow traditional software process models, such as the waterfall or agile models.However, many other software process models remain unexplored.Rather than granting agents full autonomy, existing software development and maintenance methodologies can be used to partially control their workflows.For example, as revealed by the recent Agentless study [211] and also further confirmed by OpenAI [215], LLMs using a simplistic workflow based on traditional fault localization and program repair pipelines can even outperform other more complex, fully autonomous agents.This suggests that leveraging domain expertise from SE can potentially help improve the effectiveness, robustness, efficiency, interpretability, and replicability of agentic solutions.</p>
<p>Fig. 1 :
1
Fig. 1: Structure of This Survey</p>
<p>Fig. 3 :Fig. 4 :
34
Fig. 3: Cumulative Number of Papers Over Time</p>
<p>Fig. 5 :
5
Fig. 5: Agent Distribution along Software Development and Maintenance Tasks</p>
<p> Negotiation: Negotiation plays a crucial role in facilitating communication of different stakeholders and ensuring consistency, especially in conflicting requirements. Specification: Requirements are determined and documented in a formal format. Verification: Requirements and models are validated to ensure they fully and unambiguously reflect the intent of stakeholders. Evolution: Requirements evolution refers to the ongoing process of refining and adapting requirements in response to changing needs and conditions.</p>
<p>Fig. 7 :
7
Fig. 7: Pipeline of LLM-based Agents for Code Generation</p>
<p>Fig. 8 :
8
Fig. 8: Pipeline of LLM-based Agents for Static Bug Detection</p>
<p>Fig. 9 :
9
Fig. 9: Pipeline of LLM-based Agents for Unit Testing</p>
<p>Fig. 10 :
10
Fig. 10: Pipeline of LLM-based Agents for Fault Localization</p>
<p>Fig. 11 :
11
Fig. 11: Pipeline of LLM-based Agents for Program Repair</p>
<ol>
<li>5 . 3
53
Unified Debugging Instead of tackling fault localization or program repair as isolated phases, unified debugging techniques treat them as a unified procedure, which leverages the outputs of each phase to refine each other.In particular, traditional unified debugging techniques [180]-[182] primarily pre-define heuristic rules to refine fault localization based on the patch validation results during program repair.Recently, LLMbased agents have enhanced traditional unified debugging techniques with more flexibility by leveraging LLMs to</li>
</ol>
<p>Fig. 12 :
12
Fig. 12: Process Models Adopted by LLM-based Agents for End-to-end Software Development</p>
<p>Fig. 13 :
13
Fig. 13: Pipeline of LLM-based Agents for End-to-end Software Maintenance</p>
<p>Fig. 14 :
14
Fig. 14: Benchmark Evolution in Software Maintenance</p>
<p>Fig. 15 :
15
Fig. 15: Taxonomy of Planning Strategies in LLM-based Agents for Software Engineering</p>
<p>Fig. 19 :
19
Fig. 19: Multi-agent System Collaboration Mechanisms</p>
<p>TABLE 1 :
1
Statistics of Paper Collection Keyword Hits agent | llm | language model + api 83 agent | llm | language model + bug 98 agent | llm | language model + code 915 agent | llm | language model + coding 70 agent | llm | language model + debug 95 agent | llm | language model + defect 22 agent | llm | language model + deploy 295 agent | llm | language model + evolution 1,349 agent | llm | language model + fault 685 agent | llm | language model + fix 318 agent | llm | language model + maintenance 64 agent | llm | language model + program 1,969 agent | llm | language model + refactor 15 agent | llm | language model + repair 137 agent | llm | language model + requirement 451 agent | llm | language model + software 2,151 agent | llm | language model + test 976 agent | llm | language model + verification 525 agent | llm | language model + vulnerab 144
After manual inspection67After snowballing106</p>
<p>TABLE 2 :
2
Existing LLM-based Agents for Requirements Engineering
AgentsMulti-</p>
<p>Agent Covered RE Phases Elicitation Modeling Negotiation Specification Verification Evolution Elicitron</p>
<p>[54]</p>
<p>Table 3
3
summarizes existing LLM-based agents for code generation with the iterative refinement.A: Model Feedback.Model feedback can be classified into peer-reflection and self-reflection.</p>
<p>TABLE 3 :
3
Existing LLM-based Agents for Code Generation
AgentsMulti-AgentIterative Refinement Model Feedback Tool Feedback Human Feedback Hybrid FeedbackParsel [61]</p>
<p>TABLE 4 :
4
Existing LLM-based Agents for Static Bug Detection
AgentsMulti-AgentTool Utilization Tool Category Specific ToolsDatasetTarget ProgramBug CategoryART [102] Custom Toolkit  --Self-curatedSmart ContractSmart Contract VulnerabilityContext Splitting ToolICAA [105]Custom ToolkitCode Retrieval Tool Document Retrieval ToolNFBugs [106] Self-curatedPython Program Java ProgramNon-functional Bugs API MisusageWeb Search ToolE&amp;V [107]Static AnalysisClang [108]Sampled syzbot [109]Linux KernelKernel Address Sanitizer BugsLLM4Vuln [110]Custom ToolkitDatabase Retrieval Tool Context Collection ToolSelf-curatedSmart ContractSmart Contract VulnerabilityLibrary/API Function CallMao et al. [111]--SySeVR [112]C/C++ ProgramArithmetic Expression Array UsagePointer UsagePath-TraversalIRIS [113]Static AnalysisCodeQL [114]CWE-Bench-Java [113]Java ProgramOS Command Injection Cross-Site ScriptingCode InjectionLLIFT [115]Static AnalysisUBITect [116]Rnd-300 [115]Linux Kernel C ProgramUBI Bugstarget code (e.g., function or variable definitions) throughfunction calls.</p>
<p>TABLE 5 :
5
Existing LLM-based Agents for Code Review CTO, and coder agents cooperate to document the holistic code review process.Experimental results demonstrate the effectiveness and efficiency of CodeAgent in various code review tasks, including consistency analysis, vulnerability analysis, format analysis, and code revision.
AgentsMulti-Agent RolesReview Target Consistency Vulnerability Code Smell Code OptimizationCodeAgent [119]User, CEO, CPO, CTO, Coder, Reviewer
Rasheed et al. [120] Code Review, Bug Report, Code Smell, Code Optimization Agent    ICAA [105] Context &amp; Prompt Incubation Agent, Consistency Checking Agent, Report Agent  CORE [121] Proposer LLM, Ranker LLM </p>
<p>TABLE 6 :
6
Existing LLM-based Agents for Unit Testing
AgentsMulti-AgentFeedback GoalFeedback SourceTarget LanguageChatTester [122]Reduce compilation/execution errorsError messagesJava, PythonTestPilot [123]Reduce compilation/execution errorsError messagesJavaScriptChatUniTest [124]Reduce compilation/execution errorsError messagesJavaTELPA [125]Increase coverageProgram analysis resultsPythonCoverUp [126]Increase coverageExecution results &amp; CoveragePythonMuTAP [127]Enhance fault detectionSurviving mutantsPythontest refiner of ChatTester performs a more fine-grained re-finement than TestPilot, which analyzes error messages andleverages static analysis tools to localize the buggy code forthe next iteration refinement. Similarly, ChatUniTest [124]adopts a generation-validation-repair mechanism to refinethe tests.B. Iterative Refinement to Increase Coverage.CoverUp</p>
<p>TABLE 7 :
7
Existing LLM-based Agents for System Testing
Software SystemAgentsMulti-AgentTool CategoryToolSpecific ToolsOutputOS KernelKernelGPT [130]Static Analysissyz-extract [131] LLVM Toolchain [132]Syzkaller SpecificationsCompilerWhiteFox [133]--OClint [135]Test CasesLLM4CBI [134]Static AnalysissrcSlice [136] Gcov [137]Mutated ProgramsFrama-C [138]VirtualBox [140]GPTDroid [139]Execution Environmentpyvbox [141] Android UIAutomator [142]Test ScriptsMobile AppDroidAgent [144]Custom ToolkitAndroid Debug Bridge [143] Navigation Action ToolkitTest ScriptsAXNav [145]Custom ToolkitNavigation Action ToolkitBug Replay VideoGenymotion [146]AdbGPT [15]Execution EnvironmentAndroid UIAutomator2 [147]Bug Replay StepsAndroid Debug Bridge [143]XUAT-Copilot [148]--Test ScriptsWeb AppRESTSpecIT [149]--HTTP RequestsFuzz4All [150]--Test CasesUniversalPentestGPT [151] Fang et al. [153] Testing Tool Custom ToolkitMetasploit [152] Web Browsering Tool File Creation and Editing ToolTest Operations Exploit ActionsExecution EnvironmentTerminal Code Interpreter
relying on specific GUI states.Liu et al.</p>
<p>TABLE 8 :
8
Existing LLM-based Agents for Fault Localization
AgentsMulti-AgentTool CategoryTools Specific ToolsInput ContextFL GranularityTarget LanguageAgentFL [160]Static AnalysisTree-sitter [161]Project LevelMethodJavaCode Analysis ToolRCAgent [162]Custom ToolkitLog Analysis Tool Memory Retrieval ToolProject LevelComponentJava, PythonInformation Collection ToolsAUTOFL [163]Custom ToolkitRepository Retrieval ToolsProject LevelMethodJavaprompt generation, and (ii) the generation LLM for fuzzinginput generation. They are powered by LLMs with differentcapabilities. In the fuzzing loop, the generation LLM refersto the previously generated samples and dynamically ad-justs its strategy, thereby producing diverse fuzzing inputs.Deng et al. [151] design a modular framework, PentestGPT,to conduct Penetration Testing. The system includes infer-ence, generation, and parsing modules. With the planningstrategy of Pentesting Task Tree (which is based on the cy-
[153]curity attack tree[156]) and CoT methods, PentestGPT solves the problems of context loss and inaccurate instruction generation that may be encountered during automated penetration testing.Fang et al.[153]develop a benchmark consisting of 15 one-day vulnerabilities to assess the efficacy of their agent framework in exploiting such weaknesses, utilizing various LLM backbones.Their agents are imbued with an understanding of the Common Vulnerabilities and Exposures (CVE) descriptions and are capable of harnessing a suite of tools to facilitate the exploitation process.These tools include web browsing capabilities for navigation, web search functionalities for traversing web pages, as well as terminal and code interpreter access for the generation and execution of scripts.</p>
<p>TABLE 9 :
9
Existing LLM-based Agents for Program Repair
AgentsMulti-AgentFeedback SourceTarget SoftwareBenchmarkFix RateChatRepair [166]Execution/CompilationJavaSampled Defects4J [167] &amp; QuixBugs [168]162/337 (Defects4J) 80/80 (QuixBugs)CigaR [169]Execution/CompilationJavaSampled Defects4J &amp; HumanEval-Java [170]69/267 (Defects4J) 102/162 (HumanEval)RepairAgent [171]Execution/CompilationJavaDefects4J164/835AutoSD [172]ExecutionJava/PythonDefects4J &amp; BugsInPy [173] &amp; Almost-Right HumanEval189/835 (Defects4J) 187/200 (HumanEval)ACFIX [174]Static Checking Model DebateSmart ContractSelf-curated Dataset112/118Conversational APR [128]Execution/CompilationJava/PythonSampled QuixBugs59/60FlakyDoctor [175]Execution Static CheckingJavaSampled IDoFT [176] &amp; DexFix dataset [177]&amp; Sampled ODRepair dataset [178]245/419 (Implementation-Dependent Flakiness) 185/247 (Order-Dependent Flakiness)</p>
<p>TABLE 10 :
10
Existing LLM-based Agents for End-to-end Software Development
AgentsMulti-AgentProcess ModelRoles CreationCollaboration ModeCommunication ProtocalSelf-Collaboration [4]WaterfallPre-definedOrderedNatural LanguageLow-code LLM [183]-Pre-definedOrderedNatural LanguagePrompt Sapper [184]-Pre-definedOrderedNatural LanguageTalebirad et al. [185]-DynamicOrderedNatural LanguageChatDev [186]WaterfallPre-definedDual-roleNatural LanguageMetaGPT [187]WaterfallPre-definedOrderedStructuredAgentVerse [188]-DynamicOrderedNatural LanguageAutoAgents [189]-DynamicOrderedNatural LanguageQian et al.</p>
<p>TABLE 11 :
11
Benchmarks for End-to-end Software Development
Benchmarks#TasksInput ScaleOutput ScaleLanguageEvaluated AgentsSRDD [186]1,200Software Description (55 words)Multiple FilesPython</p>
<p>TABLE 12 :
12
Metrics Used in Evaluating Agents for End-toend Software Development
CategoryMetricsUsed AgentsPass RateExecution ValidationPassK Executability</p>
<p>TABLE 13 :
13
Existing LLM-based Agents for End-to-end Software Maintenance
AgentsMulti-AgentPreprocessingIssue Reprod.Issue LocalizationPhasesTask Decomp.Patch GenerationPatch VerificationRankingMAGIS [205]Retrieval-basedw/ local contextCode ReviewAUTOCODEROVER [206]Navigation/Spectrum-basedw/ cross-file contextStatic CheckSWE-agent [207]Navigation-basedw/ local contextStatic CheckCodeR [208]Plan SelectionSpectrum-basedw/ cross-file contextDynamic CheckRepoUnderstander [209]Knowledge Graph Const.Simulationw/ cross-file contextStatic CheckMASAI [210]Test Template GenerationNavigation-basedw/ local contextStatic/Dynamic CheckAgentless [211]Repository Tree Const.Navigation-basedw/ local contextStatic/Dynamic Check
CONCLUSIONIn this paper, we have presented a comprehensive and systematic survey of 106 papers on LLM-based agents for SE.We analyzed the current research from both the SE and agent perspectives.From the SE perspective, we analyzed how LLM-based agents are applied across different software development and maintenance activities.From the agent perspective, we focus on the design of components in LLM-based agents for SE.In addition, we discussed open challenges and future directions in this critical domain.Code Generation Tool Code Execution ToolBigBench[103]Python Program Code Errors GPTLENS[104]Data Flow Graph IRIS[113], LLM4CBI[134]Code Dependency Graph AgileCoder[198], CodePlan[88]Code Completion Tokens TOOLGEN[89], CodePlan[88],Re-poAgent[227], RRR[77]Code Quality Checking RRR[77], CTC[197], Code-CoT[84], ACFIX[174], etc.
. Metagpt, MapCoder [98], etc. Multi-planner ChatDev [186], MAGIS [205</p>
<p>Chatdev, 186], MAGIS [205], etc. Multi-turn CodeAct [85], CodeAgent [82], XUAT-Copilot [148DroidAgent. 148RCAgent [162], etc. Number of Paths Single-path CodePori [193], AISD [191</p>
<p>. Metagpt, AXNav [145], etc. Multi-path MapCoder [98], LATS [76], CTC [197</p>
<p>Self-Collaboration. Plan Representation Natural Language CoCoST [86], MapCoder [98. Semi-structured AXNav [145], CodeS [195], SoA [97], Parsel [61], MAGIS [205</p>
<p>. Graph Codeplan, 88Pentest-GPT [151], LATS [76] REFERENCES</p>
<p>Kun Wayne Xin Zhao, Junyi Zhou, Tianyi Li, Xiaolei Tang, Yupeng Wang, Yingqian Hou, Beichen Min, Junjie Zhang, Zican Zhang, Yifan Dong, Chen Du, Yushuo Yang, Zhipeng Chen, Jinhao Chen, Ruiyang Jiang, Yifan Ren, Xinyu Li, Zikang Tang, Peiyu Liu, Jian-Yun Liu, Ji-Rong Nie, Wen, CoRR, abs/2303.18223A survey of large language models. 2023</p>
<p>Large language models for software engineering: A systematic literature review. Xinyi Hou, Yanjie Zhao, Yue Liu, Zhou Yang, Kailong Wang, Li Li, Xiapu Luo, David Lo, John C Grundy, Haoyu Wang, CoRR, abs/2308.106202023</p>
<p>Large language models for software engineering: Survey and open problems. Angela Fan, Beliz Gokkaya, Mark Harman, Mitya Lyubarskiy, Shubho Sengupta, Shin Yoo, Jie M Zhang, IEEE/ACM International Conference on Software Engineering: Future of Software Engineering, ICSE-FoSE 2023. Melbourne, AustraliaIEEEMay 14-20, 2023. 2023</p>
<p>Self-collaboration code generation via chatgpt. Yihong Dong, Xue Jiang, Zhi Jin, Ge Li, CoRR, abs/2304.075902023</p>
<p>Evaluating the code quality of ai-assisted code generation tools: An empirical study on github copilot, amazon codewhisperer, and chatgpt. Isik Burak Yetistiren, Miray zsoy, Eray T z Ayerdem, n, CoRR, abs/2304.107782023</p>
<p>Towards enhancing in-context learning for code generation. Jia Li, Yunfei Zhao, Yongmin Li, Ge Li, Zhi Jin, CoRR, abs/2303.177802023</p>
<p>STALL+: boosting llm-based repository-level code completion with static analysis. Junwei Liu, Yixuan Chen, Mingwei Liu, Xin Peng, Yiling Lou, CoRR, abs/2406.100182024</p>
<p>Is your code generated by chatgpt really correct? rigorous evaluation of large language models for code generation. Jiawei Liu, Chunqiu Steven Xia, Yuyao Wang, Lingming Zhang, Advances in Neural Information Processing Systems. 202436</p>
<p>Large language models are zero-shot fuzzers: Fuzzing deep-learning libraries via large language models. Yinlin Deng, Chunqiu Steven Xia, Haoran Peng, Chenyuan Yang, Lingming Zhang, 2023</p>
<p>Software testing with large language models: Survey, landscape, and vision. Junjie Wang, Yuchao Huang, Chunyang Chen, Zhe Liu, Song Wang, Qing Wang, IEEE Trans. Software Eng. 5042024</p>
<p>Codamosa: Escaping coverage plateaus in test generation with pre-trained large language models. Caroline Lemieux, Jeevana Priya Inala, K Shuvendu, Siddhartha Lahiri, Sen, 45th IEEE/ACM International Conference on Software Engineering, ICSE 2023. Melbourne, AustraliaIEEEMay 14-20, 2023. 2023</p>
<p>Less training, more repairing please: revisiting automated program repair via zeroshot learning. Chunqiu Steven, Xia , Lingming Zhang, Proceedings of the 30th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering. the 30th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering2022</p>
<p>A preliminary evaluation of llm-based fault localization. Sungmin Kang, Gabin An, Shin Yoo, CoRR, abs/2308.054872023</p>
<p>Repair is nearly generation: Multilingual program repair with llms. Harshit Joshi, Jos Pablo, Cambronero Snchez, Sumit Gulwani, Gust Vu Le, Ivan Verbruggen, Radicek, Thirty-Seventh AAAI Conference on Artificial Intelligence, AAAI 2023, Thirty-Fifth Conference on Innovative Applications of Artificial Intelligence, IAAI 2023, Thirteenth Symposium on Educational Advances in Artificial Intelligence. Brian Williams, Yiling Chen, Jennifer Neville, Washington, DC, USAAAAI PressFebruary 7-14, 2023. 20232023</p>
<p>Prompting is all you need: Automated android bug replay with large language models. Sidong Feng, Chunyang Chen, Proceedings of the 46th IEEE/ACM International Conference on Software Engineering, ICSE 2024. the 46th IEEE/ACM International Conference on Software Engineering, ICSE 2024Lisbon, PortugalACMApril 14-20, 2024. 202467</p>
<p>Automated program repair in the era of large pre-trained language models. Chunqiu Steven Xia, Yuxiang Wei, Lingming Zhang, 2023 IEEE/ACM 45th International Conference on Software Engineering (ICSE). IEEE2023</p>
<p>Impact of code language models on automated program repair. Nan Jiang, Kevin Liu, Thibaud Lutellier, Lin Tan, 2023 IEEE/ACM 45th International Conference on Software Engineering (ICSE). IEEE2023</p>
<p>Learning performance-improving code edits. Alexander Shypula, Aman Madaan, Yimeng Zeng, Uri Alon, Jacob R Gardner, Yiming Yang, Milad Hashemi, Graham Neubig, Osbert Parthasarathy Ranganathan, Amir Bastani, Yazdanbakhsh, The Twelfth International Conference on Learning Representations, ICLR 2024. Vienna, AustriaMay 7-11, 2024. 2024OpenReview.net</p>
<p>Ai-assisted coding: Experiments with GPT-4. Thomas Russell A Poldrack, Gasper Lu, Begus, CoRR, abs/2304.131872023</p>
<p>Large language models for compiler optimization. Chris Cummins, Volker Seeker, Dejan Grubisic, Mostafa Elhoushi, Youwei Liang, Baptiste Rozire, Jonas Gehring, Fabian Gloeckle, Kim M Hazelwood, Gabriel Synnaeve, Hugh Leather, CoRR, abs/2309.070622023</p>
<p>Zhiheng Xi, Wenxiang Chen, Xin Guo, Wei He, Yiwen Ding, Boyang Hong, Ming Zhang, Junzhe Wang, Senjie Jin, Enyu Zhou, Rui Zheng, Xiaoran Fan, Xiao Wang, Limao Xiong, Yuhao Zhou, Weiran Wang, Changhao Jiang, Yicheng Zou, Xiangyang Liu, Zhangyue Yin, Shihan Dou, Rongxiang Weng, Wensen Cheng, Qi Zhang, CoRR, abs/2309.07864Wenjuan Qin, Yongyan Zheng, Xipeng Qiu, Xuanjing Huang, and Tao Gui. The rise and potential of large language model based agents: A survey. 2023</p>
<p>Reinforcement learning agents. Artificial intelligence review. Chcr Ribeiro, 200217</p>
<p>Reinforcement learning: A survey. Leslie Pack, Kaelbling Michael L Littman, Andrew W Moore, Journal of artificial intelligence research. 41996</p>
<p>Steps toward artificial intelligence. Marvin Minsky, Proceedings of the IRE. the IRE196149</p>
<p>A social reinforcement learning agent. Charles Isbell, Christian R Shelton, Michael Kearns, Satinder Singh, Peter Stone, Proceedings of the fifth international conference on Autonomous agents. the fifth international conference on Autonomous agents2001</p>
<p>A survey on large language model based autonomous agents. Lei Wang, Chen Ma, Xueyang Feng, Zeyu Zhang, Hao Yang, Jingsen Zhang, Zhiyuan Chen, Jiakai Tang, Xu Chen, Yankai Lin, Wayne Xin Zhao, Zhewei Wei, Jirong Wen, Frontiers Comput. Sci. 1861863452024</p>
<p>A survey on the memory mechanism of large language model based agents. Zeyu Zhang, Xiaohe Bo, Chen Ma, Rui Li, Xu Chen, Quanyu Dai, Jieming Zhu, Zhenhua Dong, Ji-Rong Wen, CoRR, abs/2404.135012024</p>
<p>Large language model based multi-agents: A survey of progress and challenges. Taicheng Guo, Xiuying Chen, Yaqi Wang, Ruidi Chang, Shichao Pei, V Nitesh, Olaf Chawla, Xiangliang Wiest, Zhang, CoRR, abs/2402.016802024</p>
<p>Exploring large language model based intelligent agents: Definitions, methods, and prospects. Yuheng Cheng, Ceyao Zhang, Zhengwen Zhang, Xiangrui Meng, Sirui Hong, Wenhao Li, Zihao Wang, Zekai Wang, Feng Yin, Junhua Zhao, Xiuqiang He, CoRR, abs/2401.034282024</p>
<p>Augmented language models: a survey. Grgoire Mialon, Roberto Dess, Maria Lomeli, Christoforos Nalmpantis, Ramakanth Pasunuru, Roberta Raileanu, Timo Baptiste Rozire, Jane Schick, Asli Dwivedi-Yu, Edouard Celikyilmaz, Yann Grave, Thomas Lecun, Scialom, Trans. Mach. Learn. Res. 20232023</p>
<p>Agent design pattern catalogue: A collection of architectural patterns for foundation model based agents. Yue Liu, Kit Sin, Qinghua Lo, Liming Lu, Dehai Zhu, Xiwei Zhao, Stefan Xu, Jon Harrer, Whittle, CoRR, abs/2405.104672024</p>
<p>Exploring autonomous agents through the lens of large language models: A review. Saikat Barua, CoRR, abs/2404.044422024</p>
<p>A survey on large language models for code generation. Juyong Jiang, Fan Wang, Jiasi Shen, Sungju Kim, Sunghun Kim, CoRR, abs/2406.005152024</p>
<p>Llm-based multiagent systems for software engineering: Vision and the road ahead. Junda He, Christoph Treude, David Lo, arXiv:2404.048342024arXiv preprint</p>
<p>Fairness testing: A comprehensive survey and analysis of trends. Zhenpeng Chen, Jie M Zhang, Max Hort, Mark Harman, Federica Sarro, ACM Trans. Softw. Eng. Methodol. 335592024</p>
<p>A survey of compiler testing. Junjie Chen, Jibesh Patra, Michael Pradel, Yingfei Xiong, Hongyu Zhang, Dan Hao, Lu Zhang, ACM Computing Surveys. 5312020</p>
<p>Finding trends in software research. George Mathew, Amritanshu Agrawal, Tim Menzies, IEEE Trans. Software Eng. 4942023</p>
<p>Empirical research in software engineering -A literature survey. Li Zhang, Jia-Hao Tian, Jing Jiang, Yi-Jun Liu, Meng-Yuan Pu, Tao Yue, J. Comput. Sci. Technol. 3352018</p>
<p>Machine learning testing: Survey, landscapes and horizons. M Jie, Mark Zhang, Lei Harman, Yang Ma, Liu, IEEE Transactions on Software Engineering. 4822022</p>
<p>DBLP. 2024</p>
<p>Opinion mining for software development: A systematic literature review. Bin Lin, Nathan Cassee, Alexander Serebrenik, Gabriele Bavota, Nicole Novielli, Michele Lanza, ACM Trans. Softw. Eng. Methodol. 313412022</p>
<p>Requirements engineering: An overview. Klaus Pohl, 1996Citeseer</p>
<p>Requirements engineering: a roadmap. Bashar Nuseibeh, Steve Easterbrook, Proceedings of the Conference on the Future of Software Engineering. the Conference on the Future of Software Engineering2000</p>
<p>Requirements engineering: a survey. Vivek Shukla, Dhirendra Pandey, Raj Shree, Communications on Applied Electronics. 352015</p>
<p>The unified modeling language. Grady Booch, Ivar Jacobson, James Rumbaugh, Unix Review. 141351996</p>
<p>Entityrelationship-attribute designs and sketches. Theory and Applications of Categories. Michael Johnson, Robert Rosebrugh, Wood, 200210</p>
<p>PRCBERT: prompt learning for requirement classification using bert-based pretrained language models. Xianchang Luo, Yinxing Xue, Zhenchang Xing, Jiamou Sun, 37th IEEE/ACM International Conference on Automated Software Engineering, ASE 2022. Rochester, MI, USAACMOctober 10-14, 2022. 202275</p>
<p>Using llms in software requirements specifications: An empirical evaluation. Madhava Krishna, Bhagesh Gaur, Arsh Verma, Pankaj Jalote, arXiv:2404.178422024arXiv preprint</p>
<p>Empirical evaluation of chatgpt on requirements information retrieval under zero-shot setting. Jianzhang Zhang, Yiyang Chen, Chuang Liu, Nan Niu, Yinglin Wang, 2023 International Conference on Intelligent Computing and Next Generation Networks (ICNGN). IEEE2023</p>
<p>Chatgpt as a tool for user story quality evaluation: Trustworthy out of the box?. Krishna Ronanki, Beatriz Cabrero-Daniel, Christian Berger, International Conference on Agile Software Development. Springer2022</p>
<p>Improving requirements completeness: Automated assistance through large language models. Dipeeka Luitel, Shabnam Hassani, Mehrdad Sabetzadeh, Requirements Engineering. 2912024</p>
<p>Elicitron: An LLM agent-based simulation framework for design requirements elicitation. Mohammadmehdi Ataei, Hyunmin Cheong, Daniele Grandi, Ye Wang, Nigel Morris, Alexander Tessier, CoRR, abs/2404.160452024</p>
<p>Specgen: Automated generation of formal program specifications via large language models. Lezhi Ma, Shangqing Liu, Yi Li, Xiaofei Xie, Lei Bu, arXiv:2401.088072024arXiv preprint</p>
<p>Advancing requirements engineering through generative ai: Assessing the role of llms. Chetan Arora, John Grundy, Mohamed Abdelrazek, Generative AI for Effective Software Development. Springer2024</p>
<p>MARE: multi-agents collaboration framework for requirements engineering. Dongming Jin, Zhi Jin, Xiaohong Chen, Chunhui Wang, CoRR, abs/2405.032562024</p>
<p>An overview of jml tools and applications. Lilian Burdy, Yoonsik Cheon, Michael D David R Cok, Joseph R Ernst, Kiniry, Erik Gary T Leavens, K Rustan M Leino, Poll, International journal on software tools for technology transfer. 72005</p>
<p>Openjml: Jml for java 7 by extending openjdk. David R Cok, NASA Formal Methods: Third International Symposium, NFM 2011. Pasadena, CA, USASpringerApril 18-20, 2011. 20113</p>
<p>Siren's song in the AI ocean: A survey on hallucination in large language models. Yue Zhang, Yafu Li, Leyang Cui, Deng Cai, Lemao Liu, Tingchen Fu, Xinting Huang, Enbo Zhao, Yu Zhang, Yulong Chen, Longyue Wang, Anh Tuan Luu, Wei Bi, Freda Shi, Shuming Shi, CoRR, abs/2309.012192023</p>
<p>Parsel: Algorithmic reasoning with language models by composing decompositions. Eric Zelikman, Qian Huang, Gabriel Poesia, Noah D Goodman, Nick Haber, Advances in Neural Information Processing Systems 36: Annual Conference on Neural Information Processing Systems. Alice Oh, Tristan Naumann, Amir Globerson, Kate Saenko, Moritz Hardt, Sergey Levine, NeurIPS; New Orleans, LA, USA2023. 2023. December 10 -16, 2023, 2023</p>
<p>Reflexion: Language agents with verbal reinforcement learning. Noah Shinn, Federico Cassano, Edward Berman, Ashwin Gopinath, Karthik Narasimhan, Shunyu Yao, 2023</p>
<p>Jianfeng Gao, and Armando Solar-Lezama. Is self-repair a silver bullet for code generation?. Theo X Olausson, Jeevana Priya Inala, Chenglong Wang, 2024</p>
<p>Autogen: Enabling next-gen llm applications via multiagent conversation. Qingyun Wu, Gagan Bansal, Jieyu Zhang, Yiran Wu, Beibin Li, Erkang Zhu, Li Jiang, Xiaoyun Zhang, Shaokun Zhang, Jiale Liu, Ahmed Hassan Awadallah, Ryen W White, Doug Burger, Chi Wang, 2023</p>
<p>Intervenor: Prompting the coding ability of large language models with the interactive chain of repair. Hanbin Wang, Zhenghao Liu, Shuo Wang, Ganqu Cui, Ning Ding, Zhiyuan Liu, Ge Yu, 2024</p>
<p>Test-driven development for code generation. Noble Saji, Mathews , Meiyappan Nagappan, CoRR, abs/2402.135212024</p>
<p>Autocoder: Enhancing code large language model with aiev-instruct. Bin Lei, Yuchen Li, Qiuwu Chen, CoRR, abs/2405.149062024</p>
<p>Camel: Communicative agents for "mind" exploration of large language model society. Guohao Li, Hasan Abed, Al Kader Hammoud, Hani Itani, Dmitrii Khizbullin, Bernard Ghanem, 2023</p>
<p>More agents is all you need. Junyou Li, Qin Zhang, Yangbin Yu, Qiang Fu, Deheng Ye, 2024</p>
<p>Dynamic llm-agent network: An llm-agent collaboration framework with agent team optimization. Zijun Liu, Yanzhe Zhang, Peng Li, Yang Liu, Diyi Yang, 2023</p>
<p>Teaching large language models to self-debug. Xinyun Chen, Maxwell Lin, Nathanael Schrli, Denny Zhou, 2023</p>
<p>Fully autonomous programming with large language models. Vadim Liventsev, Anastasiia Grishina, Aki Hrm, Leon Moonen, Proceedings of the Genetic and Evolutionary Computation Conference. the Genetic and Evolutionary Computation Conference2023</p>
<p>Test-case-driven programming understanding in large language models for better code generation. Junjie Zhao Tian, Xiangyu Chen, Zhang, 2024</p>
<p>Code generation with alphacodium: From prompt engineering to flow engineering. Tal Ridnik, Dedy Kredo, Itamar Friedman, 2024</p>
<p>LDB: A large language model debugger via verifying runtime execution stepby-step. Lily Zhong, Zilong Wang, Jingbo Shang, CoRR, abs/2402.169062024</p>
<p>Language agent tree search unifies reasoning acting and planning in language models. Andy Zhou, Kai Yan, Michal Shlapentokh-Rothman, Haohan Wang, Yu-Xiong Wang, CoRR, abs/2310.044062023</p>
<p>Class-level code generation from natural language using iterative, tool-enhanced reasoning over repository. Ajinkya Deshpande, Anmol Agarwal, Shashank Shet, Arun Iyer, Aditya Kanade, Ramakrishna Bairi, Suresh Parthasarathy, 2024</p>
<p>Toolcoder: Teach code generation models to use api search tools. Kechi Zhang, Huangzhao Zhang, Ge Li, Jia Li, Zhuo Li, Zhi Jin, 2023</p>
<p>Selfevolve: A code evolution framework via large language models. Shuyang Jiang, Yuhao Wang, Yu Wang, 2023</p>
<p>From misuse to mastery: Enhancing code generation with knowledge-driven ai chaining. Xiaoxue Ren, Xinyuan Ye, Dehai Zhao, Zhenchang Xing, Xiaohu Yang, 2023</p>
<p>Yiheng Xu, Hongjin Su, Chen Xing, Boyu Mi, Qian Liu, Weijia Shi, Binyuan Hui, Fan Zhou, Yitao Liu, Tianbao Xie, Zhoujun Cheng, Siheng Zhao, Lingpeng Kong, Bailin Wang, Caiming Xiong, Tao Yu, Lemur: Harmonizing natural language and code for language agents. 2023</p>
<p>Codeagent: Enhancing code generation with tool-integrated agent systems for real-world repo-level coding challenges. Kechi Zhang, Jia Li, Ge Li, Xianjie Shi, Zhi Jin, 2024</p>
<p>Llm4tdd: Best practices for test driven development using large language models. Sanyogita Piya, Allison Sullivan, 2023</p>
<p>Codecot: Tackling code syntax errors in cot reasoning for code generation. Dong Huang, Qingwen Bu, Yuhao Qing, Heming Cui, 2024</p>
<p>Executable code actions elicit better llm agents. Xingyao Wang, Yangyi Chen, Lifan Yuan, Yizhe Zhang, Yunzhu Li, Hao Peng, Heng Ji, 2024</p>
<p>CONLINE: complex code generation and refinement with online searching and correctness testing. Xinyi He, Jiaru Zou, Yun Lin, Mengyu Zhou, Shi Han, Zejian Yuan, Dongmei Zhang, CoRR, abs/2403.135832024</p>
<p>Intercode: Standardizing and benchmarking interactive coding with execution feedback. John Yang, Akshara Prabhakar, Karthik Narasimhan, Shunyu Yao, 2023</p>
<p>Codeplan: Repository-level coding using llms and planning. Ramakrishna Bairi, Atharv Sonwane, Aditya Kanade, D C Vageesh, Arun Iyer, Suresh Parthasarathy, Sriram Rajamani, B Ashok, Shashank Shet, 2023</p>
<p>Teaching code llms to use autocompletion tools in repository-level code generation. Chong Wang, Jian Zhang, Yebo Feng, Tianlin Li, Weisong Sun, Yang Liu, Xin Peng, 2024</p>
<p>Self-refine: Iterative refinement with self-feedback. Aman Madaan, Niket Tandon, Prakhar Gupta, Skyler Hallinan, Luyu Gao, Sarah Wiegreffe, Uri Alon, Nouha Dziri, Shrimai Prabhumoye, Yiming Yang, Shashank Gupta, Bodhisattwa Prasad Majumder, Katherine Hermann, Sean Welleck, Amir Yazdanbakhsh, Peter Clark, Advances in Neural Information Processing Systems 36: Annual Conference on Neural Information Processing Systems. Alice Oh, Tristan Naumann, Amir Globerson, Kate Saenko, Moritz Hardt, Sergey Levine, NeurIPS; New Orleans, LA, USA2023. 2023. December 10 -16, 2023, 2023</p>
<p>Martin Josifoski, Lars Henning Klein, Maxime Peyrard, Yifei Li, Saibo Geng, Julian Paul Schnitzler, Yuxing Yao, Jiheng Wei, Debjit Paul, Robert West, CoRR, abs/2308.01285Flows: Building blocks of reasoning and collaborating AI. 2023</p>
<p>Mint: Evaluating llms in multiturn interaction with tools and language feedback. Xingyao Wang, Zihan Wang, Jiateng Liu, Yangyi Chen, Lifan Yuan, Hao Peng, Heng Ji, 2024</p>
<p>Codechain: Towards modular code generation through chain of self-revisions with representative sub-modules. Hung Le, Hailin Chen, Amrita Saha, Akash Gokul, Doyen Sahoo, Shafiq Joty, 2024</p>
<p>Clarifygpt: Empowering llm-based code generation with intention clarification. Fangwen Mu, Lin Shi, Song Wang, Zhuohao Yu, Binquan Zhang, Chenxue Wang, Shichao Liu, Qing Wang, 2023</p>
<p>Agentcoder: Multi-agent-based code generation with iterative testing and optimisation. Dong Huang, Jie M Zhang, Michael Luck, Qingwen Bu, Yuhao Qing, Heming Cui, 2024</p>
<p>Gentopia: A collaborative platform for tool-augmented llms. Binfeng Xu, Xukun Liu, Hua Shen, Zeyu Han, Yuhan Li, Murong Yue, Zhiyuan Peng, Yuchen Liu, Ziyu Yao, Dongkuan Xu, 2023</p>
<p>Self-organized agents: A LLM multi-agent framework toward ultra large-scale code generation and optimization. Yoichi Ishibashi, Yoshimasa Nishimura, CoRR, abs/2404.021832024</p>
<p>Mapcoder: Multi-agent code generation for competitive problem solving. Ashraful Md, Mohammed Eunus Islam, Md Rizwan Ali, Parvez, CoRR, abs/2405.114032024</p>
<p>Chain-of-thought prompting elicits reasoning in large language models. Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Brian Ichter, Fei Xia, Ed H Chi, V Quoc, Denny Le, Zhou, Advances in Neural Information Processing Systems 35: Annual Conference on Neural Information Processing Systems. S Sanmi Koyejo, A Mohamed, Danielle Agarwal, K Belgrave, A Cho, Oh, NeurIPS; New Orleans, LA, USA2022. 2022. November 28 -December 9, 2022, 2022</p>
<p>Evaluating instruction-tuned large language models on code comprehension and generation. Zhiqiang Yuan, Junwei Liu, Qiancheng Zi, Mingwei Liu, Xin Peng, Yiling Lou, arXiv:2308.012402023arXiv preprint</p>
<p>Xueying Du, Geng Zheng, Kaixin Wang, Jiayi Feng, Wentai Deng, Mingwei Liu, Bihuan Chen, Xin Peng, Tao Ma, Yiling Lou, arXiv:2406.11147Vul-rag: Enhancing llm-based vulnerability detection via knowledge-level rag. 2024arXiv preprint</p>
<p>ART: automatic multi-step reasoning and tool-use for large language models. Bhargavi Paranjape, Scott M Lundberg, Sameer Singh, Hannaneh Hajishirzi, Luke Zettlemoyer, Marco T lio Ribeiro, CoRR, abs/2303.090142023</p>
<p>Beyond the imitation game: Quantifying and extrapolating the capabilities of language models. Aarohi Srivastava, Abhinav Rastogi, Abhishek Rao, Abu Awal, Md Shoeb, Abubakar Abid, Adam Fisch, Adam Adam R Brown, Aditya Santoro, Adri Gupta, Garriga-Alonso, arXiv:2206.046152022arXiv preprint</p>
<p>Large language model-powered smart contract vulnerability detection: New perspectives. Sihao Hu, Tiansheng Huang, Fatih Ilhan, Selim Furkan Tekin, Ling Liu, 5th IEEE International Conference on Trust, Privacy and Security in Intelligent Systems and Applications, TPS-ISA 2023. Atlanta, GA, USAIEEENovember 1-4, 2023. 2023</p>
<p>Static code analysis in the AI era: An in-depth exploration of the concept, function, and potential of intelligent code analysis agents. Gang Fan, Xiaoheng Xie, Xunjin Zheng, Yinan Liang, Peng Di, CoRR, abs/2310.088372023</p>
<p>A dataset of non-functional bugs. Aida Radu, Sarah Nadi, Proceedings of the 16th International Conference on Mining Software Repositories, MSR 2019. D Margaret-Anne, Bram Storey, Sonia Adams, Haiduc, the 16th International Conference on Mining Software Repositories, MSR 2019Montreal, Canada26-27 May 2019. 2019</p>
<p>E&amp;v: Prompting large language models to perform static analysis by pseudo-code execution and verification. Yu Hao, Weiteng Chen, Ziqiao Zhou, Weidong Cui, CoRR, abs/2312.084772023</p>
<p>. Clang, 2024</p>
<p>Llm4vuln: A unified evaluation framework for decoupling and enhancing llms' vulnerability reasoning. Yuqiang Sun, Daoyuan Wu, Yue Xue, Han Liu, Wei Ma, Lyuye Zhang, Miaolei Shi, Yang Liu, CoRR, abs/2401.161852024</p>
<p>Multi-role consensus through llms discussions for vulnerability detection. Zhenyu Mao, Jialong Li, Munan Li, Kenji Tei, CoRR, abs/2403.142742024</p>
<p>Sysevr: A framework for using deep learning to detect software vulnerabilities. Zhen Li, Deqing Zou, Shouhuai Xu, Hai Jin, Yawei Zhu, Zhaoxuan Chen, IEEE Trans. Dependable Secur. Comput. 1942022</p>
<p>Llm-assisted static analysis for detecting security vulnerabilities. Ziyang Li, Saikat Dutta, Mayur Naik, 2024</p>
<p>Ql: Object-oriented queries on relational data. Pavel Avgustinov, Oege De Moor, Michael Peyton Jones, Max Schfer, 30th European Conference on Object-Oriented Programming. 2016. 2016Schloss-Dagstuhl-Leibniz Zentrum f r Informatik</p>
<p>Enhancing static analysis for practical bug detection: An llm-integrated approach. Haonan Li, Yu Hao, Yizhuo Zhai, Zhiyun Qian, Proc. ACM Program. Lang. 8OOPSLA12024</p>
<p>Ubitect: a precise and scalable method to detect usebefore-initialization bugs in linux kernel. Yizhuo Zhai, Yu Hao, Hang Zhang, Daimeng Wang, Chengyu Song, Zhiyun Qian, Mohsen Lesani, Paul Srikanth V Krishnamurthy, Yu, Proceedings of the 28th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering. the 28th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering2020</p>
<p>Comparative assessment of software quality classification techniques: An empirical case study. M Taghi, Naeem Khoshgoftaar, Seliya, Empirical Software Engineering. 92004</p>
<p>Auger: automatically generating review comments with pre-training models. Lingwei Li, Li Yang, Huaxi Jiang, Jun Yan, Tiejian Luo, Zihan Hua, Geng Liang, Chun Zuo, Proceedings of the 30th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering. the 30th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering2022</p>
<p>Codeagent: Collaborative agents for software engineering. Daniel Tang, Zhenghan Chen, Kisub Kim, Yewei Song, Haoye Tian, Saad Ezzini, Yongfeng Huang, Jacques Klein, Tegawend F Bissyand, CoRR, abs/2402.021722024</p>
<p>Ai-powered code review with llms: Early results. Zeeshan Rasheed, Malik Abdul Sami, Muhammad Waseem, Kai-Kristian Kemell, Xiaofeng Wang, Anh Nguyen, Kari Syst, Pekka Abrahamsson, CoRR, abs/2404.184962024</p>
<p>Nalin Wadhwa, Jui Pradhan, Atharv Sonwane, Surya Prakash Sahu, Nagarajan Natarajan, Aditya Kanade, Suresh Parthasarathy, Sriram K Rajamani, abs/2309.12938Frustrated with code quality issues? llms can help! CoRR. 2023</p>
<p>No more manual tests? evaluating and improving chatgpt for unit test generation. Zhiqiang Yuan, Yiling Lou, Mingwei Liu, Shiji Ding, Kaixin Wang, Yixuan Chen, Xin Peng, 2024</p>
<p>An empirical evaluation of using large language models for automated unit test generation. Max Schfer, Sarah Nadi, Aryaz Eghbali, Frank Tip, 2023</p>
<p>Chatunitest: a chatgpt-based automated unit test generation tool. Zhuokui Xie, Yinghao Chen, Chen Zhi, Shuiguang Deng, Jianwei Yin, CoRR, abs/2305.047642023</p>
<p>Enhancing llm-based test generation for hard-to-cover branches via program analysis. Chen Yang, Junjie Chen, Bin Lin, Jianyi Zhou, Ziqi Wang, 2024</p>
<p>Coverup: Coverageguided llm-based test generation. Juan Altmayer, Pizzorno , E Berger, ArXiv, abs/2403.162182024</p>
<p>Effective test generation using pre-trained large language models and mutation testing. Arghavan Moradi Dakhel, Amin Nikanjam, Vahid Majdinasab, Foutse Khomh, Michel C Desmarais, 2023</p>
<p>Conversational automated program repair. Chunqiu Steven, Xia , Lingming Zhang, arXiv:2301.132462023arXiv preprint</p>
<p>Slipcover: Near zero-overhead code coverage for python. Juan Altmayer, Pizzorno , Emery D Berger, Proceedings of the 32nd ACM SIGSOFT International Symposium on Software Testing and Analysis, ISSTA '23. the 32nd ACM SIGSOFT International Symposium on Software Testing and Analysis, ISSTA '23ACMJuly 2023</p>
<p>Kernelgpt: Enhanced kernel fuzzing via large language models. Chenyuan Yang, Zijie Zhao, Lingming Zhang, 2023</p>
<p>Syzkaller. </p>
<p>. The LLVM Compiler Infrastructure. </p>
<p>White-box compiler fuzzing empowered by large language models. Chenyuan Yang, Yinlin Deng, Runyu Lu, Jiayi Yao, Jiawei Liu, Reyhaneh Jabbarvand, Lingming Zhang, 2023</p>
<p>Isolating compiler bugs by generating effective witness programs with large language models. Haoxin Tu, Zhide Zhou, He Jiang, Imam Nur, Bani Yusuf, Yuxian Li, Lingxiao Jiang, IEEE Transactions on Software Engineering. 2024</p>
<p>OCLint. </p>
<p>srcslice: A tool for efficient static forward slicing. Tessandra Christian D Newman, Sage, Hakam W Michael L Collard, Jonathan I Alomari, Maletic, Proceedings of the 38th International Conference on Software Engineering Companion. the 38th International Conference on Software Engineering Companion2016</p>
<p>. Gcov, 2023</p>
<p>. -C Frama, </p>
<p>Make llm a testing expert: Bringing human-like interaction to mobile gui testing via functionality-aware decisions. Zhe Liu, Chunyang Chen, Junjie Wang, Mengzhuo Chen, Boyu Wu, Xing Che, Dandan Wang, Qing Wang, Proceedings of the IEEE/ACM 46th International Conference on Software Engineering. the IEEE/ACM 46th International Conference on Software Engineering2023</p>
<p>Python wrapper of Android uiautomator test tool. 2021</p>
<p>Android Debug, Bridge , Android Developers. 2023</p>
<p>Autonomous large language model agents enabling intent-driven mobile gui testing. Juyeon Yoon, Robert Feldt, Shin Yoo, ArXiv, abs/2311.086492023</p>
<p>Axnav: Replaying accessibility tests from natural language. Maryam Taeb, Amanda Swearngin, Eldon Schoop, Ruijia Cheng, Yue Jiang, Jeffrey Nichols, Proceedings of the CHI Conference on Human Factors in Computing Systems, CHI '24. the CHI Conference on Human Factors in Computing Systems, CHI '24ACMMay 2024</p>
<p>Genymotion -Android Emulator for app testing. 2023</p>
<p>Android Uiautomator2 Python Wrapper. 2023</p>
<p>Zhitao Wang, Wei Wang, Zirao Li, Long Wang, Can Yi, Xinjie Xu, Luyang Cao, Hanjing Su, Shouzhi Chen, Jun Zhou, Xuatcopilot: Multi-agent collaborative system for automated user acceptance testing with large language model. 2024</p>
<p>You can rest now: Automated specification inference and black-box testing of restful apis with large language models. Alix Decrop, Gilles Perrouin, Mike Papadakis, Xavier Devroey, Pierre-Yves Schobbens, 2024</p>
<p>Fuzz4all: Universal fuzzing with large language models. Chunqiu Steven Xia, Matteo Paltenghi, Jia Le Tian, Michael Pradel, Lingming Zhang, 2024</p>
<p>Pentestgpt: An llm-empowered automatic penetration testing tool. Gelei Deng, Yi Liu, Vctor Mayoral-Vilches, Peng Liu, Yuekang Li, Yuan Xu, Tianwei Zhang, Yang Liu, Martin Pinzger, Stefan Rass, 2024</p>
<p>Llm agents can autonomously exploit one-day vulnerabilities. Richard Fang, Rohan Bindu, Akul Gupta, Daniel Kang, 2024</p>
<p>Fill in the blank: Context-aware automated text input generation for mobile GUI testing. Zhe Liu, Chunyang Chen, Junjie Wang, Xing Che, Yuekai Huang, Jun Hu, Qing Wang, 45th IEEE/ACM International Conference on Software Engineering, ICSE 2023. Melbourne, AustraliaIEEEMay 14-20, 2023. 2023</p>
<p>Droidbot-gpt: Gpt-powered UI automation for android. Hongming Hao Wen, Jiaxuan Wang, Yuanchun Liu, Li, CoRR, abs/2304.070612023</p>
<p>Foundations of attack trees. Sjouke Mauw, Martijn Oostdijk, Information Security and Cryptology-ICISC 2005: 8th International Conference. Revised Selected Papers. Seoul, KoreaSpringerDecember 1-2, 2005. 20068</p>
<p>A survey on software fault localization. Eric Wong, Ruizhi Gao, Yihao Li, Rui Abreu, Franz Wotawa, IEEE Transactions on Software Engineering. 4282016</p>
<p>Automatic software repair: A survey. Luca Gazzola, Daniela Micucci, Leonardo Mariani, Proceedings of the 40th International Conference on Software Engineering. the 40th International Conference on Software Engineering2018</p>
<p>A unified debugging approach via llm-based multi-agent synergy. Cheryl Lee, Chunqiu Steven Xia, Jen-Tse Huang, Zhouruixin Zhu, Lingming Zhang, Michael R Lyu, CoRR, abs/2404.171532024</p>
<p>Agentfl: Scaling llm-based fault localization to project-level context. Yihao Qin, Shangwen Wang, Yiling Lou, Jinhao Dong, Kaixin Wang, Xiaoling Li, Xiaoguang Mao, CoRR, abs/2403.163622024</p>
<p>Rcagent: Cloud root cause analysis by autonomous agents with tool-augmented large language models. Zefan Wang, Zichuan Liu, Yingying Zhang, Aoxiao Zhong, Lunting Fan, Lingfei Wu, Qingsong Wen, CoRR, abs/2310.163402023</p>
<p>A preliminary evaluation of llm-based fault localization. Sungmin Kang, Gabin An, Shin Yoo, CoRR, abs/2308.054872023</p>
<p>Deepfl: Integrating multiple fault diagnosis dimensions for deep fault localization. Xia Li, Wei Li, Yuqun Zhang, Lingming Zhang, Proceedings of the 28th ACM SIGSOFT international symposium on software testing and analysis. the 28th ACM SIGSOFT international symposium on software testing and analysis2019</p>
<p>Sequencer: Sequence-to-sequence learning for end-to-end program repair. Zimin Chen, Steve Kommrusch, Michele Tufano, Louis-Nol Pouchet, Denys Poshyvanyk, Martin Monperrus, IEEE Transactions on Software Engineering. 4792019</p>
<p>Automated program repair via conversation: Fixing 162 out of 337 bugs for $0.42 each using chatgpt. Chunqiu Steven, Xia , Lingming Zhang, ISSTA. 2024</p>
<p>Defects4j: A database of existing faults to enable controlled testing studies for java programs. Ren Just, Darioush Jalali, Michael D Ernst, Proceedings of the 2014 international symposium on software testing and analysis. the 2014 international symposium on software testing and analysis2014</p>
<p>Quixbugs: a multi-lingual program repair benchmark set based on the quixey challenge. Derrick Lin, James Koppel, Angela Chen, Armando Solar-Lezama, Proceedings Companion of the 2017 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity. Gail C Murphy, Companion of the 2017 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for HumanityVancouver, BC, Canada, OcACM2017. tober 23 -27, 2017. 2017</p>
<p>Cigar: Cost-efficient program repair with llms. Dvid Hidvgi, Khashayar Etemadi, Sofia Bobadilla, Martin Monperrus, CoRR, abs/2402.065982024</p>
<p>. Mark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Ponde De Oliveira Pinto, Jared Kaplan, Harri Edwards, Yuri Burda, Nicholas Joseph, Greg Brockman, Alex Ray, Raul Puri, Gretchen Krueger, Michael Petrov, Heidy Khlaaf, Girish Sastry, Pamela Mishkin, Brooke Chan, Scott Gray, Nick Ryder, Mikhail Pavlov, Alethea Power, Lukasz Kaiser, Mohammad Bavarian, Clemens Winter, Philippe Tillet ; Igor Babuschkin, Suchir Balaji, Shantanu Jain, William Saunders, Christopher Hesse, Josh Achiam, Vedant Misra, Felipe Petroski Such. Jan Leike,. 2021Ilya Sutskever, and Wojciech Zaremba. Evaluating large language models trained on code</p>
<p>Repairagent: An autonomous, llm-based agent for program repair. Islem Bouzenia, T Premkumar, Michael Devanbu, Pradel, CoRR, abs/2403.171342024</p>
<p>Explainable automated debugging via large language model-driven scientific debugging. Sungmin Kang, Bei Chen, Shin Yoo, Jian-Guang Lou, CoRR, abs/2304.021952023</p>
<p>Bugsinpy: a database of existing bugs in python programs to enable controlled testing and debugging studies. Ratnadira Widyasari, Qin Sheng, Camellia Sim, Haodi Lok, Jack Qi, Qijin Phan, Constance Tay, Fiona Tan, Jodie Ethelda Wee, Yuheng Tan, Yieh, Proceedings of the 28th ACM joint meeting on european software engineering conference and symposium on the foundations of software engineering. the 28th ACM joint meeting on european software engineering conference and symposium on the foundations of software engineering2020</p>
<p>ACFIX: guiding llms with mined common RBAC practices for context-aware repair of access control vulnerabilities in smart contracts. Lyuye Zhang, Kaixuan Li, Kairan Sun, Daoyuan Wu, Ye Liu, Haoye Tian, Yang Liu, CoRR, abs/2403.068382024</p>
<p>Flakiness repair in the era of large language models. Yang Chen, Proceedings of the 2024 IEEE/ACM 46th International Conference on Software Engineering: Companion Proceedings. the 2024 IEEE/ACM 46th International Conference on Software Engineering: Companion Proceedings2024</p>
<p>International Dataset of Flaky tests. </p>
<p>TestingResearchIllinois/idoft. </p>
<p>Domain-specific fixes for flaky tests with wrong assumptions on underdetermined specifications. Peilun Zhang, Yanjie Jiang, Anjiang Wei, Victoria Stodden, Darko Marinov, August Shi, 43rd IEEE/ACM International Conference on Software Engineering, ICSE 2021. Madrid, SpainIEEE22-30 May 2021. 2021</p>
<p>Repairing order-dependent flaky tests via test generation. Chengpeng Li, Chenguang Zhu, Wenxi Wang, August Shi, 44th IEEE/ACM 44th International Conference on Software Engineering, ICSE 2022. Pittsburgh, PA, USAACMMay 25-27, 2022. 2022</p>
<p>Why Programs Fail -A Guide to Systematic Debugging. Andreas Zeller, 2009Academic Press2nd Edition</p>
<p>Can automated program repair refine fault localization? a unified debugging approach. Yiling Lou, Ali Ghanbari, Xia Li, Lingming Zhang, Haotian Zhang, Dan Hao, Lu Zhang, ISSTA '20: 29th ACM SIGSOFT International Symposium on Software Testing and Analysis. Sarfraz Khurshid, Corina S Pasareanu, Virtual Event, USAACMJuly 18-22, 2020. 2020</p>
<p>Evaluating and improving unified debugging. Samuel Benton, Xia Li, Yiling Lou, Lingming Zhang, IEEE Trans. Software Eng. 48112022</p>
<p>On the effectiveness of unified debugging: An extensive study on 16 program repair systems. Samuel Benton, Xia Li, Yiling Lou, Lingming Zhang, 35th IEEE/ACM International Conference on Automated Software Engineering, ASE 2020. Melbourne, AustraliaIEEESeptember 21-25, 2020. 2020</p>
<p>Low-code LLM: visual programming over llms. Yuzhe Cai, Shaoguang Mao, Wenshan Wu, Zehua Wang, Yaobo Liang, Tao Ge, Chenfei Wu, Wang You, Ting Song, Yan Xia, Jonathan Tien, Nan Duan, CoRR, abs/2304.081032023</p>
<p>Prompt sapper: Llm-empowered software engineering infrastructure for ai-native services. Zhenchang Xing, Qing Huang, Yu Cheng, Liming Zhu, Qinghua Lu, Xiwei Xu, CoRR, abs/2306.022302023</p>
<p>Multi-agent collaboration: Harnessing the power of intelligent LLM agents. Yashar Talebirad, Amirhossein Nadiri, CoRR, abs/2306.033142023</p>
<p>Communicative agents for software development. Chen Qian, Xin Cong, Cheng Yang, Weize Chen, Yusheng Su, Juyuan Xu, Zhiyuan Liu, Maosong Sun, CoRR, abs/2307.079242023</p>
<p>Metagpt: Meta programming for a multi-agent collaborative framework. Sirui Hong, Mingchen Zhuge, Jonathan Chen, Xiawu Zheng, Yuheng Cheng, Ceyao Zhang, Jinlin Wang, Zili Wang, Steven Ka, Shing Yau, Zijuan Lin, Liyang Zhou, Chenyu Ran, Lingfeng Xiao, Chenglin Wu, Schmidhuber, 2023</p>
<p>Agentverse: Facilitating multi-agent collaboration and exploring emergent behaviors in agents. Weize Chen, Yusheng Su, Jingwei Zuo, Cheng Yang, Chenfei Yuan, Chen Qian, Chi-Min Chan, Yujia Qin, Yaxi Lu, Ruobing Xie, Zhiyuan Liu, Maosong Sun, Jie Zhou, CoRR, abs/2308.108482023</p>
<p>Autoagents: A framework for automatic agent generation. Guangyao Chen, Siwei Dong, Yu Shu, Ge Zhang, Jaward Sesay, B , F Karlsson, Jie Fu, Yemin Shi, CoRR, abs/2309.172882023</p>
<p>Experiential co-learning of software-developing agents. Chen Qian, Yufan Dang, Jiahao Li, Wei Liu, Weize Chen, Cheng Yang, Zhiyuan Liu, Maosong Sun, CoRR, abs/2312.170252023</p>
<p>Experimenting a new programming practice with llms. Simiao Zhang, Jiaping Wang, Guoliang Dong, Jun Sun, Yueling Zhang, Geguang Pu, CoRR, abs/2401.010622024</p>
<p>LLM4PLC: harnessing large language models for verifiable programming of plcs in industrial control systems. Mohamad Fakih, Rahul Dharmaji, Yasamin Moghaddas, Gustavo Quiros, Oluwatosin Ogundare, Mohammad Abdullah, Al Faruque, Proceedings of the 46th International Conference on Software Engineering: Software Engineering in Practice, ICSE-SEIP 2024. the 46th International Conference on Software Engineering: Software Engineering in Practice, ICSE-SEIP 2024Lisbon, PortugalACMApril 14-20, 2024. 2024</p>
<p>Codepori: Large scale model for autonomous software development by using multi-agents. Zeeshan Rasheed, Muhammad Waseem, Mika Saari, Kari Syst, Pekka Abrahamsson, CoRR, abs/2402.014112024</p>
<p>When llm-based code generation meets the software development process. Feng Lin, Dong Jae Kim, Tse-Hsun Chen, CoRR, abs/2403.158522024</p>
<p>Codes: Natural language to code repository via multi-layer sketch. Daoguang Zan, Ailun Yu, Wei Liu, Dong Chen, Bo Shen, Wei Li, Yafen Yao, Yongshun Gong, Xiaolin Chen, Bei Guan, Zhiguang Yang, Yongji Wang, Qianxiang Wang, Lizhen Cui, CoRR, abs/2403.164432024</p>
<p>Iterative experience refinement of softwaredeveloping agents. Chen Qian, Jiahao Li, Yufan Dang, Wei Liu, Yifei Wang, Zihao Xie, Weize Chen, Cheng Yang, Yingli Zhang, Zhiyuan Liu, Maosong Sun, CoRR, abs/2405.042192024</p>
<p>Multi-agent software development through cross-team collaboration. Zhuoyun Du, Chen Qian, Wei Liu, Zihao Xie, Yifei Wang, Yufan Dang, Weize Chen, Cheng Yang, 2024</p>
<p>Minh Huynh Nguyen, Thang Phan Chau, Phong X Nguyen, Nghi, Bui, arXiv:2406.11912Agilecoder: Dynamic collaborative agents for software development based on agile methodology. 2024arXiv preprint</p>
<p>Managing the development of large software systems: Concepts and techniques. W W Royce, Proceedings, 9th International Conference on Software Engineering. William E Riddle, Robert M Balzer, Kouichi Kishida, 9th International Conference on Software EngineeringMonterey, California, USAACM PressMarch 30 -April 2, 1987. 1987</p>
<p>A survey on incremental software development life cycle model. Ha Thakur, Maurya, Int. J. Eng. Technol. Comput. Res. 322016</p>
<p>The unified process. Ivar Jacobson, Grady Booch, James Rumbaugh, Ieee Software. 163961999</p>
<p>Agile software process model. Mikio Aoyama, Proceedings Twenty-First Annual International Computer Software and Applications Conference (COMPSAC'97). Twenty-First Annual International Computer Software and Applications Conference (COMPSAC'97)IEEE1997</p>
<p>Codescore: Evaluating code generation by learning code execution. Yihong Dong, Jiazheng Ding, Xue Jiang, Ge Li, Zhuo Li, Zhi Jin, 2023</p>
<p>Program synthesis with large language models. Jacob Austin, Augustus Odena, Maxwell Nye, Maarten Bosma, Henryk Michalewski, David Dohan, Ellen Jiang, Carrie Cai, Michael Terry, Quoc Le, Charles Sutton, 2021</p>
<p>MAGIS: llm-based multi-agent framework for github issue resolution. Wei Tao, Yucheng Zhou, Wenqiang Zhang, Yu Cheng, CoRR, abs/2403.179272024</p>
<p>Autocoderover: Autonomous program improvement. Yuntong Zhang, Haifeng Ruan, Zhiyu Fan, Abhik Roychoudhury, CoRR, abs/2404.054272024</p>
<p>John Yang, Carlos E Jimenez, Alexander Wettig, Kilian Lieret, Shunyu Yao, Karthik Narasimhan, Ofir Press, arXiv:2405.15793Swe-agent: Agent-computer interfaces enable automated software engineering. 2024arXiv preprint</p>
<p>Dong Chen, Shaoxin Lin, Muhan Zeng, Daoguang Zan, Jian-Gang Wang, Anton Cheshkov, Jun Sun, Hao Yu, Guoliang Dong, Artem Aliev, arXiv:2406.01304Issue resolving with multi-agent and task graphs. 2024arXiv preprint</p>
<p>Yingwei Ma, Qingping Yang, Rongyu Cao, Binhua Li, Fei Huang, Yongbin Li, arXiv:2406.01422How to understand whole software repository?. 2024arXiv preprint</p>
<p>Daman Arora, Atharv Sonwane, Nalin Wadhwa, Abhav Mehrotra, Saiteja Utpala, Ramakrishna Bairi, Aditya Kanade, and Nagarajan Natarajan. Masai: Modular architecture for softwareengineering ai agents. 2024</p>
<p>Agentless: Demystifying llm-based software engineering agents. Chunqiu Steven Xia, Yinlin Deng, Soren Dunn, Lingming Zhang, CoRR, abs/2407.014892024</p>
<p>Some simple effective approximations to the 2-poisson model for probabilistic weighted retrieval. Steve Stephen E Robertson, Walker, SIGIR'94: Proceedings of the Seventeenth Annual International ACM-SIGIR Conference on Research and Development in Information Retrieval. Springer1994organised by Dublin City University</p>
<p>Swe-bench: Can language models resolve real-world github issues?. Carlos E Jimenez, John Yang, Alexander Wettig, Shunyu Yao, Kexin Pei, Ofir Press, Karthik Narasimhan, CoRR, abs/2310.067702023</p>
<p>. Swe-Bench Lite, 2024</p>
<p>Introducing SWE-bench Verified. 2024</p>
<p>Function Calling and other API updates. 2023</p>
<p>GPT-4. 2023</p>
<p>React: Synergizing reasoning and acting in language models. Shunyu Yao, Jeffrey Zhao, Dian Yu, Nan Du, Izhak Shafran, R Karthik, Yuan Narasimhan, Cao, The Eleventh International Conference on Learning Representations, ICLR 2023. Kigali, RwandaMay 1-5, 2023. OpenReview.net, 2023</p>
<p>Low-code llm: Visual programming over llms. Yuzhe Cai, Shaoguang Mao, Wenshan Wu, Zehua Wang, Yaobo Liang, Tao Ge, Chenfei Wu, Wang You, Ting Song, Yan Xia, arXiv:2304.081032023arXiv preprint</p>
<p>Transformer feed-forward layers are key-value memories. Mor Geva, Roei Schuster, Jonathan Berant, Omer Levy, Proceedings of the 2021 Conference on Empirical Methods in Natural Language Processing, EMNLP 2021, Virtual Event / Punta Cana. Marie-Francine Moens, Xuanjing Huang, Lucia Specia, Scott , Wen-Tau Yih, the 2021 Conference on Empirical Methods in Natural Language Processing, EMNLP 2021, Virtual Event / Punta CanaDominican Republic7-11 November, 2021. 2021Association for Computational Linguistics</p>
<p>Blackboard systems. Iain D Craig, Artificial Intelligence Review. 221988</p>
<p>Uml diagrams in software engineering research: a systematic literature review. Hatice Koc,  , Ali Mert Erdo Gan, Yousef Barjakly, Serhat Peker, Proceedings. nullMDPI20217413</p>
<p>Seglink++: Detecting dense and arbitrary-shaped scene text by instance-aware component grouping. Pattern recognition. Jun Tang, Zhibo Yang, Yongpan Wang, Qi Zheng, Yongchao Xu, Xiang Bai, 201996106954</p>
<p>A convnet for the 2020s. Zhuang Liu, Hanzi Mao, Chao-Yuan Wu, Christoph Feichtenhofer, Trevor Darrell, Saining Xie, Proceedings of the IEEE/CVF conference on computer vision and pattern recognition. the IEEE/CVF conference on computer vision and pattern recognition2022</p>
<p>Enchanting program specification synthesis by large language models using static analysis and program verification. Cheng Wen, Jialun Cao, Jie Su, Zhiwu Xu, Shengchao Qin, Mengda He, Haokun Li, Shing-Chi Cheung, Cong Tian, 2024</p>
<p>Repoagent: An llm-powered open-source framework for repository-level code documentation generation. Qinyu Luo, Yining Ye, Shihao Liang, Zhong Zhang, Yujia Qin, Yaxi Lu, Yesai Wu, Xin Cong, Yankai Lin, Yingli Zhang, Xiaoyin Che, Zhiyuan Liu, Maosong Sun, 2024</p>
<p>Cocost: Automatic complex code generation with online searching and correctness testing. Xinyi He, Jiaru Zou, Yun Lin, Mengyu Zhou, Shi Han, Zejian Yuan, Dongmei Zhang, 2024</p>
<p>Seglink++: Detecting dense and arbitrary-shaped scene text by instance-aware component grouping. Pattern Recognition. Jun Tang, Zhibo Yang, Yongpan Wang, Qi Zheng, Yongchao Xu, Xiang Bai, 201996106954</p>
<p>Screen recognition: Creating accessibility metadata for mobile applications from pixels. Xiaoyi Zhang, Lilian De Greef, Amanda Swearngin, Samuel White, Kyle Murray, Lisa Yu, Qi Shan, Jeffrey Nichols, Jason Wu, Chris Fleizach, Proceedings of the 2021 CHI Conference on Human Factors in Computing Systems. the 2021 CHI Conference on Human Factors in Computing Systems2021</p>
<p>A convnet for the 2020s. Zhuang Liu, Hanzi Mao, Chao-Yuan Wu, Christoph Feichtenhofer, Trevor Darrell, Saining Xie, Proceedings of the IEEE/CVF conference on computer vision and pattern recognition. the IEEE/CVF conference on computer vision and pattern recognition2022</p>
<p>Antlr: A predicated-ll(k) parser generator. Software: Practice and Experience. T J Parr, R W Quong, 199525</p>
<p>EclipseJDTLS. </p>
<p>. Black, </p>
<p>The nuxmv symbolic model checker. Roberto Cavada, Alessandro Cimatti, Michele Dorigatti, Alberto Griggio, Alessandro Mariotti, Andrea Micheli, Sergio Mover, Marco Roveri, Stefano Tonetta, Computer Aided Verification. Armin Biere, Roderick Bloem, ChamSpringer International Publishing2014</p>
<p>Slither: a static analysis framework for smart contracts. Josselin Feist, Gustavo Grieco, Alex Groce, IEEE/ACM 2nd International Workshop on Emerging Trends in Software Engineering for Blockchain. 2019. 2019IEEE</p>
<p>GPT-4. 2024</p>
<p>Pynguin: automated unit test generation for python. Stephan Lukasczyk, Gordon Fraser, Proceedings of the ACM/IEEE 44th International Conference on Software Engineering: Companion Proceedings, ICSE '22. the ACM/IEEE 44th International Conference on Software Engineering: Companion Proceedings, ICSE '22ACMMay 2022</p>
<p>Mutpy: a mutation testing tool for python 3.x source code. Konrad Haas, 2019</p>
<p>Gzoltar: an eclipse plug-in for testing and debugging. Jos Campos, Andr Riboira, Alexandre Perez, Rui Abreu, Proceedings of the 27th IEEE/ACM international conference on automated software engineering. the 27th IEEE/ACM international conference on automated software engineering2012</p>
<p>Git. </p>
<p>Engineering safety requirements for autonomous driving with large language models. Ali Nouri, Beatriz Cabrero Daniel, Hkan Fredrik T rner, Christian Sivencrona, Berger, CoRR, abs/2403.162892024</p>
<p>. OpenAI: Introducing ChatGPT. 2022</p>
<p>Deepseek-coder: When the large language model meets programming -the rise of code intelligence. Daya Guo, Qihao Zhu, Dejian Yang, Zhenda Xie, Kai Dong, Wentao Zhang, Guanting Chen, Xiao Bi, Y Wu, Y K Li, Fuli Luo, Yingfei Xiong, Wenfeng Liang, CoRR, abs/2401.141962024</p>
<p>Starcoder 2 and the stack v2: The next generation. Anton Lozhkov, Raymond Li, Loubna Ben Allal, Federico Cassano, Joel Lamy-Poirier, Nouamane Tazi, Ao Tang, Dmytro Pykhtar, Jiawei Liu, Yuxiang Wei, arXiv:2402.191732024arXiv preprint</p>            </div>
        </div>

    </div>
</body>
</html>