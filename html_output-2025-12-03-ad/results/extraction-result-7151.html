<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-7151 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-7151</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-7151</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-134.html">extraction-schema-134</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform self‑reflection or self‑critique, including the specific reflection method, number of generate‑then‑reflect iterations, tasks or benchmarks evaluated, performance before and after reflection, evaluation metrics, and any reported limitations or failure cases.</div>
                <p><strong>Paper ID:</strong> paper-6c17de3e719c0f4d1df6a16f770c2a9a5f18206f</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/6c17de3e719c0f4d1df6a16f770c2a9a5f18206f" target="_blank">Toward Self-Improvement of LLMs via Imagination, Searching, and Criticizing</a></p>
                <p><strong>Paper Venue:</strong> Neural Information Processing Systems</p>
                <p><strong>Paper TL;DR:</strong> AlphaLLM is introduced, which integrates Monte Carlo Tree Search with LLMs to establish a self-improving loop, thereby enhancing the capabilities of LLMs without additional annotations, showing the potential for self-improvement in LLMs.</p>
                <p><strong>Paper Abstract:</strong> Despite the impressive capabilities of Large Language Models (LLMs) on various tasks, they still struggle with scenarios that involves complex reasoning and planning. Recent work proposed advanced prompting techniques and the necessity of fine-tuning with high-quality data to augment LLMs' reasoning abilities. However, these approaches are inherently constrained by data availability and quality. In light of this, self-correction and self-learning emerge as viable solutions, employing strategies that allow LLMs to refine their outputs and learn from self-assessed rewards. Yet, the efficacy of LLMs in self-refining its response, particularly in complex reasoning and planning task, remains dubious. In this paper, we introduce AlphaLLM for the self-improvements of LLMs, which integrates Monte Carlo Tree Search (MCTS) with LLMs to establish a self-improving loop, thereby enhancing the capabilities of LLMs without additional annotations. Drawing inspiration from the success of AlphaGo, AlphaLLM addresses the unique challenges of combining MCTS with LLM for self-improvement, including data scarcity, the vastness search spaces of language tasks, and the subjective nature of feedback in language tasks. AlphaLLM is comprised of prompt synthesis component, an efficient MCTS approach tailored for language tasks, and a trio of critic models for precise feedback. Our experimental results in mathematical reasoning tasks demonstrate that AlphaLLM significantly enhances the performance of LLMs without additional annotations, showing the potential for self-improvement in LLMs.</p>
                <p><strong>Cost:</strong> 0.017</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e7151.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e7151.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform self‑reflection or self‑critique, including the specific reflection method, number of generate‑then‑reflect iterations, tasks or benchmarks evaluated, performance before and after reflection, evaluation metrics, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>AlPHALLM</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Imagination-Searching-Criticizing (AlPHALLM)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A self-improvement framework that synthesizes prompts, uses an option-level Monte Carlo Tree Search (ηMCTS) guided by three learned critics (value function, Process Reward Model (PRM), Outcome Reward Model (ORM)), and then fine-tunes the policy on the best trajectories to iteratively improve LLM performance without additional human annotations.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Llama-2-70B / WizardMath-70B-V1.0</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Large autoregressive transformer language models used as the policy; critics are LLM-derived (PRM, ORM initialized from policy) and a separate value-function LLM with MLP head.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>70B</td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_name</strong></td>
                            <td>Imagination-Searching-Criticizing (ηMCTS + critics)</td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_description</strong></td>
                            <td>Synthesize prompts, perform an option-level MCTS (ηMCTS) where candidate partial/full solutions (options) are expanded and evaluated by a trio of critics (value function estimating expected return, PRM giving immediate/process-level textual rewards, and ORM evaluating final outcomes possibly using external tools). The top-scoring trajectory per prompt is selected as training data to fine-tune the policy; the loop can be repeated (self-improving rounds).</td>
                        </tr>
                        <tr>
                            <td><strong>iteration_type</strong></td>
                            <td>search-guided generate-and-evaluate followed by policy fine-tuning (iterative self-improvement loop)</td>
                        </tr>
                        <tr>
                            <td><strong>num_iterations</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>GSM8K (grade-school math), MATH (competition-level math subset)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>GSM8K: grade-school math word problems (final-answer correctness); MATH: harder math competition problems (subset used due to compute).</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_metric</strong></td>
                            <td>Accuracy (percent correct final answers)</td>
                        </tr>
                        <tr>
                            <td><strong>performance_before_reflection</strong></td>
                            <td>Llama-2-70B greedy: 57.8% (GSM8K); WizardMath-70B-V1.0 greedy: 20.7% (MATH).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_after_reflection</strong></td>
                            <td>AlPHALLM after ηMCTS decoding (no finetune): GSM8K 88.9%, MATH 48.7%; After two rounds of self-improvement (training on trajectories) + ηMCTS decoding: GSM8K 92.0%, MATH 51.0%. (Reported in Table 2 and text.)</td>
                        </tr>
                        <tr>
                            <td><strong>improvement_observed</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Noted limitations: evaluations only on math tasks; critics are static (not updated continuously) which may create discriminator-generator gap; greedy decoding of the improved policy remains much weaker than ηMCTS decoding (i.e., improvements often rely on search at inference), suggesting limited transfer of improvements to base policy; possible insufficient synthetic-data volume or base-model capacity to learn from generated trajectories; PRM shows lower precision and poor calibration (PRM precision 0.62, recall 0.90, ECE 0.375 vs value function precision 0.82, ECE 0.032) meaning process feedback can be noisy; ORM can be biased by the fast-rollout policy and for hard math problems ORM needs external tools (ablation: intrinsic-knowledge-only ORM drops MATH accuracy to 38.8%); option-level vs sentence-level ablation shows performance drop and increased rollouts when options are removed; compute cost is high (70B models, many rollouts, training resources cited).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Toward Self-Improvement of LLMs via Imagination, Searching, and Criticizing', 'publication_date_yy_mm': '2024-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e7151.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e7151.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform self‑reflection or self‑critique, including the specific reflection method, number of generate‑then‑reflect iterations, tasks or benchmarks evaluated, performance before and after reflection, evaluation metrics, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>ηMCTS (AlPHALLM decoding)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Option-level Monte Carlo Tree Search with Importance-Based Adaptive Branching and State Merge (ηMCTS)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An MCTS variant tailored for language tasks that (1) uses option-level nodes (multi-token options) to reduce depth, (2) adapts node branching factors by estimated node importance, (3) merges similar states, and (4) uses a fast rollout LM plus critics (value, PRM, ORM) to score trajectories.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Llama-2-70B (policy) with Abel-002-7B fast-rollout; critics initialized from policy / value-function Llama-2-13B</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Policy: Llama-2-70B or WizardMath-70B; fast rollout: Abel-002-7B; critics: PRM and ORM initialized from policy, value-function a smaller Llama-2-13B with MLP head.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>policy 70B; fast-rollout 7B; value 13B</td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_name</strong></td>
                            <td>ηMCTS decoding with critics</td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_description</strong></td>
                            <td>At decoding time, run ηMCTS with option-level expansion; evaluate nodes and rollouts with weighted sum of critics (β_value * value + β_PRM * PRM + β_ORM * expected ORM from fast-rollouts); select best leaf trajectory as final output (no policy fine-tuning needed to apply).</td>
                        </tr>
                        <tr>
                            <td><strong>iteration_type</strong></td>
                            <td>generate-and-evaluate via search (single-shot per prompt; can be run with varying numbers of rollouts)</td>
                        </tr>
                        <tr>
                            <td><strong>num_iterations</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>GSM8K, MATH</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Mathematical reasoning benchmarks measuring final-answer correctness.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_metric</strong></td>
                            <td>Accuracy (percent correct final answers); also average number of rollouts (#tree nodes) reported as computational cost.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_before_reflection</strong></td>
                            <td>Baseline greedy decoding (policy) — GSM8K 57.8% (Llama-2-70B), MATH 20.7% (WizardMath-70B-V1.0).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_after_reflection</strong></td>
                            <td>ηMCTS decoding (no finetune) — GSM8K 88.9% (with larger rollouts ~230 reported in table; also smaller rollout configs: ~55 gave 87.0%), MATH 48.7% (with 341 rollouts; smaller 223 rollouts gave 45.4%).</td>
                        </tr>
                        <tr>
                            <td><strong>improvement_observed</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Performance depends on number of rollouts (trade-off compute vs accuracy); ORM can inherit bias from the fast-rollout policy; fast-rollout model choice affects bias/variance (Llama-2-70B rollouts reduced bias but are slower, Abel-002-7B faster but slightly more biased); without tool-augmentation ORM underperforms on hard math problems; search gains may not translate to greedy policy behavior unless fine-tuned extensively.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Toward Self-Improvement of LLMs via Imagination, Searching, and Criticizing', 'publication_date_yy_mm': '2024-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e7151.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e7151.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform self‑reflection or self‑critique, including the specific reflection method, number of generate‑then‑reflect iterations, tasks or benchmarks evaluated, performance before and after reflection, evaluation metrics, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Self-consistency (baseline)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Self-consistency (sampling multiple chains-of-thought and voting)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A decoding aggregation method that samples multiple reasoning chains and picks the most consistent final answer (voting); used as a baseline in the paper's search-comparison experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Llama-2-70B (policy; used as baseline in Table 7)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Same base policy model used for other baselines; self-consistency aggregates across multiple sampled outputs.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>70B</td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_name</strong></td>
                            <td>Self-consistency (majority/plurality over multiple samples)</td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_description</strong></td>
                            <td>Generate N diverse chain-of-thought samples and take majority vote (or heuristic) over final answers to reduce variance and improve correctness.</td>
                        </tr>
                        <tr>
                            <td><strong>iteration_type</strong></td>
                            <td>voting over multiple samples</td>
                        </tr>
                        <tr>
                            <td><strong>num_iterations</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>GSM8K, MATH</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Mathematical reasoning (final-answer correctness).</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_metric</strong></td>
                            <td>Accuracy (percent correct final answers)</td>
                        </tr>
                        <tr>
                            <td><strong>performance_before_reflection</strong></td>
                            <td>Greedy baseline: GSM8K 57.8%, MATH 20.7%.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_after_reflection</strong></td>
                            <td>Self-consistency results reported: GSM8K — 10 samples: 67.4%; 30 samples: 74.2%; 50 samples: 75.4%. MATH — 10 samples: 22.5%; 30 samples: 27.3%; 50 samples: 28.8%. (Table 7)</td>
                        </tr>
                        <tr>
                            <td><strong>improvement_observed</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Requires many samples (computational cost); performance lags behind re-ranking/ηMCTS approaches in the experiments; does not explicitly critique or refine individual samples, only aggregates outputs.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Toward Self-Improvement of LLMs via Imagination, Searching, and Criticizing', 'publication_date_yy_mm': '2024-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e7151.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e7151.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform self‑reflection or self‑critique, including the specific reflection method, number of generate‑then‑reflect iterations, tasks or benchmarks evaluated, performance before and after reflection, evaluation metrics, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Re-ranking (ORM-based)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Reranking using Outcome Reward Model (ORM)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Generate multiple candidate trajectories and rerank them using a learned outcome reward model (ORM) that assesses full trajectories; used as a competitive baseline in experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Llama-2-70B (policy) with ORM initialized from policy</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Generate N candidates via sampling from policy; ORM (text-generation evaluator) scores each trajectory; select highest-scoring trajectory.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>70B</td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_name</strong></td>
                            <td>Reranking with ORM</td>
                        </tr>
                        <tr>
                            <td><strong>reflection_method_description</strong></td>
                            <td>Produce multiple candidate solutions, have ORM score each complete trajectory for quality/outcome, and pick the highest-scoring trajectory as final output.</td>
                        </tr>
                        <tr>
                            <td><strong>iteration_type</strong></td>
                            <td>generate multiple samples then select (reranking)</td>
                        </tr>
                        <tr>
                            <td><strong>num_iterations</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>GSM8K, MATH</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Mathematical reasoning benchmarks.</td>
                        </tr>
                        <tr>
                            <td><strong>evaluation_metric</strong></td>
                            <td>Accuracy (percent correct final answers)</td>
                        </tr>
                        <tr>
                            <td><strong>performance_before_reflection</strong></td>
                            <td>Greedy baseline: GSM8K 57.8%, MATH 20.7%.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_after_reflection</strong></td>
                            <td>Re-ranking results reported: GSM8K — 10 samples: 80.8%; 30 samples: 86.3%; 50 samples: 87.7%. MATH — 10 samples: 34.1%; 30 samples: 39.0%; 50 samples: 42.0%. (Table 7)</td>
                        </tr>
                        <tr>
                            <td><strong>improvement_observed</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failure_cases</strong></td>
                            <td>Requires many candidates (higher compute); ORM quality is crucial — on hard math tasks ORM benefits substantially from external tool usage (ablation shows intrinsic-only ORM drops MATH accuracy to 38.8%); reranking still underperforms ηMCTS for equivalent or larger rollout budgets in these experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Toward Self-Improvement of LLMs via Imagination, Searching, and Criticizing', 'publication_date_yy_mm': '2024-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Self-refine: Iterative refinement with self-feedback <em>(Rating: 2)</em></li>
                <li>Self-critiquing models for assisting human evaluators <em>(Rating: 2)</em></li>
                <li>Let's verify step by step <em>(Rating: 2)</em></li>
                <li>Solving math word problems with process-and outcome-based feedback <em>(Rating: 2)</em></li>
                <li>Alphazero-like treesearch can guide large language model decoding and training <em>(Rating: 2)</em></li>
                <li>Self-rewarding language models <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-7151",
    "paper_id": "paper-6c17de3e719c0f4d1df6a16f770c2a9a5f18206f",
    "extraction_schema_id": "extraction-schema-134",
    "extracted_data": [
        {
            "name_short": "AlPHALLM",
            "name_full": "Imagination-Searching-Criticizing (AlPHALLM)",
            "brief_description": "A self-improvement framework that synthesizes prompts, uses an option-level Monte Carlo Tree Search (ηMCTS) guided by three learned critics (value function, Process Reward Model (PRM), Outcome Reward Model (ORM)), and then fine-tunes the policy on the best trajectories to iteratively improve LLM performance without additional human annotations.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "Llama-2-70B / WizardMath-70B-V1.0",
            "model_description": "Large autoregressive transformer language models used as the policy; critics are LLM-derived (PRM, ORM initialized from policy) and a separate value-function LLM with MLP head.",
            "model_size": "70B",
            "reflection_method_name": "Imagination-Searching-Criticizing (ηMCTS + critics)",
            "reflection_method_description": "Synthesize prompts, perform an option-level MCTS (ηMCTS) where candidate partial/full solutions (options) are expanded and evaluated by a trio of critics (value function estimating expected return, PRM giving immediate/process-level textual rewards, and ORM evaluating final outcomes possibly using external tools). The top-scoring trajectory per prompt is selected as training data to fine-tune the policy; the loop can be repeated (self-improving rounds).",
            "iteration_type": "search-guided generate-and-evaluate followed by policy fine-tuning (iterative self-improvement loop)",
            "num_iterations": null,
            "task_name": "GSM8K (grade-school math), MATH (competition-level math subset)",
            "task_description": "GSM8K: grade-school math word problems (final-answer correctness); MATH: harder math competition problems (subset used due to compute).",
            "evaluation_metric": "Accuracy (percent correct final answers)",
            "performance_before_reflection": "Llama-2-70B greedy: 57.8% (GSM8K); WizardMath-70B-V1.0 greedy: 20.7% (MATH).",
            "performance_after_reflection": "AlPHALLM after ηMCTS decoding (no finetune): GSM8K 88.9%, MATH 48.7%; After two rounds of self-improvement (training on trajectories) + ηMCTS decoding: GSM8K 92.0%, MATH 51.0%. (Reported in Table 2 and text.)",
            "improvement_observed": true,
            "limitations_or_failure_cases": "Noted limitations: evaluations only on math tasks; critics are static (not updated continuously) which may create discriminator-generator gap; greedy decoding of the improved policy remains much weaker than ηMCTS decoding (i.e., improvements often rely on search at inference), suggesting limited transfer of improvements to base policy; possible insufficient synthetic-data volume or base-model capacity to learn from generated trajectories; PRM shows lower precision and poor calibration (PRM precision 0.62, recall 0.90, ECE 0.375 vs value function precision 0.82, ECE 0.032) meaning process feedback can be noisy; ORM can be biased by the fast-rollout policy and for hard math problems ORM needs external tools (ablation: intrinsic-knowledge-only ORM drops MATH accuracy to 38.8%); option-level vs sentence-level ablation shows performance drop and increased rollouts when options are removed; compute cost is high (70B models, many rollouts, training resources cited).",
            "uuid": "e7151.0",
            "source_info": {
                "paper_title": "Toward Self-Improvement of LLMs via Imagination, Searching, and Criticizing",
                "publication_date_yy_mm": "2024-04"
            }
        },
        {
            "name_short": "ηMCTS (AlPHALLM decoding)",
            "name_full": "Option-level Monte Carlo Tree Search with Importance-Based Adaptive Branching and State Merge (ηMCTS)",
            "brief_description": "An MCTS variant tailored for language tasks that (1) uses option-level nodes (multi-token options) to reduce depth, (2) adapts node branching factors by estimated node importance, (3) merges similar states, and (4) uses a fast rollout LM plus critics (value, PRM, ORM) to score trajectories.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "Llama-2-70B (policy) with Abel-002-7B fast-rollout; critics initialized from policy / value-function Llama-2-13B",
            "model_description": "Policy: Llama-2-70B or WizardMath-70B; fast rollout: Abel-002-7B; critics: PRM and ORM initialized from policy, value-function a smaller Llama-2-13B with MLP head.",
            "model_size": "policy 70B; fast-rollout 7B; value 13B",
            "reflection_method_name": "ηMCTS decoding with critics",
            "reflection_method_description": "At decoding time, run ηMCTS with option-level expansion; evaluate nodes and rollouts with weighted sum of critics (β_value * value + β_PRM * PRM + β_ORM * expected ORM from fast-rollouts); select best leaf trajectory as final output (no policy fine-tuning needed to apply).",
            "iteration_type": "generate-and-evaluate via search (single-shot per prompt; can be run with varying numbers of rollouts)",
            "num_iterations": null,
            "task_name": "GSM8K, MATH",
            "task_description": "Mathematical reasoning benchmarks measuring final-answer correctness.",
            "evaluation_metric": "Accuracy (percent correct final answers); also average number of rollouts (#tree nodes) reported as computational cost.",
            "performance_before_reflection": "Baseline greedy decoding (policy) — GSM8K 57.8% (Llama-2-70B), MATH 20.7% (WizardMath-70B-V1.0).",
            "performance_after_reflection": "ηMCTS decoding (no finetune) — GSM8K 88.9% (with larger rollouts ~230 reported in table; also smaller rollout configs: ~55 gave 87.0%), MATH 48.7% (with 341 rollouts; smaller 223 rollouts gave 45.4%).",
            "improvement_observed": true,
            "limitations_or_failure_cases": "Performance depends on number of rollouts (trade-off compute vs accuracy); ORM can inherit bias from the fast-rollout policy; fast-rollout model choice affects bias/variance (Llama-2-70B rollouts reduced bias but are slower, Abel-002-7B faster but slightly more biased); without tool-augmentation ORM underperforms on hard math problems; search gains may not translate to greedy policy behavior unless fine-tuned extensively.",
            "uuid": "e7151.1",
            "source_info": {
                "paper_title": "Toward Self-Improvement of LLMs via Imagination, Searching, and Criticizing",
                "publication_date_yy_mm": "2024-04"
            }
        },
        {
            "name_short": "Self-consistency (baseline)",
            "name_full": "Self-consistency (sampling multiple chains-of-thought and voting)",
            "brief_description": "A decoding aggregation method that samples multiple reasoning chains and picks the most consistent final answer (voting); used as a baseline in the paper's search-comparison experiments.",
            "citation_title": "",
            "mention_or_use": "use",
            "model_name": "Llama-2-70B (policy; used as baseline in Table 7)",
            "model_description": "Same base policy model used for other baselines; self-consistency aggregates across multiple sampled outputs.",
            "model_size": "70B",
            "reflection_method_name": "Self-consistency (majority/plurality over multiple samples)",
            "reflection_method_description": "Generate N diverse chain-of-thought samples and take majority vote (or heuristic) over final answers to reduce variance and improve correctness.",
            "iteration_type": "voting over multiple samples",
            "num_iterations": null,
            "task_name": "GSM8K, MATH",
            "task_description": "Mathematical reasoning (final-answer correctness).",
            "evaluation_metric": "Accuracy (percent correct final answers)",
            "performance_before_reflection": "Greedy baseline: GSM8K 57.8%, MATH 20.7%.",
            "performance_after_reflection": "Self-consistency results reported: GSM8K — 10 samples: 67.4%; 30 samples: 74.2%; 50 samples: 75.4%. MATH — 10 samples: 22.5%; 30 samples: 27.3%; 50 samples: 28.8%. (Table 7)",
            "improvement_observed": true,
            "limitations_or_failure_cases": "Requires many samples (computational cost); performance lags behind re-ranking/ηMCTS approaches in the experiments; does not explicitly critique or refine individual samples, only aggregates outputs.",
            "uuid": "e7151.2",
            "source_info": {
                "paper_title": "Toward Self-Improvement of LLMs via Imagination, Searching, and Criticizing",
                "publication_date_yy_mm": "2024-04"
            }
        },
        {
            "name_short": "Re-ranking (ORM-based)",
            "name_full": "Reranking using Outcome Reward Model (ORM)",
            "brief_description": "Generate multiple candidate trajectories and rerank them using a learned outcome reward model (ORM) that assesses full trajectories; used as a competitive baseline in experiments.",
            "citation_title": "",
            "mention_or_use": "use",
            "model_name": "Llama-2-70B (policy) with ORM initialized from policy",
            "model_description": "Generate N candidates via sampling from policy; ORM (text-generation evaluator) scores each trajectory; select highest-scoring trajectory.",
            "model_size": "70B",
            "reflection_method_name": "Reranking with ORM",
            "reflection_method_description": "Produce multiple candidate solutions, have ORM score each complete trajectory for quality/outcome, and pick the highest-scoring trajectory as final output.",
            "iteration_type": "generate multiple samples then select (reranking)",
            "num_iterations": null,
            "task_name": "GSM8K, MATH",
            "task_description": "Mathematical reasoning benchmarks.",
            "evaluation_metric": "Accuracy (percent correct final answers)",
            "performance_before_reflection": "Greedy baseline: GSM8K 57.8%, MATH 20.7%.",
            "performance_after_reflection": "Re-ranking results reported: GSM8K — 10 samples: 80.8%; 30 samples: 86.3%; 50 samples: 87.7%. MATH — 10 samples: 34.1%; 30 samples: 39.0%; 50 samples: 42.0%. (Table 7)",
            "improvement_observed": true,
            "limitations_or_failure_cases": "Requires many candidates (higher compute); ORM quality is crucial — on hard math tasks ORM benefits substantially from external tool usage (ablation shows intrinsic-only ORM drops MATH accuracy to 38.8%); reranking still underperforms ηMCTS for equivalent or larger rollout budgets in these experiments.",
            "uuid": "e7151.3",
            "source_info": {
                "paper_title": "Toward Self-Improvement of LLMs via Imagination, Searching, and Criticizing",
                "publication_date_yy_mm": "2024-04"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Self-refine: Iterative refinement with self-feedback",
            "rating": 2
        },
        {
            "paper_title": "Self-critiquing models for assisting human evaluators",
            "rating": 2
        },
        {
            "paper_title": "Let's verify step by step",
            "rating": 2
        },
        {
            "paper_title": "Solving math word problems with process-and outcome-based feedback",
            "rating": 2
        },
        {
            "paper_title": "Alphazero-like treesearch can guide large language model decoding and training",
            "rating": 2
        },
        {
            "paper_title": "Self-rewarding language models",
            "rating": 1
        }
    ],
    "cost": 0.01714075,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Toward Self-Improvement of LLMs via Imagination, Searching, and Criticizing</h1>
<p>Ye Tian ${ }^{1,2}$; Baolin Peng ${ }^{1}$; Linfeng Song ${ }^{1}$; Lifeng Jin ${ }^{1}$, Dian Yu ${ }^{1}$, Lei Han ${ }^{2}$ Haitao $\mathrm{Mi}^{1 \dagger}$, Dong Yu ${ }^{1}$<br>${ }^{1}$ Tencent AI Lab, Bellevue, WA<br>${ }^{2}$ Tencent Robotics X<br>{baolinpeng,lfsong,lifengjin,yudian,haitaomi,dyu}@global.tencent.com<br>{yaptian,lxhan}@tencent.com</p>
<h4>Abstract</h4>
<p>Despite the impressive capabilities of Large Language Models (LLMs) on various tasks, they still struggle with scenarios that involves complex reasoning and planning. Self-correction and self-learning emerge as viable solutions, employing strategies that allow LLMs to refine their outputs and learn from self-assessed rewards. Yet, the efficacy of LLMs in self-refining its response, particularly in complex reasoning and planning task, remains dubious. In this paper, we introduce AlPHALLM for the self-improvements of LLMs, which integrates Monte Carlo Tree Search (MCTS) with LLMs to establish a self-improving loop, thereby enhancing the capabilities of LLMs without additional annotations. Drawing inspiration from the success of AlphaGo, AlPHALLM addresses the unique challenges of combining MCTS with LLM for self-improvement, including data scarcity, the vastness search spaces of language tasks, and the subjective nature of feedback in language tasks. AlPHALLM is comprised of prompt synthesis component, an efficient MCTS approach tailored for language tasks, and a trio of critic models for precise feedback. Our experimental results in mathematical reasoning tasks demonstrate that AlPHALLM significantly enhances the performance of LLMs without additional annotations, showing the potential for self-improvement in LLMs. The code is available at https://github.com/YeTianJHU/AlphaLLM.</p>
<h2>1 Introduction</h2>
<p>LLMs, trained on trillions of tokens with billions of parameters have shown unparalleled capabilities in a wide range of natural language processing tasks (Touvron et al., 2023b; Team et al., 2023; OpenAI, 2023). Nevertheless, they continue to face challenges in scenarios requiring complex reasoning and strategic planning (Valmeekam et al., 2022; Stechly et al., 2024). While advanced prompting approaches such as Chain, Tree, Graph-of-Thought (Wei et al., 2022; Yao et al., 2024; Besta et al., 2024; Ding et al., 2023), it remains essential to fine-tune LLMs using a substantial volume of high-quality, supervised data to fundamentally improve the model performance (Nye et al., 2021; Lewkowycz et al., 2022; Chung et al., 2022). This methodology is inherently limited by the scope and quality of data that humans can provide.
Considering these challenges, the concept of self-correction and self-learning have been proposed as promising solutions (Madaan et al., 2024; Saunders et al., 2022; Chen et al., 2024). Within these framework, LLMs typically operate by employing two main strategies: 1) they continuously refine</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Imagination-Searching-Criticizing self-improvement loop: Imagination component synthesizes prompts as new learning examples, with MCTS searching better trajectories guided by signals from critics for policy improving.</p>
<p>Their responses based on the feedback of their past responses, and 2) they extensively sample responses then learn from preferences judged by itself as reward models with PPO or DPO (Yuan et al., 2024a,b; Chen et al., 2024). However, it remains a matter of ongoing research whether LLMs can effectively critique their own outputs to either enhance response quality or apply a scalar reward to indicate the quality of responses, especially in contexts demanding intricate planning and reasoning (Valmeekam et al., 2022; Stechly et al., 2024; Huang et al., 2023; Hong et al., 2023). On the other hand, advanced search algorithms such as MCTS, combined with reinforcement learning, have enabled models to learn from self-play and achieve human parity or even surpass human performance in complex tasks such as the game of Go (Silver et al., 2016, 2017). This naturally raises a question: is it viable to leverage the strengths of MCTS alongside LLMs to inaugurate a novel paradigm of self-improving? More precisely, could the assimilation of MCTS empower LLMs to more effectively explore better responses, guided by strategic signals, and subsequently optimize these responses to enhance overall performance?</p>
<p>To answer this question, we begin with a systematic examination of AlphaGo, identifying three critical aspects for its success: (<em>i</em>) The large volume of data, including self-play data. (<em>ii</em>) The use of tree search, which facilitates the exploration of potential moves through statistical sampling of the large search space. (<em>iii</em>) Accurate and unambiguous environment feedback; the direct and accurate feedback (win or loss) provided by the game of Go offers a clear and unequivocal learning signal (Silver et al., 2017). The integration of MCTS with LLMs for self-improvement has several challenges: (<em>i</em>) Limited Data: High-quality annotated data for LLMs is generally scarce. Furthermore, how to construct of synthetic data for LLMs training, similar to AlphaGo’s self-play data, remains unclear. (<em>ii</em>) Search Efficiency: The vast number of potential token combinations in natural language tasks results in an exponentially large search space, posing a significant challenge to the efficiency of MCTS (Ramamurthy et al., 2022). (<em>iii</em>) Imperfect Feedback: In contrast to the clear win/loss feedback in Go, feedback in natural language tasks is often subjective and nuanced, without a straightforward measure of success.</p>
<p>In this paper, we introduce ALPHALLM, an imagination-searching-criticizing framework designed for the self-improvement of LLMs. ALPHALLM consists of three key components, as illustrated in Figure 1. First, an imagination component is designed to synthesize prompts, alleviating the issues of data scarcity. Second, we propose ηMCTS tailored for efficient searching in language tasks. Particularly, it has been shown that planning at multiple levels of temporal abstraction is critical for RL problems with a long horizon and large action space (Sutton et al., 1999b; Peng et al., 2017; Luketina et al., 2019). As such, we propose formulating the text generation process as options over a Markov Decision Process (MDP) problem, where each option represents the generation of a collection of tokens for a specific subtask, similar to the concept of chains in chain-of-thought prompting. This formulation improves search efficiency by substantially reducing the search depth. Additionally, we propose the use of state merge and adaptive branching factors to further enhance search efficiency by balancing the trade-off between search width and depth. Lastly, since accurate feedback is crucial to the success of MCTS, we introduce a trio of critic models to guide ηMCTS, including a value function for estimating expected rewards, a process reward model for assessing node correctness, and an outcome reward model for evaluating the overall trajectory. For complex tasks with which LLMs struggle assessing such as arithmetic computation and code execution, to ensure the accuracy</p>
<p>of feedback, we augment the critics with the capacity to make dynamic decisions on which tools to use, when to use them, and how to use them effectively. After $\eta$ MCTS stage, we collect the trajectory with the largest reward from the critic models as the training examples to improve LLMs.</p>
<p>The experimental results on mathematical reasoning tasks demonstrate that AlPHALLM can efficiently search for better responses and use them to improve LLMs’ performance, forming an effective self-improving loop. Notably, based on Llama-2-70b and WizardMath-70B-V1.0, AlPHALLM can improve its performance from 57.8 to 92.0 on GSM8K and from 20.7 to 51.0 on MATH, performing comparably to GPT-4.</p>
<h1>2 Related Work</h1>
<p>Search with LLM Effective search strategy has been shown crucial for tasks that involve complex reasoning and planning, such as go (Silver et al., 2016) and math reasoning (Cobbe et al., 2021; Hendrycks et al., 2021). For math reasoning tasks, various search methods have been studied. One direction of research (Zhu et al., 2024; Xie et al., 2024) designed beam search with dynamic pruning, where beam items of low quality are pruned. Another line of work (Yao et al., 2024; Long, 2023; Besta et al., 2024; Hao et al., 2023; Feng et al., 2023) maintains a tree or a graph that represents the current progress of solving the input question where potential branches are iteratively expanded. Both our approach and Feng et al. (2023) are based on the MCTS algorithm, while one main difference is how to define a search step: Feng et al. (2023) fix a search step to be either a token or a sentence, while our approach is more flexible on deciding steps. We have also carefully designed the MCTS process, incorporating multiple critique signals to guide the search more effectively and introducing adaptive search parameters for improved state exploration. As the result, our approach achieves much better performances.</p>
<p>LLM Self-improving Being a key to the success of scalable oversight (Bowman et al., 2022), self-improving for LLM aims to align the LLM to human preference and values mainly using the supervision from the knowledge inside the LLM (Zelikman et al., 2022, 2024). One crucial part of self-improving is how to obtain reliable signal of critique to distinguish between good responses from the LLM and bad ones. Initial work (Bai et al., 2022; Wang et al., 2022) first asks the LLM to generate input queries of diverse tasks and the corresponding outputs. They then rely on hand-crafted heuristic rules to filter out redundant or low-quality data pairs (e.g. the query is too long or too short). Since it is non-trivial to compose effective heuristic rule, later work (Sun et al., 2023; Li et al., 2023; Guo et al., 2024) proposes a few general principles or judging criteria and ask the LLM itself to evaluate the quality its responses based on these guidance, hoping that LLMs can automatically designate these principles into each data point to better guide data filtering. However, this requires LLMs to have strong abilities to apply these principles for each specific case and make correct judgements. Different from previous work, we propose to leverage the supervision from MCTS for LLM self-improvement: taking the outputs of MCTS to continue train the LLM. This is because the outputs from MCTS are usually in much better quality then standard nucleus sampling, and the large gap ensure that the LLM can self improve.</p>
<h2>3 Preliminaries</h2>
<h3>3.1 Problem Formulation</h3>
<p>In this paper, we consider a LLM characterized by probability $p_{\theta}$ and denoted as policy $\pi_{\theta}$. It takes a sequence $\boldsymbol{x}=\left[x_{1}, \cdots, x_{n}\right]$ as input, which is typically referred as prompt, to generate the response $\boldsymbol{y}=\left[y_{1}, \cdots, y_{m}\right]$. In the context of LLMs, each $x_{i}$ and $y_{i}$ represents a token from a pre-defined vocabulary. The policy $\pi_{\theta}$ operates in an autoregressive manner, where each token is generated sequentially, relying solely on the context provided by the previously generated tokens. The policy therefore constitutes a Markov process in which the conditional probability distribution $p_{\theta}(\boldsymbol{y} \mid \boldsymbol{x})$ can be decomposed and expressed with the chain rule as $p_{\theta}(\boldsymbol{y} \mid \boldsymbol{x})=\prod_{i=1}^{m} p_{\theta}\left(y_{i} \mid \boldsymbol{x}, \boldsymbol{y}<em t="t">{&lt;i}\right)$.
With this property, the text generation task can be formulated as an Markov Decision Process (MDP) problem consisting of $(\mathcal{S}, \mathcal{A}, T, R, \gamma)$ in which, $\boldsymbol{s}</em>$ denotes a single action or sampled token from the vocabulary, leading to a transition to a new state} \in \mathcal{S}$ represents the context information of current trajectory, i.e., current status of the generation process, e.g., a partial response to a prompt; $a_{t} \in \mathcal{A</p>
<p>$\boldsymbol{s}<em t="t">{t+1}$, by concatenating $\boldsymbol{s}</em>}$ and $a_{t} ; r_{t}=R\left(\boldsymbol{s<em t="t">{t}, a</em>\right)$ manifest the evaluation of the generation to the prompt, reflecting the desirability or preferences of each state-action pair.</p>
<p>This MDP framework sets the stage for applying Reinforcement Learning (RL) methods to optimize the policy $\pi_{\boldsymbol{\theta}}$ aiming to maximize the expected cumulative reward $R$. Base on these setups, we describe the self-improving problem. Given a LLM $\pi_{\boldsymbol{\theta}}$ and an initial dataset $\mathcal{D}^{0}$, which consists of $N$ expert-generated prompt-response pairs $\left{\left(\boldsymbol{x}<em i="i">{i}^{0}, \boldsymbol{y}</em>$ to maximize the reward. The refinement process includes learning from synthesized prompts and corresponding responses. These responses are obtained using an advanced search algorithm that navigates the space of possible responses to maximize the expected reward. The detailed process is described in Algorithm 1 in Appendix. The primary challenges in forming an effective self-improving loop lie in synthesizing suitable prompts, efficiently searching over a vast action space, and obtaining precise feedback, which will be discussed in $\S 4$.}^{0}\right) \mid i \in[N]\right}$, the goal of self-improving is to iteratively refine $\pi_{\theta</p>
<h1>3.2 Monte Carlo Tree Search</h1>
<p>MCTS is a sampling-based search algorithm for policy optimization in decision-making problems. It would iteratively build a search tree, by repeating four phases: selection, expansion, evaluation, and backpropagation. In the selection phase, it would recursively select the children from the root node by Upper Confidence Bound (UCB) (Auer et al., 2002), $U C B(i)=w_{i}+C * \sqrt{2 * \ln \frac{N_{i}}{n_{i}}}$, where $n_{i}$ and $N_{i}$ are the visit counts for the node $i$ and its parent respectively, $C$ represents a hyperparameter balancing exploration and exploitation, and the $w_{i}$ is the average value of all descendant nodes of $i$.</p>
<h2>4 AlPHALLM</h2>
<h3>4.1 Overview</h3>
<p>The architecture of AlPHALLM is depicted in Figure 1, comprising three key components. Firstly, the imagination component is tasked with synthesizing prompts as learning examples. Secondly, an efficient search component, named $\eta$ MCTS, is proposed to search high-quality trajectories for optimizing the policy. Lastly, the search process is guided by critics specifically designed to provide reliable signals.</p>
<h3>4.2 Data Synthesizing</h3>
<p>Let $\mathcal{D}^{0}=\left{\left(\boldsymbol{x}<em i="i">{i}, \boldsymbol{y}</em>}\right) \mid i \in[N]\right}$ denote the initial dataset consisting of $N$ expert-generated promptresponse pairs. The data synthesizing process aims to expand this dataset by generating a set of synthesized prompts $\mathcal{D}^{1}=\left{\left(\boldsymbol{x<em i="i">{i}^{1}, \cdots\right) \mid i \in[N]\right}$. The generation of each synthesized prompt $\boldsymbol{x}</em>}^{1}$ can be mathematically described as a transformation $g$ applied to one or more examples from $\mathcal{D}^{0}$, $\boldsymbol{x<em i__1="i_{1">{i}^{1}=g\left(\boldsymbol{x}</em>}}^{0}, \cdots, \boldsymbol{x<em m="m">{i</em>}}^{0}, \pi^{0}\right)$ where $\boldsymbol{x<em 1="1">{i</em>}}^{0}, \cdots, \boldsymbol{x<em m="m">{i</em>$ equipped with data synthesis instructions. The data synthesizing process aims to enrich the diversity and complexity presented for the training of the policy model. Among various strategies, such as Self-instruct (Wang et al., 2022), Evol-instruct (Xu et al., 2023), we opt for a method akin to that described in Yu et al. (2023).}}^{0}$ are selected examples from $\mathcal{D}^{0}$. The transformation function $g$ controls the synthesis process, which can be a learnable function, manually defined heuristic rules, a strong LLM or the policy model itself $\pi^{0</p>
<h2>$4.3 \eta$ MCTS</h2>
<h3>4.3.1 Option-level MCTS</h3>
<p>When applying MCTS to LLMs, it is natural to perform token-level search, where each token is considered as an action (Liu et al., 2023). However, the substantial vocabulary size typical of LLMs presents a significant challenge i.e., conducting a deep search in such a vast space becomes increasingly complex as the search space expands exponentially. To mitigate this, some efforts proposed a sentence-level search, treating each sentence or step as a search node (Feng et al., 2023). While this method reduces the search space, it might compromise the flexibility and effectiveness of applying MCTS to LLMs, which is particularly true for tasks where subtle variations in token can dramatically impact the outcome, or where a more comprehensive search beyond a sentence is necessary.</p>
<table>
<thead>
<tr>
<th>Search Node</th>
<th>Example</th>
<th>Termination</th>
</tr>
</thead>
<tbody>
<tr>
<td>Token-level</td>
<td>$y_{0} \rightarrow y_{1} \rightarrow y_{2} \rightarrow y_{3} \rightarrow y_{5} \rightarrow y_{6} \rightarrow y_{7} \rightarrow y_{8}$</td>
<td>token</td>
</tr>
<tr>
<td>Sentence-level</td>
<td>$y_{0} y_{1} y_{2} \square \rightarrow y_{4} y_{5} y_{6} \square \rightarrow y_{7} y_{8} y_{9} y_{10}$</td>
<td>new line</td>
</tr>
<tr>
<td>Option-level</td>
<td>$y_{0} \rightarrow y_{1} y_{2} \square \rightarrow y_{4} y_{5} y_{6} \square y_{7} y_{8} y_{9} \square \rightarrow y_{10}$</td>
<td>termination function</td>
</tr>
</tbody>
</table>
<p>Table 1: Comparative illustration of token-level, sentence-level, and option-level MCTS search nodes. $y$ denotes a token sampled from the policy model. The arrow $\rightarrow$ represents the transition from one search node to the subsequent node within the search process.</p>
<p>Inspired by Sutton et al. (1999a); De Waard et al. (2016), we use the term option as a search node and propose option-level MCTS where each option represents a sequence of tokens, which can range from multiple tokens to several sentences. A comparisons of different levels search is listed in Table 1. Mathematically, an option $o=\langle\mathcal{I}, \pi, \beta\rangle$, where $\mathcal{I} \subseteq \mathcal{S}$ is a set of initial states for the option; $\pi: \mathcal{S} \times \mathcal{A} \rightarrow[0,1]$ is a policy to generate actions, which in our case is a LLM; and $\beta: \mathcal{S}^{+} \rightarrow[0,1]$ is the termination function. Starting from a state $s_{t}$, we can choose all the options for which $s_{t} \in \mathcal{I}$. Once an option is chosen, the policy $\pi$ will generate actions for several steps until the option terminates according to the termination function $\beta$. The option-level MCTS consists of stages including selection, expansion, simulation, and backpropagation. The option-level formulation offers more flexibility compared to the sentence-level, as a new line can be treated as a special case of the termination function, as demonstrated in Table 1. Additional detailed steps of the option-level MCTS can be found in Appendix A.2.</p>
<h1>4.3.2 Importance-Based Adaptive Branching</h1>
<p>In previous works related to option/sentence level tree search (Feng et al., 2023; Yao et al., 2024), it was a common practice to assume that each node in the tree has the same predefined width, i.e., branching factor. This assumption was due to the fact that unlike token-level MCTS with a limited action space, the sample space at the option-level is exceedingly large, with an unlimited number of token combinations. As a result, it was necessary to set a predefined maximum width for each node. However, this predefined branching factor is hard to set, as an improper choice can lead to a search tree that is either too shallow or too thin, resulting in an inefficient exploration of the search space.
To quantify the error induced by the branching factor limit, we defined the branching error $E_{\phi}(t)$. For a node $t$ with a branching factor of $m_{t}$, it aims to use the $m_{t}$ child options $\boldsymbol{o}<em t="t">{t}^{i} \sim \mathcal{D}</em>}^{\text {children }}$ (where $i \in\left{1, \ldots, m_{t}\right}$ ) to represent all possible options. Consequently, for a legal option $\boldsymbol{o<em t="t">{t}^{j} \sim \pi\left(\boldsymbol{s}</em>}\right)$ from the option space, we can calculate the minimal value difference between it and the $m_{t}$ existing options, which captures the error associated with representing other possible options using the $m_{t}$ available options. It can be formulated as $E_{\phi}(t)=\mathbb{E<em t="t">{\boldsymbol{o}</em>}^{i} \sim \pi\left(\boldsymbol{s<em _boldsymbol_o="\boldsymbol{o">{t}\right)}\left[\min </em><em _phi="\phi">{t}^{i}} \mid v</em>}^{\pi}\left(\left[\boldsymbol{s<em t="t">{t}, \boldsymbol{o}</em>}^{i}\right]\right)-v_{\phi}^{\pi}\left(\left[\boldsymbol{s<em t="t">{t}, \boldsymbol{o}</em>}^{i}\right]\right)\right]]$, where $v_{\phi}^{\pi}$ is the value function which will be detailed in $\S 4.4$. Here we define the importance of node $\boldsymbol{s<em t="t">{t}$ as $I\left(\boldsymbol{s}</em>\right)=\max <em t="t">{\boldsymbol{o}</em>}^{i}} \mid v_{\phi}^{\pi}\left(\left[\boldsymbol{s<em t="t">{t}, \boldsymbol{o}</em>}^{i}\right]\right)-v_{\phi}^{\pi}\left(\boldsymbol{s<em _phi="\phi">{t}\right) \mid$. For simplicity, we assume that the value of the children nodes are uniformly distributed (a detailed analysis of the Gaussian distribution can be found in Appendix A.4). Under this assumption, we show in Appendix A. 3 that $E</em>}(t) \leq \frac{I\left(\boldsymbol{s<em t="t">{t}\right)}{m</em>$ is less than some $\epsilon$, we aim to use a smaller total number of nodes for efficiency.
Theorem 4.1. The optimal branching factor $m_{t}$ in a tree search is set such that $m_{t}-1$ is proportional to the node importance $I\left(\boldsymbol{s}}-1}$. While $E_{\phi<em t="t">{t}\right)$, under the condition $\frac{I\left(\boldsymbol{s}</em> \leq \epsilon$. Refer to Appendix A. 3 for the detailed proof.}\right)}{m_{t}-1</p>
<p>A similar concept has also been proposed in Taylor et al. (2014); Clouse (1996). Intuitively, $I\left(\boldsymbol{s}<em t="t">{t}\right)$ captures the maximum value deviation from the current state. When this value is small, there is no need to explore further on this node, as there will not be a significant difference by rolling out on this node. Conversely, if the value is large, it is worth trying different children. We set the number of children allowed for a node $n\left(\boldsymbol{s}</em>}\right)$ (after extracting 1) to be linear with this importance, using a factor $\alpha$. In practice, to avoid extreme cases of large variance of $I\left(\boldsymbol{s<em _min="\min">{t}\right)$ in the early stage, we bound the number of children by depth-dependent constants $c</em>}(t)$ and $c_{\max }(t)$, $n\left(\boldsymbol{s<em _min="\min">{t}\right)=\max \left(c</em>}(t), \min \left(\left\lfloor\alpha I\left(\boldsymbol{s<em _max="\max">{t}\right)\right\rfloor+1, c</em>(t)\right)\right)$.</p>
<h1>4.3.3 State Merge</h1>
<p>With $n\left(\boldsymbol{s}<em t="t">{t}\right)$ determined, another issue is that options under the same node may be very similar, leading to many unnecessary sub-trees. Since we cannot directly control the $\boldsymbol{o}</em>} \sim \pi\left(\boldsymbol{s<em M="M" v="v">{t}\right)$, one strategy to mitigate this issue is to utilize the concept of move groups, as discussed in Van Eyck \&amp; Müller (2012). By merging similar nodes into the same group, we can increase the diversity among groups, thereby covering a larger problem space with limited search rollouts and making the search process more efficient.
Here, we adapt the definition of node predicate $p</em>$ to check its similarity with all existing groups. The heuristic function can either be a faster rule-based measurement (e.g., edit distance) or a model-based method (e.g., prompting a language model). Based on this, we decide whether to merge this option with a previous one or create a new group.}$ from Abel et al. (2018) and Fu et al. (2024) to represent whether two nodes are extremely similar. In practice, each time we generate a new option from the policy, we use heuristic functions as $p_{v M</p>
<h3>4.3.4 Fast Rollout with Specialized LM</h3>
<p>The simulation operation which employs a rollout policy to project future trajectories from a given state, is crucial for an effective MCTS. This process significantly improves the efficiency of exploration and exploitation, and enhances the accuracy of reward estimation ${ }^{2}$. Estimations made at the end of trajectories tend to have lower bias but higher variance; thus, simulating multiple possible trajectories yields low-bias, low-variance estimates, enabling a more informed and effective search process. Ideally, $\pi_{\theta}$ would serve as the rollout policy, yet its computational demands render it impractical for the rapid simulations required by MCTS. To address this challenge, we propose the use of a smaller, specialized LM as the fast rollout policy $\pi^{\text {fast }}$. Given a state $\boldsymbol{s}<em t="t">{t}$, the fast rollout policy $\pi^{\text {fast }}$ efficiently continues generation until it reaches a termination condition, denoted as $\pi^{\text {fast }}\left(\boldsymbol{s}</em>\right)$.</p>
<h3>4.4 Critic</h3>
<p>In AlPHALLM, we design three types of critic models to guide the search process.
Value Function The value function, denoted as $v^{\pi}(\boldsymbol{s})$, represents the expected return starting from state $\boldsymbol{s}$ and following policy $\pi$ thereafter, given by $v^{\pi}(\boldsymbol{s})=\mathbb{E}<em 0="0">{\tau \sim s}\left[R(\tau) \mid s</em>}=\boldsymbol{s}\right]$ where $R(\tau)$ represents the discounted return of trajectory $\tau$. To train a parameterized value function $v_{\phi}^{\pi}(\boldsymbol{s})$, given the prompts $\mathcal{D}={(\boldsymbol{x<em i="i">{i}, \cdots) \mid i \in[N]}$, for each prompt $\boldsymbol{x}</em>}$, we generate multiple trajectories $\boldsymbol{\tau<em i="i">{i}^{j}=\left{\boldsymbol{x}</em>}, \boldsymbol{o<em 2="2" i="i">{i 1}^{j}, \boldsymbol{o}</em>}^{j}, \cdots, \boldsymbol{o<em i="i">{i T}^{j}\right}$ by following policy $\pi$ for $J$ times. A final reward $r</em>}^{j}$ is assigned to indicate whether $\boldsymbol{\tau<em i="i">{i}^{j}$ aligns with $\boldsymbol{y}</em>}$-for example, rewarding trajectories that contain correct answers in mathematical tasks or closely follow instructions as ground truth. We then construct a dataset $\mathcal{D<em i="i" t="t">{\text {value }}=\left{\left(\boldsymbol{s}</em>}^{j}, v_{i t}^{j}\right) \mid i \in[N], t \in[T], j \in[J]\right}$ where $\boldsymbol{s<em i="i">{i t}^{j}=\left[\boldsymbol{x}</em>} \cdot \boldsymbol{o<em i="i" t="t">{&lt;i t}^{j}\right]$ and $v</em>}^{j}=r_{i}^{j}$. The value function $v_{\phi}^{\pi}$ is optimized by minimizing the mean squared error: $\mathcal{L<em _boldsymbol_s="(\boldsymbol{s">{\phi}=-\mathbb{E}</em>}, v) \sim \mathcal{D<em _phi="\phi">{\text {value }}}\left(v</em>$ is a LLM with an MLP layer on top to output a scalar on each token, using the scalar prediction at the last token of each state as the value.}^{\pi}(\boldsymbol{s})-v\right)^{2}$. Similar to (Feng et al., 2023), $v_{\phi}^{\pi</p>
<p>PRM The value function often struggles with credit assignment problem (Sutton, 1984) and its learning could be inefficient due to delayed and sparse rewards (Sutton \&amp; Barto, 2018). Therefore, we propose to incorporate PRM that introduces process supervision (Lightman et al., 2023) for direct option assessment. PRM generates intrinsic rewards (Chentanez et al., 2004) to encourage explorations of advantageous options, effectively mitigating issues of reward sparsity by providing immediate, action-specific rewards. Given a state $\boldsymbol{s}<em t="t">{t}$ and an option $\boldsymbol{o}</em>}$ at time $t$, the PRM aims to predict the immediate reward $r_{t}^{\text {PRM }}$ that results from taking option $\boldsymbol{o<em t="t">{t}$ in state $\boldsymbol{s}</em>}$. Formally, the PRM is a function $R\left(\boldsymbol{s<em t="t">{t}, \boldsymbol{o}</em>$. While PRM ideally requires quality labels for each state (Uesato et al., 2022), due to the high cost and time involved in obtaining these, MC estimation with prefix sampling (Wang et al., 2023) is used as a proxy, which aligns with the objective of the value function. Instead of adding a MLP layer on top of the policy model for outputting a scalar reward (Ouyang et al., 2022), we formulate PRM as a text generation task to best leverage LLM's intrinsic knowledge}\right) \rightarrow r_{t}^{\text {PRM }</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>for assessing the quality of an option. We adapt the dataset constructed for the value function as $\mathcal{D}<em i="i" t="t">{\text {PRM }}=\left{\left(\boldsymbol{s}</em>}, \boldsymbol{o<em i="i">{t}, r</em>$ is larger than certain threshold. To train PRM, we initialize it from the policy model $\pi$ and use the following prompt templates and typical language model loss. The prompt template is shown in Appendix A.5.}^{\text {PRM }}\right) \mid i \in[N], t \in[T]\right}$ where $r_{i}^{\text {PRM }}$ is the textual description of the reward, e.g., an option can be regarded as good if $v_{i t</p>
<p>ORM In additional to the value function and PRM, ORM is also used to guide MCTS. ORM is designed to evaluate options sequences in their entirety, assessing the extent to which the complete trajectory aligns with the desired end goal (Uesato et al., 2022; Lightman et al., 2023; Wang et al., 2023; Feng et al., 2023). The outcome evaluation complements value function and PRM by offering a comprehensive assessment of trajectories. Crucially, ORM plays a vital role in the simulation stage of MCTS by providing more accurate signals on the terminal state, which in turn facilitates a more balance between exploration and exploitation strategies. ORM is formulated as a text generation task, similar to PRM. We leverage the same dataset for the value function training and construct $\mathcal{D}<em i="i">{\text {ORM }}=\left{\left(\boldsymbol{x}</em>}, \boldsymbol{o<em i="i">{1: T}^{i}, r</em>}^{\text {ORM }}\right) \mid i \in[N]\right}$, where each instance includes a initial state or prompt $\boldsymbol{x<em 1:="1:" T="T">{i}$, a sequence of actions or options $\boldsymbol{o}</em>$ indicating the sequence's success or quality. Similarly, ORM is initialized from the policy model $\pi$ and the following prompt templates and language model loss are used for training. The prompt template is shown in Appendix A.5.}^{i}$ taken from that state, and a textual reward $r_{i}^{\text {ORM }</p>
<p>The final score evaluation of a state $\boldsymbol{s}$ is a weighted sum of the value function, PRM, and ORM: $s(\boldsymbol{s})=\beta_{\text {value }} \cdot v_{\beta}^{\pi}(\boldsymbol{s})+\beta_{\text {PRM }} \cdot \operatorname{PRM}(\boldsymbol{s})+\beta_{\text {ORM }} \cdot \mathbb{E}<em _text="\text" _value="{value">{\tau \sim \pi^{\text {fast }}(\boldsymbol{s})}[\operatorname{ORM}(\tau)]$, where $\tau \sim \pi^{\text {fast }}(\boldsymbol{s})$ represents trajectories starting from $\boldsymbol{s}$ under $\pi^{\text {fast }}$, and $\beta</em>$. Thus, combining these critics yields a stronger evaluation signal.}}, \beta_{\text {PRM }}, \beta_{\text {ORM }}$ are hyperparameters. In practice, we found that the value function model has better precision and calibration, while PRM has superior recall (Appendix A.10). Although ORM with fast rollouts provides low-bias, low-variance estimates, it still inherits some bias from $\pi^{\text {fast }</p>
<h1>4.5 Policy Self-Improvement</h1>
<p>The policy improvement an iterative process with each iteration containing two main steps: data generation and policy finetuning.</p>
<p>Data generation In this step, we assume to have the current policy $\pi_{\theta_{k}}$ and synthetic prompts $\mathcal{D}<em 1="1">{k}=\left{\boldsymbol{x}</em>}^{k}, \ldots\right}$ at the $k$-th round, where each $\boldsymbol{x<em k="k">{1}^{k}$ represents a question. We obtain the corresponding training data $\mathcal{D}</em>}$ for policy $\pi_{\theta_{k}}$ by firstly performing $\eta$ MCTS on $\mathcal{D<em i="i">{k}$ (§4.3) and then sampling a trajectory $\boldsymbol{y}</em>}^{k}$ from the corresponding tree for each question $\boldsymbol{x<em k="k">{i}^{k}$. Here we choose the trajectory that yield the highest critic score on the leaf node for each input question. Next, we filter out instances where the corresponding trajectory is substandard forming $\mathcal{D}</em>}=\left{\left(\boldsymbol{x<em i="i">{i}^{k}, \boldsymbol{y}</em>}^{k}\right) \mid f\left(\boldsymbol{x<em i="i">{i}^{k}, \boldsymbol{y}</em>\right)&gt;\gamma\right}$ where $f$ represents a function for quality scoring, and $\gamma$ indicates a threshold. There can be several ways to implement the function, and here we simply use the ORM (§4.4).}^{k</p>
<p>Policy finetuning With the obtained training data $\mathcal{D}<em _theta__k="\theta_{k">{k}$, we organize the data into the prompt templates shown in Appendix A.5. Then the policy $\pi</em>}}$ is finetuned using target-loss: $\mathcal{L<em k="k">{\theta</em>}}=$ $\mathbb{E<em i="i">{\left(\boldsymbol{x}</em>}^{k}, \boldsymbol{y<em k="k">{i}^{k}\right) \sim \mathcal{D}</em>}}\left[\log \pi_{\theta_{k}}\left(\boldsymbol{y<em i="i">{i}^{k} \mid \boldsymbol{x}</em>$. We leave other training methods, such as DPO (Rafailov et al., 2023) or PPO (Schulman et al., 2017) in future work.}^{k}\right)\right]$, resulting in an updated policy $\pi_{\theta_{k+1}</p>
<h2>5 Experiments</h2>
<h3>5.1 Experiment Setups</h3>
<p>ALPHALLM is generally applicable to a wide spectrum tasks. As an early exploration, in this paper, we conduct experiments on mathematical reasoning problems where the learning signals are clear to define i.e., , final answer is correct or wrong. We choose to evaluate on two widely used datasets GSM8K (Cobbe et al., 2021) and MATH (Hendrycks et al., 2021). For GSM8K, we utilize the whole test set while for MATH, due to computation constraints, we utilize a subset following the same procedure of Lightman et al. (2023). We evaluate the performance of predicting answers correctly for policy models. In addition, we calculate the average rollouts, represented by the number of nodes in</p>
<p>the tree, as a measure of computational efficiency. We compare the performance of AlPHALLM with a suite of proprietary model, including OpenAI's GPT-4 and GPT-3.5, Anthropic's Claude-2, as well as Google's PaLM-2 and the gemini model family. To ensure a fair and consistent evaluation, we employ CoT as our primary prompting method. Additionally, we conduct comparisons with strong open-source models, including Llama-2-70b (Touvron et al., 2023a) and WizardMath-70B-V1.0 (Luo et al., 2023).
We select Llama-2-70b as the policy model for the GSM8K dataset and WizardMath-70B-V1.0 for the MATH dataset. To construct the training dataset for the value function, PRM and ORM, we generate 50 trajectories for each prompt and construct the training target following Section 4.4. Both PRM and ORM are initialized using the weights from the policy model, while the value function uses a smaller Llama-2-13b model, as we observed no performance gains from increasing the value function model size. In the design of ORM, tool usage is not incorporated for GSM8K. However, for MATH, we enhance ORM by incorporating tools like python sympy to assess the quality of a trajectory, in a manner similar to that described by Gou et al. (2023). The training employ a learning rate of 1e-6 and are trained for one epoch. For the fast rollout policy model, we opt for the Abel-002-7B model (Chern et al., 2023) for both the GSM8K and MATH tasks for its high efficiency and superior performance. For the MCTS parameters, they are configured at different scales, as shown in Appendix A.6. We set $\beta_{\text {value }}, \beta_{\text {PRM }}$, and $\beta_{\text {ORM }}$ all to 1.0 .
For policy self-improving (§4.5), we train the policy model up to 3 epochs, setting batch size to 128, learning rate to $5 \times 10^{-6}$ and minimal learning rate to $1 \times 10^{-6}$. Linear warm-up and decay is used with warm-up percent to be $10 \%$. We perform early stopping based on a devset held out from the training instances. For GSM8K experiments, we perform two rounds of self-improving, synthesizing 6.4 k and 7.9 k prompts(Yu et al., 2023) respectively to obtain the corresponding MCTS outputs for training. For MATH experiments, we only perform one round of self-improving due to limited computation resources, and 5.9 k prompts are synthesized.
The termination function for options can be either be learned or rule-based. In practice, for the GSM8K dataset, the termination condition occurs at the end of each line. This is based on the typical structure of this dataset, where each line represents a distinct step or point. For the MATH dataset, due to its complexity and the base model's tendency to generate many $\backslash \mathrm{n} \backslash \mathrm{n}$ line breaks with some less meaningful content between them, termination occurs at the end of a line if a formula pattern is detected. During inference, if $\backslash \mathrm{n} \backslash \mathrm{n}$ is encountered, we perform a rule-based check for formula patterns. It terminates if a pattern is found or continues generating until the next $\backslash \mathrm{n} \backslash \mathrm{n}$.</p>
<h1>5.2 Results</h1>
<p>Table 2 lists the performance comparisons of various methods on the GSM8K and MATH datasets. Our findings reveal that AlPHALLM, based on Llama-2-70B and WizardMath-70B-V1.0, utilizes only final answer annotations and continues to improve through training on responses from $\eta$ MCTS. This comparison underscores the efficacy and broad applicability of our imagination-searchingcriticizing self-improving framework. Moreover, when our model is augmented with $\eta$ MCTS decoding strategy, its performance markedly improves, achieving scores of 88.9 and 48.7 on the GSM8K and MATH datasets, respectively. Following two iterations of self-improvement using synthetic prompts, AlPHALLM demonstrates performance comparable to that of GPT-4. This suggests a viable approach to improving LLMs' capabilities in complex problem-solving tasks in a self-improving fashion, leveraging a minimal amount of labeled data. We also analyze the performance of various search methods in Appendix A.8.</p>
<h3>5.3 Ablation Study</h3>
<p>We assess the effectiveness of each component in AlPHALLM and report the results on GSM8K in Table 3(a). Vanilla MCTS, configured with only the value function and a fixed number of children per node, achieves an accuracy of $79.5 \%$. This serves as a reference point for evaluating the incremental benefits introduced by each additional component. The use of adaptive branching increase the accuracy to $84.9 \%$. The addition of PRM improves the accuracy modestly to $85.9 \%$, showing the effectivenss of process supervision for searching. A more significant improvement is observed with the introduction of ORM with fast rollout, which boosts the accuracy to $86.5 \%$. Integrating state merging results in</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: left;">Decoding</th>
<th style="text-align: left;">#Annotation</th>
<th style="text-align: left;">RN</th>
<th style="text-align: left;">FA</th>
<th style="text-align: left;">SYN</th>
<th style="text-align: center;">GSM8K</th>
<th style="text-align: center;">MATH</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">GPT-3.5</td>
<td style="text-align: left;">Sampling</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: center;">80.8</td>
<td style="text-align: center;">35.5</td>
</tr>
<tr>
<td style="text-align: left;">GPT-4</td>
<td style="text-align: left;">Sampling</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: center;">92.0</td>
<td style="text-align: center;">42.5</td>
</tr>
<tr>
<td style="text-align: left;">GPT-4 (PAL)</td>
<td style="text-align: left;">Sampling</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: center;">94.2</td>
<td style="text-align: center;">51.8</td>
</tr>
<tr>
<td style="text-align: left;">Gemini 1.0 Pro</td>
<td style="text-align: left;">Sampling</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: center;">77.9</td>
<td style="text-align: center;">32.6</td>
</tr>
<tr>
<td style="text-align: left;">Gemini 1.0 Ultra</td>
<td style="text-align: left;">Sampling</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: center;">88.9</td>
<td style="text-align: center;">53.2</td>
</tr>
<tr>
<td style="text-align: left;">Gemini 1.5 Pro</td>
<td style="text-align: left;">Sampling</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: center;">92.5</td>
<td style="text-align: center;">58.5</td>
</tr>
<tr>
<td style="text-align: left;">Claude-2</td>
<td style="text-align: left;">Sampling</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: center;">85.2</td>
<td style="text-align: center;">32.5</td>
</tr>
<tr>
<td style="text-align: left;">PaLM-2 540B</td>
<td style="text-align: left;">Sampling</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: center;">80.7</td>
<td style="text-align: center;">34.3</td>
</tr>
<tr>
<td style="text-align: left;">Llama-2-70b</td>
<td style="text-align: left;">Greedy</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">$\times$</td>
<td style="text-align: left;">$\times$</td>
<td style="text-align: left;">$\times$</td>
<td style="text-align: center;">57.8</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">Llama-2-70b SFT</td>
<td style="text-align: left;">Greedy</td>
<td style="text-align: left;">7.5 k</td>
<td style="text-align: left;">$\checkmark$</td>
<td style="text-align: left;">$\checkmark$</td>
<td style="text-align: left;">$\times$</td>
<td style="text-align: center;">69.3</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">WizardMath-70B-V1.0</td>
<td style="text-align: left;">Greedy</td>
<td style="text-align: left;">96 k</td>
<td style="text-align: left;">$\checkmark$</td>
<td style="text-align: left;">$\checkmark$</td>
<td style="text-align: left;">$\times$</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">20.7</td>
</tr>
<tr>
<td style="text-align: left;">AlPHALLM</td>
<td style="text-align: left;">Greedy</td>
<td style="text-align: left;">$7.5 \mathrm{k} / 7.5 \mathrm{k}$</td>
<td style="text-align: left;">$\times$</td>
<td style="text-align: left;">$\checkmark$</td>
<td style="text-align: left;">$\checkmark$</td>
<td style="text-align: center;">73.7</td>
<td style="text-align: center;">23.6</td>
</tr>
<tr>
<td style="text-align: left;">AlPHALLM</td>
<td style="text-align: left;">$\eta$ MCTS</td>
<td style="text-align: left;">$7.5 \mathrm{k} / 7.5 \mathrm{k}$</td>
<td style="text-align: left;">$\times$</td>
<td style="text-align: left;">$\checkmark$</td>
<td style="text-align: left;">$\times$</td>
<td style="text-align: center;">88.9</td>
<td style="text-align: center;">48.7</td>
</tr>
<tr>
<td style="text-align: left;">AlPHALLM</td>
<td style="text-align: left;">$\eta$ MCTS</td>
<td style="text-align: left;">$7.5 \mathrm{k} / 7.5 \mathrm{k}$</td>
<td style="text-align: left;">$\times$</td>
<td style="text-align: left;">$\checkmark$</td>
<td style="text-align: left;">$\checkmark$</td>
<td style="text-align: center;">92.0</td>
<td style="text-align: center;">51.0</td>
</tr>
</tbody>
</table>
<p>Table 2: Comparison results of AlPHALLM on the GSM8K and MATH datasets. #Annotation indicates the quantity of labeled data employed for fine-tuning policy or training critic models. The annotation used for training are noted as RN for rationales and FA for final answers. SYN means models trained on synthetic prompts, where trajectories were generated using $\eta$ MCTS.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">AB</th>
<th style="text-align: center;">PRM</th>
<th style="text-align: center;">FR-ORM</th>
<th style="text-align: center;">SM</th>
<th style="text-align: center;">LG-#Rollout</th>
<th style="text-align: center;">Acc</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">$\times$</td>
<td style="text-align: center;">$\times$</td>
<td style="text-align: center;">$\times$</td>
<td style="text-align: center;">$\times$</td>
<td style="text-align: center;">$\times$</td>
<td style="text-align: center;">79.5</td>
</tr>
<tr>
<td style="text-align: center;">$\checkmark$</td>
<td style="text-align: center;">$\times$</td>
<td style="text-align: center;">$\times$</td>
<td style="text-align: center;">$\times$</td>
<td style="text-align: center;">$\times$</td>
<td style="text-align: center;">84.9</td>
</tr>
<tr>
<td style="text-align: center;">$\checkmark$</td>
<td style="text-align: center;">$\checkmark$</td>
<td style="text-align: center;">$\times$</td>
<td style="text-align: center;">$\times$</td>
<td style="text-align: center;">$\times$</td>
<td style="text-align: center;">85.9</td>
</tr>
<tr>
<td style="text-align: center;">$\checkmark$</td>
<td style="text-align: center;">$\checkmark$</td>
<td style="text-align: center;">$\checkmark$</td>
<td style="text-align: center;">$\times$</td>
<td style="text-align: center;">$\times$</td>
<td style="text-align: center;">86.5</td>
</tr>
<tr>
<td style="text-align: center;">$\checkmark$</td>
<td style="text-align: center;">$\checkmark$</td>
<td style="text-align: center;">$\checkmark$</td>
<td style="text-align: center;">$\checkmark$</td>
<td style="text-align: center;">$\times$</td>
<td style="text-align: center;">87.0</td>
</tr>
<tr>
<td style="text-align: center;">$\checkmark$</td>
<td style="text-align: center;">$\checkmark$</td>
<td style="text-align: center;">$\checkmark$</td>
<td style="text-align: center;">$\checkmark$</td>
<td style="text-align: center;">$\checkmark$</td>
<td style="text-align: center;">88.9</td>
</tr>
</tbody>
</table>
<p>(a) Ablation study on GSM8K</p>
<p>Table 3: (a): Ablation studies on the GSM8K test set of various components of $\eta$ MCTS, including adaptive branching, PRM, fast-rollout with ORM, state merge, and large number of rollouts. (b): Ablation studies of the impacts of tool-augmented ORM and option-level formulation on MATH.
a further increase in accuracy, reaching $87.0 \%$. Finally the combined of increasing the number of rollouts with the other components yields the best performance on this task.</p>
<p>Table 3(b) presents the ablation study of option formulation and the tool-augmented critic on the MATH dataset. Our proposed $\eta$ MCTS achieves an accuracy of 45.4 with 148 rollouts. When options are excluded, reverting to essentially sentence-level MCTS, the performance decreases to 44.1 with a noticeable increase in the number of rollouts to 198. This demonstrates that option formulation introduces enhanced flexibility to MCTS, enabling better performance with fewer search efforts. Furthermore, the most significant decrease in performance is observed when only intrinsic knowledge is utilized for ORM, which drops to an accuracy of 38.8. This suggests that the absence of an external tool critically impedes the ORM's capability to effectively assess challenging math problems.</p>
<p>Figure 2 depicts a comparative results on GSM8K of two rounds of self-improving trained on trajectories collected using reranking and $\eta$ MCTs. We report the performance of greedy decoding, $\eta$ MCTS with a relatively small number of rollouts (50-60), and $\eta$ MCTS with a larger number of rollouts (200-300) for each model. We observe that 1) Models trained on the trajectories from reranking or $\eta$ MCTS outperform the initial policy by a significant margin. In addition, the performance can be iteratively improved with training suggesting that self-improving has the potential to achieve continual performance gain. 2) While both reranking and $\eta$ MCTS can generate high-quality trajectories for self-improving, $\eta$ MCTS is performant with high efficiency and better accuracy. Models trained on trajectories generated by it not only exceed the performance of those trained on reranked trajectories</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: Empirical analysis on GSM8K of different self-improving data collection methods and number of iterations. Models are evaluated with greedy decoding, ηMCTS with small #rollout and large #rollout.</p>
<p>but also, when decoded with ηMCTS, demonstrate on par performance with GPT-4, revealing that ALPHALLM is an effective self-improving framework.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Threshold</th>
<th>Acc</th>
</tr>
</thead>
<tbody>
<tr>
<td>Edit distance</td>
<td>20</td>
<td>86.8</td>
</tr>
<tr>
<td>Edit distance</td>
<td>50</td>
<td>87.0</td>
</tr>
<tr>
<td>Cosine Similarity</td>
<td>0.7</td>
<td>86.3</td>
</tr>
<tr>
<td>Model-based</td>
<td>N/A</td>
<td>86.7</td>
</tr>
</tbody>
</table>
<p>(a) Ablation on the choice of state merge functions.</p>
<table>
<thead>
<tr>
<th>#Trajetory</th>
<th>Acc</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>85.9</td>
</tr>
<tr>
<td>4</td>
<td>86.5</td>
</tr>
<tr>
<td>8</td>
<td>86.7</td>
</tr>
</tbody>
</table>
<p>(b) Ablation on the number of trajectories.</p>
<p>Table 4: (a): Ablation studies on the choice of heuristic/model-based functions in state merge on GSM8K with base Llama2-70b. The model used in the model-based state merge is Llama-2-70b-chat. (b): Ablation studies of the number of rollout trajectories in fast-rollout estimation on GSM8K with base Llama2-70b.</p>
<p>We further analyze the impact of different hyperparameters and design choices for each component. Table 4(a) shows that varying heuristic functions (with hyperparameters) for state merge has limited impact on performance. Table 4(b) shows that, as the number of fast-rollouts increases, there is a corresponding improvement in performance. This is due to the reduction in the variance of the estimates. We used n=4 in our experiments for better trade-off between performance and efficiency. Additional ablations on the choice of fast-rollout models, are provided in Appendix A.7.</p>
<h2>6 Conclusion</h2>
<p>In this paper, we introduce ALPHALLM, an imagination-searching-criticizing framework designed for the self-improvement of LLMs without the necessity of additional annotations. At the heart of it is the integration of MCTS with LLMs. To tackle the inherent challenges associated with this integration, including data scarcity, the vastness of search spaces, and the subjective nature of feedback in language tasks, we introduce a data synthesizer for strategic prompt synthesis, an optimized MCTS tailored for efficient search in language tasks, and a trio of critic models to provide precise feedback. Our experimental findings on mathematical reasoning tasks reveal that ALPHALLM significantly boosts the performance of LLMs without requiring extra data annotations. Moreover, when decoded with ηMCTS, ALPHALLM performs comparably to GPT-4, highlighting the potential for self-improvement in LLMs.</p>
<h1>References</h1>
<p>David Abel, Dilip Arumugam, Lucas Lehnert, and Michael Littman. State abstractions for lifelong reinforcement learning. In International Conference on Machine Learning, pp. 10-19. PMLR, 2018.</p>
<p>Peter Auer, Nicolo Cesa-Bianchi, and Paul Fischer. Finite-time analysis of the multiarmed bandit problem. Machine learning, 47:235-256, 2002.</p>
<p>Yuntao Bai, Saurav Kadavath, Sandipan Kundu, Amanda Askell, Jackson Kernion, Andy Jones, Anna Chen, Anna Goldie, Azalia Mirhoseini, Cameron McKinnon, et al. Constitutional ai: Harmlessness from ai feedback. arXiv preprint arXiv:2212.08073, 2022.</p>
<p>Maciej Besta, Nils Blach, Ales Kubicek, Robert Gerstenberger, Michal Podstawski, Lukas Gianinazzi, Joanna Gajda, Tomasz Lehmann, Hubert Niewiadomski, Piotr Nyczyk, et al. Graph of thoughts: Solving elaborate problems with large language models. In Proceedings of the AAAI Conference on Artificial Intelligence, pp. 17682-17690, 2024.</p>
<p>Samuel R Bowman, Jeeyoon Hyun, Ethan Perez, Edwin Chen, Craig Pettit, Scott Heiner, Kamilė Lukošiūtė, Amanda Askell, Andy Jones, Anna Chen, et al. Measuring progress on scalable oversight for large language models. arXiv preprint arXiv:2211.03540, 2022.</p>
<p>Zixiang Chen, Yihe Deng, Huizhuo Yuan, Kaixuan Ji, and Quanquan Gu. Self-play fine-tuning converts weak language models to strong language models. arXiv preprint arXiv:2401.01335, 2024.</p>
<p>Nuttapong Chentanez, Andrew Barto, and Satinder Singh. Intrinsically motivated reinforcement learning. Advances in neural information processing systems, 17, 2004.</p>
<p>Ethan Chern, Haoyang Zou, Xuefeng Li, Jiewen Hu, Kehua Feng, Junlong Li, and Pengfei Liu. Generative ai for math: Abel. https://github.com/GAIR-NLP/abel, 2023.</p>
<p>Hyung Won Chung, Le Hou, Shayne Longpre, Barret Zoph, Yi Tay, William Fedus, Yunxuan Li, Xuezhi Wang, Mostafa Dehghani, Siddhartha Brahma, et al. Scaling instruction-finetuned language models. arXiv preprint arXiv:2210.11416, 2022.</p>
<p>Jeffery Allen Clouse. On integrating apprentice learning and reinforcement learning. University of Massachusetts Amherst, 1996.</p>
<p>Karl Cobbe, Vineet Kosaraju, Mohammad Bavarian, Mark Chen, Heewoo Jun, Lukasz Kaiser, Matthias Plappert, Jerry Tworek, Jacob Hilton, Reichiro Nakano, et al. Training verifiers to solve math word problems. arXiv preprint arXiv:2110.14168, 2021.</p>
<p>Maarten De Waard, Diederik M Roijers, and Sander CJ Bakkes. Monte carlo tree search with options for general video game playing. In 2016 IEEE Conference on Computational Intelligence and Games (CIG), pp. 1-8. IEEE, 2016.</p>
<p>Ruomeng Ding, Chaoyun Zhang, Lu Wang, Yong Xu, Minghua Ma, Wei Zhang, Si Qin, Saravan Rajmohan, Qingwei Lin, and Dongmei Zhang. Everything of thoughts: Defying the law of penrose triangle for thought generation. arXiv preprint arXiv:2311.04254, 2023.</p>
<p>Xidong Feng, Ziyu Wan, Muning Wen, Ying Wen, Weinan Zhang, and Jun Wang. Alphazero-like treesearch can guide large language model decoding and training. arXiv preprint arXiv:2309.17179, 2023.</p>
<p>Yangqing Fu, Ming Sun, Buqing Nie, and Yue Gao. Accelerating monte carlo tree search with probability tree state abstraction. Advances in Neural Information Processing Systems, 36, 2024.</p>
<p>Zhibin Gou, Zhihong Shao, Yeyun Gong, Yujiu Yang, Minlie Huang, Nan Duan, Weizhu Chen, et al. Tora: A tool-integrated reasoning agent for mathematical problem solving. arXiv preprint arXiv:2309.17452, 2023.</p>
<p>Hongyi Guo, Yuanshun Yao, Wei Shen, Jiaheng Wei, Xiaoying Zhang, Zhaoran Wang, and Yang Liu. Human-instruction-free llm self-alignment with limited samples. arXiv preprint arXiv:2401.06785, 2024.</p>
<p>Shibo Hao, Yi Gu, Haodi Ma, Joshua Hong, Zhen Wang, Daisy Wang, and Zhiting Hu. Reasoning with language model is planning with world model. In Proceedings of the 2023 Conference on Empirical Methods in Natural Language Processing, pp. 8154-8173, 2023.</p>
<p>Dan Hendrycks, Collin Burns, Saurav Kadavath, Akul Arora, Steven Basart, Eric Tang, Dawn Song, and Jacob Steinhardt. Measuring mathematical problem solving with the math dataset, 2021.</p>
<p>Ruixin Hong, Hongming Zhang, Xinyu Pang, Dong Yu, and Changshui Zhang. A closer look at the self-verification abilities of large language models in logical reasoning. arXiv preprint arXiv:2311.07954, 2023.</p>
<p>Jie Huang, Xinyun Chen, Swaroop Mishra, Huaixiu Steven Zheng, Adams Wei Yu, Xinying Song, and Denny Zhou. Large language models cannot self-correct reasoning yet. arXiv preprint arXiv:2310.01798, 2023.</p>
<p>Aitor Lewkowycz, Anders Andreassen, David Dohan, Ethan Dyer, Henryk Michalewski, Vinay Ramasesh, Ambrose Slone, Cem Anil, Imanol Schlag, Theo Gutman-Solo, et al. Solving quantitative reasoning problems with language models. Advances in Neural Information Processing Systems, 35:3843-3857, 2022.</p>
<p>Xian Li, Ping Yu, Chunting Zhou, Timo Schick, Luke Zettlemoyer, Omer Levy, Jason Weston, and Mike Lewis. Self-alignment with instruction backtranslation. arXiv preprint arXiv:2308.06259, 2023.</p>
<p>Hunter Lightman, Vineet Kosaraju, Yura Burda, Harri Edwards, Bowen Baker, Teddy Lee, Jan Leike, John Schulman, Ilya Sutskever, and Karl Cobbe. Let's verify step by step. arXiv preprint arXiv:2305.20050, 2023.</p>
<p>Jiacheng Liu, Andrew Cohen, Ramakanth Pasunuru, Yejin Choi, Hannaneh Hajishirzi, and Asli Celikyilmaz. Making ppo even better: Value-guided monte-carlo tree search decoding. arXiv preprint arXiv:2309.15028, 2023.</p>
<p>Jieyi Long. Large language model guided tree-of-thought. arXiv preprint arXiv:2305.08291, 2023.
Jelena Luketina, Nantas Nardelli, Gregory Farquhar, Jakob N. Foerster, Jacob Andreas, Edward Grefenstette, Shimon Whiteson, and Tim Rocktäschel. A survey of reinforcement learning informed by natural language. ArXiv, abs/1906.03926, 2019. URL https://api.semanticscholar. org/CorpusID:182952502.</p>
<p>Haipeng Luo, Qingfeng Sun, Can Xu, Pu Zhao, Jianguang Lou, Chongyang Tao, Xiubo Geng, Qingwei Lin, Shifeng Chen, and Dongmei Zhang. Wizardmath: Empowering mathematical reasoning for large language models via reinforced evol-instruct. arXiv preprint arXiv:2308.09583, 2023.</p>
<p>Aman Madaan, Niket Tandon, Prakhar Gupta, Skyler Hallinan, Luyu Gao, Sarah Wiegreffe, Uri Alon, Nouha Dziri, Shrimai Prabhumoye, Yiming Yang, et al. Self-refine: Iterative refinement with self-feedback. Advances in Neural Information Processing Systems, 36, 2024.</p>
<p>Maxwell Nye, Anders Johan Andreassen, Guy Gur-Ari, Henryk Michalewski, Jacob Austin, David Bieber, David Dohan, Aitor Lewkowycz, Maarten Bosma, David Luan, et al. Show your work: Scratchpads for intermediate computation with language models. arXiv preprint arXiv:2112.00114, 2021.</p>
<p>R OpenAI. Gpt-4 technical report. arXiv, pp. 2303-08774, 2023.
Long Ouyang, Jeffrey Wu, Xu Jiang, Diogo Almeida, Carroll Wainwright, Pamela Mishkin, Chong Zhang, Sandhini Agarwal, Katarina Slama, Alex Ray, et al. Training language models to follow instructions with human feedback. Advances in Neural Information Processing Systems, 35: $27730-27744,2022$.</p>
<p>Baolin Peng, Xiujun Li, Lihong Li, Jianfeng Gao, Asli Celikyilmaz, Sungjin Lee, and Kam-Fai Wong. Composite task-completion dialogue policy learning via hierarchical deep reinforcement learning. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing. Association for Computational Linguistics, 2017.</p>
<p>Rafael Rafailov, Archit Sharma, Eric Mitchell, Stefano Ermon, Christopher D Manning, and Chelsea Finn. Direct preference optimization: Your language model is secretly a reward model. arXiv preprint arXiv:2305.18290, 2023.</p>
<p>Rajkumar Ramamurthy, Prithviraj Ammanabrolu, Kianté Brantley, Jack Hessel, Rafet Sifa, Christian Bauckhage, Hannaneh Hajishirzi, and Yejin Choi. Is reinforcement learning (not) for natural language processing?: Benchmarks, baselines, and building blocks for natural language policy optimization. ArXiv, abs/2210.01241, 2022. URL https://api.semanticscholar.org/ CorpusID:252693405.</p>
<p>William Saunders, Catherine Yeh, Jeff Wu, Steven Bills, Long Ouyang, Jonathan Ward, and Jan Leike. Self-critiquing models for assisting human evaluators. arXiv preprint arXiv:2206.05802, 2022.</p>
<p>John Schulman, Filip Wolski, Prafulla Dhariwal, Alec Radford, and Oleg Klimov. Proximal policy optimization algorithms. arXiv preprint arXiv:1707.06347, 2017.</p>
<p>David Silver, Aja Huang, Chris J Maddison, Arthur Guez, Laurent Sifre, George Van Den Driessche, Julian Schrittwieser, Ioannis Antonoglou, Veda Panneershelvam, Marc Lanctot, et al. Mastering the game of go with deep neural networks and tree search. nature, 529(7587):484-489, 2016.</p>
<p>David Silver, Thomas Hubert, Julian Schrittwieser, Ioannis Antonoglou, Matthew Lai, Arthur Guez, Marc Lanctot, Laurent Sifre, Dharshan Kumaran, Thore Graepel, et al. Mastering chess and shogi by self-play with a general reinforcement learning algorithm. arXiv preprint arXiv:1712.01815, 2017.</p>
<p>Kaya Stechly, Karthik Valmeekam, and Subbarao Kambhampati. On the self-verification limitations of large language models on reasoning and planning tasks. arXiv preprint arXiv:2402.08115, 2024.</p>
<p>Zhiqing Sun, Yikang Shen, Qinhong Zhou, Hongxin Zhang, Zhenfang Chen, David Cox, Yiming Yang, and Chuang Gan. Principle-driven self-alignment of language models from scratch with minimal human supervision. arXiv preprint arXiv:2305.03047, 2023.</p>
<p>Richard S Sutton and Andrew G Barto. Reinforcement learning: An introduction. MIT press, 2018.
Richard S. Sutton, Doina Precup, and Satinder Singh. Between mdps and semi-mdps: A framework for temporal abstraction in reinforcement learning. Artificial Intelligence, 112(1):181-211, 1999a. ISSN 0004-3702. doi: https://doi.org/10.1016/S0004-3702(99)00052-1. URL https://www. sciencedirect.com/science/article/pii/S0004370299000521.</p>
<p>Richard S Sutton, Doina Precup, and Satinder Singh. Between mdps and semi-mdps: A framework for temporal abstraction in reinforcement learning. Artificial intelligence, 112(1-2):181-211, 1999b.</p>
<p>Richard Stuart Sutton. Temporal credit assignment in reinforcement learning. University of Massachusetts Amherst, 1984.</p>
<p>Matthew E Taylor, Nicholas Carboni, Anestis Fachantidis, Ioannis Vlahavas, and Lisa Torrey. Reinforcement learning agents providing advice in complex video games. Connection Science, 26(1): $45-63,2014$.</p>
<p>Gemini Team, Rohan Anil, Sebastian Borgeaud, Yonghui Wu, Jean-Baptiste Alayrac, Jiahui Yu, Radu Soricut, Johan Schalkwyk, Andrew M Dai, Anja Hauth, et al. Gemini: a family of highly capable multimodal models. arXiv preprint arXiv:2312.11805, 2023.</p>
<p>Hugo Touvron, Louis Martin, Kevin Stone, Peter Albert, Amjad Almahairi, Yasmine Babaei, Nikolay Bashlykov, Soumya Batra, Prajjwal Bhargava, Shruti Bhosale, et al. Llama 2: Open foundation and fine-tuned chat models. arXiv preprint arXiv:2307.09288, 2023a.</p>
<p>Hugo Touvron, Louis Martin, Kevin Stone, Peter Albert, Amjad Almahairi, Yasmine Babaei, Nikolay Bashlykov, Soumya Batra, Prajjwal Bhargava, Shruti Bhosale, et al. Llama 2: Open foundation and fine-tuned chat models. arXiv preprint arXiv:2307.09288, 2023b.</p>
<p>Jonathan Uesato, Nate Kushman, Ramana Kumar, Francis Song, Noah Siegel, Lisa Wang, Antonia Creswell, Geoffrey Irving, and Irina Higgins. Solving math word problems with process-and outcome-based feedback. arXiv preprint arXiv:2211.14275, 2022.</p>
<p>Karthik Valmeekam, Alberto Olmo, Sarath Sreedharan, and Subbarao Kambhampati. Large language models still can't plan (a benchmark for llms on planning and reasoning about change). arXiv preprint arXiv:2206.10498, 2022.</p>
<p>Gabriel Van Eyck and Martin Müller. Revisiting move groups in monte-carlo tree search. In Advances in Computer Games: 13th International Conference, ACG 2011, Tilburg, The Netherlands, November 20-22, 2011, Revised Selected Papers 13, pp. 13-23. Springer, 2012.</p>
<p>Peiyi Wang, Lei Li, Zhihong Shao, RX Xu, Damai Dai, Yifei Li, Deli Chen, Y Wu, and Zhifang Sui. Math-shepherd: Verify and reinforce llms step-by-step without human annotations. CoRR, abs/2312.08935, 2023.</p>
<p>Yizhong Wang, Yeganeh Kordi, Swaroop Mishra, Alisa Liu, Noah A Smith, Daniel Khashabi, and Hannaneh Hajishirzi. Self-instruct: Aligning language model with self generated instructions. arXiv preprint arXiv:2212.10560, 2022.</p>
<p>Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Fei Xia, Ed Chi, Quoc V Le, Denny Zhou, et al. Chain-of-thought prompting elicits reasoning in large language models. Advances in neural information processing systems, 35:24824-24837, 2022.</p>
<p>Yuxi Xie, Kenji Kawaguchi, Yiran Zhao, James Xu Zhao, Min-Yen Kan, Junxian He, and Michael Xie. Self-evaluation guided beam search for reasoning. Advances in Neural Information Processing Systems, 36, 2024.</p>
<p>Can Xu, Qingfeng Sun, Kai Zheng, Xiubo Geng, Pu Zhao, Jiazhan Feng, Chongyang Tao, and Daxin Jiang. Wizardlm: Empowering large language models to follow complex instructions. arXiv preprint arXiv:2304.12244, 2023.</p>
<p>Shunyu Yao, Dian Yu, Jeffrey Zhao, Izhak Shafran, Tom Griffiths, Yuan Cao, and Karthik Narasimhan. Tree of thoughts: Deliberate problem solving with large language models. Advances in Neural Information Processing Systems, 36, 2024.</p>
<p>Longhui Yu, Weisen Jiang, Han Shi, Jincheng Yu, Zhengying Liu, Yu Zhang, James T Kwok, Zhenguo Li, Adrian Weller, and Weiyang Liu. Metamath: Bootstrap your own mathematical questions for large language models. arXiv preprint arXiv:2309.12284, 2023.</p>
<p>Lifan Yuan, Ganqu Cui, Hanbin Wang, Ning Ding, Xingyao Wang, Jia Deng, Boji Shan, Huimin Chen, Ruobing Xie, Yankai Lin, et al. Advancing llm reasoning generalists with preference trees. arXiv preprint arXiv:2404.02078, 2024a.</p>
<p>Weizhe Yuan, Richard Yuanzhe Pang, Kyunghyun Cho, Sainbayar Sukhbaatar, Jing Xu, and Jason Weston. Self-rewarding language models. arXiv preprint arXiv:2401.10020, 2024b.</p>
<p>Eric Zelikman, Yuhuai Wu, Jesse Mu, and Noah Goodman. Star: Bootstrapping reasoning with reasoning. Advances in Neural Information Processing Systems, 35:15476-15488, 2022.</p>
<p>Eric Zelikman, Georges Harik, Yijia Shao, Varuna Jayasiri, Nick Haber, and Noah D Goodman. Quiet-star: Language models can teach themselves to think before speaking. arXiv preprint arXiv:2403.09629, 2024.</p>
<p>Tinghui Zhu, Kai Zhang, Jian Xie, and Yu Su. Deductive beam search: Decoding deducible rationale for chain-of-thought reasoning. arXiv preprint arXiv:2401.17686, 2024.</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: An overview of the four operations of $\eta$ MCTs. A node is selected, expanded, simulated with fast rollout policy until a terminal node is reached, then the signals from value function, PRM and ORM are backpropagated.</p>
<h1>A Appendix</h1>
<h2>A. 1 Imagination, Searching, Criticizing and Learning Loop</h2>
<div class="codehilite"><pre><span></span><code><span class="n">Algorithm</span><span class="w"> </span><span class="mi">1</span><span class="err">:</span><span class="w"> </span><span class="n">LLM</span><span class="w"> </span><span class="n">self</span><span class="o">-</span><span class="n">improving</span><span class="w"> </span><span class="n">loop</span>
<span class="k">Input</span><span class="w"> </span><span class="n">Initial</span><span class="w"> </span><span class="n">dataset</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">D</span><span class="err">}</span><span class="o">^</span><span class="err">{</span><span class="mi">0</span><span class="err">}</span><span class="o">=</span><span class="err">\</span><span class="nf">left</span><span class="err">\{\</span><span class="nf">left</span><span class="p">(</span><span class="err">\</span><span class="n">boldsymbol</span><span class="err">{</span><span class="n">x</span><span class="err">}</span><span class="n">_</span><span class="err">{</span><span class="n">i</span><span class="err">}</span><span class="o">^</span><span class="err">{</span><span class="mi">0</span><span class="err">}</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="n">boldsymbol</span><span class="err">{</span><span class="n">y</span><span class="err">}</span><span class="n">_</span><span class="err">{</span><span class="n">i</span><span class="err">}</span><span class="o">^</span><span class="err">{</span><span class="mi">0</span><span class="err">}\</span><span class="nf">right</span><span class="p">)</span><span class="w"> </span><span class="err">\</span><span class="n">mid</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="err">\</span><span class="ow">in</span><span class="o">[</span><span class="n">N</span><span class="o">]</span><span class="err">\</span><span class="nf">right</span><span class="err">\}\</span><span class="p">),</span><span class="w"> </span><span class="n">policy</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">pi_</span><span class="err">{\</span><span class="n">theta</span><span class="err">}</span><span class="o">^</span><span class="err">{</span><span class="mi">0</span><span class="err">}\</span><span class="p">),</span><span class="w"> </span><span class="n">reward</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">R</span><span class="err">\</span><span class="p">),</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="k">of</span>
<span class="w">    </span><span class="n">self</span><span class="o">-</span><span class="n">improving</span><span class="w"> </span><span class="n">training</span><span class="w"> </span><span class="n">loop</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">K</span><span class="err">\</span><span class="p">)</span>
<span class="k">Output</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">theta</span><span class="o">^</span><span class="err">{</span><span class="n">k</span><span class="err">}\</span><span class="p">)</span>
<span class="k">for</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="err">\</span><span class="n">leftarrow</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="n">ldots</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="n">do</span>
<span class="w">    </span><span class="n">Generate</span><span class="w"> </span><span class="n">synthetic</span><span class="w"> </span><span class="n">prompts</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nf">left</span><span class="o">[</span><span class="n">\boldsymbol{x}^{k}\right</span><span class="o">]=</span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="n">SYN</span><span class="err">}\</span><span class="nf">left</span><span class="p">(</span><span class="err">\</span><span class="n">pi_</span><span class="err">{\</span><span class="n">theta</span><span class="err">}</span><span class="o">^</span><span class="err">{</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="err">}</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">D</span><span class="err">}</span><span class="o">^</span><span class="err">{</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="err">}\</span><span class="nf">right</span><span class="p">)</span><span class="err">\</span><span class="p">)</span>
<span class="w">    </span><span class="k">Collect</span><span class="w"> </span><span class="n">trajectories</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="k">search</span><span class="w"> </span><span class="n">algorithm</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">g</span><span class="p">.,</span><span class="w"> </span><span class="n">MCTS</span><span class="w"> </span><span class="n">guided</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">R</span><span class="err">\</span><span class="p">).</span>
<span class="w">    </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nf">left</span><span class="o">[</span><span class="n">\hat{\boldsymbol{y}}^{k}\right</span><span class="o">]=</span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="n">MCTS</span><span class="err">}\</span><span class="nf">left</span><span class="p">(</span><span class="err">\</span><span class="n">pi_</span><span class="err">{\</span><span class="n">theta</span><span class="err">}</span><span class="o">^</span><span class="err">{</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="err">}</span><span class="p">,</span><span class="err">\</span><span class="nf">left</span><span class="o">[</span><span class="n">\boldsymbol{x}^{k}\right</span><span class="o">]</span><span class="err">\</span><span class="nf">right</span><span class="p">)</span><span class="err">\</span><span class="p">)</span>
<span class="w">    </span><span class="n">Construct</span><span class="w"> </span><span class="n">dataset</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">D</span><span class="err">}</span><span class="o">^</span><span class="err">{</span><span class="n">k</span><span class="err">}</span><span class="o">=</span><span class="err">\</span><span class="nf">left</span><span class="err">\{\</span><span class="nf">left</span><span class="p">(</span><span class="err">\</span><span class="n">boldsymbol</span><span class="err">{</span><span class="n">x</span><span class="err">}</span><span class="o">^</span><span class="err">{</span><span class="n">k</span><span class="err">}</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="n">hat</span><span class="err">{\</span><span class="n">boldsymbol</span><span class="err">{</span><span class="n">y</span><span class="err">}}</span><span class="o">^</span><span class="err">{</span><span class="n">k</span><span class="err">}\</span><span class="nf">right</span><span class="p">)</span><span class="err">\</span><span class="nf">right</span><span class="err">\}\</span><span class="p">)</span>
<span class="w">    </span><span class="k">Update</span><span class="w"> </span><span class="n">policy</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">theta</span><span class="o">^</span><span class="err">{</span><span class="n">k</span><span class="err">}</span><span class="o">=</span><span class="err">\</span><span class="n">arg</span><span class="w"> </span><span class="err">\</span><span class="nf">min</span><span class="w"> </span><span class="n">_</span><span class="err">{\</span><span class="n">theta</span><span class="err">}</span><span class="w"> </span><span class="n">L</span><span class="err">\</span><span class="nf">left</span><span class="p">(</span><span class="err">\</span><span class="n">pi_</span><span class="err">{\</span><span class="n">theta</span><span class="err">}</span><span class="o">^</span><span class="err">{</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="err">}</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="n">mathcal</span><span class="err">{</span><span class="n">D</span><span class="err">}</span><span class="o">^</span><span class="err">{</span><span class="n">k</span><span class="err">}\</span><span class="nf">right</span><span class="p">)</span><span class="err">\</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>

<p>The algorithm is shown in Algorithm 1.</p>
<h2>A. 2 Option-level MCTS</h2>
<p>As illustrated in Figure 3, option-level MCTS consists of the following operations:</p>
<ul>
<li>Selection Starting from the root node, we iteratively select the child node based on Equation ??.</li>
<li>Expansion Once an expandable leaf node is selected, a new node is generated by starting with the previous state of the parent node as the initial option state. The option is then sampled using the policy $\pi$, and its completion is determined by the termination function $\beta$.</li>
<li>Simulation The scaled reward of the newly expanded node, as well as some simulated future trajectories are evaluated using the feedback functions, which is discussed in $\S 4.4$.</li>
<li>Backpropagation The average value of the newly generated node and all its ancestors is updated using the scaled reward from the evaluation step. Meanwhile, the visit counts for these nodes are also increased by one.</li>
</ul>
<h2>A. 3 Importance-Based Adaptive Branching Under Uniform Distribution</h2>
<p>Let $V=\left{v_{\phi}^{\pi}\left(\boldsymbol{s}<em t="t">{t}, \boldsymbol{o}</em>}^{1}\right), v_{\phi}^{\pi}\left(\boldsymbol{s<em t="t">{t}, \boldsymbol{o}</em>}^{2}\right), \ldots, v_{\phi}^{\pi}\left(\boldsymbol{s<em t="t">{t}, \boldsymbol{o}</em>$.}^{m_{t}}\right)\right}$ be a set of $m_{t}$ values that are uniformly distributed. If the maximum and minimum values from $V$ are $v_{\max }$ and $v_{\min }$, the average gap between two consecutive values is given by $\frac{v_{\max }-v_{\min }}{m_{t}-1}$. The upper bound of expected minimum distances from a new value $v_{\text {new }}$ to any value from $V$ is achieved when $v_{\text {new }}$ is consistently positioned at the midpoint between two consecutive values, and it is given by $\frac{v_{\max }-v_{\min }}{2\left(m_{t}-1\right)</p>
<p>Since $v_{\max }-v_{\min }=2 I\left(\boldsymbol{s}<em _phi="\phi">{t}\right)$ for a uniform distribution, we can conclude that $E</em>}(t) \leq \frac{I\left(\boldsymbol{s<em t="t">{t}\right)}{m</em>$.
Theorem 4.1. The optimal branching factor $m_{t}$ in a tree search is set such that $m_{t}-1$ is proportional to the node importance $I\left(\boldsymbol{s}}-1<em t="t">{t}\right)$, under the condition $\frac{I\left(\boldsymbol{s}</em> \leq \epsilon$.}\right)}{m_{t}-1</p>
<p>Proof. We can have the optimization problem as:</p>
<p>$$
\begin{aligned}
&amp; \text { minimize: } \sum m_{t} \
&amp; \text { subject to: } \frac{I\left(\boldsymbol{s}<em t="t">{t}\right)}{m</em> \leq \epsilon
\end{aligned}
$$}-1</p>
<p>Introduce the Lagrange multiplier $\lambda_{t}$ for each constraint:</p>
<p>$$
L\left(m_{t}, \lambda_{t}\right)=\sum m_{t}+\sum \lambda_{t}\left(\epsilon\left(m_{t}-1\right)-I\left(\boldsymbol{s}_{t}\right)\right)
$$</p>
<p>Now, let's find the gradient of the Lagrangian with respect to $m_{t}$ and $\lambda_{t}$ and set them to zero:</p>
<p>$$
\begin{aligned}
\nabla_{m_{t}} L &amp; =1+\epsilon \lambda_{t}=0 \
\nabla_{\lambda_{t}} L &amp; =\epsilon\left(m_{t}-1\right)-I\left(\boldsymbol{s}_{t}\right)=0
\end{aligned}
$$</p>
<p>From the first equation, we get:</p>
<p>$$
\lambda_{t}=-\frac{1}{\epsilon}
$$</p>
<p>Substitute this value of $\lambda_{t}$ into the second equation:</p>
<p>$$
\epsilon\left(m_{t}-1\right)-I\left(\boldsymbol{s}_{t}\right)=0
$$</p>
<p>Solving for $m_{t}$, we get:</p>
<p>$$
m_{t}=\frac{I\left(\boldsymbol{s}_{t}\right)}{\epsilon}+1
$$</p>
<p>Thus, $m_{t}-1$ is proportional to the node importance $I\left(\boldsymbol{s}_{t}\right)$.</p>
<h1>A. 4 Importance-Based Adaptive Branching Under Gaussian Distribution</h1>
<p>If we assume that $v_{\phi}^{\pi}\left(\left[\boldsymbol{s}<em t="t">{t}, \boldsymbol{o}</em>}^{j}\right]\right)$ and $v_{\phi}^{\pi}\left(\left[\boldsymbol{s<em t="t">{t}, \boldsymbol{o}</em>\right]\right)$ are independent and identically distributed Gaussian random variables:}^{i</p>
<p>$$
v_{\phi}^{\pi}\left(\left[\boldsymbol{s}<em t="t">{t}, \boldsymbol{o}</em>}^{j}\right]\right), v_{\phi}^{\pi}\left(\left[\boldsymbol{s<em t="t">{t}, \boldsymbol{o}</em>\right)
$$}^{i}\right]\right) \sim \mathcal{N}\left(\mu, \sigma^{2</p>
<p>The difference $D_{i j}=v_{\phi}^{\pi}\left(\left[\boldsymbol{s}<em t="t">{t}, \boldsymbol{o}</em>}^{j}\right]\right)-v_{\phi}^{\pi}\left(\left[\boldsymbol{s<em t="t">{t}, \boldsymbol{o}</em>\right]\right)$ will follow a normal distribution with:}^{i</p>
<p>$$
D_{i j} \sim \mathcal{N}\left(0,2 \sigma^{2}\right)
$$</p>
<p>To find the expected minimum absolute difference between $v_{\phi}^{\pi}\left(\left[\boldsymbol{s}<em t="t">{t}, \boldsymbol{o}</em>}^{j}\right]\right)$ and the closest $v_{\phi}^{\pi}\left(\left[\boldsymbol{s<em t="t">{t}, \boldsymbol{o}</em>$ Gaussian differences.
The expected minimum value of $m_{t}$ absolute differences can be approximated using properties of order statistics for Gaussian distributions.
For a set of $m_{t}$ independent normal random variables with variance $2 \sigma^{2}$, the expected minimum absolute difference, $\mathbb{E}\left[\min }^{i}\right]\right)$, we need to consider the distribution of the minimum of $m_{t<em i="i" j="j">{i}\left|D</em>\right|\right]$, can be approximated by:</p>
<p>$$
E_{\phi}(t) \approx \frac{\sigma \sqrt{2}}{\sqrt{m_{t}}}
$$</p>
<p>This approximation arises from the fact that the expected minimum value of the absolute deviations of normally distributed random variables scales with the inverse of the square root of the number of samples.</p>
<p>Then, assume the range of the $m_{t}$ samples are $R_{m}=\max \left(v_{\phi}^{\pi}\left(\left[\boldsymbol{s}<em t="t">{t}, \boldsymbol{o}</em>}^{i}\right]\right)-\min \left(v_{\phi}^{\pi}\left(\left[\boldsymbol{s<em t="t">{t}, \boldsymbol{o}</em>$ can be approximated as:}^{i}\right]\right)\right.\right.$, the the expected range $\mathbb{E}\left[R_{m}\right]$ of $m_{t}$ samples from a normal distribution can be approximated using properties of extreme values of Gaussian distributions. The range $R_{m</p>
<p>$$
R_{m} \approx \sigma\left(z_{0.9995}-z_{0.0005}\right)
$$</p>
<p>where $z_{p}$ is the p-th percentile of the standard normal distribution. It can converge to</p>
<p>$$
R_{m} \approx \sigma \sqrt{2 \ln \left(m_{t}\right)}\left(2-\frac{\ln \left(\ln \left(m_{t}\right)\right)}{4 \ln \left(m_{t}\right)}\right)
$$</p>
<p>For simplicity, we can approximate the range using the primary term, which captures the dominant behavior:</p>
<p>$$
R_{m} \approx \sigma \sqrt{2 \ln \left(m_{t}\right)}
$$</p>
<p>Then we have</p>
<p>$$
E_{\phi}(t) \approx \frac{\sqrt{2}}{\sqrt{m_{t}}} \frac{R_{m}}{\sqrt{2 \ln \left(m_{t}\right)}}
$$</p>
<p>Knowing that for all distributions,</p>
<p>$$
I\left(s_{t}\right) \geq \frac{R_{m}}{2}
$$</p>
<p>We have</p>
<p>$$
E_{\phi}(t) \leq \frac{I\left(s_{t}\right)}{\sqrt{m_{t} \ln \left(m_{t}\right)}}
$$</p>
<p>Then to find the optimal $m_{t}$, the optimization problem is</p>
<p>$$
\begin{aligned}
&amp; \text { minimize: } \sum m_{t} \
&amp; \text { subject to: } \frac{I\left(s_{t}\right)}{\sqrt{m_{t} \ln \left(m_{t}\right)}} \leq \epsilon
\end{aligned}
$$</p>
<p>To solve this optimization problem, we can first rewrite the constraint in terms of $m_{t}$.</p>
<p>$$
m_{t} \ln \left(m_{t}\right) \geq \frac{I^{2}\left(s_{t}\right)}{\epsilon^{2}}
$$</p>
<p>Now, let's define a new function $g\left(m_{t}\right)=m_{t} \ln \left(m_{t}\right)$. We want to find the minimum $m_{t}$ such that $g\left(m_{t}\right) \geq \frac{I^{2}\left(s_{t}\right)}{\epsilon^{2}}$. To do this, we can find the derivative of $g\left(m_{t}\right)$ and set it to zero to find the critical points.</p>
<p>$$
g^{\prime}\left(m_{t}\right)=\frac{d}{d m_{t}}\left(m_{t} \ln \left(m_{t}\right)\right)=\ln \left(m_{t}\right)+1
$$</p>
<p>Setting the derivative to zero:</p>
<p>$$
\begin{gathered}
\ln \left(m_{t}\right)=-1 \
m_{t}=e^{-1}
\end{gathered}
$$</p>
<p>However, this critical point corresponds to a minimum of the function $g\left(m_{t}\right)$, and we are interested in the minimum $m_{t}$ that satisfies the constraint $g\left(m_{t}\right) \geq \frac{I^{2}\left(s_{t}\right)}{\epsilon^{2}}$. Since the function $g\left(m_{t}\right)$ is increasing for $m_{t}&gt;e^{-1}$, we can find the minimum $m_{t}$ by setting $g\left(m_{t}\right)=\frac{I^{2}\left(s_{t}\right)}{\epsilon^{2}}$ and solving for $m_{t}$ :</p>
<p>$$
m_{t} \ln \left(m_{t}\right)=\frac{I^{2}\left(s_{t}\right)}{\epsilon^{2}}
$$</p>
<p>This can not be solved directly, but we can still observe that there is a positive correlation between $m_{t}$ and $I\left(s_{t}\right)$.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Method</th>
<th style="text-align: right;">GSM8K</th>
<th style="text-align: right;"></th>
<th style="text-align: right;">MATH</th>
<th style="text-align: right;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: right;">Small</td>
<td style="text-align: right;">Large</td>
<td style="text-align: right;">Small</td>
<td style="text-align: right;">Large</td>
</tr>
<tr>
<td style="text-align: left;">$c$</td>
<td style="text-align: right;">1.0</td>
<td style="text-align: right;">1.5</td>
<td style="text-align: right;">1.0</td>
<td style="text-align: right;">1.0</td>
</tr>
<tr>
<td style="text-align: left;">$\alpha$</td>
<td style="text-align: right;">1.0</td>
<td style="text-align: right;">1.0</td>
<td style="text-align: right;">1.0</td>
<td style="text-align: right;">1.0</td>
</tr>
<tr>
<td style="text-align: left;">$c_{\max }(0)$</td>
<td style="text-align: right;">60</td>
<td style="text-align: right;">60</td>
<td style="text-align: right;">60</td>
<td style="text-align: right;">60</td>
</tr>
<tr>
<td style="text-align: left;">$c_{\max }(t)$ where $t&gt;0$</td>
<td style="text-align: right;">10</td>
<td style="text-align: right;">10</td>
<td style="text-align: right;">10</td>
<td style="text-align: right;">10</td>
</tr>
<tr>
<td style="text-align: left;">$c_{\min }(0)$</td>
<td style="text-align: right;">10</td>
<td style="text-align: right;">40</td>
<td style="text-align: right;">10</td>
<td style="text-align: right;">20</td>
</tr>
<tr>
<td style="text-align: left;">$c_{\min }(t)$ where $t&gt;0$</td>
<td style="text-align: right;">2</td>
<td style="text-align: right;">2</td>
<td style="text-align: right;">3</td>
<td style="text-align: right;">3</td>
</tr>
</tbody>
</table>
<p>Table 5: Parameters for MCTS. The Small/Large means small #rollout and small #rollout</p>
<h1>A. 5 Prompt Templates</h1>
<h2>A.5.1 PRM</h2>
<p>###You are given a math problem, followed by a step-by-step reasoning process. Your task is to read the problem carefully, understand the solving steps, and check the correctness of the last reasoning step. Output 'True' if the last step is correct, and 'False' otherwise.\n\n### State\n{state}\n\n###Action\n{option}\n\n###Assessment\n{textual reward}</p>
<h2>A.5.2 ORM</h2>
<p>###Assess a solution including final answer to a given math problem by following below steps. \n- Evaluate the method used for solving the problem.\n- Review each calculation step for accuracy. Check for computational errors, incorrect formula applications, or arithmetic mistakes. \n- The solution should use all the information provided in the question.\n- Examine the final answer for correctness, considering the calculations and method used.\n.\n\n### Prompt\n{prompt}\n\n###Trajectory\n{trajectory}\n\n###Assessment\n{textual reward}</p>
<h2>A.5.3 Policy Finetuning</h2>
<p>For MATH experiments that take a WizardMath V1.0 70B as the policy, we adopt their proposed system prompt for self-improving. For GSM8K experiments taking Llama2 70B pretrain as the policy, we use the following system prompt.</p>
<p>A chat between a curious user and an artificial intelligence assistant. \n The assistant gives helpful, detailed, and polite answers to the user's questions. \n User: $\boldsymbol{x}<em i="i">{i} \backslash$ n Assistant: $\boldsymbol{y}</em>$</p>
<h2>A. 6 MCTS Details</h2>
<p>We set the MCTS parameters in Table 5.</p>
<h2>A. 7 Additional Ablations</h2>
<p>Fast-rollout model Using Llama-2-70b instead of Abel-7B-002 improves performance by reducing bias from a smaller model, but Abel-002-7B is faster with similar computational resources due to higher concurrency and quicker processing. The details can be found in Table 6.</p>
<h2>A. 8 Search Comparison</h2>
<p>Table 7 presents the performance of various methods applied to different number of responses, from 10 to 50 . Our analysis confirms several key findings: 1) Reranking utilizing ORM consistently outperforms self-consistency techniques, indicating that ORM is capable of generating meaningful</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: center;">Acc (\%)</th>
<th style="text-align: center;">Speed (s)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Abel-002-7B</td>
<td style="text-align: center;">87.0</td>
<td style="text-align: center;">16.8</td>
</tr>
<tr>
<td style="text-align: left;">Llama-2-70B</td>
<td style="text-align: center;">87.3</td>
<td style="text-align: center;">38.1</td>
</tr>
</tbody>
</table>
<p>Table 6: Ablation study over different fast-rollout models on GSM8K.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Method</th>
<th style="text-align: center;">#Responses</th>
<th style="text-align: center;">GSM8K</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">MATH</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">#Rollouts</td>
<td style="text-align: center;">Accuracy</td>
<td style="text-align: center;">#Rollouts</td>
<td style="text-align: center;">Accuracy</td>
</tr>
<tr>
<td style="text-align: center;">Greedy</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">4.6</td>
<td style="text-align: center;">57.8</td>
<td style="text-align: center;">9.9</td>
<td style="text-align: center;">20.7</td>
</tr>
<tr>
<td style="text-align: center;">Self-consistency</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">46</td>
<td style="text-align: center;">67.4</td>
<td style="text-align: center;">99</td>
<td style="text-align: center;">22.5</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">30</td>
<td style="text-align: center;">137</td>
<td style="text-align: center;">74.2</td>
<td style="text-align: center;">299</td>
<td style="text-align: center;">27.3</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">50</td>
<td style="text-align: center;">229</td>
<td style="text-align: center;">75.4</td>
<td style="text-align: center;">499</td>
<td style="text-align: center;">28.8</td>
</tr>
<tr>
<td style="text-align: center;">Re-ranking</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">46</td>
<td style="text-align: center;">80.8</td>
<td style="text-align: center;">99</td>
<td style="text-align: center;">34.1</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">30</td>
<td style="text-align: center;">137</td>
<td style="text-align: center;">86.3</td>
<td style="text-align: center;">299</td>
<td style="text-align: center;">39.0</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">50</td>
<td style="text-align: center;">229</td>
<td style="text-align: center;">87.7</td>
<td style="text-align: center;">499</td>
<td style="text-align: center;">42.0</td>
</tr>
<tr>
<td style="text-align: center;">$\eta$ MCTS</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">55</td>
<td style="text-align: center;">87.0</td>
<td style="text-align: center;">223</td>
<td style="text-align: center;">45.4</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">230</td>
<td style="text-align: center;">88.9</td>
<td style="text-align: center;">341</td>
<td style="text-align: center;">48.7</td>
</tr>
</tbody>
</table>
<p>Table 7: Comparative results of various searching method on GSM8K and MATH.
signals for searching. 2) $\eta$ MCTS demonstrates superior performance while requiring significantly fewer rollouts. For instance, on the MATH dataset, $\eta$ MCTS achieves better results with only half the number of rollouts compared to reranking. Additionally, we evaluated the performance of BFS on the GSM8K only, where it requires 87.9 rollouts to achieve a score of 80.6 . These results suggest that our design of an efficient MCTS in AlPHALLM can serve as an effective policy improvement operation, enabling the search for high-quality trajectories with reduced computational cost.</p>
<h1>A. 9 Rollout Example</h1>
<p>Consider the following GSM-like question:</p>
<p>Question: Sandy's monthly phone bill expense is equal to ten times her age now. In two years, Sandy will be three times as old as Kim. If Kim is currently x years old, calculate Sandy's monthly phone bill expense. \nIf we know the answer to the above question is 340 , what is the value of the unknown variable $x \cap n$</p>
<p>A node in the second layer could have the following content:</p>
<p>Answer: We know that Sandy's monthly phone bill is 10 times her age. In two years, Sandy will be 3 times as old as Kim. The sum of Sandy's age now and 2 years is 3 times the sum of Kim's age now and two years.\nSandy's age now is $340 / 10=« 340 / 10=34 » 34$. In two years, Sandy's age will be $34+2=« 34+2=36 » 36 . \backslash n$</p>
<p>The parent of this node has the content:</p>
<p>Answer: We know that Sandy's monthly phone bill is 10 times her age. In two years, Sandy will be 3 times as old as Kim. The sum of Sandy's age now and 2 years is 3 times the sum of Kim's age now and two years. \n</p>
<p>And one of its fast-rollout paths could be:</p>
<p>The sum of Sandy's age now and 2 years is 36 . The sum of Kim's age now and two years is x $+2 \backslash \mathrm{n} 36=3(\mathrm{x}+2) \backslash \mathrm{n} 6=3 \mathrm{x}+6 \backslash \mathrm{n} 3 \mathrm{x}=30 \backslash \mathrm{nx}=10 \backslash \mathrm{n} # # # # 10$</p>
<h1>A. 10 Critic Performance</h1>
<p>We evaluated the performance of the value function and PRM on the GSM8K test set. Table 8 presents a comparison of these models in terms of precision, recall, and Expected Calibration Error (ECE). Results indicate that the value function achieves higher precision and better calibration, while PRM demonstrates a superior recall.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: center;">Precision</th>
<th style="text-align: center;">Recall</th>
<th style="text-align: center;">ECE</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Value Function</td>
<td style="text-align: center;">0.82</td>
<td style="text-align: center;">0.79</td>
<td style="text-align: center;">0.032</td>
</tr>
<tr>
<td style="text-align: left;">PRM</td>
<td style="text-align: center;">0.62</td>
<td style="text-align: center;">0.90</td>
<td style="text-align: center;">0.375</td>
</tr>
</tbody>
</table>
<p>Table 8: Performance comparison of the Value Function model and PRM on the GSM8K test set.</p>
<h2>A. 11 Compute Resources</h2>
<p>Our experiments were conducted using NVIDIA A100 40GB GPUs. Serving models based on Llama-2-70B or WizardMath-70B required 4 GPUs, while serving Llama-2-7B and Abel-002-7B was possible on a single GPU. Training the 70B models required 64 GPUs.</p>
<h2>A. 12 Limitations and Future Work</h2>
<p>Despite the promising results demonstrated by AlPHALLM in this study, there are several limitations that requires further exploration. (i) Our current implementation employs relatively simple methods for generating synthetic prompts. Future iterations of AlPHALLM should explore advanced techniques, such as Self-Instruct, to create both diverse and model capability-awared prompts. (ii) Although AlPHALLM demonstrates improvements over base models, its performance in greedy sampling is substantially inferior to that observed when decoded with $\eta$ MCTS. This indicates that the full potential of MCTS for self-improvement in LLMs has not yet been fully realized. Two potential factors contributing to this issue have been identified: a) the self-improvement loop may not be leveraging sufficient data; and b) the base model may be limited in its capacity for rapid learning. Addressing these concerns could lead to more significant improvemens. (iii) In our existing framework, the critic models remain static. We will explore mechanisms to continually update critic models to adapt to new policy models. This will help ensure the discriminator-generator gap and improve the overall training dynamics. (iv) The evaluation of AlPHALLM has been limited to mathematical reasoning tasks. To verify the generalizability and broader applicability of the framework, future research will need to extend its application to other domains.</p>
<h1>NeurIPS Paper Checklist</h1>
<h2>1. Claims</h2>
<p>Question: Do the main claims made in the abstract and introduction accurately reflect the paper's contributions and scope?
Answer: [Yes]
Justification: Yes the claims are accurately made.
Guidelines:</p>
<ul>
<li>The answer NA means that the abstract and introduction do not include the claims made in the paper.</li>
<li>The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.</li>
<li>The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.</li>
<li>It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper.</li>
</ul>
<h2>2. Limitations</h2>
<p>Question: Does the paper discuss the limitations of the work performed by the authors?
Answer: [Yes]
Justification: Yes we discussed the limitations in Appendix.
Guidelines:</p>
<ul>
<li>The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.</li>
<li>The authors are encouraged to create a separate "Limitations" section in their paper.</li>
<li>The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.</li>
<li>The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.</li>
<li>The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.</li>
<li>The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.</li>
<li>If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.</li>
<li>While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren't acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations.</li>
</ul>
<h2>3. Theory Assumptions and Proofs</h2>
<p>Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof?
Answer: [Yes]</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{2}$ Typically, the closer the simulation is to the termination state, the more accurate the reward estimation becomes.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>