<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-702 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-702</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-702</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-18.html">extraction-schema-18</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of discrepancies, gaps, or misalignments between natural language descriptions (such as paper descriptions, documentation, or specifications) and their corresponding code implementations in automated experimentation systems, including how these gaps are identified, measured, and their impacts.</div>
                <p><strong>Paper ID:</strong> paper-92a4d2c5b642ded5e227d0b199cc0fc9722ac802</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/92a4d2c5b642ded5e227d0b199cc0fc9722ac802" target="_blank">CNL2ASP: converting controlled natural language sentences into ASP</a></p>
                <p><strong>Paper Venue:</strong> Theory and Practice of Logic Programming</p>
                <p><strong>Paper TL;DR:</strong> This paper proposes a novel tool, called CNL2ASP, for translating English sentences expressed in a controlled natural language (CNL) form into ASP, and reports the results of an experimental analysis conducted on the real-world problems, showing that the tool can obtain satisfactory performance on these benchmarks.</p>
                <p><strong>Paper Abstract:</strong> 
 Answer set programming (ASP) is a popular declarative programming language for solving hard combinatorial problems. Although ASP has gained widespread acceptance in academic and industrial contexts, there are certain user groups who may find it more advantageous to employ a higher-level language that closely resembles natural language when specifying ASP programs. In this paper, we propose a novel tool, called CNL2ASP, for translating English sentences expressed in a controlled natural language (CNL) form into ASP. In particular, we first provide a definition of the type of sentences allowed by our CNL and their translation as ASP rules and then exemplify the usage of the CNL for the specification of both synthetic and real-world combinatorial problems. Finally, we report the results of an experimental analysis conducted on the real-world problems to compare the performance of automatically generated encodings with the ones written by ASP practitioners, showing that our tool can obtain satisfactory performance on these benchmarks.</p>
                <p><strong>Cost:</strong> 0.014</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e702.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e702.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of discrepancies, gaps, or misalignments between natural language descriptions (such as paper descriptions, documentation, or specifications) and their corresponding code implementations in automated experimentation systems, including how these gaps are identified, measured, and their impacts.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Aggregate translation inefficiency</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Inefficient translation of constraints into aggregates (observed in Nurse Scheduling Problem)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>The CNL2ASP translator emits aggregate-based ASP constraints for certain natural-language constraints; these aggregates were found to be less efficient than the hand-written normal rules used by ASP experts in the Nurse Scheduling Problem, leading to slower solver runtimes.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>CNL2ASP automatic CNL-to-ASP translator</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>A Python tool that parses controlled natural language (CNL) specifications and rewrites them into ASP encodings (supports choice/disjunctive rules, aggregates, weak constraints). Used to auto-generate encodings for benchmark and real-world combinatorial problems.</td>
                        </tr>
                        <tr>
                            <td><strong>nl_description_type</strong></td>
                            <td>controlled natural language specification (paper CNL examples)</td>
                        </tr>
                        <tr>
                            <td><strong>code_implementation_type</strong></td>
                            <td>automatically generated ASP encoding (output of CNL2ASP)</td>
                        </tr>
                        <tr>
                            <td><strong>gap_type</strong></td>
                            <td>inefficient translation (aggregate vs. expert normal rules)</td>
                        </tr>
                        <tr>
                            <td><strong>gap_description</strong></td>
                            <td>For some constraints expressed in the CNL (specifically constraints corresponding to lines 9 and 10 of the NSP specification), CNL2ASP translates the natural-language constraint into ASP aggregates. The original human-written encoding used ordinary rules (non-aggregate encodings) that produced better solver performance. Thus the automatic mapping produced a semantically correct encoding but a less performant variant.</td>
                        </tr>
                        <tr>
                            <td><strong>gap_location</strong></td>
                            <td>constraint translation / generated ASP encoding (use of aggregates)</td>
                        </tr>
                        <tr>
                            <td><strong>detection_method</strong></td>
                            <td>empirical performance comparison between CNL-generated encoding and human-written encodings (Original and Optimized) on benchmark NSP instances using CLINGO</td>
                        </tr>
                        <tr>
                            <td><strong>measurement_method</strong></td>
                            <td>Solver runtime measurements using CLINGO v5.6.1 with identical options, 5 NSP instances with increasing size; time and memory limits set to 1200 seconds and 8 GB respectively; reported that CNL encoding is ~1.5–2× slower than the original human encoding and markedly slower than an optimized variant</td>
                        </tr>
                        <tr>
                            <td><strong>impact_on_results</strong></td>
                            <td>Quantitative slowdown: CNL-generated encoding ran approximately 1.5 to 2 times slower than the original human encoding; optimized expert encoding outperformed both. Despite the slowdown, the CNL-generated encoding still solved the hardest instance within ~10 minutes (i.e., within the experimental time limit).</td>
                        </tr>
                        <tr>
                            <td><strong>frequency_or_prevalence</strong></td>
                            <td>Observed concretely in the NSP experiments reported in this paper (specific to constraints at lines 9 and 10); no broad prevalence statistics provided.</td>
                        </tr>
                        <tr>
                            <td><strong>root_cause</strong></td>
                            <td>Translation strategy: the automatic rewriter favors aggregates for expressing some constraint patterns; these aggregate encodings are less efficient for the NSP search space than handcrafted normal-rule encodings. Also, the CNL-to-ASP mapping does not perform problem-specific rewriting/optimization.</td>
                        </tr>
                        <tr>
                            <td><strong>mitigation_approach</strong></td>
                            <td>Use an automatic aggregate-rewriting/optimization pass (authors cite aggregate-rewriting tools such as the approach of Dingess and Truszczynski (2020)); or allow CNL2ASP to detect and rewrite aggregates into equivalent normal-rule encodings for known patterns.</td>
                        </tr>
                        <tr>
                            <td><strong>mitigation_effectiveness</strong></td>
                            <td>Not empirically evaluated in this paper; authors only suggest that existing aggregate-rewriting tools could be helpful but provide no quantitative results on effectiveness within their experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>domain_or_field</strong></td>
                            <td>declarative programming / answer set programming (applied to scheduling / combinatorial optimization)</td>
                        </tr>
                        <tr>
                            <td><strong>reproducibility_impact</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'CNL2ASP: converting controlled natural language sentences into ASP', 'publication_date_yy_mm': '2023-11'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e702.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e702.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of discrepancies, gaps, or misalignments between natural language descriptions (such as paper descriptions, documentation, or specifications) and their corresponding code implementations in automated experimentation systems, including how these gaps are identified, measured, and their impacts.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Generated-variable / anaphora handling</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Semantics mismatch due to autogenerated variables and explicit anaphora requirements</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>When input CNL omits variables needed to bind atoms, CNL2ASP generates fresh variables (prefixed with '_'), and the tool requires authors to express anaphora explicitly; this design can cause unexpected bindings or require unnatural CNL forms, representing a gap between intuitive natural-language writing and the generated code's binding semantics.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>CNL2ASP automatic CNL-to-ASP translator</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Parses CNL specifications and emits ASP code; to avoid clutter it auto-generates variables when the input lacks explicit variables that would otherwise be used to bind atoms.</td>
                        </tr>
                        <tr>
                            <td><strong>nl_description_type</strong></td>
                            <td>controlled natural language specification (user-authored CNL sentences)</td>
                        </tr>
                        <tr>
                            <td><strong>code_implementation_type</strong></td>
                            <td>automatically generated ASP encoding (uses generated variables)</td>
                        </tr>
                        <tr>
                            <td><strong>gap_type</strong></td>
                            <td>missing anaphora handling / implicit variable insertion</td>
                        </tr>
                        <tr>
                            <td><strong>gap_description</strong></td>
                            <td>CNL2ASP creates generated variables (starting with '_') when two atoms must be bound but the CNL sentence did not provide a variable. While this reduces verbosity, it means that writers who rely on natural-language anaphora rather than explicit variables may get encodings that do not reflect their intended bindings; the tool requires explicit anaphora instead of inferring them from natural text.</td>
                        </tr>
                        <tr>
                            <td><strong>gap_location</strong></td>
                            <td>variable binding / subject-object linking in generated ASP atoms</td>
                        </tr>
                        <tr>
                            <td><strong>detection_method</strong></td>
                            <td>design description and examples in the paper (behavioral documentation of the translator); noted as a language-design tradeoff rather than discovered by an external audit</td>
                        </tr>
                        <tr>
                            <td><strong>measurement_method</strong></td>
                            <td>Not quantified; no experimental measure provided.</td>
                        </tr>
                        <tr>
                            <td><strong>impact_on_results</strong></td>
                            <td>Potential semantic mismatch if the user expects implicit anaphora to be resolved; may cause incorrect or unintended atom bindings in generated ASP encodings. No quantitative impact on solver performance reported.</td>
                        </tr>
                        <tr>
                            <td><strong>frequency_or_prevalence</strong></td>
                            <td>Described as a systematic behavior of CNL2ASP for cases lacking explicit variables; prevalence depends on how users author CNL (no statistics provided).</td>
                        </tr>
                        <tr>
                            <td><strong>root_cause</strong></td>
                            <td>Design choice in CNL2ASP to auto-generate variables to keep CNL concise and avoid variable clutter, combined with conservative anaphora handling (tool requires explicit anaphora).</td>
                        </tr>
                        <tr>
                            <td><strong>mitigation_approach</strong></td>
                            <td>Require users to express anaphoras explicitly (documented in the paper); or extend the parser with natural-language anaphora resolution to infer intended bindings.</td>
                        </tr>
                        <tr>
                            <td><strong>mitigation_effectiveness</strong></td>
                            <td>Not evaluated in the paper; current mitigation is documentation and user discipline (explicit variables), effectiveness not quantified.</td>
                        </tr>
                        <tr>
                            <td><strong>domain_or_field</strong></td>
                            <td>language-to-program translation / knowledge representation</td>
                        </tr>
                        <tr>
                            <td><strong>reproducibility_impact</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'CNL2ASP: converting controlled natural language sentences into ASP', 'publication_date_yy_mm': '2023-11'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e702.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e702.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of discrepancies, gaps, or misalignments between natural language descriptions (such as paper descriptions, documentation, or specifications) and their corresponding code implementations in automated experimentation systems, including how these gaps are identified, measured, and their impacts.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Variable-naming convention mismatch</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Misclassification of identifiers as variables or constants due to naming conventions</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>CNL2ASP applies a syntactic rule treating tokens with only uppercase letters (and starting uppercase) as variables; this can mismatch user intent when natural names use different capitalization conventions, leading to different generated code semantics than the user expected.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>CNL2ASP automatic CNL-to-ASP translator</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>CNL parser that maps token lexical forms to ASP variables or constants using simple capitalization heuristics (uppercase-only tokens are variables; others treated as strings or numbers).</td>
                        </tr>
                        <tr>
                            <td><strong>nl_description_type</strong></td>
                            <td>controlled natural language specification (naming of entities and constants)</td>
                        </tr>
                        <tr>
                            <td><strong>code_implementation_type</strong></td>
                            <td>automatically generated ASP encoding (classification of tokens into variables vs constants)</td>
                        </tr>
                        <tr>
                            <td><strong>gap_type</strong></td>
                            <td>ambiguous description / lexical mismatch (naming convention)</td>
                        </tr>
                        <tr>
                            <td><strong>gap_description</strong></td>
                            <td>The tool assumes that any token starting with an uppercase letter and containing only uppercase letters, numbers, or symbols is a variable (e.g., MY_VAR), while other tokens (e.g., My_String) are treated as strings. This rigid rule can misclassify user-intended constants or identifiers if the user's naming does not match the convention, producing a semantically different ASP encoding.</td>
                        </tr>
                        <tr>
                            <td><strong>gap_location</strong></td>
                            <td>lexical interpretation during parsing (identifier classification)</td>
                        </tr>
                        <tr>
                            <td><strong>detection_method</strong></td>
                            <td>stated in the tool documentation and examples within the paper (design-time specification of lexical rules)</td>
                        </tr>
                        <tr>
                            <td><strong>measurement_method</strong></td>
                            <td>No empirical measurement provided.</td>
                        </tr>
                        <tr>
                            <td><strong>impact_on_results</strong></td>
                            <td>Potential semantic errors in generated ASP code if users use capitalization patterns inconsistent with the tool's conventions; no quantified incidence or measured effect on solver results reported.</td>
                        </tr>
                        <tr>
                            <td><strong>frequency_or_prevalence</strong></td>
                            <td>Not quantified; present whenever users deviate from the documented naming conventions.</td>
                        </tr>
                        <tr>
                            <td><strong>root_cause</strong></td>
                            <td>Simplifying parser design using capitalization heuristics to distinguish variables from constants in CNL, rather than full NLP disambiguation.</td>
                        </tr>
                        <tr>
                            <td><strong>mitigation_approach</strong></td>
                            <td>Document naming conventions clearly; require users to follow the conventions; extend parser to allow explicit annotations or more flexible naming rules.</td>
                        </tr>
                        <tr>
                            <td><strong>mitigation_effectiveness</strong></td>
                            <td>Not evaluated in the paper.</td>
                        </tr>
                        <tr>
                            <td><strong>domain_or_field</strong></td>
                            <td>language-to-program translation / controlled natural language</td>
                        </tr>
                        <tr>
                            <td><strong>reproducibility_impact</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'CNL2ASP: converting controlled natural language sentences into ASP', 'publication_date_yy_mm': '2023-11'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e702.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e702.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of discrepancies, gaps, or misalignments between natural language descriptions (such as paper descriptions, documentation, or specifications) and their corresponding code implementations in automated experimentation systems, including how these gaps are identified, measured, and their impacts.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Contradictory weak-constraint forms</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Ambiguity from supporting multiple natural-language forms for optimization leading to parser-level contradictions</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>CNL2ASP accepts two natural-language ways to express weak-constraint objectives (e.g., 'as much as possible' and 'is minimized'); although both are permitted for naturalness, using both simultaneously in a sentence is contradictory, and the tool detects this and raises an error.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>CNL2ASP automatic CNL-to-ASP translator</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Parses user-written CNL that can express weak constraints either at the front ('as much as possible') or at the end ('is minimized'); the parser supports both but enforces consistency.</td>
                        </tr>
                        <tr>
                            <td><strong>nl_description_type</strong></td>
                            <td>controlled natural language specification (optimization/weak-constraint sentences)</td>
                        </tr>
                        <tr>
                            <td><strong>code_implementation_type</strong></td>
                            <td>automatically generated ASP encoding (weak constraints with priority/weight translation)</td>
                        </tr>
                        <tr>
                            <td><strong>gap_type</strong></td>
                            <td>ambiguous description / contradictory natural-language forms</td>
                        </tr>
                        <tr>
                            <td><strong>gap_description</strong></td>
                            <td>The CNL allows two equivalent-but-differently-placed natural-language constructs to specify optimization (front vs end of sentence). Sentences that include both (contradictory) forms are considered well-formed by the grammar but are semantically inconsistent; CNL2ASP detects such contradictions and triggers an error so only one form is used.</td>
                        </tr>
                        <tr>
                            <td><strong>gap_location</strong></td>
                            <td>parsing and interpretation of weak-constraint specifications</td>
                        </tr>
                        <tr>
                            <td><strong>detection_method</strong></td>
                            <td>syntactic/semantic checks performed by the CNL2ASP parser (design-time enforcement)</td>
                        </tr>
                        <tr>
                            <td><strong>measurement_method</strong></td>
                            <td>No quantitative measurement; described as deterministic parser behavior.</td>
                        </tr>
                        <tr>
                            <td><strong>impact_on_results</strong></td>
                            <td>Prevents ambiguous specifications from being translated (the tool raises an error rather than producing a possibly incorrect encoding), thus avoiding silent misimplementation; no solver-performance impact reported.</td>
                        </tr>
                        <tr>
                            <td><strong>frequency_or_prevalence</strong></td>
                            <td>Not quantified; applies to author inputs that accidentally combine both forms.</td>
                        </tr>
                        <tr>
                            <td><strong>root_cause</strong></td>
                            <td>Natural-language flexibility allows multiple equivalent phrasing locations, leading to potential contradictory combinations which must be resolved by the translator.</td>
                        </tr>
                        <tr>
                            <td><strong>mitigation_approach</strong></td>
                            <td>The tool performs a check and raises an error if both forms are used; user must choose a single, consistent form.</td>
                        </tr>
                        <tr>
                            <td><strong>mitigation_effectiveness</strong></td>
                            <td>Effective in preventing ambiguous translations in the implemented tool (error is triggered), but no user-study data on usability impact provided.</td>
                        </tr>
                        <tr>
                            <td><strong>domain_or_field</strong></td>
                            <td>controlled natural language / ASP optimization</td>
                        </tr>
                        <tr>
                            <td><strong>reproducibility_impact</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'CNL2ASP: converting controlled natural language sentences into ASP', 'publication_date_yy_mm': '2023-11'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <p class="empty-note">No potentially relevant new papers extracted.</p>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-702",
    "paper_id": "paper-92a4d2c5b642ded5e227d0b199cc0fc9722ac802",
    "extraction_schema_id": "extraction-schema-18",
    "extracted_data": [
        {
            "name_short": "Aggregate translation inefficiency",
            "name_full": "Inefficient translation of constraints into aggregates (observed in Nurse Scheduling Problem)",
            "brief_description": "The CNL2ASP translator emits aggregate-based ASP constraints for certain natural-language constraints; these aggregates were found to be less efficient than the hand-written normal rules used by ASP experts in the Nurse Scheduling Problem, leading to slower solver runtimes.",
            "citation_title": "here",
            "mention_or_use": "use",
            "system_name": "CNL2ASP automatic CNL-to-ASP translator",
            "system_description": "A Python tool that parses controlled natural language (CNL) specifications and rewrites them into ASP encodings (supports choice/disjunctive rules, aggregates, weak constraints). Used to auto-generate encodings for benchmark and real-world combinatorial problems.",
            "nl_description_type": "controlled natural language specification (paper CNL examples)",
            "code_implementation_type": "automatically generated ASP encoding (output of CNL2ASP)",
            "gap_type": "inefficient translation (aggregate vs. expert normal rules)",
            "gap_description": "For some constraints expressed in the CNL (specifically constraints corresponding to lines 9 and 10 of the NSP specification), CNL2ASP translates the natural-language constraint into ASP aggregates. The original human-written encoding used ordinary rules (non-aggregate encodings) that produced better solver performance. Thus the automatic mapping produced a semantically correct encoding but a less performant variant.",
            "gap_location": "constraint translation / generated ASP encoding (use of aggregates)",
            "detection_method": "empirical performance comparison between CNL-generated encoding and human-written encodings (Original and Optimized) on benchmark NSP instances using CLINGO",
            "measurement_method": "Solver runtime measurements using CLINGO v5.6.1 with identical options, 5 NSP instances with increasing size; time and memory limits set to 1200 seconds and 8 GB respectively; reported that CNL encoding is ~1.5–2× slower than the original human encoding and markedly slower than an optimized variant",
            "impact_on_results": "Quantitative slowdown: CNL-generated encoding ran approximately 1.5 to 2 times slower than the original human encoding; optimized expert encoding outperformed both. Despite the slowdown, the CNL-generated encoding still solved the hardest instance within ~10 minutes (i.e., within the experimental time limit).",
            "frequency_or_prevalence": "Observed concretely in the NSP experiments reported in this paper (specific to constraints at lines 9 and 10); no broad prevalence statistics provided.",
            "root_cause": "Translation strategy: the automatic rewriter favors aggregates for expressing some constraint patterns; these aggregate encodings are less efficient for the NSP search space than handcrafted normal-rule encodings. Also, the CNL-to-ASP mapping does not perform problem-specific rewriting/optimization.",
            "mitigation_approach": "Use an automatic aggregate-rewriting/optimization pass (authors cite aggregate-rewriting tools such as the approach of Dingess and Truszczynski (2020)); or allow CNL2ASP to detect and rewrite aggregates into equivalent normal-rule encodings for known patterns.",
            "mitigation_effectiveness": "Not empirically evaluated in this paper; authors only suggest that existing aggregate-rewriting tools could be helpful but provide no quantitative results on effectiveness within their experiments.",
            "domain_or_field": "declarative programming / answer set programming (applied to scheduling / combinatorial optimization)",
            "reproducibility_impact": true,
            "uuid": "e702.0",
            "source_info": {
                "paper_title": "CNL2ASP: converting controlled natural language sentences into ASP",
                "publication_date_yy_mm": "2023-11"
            }
        },
        {
            "name_short": "Generated-variable / anaphora handling",
            "name_full": "Semantics mismatch due to autogenerated variables and explicit anaphora requirements",
            "brief_description": "When input CNL omits variables needed to bind atoms, CNL2ASP generates fresh variables (prefixed with '_'), and the tool requires authors to express anaphora explicitly; this design can cause unexpected bindings or require unnatural CNL forms, representing a gap between intuitive natural-language writing and the generated code's binding semantics.",
            "citation_title": "here",
            "mention_or_use": "use",
            "system_name": "CNL2ASP automatic CNL-to-ASP translator",
            "system_description": "Parses CNL specifications and emits ASP code; to avoid clutter it auto-generates variables when the input lacks explicit variables that would otherwise be used to bind atoms.",
            "nl_description_type": "controlled natural language specification (user-authored CNL sentences)",
            "code_implementation_type": "automatically generated ASP encoding (uses generated variables)",
            "gap_type": "missing anaphora handling / implicit variable insertion",
            "gap_description": "CNL2ASP creates generated variables (starting with '_') when two atoms must be bound but the CNL sentence did not provide a variable. While this reduces verbosity, it means that writers who rely on natural-language anaphora rather than explicit variables may get encodings that do not reflect their intended bindings; the tool requires explicit anaphora instead of inferring them from natural text.",
            "gap_location": "variable binding / subject-object linking in generated ASP atoms",
            "detection_method": "design description and examples in the paper (behavioral documentation of the translator); noted as a language-design tradeoff rather than discovered by an external audit",
            "measurement_method": "Not quantified; no experimental measure provided.",
            "impact_on_results": "Potential semantic mismatch if the user expects implicit anaphora to be resolved; may cause incorrect or unintended atom bindings in generated ASP encodings. No quantitative impact on solver performance reported.",
            "frequency_or_prevalence": "Described as a systematic behavior of CNL2ASP for cases lacking explicit variables; prevalence depends on how users author CNL (no statistics provided).",
            "root_cause": "Design choice in CNL2ASP to auto-generate variables to keep CNL concise and avoid variable clutter, combined with conservative anaphora handling (tool requires explicit anaphora).",
            "mitigation_approach": "Require users to express anaphoras explicitly (documented in the paper); or extend the parser with natural-language anaphora resolution to infer intended bindings.",
            "mitigation_effectiveness": "Not evaluated in the paper; current mitigation is documentation and user discipline (explicit variables), effectiveness not quantified.",
            "domain_or_field": "language-to-program translation / knowledge representation",
            "reproducibility_impact": null,
            "uuid": "e702.1",
            "source_info": {
                "paper_title": "CNL2ASP: converting controlled natural language sentences into ASP",
                "publication_date_yy_mm": "2023-11"
            }
        },
        {
            "name_short": "Variable-naming convention mismatch",
            "name_full": "Misclassification of identifiers as variables or constants due to naming conventions",
            "brief_description": "CNL2ASP applies a syntactic rule treating tokens with only uppercase letters (and starting uppercase) as variables; this can mismatch user intent when natural names use different capitalization conventions, leading to different generated code semantics than the user expected.",
            "citation_title": "here",
            "mention_or_use": "use",
            "system_name": "CNL2ASP automatic CNL-to-ASP translator",
            "system_description": "CNL parser that maps token lexical forms to ASP variables or constants using simple capitalization heuristics (uppercase-only tokens are variables; others treated as strings or numbers).",
            "nl_description_type": "controlled natural language specification (naming of entities and constants)",
            "code_implementation_type": "automatically generated ASP encoding (classification of tokens into variables vs constants)",
            "gap_type": "ambiguous description / lexical mismatch (naming convention)",
            "gap_description": "The tool assumes that any token starting with an uppercase letter and containing only uppercase letters, numbers, or symbols is a variable (e.g., MY_VAR), while other tokens (e.g., My_String) are treated as strings. This rigid rule can misclassify user-intended constants or identifiers if the user's naming does not match the convention, producing a semantically different ASP encoding.",
            "gap_location": "lexical interpretation during parsing (identifier classification)",
            "detection_method": "stated in the tool documentation and examples within the paper (design-time specification of lexical rules)",
            "measurement_method": "No empirical measurement provided.",
            "impact_on_results": "Potential semantic errors in generated ASP code if users use capitalization patterns inconsistent with the tool's conventions; no quantified incidence or measured effect on solver results reported.",
            "frequency_or_prevalence": "Not quantified; present whenever users deviate from the documented naming conventions.",
            "root_cause": "Simplifying parser design using capitalization heuristics to distinguish variables from constants in CNL, rather than full NLP disambiguation.",
            "mitigation_approach": "Document naming conventions clearly; require users to follow the conventions; extend parser to allow explicit annotations or more flexible naming rules.",
            "mitigation_effectiveness": "Not evaluated in the paper.",
            "domain_or_field": "language-to-program translation / controlled natural language",
            "reproducibility_impact": null,
            "uuid": "e702.2",
            "source_info": {
                "paper_title": "CNL2ASP: converting controlled natural language sentences into ASP",
                "publication_date_yy_mm": "2023-11"
            }
        },
        {
            "name_short": "Contradictory weak-constraint forms",
            "name_full": "Ambiguity from supporting multiple natural-language forms for optimization leading to parser-level contradictions",
            "brief_description": "CNL2ASP accepts two natural-language ways to express weak-constraint objectives (e.g., 'as much as possible' and 'is minimized'); although both are permitted for naturalness, using both simultaneously in a sentence is contradictory, and the tool detects this and raises an error.",
            "citation_title": "here",
            "mention_or_use": "use",
            "system_name": "CNL2ASP automatic CNL-to-ASP translator",
            "system_description": "Parses user-written CNL that can express weak constraints either at the front ('as much as possible') or at the end ('is minimized'); the parser supports both but enforces consistency.",
            "nl_description_type": "controlled natural language specification (optimization/weak-constraint sentences)",
            "code_implementation_type": "automatically generated ASP encoding (weak constraints with priority/weight translation)",
            "gap_type": "ambiguous description / contradictory natural-language forms",
            "gap_description": "The CNL allows two equivalent-but-differently-placed natural-language constructs to specify optimization (front vs end of sentence). Sentences that include both (contradictory) forms are considered well-formed by the grammar but are semantically inconsistent; CNL2ASP detects such contradictions and triggers an error so only one form is used.",
            "gap_location": "parsing and interpretation of weak-constraint specifications",
            "detection_method": "syntactic/semantic checks performed by the CNL2ASP parser (design-time enforcement)",
            "measurement_method": "No quantitative measurement; described as deterministic parser behavior.",
            "impact_on_results": "Prevents ambiguous specifications from being translated (the tool raises an error rather than producing a possibly incorrect encoding), thus avoiding silent misimplementation; no solver-performance impact reported.",
            "frequency_or_prevalence": "Not quantified; applies to author inputs that accidentally combine both forms.",
            "root_cause": "Natural-language flexibility allows multiple equivalent phrasing locations, leading to potential contradictory combinations which must be resolved by the translator.",
            "mitigation_approach": "The tool performs a check and raises an error if both forms are used; user must choose a single, consistent form.",
            "mitigation_effectiveness": "Effective in preventing ambiguous translations in the implemented tool (error is triggered), but no user-study data on usability impact provided.",
            "domain_or_field": "controlled natural language / ASP optimization",
            "reproducibility_impact": null,
            "uuid": "e702.3",
            "source_info": {
                "paper_title": "CNL2ASP: converting controlled natural language sentences into ASP",
                "publication_date_yy_mm": "2023-11"
            }
        }
    ],
    "potentially_relevant_new_papers": [],
    "cost": 0.013874999999999998,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>CNL2ASP: converting controlled natural language sentences into ASP</h1>
<p>SIMONE CARUSO<br>DIBRIS, University of Genova, Genova, Italy<br>CARMINE DODARO<br>DeMaCS, University of Calabria, Rende, Italy<br>MARCO MARATEA<br>DIBRIS, University of Genova, Genova, Italy; \&amp; DeMaCS, University of Calabria, Rende, Italy<br>MARCO MOCHI<br>DIBRIS, University of Genova, Genova, Italy<br>FRANCESCO RICCIO<br>Engineering Division, ALTEN Italia, Torino, Italy</p>
<p>submitted $x x x x x x x x$; revised $x x x x x x x x$; accepted $x x x x x x x x$</p>
<h2>Abstract</h2>
<p>Answer Set Programming (ASP) is a popular declarative programming language for solving hard combinatorial problems. Although ASP has gained widespread acceptance in academic and industrial contexts, there are certain user groups who may find it more advantageous to employ a higher-level language that closely resembles natural language when specifying ASP programs. In this paper, we propose a novel tool, called CNL2ASP, for translating English sentences expressed in a controlled natural language (CNL) form into ASP. In particular, we first provide a definition of the type of sentences allowed by our CNL and their translation as ASP rules, and then exemplify the usage of the CNL for the specification of both synthetic and real-world combinatorial problems. Finally, we report the results of an experimental analysis conducted on the real-world problems to compare the performance of automatically generated encodings with the ones written by ASP practitioners, showing that our tool can obtain satisfactory performance on these benchmarks. Under consideration in Theory and Practice of Logic Programming (TPLP).</p>
<p>KEYWORDS: Answer set programming, Logic Programming, Controlled Natural Language</p>
<h2>1 Introduction</h2>
<p>Answer Set Programming (ASP) (Lifschitz 2019; Brewka et al. 2011; Gelfond and Lifschitz 1988) is a well-known declarative programming paradigm proposed in the area of Knowledge Representation and Reasoning (KRR) and geared toward solving hard combinatorial problems. As a matter of fact, ASP has been widely used for solving problems in both academic and industrial contexts (see (Erdem et al. 2016) for a complete survey on ASP applications). The success of ASP is mainly due to its simple syntax, its intuitive semantics, and the availability of efficient systems, like ClingO (Gebser et al. 2016) or DLV (Alviano et al. 2017).</p>
<p>Nevertheless, despite the success of ASP, and in general of KR formalisms, it may be preferable for certain types of users to use a higher-level language that is closer to natural language for specifying ASP programs. For this reason, in the last decades, a number of attempts to convert English sentences expressed in a controlled natural language (CNL) into a KR formalism emerged (Fuchs 2005; Clark et al. 2005). In the context of ASP, a CNL has been used for solving logic puzzles (Baral and Dzifcak 2012), and for answering biomedical queries (Erdem and Yeniterzi 2009).</p>
<p>Arguably, using a CNL may offer several practical advantages:</p>
<ol>
<li>CNL specifications are usually more readable.</li>
<li>Writing CNL specifications is expected to be easier and faster than encoding knowledge in a formal KR language, like ASP. The generated ASP encodings can be used as a starting point for further optimization made by ASP experts.</li>
<li>CNL specifications tend to be more adaptable to changes compared to ASP encodings, e.g., adding a term in an ASP atom requires the substitution of all occurrences of the atoms, whereas in a CNL this should have almost no impact.</li>
<li>CNL specifications can be used as a basis for deploying richer language processing.</li>
</ol>
<p>The contribution of this paper is in the aforementioned context. In fact, we propose a tool called CNL2ASP that automatically translates sentences expressed in a CNL language into ASP rules. The CNL supported by CNL2ASP is inspired by the Semantics of Business Vocabulary and Business Rules (SBVR) (Bajwa et al. 2011; The Business Rules Group 2000), which is a standard proposed by the Object Management Group to formally describe complex entities, e.g., the ones related to a business, using natural language, and by PENG ${ }^{\text {ASP }}$, a CNL defined by Schwitter (2018).</p>
<p>The development of the tool has been oriented towards four different types of use cases, i.e., (i) enabling the possibility of specifying ASP programs also to users that have a limited experience on ASP; (ii) to help ASP experts to create a fast prototype of intuitive encodings which are subsequently subject to optimization; (iii) improving the readability of ASP programs since there is a one-to-one mapping between ASP rules and English specifications; and (iv) offering a modern tool that can be used as a basis for writing specifications in a natural language. In particular, to show the capabilities of our CNL, we reported several synthetic and real-world use cases showing how the CNL can be indeed used for solving (complex) combinatorial problems. Moreover, we performed an experimental analysis on the real-world use cases comparing the performance of the ASP encoding generated by CNL2ASP with the one created by ASP practitioners, showing that our tool can, in general, obtain good performances. Subsequently, we conducted a preliminary analysis to assess the usability and readability of the proposed CNL. Finally, we mention that the implementation of the tool presented in this paper is open source and publicly available at https://github.com/dodaro/cnl2asp.</p>
<p>Contributions. To summarize, the main contributions of this paper are the following:</p>
<ol>
<li>We defined a CNL designed for solving complex combinatorial problems.</li>
<li>We implemented CNL2ASP, a tool that automatically translates English sentences expressed in such a CNL into a corresponding ASP encoding. CNL2ASP supports</li>
</ol>
<p>the main features of the ASP language, including disjunctive and choice rules, aggregates, and weak constraints (Section 3).
3. We provided several use cases on well-known, synthetic domains (Section 4), as well as on real-world problems described in the literature (Section 5). Concerning the latter, we also provided the results of an experimental analysis comparing the performance of the generated encodings with the ones written by human experts.
4. We performed a preliminary user validation to evaluate the usability and the readability of the CNL (Section 6).</p>
<h1>2 Preliminaries</h1>
<p>Answer Set Programming (ASP) (Brewka et al. 2011) is a programming paradigm developed in the area of KRR and logic programming. In this section, we overview the language of ASP (Calimeri et al. 2020).</p>
<p>Syntax. The syntax of ASP is similar to the one of Prolog. Variables are strings starting with an uppercase letter, and constants are integers or strings starting with lowercase letters. A term is either a variable or a constant. A standard atom is an expression $\mathrm{p}\left(\mathrm{t}<em n="n">{1}, \ldots, \mathrm{t}</em>}\right)$, where p is a predicate of arity $n$ and $\mathrm{t<em n="n">{1}, \ldots, \mathrm{t}</em>}$ are terms. An atom $\mathrm{p}\left(\mathrm{t<em n="n">{1}, \ldots, \mathrm{t}</em>}\right)$ is ground if $\mathrm{t<em n="n">{1}, \ldots, \mathrm{t}</em>\rangle$, where consts is a list of constants and conj is a conjunction of ground standard atoms. A symbolic set is a set specified syntactically as {Terms $}$ : Conj $}$ are constants. A ground set is a set of pairs of the form $\langle$ consts $: \operatorname{conj<em t="t">{1} ; \ldots$, Terms $</em>:$ Conj $<em i="i">{t}$ } where $t&gt;0$, and for all $i \in[1, t]$, each Terms ${ }</em>)$ true. An aggregate function is of the form $f(S)$, where $S$ is a set term, and $f$ is an aggregate function symbol. Basically, aggregate functions map multisets of constants to a constant. The most common functions implemented in ASP systems are #count, for counting number of terms; #sum, for computing sum of integers, #min, for computing the minimum integer in a set, and #max, for computing the maximum integer in a set (Faber et al. 2011). An aggregate atom is of the form $f(S) \prec T$, where $f(S)$ is an aggregate function, $\prec \in{\langle,\langle=,&gt;,&gt;=,!=,=}$ is a comparison operator, and $T$ is a term called guard. An aggregate atom $f(S) \prec T$ is ground if $T$ is a constant and $S$ is a ground set. An atom is either a standard atom or an aggregate atom. A rule $r$ has the following form:}$ is a non-empty list of terms, and each Conj $_{i}$ is a non-empty conjunction of standard atoms. A set term is either a symbolic set or a ground set. Intuitively, a set term ${\mathrm{X}: \mathrm{a}(\mathrm{X}, \mathrm{c}), \mathrm{p}(\mathrm{X}) ; \mathrm{Y}: \mathrm{b}(\mathrm{Y}, \mathrm{m})}$ stands for the union of two sets: the first one contains the X -values making the conjunction $\mathrm{a}(\mathrm{X}, \mathrm{c}), \mathrm{p}(\mathrm{X})$ true, and the second one contains the Y -values making the conjunction $\mathrm{b}(\mathrm{Y}, \mathrm{m</p>
<p>$$
a_{1}|\ldots| a_{n}:-b_{1}, \ldots, b_{k}, \text { not } b_{k+1}, \ldots, \text { not } b_{m}
$$</p>
<p>where $\mathrm{a}<em n="n">{1}, \ldots, \mathrm{a}</em>}$ are standard atoms (with $n \geq 0$ ), $\mathrm{b<em k="k">{1}, \ldots, \mathrm{~b}</em>}$ are atoms, and $\mathrm{b<em m="m">{k+1}, \ldots, \mathrm{~b}</em>}$ are standard atoms (with $m \geq k \geq 0$ ). A literal is either a standard atom a or its negation not a. The disjunction $\mathrm{a<em n="n">{1}|\ldots| \mathrm{a}</em>}$ is the head of $r$, while the conjunction $\mathrm{b<em k="k">{1}, \ldots, \mathrm{~b}</em>}$, not $\mathrm{b<em m="m">{k+1}, \ldots$, not $\mathrm{b}</em>$ is its body. Rules with empty body are called facts. Rules with empty head are called constraints. A variable that appears uniquely in set terms of a rule $r$ is said to be local in $r$, otherwise it is a global variable of $r$. An ASP program is a set of safe rules, where a rule $r$ is safe if the following conditions hold: (i) for each global</p>
<p>variable $X$ of $r$ there is a positive standard atom $\ell$ in the body of $r$ such that $X$ appears in $\ell$; and (ii) each local variable of $r$ appearing in a symbolic set {Terms : Conj} also appears in a positive atom in Conj. A weak constraint $\omega$ (Buccafurri et al. 2000) is of the form:</p>
<dl>
<dt>$$</dt>
<dd>\sim \mathrm{b}<em k="k">{1}, \ldots, \mathrm{~b}</em>}, \text { not } \mathrm{b<em m="m">{k+1}, \ldots, \text { not } \mathrm{b}</em>} \cdot\left[\mathrm{w} @ 1, \mathrm{t<em z="z">{1}, \ldots, \mathrm{t}</em>\right]
$$</dd>
</dl>
<p>where $t_{1}, \ldots, t_{z}$ are terms, $w$ and 1 are the weight and level of $\omega$, respectively. Intuitively, [w@l] is read "as weight w at level 1", where weight is the "cost" of violating the condition in the body of w, whereas levels can be specified for defining a priority among preference criteria. An ASP program with weak constraints is $\Pi=\langle P, W\rangle$, where $P$ is a program and $W$ is a set of weak constraints. A standard atom, a literal, a rule, a program or a weak constraint is ground if no variables appear in it.</p>
<p>Semantics. Let $P$ be an ASP program. The Herbrand universe $U_{P}$ and the Herbrand base $B_{P}$ of $P$ are defined as usual. The ground instantiation $G_{P}$ of $P$ is the set of all the ground instances of rules of $P$ that can be obtained by substituting variables with constants from $U_{P}$. An interpretation $I$ for $P$ is a subset $I$ of $B_{P}$. A ground standard atom p is true w.r.t. $I$ if $\mathrm{p} \in I$, and false otherwise. A literal not p is true w.r.t. $I$ if p is false w.r.t. $I$, and false otherwise. An aggregate atom is true w.r.t. $I$ if the evaluation of its aggregate function (i.e., the result of the application of $f$ on the multiset $S$ ) with respect to $I$ satisfies the guard; otherwise, it is false. A ground rule $r$ is satisfied by $I$ if at least one atom in the head is true w.r.t. $I$ whenever all conjuncts of the body of $r$ are true w.r.t. $I$. A model is an interpretation that satisfies all rules of a program. Given a ground program $G_{P}$ and an interpretation $I$, the reduct of $G_{P}$ w.r.t. $I$ is the subset $G_{P}^{I}$ of $G_{P}$ obtained by deleting from $G_{P}$ the rules in which a body literal is false w.r.t. $I$ (Faber et al. 2011). An interpretation $I$ for $P$ is an answer set (or stable model) for $P$ if $I$ is a minimal model (under subset inclusion) of $G_{P}^{I}$ (i.e., $I$ is a minimal model for $G_{P}^{I}$ ). Given a program with weak constraints $\Pi=\langle P, W\rangle$ and an interpretation $I$, the semantics of $\Pi$ extends from the basic case defined above. Thus, let $G_{P}$ and $G_{W}$ be the instantiation of $P$ and $W$, respectively. Then, let $G_{W}^{I}$ be the set</p>
<p>$$
\begin{aligned}
&amp; \left{\left(\mathrm{w} @ 1, \mathrm{t}<em z="z">{1}, \ldots, \mathrm{t}</em>}\right) \mid: \sim \mathrm{b<em k="k">{1}, \ldots, \mathrm{~b}</em>}, \text { not } \mathrm{b<em m="m">{k+1}, \ldots, \text { not } \mathrm{b}</em>} \cdot\left[\mathrm{w} @ 1, \mathrm{t<em z="z">{1}, \ldots, \mathrm{t}</em>\right. \
&amp; \left.\quad, \ldots, \mathrm{~b}}\right] \in G_{W}, b_{1<em k_1="k+1">{k} \in I, \text { and } \mathrm{b}</em> \notin I\right} .
\end{aligned}
$$}, \ldots, \mathrm{~b}_{m</p>
<p>Moreover, for an integer $l, P_{l}^{I}=\sum_{\left(w @ l, t_{1}, \ldots, t_{z}\right) \in G_{W}^{I}} w$ if there is at least one tuple in $G_{W}^{I}$ whose level is equal to $l$, and 0 otherwise. Given a program with weak constraints $\Pi=\langle P, W\rangle$, an answer set $M$ for $P$ is said to be dominated by an answer set $M^{\prime}$ for $P$, if there exists an integer $l$ such that $P_{l}^{M^{\prime}}<P_{l}^{M}$ and $P_{l^{\prime}}^{M^{\prime}}=P_{l^{\prime}}^{M}$ for all integers $l^{\prime}>l$. An answer set $M$ for $P$ is said to be optimal or optimum for $\Pi$ if there is no other answer set $M^{\prime}$ that dominates $M$ (Calimeri et al. 2020).</p>
<p>Syntactic shortcuts. In the following, $\mathrm{p}(1 \ldots \mathrm{n})$. denotes the set of facts $\mathrm{p}(1) \ldots \mathrm{p}(\mathrm{n})$. Moreover, we use choice rules of the form ${\mathrm{x}}$, where x is a set of atoms. Choice rules of this kind can be viewed as a syntactic shortcut for the rule $\mathrm{p} \mid \mathrm{p}^{\prime}$. for each $\mathrm{p} \in \mathrm{x}$, where $\mathrm{p}^{\prime}$ is a fresh new atom not appearing elsewhere in the program, meaning that the atom $p$ can be chosen as true. Choice rules can also have bounds, i.e., $1&lt;={\mathrm{x}}&lt;1$, and in this case can be seen as a shortcut for the choice rule ${\mathrm{x}}$ and the rule :- #count ${\mathrm{x}}$ != 1.</p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Fig. 1: Architecture of the tool CNL2ASP.</p>
<h1>3 CNL2ASP</h1>
<p>This section deals with the specification of CNL language and with the implementation of the tool CNL2ASP, whose architecture is depicted in Figure 1. The tool takes as input a file containing a list of statements written in a CNL and produces as output a file containing a set of ASP rules. A specification written in this CNL is made of propositions, the structure of which is defined by clauses, linked by connectives, that are used to express concepts, to query them for information or to express conditions on them. Concepts in a proposition define the application domain, i.e., they describe entities that are used as subjects of other propositions. The combination of clauses that produces a proposition defines its type, that is used to understand what the proposition is supposed to mean and how that meaning can be translated into ASP rules and facts.</p>
<p>CNL2ASP is made of three main components, namely the Parser, the Concepts Data Structures, and the ASP Rewriter. In particular, each CNL proposition in the input file is processed by the Parser, whose role is (i) to create appropriate data structures for concepts to be stored in the Concept Data Structures, and (ii) to tokenize the CNL statements and send the result to the ASP Rewriter component. In more details, the Parser interprets three subtypes of CNL propositions, namely explicit definition propositions, implicit definition propositions, and (standard) CNL propositions. In particular, the starting production rule is the following:</p>
<div class="codehilite"><pre><span></span><code><span class="nx">start</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="nx">longrightarrow</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">explicit_definition_proposition</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">implicit_definition_proposition</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">standard_proposition</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
</code></pre></div>

<p>The first two types of propositions are used to define the concepts, where in our context a concept is a thing, a place, a person or an object that is used to model entities of the application domain of the CNL. Standard CNL propositions are sentences describing the rules of the application domain. As an example, consider the application domain of describing the rights and the obligations of a customer of an online store. In this context, concepts can be the customer, the company, the product, and so on, whereas CNL propositions are sentences stating what actions customers and companies can/cannot do. It is important to highlight that, in our tool, concepts are exclusively defined by their names. Consequently, taking the earlier example into account, there exists only a single concept for customer, company, product, and so forth. After all the sentences have been processed by the Parser, they are sorted as follows: (explicit and implicit) definition propositions are processed before (standard) CNL propositions. Among the CNL propositions, the ASP Rewriter first processes the ones that are related to choice and disjunctive rules since they can also define new concepts in the data structures, and then processes strong and weak constraints. For each proposition, the ASP Rewriter first initializes the ASP atoms, then creates aggregates, arithmetic operations and comparisons, and further it merges all of them to create the head and the body of the ASP rules. Finally, after all ASP rules are created, they are stored in a output file that is returned to the user. In the following sections we first describe the different propositions accepted by the Parser along with their grammar ${ }^{1}$ and their translation as ASP rules (Sections 3.1, 3.2, and 3.3), and then we report a brief description of the usage of the tool (Section 3.4).</p>
<h1>3.1 Explicit definition propositions</h1>
<p>Explicit definition propositions are used to define the concepts occurring in the domain application, and they are used to create data structures which are later on used by the ASP Rewriter to produce ASP rules. In more details, the production rule of explicit definition propositions is the following:</p>
<div class="codehilite"><pre><span></span><code><span class="n">explicit_definition_proposition</span> <span class="err">\</span><span class="p">(</span><span class="err">\</span><span class="n">longrightarrow</span><span class="err">\</span><span class="p">)</span> <span class="p">(</span><span class="n">domain_definition</span> <span class="p">|</span>
    <span class="n">temporal_concept_definition</span><span class="p">)</span><span class="n">CNL_END_OF_LINE</span>
</code></pre></div>

<p>where each proposition is terminated by CNL_END_OF_LINE (in our case, a dot). In particular, an explicit definition proposition can be either a domain_definition, used to define all the entities of the problem and their structure; or a temporal_concept_definition, used to define only temporal elements, as days or timeslots.</p>
<h3>3.1.1 Domain definition</h3>
<p>Domain definitions start with a subject optionally followed by the sentence "is identified by" and the definition of the keys, i.e., the parameters that uniquely represent the entity and then, also optionally, a sentence used to express the other parameters. The production rule is the following:</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<div class="codehilite"><pre><span></span><code>domain_definition: (&quot;A &quot; | &quot;An &quot;)? subject_name (&quot;is identified by&quot; atom_key)? &quot;, 
    and&quot;? (&quot;has&quot; parameter ((&quot;,&quot;|&quot;, and&quot;) parameter)*)?
</code></pre></div>

<p>Domain definitions are not directly translated as ASP rules, instead they are used to add elements in the data structures. All properties can be later on used in propositions to refer specific properties of a concept. By default, if no property is referred to by a sentence, then the identifier is used.</p>
<p>The following sentences are examples of domain definitions:</p>
<div class="codehilite"><pre><span></span><code>A movie is identified by an id, and has a title, a director, and a year.
A director is identified by a name.
A topMovie is identified by an id.
A scoreAssignment is identified by a movie, and by a value.
</code></pre></div>

<p>Note that scoreAssignment is identified by a movie, which is a concept that is created by the user. This has an impact on its translation into ASP, as shown in Section 3.3.1.</p>
<h1>3.1.2 Temporal concept definition</h1>
<p>Temporal concept definitions start with a subject followed by the sentence "is a temporal concept expressed in", then by the temporal type that can be minutes, days or steps. The preposition continues with a sentence used to express the temporal range and, finally, it can be closed with a sentence used to specify the length of each temporal step. The production rule is the following:</p>
<div class="codehilite"><pre><span></span><code>temporal_concept_definition: (&quot;A &quot; | &quot;An &quot;) subject_name &quot;is a temporal concept
    expressed in&quot; CNL_TEMPORAL_TYPE &quot;ranging from&quot; temporal_range_start &quot;to&quot;
    temporal_range_end (&quot;with a length of&quot; CNL_NUMBER (&quot;minutes&quot; | &quot;days&quot;)??
</code></pre></div>

<p>Temporal concepts enable the possibility to refer to them using special words like after, before, and so on.</p>
<p>An example of a temporal definition is the following sentence:</p>
<div class="codehilite"><pre><span></span><code>A timeslot is a temporal concept expressed in minutes ranging from 07:00 AM to
    09:00 AM with a length of 30 minutes.
</code></pre></div>

<p>Such concepts are conveniently translated as ASP facts by the ASP Rewriter as follows:</p>
<div class="codehilite"><pre><span></span><code>timeslot(1,&quot;07:00&quot;).
timeslot(2,&quot;07:30&quot;).
timeslot(3,&quot;08:00&quot;).
timeslot(4,&quot;08:30&quot;).
</code></pre></div>

<p>and the association between the used number and the corresponding time slot is stored into a dedicated data structure, so that when a user refers to a particular time slot (e.g., 07:30 AM), it is automatically encoded as the corresponding ASP atom (e.g., timeslot(2, "07:30")). The second term is a string representing the time slot, which is never used in the generated ASP encoding, but that can be useful when provided as output to the user.</p>
<h3>3.2 Implicit definition propositions</h3>
<p>Implicit definition propositions are used to define concepts that can, then, be used by other propositions. These definitions express the signature of the concept indicated by</p>
<p>the subject of the proposition, carrying information regarding the concept in the definition that our tool can use later on in the specification whenever the same concept is used. Differently from explicit definition propositions, users do not have to specify the properties of the concepts, because they are inferred from the sentence. In more details, the production rule of implicit definition propositions is the following:</p>
<div class="codehilite"><pre><span></span><code><span class="n">implicit_definition_proposition</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">constant_definition_clause</span><span class="w"> </span><span class="o">|</span>
<span class="n">compounded_clause</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">enumerative_definition_clause</span><span class="p">)</span><span class="n">CNL_END_OF_LINE</span>
</code></pre></div>

<p>In particular, an implicit definition proposition can be a constant_definition_clause, used to specify constants; or a compounded_clause, used to define elements using lists and ranges; or a enumerative_definition_clause, used to define elements one at a time, optionally closing the proposition with a when clause, defining a condition in which the element is defined (e.g., X is true when Y is true), and with a where clause.</p>
<h1>3.2.1 Constant definitions</h1>
<p>Constant definitions are used to introduce constants to be used later on in the specification.</p>
<p>The following sentences are examples of constant definitions:</p>
<div class="codehilite"><pre><span></span><code><span class="n">minKelvinTemperature</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">constant</span><span class="w"> </span><span class="n">equal</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mf">0.</span>
<span class="n">acceptableTemperature</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">constant</span><span class="o">.</span>
</code></pre></div>

<p>As we can see from the proposition at line 1 , the constant 0 is introduced with a equal to clause, and it is bound to the subject of the proposition. Instead, in the proposition at line 2 , we are defining a constant without assigning it a value, which can be later on assigned by the user (e.g., the ASP system ClingO (Gebser et al. 2016) supports the option --const to specify constants). In the case of constant definitions, there are no translations to ASP available, because they are instead stored in the data structures and substituted in the resulting program when the subject of the definition is used.</p>
<h3>3.2.2 Compound definitions</h3>
<p>Compound definitions are used to introduce a set of related concepts all at once, by making use of either ranges of numbers or lists. The following sentences are examples of compound definitions:</p>
<div class="codehilite"><pre><span></span><code>A ColdTemperature goes from minKelvinTemperature to acceptableTemperature.
A day goes from 1 to 365.
A drink is one of alcoholic, nonalcoholic and has color that is equal to
    respectively blue, yellow.
</code></pre></div>

<p>Propositions at lines 1 and 2 are examples of definitions using a range, identified by the construct goes from/to. In particular, proposition at line 1 uses the constants defined in Section 3.2.1.</p>
<p>Proposition at line 3 is an example of a definition of a drink using lists with a one of clause, where one can also specify additional attributes for each element of the list in a positional way using a respectively clause, and a list with the same number of elements of the list enumerating all the possible values that the subject of the proposition can have.</p>
<p>The corresponding ASP code, in this case, is quite straightforward and is depicted below:</p>
<div class="codehilite"><pre><span></span><code>coldtemperature(0..acceptableTemperature).
day(1..365).
drink(1, &quot;alcoholic&quot;, &quot;blue&quot;).
drink(2, &quot;nonalcoholic&quot;, &quot;yellow&quot;).
</code></pre></div>

<p>First of all, note that constant minKelvinTemperature is directly replaced by its value (i.e., 0), whereas constant acceptableTemperature is left as is. List elements defined in proposition at line 3 carry on their position number with them, which turns out to be handy as a basic way to encode precedence relationships when the subject is not a number.</p>
<h1>3.2.3 Enumerative definitions</h1>
<p>Enumerative definitions are used to introduce a property for a single concept or a relationship among a set of concepts. The peculiarity of this kind of propositions lies in the different translations into ASP as the clauses used within them change.</p>
<p>The following sentences are examples of enumerative definitions:</p>
<div class="codehilite"><pre><span></span><code>John is a waiter.
1 is a pub.
Alice is a patron.
Waiter John works in pub 1.
Waiter John serves a drink alcoholic.
Pub 1 is close to pub 2 and pub X, where X is one of 3,4.
Waiter W is working when waiter W serves a drink.
</code></pre></div>

<p>Such propositions show the construction to define relationships or properties related to a particular subject. In particular, propositions from line 1 to line 3 are used to define the concepts of waiter, pub, and patron, respectively, whereas propositions at lines 4 and 5 define concepts related to work in and to serve, respectively. Proposition at line 6 illustrates another feature of our CNL, i.e., where clauses, that are used in the example to define the values that the variable X can take. Proposition at line 7 is a conditional definition, identified by a when clause.</p>
<p>The translations in ASP of these examples are the following:</p>
<div class="codehilite"><pre><span></span><code><span class="nf">waiter</span><span class="p">(</span><span class="s2">&quot;john&quot;</span><span class="p">).</span>
<span class="nf">pub</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span>
<span class="nf">patron</span><span class="p">(</span><span class="s2">&quot;alice&quot;</span><span class="p">).</span>
<span class="nf">work_in</span><span class="p">(</span><span class="s2">&quot;john&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span>
<span class="nf">serve</span><span class="p">(</span><span class="s2">&quot;john&quot;</span><span class="p">,</span> <span class="s2">&quot;alcoholic&quot;</span><span class="p">).</span>
<span class="nf">close_to</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">).</span> <span class="nf">close_to</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">).</span>
<span class="nf">working</span><span class="p">(</span><span class="nv">W</span><span class="p">)</span> <span class="o">:-</span> <span class="nf">serve</span><span class="p">(</span><span class="nv">W</span><span class="p">,</span><span class="k">_</span><span class="p">).</span>
</code></pre></div>

<p>Propositions from line 1 to line 6 always hold true, therefore they are used by the ASP Rewriter to produce the corresponding ASP facts. In particular, proposition at line 6 is translated in a similar manner to compound definitions with lists. Instead, proposition at line 7 holds true only if the statement introduced by the when clause is true, hence it is translated into an ASP rule, where the body of the rule is the element inside the when clause.</p>
<p>Note that, in these examples, W is considered as a variable, whereas John and Alice are treated as ASP strings. This is because CNL2ASP assumes that every object starting with an upper case letter and containing only upper case letters, numbers or symbols is considered as a variable, while other objects are strings or numbers (e.g., MY_VARIABLE is considered as a variable, whereas My_String is considered as a string).</p>
<h1>3.3 CNL propositions</h1>
<p>Explicit and implicit definition propositions are used to define the concepts of the domain application, whose specifications are instead described by (standard) CNL propositions. The production rule of standard CNL propositions is the following:</p>
<div class="codehilite"><pre><span></span><code><span class="nx">standard_proposition</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">whenever_then_clause_proposition</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="nx">fact_proposition</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="nx">quantified_choice_proposition</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="nx">negative_strong_constraint_proposition</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="nx">positive_strong_constraint_proposition</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="nx">weak_constraint_proposition</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="p">)</span><span class="nx">CNL_END_OF_LINE</span>
</code></pre></div>

<p>Therefore, the CNL considers several types of propositions, which are described in the following.</p>
<h3>3.3.1 Whenever/then clauses</h3>
<p>Whenever/then clauses are used to describe actions occurring when a condition is fulfilled. In more details, the production rule is the following:
whenever_then_clause $\longrightarrow$ (whenever_clause ","?)+ then_clause
They start with whenever clauses, i.e., sentences specifying conditions, followed by a then clause, that is a sentence used to express the actions that must or can hold when the whenever clauses are fulfilled.</p>
<p>The following sentences are examples of whenever/then clauses:</p>
<div class="codehilite"><pre><span></span><code><span class="nv">Whenever</span><span class="w"> </span><span class="nv">there</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">movie</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">director</span><span class="w"> </span><span class="nv">equal</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">Spielberg</span>,<span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">id</span><span class="w"> </span><span class="nv">X</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="nv">we</span>
<span class="w">    </span><span class="nv">must</span><span class="w"> </span><span class="nv">have</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">topmovie</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">id</span><span class="w"> </span><span class="nv">X</span>.
<span class="nv">Whenever</span><span class="w"> </span><span class="nv">there</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">director</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">X</span><span class="w"> </span><span class="nv">different</span><span class="w"> </span><span class="nv">from</span><span class="w"> </span><span class="nv">Spielberg</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="nv">we</span><span class="w"> </span><span class="nv">can</span>
<span class="w">    </span><span class="nv">have</span><span class="w"> </span><span class="nv">at</span><span class="w"> </span><span class="nv">most</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nv">topmovie</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">id</span><span class="w"> </span><span class="nv">I</span><span class="w"> </span><span class="nv">such</span><span class="w"> </span><span class="nv">that</span><span class="w"> </span><span class="nv">there</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">movie</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">director</span><span class="w"> </span><span class="nv">X</span>,
<span class="w">        </span><span class="nv">and</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">id</span><span class="w"> </span><span class="nv">I</span>.
<span class="nv">Whenever</span><span class="w"> </span><span class="nv">there</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">movie</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">id</span><span class="w"> </span><span class="nv">I</span>,<span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">director</span><span class="w"> </span><span class="nv">equal</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">nolan</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="nv">we</span><span class="w"> </span><span class="nv">can</span>
<span class="w">    </span><span class="nv">have</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">scoreAssignment</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">movie</span><span class="w"> </span><span class="nv">I</span>,<span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">value</span><span class="w"> </span><span class="nv">equal</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="nv">or</span><span class="w"> </span><span class="nv">a</span>
<span class="w">    </span><span class="nv">scoreAssignment</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">movie</span><span class="w"> </span><span class="nv">I</span>,<span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">value</span><span class="w"> </span><span class="nv">equal</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="mi">2</span>.
</code></pre></div>

<p>Such propositions are encoded in ASP as follows:</p>
<div class="codehilite"><pre><span></span><code><span class="nf">topmovie</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">:-</span> <span class="nf">movie</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="k">_</span><span class="p">,</span><span class="s2">&quot;spielberg&quot;</span><span class="p">,</span><span class="k">_</span><span class="p">).</span>
<span class="mi">0</span> <span class="s s-Atom">&lt;=</span> <span class="p">{</span><span class="nf">topmovie</span><span class="p">(</span><span class="nv">I</span><span class="p">)</span><span class="o">:</span><span class="nf">movie</span><span class="p">(</span><span class="nv">I</span><span class="p">,</span><span class="k">_</span><span class="p">,</span><span class="nv">X</span><span class="p">,</span><span class="k">_</span><span class="p">)}</span> <span class="s s-Atom">&lt;=</span> <span class="mi">1</span> <span class="o">:-</span> <span class="nf">director</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span> <span class="nv">X</span> <span class="p">!</span><span class="o">=</span> <span class="s2">&quot;spielberg&quot;</span><span class="p">.</span>
<span class="nf">scoreassignment</span><span class="p">(</span><span class="nf">movie</span><span class="p">(</span><span class="nv">I</span><span class="p">),</span><span class="mi">3</span><span class="p">)</span> <span class="p">|</span> <span class="nf">scoreassignment</span><span class="p">(</span><span class="nf">movie</span><span class="p">(</span><span class="nv">I</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span> <span class="o">:-</span>
    <span class="nf">movie</span><span class="p">(</span><span class="nv">I</span><span class="p">,</span><span class="k">_</span><span class="p">,</span><span class="s2">&quot;nolan&quot;</span><span class="p">,</span><span class="k">_</span><span class="p">).</span>
</code></pre></div>

<p>In particular, the form whenever/then followed by the word must is translated as a normal rule by the ASP Rewriter, whereas if it is followed by the word can then it can be</p>
<p>translated as a choice rule or as a disjunctive rule depending on whether the CNL sentence contains the keyword or. Here, we want also to emphasize the fact that the first term of scoreAssignment is of the form movie(I) since it is defined to be of the type movie.</p>
<h1>3.3.2 Fact proposition</h1>
<p>Fact propositions are used to define the facts of the problem. Differently from implicit definition propositions, here no new concepts are introduced, meaning that all concepts used here must be explicitly defined. An example of a fact proposition is the following sentence:</p>
<p>There is a movie with id equal to 1, with director equal to Spielberg, with title equal to jurassicPark, with year equal to 1993.</p>
<p>This sentence is translated as:
movie(1,"jurassicPark","spielberg",1993).
It is worth mentioning that the order of the elements listed in the sentence has no impact on its translation, since the properties of the concepts are explicitly defined. Therefore, the specifications listed below all produce the same ASP output.</p>
<p>There is a movie with id equal to 1, with director equal to Spielberg, with year equal to 1993, with title equal to jurassicPark.
There is a movie with director equal to Spielberg, with year equal to 1993, with id equal to 1, with title equal to jurassicPark.</p>
<h3>3.3.3 Quantified choice propositions</h3>
<p>Quantified choice propositions are used to define relationships or properties that can be true for a given set of selected concepts following a choice. Also these propositions define a signature for the concept upon which the choice has to be made. Quantified propositions are always introduced by the every quantifier and, since they express possibilities, always contain a can clause. In more details, the production rule is the following:
quantified_choice_proposition $\longrightarrow$ quantifier subject_clause "can" CNL_COPULA? ( verb_name | verb_name_with_preposition) (quantified_exact_quantity_clause | quantified_range_clause)? (quantified_object_clause | disjunctive_clause)? foreach_clause?</p>
<p>Thus, they start with a quantifier, and are always followed by a subject and a verb, optionally connected by a CNL_COPULA (e.g., is, is a, is an, ...) and then, also optionally, either by a sentence of type quantified_exact_quantity_clause, used to express the quantity in exact terms (e.g., exactly 1); or by a sentence of type quantified_range_clause, used to express it using a range (e.g., between 1 and 2). The proposition can be closed either with an object clause, i.e., a sentence used to express an object for the proposition, in a subject verb object fashion, or with a disjunctive clause; and, finally, a foreach clause, i.e., a sentence used to express additional objects for which any possible value can be tried.</p>
<p>The following sentences are examples of quantified choice propositions:
Every patron can drink in exactly 1 pub for each day.
Every waiter can serve a drink.</p>
<p>3 Every movie with id I can have a scoreAssignment with movie I, and with value equal to 1 or a scoreAssignment with movie I, and with value equal to 2, or a scoreAssignment with movie I, and with value equal to 3.</p>
<p>Proposition at line 1 shows how one can express an exact number of choices that can be made for the concept expressed by the subject, and also how other concepts can be used in tandem with the subject to create a sort of cartesian product of choices, using a for each clause. These last constructions are optional, as shown in proposition at line 2. Proposition at line 3, instead, shows an example of a disjunctive clause. Their full translations into ASP is shown below:</p>
<div class="codehilite"><pre><span></span><code><span class="mi">1</span> <span class="s s-Atom">&lt;=</span> <span class="p">{</span><span class="nf">drink_in</span><span class="p">(</span><span class="k">_</span><span class="nv">X1</span><span class="p">,</span><span class="k">_</span><span class="nv">X2</span><span class="p">,</span><span class="k">_</span><span class="nv">X3</span><span class="p">)</span><span class="o">:</span><span class="nf">pub</span><span class="p">(</span><span class="k">_</span><span class="nv">X3</span><span class="p">)}</span> <span class="s s-Atom">&lt;=</span> <span class="mi">1</span> <span class="o">:-</span> <span class="nf">patron</span><span class="p">(</span><span class="k">_</span><span class="nv">X1</span><span class="p">),</span> <span class="nf">day</span><span class="p">(</span><span class="k">_</span><span class="nv">X2</span><span class="p">).</span>
<span class="p">{</span><span class="nf">serve</span><span class="p">(</span><span class="k">_</span><span class="nv">X1</span><span class="p">,</span><span class="k">_</span><span class="nv">X2</span><span class="p">)</span><span class="o">:</span><span class="nf">drink</span><span class="p">(</span><span class="k">_</span><span class="p">,</span><span class="k">_</span><span class="nv">X2</span><span class="p">,</span><span class="k">_</span><span class="p">)}</span> <span class="o">:-</span> <span class="nf">waiter</span><span class="p">(</span><span class="k">_</span><span class="nv">X1</span><span class="p">).</span>
<span class="nf">scoreassignment</span><span class="p">(</span><span class="nf">movie</span><span class="p">(</span><span class="nv">I</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span> <span class="p">|</span> <span class="nf">scoreassignment</span><span class="p">(</span><span class="nf">movie</span><span class="p">(</span><span class="nv">I</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span> <span class="p">|</span>
    <span class="nf">scoreassignment</span><span class="p">(</span><span class="nf">movie</span><span class="p">(</span><span class="nv">I</span><span class="p">),</span><span class="mi">3</span><span class="p">)</span> <span class="o">:-</span> <span class="nf">movie</span><span class="p">(</span><span class="nv">I</span><span class="p">,</span><span class="k">_</span><span class="p">,</span><span class="k">_</span><span class="p">,</span><span class="k">_</span><span class="p">).</span>
</code></pre></div>

<p>The first two translations use choice rules (possibly with bounds), that are the ASP constructs that make it possible to represent propositions of this type, whereas the third one uses a disjunctive rule. Note that the first two rules also employ generated variables (starting with symbol _) that are used wherever two atoms have to be bound and no variable to use has been found in the specification given in input. This feature enables the specification writer to avoid cluttering the document with unnecessary variables, as can be seen throughout the propositions, with the only limitation that anaphoras have to be expressed explicitly by providing the correct variable.</p>
<h1>3.3.4 Negative and positive strong constraints</h1>
<p>Negative and positive strong constraint propositions are used to define assertions that must be true for a given set of selected concepts. This kind of propositions does not introduce new signatures but, on the contrary, they consume other signatures that were previously defined, meaning that the concepts used inside such constraints have to be defined before they are used. A strong constraint can represent either a prohibition (sentences starting with It is prohibited) or a requirement (sentences starting with It is required). After specifying if the strong constraint is a prohibition or a requirement, then a user can add simple clauses, that are made of a subject, a verb, and related object clauses; aggregate clauses, either in active or passive form, that define an aggregation of the set of concepts that satisfy the statement in their body with the operator that was specified (number, total, lowest, highest); or other complex clauses as shown below.</p>
<p>In more details, the production rules of strong constraints are the following:</p>
<div class="codehilite"><pre><span></span><code><span class="nx">negative_strong_constraint_clause</span><span class="w"> </span><span class="p">}</span><span class="o">-&gt;</span><span class="err">\</span><span class="nx">mathrm</span><span class="p">{</span><span class="w"> </span><span class="s">&quot;it is prohibited that&quot;</span><span class="w"> </span><span class="p">(</span><span class="nx">simple_clause</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;</span>
<span class="s">    and also&quot;</span><span class="w"> </span><span class="nx">simple_clause</span><span class="p">)</span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="nx">where_clause</span><span class="p">)?</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="w"> </span><span class="p">(</span><span class="nx">whenever_clause</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="p">?)</span><span class="o">+</span><span class="p">)?</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="nx">aggregate_clause</span><span class="w"> </span><span class="nx">comparison_clause</span><span class="w"> </span><span class="p">(</span><span class="nx">where_clause</span><span class="p">)?</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="w"> </span><span class="p">(</span><span class="nx">whenever_clause</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="w"> </span>
<span class="w">    </span><span class="p">?)</span><span class="o">+</span><span class="p">)?</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">when_then_clause</span><span class="w"> </span><span class="p">(</span><span class="nx">where_clause</span><span class="p">)?</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">quantified_constraint</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="nx">where_clause</span><span class="p">)?</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">condition_clause</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="w"> </span><span class="p">(</span><span class="nx">whenever_clause</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="p">?)</span><span class="o">+</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="nx">temporal_constraint</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="w"> </span><span class="p">(</span><span class="nx">whenever_clause</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="p">?)</span><span class="o">+</span><span class="p">)</span>
<span class="mi">2</span><span class="w"> </span><span class="nx">positive_strong_constraint_proposition</span><span class="w"> </span><span class="p">}</span><span class="o">-&gt;</span><span class="err">\</span><span class="nx">mathrm</span><span class="p">{</span><span class="w"> </span><span class="s">&quot;it is required that&quot;</span><span class="w"> </span><span class="p">(</span><span class="nx">simple_clause</span><span class="w"> </span><span class="s">&quot;</span>
<span class="s">    ,&quot;</span><span class="w"> </span><span class="p">(</span><span class="nx">whenever_clause</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="p">?)</span><span class="o">+</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">aggregate_clause</span><span class="w"> </span><span class="nx">comparison_clause</span><span class="w"> </span><span class="p">(</span><span class="nx">where_clause</span>
<span class="w">    </span><span class="p">)?</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="w"> </span><span class="p">(</span><span class="nx">whenever_clause</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="p">?)</span><span class="o">+</span><span class="p">)?</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">when_then_clause</span><span class="w"> </span><span class="p">(</span><span class="nx">where_clause</span><span class="p">)?</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="nx">quantified_constraint</span><span class="w"> </span><span class="p">(</span><span class="nx">where_clause</span><span class="p">)?</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">condition_clause</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="w"> </span><span class="p">(</span><span class="nx">whenever_clause</span>
<span class="w">        </span><span class="s">&quot;,&quot;</span><span class="p">?)</span><span class="o">+</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">temporal_constraint</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="w"> </span><span class="p">(</span><span class="nx">whenever_clause</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="p">?)</span><span class="o">+</span><span class="p">)</span>
</code></pre></div>

<p>It is possible to observe that they start with the sentence it is prohibited that or with the sentence it is required that and are always followed by a simple clause, i.e., a sentence of the form subject verb object; by an aggregate clause, a sentence expressing a form of aggregations (e.g., the number of); by a whenever clause, described in Section 3.3.1; by a quantified constraint, used to specify clauses with quantifiers as every or any; or by a temporal constraint, used to specify constraints on temporal concepts as after 11:00 AM or before 11:00 AM. After simple clauses, aggregate clauses, and quantified constraints, additional sentences can be added, which can be of the type where_clause , used to specify conditions; or of the type comparison_clause, used to specify comparison between elements (e.g., X is equal to 1 ).</p>
<p>The following sentences are examples of negative and positive strong constraints:</p>
<div class="codehilite"><pre><span></span><code><span class="nv">It</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">prohibited</span><span class="w"> </span><span class="nv">that</span><span class="w"> </span><span class="nv">waiter</span><span class="w"> </span><span class="nv">W1</span><span class="w"> </span><span class="nv">work</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">pub</span><span class="w"> </span><span class="nv">P1</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">also</span><span class="w"> </span><span class="nv">waiter</span><span class="w"> </span><span class="nv">W2</span><span class="w"> </span><span class="nv">work</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">pub</span><span class="w"> </span><span class="nv">P1</span>,
<span class="w">    </span><span class="nv">where</span><span class="w"> </span><span class="nv">W1</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">different</span><span class="w"> </span><span class="nv">from</span><span class="w"> </span><span class="nv">W2</span>.
<span class="nv">It</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">prohibited</span><span class="w"> </span><span class="nv">that</span><span class="w"> </span><span class="nv">X</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">equal</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">Y</span>,<span class="w"> </span><span class="nv">whenever</span><span class="w"> </span><span class="nv">there</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">movie</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">id</span><span class="w"> </span><span class="nv">X</span>,<span class="w"> </span><span class="nv">and</span>
<span class="w">    </span><span class="nv">with</span><span class="w"> </span><span class="nv">year</span><span class="w"> </span><span class="nv">equal</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="mi">1964</span>,<span class="w"> </span><span class="nv">whenever</span><span class="w"> </span><span class="nv">there</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">topMovie</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">id</span><span class="w"> </span><span class="nv">Y</span>.
<span class="nv">It</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">prohibited</span><span class="w"> </span><span class="nv">that</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">lowest</span><span class="w"> </span><span class="nv">value</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">scoreAssignment</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">movie</span><span class="w"> </span><span class="nv">X</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">equal</span>
<span class="w">    </span><span class="nv">to</span><span class="w"> </span><span class="mi">1</span>,<span class="w"> </span><span class="nv">whenever</span><span class="w"> </span><span class="nv">there</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">topMovie</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">id</span><span class="w"> </span><span class="nv">X</span>.
<span class="nv">It</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">required</span><span class="w"> </span><span class="nv">that</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">total</span><span class="w"> </span><span class="nv">value</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">scoreAssignment</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">movie</span><span class="w"> </span><span class="nv">X</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">equal</span><span class="w"> </span><span class="nv">to</span>
<span class="w">    </span><span class="mi">10</span>,<span class="w"> </span><span class="nv">such</span><span class="w"> </span><span class="nv">that</span><span class="w"> </span><span class="nv">there</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">topMovie</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">id</span><span class="w"> </span><span class="nv">X</span>.
<span class="nv">It</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">required</span><span class="w"> </span><span class="nv">that</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">number</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">pub</span><span class="w"> </span><span class="nv">where</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">waiter</span><span class="w"> </span><span class="nv">work</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">less</span><span class="w"> </span><span class="nv">than</span><span class="w"> </span><span class="mi">2</span>.
<span class="nv">It</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">required</span><span class="w"> </span><span class="nv">that</span><span class="w"> </span><span class="nv">when</span><span class="w"> </span><span class="nv">waiter</span><span class="w"> </span><span class="nv">X</span><span class="w"> </span><span class="nv">works</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">pub</span><span class="w"> </span><span class="nv">P1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="nv">waiter</span><span class="w"> </span><span class="nv">X</span><span class="w"> </span><span class="nv">does</span><span class="w"> </span><span class="nv">not</span><span class="w"> </span><span class="nv">work</span><span class="w"> </span><span class="nv">in</span>
<span class="w">    </span><span class="nv">pub</span><span class="w"> </span><span class="nv">P2</span>,<span class="w"> </span><span class="nv">where</span><span class="w"> </span><span class="nv">P1</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">different</span><span class="w"> </span><span class="nv">from</span><span class="w"> </span><span class="nv">P2</span>.
<span class="nv">It</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">required</span><span class="w"> </span><span class="nv">that</span><span class="w"> </span><span class="nv">V</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">equal</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="mi">3</span>,<span class="w"> </span><span class="nv">whenever</span><span class="w"> </span><span class="nv">there</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">movie</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">id</span><span class="w"> </span><span class="nv">I</span>,<span class="w"> </span><span class="nv">and</span>
<span class="w">    </span><span class="nv">with</span><span class="w"> </span><span class="nv">director</span><span class="w"> </span><span class="nv">equal</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">spielberg</span>,<span class="w"> </span><span class="nv">whenever</span><span class="w"> </span><span class="nv">there</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">scoreAssignment</span><span class="w"> </span><span class="nv">with</span>
<span class="w">    </span><span class="nv">movie</span><span class="w"> </span><span class="nv">I</span>,<span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">value</span><span class="w"> </span><span class="nv">V</span>.
<span class="nv">It</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">required</span><span class="w"> </span><span class="nv">that</span><span class="w"> </span><span class="nv">every</span><span class="w"> </span><span class="nv">waiter</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">payed</span>.
</code></pre></div>

<p>Proposition at line 1 shows a practical example of the combination of several simple clauses, and the feature enabled by where clauses, that makes it possible to express comparisons between variables. Proposition at line 2 shows an example of whenever clause. Propositions at line 3, at line 4, and at line 5 show examples of aggregation expressing conditions on the minimum value, on the sum of values, and on the number of occurrences, respectively. Proposition at line 6 shows a when/then clause. Proposition at line 7 shows an example of whenever clause in the context of positive strong constraints. Lastly, proposition at line 8 is an example of how to specify a requirement that must hold for all the elements present in a particular set of concepts. Such propositions are encoded as ASP rules as follows:</p>
<div class="codehilite"><pre><span></span><code><span class="p">:- </span>work_in(<span class="nv">W1</span>,<span class="nv">P1</span>), work_in(<span class="nv">W2</span>,<span class="nv">P1</span>), <span class="nv">W1</span> <span class="o">!=</span> <span class="nv">W2</span>.
<span class="p">:- </span>movie(<span class="nv">X</span>,<span class="nv">_</span>,<span class="nv">_</span>,<span class="m">1964</span>), topmovie(<span class="nv">Y</span>), <span class="nv">X</span> <span class="o">=</span> <span class="nv">Y</span>.
<span class="p">:- </span>topmovie(<span class="nv">X</span>), <span class="err">#</span>min<span class="k">{</span><span class="nv">_X1</span><span class="o">:</span> scoreassignment(movie(<span class="nv">X</span>),<span class="nv">_X1</span>)<span class="k">}</span> <span class="o">=</span> <span class="m">1.</span>
<span class="p">:- </span><span class="err">#sum{_X1: </span>scoreassignment(movie(<span class="nv">X</span>),<span class="nv">_X1</span>), topmovie(<span class="nv">X</span>)<span class="k">}</span> <span class="o">!=</span> <span class="m">10.</span>
<span class="p">:- </span>waiter(<span class="nv">_X1</span>), <span class="err">#</span>count<span class="k">{</span><span class="nv">_X2</span><span class="o">:</span> work_in(<span class="nv">_X1</span>,<span class="nv">_X2</span>)<span class="k">}</span> <span class="o">&gt;=</span> <span class="m">3.</span>
<span class="p">:- </span>work_in(<span class="nv">X</span>,<span class="nv">P1</span>), work_in(<span class="nv">X</span>,<span class="nv">P2</span>), <span class="nv">P1</span> <span class="o">!=</span> <span class="nv">P2</span>.
<span class="p">:- </span>movie(<span class="nv">I</span>,<span class="nv">_</span>,<span class="s">&quot;spielberg&quot;</span>,<span class="nv">_</span>), scoreassignment(movie(<span class="nv">I</span>),<span class="nv">V</span>), <span class="nv">V</span> <span class="o">!=</span> <span class="m">3.</span>
<span class="p">:- </span><span class="err">not </span>payed(<span class="nv">_X1</span>), waiter(<span class="nv">_X1</span>).
</code></pre></div>

<p>Note that their translation is quite intuitive, and positive strong constraints are translated as ASP constraints by negating the condition expressed by the sentence.</p>
<h1>3.3.5 Weak constraint propositions</h1>
<p>Weak constraint propositions are used to define assertions that are preferably true for a given set of selected concepts. Also this type of propositions consumes signatures from previously defined concepts. They are always introduced by it is preferred and need the specification of the optimization objective (either minimization or maximization), and the level of priority of the optimization (low, medium or high). The production rule is the following:</p>
<div class="codehilite"><pre><span></span><code><span class="n">weak_constraint_proposition</span><span class="w"> </span>\<span class="p">(</span>\<span class="n">longrightarrow</span>\<span class="p">)</span><span class="w"> </span><span class="s2">&quot;it is preferred that&quot;</span>
<span class="w">    </span><span class="n">CNL_WEAK_OPTIMIZATION_OPERATOR</span><span class="err">?</span><span class="w"> </span><span class="s2">&quot;,&quot;</span><span class="err">?</span><span class="w"> </span><span class="n">weak_priority_operator</span><span class="w"> </span><span class="s2">&quot;,&quot;</span><span class="err">?</span><span class="w"> </span><span class="s2">&quot;that&quot;</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">condition_operation</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">aggregate_clause</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">subject_clause</span><span class="w"> </span><span class="n">CNL_COPULA</span><span class="w"> </span><span class="p">(</span><span class="n">verb_name</span>
<span class="w">        </span><span class="o">|</span><span class="w"> </span><span class="n">verb_name_with_preposition</span><span class="p">)</span><span class="w"> </span><span class="n">object_clause</span><span class="w"> </span><span class="s2">&quot;,&quot;</span><span class="w"> </span><span class="n">whenever_clause</span><span class="p">)</span>
<span class="w">    </span><span class="n">weak_optimization_operator</span><span class="err">?</span><span class="w"> </span><span class="p">(</span><span class="n">where_clause</span><span class="p">)</span><span class="err">?</span>
</code></pre></div>

<p>In particular, they start with the sentence it is preferred ... that, and can be followed by a sentence expressing the nature of the optimization (i.e., as much as possible or as little as possible), and are always followed by a priority operator, i.e., a sentence expressing the level of relevance of the constraint with respect to other weak constraints (e.g., "with low priority") and either a clause followed by a whenever clause, an aggregate clause or a condition operation, i.e., a sentence expressing operations between variables in the proposition (e.g., the sum of X and Y ). The proposition is closed with an optimization operator, i.e., a sentence expressing the nature of the optimization (i.e., "is minimized" or "is maximized") and an optional where clause. Note that here we have two ways for expressing the object, either in the form of as much (little) as possible at the beginning of the sentence or using is maximized (minimized) at the end of the sentence. The two ways are equivalent, but we support both of them to make sentences more natural. Moreover, sentences containing both kind of specifications are well-formed, thus they are correctly parsed even if they are in contrast (e.g., a user can specify as much as possible and "is minimized" in the same sentence). However, CNL2ASP subsequently checks if this happens and, in case, it triggers an error so that only one of the form is used.</p>
<p>The following sentences are examples of weak constraint propositions:</p>
<p>1 It is preferred with low priority that the number of drinks that are serve is maximized.
2 It is preferred as little as possible, with high priority, that V is equal to 1 , whenever there is a scoreAssignment with movie I, and with value V, whenever there is a topMovie with id I.
3 It is preferred, with medium priority, that whenever there is a topMovie with id I, whenever there is a scoreAssignment with movie I, and with value V, V is maximized.
4 It is preferred, with medium priority, that the total value of a scoreAssignment is maximized.</p>
<p>The sentence at line 1 shows an example of a maximization over the result of a #count aggregate. The sentence at line 2 instead is an example of minimization using the form as little as possible. Then, the sentence at line 3 shows a sentence where the subject of maximization is a variable defined in scoreAssignment. Finally, the sentence at line 4 is an example of a #sum aggregate, where the result of the aggregation is subject to maximization. Translation of the propositions above are shown below:</p>
<div class="codehilite"><pre><span></span><code><span class="o">:</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="err">#</span><span class="n">count</span><span class="p">{</span><span class="n">_X1</span><span class="o">:</span><span class="w"> </span><span class="n">serve</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="n">_X1</span><span class="p">)}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_X2</span><span class="p">.</span><span class="w"> </span><span class="p">[</span><span class="o">-</span><span class="n">_X2</span><span class="mi">@1</span><span class="p">]</span>
<span class="o">:</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">scoreassignment</span><span class="p">(</span><span class="n">movie</span><span class="p">(</span><span class="n">I</span><span class="p">),</span><span class="n">V</span><span class="p">),</span><span class="w"> </span><span class="n">topmovie</span><span class="p">(</span><span class="n">I</span><span class="p">),</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.</span><span class="w"> </span><span class="p">[</span><span class="mi">1@3</span><span class="p">,</span><span class="w"> </span><span class="n">I</span><span class="p">,</span><span class="n">V</span><span class="p">]</span>
<span class="o">:</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">topmovie</span><span class="p">(</span><span class="n">I</span><span class="p">),</span><span class="w"> </span><span class="n">scoreassignment</span><span class="p">(</span><span class="n">movie</span><span class="p">(</span><span class="n">I</span><span class="p">),</span><span class="n">V</span><span class="p">).</span><span class="w"> </span><span class="p">[</span><span class="o">-</span><span class="n">V</span><span class="mi">@2</span><span class="p">,</span><span class="w"> </span><span class="n">I</span><span class="p">]</span>
<span class="o">:</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="err">#</span><span class="n">sum</span><span class="p">{</span><span class="n">_X1</span><span class="o">:</span><span class="w"> </span><span class="n">scoreassignment</span><span class="p">(</span><span class="n">movie</span><span class="p">(</span><span class="n">_</span><span class="p">),</span><span class="n">_X1</span><span class="p">)}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_X2</span><span class="p">.</span><span class="w"> </span><span class="p">[</span><span class="o">-</span><span class="n">_X2</span><span class="mi">@2</span><span class="p">]</span>
</code></pre></div>

<p>Also in this case the translation is quite intuitive, however one should note that maximization constructs are translated using negative weights.</p>
<h1>3.4 Usage</h1>
<p>In this section, we provide a few technical details and report the usage of the tool. CNL2ASP has been implemented using the programming language Python, and the open-source library lark (https://github.com/lark-parser/lark) for creating the Parser, which is the only required dependence to run it. Moreover, the tool requires to use the version 3.10 (or higher) of Python. Concerning the distribution licence, CNL2ASP is released under the Apache 2.0 licence, a permissive open-source licence, which allows the user to use it also in industrial contexts. Its usage is quite intuitive since it can be used as a standalone tool by issuing the command
python3 src/main.py input_file [output_file]
or, as an alternative, it can be used as a library in other Python projects by simply importing it.</p>
<h2>4 Synthetic use cases</h2>
<p>In this section, we present some examples to demonstrate how the language can be used to define well-known combinatorial problems in a natural and easily understandable way. The corresponding translations into ASP are also provided.</p>
<h3>4.1 Graph coloring</h3>
<p>We begin by presenting an encoding of the graph coloring problem using our CNL. We recall that the graph coloring problem is the problem of finding an assignment of colors to nodes in a graph such that two adjacent nodes do not share the same color.</p>
<div class="codehilite"><pre><span></span><code><span class="n">A</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="n">goes</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="mh">1</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mf">3.</span>
<span class="n">A</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">red</span><span class="p">,</span><span class="w"> </span><span class="n">green</span><span class="p">,</span><span class="w"> </span><span class="n">blue</span><span class="p">.</span>
<span class="n">Node</span><span class="w"> </span><span class="mh">1</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">connected</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="mh">2</span><span class="p">,</span><span class="w"> </span><span class="mf">3.</span>
<span class="n">Node</span><span class="w"> </span><span class="mh">2</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">connected</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="mh">1</span><span class="p">,</span><span class="w"> </span><span class="mf">3.</span>
<span class="n">Node</span><span class="w"> </span><span class="mh">3</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">connected</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="mh">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2.</span>
<span class="n">Every</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">assigned</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">exactly</span><span class="w"> </span><span class="mh">1</span><span class="w"> </span><span class="n">color</span><span class="p">.</span>
<span class="n">It</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">required</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">when</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">connected</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="k">not</span>
<span class="w">    </span><span class="n">assigned</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">also</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="n">assigned</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="n">C</span><span class="p">.</span>
</code></pre></div>

<p>One can notice the presence of explicit definition propositions (lines 1-5), with a ranged definition proposition (line 1) and a list definition proposition (line 2), enumerative definition propositions with where clauses (lines 3-5), a quantified clause (line 6) and, lastly, a positive strong constraint (line 7).</p>
<p>The resulting ASP encoding is the following:</p>
<div class="codehilite"><pre><span></span><code>node(<span class="m">1.</span>.<span class="m">3</span>).
color(<span class="m">1</span>,<span class="s">&quot;red&quot;</span>). color(<span class="m">2</span>,<span class="s">&quot;green&quot;</span>). color(<span class="m">3</span>,<span class="s">&quot;blue&quot;</span>).
connected_to(<span class="m">1</span>,<span class="m">2</span>). connected_to(<span class="m">1</span>,<span class="m">3</span>).
connected_to(<span class="m">2</span>,<span class="m">1</span>). connected_to(<span class="m">2</span>,<span class="m">3</span>).
connected_to(<span class="m">3</span>,<span class="m">1</span>). connected_to(<span class="m">3</span>,<span class="m">2</span>).
<span class="k">{</span>assigned_to(<span class="nv">_X1</span>,<span class="nv">_X2</span>)<span class="o">:</span> color(<span class="nv">_</span>,<span class="nv">_X2</span>)<span class="k">}</span> <span class="o">=</span> <span class="m">1</span> <span class="o">:-</span> node(<span class="nv">_X1</span>).
<span class="p">:- </span>connected_to(<span class="nv">X</span>,<span class="nv">Y</span>), assigned_to(<span class="nv">X</span>,<span class="nv">C</span>), assigned_to(<span class="nv">Y</span>,<span class="nv">C</span>).
</code></pre></div>

<p>where each proposition at line $i$ is translated as the rule(s) reported at line $i$ (with $i=1 . .7)$.</p>
<h1>4.2 Hamiltonian path</h1>
<p>The second problem we consider here is the well-known Hamiltonian path problem, which is the problem of finding a path in a graph that visits each node exactly once, starting from a given node.</p>
<div class="codehilite"><pre><span></span><code>A node goes from 1 to 5.
Node 1 is connected to node X, where X is one of 2, 3.
Node 2 is connected to node X, where X is one of 1, 4.
Node 3 is connected to node X, where X is one of 1, 4.
Node 4 is connected to node X, where X is one of 3, 5.
Node 5 is connected to node X, where X is one of 3, 4.
Every node X can have a path to a node connected to node X.
It is required that the number of nodes where node X has a path to is equal to 1.
It is required that the number of nodes that have a path to node X is equal to 1.
Node Y is reachable when node X is reachable and also node X has a path to node Y
</code></pre></div>

<p>It is required that every node is reachable.
start is a constant equal to 1.
Node start is reachable.
Line 1 defines the nodes and lines from 2-6 define the connections between nodes. Then, line 7 reports a quantified proposition with an object accompanied by a verb clause, lines 8 and 9 report strong constraint propositions with aggregates, line 10 reports a conditional definition clause, line 11 reports a constraint clause with the presence of a quantifier, and line 12 defines the constant start, which is subsequently used in line 13. The ASP encoding corresponding to the CNL statements is the following:</p>
<div class="codehilite"><pre><span></span><code>node(<span class="m">1.</span>.<span class="m">5</span>).
connected_to(<span class="m">1</span>,<span class="m">2</span>). connected_to(<span class="m">1</span>,<span class="m">3</span>).
connected_to(<span class="m">2</span>,<span class="m">1</span>). connected_to(<span class="m">2</span>,<span class="m">4</span>).
connected_to(<span class="m">3</span>,<span class="m">1</span>). connected_to(<span class="m">3</span>,<span class="m">4</span>).
connected_to(<span class="m">4</span>,<span class="m">3</span>). connected_to(<span class="m">4</span>,<span class="m">5</span>).
connected_to(<span class="m">5</span>,<span class="m">3</span>). connected_to(<span class="m">5</span>,<span class="m">4</span>).
<span class="k">{</span>path_to(<span class="nv">X</span>,<span class="nv">_X1</span>)<span class="o">:</span> connected_to(<span class="nv">X</span>,<span class="nv">_X1</span>)<span class="k">}</span> <span class="o">:-</span> node(<span class="nv">X</span>).
<span class="p">:- </span>node(<span class="nv">X</span>), <span class="err">#</span>count<span class="k">{</span><span class="nv">_X2</span><span class="o">:</span> path_to(<span class="nv">X</span>,<span class="nv">_X2</span>)<span class="k">}</span> <span class="o">!=</span> <span class="m">1.</span>
<span class="p">:- </span>node(<span class="nv">X</span>), <span class="err">#</span>count<span class="k">{</span><span class="nv">_X3</span><span class="o">:</span> path_to(<span class="nv">_X3</span>,<span class="nv">X</span>)<span class="k">}</span> <span class="o">!=</span> <span class="m">1.</span>
reachable(<span class="nv">Y</span>) <span class="o">:-</span> reachable(<span class="nv">X</span>), path_to(<span class="nv">X</span>,<span class="nv">Y</span>).
<span class="p">:- </span><span class="err">not </span>reachable(<span class="nv">_X4</span>), node(<span class="nv">_X4</span>).
reachable(<span class="m">1</span>).
</code></pre></div>

<p>where a CNL statement at line $i$ is represented by the rule(s) at line $i$ with $(i=1 . .11)$, whereas CNL statements reported in lines 12 and 13 are encoded by the rule at line 12.</p>
<p>As an alternative, one could also use the sentence start is a constant, and then use the solver options to change the starting node.</p>
<h1>4.3 Maximal clique</h1>
<p>The third problem is the maximal clique problem, which is the problem of finding a clique, i.e., a subset of the nodes of a given graph where all nodes in the clique are adjacent to each other, and the cardinality of the clique is maximal.</p>
<div class="codehilite"><pre><span></span><code><span class="nv">A</span><span class="w"> </span><span class="nv">node</span><span class="w"> </span><span class="nv">goes</span><span class="w"> </span><span class="nv">from</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="mi">5</span>.
<span class="nv">Node</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">connected</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">node</span><span class="w"> </span><span class="nv">X</span>,<span class="w"> </span><span class="nv">where</span><span class="w"> </span><span class="nv">X</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">one</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="mi">2</span>,<span class="w"> </span><span class="mi">3</span>.
<span class="nv">Node</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">connected</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">node</span><span class="w"> </span><span class="nv">X</span>,<span class="w"> </span><span class="nv">where</span><span class="w"> </span><span class="nv">X</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">one</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="mi">1</span>,<span class="w"> </span><span class="mi">3</span>,<span class="w"> </span><span class="mi">4</span>,<span class="w"> </span><span class="mi">5</span>.
<span class="nv">Node</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">connected</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">node</span><span class="w"> </span><span class="nv">X</span>,<span class="w"> </span><span class="nv">where</span><span class="w"> </span><span class="nv">X</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">one</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="mi">1</span>,<span class="w"> </span><span class="mi">2</span>,<span class="w"> </span><span class="mi">4</span>,<span class="w"> </span><span class="mi">5</span>.
<span class="nv">Node</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">connected</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">node</span><span class="w"> </span><span class="nv">X</span>,<span class="w"> </span><span class="nv">where</span><span class="w"> </span><span class="nv">X</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">one</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="mi">2</span>,<span class="w"> </span><span class="mi">3</span>,<span class="w"> </span><span class="mi">5</span>.
<span class="nv">Node</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">connected</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">node</span><span class="w"> </span><span class="nv">X</span>,<span class="w"> </span><span class="nv">where</span><span class="w"> </span><span class="nv">X</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">one</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="mi">2</span>,<span class="w"> </span><span class="mi">3</span>,<span class="w"> </span><span class="mi">4</span>.
<span class="nv">Every</span><span class="w"> </span><span class="nv">node</span><span class="w"> </span><span class="nv">can</span><span class="w"> </span><span class="nv">be</span><span class="w"> </span><span class="nv">chosen</span>.
<span class="nv">It</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">required</span><span class="w"> </span><span class="nv">that</span><span class="w"> </span><span class="nv">when</span><span class="w"> </span><span class="nv">node</span><span class="w"> </span><span class="nv">X</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">not</span><span class="w"> </span><span class="nv">connected</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">node</span><span class="w"> </span><span class="nv">Y</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="nv">node</span><span class="w"> </span><span class="nv">X</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">not</span>
<span class="w">    </span><span class="nv">chosen</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">also</span><span class="w"> </span><span class="nv">node</span><span class="w"> </span><span class="nv">Y</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">not</span><span class="w"> </span><span class="nv">chosen</span>,<span class="w"> </span><span class="nv">where</span><span class="w"> </span><span class="nv">X</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">different</span><span class="w"> </span><span class="nv">from</span><span class="w"> </span><span class="nv">Y</span>.
<span class="nv">It</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">preferred</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">high</span><span class="w"> </span><span class="nv">priority</span><span class="w"> </span><span class="nv">that</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">number</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">nodes</span><span class="w"> </span><span class="nv">that</span><span class="w"> </span><span class="nv">are</span><span class="w"> </span><span class="nv">chosen</span><span class="w"> </span><span class="nv">is</span>
<span class="w">    </span><span class="nv">maximized</span>.
</code></pre></div>

<p>where statements from line 1 to line 6 define the input graph. Then, line 7 reports a quantified proposition with no object, line 8 contains a strong constraint proposition with a comparison on the variables used inside it, and line 9 reports a weak constraint expressing a maximization preference on the highest priority level. The resulting ASP encoding is reported in the following:</p>
<div class="codehilite"><pre><span></span><code>node(<span class="m">1.</span>.<span class="m">5</span>).
connected_to(<span class="m">1</span>,<span class="m">2</span>). connected_to(<span class="m">1</span>,<span class="m">3</span>).
connected_to(<span class="m">2</span>,<span class="m">1</span>). connected_to(<span class="m">2</span>,<span class="m">3</span>). connected_to(<span class="m">2</span>,<span class="m">4</span>). connected_to(<span class="m">2</span>,<span class="m">5</span>).
connected_to(<span class="m">3</span>,<span class="m">1</span>). connected_to(<span class="m">3</span>,<span class="m">2</span>). connected_to(<span class="m">3</span>,<span class="m">4</span>). connected_to(<span class="m">3</span>,<span class="m">5</span>).
connected_to(<span class="m">4</span>,<span class="m">2</span>). connected_to(<span class="m">4</span>,<span class="m">3</span>). connected_to(<span class="m">4</span>,<span class="m">5</span>).
connected_to(<span class="m">5</span>,<span class="m">2</span>). connected_to(<span class="m">5</span>,<span class="m">3</span>). connected_to(<span class="m">5</span>,<span class="m">4</span>).
<span class="k">{</span>chosen(<span class="nv">_X1</span>)<span class="k">}</span> <span class="o">:-</span> node(<span class="nv">_X1</span>).
<span class="p">:- </span><span class="err">not </span>connected_to(<span class="nv">X</span>,<span class="nv">Y</span>), chosen(<span class="nv">X</span>), chosen(<span class="nv">Y</span>), <span class="nv">X</span> <span class="o">!=</span> <span class="nv">Y</span>.
<span class="o">:</span> <span class="err">~</span> <span class="err">#</span>count<span class="k">{</span><span class="nv">_X1</span><span class="o">:</span> chosen(<span class="nv">_X1</span>)<span class="k">}</span> <span class="o">=</span> <span class="nv">_X2</span>. [<span class="o">-</span><span class="nv">_X2</span><span class="o">@</span><span class="m">1</span>]
</code></pre></div>

<p>where each CNL proposition at line $i$ is translated as the rule(s) reported at line $i$ (with $i=1 . .9)$.</p>
<h2>5 Real-world use cases</h2>
<p>In this section, we show the usage of the CNL specifications to encode three real-world problems which we previously addressed using plain ASP encodings, namely the Nurse Scheduling Problem (NSP) (Section 5.1; (Dodaro and Maratea 2017)), the Manipulation of Articulated Objects Using Dual-Arm Robots (Section 5.2; (Bertolucci et al. 2021)), and the Chemotherapy Treatment Scheduling (CTS) Problem (Section 5.3; (Dodaro et al. 2021)). Moreover, for each of the reported problem, we also show an empirical analysis comparing the performance of the encoding generated in an automatic way by CNL2ASP and the encoding written by human experts. The encodings were compared using the same solver, i.e., CLINGO version 5.6.1 configured with the same options used in the</p>
<p>original papers where the problems were presented. The experiments were executed on a AMD Ryzen 52600 with 3.4 GHz , with time and memory limits set to 1200 seconds and 8 GB , respectively. For the sake of the readability, we do not report in this section the generated encodings, which are however available in Appendix A.</p>
<h1>5.1 Nurse scheduling problem (NSP)</h1>
<p>The NSP is the problem of computing an assignment of nurses to shifts (morning, afternoon, night, or rest) in a given period of time such that the assignment satisfies a set of requirements. In particular, the NSP described in this section was originally defined by Dodaro and Maratea (2017), where authors classified the requirements as follows: (i) Hospital requirements, which impose the length of the shifts and that each shift is associated with a minimum and a maximum number of nurses that must be present in the hospital; (ii) Nurses requirements, which impose that nurses have a limit on the minimum and maximum number of working hours during the considered period of time, and that each nurse has an adequate rest period; (iii) Balance requirements, which impose that the number of times a nurse can be assigned to morning, afternoon and night shifts is fixed.</p>
<p>The first part of our CNL specifications concerns the definition of the domain and of the input facts of the NSP, and it is reported in the following:</p>
<div class="codehilite"><pre><span></span><code><span class="n">numberOfNurses</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">constant</span><span class="o">.</span>
<span class="n">A</span><span class="w"> </span><span class="n">nurse</span><span class="w"> </span><span class="n">goes</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">numberOfNurses</span><span class="o">.</span>
<span class="n">A</span><span class="w"> </span><span class="n">day</span><span class="w"> </span><span class="n">goes</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mi">365</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">made</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">shifts</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">made</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">hours</span><span class="o">.</span>
<span class="n">A</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">morning</span><span class="p">,</span><span class="w"> </span><span class="n">afternoon</span><span class="p">,</span><span class="w"> </span><span class="n">night</span><span class="p">,</span><span class="w"> </span><span class="n">specrest</span><span class="p">,</span><span class="w"> </span><span class="n">rest</span><span class="p">,</span><span class="w"> </span><span class="n">vacation</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">has</span>
<span class="w">    </span><span class="n">hours</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">equal</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">respectively</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span>
<span class="n">maxNurseMorning</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">constant</span><span class="o">.</span>
<span class="n">maxNurseAfternoon</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">constant</span><span class="o">.</span>
<span class="n">maxNurseNight</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">constant</span><span class="o">.</span>
<span class="n">minNurseMorning</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">constant</span><span class="o">.</span>
<span class="n">minNurseAfternoon</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">constant</span><span class="o">.</span>
<span class="n">minNurseNight</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">constant</span><span class="o">.</span>
<span class="n">maxHours</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">constant</span><span class="w"> </span><span class="n">equal</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mf">1692.</span>
<span class="n">minHours</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">constant</span><span class="w"> </span><span class="n">equal</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mf">1687.</span>
<span class="n">maxDay</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">constant</span><span class="w"> </span><span class="n">equal</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mf">82.</span>
<span class="n">maxNight</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">constant</span><span class="w"> </span><span class="n">equal</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mf">61.</span>
<span class="n">minDay</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">constant</span><span class="w"> </span><span class="n">equal</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mf">74.</span>
<span class="n">minNight</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">constant</span><span class="w"> </span><span class="n">equal</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mf">58.</span>
<span class="n">balanceNurseDay</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">constant</span><span class="w"> </span><span class="n">equal</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mf">78.</span>
<span class="n">balanceNurseAfternoon</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">constant</span><span class="w"> </span><span class="n">equal</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mf">78.</span>
<span class="n">balanceNurseNight</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">constant</span><span class="w"> </span><span class="n">equal</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mf">60.</span>
</code></pre></div>

<p>In the definition above, we used implicit definition propositions that therefore also create the input facts of the problem. Note that the number of nurses is a constant that is specified by the user, some constants like maxNurseMorning, maxNurseAfternoon, etc. depend on the number of nurses, therefore they are also left to the user, whereas all other constants are specific to the NSP considered, therefore they are stated.</p>
<p>Then, the second part of our CNL specifications are used for solving the problem:
Every nurse can work in exactly 1 shift for each day.</p>
<p>2 It is required that the number of nurses that work in shift $S$ for each day is at most M, where S is one of morning, afternoon, night and M is one of respectively maxNurseMorning, maxNurseAfternoon, maxNurseNight.
3 It is prohibited that the number of nurses that work in shift $S$ for each day is less than M, where S is one of morning, afternoon, night and M is one of respectively minNurseMorning, minNurseAfternoon, minNurseNight.
4 It is prohibited that the total of hours in a day where a nurse works in is more than maxHours.
5 It is prohibited that the total of hours in a day where a nurse works in is less than minHours.
6 It is prohibited that the number of days with shift vacation where a nurse works in is different from 30.
7 It is prohibited that a nurse works in shift $S$ in a day and also the next day works in a shift before $S$, where $S$ is between morning and night.
8 It is required that the number of occurrences between each 14 days with shift rest where a nurse works in is at least 2.
9 It is required that when a nurse works in shift night for 2 consecutive days then the next day works in shift specrest.
10 It is prohibited that a nurse works in a day in shift specrest and also the previous 2 consecutive days does not work in shift night.
11 It is prohibited that the number of days with shift $S$ where a nurse works in is more than M, where S is one of morning, afternoon, night and M is one of respectively maxDay, maxDay, maxNight.
12 It is prohibited that the number of days with shift $S$ where a nurse works in is less than M, where S is one of morning, afternoon, night and M is one of respectively minDay, minDay, minNight.
13 It is preferred, with high priority, that the difference in absolute value between $B$, and the number of days with shift $S$ where a nurse works in ranging between minDay and maxDay is minimized, where B is one of balanceNurseDay, balanceNurseAfternoon and $S$ is one of morning, afternoon.
14 It is preferred, with high priority, that the difference in absolute value between balanceNurseNight, and the number of days with shift night where a nurse works in ranging between minNight and maxNight is minimized.</p>
<p>Here, it is interesting to observe that the specifications first define that a nurse can work in exactly one shift for each day leaving a free choice about the shift to assign to each nurse, and then they impose some requirements on the assigned shift. Moreover, note that in general we used negative constraints (i.e., sentences starting with It is prohibited), with the exception of the ones at lines 8 and 9 since we found that this formulation is more natural.</p>
<p>Comparison of the performances. The encoding generated by the CNL specifications described before has been compared to the original one proposed by Dodaro and Maratea (2017) (referred to as Original) and with an optimized version proposed by Alviano et al. (2018) (referred to as Optimized). The experiment consists of five instances of the NSP with increasing number of nurses. Results are shown in Figure 2, where it is possible to observe that the Optimized encoding outperforms both the original and the CNL one. This result is not surprising since the Optimized encoding takes advantage of specific properties of the NSP to reduce the search space for the solver. Concerning the performance of the CNL encoding, it is possible to observe that it is approximately between 1.5 to 2 times slower than the original one. The main difference in terms of</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Fig. 2: Time comparison of the performance of the original, the optimized and the CNL encodings to solve instances of the NSP.
performance is due to the fact that CNL encoding generates aggregates for constraints at lines 9 and 10, which are less efficient in this context than the normal rules used in the original encoding. In this respect, tools for the automatic rewriting of aggregates, such as the one proposed by Dingess and Truszczynski (2020), can be helpful also in our context. However, it is worth mentioning that, even on the hardest instance, the generated encoding is able to terminate in approximately ten minutes.</p>
<h1>5.2 Manipulation of articulated objects using dual-arm robots</h1>
<p>The manipulation of articulated objects is an important task in real-world robot scenarios. Bertolucci et al. (2021) presented an ASP framework for handling the manipulation of an articulated object in a 2D workspace with the possibility of performing actions like rotating one of its link with respect to another one around their joint. The framework was composed by five modules, namely Knowledge Base, Goal Checker, Consistency Checking, Action Planner, and Motion Planner. All the modules but Motion Planner were implemented using ASP. In this section, we focus on the Action Planner as described by the encoding reported in the Figure 6 of the paper by Bertolucci et al. (2021), since it involves a number of interesting constructs, such as temporal concepts as well as the concept of angle.</p>
<p>The first part of our CNL specifications concerns the definition of the domain of the problem, and it is reported in the following:</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<ul>
<li>A rotation is identified by a first joint, by a second joint, by a desired angle, by a current angle, and by a time.</li>
<li>A goal is identified by a joint, and by an angle.</li>
<li>granularity is a constant.</li>
<li>timemax is a constant.</li>
</ul>
<p>It is possible to observe that we have the concept of time that is marked as temporal. As described in Section 3.1.2, this enables the possibility to use constructs like after, before, and so forth (as shown at line 2 of the second part of the CNL specifications). Moreover, our CNL implicitly handles the concept of angle, e.g., by ensuring that sum operations always create angles whose values are between 0 and 359 degrees.</p>
<p>The second part of the CNL specifications is instead used for solving the problem, and it is reported in the following:</p>
<p>1 Whenever there is a link with a first joint J1, and with a second joint J2, then we must have a link with a first joint J2, and with a second joint J1.
2 Whenever there is a time T that is after 0 , then we can have at most 1 rotation with a first joint J1, with a second joint J2, with a desired angle A, with a current angle AI, and with time T such that there is a joint J1, a joint J2, an angle A, a link with first joint J1, and with second joint J2, a position with joint J1, with angle AI, and with time T.
3 It is required that T is less than timemax, whenever there is a rotation with time T.
4 It is required that the first joint J1 of the rotation R is greater than the second joint J2 of the rotation R, whenever there is a rotation R with first joint J1, with second joint J2.
5 It is required that the desired angle A of the rotation R is different from the current angle AI of the rotation R, whenever there is a rotation R with desired angle A, and with current angle AI.
6 It is required that the sum between the desired angle A of the rotation R and granularity is equal to the current angle AI of the rotation R, whenever there is a rotation $R$ with desired angle $A$ greater than 0 , with current angle AI greater than A.
7 It is required that the sum between the current angle AI of the rotation R and granularity is equal to the desired angle A of the rotation R, whenever there is a rotation $R$ with current angle AI greater than 0 , with desired angle $A$ greater than AI.
8 It is required that the difference between 360 and granularity is equal to the desired angle A of the rotation R, whenever there is a rotation R with desired angle A, and with current angle equal to 0 .
9 It is required that the difference between 360 and granularity is equal to the current angle AI of the rotation R, whenever there is a rotation R with desired angle A equal to 0 , and with current angle AI.
10 Whenever there is a joint J, whenever there is a time T, then we can have a position with joint J, with angle A, and with time T to exactly 1 angle A.
11 It is required that the angle A1 of the position P1 is equal to the angle A2 of the position P2, whenever there is a position P1 with joint J, with angle A1, and with time T, whenever there is a position P2 the next step with joint J, and with angle A2, whenever there is not a rotation with time T less than or equal to timemax.
12 It is required that the angle A1 of the position $P$ is equal to the desired angle A2 of the rotation $R$, whenever there is a position $P$ with joint $J 1$, with time T, with angle A1, whenever there is a rotation R the previous step with first joint J1, and with desired angle A2.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>1 A time is a temporal concept expressed in steps ranging from 1 to 10.
2 A joint is identified by an id.
3 An angle is identified by a value.
4 A position is identified by a joint, by an angle, and by a time.
5 A link is identified by a first joint, and by a second joint.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>