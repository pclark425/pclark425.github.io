<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-3341 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-3341</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-3341</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-77.html">extraction-schema-77</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models solving puzzle games that require spatial knowledge (such as Sudoku), including details about the models, the puzzles, the methods used, performance, and any analysis of how the models solve these tasks.</div>
                <p><strong>Paper ID:</strong> paper-5f19ae1135a9500940978104ec15a5b8751bc7d2</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/5f19ae1135a9500940978104ec15a5b8751bc7d2" target="_blank">Self-Consistency Improves Chain of Thought Reasoning in Language Models</a></p>
                <p><strong>Paper Venue:</strong> International Conference on Learning Representations</p>
                <p><strong>Paper TL;DR:</strong> This paper proposes a new decoding strategy, self-consistency, to replace the naive greedy decoding used in chain-of-thought prompting that first samples a diverse set of reasoning paths instead of only taking the greedy one, and then selects the most consistent answer by marginalizing out the sampled reasoning paths.</p>
                <p><strong>Paper Abstract:</strong> Chain-of-thought prompting combined with pre-trained large language models has achieved encouraging results on complex reasoning tasks. In this paper, we propose a new decoding strategy, self-consistency, to replace the naive greedy decoding used in chain-of-thought prompting. It first samples a diverse set of reasoning paths instead of only taking the greedy one, and then selects the most consistent answer by marginalizing out the sampled reasoning paths. Self-consistency leverages the intuition that a complex reasoning problem typically admits multiple different ways of thinking leading to its unique correct answer. Our extensive empirical evaluation shows that self-consistency boosts the performance of chain-of-thought prompting with a striking margin on a range of popular arithmetic and commonsense reasoning benchmarks, including GSM8K (+17.9%), SVAMP (+11.0%), AQuA (+12.2%), StrategyQA (+6.4%) and ARC-challenge (+3.9%).</p>
                <p><strong>Cost:</strong> 0.006</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <p class="empty-note">No extracted data.</p>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <p class="empty-note">No potentially relevant new papers extracted.</p>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-3341",
    "paper_id": "paper-5f19ae1135a9500940978104ec15a5b8751bc7d2",
    "extraction_schema_id": "extraction-schema-77",
    "extracted_data": [],
    "potentially_relevant_new_papers": [],
    "cost": 0.0063592499999999995,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Self-Consistency Improves Chain of Thought REASONING in LANGUAGE MODELS</h1>
<p>Xuezhi Wang ${ }^{\dagger \ddagger}$ Jason Wei ${ }^{\dagger}$ Dale Schuurmans ${ }^{\dagger}$ Quoc Le ${ }^{\dagger}$ Ed H. Chi ${ }^{\ddagger}$<br>Sharan Narang ${ }^{\dagger}$ Aakanksha Chowdhery ${ }^{\dagger}$ Denny Zhou ${ }^{\dagger \S}$<br>${ }^{\dagger}$ Google Research, Brain Team<br>${ }^{\ddagger}$ xuezhiw@google.com, ${ }^{\S}$ dennyzhou@google.com</p>
<h2>ABSTRACT</h2>
<h4>Abstract</h4>
<p>Chain-of-thought prompting combined with pre-trained large language models has achieved encouraging results on complex reasoning tasks. In this paper, we propose a new decoding strategy, self-consistency, to replace the naive greedy decoding used in chain-of-thought prompting. It first samples a diverse set of reasoning paths instead of only taking the greedy one, and then selects the most consistent answer by marginalizing out the sampled reasoning paths. Self-consistency leverages the intuition that a complex reasoning problem typically admits multiple different ways of thinking leading to its unique correct answer. Our extensive empirical evaluation shows that self-consistency boosts the performance of chain-of-thought prompting with a striking margin on a range of popular arithmetic and commonsense reasoning benchmarks, including GSM8K (+17.9\%), SVAMP (+11.0\%), AQuA (+12.2\%), StrategyQA $(+6.4 \%)$ and ARC-challenge $(+3.9 \%)$.</p>
<h2>1 INTRODUCTION</h2>
<p>Although language models have demonstrated remarkable success across a range of NLP tasks, their ability to demonstrate reasoning is often seen as a limitation, which cannot be overcome solely by increasing model scale (Rae et al., 2021; BIG-bench collaboration, 2021, inter alia). In an effort to address this shortcoming, Wei et al. (2022) have proposed chain-of-thought prompting, where a language model is prompted to generate a series of short sentences that mimic the reasoning process a person might employ in solving a task. For example, given the question "If there are 3 cars in the parking lot and 2 more cars arrive, how many cars are in the parking lot?", instead of directly responding with " 5 ", a language model would be prompted to respond with the entire chain-of-thought: "There are 3 cars in the parking lot already. 2 more arrive. Now there are 3+ $2=5$ cars. The answer is 5.". It has been observed that chain-of-thought prompting significantly improves model performance across a variety of multi-step reasoning tasks (Wei et al., 2022).
In this paper, we introduce a novel decoding strategy called self-consistency to replace the greedy decoding strategy used in chain-of-thought prompting (Wei et al., 2022), that further improves language models' reasoning performance by a significant margin. Self-consistency leverages the intuition that complex reasoning tasks typically admit multiple reasoning paths that reach a correct answer (Stanovich \&amp; West, 2000). The more that deliberate thinking and analysis is required for a problem (Evans, 2010), the greater the diversity of reasoning paths that can recover the answer.</p>
<p>Figure 1 illustrates the self-consistency method with an example. We first prompt the language model with chain-of-thought prompting, then instead of greedily decoding the optimal reasoning path, we propose a "sample-and-marginalize" decoding procedure: we first sample from the language model's decoder to generate a diverse set of reasoning paths; each reasoning path might lead to a different final answer, so we determine the optimal answer by marginalizing out the sampled reasoning paths to find the most consistent answer in the final answer set. Such an approach is analogous to the human experience that if multiple different ways of thinking lead to the same answer, one has greater confidence that the final answer is correct. Compared to other decoding methods, self-consistency avoids the repetitiveness and local-optimality that plague greedy decoding, while mitigating the stochasticity of a single sampled generation.</p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: The self-consistency method contains three steps: (1) prompt a language model using chain-of-thought (CoT) prompting; (2) replace the "greedy decode" in CoT prompting by sampling from the language model's decoder to generate a diverse set of reasoning paths; and (3) marginalize out the reasoning paths and aggregate by choosing the most consistent answer in the final answer set.</p>
<p>Self-consistency is far simpler than prior approaches that either train an additional verifier [Cobbe et al., 2021] or train a re-ranker given additional human annotations to improve generation quality [Thoppilan et al., 2022]. Instead, self-consistency is entirely <em>unsupervised</em>, works off-the-shelf with pre-trained language models, requires no additional human annotation, and avoids any additional training, auxiliary models or fine-tuning. Self-consistency also differs from a typical ensemble approach where multiple models are trained and the outputs from each model are aggregated, it acts more like a "self-ensemble" that works on top of a <em>single</em> language model.</p>
<p>We evaluate self-consistency on a wide range of arithmetic and commonsense reasoning tasks over four language models with varying scales: the public UL2-20B [Tay et al., 2022] and GPT-3-175B [Brown et al., 2020], and two densely-activated decoder-only language models: LaMDA-137B [Thoppilan et al., 2022] and PaLM-540B [Chowdhery et al., 2022]. On all four language models, self-consistency improves over chain-of-thought prompting by a striking margin across all tasks. In particular, when used with PaLM-540B or GPT-3, self-consistency achieves new state-of-the-art levels of performance across arithmetic reasoning tasks, including GSM8K [Cobbe et al., 2021] (+17.9% absolute accuracy gains), SVAMP [Patel et al., 2021] (+11.0%), AQuA [Ling et al., 2017] (+12.2%), and across commonsense reasoning tasks such as StrategyQA [Geva et al., 2021] (+6.4%) and ARC-challenge [Clark et al., 2018] (+3.9%). In additional experiments, we show self-consistency can robustly boost performance on NLP tasks where adding a chain-of-thought might hurt performance compared to standard prompting [Ye &amp; Durrett, 2022]. We also show self-consistency significantly outperforms sample-and-rank, beam search, ensemble-based approaches, and is robust to sampling strategies and imperfect prompts.</p>
<h2>2 Self-Consistency over Diverse Reasoning Paths</h2>
<p>A salient aspect of humanity is that people think differently. It is natural to suppose that in tasks requiring deliberate thinking, there are likely several ways to attack the problem. We propose that such a process can be simulated in language models via sampling from the language model's decoder. For instance, as shown in Figure 1, a model can generate several plausible responses to a math question that all arrive at the same correct answer (Outputs 1 and 3). Since language models are not perfect reasoners, the model might also produce an incorrect reasoning path or make a mistake in one of the reasoning steps (e.g., in Output 2), but such solutions are less likely to arrive at the <em>same</em> answer. That is, we hypothesize that correct reasoning processes, even if they are diverse, tend to have greater agreement in their final answer than incorrect processes.</p>
<p>We leverage this intuition by proposing the following <em>self-consistency</em> method. First, a language model is prompted with a set of manually written chain-of-thought exemplars [Wei et al., 2022]. Next,</p>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">GSM8K</th>
<th style="text-align: center;">MultiArith</th>
<th style="text-align: center;">AQuA</th>
<th style="text-align: center;">SVAMP</th>
<th style="text-align: center;">CSQA</th>
<th style="text-align: center;">ARC-c</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Greedy decode</td>
<td style="text-align: center;">56.5</td>
<td style="text-align: center;">94.7</td>
<td style="text-align: center;">35.8</td>
<td style="text-align: center;">79.0</td>
<td style="text-align: center;">79.0</td>
<td style="text-align: center;">85.2</td>
</tr>
<tr>
<td style="text-align: center;">Weighted avg (unnormalized)</td>
<td style="text-align: center;">$56.3 \pm 0.0$</td>
<td style="text-align: center;">$90.5 \pm 0.0$</td>
<td style="text-align: center;">$35.8 \pm 0.0$</td>
<td style="text-align: center;">$73.0 \pm 0.0$</td>
<td style="text-align: center;">$74.8 \pm 0.0$</td>
<td style="text-align: center;">$82.3 \pm 0.0$</td>
</tr>
<tr>
<td style="text-align: center;">Weighted avg (normalized)</td>
<td style="text-align: center;">$22.1 \pm 0.0$</td>
<td style="text-align: center;">$59.7 \pm 0.0$</td>
<td style="text-align: center;">$15.7 \pm 0.0$</td>
<td style="text-align: center;">$40.5 \pm 0.0$</td>
<td style="text-align: center;">$52.1 \pm 0.0$</td>
<td style="text-align: center;">$51.7 \pm 0.0$</td>
</tr>
<tr>
<td style="text-align: center;">Weighted sum (unnormalized)</td>
<td style="text-align: center;">$59.9 \pm 0.0$</td>
<td style="text-align: center;">$92.2 \pm 0.0$</td>
<td style="text-align: center;">$38.2 \pm 0.0$</td>
<td style="text-align: center;">$76.2 \pm 0.0$</td>
<td style="text-align: center;">$76.2 \pm 0.0$</td>
<td style="text-align: center;">$83.5 \pm 0.0$</td>
</tr>
<tr>
<td style="text-align: center;">Weighted sum (normalized)</td>
<td style="text-align: center;">$74.1 \pm 0.0$</td>
<td style="text-align: center;">$99.3 \pm 0.0$</td>
<td style="text-align: center;">$48.0 \pm 0.0$</td>
<td style="text-align: center;">$86.8 \pm 0.0$</td>
<td style="text-align: center;">$80.7 \pm 0.0$</td>
<td style="text-align: center;">$88.7 \pm 0.0$</td>
</tr>
<tr>
<td style="text-align: center;">Unweighted sum (majority vote)</td>
<td style="text-align: center;">$74.4 \pm 0.1$</td>
<td style="text-align: center;">$99.3 \pm 0.0$</td>
<td style="text-align: center;">$48.3 \pm 0.5$</td>
<td style="text-align: center;">$86.6 \pm 0.1$</td>
<td style="text-align: center;">$80.7 \pm 0.1$</td>
<td style="text-align: center;">$88.7 \pm 0.1$</td>
</tr>
</tbody>
</table>
<p>Table 1: Accuracy comparison of different answer aggregation strategies on PaLM-540B.
we sample a set of candidate outputs from the language model's decoder, generating a diverse set of candidate reasoning paths. Self-consistency is compatible with most existing sampling algorithms, including temperature sampling (Ackley et al., 1985; Ficler \&amp; Goldberg, 2017), top- $k$ sampling (Fan et al., 2018; Holtzman et al., 2018; Radford et al., 2019), and nucleus sampling (Holtzman et al., 2020). Finally, we aggregate the answers by marginalizing out the sampled reasoning paths and choosing the answer that is the most consistent among the generated answers.</p>
<p>In more detail, assume the generated answers $\mathbf{a}<em i="i">{i}$ are from a fixed answer set, $\mathbf{a}</em>} \in \mathbb{A}$, where $i=1, \ldots, m$ indexes the $m$ candidate outputs sampled from the decoder. Given a prompt and a question, self-consistency introduces an additional latent variable $\mathbf{r<em i="i">{i}$, which is a sequence of tokens representing the reasoning path in the $i$-th output, then couples the generation of $\left(\mathbf{r}</em>}, \mathbf{a<em i="i">{i}\right)$ where $\mathbf{r}</em>} \rightarrow \mathbf{a<em i="i">{i}$, i.e., generating a reasoning path $\mathbf{r}</em>}$ is optional and only used to reach the final answer $\mathbf{a<em i="i">{i}$. As an example, consider Output 3 from Figure 1: the first few sentences "She eats 3 for breakfast ... So she has 9 eggs * $\$ 2=\$ 18$." constitutes $\mathbf{r}</em>}$, while the answer 18 from the last sentence, "The answer is $\$ 18$ ", is parsed as $\mathbf{a<em i="i">{i} .{ }^{1}$ After sampling multiple $\left(\mathbf{r}</em>}, \mathbf{a<em i="i">{i}\right)$ from the model's decoder, self-consistency applies a marginalization over $\mathbf{r}</em>}$ by taking a majority vote over $\mathbf{a<em a="a">{i}$, i.e., $\arg \max </em>=a\right)$, or as we defined as the most "consistent" answer among the final answer set.} \sum_{i=1}^{m} \mathbb{1}\left(\mathbf{a}_{i</p>
<p>In Table 1, we show the test accuracy over a set of reasoning tasks by using different answer aggregation strategies. In addition to majority vote, one can also weight each $\left(\mathbf{r}<em i="i">{i}, \mathbf{a}</em>}\right)$ by $P\left(\mathbf{r<em i="i">{i}, \mathbf{a}</em>} \mid\right.$ prompt, question) when aggregating the answers. Note to compute $P\left(\mathbf{r<em i="i">{i}, \mathbf{a}</em>} \mid\right.$ prompt, question), we can either take the unnormalized probability of the model generating $\left(\mathbf{r<em i="i">{i}, \mathbf{a}</em>\right)$ given (prompt, question), or we can normalize the conditional probability by the output length (Brown et al., 2020), i.e.,</p>
<p>$$
P\left(\mathbf{r}<em i="i">{i}, \mathbf{a}</em>\right)
$$} \mid \text { prompt, question }\right)=\exp \frac{1}{K} \sum_{k=1}^{K} \log P\left(t_{k} \mid \text { prompt, question, } t_{1}, \ldots, t_{k-1</p>
<p>where $\log P\left(t_{k} \mid\right.$ prompt, question, $\left.t_{1}, \ldots, t_{k-1}\right)$ is the log probability of generating the $k$-th token $t_{k}$ in $\left(\mathbf{r}<em i="i">{i}, \mathbf{a}</em>}\right)$ conditioned on the previous tokens, and $K$ is the total number of tokens in $\left(\mathbf{r<em i="i">{i}, \mathbf{a}</em>}\right)$. In Table 1, we show that taking the "unweighted sum", i.e., taking a majority vote directly over $\mathbf{a<em i="i">{i}$ yields a very similar accuracy as aggregating using the "normalized weighted sum". We took a closer look at the model's output probabilities and found this is because for each $\left(\mathbf{r}</em>}, \mathbf{a<em i="i">{i}\right)$, the normalized conditional probabilities $P\left(\mathbf{r}</em>}, \mathbf{a<em i="1">{i} \mid\right.$ prompt, question) are quite close to each other, i.e., the language model regards those generations as "similarly likely". ${ }^{2}$ Additionally, when aggregating the answers, the results in Table 1 show that the "normalized" weighted sum (i.e., Equation 1) yields a much higher accuracy compared to its unnormalized counterpart. For completeness, in Table 1 we also report the results by taking a "weighted average", i.e., each $a$ gets a score of its weighted sum divided by $\sum</em>=a\right)$, which results in a much worse performance.}^{m} \mathbb{1}\left(\mathbf{a}_{i</p>
<p>Self-consistency explores an interesting space between open-ended text generation and optimal text generation with a fixed answer. Reasoning tasks typically have fixed answers, which is why researchers have generally considered greedy decoding approaches (Radford et al., 2019; Wei et al., 2022; Chowdhery et al., 2022). However, we have found that even when the desired answer is fixed, introducing diversity in the reasoning processes can be highly beneficial; therefore we leverage</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>sampling, as commonly used for open-ended text generation (Radford et al., 2019; Brown et al., 2020; Thoppilan et al., 2022), to achieve this goal. One should note that self-consistency can be applied only to problems where the final answer is from a fixed answer set, but in principle this approach can be extended to open-text generation problems if a good metric of consistency can be defined between multiple generations, e.g., whether two answers agree or contradict each other.</p>
<h1>3 EXPERIMENTS</h1>
<p>We conducted a series of experiments to compare the proposed self-consistency method with existing approaches on a range of reasoning benchmarks. We find that self-consistency robustly improves reasoning accuracy for every language model considered, spanning a wide range of model scales.</p>
<h3>3.1 EXPERIMENT SETUP</h3>
<p>Tasks and datasets. We evaluate self-consistency on the following reasoning benchmarks. ${ }^{3}$</p>
<ul>
<li>Arithmetic reasoning. For these tasks, we used the Math Word Problem Repository (KoncelKedziorski et al., 2016), including AddSub (Hosseini et al., 2014), MultiArith (Roy \&amp; Roth, 2015), and ASDiv (Miao et al., 2020). We also included AQUA-RAT (Ling et al., 2017), a recently published benchmark of grade-school-math problems (GSM8K; Cobbe et al., 2021), and a challenge dataset over math word problems (SVAMP; Patel et al., 2021).</li>
<li>Commonsense reasoning. For these tasks, we used CommonsenseQA (Talmor et al., 2019), StrategyQA (Geva et al., 2021), and the AI2 Reasoning Challenge (ARC) (Clark et al., 2018).</li>
<li>Symbolic Reasoning. We evaluate two symbolic reasoning tasks: last letter concatenation (e.g., the input is "Elon Musk" and the output should be "nk"), and Coinflip (e.g., a coin is heads-up, after a few flips is the coin still heads-up?) from Wei et al. (2022).</li>
</ul>
<p>Language models and prompts. We evaluate self-consistency over four transformer-based language models with varying scales:</p>
<ul>
<li>UL2 (Tay et al., 2022) is an encoder-decoder model trained on a mixture of denoisers with 20billion parameters. UL2 is completely open-sourced ${ }^{4}$ and has similar or better performance than GPT-3 on zero-shot SuperGLUE, with only 20B parameters and thus is more compute-friendly;</li>
<li>GPT-3 (Brown et al., 2020) with 175-billion parameters. We use two public engines code-davinci001 and code-davinci-002 from the Codex series (Chen et al., 2021) to aid reproducibility; ${ }^{5}$</li>
<li>LaMDA-137B (Thoppilan et al., 2022) is a dense left-to-right, decoder-only language model with 137-billion parameters, pre-trained on a mixture of web documents, dialog data and Wikipedia;</li>
<li>PaLM-540B (Chowdhery et al., 2022) is a dense left-to-right, decoder-only language model with 540-billion parameters, pre-trained on a high quality corpus of 780 billion tokens with filtered webpages, books, Wikipedia, news articles, source code, and social media conversations.
We perform all experiments in the few-shot setting, without training or fine-tuning the language models. For a fair comparison we use the same prompts as in Wei et al. (2022): for all arithmetic reasoning tasks we use the same set of 8 manually written exemplars; for each commonsense reasoning task, 4-7 exemplars are randomly chosen from the training set with manually composed chain-of-thought prompts. ${ }^{6}$ Full details on the prompts used are given in Appendix A.3.
Sampling scheme. To sample diverse reasoning paths, we followed similar settings to those suggested in Radford et al. (2019); Holtzman et al. (2020) for open-text generation. In particular, for UL2-20B and LaMDA-137B we applied temperature sampling with $T=0.5$ and truncated at the top- $k(k=40)$ tokens with the highest probability, for PaLM-540B we applied $T=0.7, k=40$, and for GPT-3 we use $T=0.7$ without top- $k$ truncation. We provide an ablation study in Section 3.5 to show that self-consistency is generally robust to sampling strategies and parameters.</li>
</ul>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;">Method</th>
<th style="text-align: left;">AddSub</th>
<th style="text-align: left;">MultiArith</th>
<th style="text-align: left;">ASDiv</th>
<th style="text-align: left;">AQuA</th>
<th style="text-align: left;">SVAMP</th>
<th style="text-align: left;">GSM8K</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">Previous SoTA</td>
<td style="text-align: left;">$\mathbf{9 4 . 9}^{\mathrm{a}}$</td>
<td style="text-align: left;">$60.5^{a}$</td>
<td style="text-align: left;">$75.3^{b}$</td>
<td style="text-align: left;">$37.9^{c}$</td>
<td style="text-align: left;">$57.4^{d}$</td>
<td style="text-align: left;">$35^{e} / 55^{g}$</td>
</tr>
<tr>
<td style="text-align: left;">UL2-20B</td>
<td style="text-align: left;">CoT-prompting</td>
<td style="text-align: left;">18.2</td>
<td style="text-align: left;">10.7</td>
<td style="text-align: left;">16.9</td>
<td style="text-align: left;">23.6</td>
<td style="text-align: left;">12.6</td>
<td style="text-align: left;">4.1</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">Self-consistency</td>
<td style="text-align: left;">$24.8(+6.6)$</td>
<td style="text-align: left;">$15.0(+4.3)$</td>
<td style="text-align: left;">$21.5(+4.6)$</td>
<td style="text-align: left;">$26.9(+3.3)$</td>
<td style="text-align: left;">$19.4(+6.8)$</td>
<td style="text-align: left;">$7.3(+3.2)$</td>
</tr>
<tr>
<td style="text-align: left;">LaMDA-137B</td>
<td style="text-align: left;">CoT-prompting</td>
<td style="text-align: left;">52.9</td>
<td style="text-align: left;">51.8</td>
<td style="text-align: left;">49.0</td>
<td style="text-align: left;">17.7</td>
<td style="text-align: left;">38.9</td>
<td style="text-align: left;">17.1</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">Self-consistency</td>
<td style="text-align: left;">$63.5(+10.6)$</td>
<td style="text-align: left;">$75.7(+23.9)$</td>
<td style="text-align: left;">$58.2(+9.2)$</td>
<td style="text-align: left;">$26.8(+9.1)$</td>
<td style="text-align: left;">$53.3(+14.4)$</td>
<td style="text-align: left;">$27.7(+10.6)$</td>
</tr>
<tr>
<td style="text-align: left;">PaLM-540B</td>
<td style="text-align: left;">CoT-prompting</td>
<td style="text-align: left;">91.9</td>
<td style="text-align: left;">94.7</td>
<td style="text-align: left;">74.0</td>
<td style="text-align: left;">35.8</td>
<td style="text-align: left;">79.0</td>
<td style="text-align: left;">56.5</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">Self-consistency</td>
<td style="text-align: left;">$93.7(+1.8)$</td>
<td style="text-align: left;">$99.3(+4.6)$</td>
<td style="text-align: left;">$81.9(+7.9)$</td>
<td style="text-align: left;">$48.3(+12.5)$</td>
<td style="text-align: left;">$86.6(+7.6)$</td>
<td style="text-align: left;">$74.4(+17.9)$</td>
</tr>
<tr>
<td style="text-align: left;">GPT-3</td>
<td style="text-align: left;">CoT-prompting</td>
<td style="text-align: left;">57.2</td>
<td style="text-align: left;">59.5</td>
<td style="text-align: left;">52.7</td>
<td style="text-align: left;">18.9</td>
<td style="text-align: left;">39.8</td>
<td style="text-align: left;">14.6</td>
</tr>
<tr>
<td style="text-align: left;">Code-davinci-001</td>
<td style="text-align: left;">Self-consistency</td>
<td style="text-align: left;">$67.8(+10.6)$</td>
<td style="text-align: left;">$82.7(+23.2)$</td>
<td style="text-align: left;">$61.9(+9.2)$</td>
<td style="text-align: left;">$25.6(+6.7)$</td>
<td style="text-align: left;">$54.5(+14.7)$</td>
<td style="text-align: left;">$23.4(+8.8)$</td>
</tr>
<tr>
<td style="text-align: left;">GPT-3</td>
<td style="text-align: left;">CoT-prompting</td>
<td style="text-align: left;">89.4</td>
<td style="text-align: left;">96.2</td>
<td style="text-align: left;">80.1</td>
<td style="text-align: left;">39.8</td>
<td style="text-align: left;">75.8</td>
<td style="text-align: left;">60.1</td>
</tr>
<tr>
<td style="text-align: left;">Code-davinci-002</td>
<td style="text-align: left;">Self-consistency</td>
<td style="text-align: left;">$91.6(+2.2)$</td>
<td style="text-align: left;">$\mathbf{1 0 0 . 0}(+3.8)$</td>
<td style="text-align: left;">$\mathbf{8 7 . 8}(+7.6)$</td>
<td style="text-align: left;">$\mathbf{5 2 . 0}(+12.2)$</td>
<td style="text-align: left;">$\mathbf{8 6 . 8}(+11.0)$</td>
<td style="text-align: left;">$\mathbf{7 8 . 0}(+17.9)$</td>
</tr>
</tbody>
</table>
<p>Table 2: Arithmetic reasoning accuracy by self-consistency compared to chain-of-thought prompting (Wei et al., 2022). The previous SoTA baselines are obtained from: $a$ : Relevance and LCA operation classifier (Roy \&amp; Roth, 2015), b: Lan et al. (2021), c: Amini et al. (2019), d: Pi et al. (2022), $e$ : GPT-3 175B finetuned with 7.5 k examples (Cobbe et al., 2021), $g$ : GPT-3 175B finetuned plus an additional 175B verifier (Cobbe et al., 2021). The best performance for each task is shown in bold.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;">Method</th>
<th style="text-align: left;">CSQA</th>
<th style="text-align: left;">StrategyQA</th>
<th style="text-align: left;">ARC-e</th>
<th style="text-align: left;">ARC-c</th>
<th style="text-align: left;">Letter (4)</th>
<th style="text-align: left;">Coinflip (4)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">Previous SoTA</td>
<td style="text-align: left;">$\mathbf{9 1 . 2}^{\mathrm{a}}$</td>
<td style="text-align: left;">$73.9^{b}$</td>
<td style="text-align: left;">$86.4^{c}$</td>
<td style="text-align: left;">$75.0^{c}$</td>
<td style="text-align: left;">N/A</td>
<td style="text-align: left;">N/A</td>
</tr>
<tr>
<td style="text-align: left;">UL2-20B</td>
<td style="text-align: left;">CoT-prompting</td>
<td style="text-align: left;">51.4</td>
<td style="text-align: left;">53.3</td>
<td style="text-align: left;">61.6</td>
<td style="text-align: left;">42.9</td>
<td style="text-align: left;">0.0</td>
<td style="text-align: left;">50.4</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">Self-consistency</td>
<td style="text-align: left;">$55.7(+4.3)$</td>
<td style="text-align: left;">$54.9(+1.6)$</td>
<td style="text-align: left;">$69.8(+8.2)$</td>
<td style="text-align: left;">$49.5(+6.8)$</td>
<td style="text-align: left;">$0.0(+0.0)$</td>
<td style="text-align: left;">$50.5(+0.1)$</td>
</tr>
<tr>
<td style="text-align: left;">LaMDA-137B</td>
<td style="text-align: left;">CoT-prompting</td>
<td style="text-align: left;">57.9</td>
<td style="text-align: left;">65.4</td>
<td style="text-align: left;">75.3</td>
<td style="text-align: left;">55.1</td>
<td style="text-align: left;">8.2</td>
<td style="text-align: left;">72.4</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">Self-consistency</td>
<td style="text-align: left;">$63.1(+5.2)$</td>
<td style="text-align: left;">$67.8(+2.4)$</td>
<td style="text-align: left;">$79.3(+4.0)$</td>
<td style="text-align: left;">$59.8(+4.7)$</td>
<td style="text-align: left;">$8.2(+0.0)$</td>
<td style="text-align: left;">$73.5(+1.1)$</td>
</tr>
<tr>
<td style="text-align: left;">PaLM-540B</td>
<td style="text-align: left;">CoT-prompting</td>
<td style="text-align: left;">79.0</td>
<td style="text-align: left;">75.3</td>
<td style="text-align: left;">95.3</td>
<td style="text-align: left;">85.2</td>
<td style="text-align: left;">65.8</td>
<td style="text-align: left;">88.2</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">Self-consistency</td>
<td style="text-align: left;">$80.7(+1.7)$</td>
<td style="text-align: left;">$\mathbf{8 1 . 6}(+6.3)$</td>
<td style="text-align: left;">$\mathbf{9 6 . 4}(+1.1)$</td>
<td style="text-align: left;">$\mathbf{8 8 . 7}(+3.5)$</td>
<td style="text-align: left;">$70.8(+5.0)$</td>
<td style="text-align: left;">$91.2(+3.0)$</td>
</tr>
<tr>
<td style="text-align: left;">GPT-3</td>
<td style="text-align: left;">CoT-prompting</td>
<td style="text-align: left;">46.6</td>
<td style="text-align: left;">56.7</td>
<td style="text-align: left;">63.1</td>
<td style="text-align: left;">43.1</td>
<td style="text-align: left;">7.8</td>
<td style="text-align: left;">71.4</td>
</tr>
<tr>
<td style="text-align: left;">Code-davinci-001</td>
<td style="text-align: left;">Self-consistency</td>
<td style="text-align: left;">$54.9(+8.3)$</td>
<td style="text-align: left;">$61.7(+5.0)$</td>
<td style="text-align: left;">$72.1(+9.0)$</td>
<td style="text-align: left;">$53.7(+10.6)$</td>
<td style="text-align: left;">$10.0(+2.2)$</td>
<td style="text-align: left;">$75.9(+4.5)$</td>
</tr>
<tr>
<td style="text-align: left;">GPT-3</td>
<td style="text-align: left;">CoT-prompting</td>
<td style="text-align: left;">79.0</td>
<td style="text-align: left;">73.4</td>
<td style="text-align: left;">94.0</td>
<td style="text-align: left;">83.6</td>
<td style="text-align: left;">70.4</td>
<td style="text-align: left;">99.0</td>
</tr>
<tr>
<td style="text-align: left;">Code-davinci-002</td>
<td style="text-align: left;">Self-consistency</td>
<td style="text-align: left;">$81.5(+2.5)$</td>
<td style="text-align: left;">$79.8(+6.4)$</td>
<td style="text-align: left;">$96.0(+2.0)$</td>
<td style="text-align: left;">$87.5(+3.9)$</td>
<td style="text-align: left;">$\mathbf{7 3 . 4}(+3.0)$</td>
<td style="text-align: left;">$\mathbf{9 9 . 5}(+0.5)$</td>
</tr>
</tbody>
</table>
<p>Table 3: Commonsense and symbolic reasoning accuracy by self-consistency compared to chain-of-thought prompting (Wei et al., 2022). The previous SoTA baselines are obtained from: $a$ : DeBERTaV3-large + KEAR (Xu et al., 2021b), b: Chowdhery et al. (2022), c: UnifiedQA-FT (Khashabi et al., 2020). The best performance for each task is shown in bold.</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<table>
<thead>
<tr>
<th></th>
<th>GSM8K</th>
<th>StrategyQA</th>
</tr>
</thead>
<tbody>
<tr>
<td>Question</td>
<td>Henry made two stops during his 60-mile bike trip. He first stopped after 20 miles. His second stop was 15 miles before the end of the trip. How many miles did he travel between his first and second stops?</td>
<td>Yes or no: Is Albany, Georgia the most populous US Albany?</td>
</tr>
<tr>
<td>Greedy Decode</td>
<td>He traveled 60 miles in total. He stopped after 20 miles, so he traveled $60-20$ $=40$ miles between the first and second stops. The answer is 40 .</td>
<td>Albany, Georgia is the most populous US Albany. Thus, the answer is yes.</td>
</tr>
<tr>
<td>Sampled Path 1</td>
<td>Henry travelled a total of 60 miles. His first stop was 20 miles in, and his second stop was 15 miles before the end. So between his first and second stops he travelled $60-20-15=25$ miles. The answer is 25 .</td>
<td>The most populous US Albany is Albany, New York. Thus, Albany, Georgia is not the most populous US Albany. So the answer is no.</td>
</tr>
<tr>
<td>Sampled Path 2</td>
<td>He made two stops during a 60-mile trip. The first was 20 miles into the trip. The second was 15 miles before the end of the trip. This means the second stop was $60-15=45$ miles into the trip. Since he made the stops in order, the second stop must have been $45-20=25$ miles after the first stop. The answer is 25 .</td>
<td>Albany, Georgia has a population of about 88,000. Albany, New York has a population of about 95,000. Thus, Albany, Georgia is not the most populous US Albany. So the answer is no.</td>
</tr>
</tbody>
</table>
<p>Table 4: Examples where self-consistency helps repair the errors over greedy decode, on PaLM-540B. Two sampled reasoning paths that are consistent with the ground truth are shown.</p>
<h1>3.3 Self-Consistency Helps When Chain-of-Thought Hurts Performance</h1>
<p>Ye \&amp; Durrett (2022) show that sometimes chain-of-thought prompting could hurt performance compared to standard prompting in few-shot in-context learning. Here we perform a study using self-consistency to see if it can help fill in the gap, over a set of common NLP tasks, including (1) Closed-Book Question Answering: BoolQ (Clark et al., 2019), HotpotQA (Yang et al., 2018), and (2) Natural Language Inference: e-SNLI (Camburu et al., 2018), ANLI (Nie et al., 2020) and RTE (Dagan et al., 2005; Bar-Haim et al., 2006; Giampiccolo et al., 2007; Bentivogli et al., 2009).</p>
<p>The results over PaLM-540B are shown in Table 5. For some tasks (e.g., ANLI-R1, e-SNLI, RTE), adding chain-of-thought does hurt performance compared to standard prompting (Brown et al., 2020), but self-consistency is able to robustly boost the performance and outperform standard prompting, making it a reliable way to add rationales in few-shot in-context learning for common NLP tasks.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;">ANLI R1 / R2 / R3</th>
<th style="text-align: left;">e-SNLI</th>
<th style="text-align: left;">RTE</th>
<th style="text-align: left;">BoolQ</th>
<th style="text-align: left;">HotpotQA (EM/F1)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Standard-prompting (no-rationale)</td>
<td style="text-align: left;">$69.1 / 55.8 / 55.8$</td>
<td style="text-align: left;">85.8</td>
<td style="text-align: left;">84.8</td>
<td style="text-align: left;">71.3</td>
<td style="text-align: left;">$27.1 / 36.8$</td>
</tr>
<tr>
<td style="text-align: left;">CoT-prompting (Wei et al., 2022)</td>
<td style="text-align: left;">$68.8 / 58.9 / 60.6$</td>
<td style="text-align: left;">81.0</td>
<td style="text-align: left;">79.1</td>
<td style="text-align: left;">74.2</td>
<td style="text-align: left;">$28.9 / 39.8$</td>
</tr>
<tr>
<td style="text-align: left;">Self-consistency</td>
<td style="text-align: left;">$\mathbf{7 8 . 5 / 6 4 . 5 / 6 3 . 4}$</td>
<td style="text-align: left;">$\mathbf{8 8 . 4}$</td>
<td style="text-align: left;">$\mathbf{8 6 . 3}$</td>
<td style="text-align: left;">$\mathbf{7 8 . 4}$</td>
<td style="text-align: left;">$\mathbf{3 3 . 8 / 4 4 . 6}$</td>
</tr>
</tbody>
</table>
<p>Table 5: Compare Standard/CoT prompting with self-consistency on common NLP tasks.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">Beam size / Self-consistency paths</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">10</th>
<th style="text-align: center;">20</th>
<th style="text-align: center;">40</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">AQuA</td>
<td style="text-align: center;">Beam search decoding (top beam)</td>
<td style="text-align: center;">23.6</td>
<td style="text-align: center;">19.3</td>
<td style="text-align: center;">16.1</td>
<td style="text-align: center;">15.0</td>
<td style="text-align: center;">10.2</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Self-consistency using beam search</td>
<td style="text-align: center;">23.6</td>
<td style="text-align: center;">$19.8 \pm 0.3$</td>
<td style="text-align: center;">$21.2 \pm 0.7$</td>
<td style="text-align: center;">$24.6 \pm 0.4$</td>
<td style="text-align: center;">$24.2 \pm 0.5$</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Self-consistency using sampling</td>
<td style="text-align: center;">$19.7 \pm 2.5$</td>
<td style="text-align: center;">$24.9 \pm 2.6$</td>
<td style="text-align: center;">$25.3 \pm 1.8$</td>
<td style="text-align: center;">$26.7 \pm 1.0$</td>
<td style="text-align: center;">$26.9 \pm 0.5$</td>
</tr>
<tr>
<td style="text-align: center;">MultiArith</td>
<td style="text-align: center;">Beam search decoding (top beam)</td>
<td style="text-align: center;">10.7</td>
<td style="text-align: center;">12.0</td>
<td style="text-align: center;">11.3</td>
<td style="text-align: center;">11.0</td>
<td style="text-align: center;">10.5</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Self-consistency using beam search</td>
<td style="text-align: center;">10.7</td>
<td style="text-align: center;">$11.8 \pm 0.0$</td>
<td style="text-align: center;">$11.4 \pm 0.1$</td>
<td style="text-align: center;">$12.3 \pm 0.1$</td>
<td style="text-align: center;">$10.8 \pm 0.1$</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Self-consistency using sampling</td>
<td style="text-align: center;">$9.5 \pm 1.2$</td>
<td style="text-align: center;">$11.3 \pm 1.2$</td>
<td style="text-align: center;">$12.3 \pm 0.8$</td>
<td style="text-align: center;">$13.7 \pm 0.9$</td>
<td style="text-align: center;">$14.7 \pm 0.3$</td>
</tr>
</tbody>
</table>
<p>Table 6: Compare self-consistency with beam search decoding on the UL2-20B model.
Comparison to Ensemble-based Approaches We further compare self-consistency to ensemblebased methods for few-shot learning. In particular, we consider ensembling by: (1) prompt order permutation: we randomly permute the exemplars in the prompt 40 times to mitigate model's sensitivity to prompt order (Zhao et al., 2021; Lu et al., 2021); and (2) multiple sets of prompts (Gao et al., 2021): we manually write 3 different sets of prompts. We took majority vote of the answers from greedy decoding in both approaches as an ensemble. Table 7 shows that compared to self-consistency, existing ensemble-based approaches achieve a much smaller gain. ${ }^{8}$ In addition, note that self-consistency is different from a typical model-ensemble approach, where multiple models are trained and their outputs are aggregated. Self-consistency acts more like a "self-ensemble" on top of a single language model. We additionally show the results of ensembling multiple models in Appendix A.1.3 where the model-ensembles perform much worse compared to self-consistency.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;">GSM8K</th>
<th style="text-align: center;">MultiArith</th>
<th style="text-align: center;">SVAMP</th>
<th style="text-align: center;">ARC-e</th>
<th style="text-align: center;">ARC-c</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">CoT (Wei et al., 2022)</td>
<td style="text-align: left;">17.1</td>
<td style="text-align: center;">51.8</td>
<td style="text-align: center;">38.9</td>
<td style="text-align: center;">75.3</td>
<td style="text-align: center;">55.1</td>
</tr>
<tr>
<td style="text-align: left;">Ensemble (3 sets of prompts)</td>
<td style="text-align: left;">$18.6 \pm 0.5$</td>
<td style="text-align: center;">$57.1 \pm 0.7$</td>
<td style="text-align: center;">$42.1 \pm 0.6$</td>
<td style="text-align: center;">$76.6 \pm 0.1$</td>
<td style="text-align: center;">$57.0 \pm 0.2$</td>
</tr>
<tr>
<td style="text-align: left;">Ensemble (40 prompt permutations)</td>
<td style="text-align: left;">$19.2 \pm 0.1$</td>
<td style="text-align: center;">$60.9 \pm 0.2$</td>
<td style="text-align: center;">$42.7 \pm 0.1$</td>
<td style="text-align: center;">$76.9 \pm 0.1$</td>
<td style="text-align: center;">$57.0 \pm 0.1$</td>
</tr>
<tr>
<td style="text-align: left;">Self-Consistency (40 sampled paths)</td>
<td style="text-align: left;">$\mathbf{2 7 . 7} \pm \mathbf{0 . 2}$</td>
<td style="text-align: center;">$\mathbf{7 5 . 7} \pm \mathbf{0 . 3}$</td>
<td style="text-align: center;">$\mathbf{5 3 . 3} \pm \mathbf{0 . 2}$</td>
<td style="text-align: center;">$\mathbf{7 9 . 3} \pm \mathbf{0 . 3}$</td>
<td style="text-align: center;">$\mathbf{5 9 . 8} \pm \mathbf{0 . 2}$</td>
</tr>
</tbody>
</table>
<p>Table 7: Self-consistency outperforms prompt-order and multi-prompt ensembles on LaMDA-137B.</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<h3>3.5 Additional Studies</h3>
<p>We conducted a number of additional experiments to analyze different aspects of the self-consistency method, including its robustness to sampling strategies and parameters, and how it works with imperfect prompts and non-natural-language reasoning paths.</p>
<p>Self-Consistency is Robust to Sampling Strategies and Scaling We show self-consistency is robust to sampling strategies and parameters, by varying $T$ in temperature sampling (Ackley et al., 1985; Ficler \&amp; Goldberg, 2017), $k$ in top- $k$ sampling (Fan et al., 2018; Holtzman et al., 2018; Radford et al., 2019), and $p$ in nucleus sampling (Holtzman et al., 2020), over PaLM-540B in Figure 4 (left). Figure 4 (right) shows that self-consistency robustly improves performance across all scales for the LaMDA-137B model series. The gain is relatively lower for smaller models due to certain abilities (e.g., arithmetic) only emerge when the model reaches a sufficient scale (Brown et al., 2020).
<img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 4: GSM8K accuracy. (Left) Self-consistency is robust to various sampling strategies and parameters. (Right) Self-consistency improves performance across language model scales.</p>
<p>Self-Consistency Improves Robustness to Imperfect Prompts For few-shot learning with manually constructed prompts, human annotators sometimes make minor mistakes when creating the prompts. We further study if self-consistency can help improve a language model's robustness to imperfect prompts. ${ }^{9}$ We show the results in Table 8: while imperfect prompts decrease accuracy with greedy decoding ( $17.1 \rightarrow 14.9$ ), self-consistency can fill in the gaps and robustly improve the results.</p>
<p>Additionally, we found that the consistency (in terms of \% of decodes agreeing with the final aggregated answer) is highly correlated with accuracy (Figure 5, over GSM8K). This suggests that one can use self-consistency to provide an uncertainty estimate of the model in its generated solutions. In other words, one can use low consistency as an indicator that the model has low confidence; i.e., self-consistency confers some ability for the model to "know when it doesn't know".</p>
<table>
<thead>
<tr>
<th style="text-align: center;">LaMDA-137B</th>
<th style="text-align: center;">Prompt with correct chain-of-thought</th>
<th style="text-align: center;">17.1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Prompt with imperfect chain-of-thought <br> + Self-consistency (40 paths)</td>
<td style="text-align: center;">$\begin{aligned} &amp; 14.9 \ &amp; 23.4 \end{aligned}$</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Prompt with equations <br> + Self-consistency (40 paths)</td>
<td style="text-align: center;">$\begin{aligned} &amp; 5.0 \ &amp; 6.5 \end{aligned}$</td>
</tr>
<tr>
<td style="text-align: center;">PaLM-540B</td>
<td style="text-align: center;">Zero-shot CoT (Kojima et al., 2022) <br> + Self-consistency (40 paths)</td>
<td style="text-align: center;">$\begin{aligned} &amp; 43.0 \ &amp; 69.2 \end{aligned}$</td>
</tr>
</tbody>
</table>
<p>Table 8: Self-consistency works under imperfect prompts, equation prompts and zero-shot chain-of-thought for GSM8K.
<img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 5: The consistency is correlated with model's accuracy.</p>
<p>Self-Consistency Works for Non-Natural-Language Reasoning Paths and Zero-shot CoT We also tested the generality of the self-consistency concept to alternative forms of intermediate reasoning like equations (e.g., from "There are 3 cars in the parking lot already. 2 more arrive. Now there are $3+2=5$ cars." to " $3+2=5$ "). The results are shown in Table 8 ("Prompt with equations"): self-consistency still improves accuracy by generating intermediate equations; however, compared to generating natural language reasoning paths, the gain is smaller since the equations are much shorter and less opportunity remains for generating diversity in the decoding process. In addition, we tested self-consistency with zero-shot chain-of-thought (Kojima et al., 2022) and show that self-consistency works for zero-shot CoT as well and improves the results significantly ( $+26.2 \%$ ) in Table 8.</p>
<p><sup id="fnref5:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<h1>4 Related Work</h1>
<p>Reasoning in language models. Language models are known to struggle in Type 2 tasks, such as arithmetic, logical and commonsense reasoning (Evans, 2010). Previous work has primarily focused on specialized approaches for improving reasoning (Andor et al., 2019; Ran et al., 2019; Geva et al., 2020; PiÄ™kos et al., 2021). Compared to prior work, self-consistency is applicable to a wide range of reasoning tasks without any additional supervision or fine-tuning, while still substantially improving the performance of the chain-of-thought prompting approach proposed in Wei et al. (2022).
Sampling and re-ranking in language models. Multiple decoding strategies for language models have been proposed in the literature, e.g., temperature sampling (Ackley et al., 1985; Ficler \&amp; Goldberg, 2017), top- $k$ sampling (Fan et al., 2018; Holtzman et al., 2018; Radford et al., 2019), nucleus sampling (Holtzman et al., 2020), minimum Bayes risk decoding (Eikema \&amp; Aziz, 2020; Shi et al., 2022), and typical decoding (Meister et al., 2022). Other work has sought to explicitly promote diversity in the decoding process (Batra et al., 2012; Li et al., 2016; Vijayakumar et al., 2018).
Re-ranking is another common approach to improve generation quality in language models (Adiwardana et al., 2020; Shen et al., 2021). Thoppilan et al. (2022) collect additional human annotations to train a re-ranker for response filtering. Cobbe et al. (2021) train a "verifier" to re-rank generated solutions, which substantially improves the solve rate on math tasks compared to just fine-tuning the language model. Elazar et al. (2021) improve the consistency of factual knowledge extraction by extending pre-training with an additional consistency loss. All these methods require either training an additional re-ranker or collecting additional human annotation, while self-consistency requires no additional training, fine-tuning, nor extra data collection.
Extract reasoning paths. Some previous work has considered task-specific approaches for identifying reasoning paths, such as constructing semantic graphs (Xu et al., 2021a), learning an RNN to retrieve reasoning paths over the Wikipedia graph (Asai et al., 2020), fine-tuning with human annotated reasoning paths on math problems (Cobbe et al., 2021), or training an extractor with heuristic-based pseudo reasoning paths (Chen et al., 2019). More recently, the importance of diversity in the reasoning processes has been noticed, but only leveraged via task-specific training, either through an additional QA model over extracted reasoning paths (Chen et al., 2019), or by the introduction of latent variables in a commonsense knowledge graph (Yu et al., 2022). Compared to these approaches, self-consistency is far simpler and requires no additional training. The approach we propose simply couples the generation of reasoning paths and a final answer by sampling from the decoder, using aggregation to recover the most consistent answer without additional modules.
Consistency in language models. Some prior work has shown that language models can suffer from inconsistency in conversation (Adiwardana et al., 2020), explanation generation (Camburu et al., 2020), and factual knowledge extraction (Elazar et al., 2021). Welleck et al. (2020) use "consistency" to refer to generating an infinite-length sequence in recurrent language models. Nye et al. (2021) improve the logical consistency of samples from a System 1 model by adding a System 2-inspired logical reasoning module. In this paper we focus on a slightly different notion of "consistency", i.e., utilizing answer consistency among diverse reasoning paths to improve accuracy.</p>
<h2>5 CONCLUSION AND DISCUSSION</h2>
<p>We introduced a simple yet effective method called self-consistency, and observed that it significantly improves accuracy in a range of arithmetic and commonsense reasoning tasks, across four large language models with varying scales. Beyond accuracy gains, self-consistency is also useful for collecting rationales when performing reasoning tasks with language models, and for providing uncertainty estimates and improved calibration of language model outputs.
One limitation of self-consistency is that it incurs more computation cost. In practice people can try a small number of paths (e.g., 5 or 10) as a starting point to realize most of the gains while not incurring too much cost, as in most cases the performance saturates quickly (Figure 2). As part of future work, one could use self-consistency to generate better supervised data to fine-tune the model, such that the model can give more accurate predictions in a single inference run after fine-tuning. In addition, we observed that language models can sometimes generate incorrect or nonsensical reasoning paths (e.g., the StrategyQA example in Table 4, the two population numbers are not exactly correct), and further work is needed to better ground models' rationale generations.</p>
<h1>REPRODUCIbILITY STATEMENT</h1>
<p>In experiments, we included four different language models with varying scales. Two of them are public models: UL2 is a completely open-sourced model with model checkpoints available at https:// github.com/google-research/google-research/tree/master/ul2; GPT-3 is also a public model with public API available at https://openai.com/api/. For GPT-3, we have included two public engines ("code-davinci-001" and "code-davinci-002") to further aid reproducibility, as Codex is currently free so anyone can reproduce the results. In addition, as our results make use of LaMDA-137B and PaLM-540B that are not publicly available, we provide the exact input prompts for all tasks in Appendix A. 3 (and note that we do not perform any finetuning and only apply prompting to off-the-shelf language models).</p>
<h2>ETHICS STATEMENT</h2>
<p>As we stated in the discussion, language models can sometimes generate nonsensical or non-factual reasoning paths, so one should use language models' outputs with extra caution. We deal with reasoning tasks mostly and the generated rationales are only used for inspecting how a model reaches its answer. One could potentially use the generated rationales to further check why the model makes certain mistakes or whether the model contains any biases when performing a certain task. For language model in real-world use, further work is needed to better ground models' predictions and improve model's factuality and safety, to ensure the models do not cause harms to users.</p>
<h2>REFERENCES</h2>
<p>David H. Ackley, Geoffrey E. Hinton, and Terrence J. Sejnowski. A learning algorithm for boltzmann machines. Cognitive Science, 9(1):147-169, 1985. ISSN 0364-0213. URL https://www . sciencedirect.com/science/article/pii/S0364021385800124.</p>
<p>Daniel Adiwardana, Minh-Thang Luong, David R. So, Jamie Hall, Noah Fiedel, Romal Thoppilan, Zi Yang, Apoorv Kulshreshtha, Gaurav Nemade, Yifeng Lu, and Quoc V. Le. Towards a human-like open-domain chatbot, 2020.</p>
<p>Aida Amini, Saadia Gabriel, Shanchuan Lin, Rik Koncel-Kedziorski, Yejin Choi, and Hannaneh Hajishirzi. MathQA: Towards interpretable math word problem solving with operation-based formalisms. In Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long and Short Papers), pp. 2357-2367. Association for Computational Linguistics, June 2019. URL https://aclanthology.org/N19-1245.</p>
<p>Daniel Andor, Luheng He, Kenton Lee, and Emily Pitler. Giving BERT a calculator: Finding operations and arguments with reading comprehension. In Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing and the 9th International Joint Conference on Natural Language Processing (EMNLP-IJCNLP), 2019. URL https://aclanthology . org/D19-1609.</p>
<p>Akari Asai, Kazuma Hashimoto, Hannaneh Hajishirzi, Richard Socher, and Caiming Xiong. Learning to retrieve reasoning paths over wikipedia graph for question answering. In International Conference on Learning Representations, 2020. URL https://openreview.net/forum? id=SJgVHkrYDH.</p>
<p>Roy Bar-Haim, Ido Dagan, Bill Dolan, Lisa Ferro, Danilo Giampiccolo, Bernardo Magnini, and Idan Szpektor. The second pascal recognising textual entailment challenge. In Proceedings of the second PASCAL challenges workshop on recognising textual entailment, 2006.</p>
<p>Dhruv Batra, Payman Yadollahpour, Abner Guzman-Rivera, and Gregory Shakhnarovich. Diverse m-best solutions in markov random fields. In Proceedings of the 12th European Conference on Computer Vision - Volume Part V, ECCV'12, pp. 1-16, Berlin, Heidelberg, 2012. Springer-Verlag. ISBN 9783642337147. URL https://doi.org/10.1007/978-3-642-33715-4_1.</p>
<p>Luisa Bentivogli, Peter Clark, Ido Dagan, and Danilo Giampiccolo. The fifth pascal recognizing textual entailment challenge. In TAC, 2009.</p>
<p>BIG-bench collaboration. Beyond the imitation game: Measuring and extrapolating the capabilities of language models. In preparation, 2021. URL https://github.com/google/ BIG-bench/.</p>
<p>Tom Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared D Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, Sandhini Agarwal, Ariel Herbert-Voss, Gretchen Krueger, Tom Henighan, Rewon Child, Aditya Ramesh, Daniel Ziegler, Jeffrey Wu, Clemens Winter, Chris Hesse, Mark Chen, Eric Sigler, Mateusz Litwin, Scott Gray, Benjamin Chess, Jack Clark, Christopher Berner, Sam McCandlish, Alec Radford, Ilya Sutskever, and Dario Amodei. Language models are few-shot learners. In Advances in Neural Information Processing Systems, 2020. URL https://proceedings.neurips.cc/paper/2020/ file/1457c0d6bfcb4967418bfb8ac142f64a-Paper.pdf.</p>
<p>Oana-Maria Camburu, Tim RocktÃ¤schel, Thomas Lukasiewicz, and Phil Blunsom. esnli: Natural language inference with natural language explanations. In S. Bengio, H. Wallach, H. Larochelle, K. Grauman, N. Cesa-Bianchi, and R. Garnett (eds.), Advances in Neural Information Processing Systems 31, pp. 9539-9549. Curran Associates, Inc., 2018. URL http://papers.nips.cc/paper/ 8163-e-snli-natural-language-inference-with-natural-language-explanations. pdf.</p>
<p>Oana-Maria Camburu, Brendan Shillingford, Pasquale Minervini, Thomas Lukasiewicz, and Phil Blunsom. Make up your mind! adversarial generation of inconsistent natural language explanations. In Proceedings of the 58th Annual Meeting of the Association for Computational Linguistics, pp. 4157-4165, Online, July 2020. Association for Computational Linguistics. doi: 10.18653/v1/2020. acl-main.382. URL https://aclanthology.org/2020.acl-main.382.</p>
<p>Jifan Chen, Shih-Ting Lin, and Greg Durrett. Multi-hop question answering via reasoning chains. CoRR, abs/1910.02610, 2019. URL http://arxiv.org/abs/1910.02610.</p>
<p>Mark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Ponde de Oliveira Pinto, Jared Kaplan, Harri Edwards, Yuri Burda, Nicholas Joseph, Greg Brockman, et al. Evaluating large language models trained on code. arXiv preprint arXiv:2107.03374, 2021.</p>
<p>Aakanksha Chowdhery, Sharan Narang, Jacob Devlin, Maarten Bosma, Gaurav Mishra, Adam Roberts, Paul Barham, Hyung Won Chung, Charles Sutton, Sebastian Gehrmann, Parker Schuh, Kensen Shi, Sasha Tsvyashchenko, Joshua Maynez, Abhishek Rao, Parker Barnes, Yi Tay, Noam Shazeer, Vinodkumar Prabhakaran, Emily Reif, Nan Du, Ben Hutchinson, Reiner Pope, James Bradbury, Jacob Austin, Michael Isard, Guy Gur-Ari, Pengcheng Yin, Toju Duke, Anselm Levskaya, Sanjay Ghemawat, Sunipa Dev, Henryk Michalewski, Xavier Garcia, Vedant Misra, Kevin Robinson, Liam Fedus, Denny Zhou, Daphne Ippolito, David Luan, Hyeontaek Lim, Barret Zoph, Alexander Spiridonov, Ryan Sepassi, David Dohan, Shivani Agrawal, Mark Omernick, Andrew M. Dai, Thanumalayan Sankaranarayana Pillai, Marie Pellat, Aitor Lewkowycz, Erica Moreira, Rewon Child, Oleksandr Polozov, Katherine Lee, Zongwei Zhou, Xuezhi Wang, Brennan Saeta, Mark Diaz, Orhan Firat, Michele Catasta, Jason Wei, Kathy Meier-Hellstern, Douglas Eck, Jeff Dean, Slav Petrov, and Noah Fiedel. Palm: Scaling language modeling with pathways, 2022. URL https://arxiv.org/abs/2204.02311.</p>
<p>Christopher Clark, Kenton Lee, Ming-Wei Chang, Tom Kwiatkowski, Michael Collins, and Kristina Toutanova. Boolq: Exploring the surprising difficulty of natural yes/no questions. In NAACL, 2019.</p>
<p>Peter Clark, Isaac Cowhey, Oren Etzioni, Tushar Khot, Ashish Sabharwal, Carissa Schoenick, and Oyvind Tafjord. Think you have solved question answering? try arc, the ai2 reasoning challenge. ArXiv, abs/1803.05457, 2018.</p>
<p>Karl Cobbe, Vineet Kosaraju, Mohammad Bavarian, Mark Chen, Heewoo Jun, Lukasz Kaiser, Matthias Plappert, Jerry Tworek, Jacob Hilton, Reiichiro Nakano, Christopher Hesse, and John Schulman. Training verifiers to solve math word problems, 2021.</p>
<p>Ido Dagan, Oren Glickman, and Bernardo Magnini. The pascal recognising textual entailment challenge. In Machine Learning Challenges Workshop, pp. 177-190. Springer, 2005.</p>
<p>Bryan Eikema and Wilker Aziz. Is MAP decoding all you need? the inadequacy of the mode in neural machine translation. In Proceedings of the 28th International Conference on Computational Linguistics, pp. 4506-4520, Barcelona, Spain (Online), December 2020. International Committee on Computational Linguistics. URL https://aclanthology.org/2020.coling-main. 398 .</p>
<p>Yanai Elazar, Nora Kassner, Shauli Ravfogel, Abhilasha Ravichander, Eduard Hovy, Hinrich SchÃ¼tze, and Yoav Goldberg. Measuring and improving consistency in pretrained language models. Transactions of the Association for Computational Linguistics, 9:1012-1031, 2021. doi: 10.1162/tacl_a_00410. URL https://aclanthology.org/2021.tacl-1.60.</p>
<p>Jonathan St BT Evans. Intuition and reasoning: A dual-process perspective. Psychological Inquiry, 21(4):313-326, 2010.</p>
<p>Angela Fan, Mike Lewis, and Yann Dauphin. Hierarchical neural story generation. In Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pp. 889-898, Melbourne, Australia, July 2018. Association for Computational Linguistics. doi: 10.18653/v1/P18-1082. URL https://aclanthology.org/P18-1082.</p>
<p>Jessica Ficler and Yoav Goldberg. Controlling linguistic style aspects in neural language generation. In Proceedings of the Workshop on Stylistic Variation, pp. 94-104, Copenhagen, Denmark, September 2017. Association for Computational Linguistics. doi: 10.18653/v1/W17-4912. URL https: //aclanthology.org/W17-4912.</p>
<p>Tianyu Gao, Adam Fisch, and Danqi Chen. Making pre-trained language models better few-shot learners. In Proceedings of the 59th Annual Meeting of the Association for Computational Linguistics and the 11th International Joint Conference on Natural Language Processing (Volume 1: Long Papers), pp. 3816-3830, Online, August 2021. Association for Computational Linguistics. doi: 10.18653/v1/2021.acl-long.295. URL https://aclanthology.org/2021.acl-long. 295 .</p>
<p>Mor Geva, Ankit Gupta, and Jonathan Berant. Injecting numerical reasoning skills into language models. In Proceedings of the 58th Annual Meeting of the Association for Computational Linguistics, 2020. doi: 10.18653/v1/2020.acl-main.89. URL https://aclanthology.org/2020 . acl-main. 89 .</p>
<p>Mor Geva, Daniel Khashabi, Elad Segal, Tushar Khot, Dan Roth, and Jonathan Berant. Did aristotle use a laptop? A question answering benchmark with implicit reasoning strategies. Transactions of the Association for Computational Linguistics, 2021. URL https://aclanthology.org/ 2021.tacl-1.21.</p>
<p>Danilo Giampiccolo, Bernardo Magnini, Ido Dagan, and Bill Dolan. The third pascal recognizing textual entailment challenge. In Proceedings of the ACL-PASCAL workshop on textual entailment and paraphrasing, pp. 1-9. Association for Computational Linguistics, 2007.</p>
<p>Ari Holtzman, Jan Buys, Maxwell Forbes, Antoine Bosselut, David Golub, and Yejin Choi. Learning to write with cooperative discriminators. In Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pp. 1638-1649, Melbourne, Australia, July 2018. Association for Computational Linguistics. doi: 10.18653/v1/P18-1152. URL https://aclanthology.org/P18-1152.</p>
<p>Ari Holtzman, Jan Buys, Li Du, Maxwell Forbes, and Yejin Choi. The curious case of neural text degeneration. In International Conference on Learning Representations, 2020. URL https: //openreview.net/forum?id=rygGQyrFvH.</p>
<p>Mohammad Javad Hosseini, Hannaneh Hajishirzi, Oren Etzioni, and Nate Kushman. Learning to solve arithmetic word problems with verb categorization. In Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), 2014. doi: 10.3115/v1/D14-1058. URL https://aclanthology.org/D14-1058.</p>
<p>Daniel Khashabi, Sewon Min, Tushar Khot, Ashish Sabharwal, Oyvind Tafjord, Peter Clark, and Hannaneh Hajishirzi. UNIFIEDQA: Crossing format boundaries with a single QA system. In Findings of the Association for Computational Linguistics: EMNLP 2020, pp. 1896-1907, Online, November 2020. Association for Computational Linguistics. doi: 10.18653/v1/2020.findings-emnlp.171. URL https://aclanthology.org/2020.findings-emnlp.171.</p>
<p>Takeshi Kojima, Shixiang Shane Gu, Machel Reid, Yutaka Matsuo, and Yusuke Iwasawa. Large language models are zero-shot reasoners. In Alice H. Oh, Alekh Agarwal, Danielle Belgrave, and Kyunghyun Cho (eds.), Advances in Neural Information Processing Systems, 2022. URL https://openreview.net/forum?id=e2TBb5y0yFf.</p>
<p>Rik Koncel-Kedziorski, Subhro Roy, Aida Amini, Nate Kushman, and Hannaneh Hajishirzi. MAWPS: A math word problem repository. In Proceedings of the 2016 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, 2016. doi: 10.18653/v1/N16-1136. URL https://aclanthology.org/N16-1136.</p>
<p>Yihuai Lan, Lei Wang, Qiyuan Zhang, Yunshi Lan, Bing Tian Dai, Yan Wang, Dongxiang Zhang, and Ee-Peng Lim. MWPToolkit: An open-source framework for deep learning-based math word problem solvers. arXiv preprint arXiv:2109.00799, 2021. URL https://arxiv.org/abs/ 2109.00799 .</p>
<p>Jiwei Li and Dan Jurafsky. Mutual information and diverse decoding improve neural machine translation, 2016. URL https://arxiv.org/abs/1601.00372.</p>
<p>Jiwei Li, Will Monroe, and Dan Jurafsky. A simple, fast diverse decoding algorithm for neural generation. CoRR, abs/1611.08562, 2016. URL http://arxiv.org/abs/1611.08562.</p>
<p>Wang Ling, Dani Yogatama, Chris Dyer, and Phil Blunsom. Program induction by rationale generation: Learning to solve and explain algebraic word problems. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), 2017. doi: 10.18653/v1/P17-1015. URL https://aclanthology.org/P17-1015.</p>
<p>Yao Lu, Max Bartolo, Alastair Moore, Sebastian Riedel, and Pontus Stenetorp. Fantastically ordered prompts and where to find them: Overcoming few-shot prompt order sensitivity. ArXiv, abs/2104.08786, 2021.</p>
<p>Clara Meister, Tiago Pimentel, Gian Wiher, and Ryan Cotterell. Typical decoding for natural language generation. arXiv preprint arXiv:2202.00666, 2022.</p>
<p>Shen Yun Miao, Chao Chun Liang, and Keh Yih Su. A diverse corpus for evaluating and developing English math word problem solvers. In Proceedings of the 58th Annual Meeting of the Association for Computational Linguistics, 2020. URL https://aclanthology.org/2020. acl-main. 92 .</p>
<p>Yixin Nie, Adina Williams, Emily Dinan, Mohit Bansal, Jason Weston, and Douwe Kiela. Adversarial NLI: A new benchmark for natural language understanding. In Proceedings of the 58th Annual Meeting of the Association for Computational Linguistics. Association for Computational Linguistics, 2020.</p>
<p>Maxwell Nye, Michael Henry Tessler, Joshua B. Tenenbaum, and Brenden M. Lake. Improving coherence and consistency in neural sequence models with dual-system, neuro-symbolic reasoning. In A. Beygelzimer, Y. Dauphin, P. Liang, and J. Wortman Vaughan (eds.), Advances in Neural Information Processing Systems, 2021. URL https://openreview.net/forum?id= uyKk_avJ-p4.</p>
<p>Arkil Patel, Satwik Bhattamishra, and Navin Goyal. Are NLP models really able to solve simple math word problems? In Proceedings of the 2021 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, pp. 2080-2094, Online, June 2021. Association for Computational Linguistics. doi: 10.18653/v1/2021.naacl-main. 168. URL https://aclanthology.org/2021.naacl-main. 168.</p>
<p>Xinyu Pi, Qian Liu, Bei Chen, Morteza Ziyadi, Zeqi Lin, Yan Gao, Qiang Fu, Jian-Guang Lou, and Weizhu Chen. Reasoning like program executors, 2022.</p>
<p>Piotr PiÄ™kos, Mateusz Malinowski, and Henryk Michalewski. Measuring and improving BERT's mathematical abilities by predicting the order of reasoning. In Proceedings of the 59th Annual Meeting of the Association for Computational Linguistics and the 11th International Joint Conference on Natural Language Processing (Volume 2: Short Papers), 2021. doi: 10.18653/v1/2021.acl-short.49. URL https://aclanthology.org/2021.acl-short. 49.</p>
<p>Alec Radford, Jeff Wu, Rewon Child, David Luan, Dario Amodei, and Ilya Sutskever. Language models are unsupervised multitask learners. 2019.</p>
<p>Jack W Rae, Sebastian Borgeaud, Trevor Cai, Katie Millican, Jordan Hoffmann, Francis Song, John Aslanides, Sarah Henderson, Roman Ring, Susannah Young, et al. Scaling language models: Methods, analysis \&amp; insights from training gopher. arXiv preprint arXiv:2112.11446, 2021.</p>
<p>Qiu Ran, Yankai Lin, Peng Li, Jie Zhou, and Zhiyuan Liu. NumNet: Machine reading comprehension with numerical reasoning. In Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing and the 9th International Joint Conference on Natural Language Processing (EMNLP-IJCNLP), 2019. doi: 10.18653/v1/D19-1251. URL https://aclanthology. org/D19-1251.</p>
<p>Subhro Roy and Dan Roth. Solving general arithmetic word problems. In Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing, 2015. doi: 10.18653/v1/ D15-1202. URL https://aclanthology.org/D15-1202.</p>
<p>Jianhao Shen, Yichun Yin, Lin Li, Lifeng Shang, Xin Jiang, Ming Zhang, and Qun Liu. Generate \&amp; rank: A multi-task framework for math word problems. In Findings of the Association for Computational Linguistics: EMNLP 2021, pp. 2269-2279, Punta Cana, Dominican Republic, November 2021. Association for Computational Linguistics. URL https://aclanthology. org/2021.findings-emnlp. 195.</p>
<p>Freda Shi, Daniel Fried, Marjan Ghazvininejad, Luke Zettlemoyer, and Sida I. Wang. Natural language to code translation with execution. In Proceedings of the 2022 Conference on Empirical Methods in Natural Language Processing, pp. 3533-3546, Abu Dhabi, United Arab Emirates, December 2022. Association for Computational Linguistics. URL https://aclanthology. org/2022.emnlp-main. 231.</p>
<p>Keith E Stanovich and Richard F West. Individual differences in reasoning: Implications for the rationality debate? Behavioral and brain sciences, 23(5):645-665, 2000. URL https: //pubmed.ncbi.nlm.nih.gov/11301544/.</p>
<p>Alon Talmor, Jonathan Herzig, Nicholas Lourie, and Jonathan Berant. CommonsenseQA: A question answering challenge targeting commonsense knowledge. In Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long and Short Papers), 2019. URL https://aclanthology. org/N19-1421.</p>
<p>Yi Tay, Mostafa Dehghani, Vinh Q. Tran, Xavier Garcia, Jason Wei, Xuezhi Wang, Hyung Won Chung, Dara Bahri, Tal Schuster, Steven Zheng, Denny Zhou, Neil Houlsby, and Donald Metzler. Unifying language learning paradigms, 2022. URL https://arxiv.org/abs/2205.05131.</p>
<p>Romal Thoppilan, Daniel De Freitas, Jamie Hall, Noam Shazeer, Apoorv Kulshreshtha, Heng-Tze Cheng, Alicia Jin, Taylor Bos, Leslie Baker, Yu Du, et al. Lamda: Language models for dialog applications. arXiv preprint arXiv:2201.08239, 2022. URL https://arxiv.org/abs/ 2201.08239.</p>
<p>Ashwin Vijayakumar, Michael Cogswell, Ramprasaath Selvaraju, Qing Sun, Stefan Lee, David Crandall, and Dhruv Batra. Diverse beam search for improved description of complex scenes. Proceedings of the AAAI Conference on Artificial Intelligence, 32, Apr. 2018. URL https: //ojs.aaai.org/index.php/AAAI/article/view/12340.</p>
<p>Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Brian Ichter, Fei Xia, Ed Chi, Quoc Le, and Denny Zhou. Chain of thought prompting elicits reasoning in large language models. Conference on Neural Information Processing Systems (NeurIPS), 2022. URL https://arxiv. org/pdf/2201.11903.</p>
<p>Sean Welleck, Ilia Kulikov, Jaedeok Kim, Richard Yuanzhe Pang, and Kyunghyun Cho. Consistency of a recurrent language model with respect to incomplete decoding. In Proceedings of the 2020 Conference on Empirical Methods in Natural Language Processing (EMNLP), pp. 5553-5568, Online, November 2020. Association for Computational Linguistics. doi: 10.18653/v1/2020. emnlp-main.448. URL https://aclanthology.org/2020.emnlp-main.448.</p>
<p>Weiwen Xu, Yang Deng, Huihui Zhang, Deng Cai, and Wai Lam. Exploiting reasoning chains for multi-hop science question answering. In Findings of the Association for Computational Linguistics: EMNLP 2021, pp. 1143-1156, Punta Cana, Dominican Republic, November 2021a. Association for Computational Linguistics. URL https://aclanthology.org/2021. findings-emnlp. 99 .</p>
<p>Yichong Xu, Chenguang Zhu, Shuohang Wang, Siqi Sun, Hao Cheng, Xiaodong Liu, Jianfeng Gao, Pengcheng He, Michael Zeng, and Xuedong Huang. Human parity on commonsenseqa: Augmenting self-attention with external attention, 2021b. URL https://arxiv.org/abs/ 2112.03254.</p>
<p>Zhilin Yang, Peng Qi, Saizheng Zhang, Yoshua Bengio, William Cohen, Ruslan Salakhutdinov, and Christopher D. Manning. HotpotQA: A dataset for diverse, explainable multi-hop question answering. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pp. 2369-2380, Brussels, Belgium, October-November 2018. Association for Computational Linguistics. doi: 10.18653/v1/D18-1259. URL https://aclanthology.org/D18-1259.</p>
<p>Xi Ye and Greg Durrett. The unreliability of explanations in few-shot prompting for textual reasoning. In Alice H. Oh, Alekh Agarwal, Danielle Belgrave, and Kyunghyun Cho (eds.), Advances in Neural Information Processing Systems, 2022. URL https://openreview.net/forum? id=Bct2f8fRd8S.</p>
<p>Wenhao Yu, Chenguang Zhu, Lianhui Qin, Zhihan Zhang, Tong Zhao, and Meng Jiang. Diversifying content generation for commonsense reasoning with mixture of knowledge graph experts. In Findings of Annual Meeting of the Association for Computational Linguistics (ACL), 2022.</p>
<p>Zihao Zhao, Eric Wallace, Shi Feng, Dan Klein, and Sameer Singh. Calibrate before use: Improving few-shot performance of language models. In Marina Meila and Tong Zhang (eds.), Proceedings of the 38th International Conference on Machine Learning, volume 139 of Proceedings of Machine Learning Research. PMLR, 2021. URL https://proceedings.mlr.press/ v139/zhao21c.html.</p>
<h1>A APPENDIX</h1>
<h2>A. 1 Additional Experiment Results</h2>
<h2>A.1.1 Robustness to Sampling Strategies and Parameters</h2>
<p>In Figure 6 we ablate the results with respect to different sampling strategies and parameters by varying $T$ in temperature sampling and $k$ in Top- $k$ sampling, on LaMDA-137B. We show that self-consistency is robust to various sampling strategies and parameters.
<img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 6: GSM8K accuracy over LaMDA-137B. Self-consistency works under various sampling strategies and sampling parameters.</p>
<p>In Figure 7 and Figure 8, we show the results of self-consistency compared with greedy decoding a single path over LaMDA-137B and PaLM-540B, respectively. Self-consistency improves over greedy decode by a quite significant margin on both models, on top of high accuracy already achieved by scaling up model sizes.
<img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 7: Self-consistency (blue) significantly improves accuracy across various arithmetic and commonsense reasoning tasks, over LaMDA-137B. Sampling a higher number of diverse reasoning paths consistently improves reasoning accuracy.</p>
<p>We further show additional sampled reasoning paths from the LaMDA-137B model in Table 12, and sampled reasoning paths from the PaLM-540B model in Table 13. We see that the diversity in the additionally sampled reasoning paths indeed helps the model arrive at a more correct final answer after aggregation.</p>
<h2>A.1.2 ROBUSTNESS TO DIFFERENT SETS OF PROMPTS</h2>
<p>In Table 9, we further show that self-consistency is quite robust to different sets of input prompts. We manually wrote 3 different sets of chain-of-thought as prompts to the model. Across all sets of prompts, self-consistency yields consistent gains over the original CoT approach.</p>
<h2>A.1.3 COMPARED TO MODEL ENSEMBLES</h2>
<p>Additionally, we provide results of directly ensembling the outputs from multiple language models. The results are shown in Table 10, by greedily decoding sequences from 3 language models and</p>
<p><img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>Figure 8: Self-consistency (blue) significantly improves accuracy across various arithmetic and commonsense reasoning tasks, over PaLM-540B. Sampling a higher number of diverse reasoning paths consistently helps reasoning accuracy.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">Prompt set 1 (used in the main text)</th>
<th style="text-align: center;">Prompt set 2</th>
<th style="text-align: center;">Prompt set 3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">CoT (Wei et al., 2022)</td>
<td style="text-align: center;">56.5</td>
<td style="text-align: center;">54.6</td>
<td style="text-align: center;">54.0</td>
</tr>
<tr>
<td style="text-align: center;">Self-consistency</td>
<td style="text-align: center;">$74.4(+17.9)$</td>
<td style="text-align: center;">$72.1(+17.5)$</td>
<td style="text-align: center;">$70.4(+16.4)$</td>
</tr>
</tbody>
</table>
<p>Table 9: GSM8K accuracy over PaLM-540B. The results show robustness of self-consistency with respect to different prompts in the input.
taking the majority vote (averaged over 10 runs). Note this is a typical ensemble approach (averaging over the predictions over multiple models) and it achieves a performance significantly worse than self-consistency (self-consistency over PaLM-540B gets an accuracy of $74.4 \%$ ), as lower-capacity models drag down the performance of higher-capacity models. In addition, this approach is limited in two ways: 1) It requires multiple models for an ensemble which might not always be available, while self-consistency only requires one single model to "self-ensemble"; 2) If one of the models is much weaker, it can actually hurt the final performance.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;">Method</th>
<th style="text-align: center;">GSM8K accuracy</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Single model</td>
<td style="text-align: left;">PaLM-540B, greedy / self-consistency</td>
<td style="text-align: center;">$56.5 / 74.4$</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">LaMDA-137B + PaLM-540B</td>
<td style="text-align: center;">$36.9 \pm 0.5$</td>
</tr>
<tr>
<td style="text-align: left;">Ensemble of models</td>
<td style="text-align: left;">PaLM-540B + GPT-3 (code-davinci-001, 175B)</td>
<td style="text-align: center;">$36.6 \pm 0.4$</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">LaMDA-137B + GPT-3 (code-davinci-001, 175B)</td>
<td style="text-align: center;">$16.0 \pm 0.8$</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">LaMDA-137B + PaLM-540B + GPT-3 (code-davinci-001, 175B)</td>
<td style="text-align: center;">$33.3 \pm 0.7$</td>
</tr>
</tbody>
</table>
<p>Table 10: Comparison of GSM8K accuracy over multiple-model ensembles.</p>
<h1>A.1.4 COMBINING SELF-CONSISTENCY WITH OTHER ENSEMBLING STRATEGIES</h1>
<p>Self-consistency is completely compatible with other ensemble strategies, although the gains achieved by self-consistency are significantly higher than other ensemble strategies (and can "override" the performance gains achieved by other ensemble strategies). We further performed experiments and include the results in Table 11 (for a fair comparison, we use 40 sets of prompts, or 40 prompt permutations to compare with self-consistency with 40 paths, all experiments are based on PaLM540B).</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: center;">GSM8K accuracy</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Different sets of prompts (x40)</td>
<td style="text-align: center;">58.9</td>
</tr>
<tr>
<td style="text-align: left;">Prompt-permutation (x40)</td>
<td style="text-align: center;">59.6</td>
</tr>
<tr>
<td style="text-align: left;">Self-consistency (x40)</td>
<td style="text-align: center;">74.4</td>
</tr>
<tr>
<td style="text-align: left;">Self-consistency + different sets of prompts (x40)</td>
<td style="text-align: center;">75.4</td>
</tr>
<tr>
<td style="text-align: left;">Self-consistency + prompt-permutation (x40)</td>
<td style="text-align: center;">73.8</td>
</tr>
</tbody>
</table>
<p>Table 11: Combining self-consistency with other ensembling strategies.</p>
<h1>A. 2 Details on Resources and Inference</h1>
<p>For all four language models we perform prompting-based inference only. For UL2 we use TPU v3 (2x2 configuration, 4 chips, 8 cores). For GPT-3 models the experiments are done though the public API. ${ }^{10}$ For LaMDA-137B we use TPU v3 (8x8 configuration, 64 chips, 128 cores). For PaLM-540B we use TPU v4 ( $4 \times 4 \times 12$ configuration, 192 chips, 384 cores). Most inference jobs take 1 to 4 hours (over about 1,000 examples) for each task on UL2 and LaMDA-137B, and about 2 to 12 hours on PaLM-540B. Some tasks (e.g., commonsense reasoning) take longer but do not exceed 2 days for each task.</p>
<p>For GPT-3 models, we use 128 max tokens for all methods, without frequency penalty or presence penalty. For all models, we take the generated outputs until the start of the next "Q:" to parse the final answers, consistent with our prompting format.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Question</th>
<th style="text-align: center;">Greedy Decode</th>
<th style="text-align: center;">Sampled Path 1</th>
<th style="text-align: center;">Sampled Path 2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">[MultiArith] Sam had 10 socks. If he threw away 3 old ones that didn't fit and bought 36 new ones, how many socks would he have?</td>
<td style="text-align: center;">Sam had 10 socks. He threw away 3 old ones that didn't fit. He bought 36 new ones. That means he has $10+36-3=41$ socks. The answer is 41 .</td>
<td style="text-align: center;">Sam had 10 socks. He threw away 3 old ones. So now he has 7 left. Then he bought 36 new ones. So now he has $7+36=43$ socks. The answer is 43 .</td>
<td style="text-align: center;">He had 10 socks. He threw away 3 old ones that didn't fit. He bought 36 new ones. So in total he has $10-3+36=43$ socks. The answer is 43 .</td>
</tr>
<tr>
<td style="text-align: center;">[SVAMP] In a school there are 697 girls and the rest are boys. If there are 228 more girls than boys. How many boys are there in that school?</td>
<td style="text-align: center;">There are 697 girls and the rest are boys. That means there are $697+228=925$ girls. The rest are boys. So the number of boys is $925-697=228$. The answer is 228 .</td>
<td style="text-align: center;">The number of boys is the difference between 697 and 228. This is $697-228$ $=469$. The answer is 469 .</td>
<td style="text-align: center;">In the beginning there are 697 girls and the rest are boys. So, the number of boys must be $697-228$ $=469$ boys. The answer is 469 .</td>
</tr>
<tr>
<td style="text-align: center;">[AQuA] There are 10 oranges in a basket. Find the no. of ways in which 2 oranges are chosen from the basket? (a) 45 (b) 90 (c) 120 (d) 150 (e) 180</td>
<td style="text-align: center;">There are 10 oranges in a basket. So there are 10 ways in which 2 oranges are chosen from the basket.</td>
<td style="text-align: center;">There are 10 oranges in a basket. We need to choose 2 oranges from the basket. So the number of ways are 10C2. So the answer is (a).</td>
<td style="text-align: center;">There are 10 oranges in the basket. If you choose 2 oranges, you have $10 \mathrm{C} 2=45$ ways of choosing 2 oranges. So the answer is (a).</td>
</tr>
<tr>
<td style="text-align: center;">[CommonsenseQA] The man laid on the soft moss and looked up at the trees, where was the man? (a) niagra falls (b) forest (c) waterfall (d) ground (e) tree</td>
<td style="text-align: center;">The answer must be something that is soft and mossy. Of the above choices, only ground is soft and mossy. So the answer is (d).</td>
<td style="text-align: center;">The answer must be somewhere where moss is found. Of the above choices, only forests are known for having moss. So the answer is (b).</td>
<td style="text-align: center;">The answer must be a place where the man is laying down and looking up at trees. Of the above choices, only forest is a place where people lay down and look at trees. So the answer is (b).</td>
</tr>
<tr>
<td style="text-align: center;">[ARC] Which of these will most likely harm a habitat? (a) planting trees. (b) water pollution. (c) rainfall. (d) sunlight.</td>
<td style="text-align: center;">Planting trees will not harm a habitat. So the answer is (a).</td>
<td style="text-align: center;">The answer is (b), water pollution, because it will most likely harm the habitat. The other answers are not likely to harm the habitat.</td>
<td style="text-align: center;">The answer is (b), water pollution. Trees are good for a habitat, rainfall is necessary for a habitat, and sunlight is necessary for a habitat. So the answer is (b).</td>
</tr>
<tr>
<td style="text-align: center;">[ARC-challenge] Which process in the carbon cycle takes the longest to complete? (a) emission of waste. (b) respiration in animals. (c) photosynthesis in plants. (d) formation of fossil fuels.</td>
<td style="text-align: center;">The process of photosynthesis in plants takes the longest to complete. So the answer is (c).</td>
<td style="text-align: center;">The formation of fossil fuels takes the longest time to complete. So the answer is (d).</td>
<td style="text-align: center;">The process that takes the longest time to complete is the formation of fossil fuels, which happens over millions of years. So the answer is (d).</td>
</tr>
</tbody>
</table>
<p>Table 12: Additional examples where self-consistency helps repair the errors over greedy decode on LaMDA-137B. Two sampled reasoning paths that are consistent with the ground truth are shown.</p>
<p><sup id="fnref6:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<table>
<thead>
<tr>
<th style="text-align: center;">Question</th>
<th style="text-align: center;">Greedy Decode</th>
<th style="text-align: center;">Sampled Path 1</th>
<th style="text-align: center;">Sampled Path 2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">[GSM8K] Kyle bought last year's best-selling book for $\$ 19.50$. This is with a $25 \%$ discount from the original price. What was the original price of the book?</td>
<td style="text-align: center;">The book was sold for $\$ 19.50$. This is $25 \%$ less than the original price. This means the original price was $100 \%, 25 \%$ of $100 \%$ is $25 \%$. So the original price was $100 \%$ - $25 \%=75 \%$. The original price was $75 \%$ of $\$ 19.50$. $75 \%$ of $\$ 19.50$ is $75 \%$ * $\$ 19.50=$ $\$ 14.625$. The answer is $\$ 14.625$.</td>
<td style="text-align: center;">The original price of the book is $\$ 19.50$. Since it was discounted by $25 \%$, the original price was $19.50 / 0.75=26$. The answer is 26 .</td>
<td style="text-align: center;">Kyle bought a book that is sold for $\$ 19.50$. With a $25 \%$ discount, the original price must be higher. If we call the original price x , then the discounted price is 0.75 x . Since this is $\$ 19.50$, we can write $0.75 \mathrm{x}=19.50$. Solving this, we find that the original price is $\mathrm{x}=$ $19.50 / 0.75=\$ 26$. The answer is $\$ 26$.</td>
</tr>
<tr>
<td style="text-align: center;">[AQuA] The capacity of a tank of dimensions ( $8 \mathrm{~m} \times 6$ $m \times 2.5 \mathrm{~m}$ ) is (a) 120 litres (b) 1200 litres (c) 12000 litres (d) 120000 litres (e) None of these</td>
<td style="text-align: center;">The volume of the tank is $8 \mathrm{~m} *$ $6 \mathrm{~m} * 2.5 \mathrm{~m}=120 \mathrm{~m}^{3}$. So the capacity of the tank is $120 \mathrm{~m}^{3}$. So the answer is (c).</td>
<td style="text-align: center;">The volume of the tank is $8 \mathrm{~m}$ * $6 \mathrm{~m} * 2.5 \mathrm{~m}=120 \mathrm{~m}^{3}$. This is equal to 120000 litres. So the answer is (d)</td>
<td style="text-align: center;">The volume of the tank is $8 \mathrm{~m} *$ $6 \mathrm{~m} * 2.5 \mathrm{~m}=120 \mathrm{~m} 3$. One cubic meter contains 1000 litres, so the tank contains $120 \mathrm{~m} 3 * 1000$ liters $/ \mathrm{m} 3=120,000$ liters. So the answer is (d).</td>
</tr>
<tr>
<td style="text-align: center;">[StrategyQA] Yes or no: Can the Great Depression be treated with Prozac?</td>
<td style="text-align: center;">The Great Depression was an economic depression. Prozac is a drug used to treat depression. Thus, the Great Depression could be treated with Prozac. So the answer is yes.</td>
<td style="text-align: center;">Prozac is an anti-depressant medication. The Great Depression is not a disease. Thus, Prozac cannot treat the Great Depression. So the answer is no.</td>
<td style="text-align: center;">The Great Depression is a time period. Prozac is used to treat depression (the mental illness). Thus, the Great Depression can not be treated with Prozac. So the answer is no.</td>
</tr>
<tr>
<td style="text-align: center;">[ARC-easy] Which source of energy is nonrenewable? (a) coal. (b) sunlight. (c) water. (d) wood.</td>
<td style="text-align: center;">Coal, sunlight, and water are all renewable sources of energy. Wood is a nonrenewable source of energy. So the answer is (d).</td>
<td style="text-align: center;">A nonrenewable source of energy is one in which the source is not replenished in a short amount of time. Thus, the only option that is nonrenewable is coal. So the answer is (a).</td>
<td style="text-align: center;">Coal is a fossil fuel and is formed from dead organisms from the past. Coal cannot be produced in a short period of time, so it is considered a nonrenewable source of energy. So the answer is (a).</td>
</tr>
<tr>
<td style="text-align: center;">[ARC-challenge] Students studied the revolution of Earth around the Sun. During which month will Florida have the most sunlight energy available? (a) March. (b) June. (c) September. (d) December.</td>
<td style="text-align: center;">The Earth is closest to the Sun in December, hence Florida will have the most sunlight energy available in December. So the answer is (d).</td>
<td style="text-align: center;">Earth is closest to the Sun on June 21, the summer solstice. So the answer is (b).</td>
<td style="text-align: center;">Florida is closer to the sun during June, so it will have the most sunlight energy during that month. So the answer is (b).</td>
</tr>
</tbody>
</table>
<p>Table 13: Additional examples where self-consistency helps repair the errors over greedy decode on PaLM-540B. Two sampled reasoning paths that are consistent with the ground truth are shown.</p>
<h1>A. 3 Full Sets of Prompts</h1>
<p>We list the full details of the prompts used for two newly-introduced datasets, AQUA-RAT (Ling et al., 2017) and AI2 Reasoning Challenge (ARC) (Clark et al., 2018), where we manually composed the example chain-of-thought in this paper, in Table 14 and Table 15, respectively.</p>
<p>Table 14: Few-shot exemplars for AQUA-RAT.
Q: John found that the average of 15 numbers is 40 . If 10 is added to each number then the mean of the numbers is? Answer Choices: (a) 50 (b) 45 (c) 65 (d) 78 (e) 64
A: If 10 is added to each number, then the mean of the numbers also increases by 10 . So the new mean would be 50 . The answer is (a).
Q: If a / b = 3/4 and $8 \mathrm{a}+5 \mathrm{~b}=22$, then find the value of a. Answer Choices: (a) $1 / 2$ (b) $3 / 2$ (c) $5 / 2$ (d) $4 / 2$ (e) $7 / 2$
A: If a / b = 3/4, then $\mathrm{b}=4 \mathrm{a} / 3$. So $8 \mathrm{a}+5(4 \mathrm{a} / 3)=22$. This simplifies to $8 \mathrm{a}+20 \mathrm{a} / 3=22$, which means $44 \mathrm{a} / 3=22$. So a is equal to $3 / 2$. The answer is (b).
Q: A person is traveling at $20 \mathrm{~km} / \mathrm{hr}$ and reached his destiny in 2.5 hr then find the distance? Answer Choices: (a) 53 km (b) 55 km (c) 52 km (d) 60 km (e) 50 km</p>
<p>A: The distance that the person traveled would have been $20 \mathrm{~km} / \mathrm{hr} * 2.5 \mathrm{hrs}=50 \mathrm{~km}$. The answer is (e).
Q: How many keystrokes are needed to type the numbers from 1 to 500? Answer Choices: (a) 1156 (b) 1392 (c) 1480 (d) 1562 (e) 1788</p>
<p>A: There are 9 one-digit numbers from 1 to 9 . There are 90 two-digit numbers from 10 to 99 . There are 401 three-digit numbers from 100 to $500.9+90(2)+401(3)=1392$. The answer is (b).</p>
<p>Table 15: Few-shot exemplars for ARC easy/challenge.
Q: George wants to warm his hands quickly by rubbing them. Which skin surface will produce the most heat? (a) dry palms. (b) wet palms. (c) palms covered with oil. (d) palms covered with lotion.
A: Dry surfaces will more likely cause more friction via rubbing than other smoother surfaces, hence dry palms will produce the most heat. The answer is (a).
Q: Which factor will most likely cause a person to develop a fever? (a) a leg muscle relaxing after exercise. (b) a bacterial population in the bloodstream. (c) several viral particles on the skin. (d) carbohydrates being digested in the stomach.
A: Option (b), bacterial population is the most likely cause for a person developing fever. The answer is (b).
Q: Which change in the state of water particles causes the particles to become arranged in a fixed position? (a) boiling. (b) melting. (c) freezing. (d) evaporating.</p>
<p>A: When water is freezed, the particles are arranged in a fixed position; the particles are still moving for all other options. The answer is (c).
$\mathbf{Q}$ : When a switch is used in an electrical circuit, the switch can (a) cause the charge to build. (b) increase and decrease the voltage. (c) cause the current to change direction. (d) stop and start the flow of current.
A: The function of a switch is to start and stop the flow of a current. The answer is (d).</p>
<p>Table 16: Few-shot exemplars for HotpotQA (closed-book setting).
Q: Which magazine was started first Arthur's Magazine or First for Women?
A: Arthur's Magazine started in 1844. First for Women started in 1989. So Arthur's Magazine was started first. The answer is Arthur's Magazine.
Q: The Oberoi family is part of a hotel company that has a head office in what city?
A: The Oberoi family is part of the hotel company called The Oberoi Group. The Oberoi Group has its head office in Delhi. The answer is Delhi.
Q: What nationality was James Henry Miller's wife?
A: James Henry Miller's wife is June Miller. June Miller is an American. The answer is American.
Q: The Dutch-Belgian television series that "House of Anubis" was based on first aired in what year?
A: "House of Anubis" is based on the Dutch-Belgian television series Het Huis Anubis. Het Huis Anubis is first aired in September 2006. The answer is 2006.</p>
<p>As additional information, we also list the exact set of prompts used for all arithmetic reasoning tasks in Table 17, since there are multiple sets of prompts introduced in Wei et al. (2022). The prompts for CommonsenseQA and StrategyQA are the same as used in Wei et al. (2022).
We provide the exact prompts used for common NLP tasks in the following tables as well, including NLI (Table 18, Table 19, Table 20) and Closed-Book Question-Answering tasks (Table 16, Table 21).</p>
<p>Table 17: Few-shot exemplars for all arithmetic reasoning tasks, from Wei et al. (2022).
Q: There are 15 trees in the grove. Grove workers will plant trees in the grove today. After they are done, there will be 21 trees. How many trees did the grove workers plant today?
A: We start with 15 trees. Later we have 21 trees. The difference must be the number of trees they planted. So, they must have planted $21-15=6$ trees. The answer is 6 .</p>
<p>Q: If there are 3 cars in the parking lot and 2 more cars arrive, how many cars are in the parking lot?
A: There are 3 cars in the parking lot already. 2 more arrive. Now there are $3+2=5$ cars. The answer is 5 .
Q: Leah had 32 chocolates and her sister had 42. If they ate 35, how many pieces do they have left in total?
A: Leah had 32 chocolates and Leah's sister had 42. That means there were originally $32+42=74$ chocolates. 35 have been eaten. So in total they still have $74-35=39$ chocolates. The answer is 39 .</p>
<p>Q: Jason had 20 lollipops. He gave Denny some lollipops. Now Jason has 12 lollipops. How many lollipops did Jason give to Denny?
A: Jason had 20 lollipops. Since he only has 12 now, he must have given the rest to Denny. The number of lollipops he has given to Denny must have been $20-12=8$ lollipops. The answer is 8 .</p>
<p>Q: Shawn has five toys. For Christmas, he got two toys each from his mom and dad. How many toys does he have now?
A: He has 5 toys. He got 2 from mom, so after that he has $5+2=7$ toys. Then he got 2 more from dad, so in total he has $7+2=9$ toys. The answer is 9 .</p>
<p>Q: There were nine computers in the server room. Five more computers were installed each day, from monday to thursday. How many computers are now in the server room?
A: There are 4 days from monday to thursday. 5 computers were added each day. That means in total $4 * 5=$ 20 computers were added. There were 9 computers in the beginning, so now there are $9+20=29$ computers. The answer is 29 .</p>
<p>Q: Michael had 58 golf balls. On tuesday, he lost 23 golf balls. On wednesday, he lost 2 more. How many golf balls did he have at the end of wednesday?
A: Michael initially had 58 balls. He lost 23 on Tuesday, so after that he has $58-23=35$ balls. On Wednesday he lost 2 more so now he has $35-2=33$ balls. The answer is 33 .</p>
<p>Q: Olivia has $\$ 23$. She bought five bagels for $\$ 3$ each. How much money does she have left?
A: She bought 5 bagels for $\$ 3$ each. This means she spent $5 * \$ 3=\$ 15$ on the bagels. She had $\$ 23$ in beginning, so now she has $\$ 23-\$ 15=\$ 8$. The answer is 8 .</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{10}$ https://beta.openai.com/docs/api-reference/making-requests&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref5:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref6:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>