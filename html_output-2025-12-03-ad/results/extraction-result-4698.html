<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-4698 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-4698</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-4698</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-102.html">extraction-schema-102</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, performance, and failure modes.</div>
                <p><strong>Paper ID:</strong> paper-90abbc2cf38462b954ae1b772fac9532e2ccd8b0</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/90abbc2cf38462b954ae1b772fac9532e2ccd8b0" target="_blank">Language Models are Few-Shot Learners</a></p>
                <p><strong>Paper Venue:</strong> Neural Information Processing Systems</p>
                <p><strong>Paper TL;DR:</strong> GPT-3 achieves strong performance on many NLP datasets, including translation, question-answering, and cloze tasks, as well as several tasks that require on-the-fly reasoning or domain adaptation, such as unscrambling words, using a novel word in a sentence, or performing 3-digit arithmetic.</p>
                <p><strong>Paper Abstract:</strong> Recent work has demonstrated substantial gains on many NLP tasks and benchmarks by pre-training on a large corpus of text followed by fine-tuning on a specific task. While typically task-agnostic in architecture, this method still requires task-specific fine-tuning datasets of thousands or tens of thousands of examples. By contrast, humans can generally perform a new language task from only a few examples or from simple instructions - something which current NLP systems still largely struggle to do. Here we show that scaling up language models greatly improves task-agnostic, few-shot performance, sometimes even reaching competitiveness with prior state-of-the-art fine-tuning approaches. Specifically, we train GPT-3, an autoregressive language model with 175 billion parameters, 10x more than any previous non-sparse language model, and test its performance in the few-shot setting. For all tasks, GPT-3 is applied without any gradient updates or fine-tuning, with tasks and few-shot demonstrations specified purely via text interaction with the model. GPT-3 achieves strong performance on many NLP datasets, including translation, question-answering, and cloze tasks, as well as several tasks that require on-the-fly reasoning or domain adaptation, such as unscrambling words, using a novel word in a sentence, or performing 3-digit arithmetic. At the same time, we also identify some datasets where GPT-3's few-shot learning still struggles, as well as some datasets where GPT-3 faces methodological issues related to training on large web corpora. Finally, we find that GPT-3 can generate samples of news articles which human evaluators have difficulty distinguishing from articles written by humans. We discuss broader societal impacts of this finding and of GPT-3 in general.</p>
                <p><strong>Cost:</strong> 0.01</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e4698.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e4698.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, performance, and failure modes.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>GPT-3 arithmetic</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>GPT-3 arithmetic evaluation and observations</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>The paper evaluates GPT-3's ability to perform simple arithmetic in zero-, one-, and few-shot settings using a small battery of synthetic arithmetic tests (e.g. 2-digit addition/subtraction, 3-digit addition), and situates arithmetic performance within the broader phenomenon of in‑context learning and scale-driven improvements in language models.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>GPT-3</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Autoregressive transformer language model (GPT-2 architecture family) scaled to 175 billion parameters (96 layers, model width d_model=12288, 96 attention heads with d_head=128), trained on a mixed corpus (filtered Common Crawl plus WebText2, Books1/2, Wikipedia) for ~300B training tokens, context window of 2048 tokens; evaluated in zero-shot, one-shot, and few-shot (in-context) settings.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>Simple integer arithmetic: 2-digit addition (2D+), 2-digit subtraction (2D-), 3-digit addition (3D+) (paper describes a small battery of 10 related tests phrased as natural-language Q/A prompts).</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_hypothesis</strong></td>
                            <td>The paper frames arithmetic ability as an instance of in‑context learning/meta‑learning: the model either (a) uses pattern recognition and memorized regularities from pretraining or (b) learns an on‑the‑fly mapping from examples in the context window; the authors explicitly note the ambiguity between 'recognizing patterns seen during training' and 'learning new tasks at inference time' and do not claim a specific mechanistic circuit for arithmetic.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>Empirical evidence presented in the paper supports that (i) in‑context examples improve task performance (zero→one→few‑shot trend), and (ii) larger model scale markedly improves in‑context learning ability (figures show steeper in‑context learning curves for larger models). These general in‑context scaling patterns are offered as indirect evidence that arithmetic performance benefits from pattern recognition/meta‑learning encoded by model parameters and leveraged by contextual examples.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_against_mechanism</strong></td>
                            <td>The paper provides no direct mechanistic probes showing algorithmic arithmetic procedures (no neuron/circuit-level analysis). It also highlights that some reasoning/numeracy tasks remain challenging (e.g., DROP and other discrete reasoning benchmarks still lag specialized approaches), indicating that arithmetic ability is limited and not reliably algorithmic. The authors also caution about possible training data contamination for some benchmarks, complicating interpretation.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>The provided excerpt enumerates the arithmetic tasks and example prompt formats but does not report numeric accuracy/error metrics for these arithmetic tests. The paper elsewhere (outside the excerpt) refers to GPT-3 demonstrating capability on small‑scale arithmetic (e.g. 'performing 3‑digit arithmetic' in examples), but no specific performance numbers are present in the quoted text. (The paper does report related numeric reasoning results on DROP and other benchmarks, where GPT-3 improves with few‑shot but remains below specialized symbolic systems.)</td>
                        </tr>
                        <tr>
                            <td><strong>probing_or_intervention_results</strong></td>
                            <td>No probing, ablation, or targeted intervention results specifically diagnosing how GPT‑3 performs arithmetic are reported in the provided text. The paper includes broader analyses (e.g., scaling trends, data contamination checks) but does not present mechanistic probing for arithmetic (no neuron/attention probing, no circuit edits, no controlled ablations for arithmetic).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_and_failure_modes</strong></td>
                            <td>The paper emphasizes several limitations relevant to arithmetic: (1) ambiguity whether improvements reflect memorization vs. genuine algorithmic reasoning; (2) certain reasoning and numeracy tasks (e.g., DROP, some reading-comprehension datasets) remain substantially below SOTA, implying brittle numeric reasoning; (3) sensitivity to prompt formatting and number of in‑context examples (few‑shot helps but small models can degrade); (4) potential contamination of training data can inflate apparent capabilities on some benchmarks; (5) no evidence is provided for systematic generalization to arbitrarily large digit lengths or multi-step arithmetic.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_other_models</strong></td>
                            <td>The paper compares multiple GPT‑3-sized variants (125M up to 175B) and reports smooth scaling: arithmetic-like in‑context tasks improve with model size and with the number of examples in context. It does not provide detailed side‑by‑side arithmetic accuracy comparisons to other published models in the provided excerpt, nor mechanistic comparisons; related comparisons are made at a higher level for tasks like translation and closed-book QA.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Language Models are Few-Shot Learners', 'publication_date_yy_mm': '2020-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Language Models are Unsupervised Multitask Learners <em>(Rating: 2)</em></li>
                <li>Scaling Laws for Neural Language Models <em>(Rating: 2)</em></li>
                <li>Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-4698",
    "paper_id": "paper-90abbc2cf38462b954ae1b772fac9532e2ccd8b0",
    "extraction_schema_id": "extraction-schema-102",
    "extracted_data": [
        {
            "name_short": "GPT-3 arithmetic",
            "name_full": "GPT-3 arithmetic evaluation and observations",
            "brief_description": "The paper evaluates GPT-3's ability to perform simple arithmetic in zero-, one-, and few-shot settings using a small battery of synthetic arithmetic tests (e.g. 2-digit addition/subtraction, 3-digit addition), and situates arithmetic performance within the broader phenomenon of in‑context learning and scale-driven improvements in language models.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "GPT-3",
            "model_description": "Autoregressive transformer language model (GPT-2 architecture family) scaled to 175 billion parameters (96 layers, model width d_model=12288, 96 attention heads with d_head=128), trained on a mixed corpus (filtered Common Crawl plus WebText2, Books1/2, Wikipedia) for ~300B training tokens, context window of 2048 tokens; evaluated in zero-shot, one-shot, and few-shot (in-context) settings.",
            "arithmetic_task_type": "Simple integer arithmetic: 2-digit addition (2D+), 2-digit subtraction (2D-), 3-digit addition (3D+) (paper describes a small battery of 10 related tests phrased as natural-language Q/A prompts).",
            "mechanism_hypothesis": "The paper frames arithmetic ability as an instance of in‑context learning/meta‑learning: the model either (a) uses pattern recognition and memorized regularities from pretraining or (b) learns an on‑the‑fly mapping from examples in the context window; the authors explicitly note the ambiguity between 'recognizing patterns seen during training' and 'learning new tasks at inference time' and do not claim a specific mechanistic circuit for arithmetic.",
            "evidence_for_mechanism": "Empirical evidence presented in the paper supports that (i) in‑context examples improve task performance (zero→one→few‑shot trend), and (ii) larger model scale markedly improves in‑context learning ability (figures show steeper in‑context learning curves for larger models). These general in‑context scaling patterns are offered as indirect evidence that arithmetic performance benefits from pattern recognition/meta‑learning encoded by model parameters and leveraged by contextual examples.",
            "evidence_against_mechanism": "The paper provides no direct mechanistic probes showing algorithmic arithmetic procedures (no neuron/circuit-level analysis). It also highlights that some reasoning/numeracy tasks remain challenging (e.g., DROP and other discrete reasoning benchmarks still lag specialized approaches), indicating that arithmetic ability is limited and not reliably algorithmic. The authors also caution about possible training data contamination for some benchmarks, complicating interpretation.",
            "performance_metrics": "The provided excerpt enumerates the arithmetic tasks and example prompt formats but does not report numeric accuracy/error metrics for these arithmetic tests. The paper elsewhere (outside the excerpt) refers to GPT-3 demonstrating capability on small‑scale arithmetic (e.g. 'performing 3‑digit arithmetic' in examples), but no specific performance numbers are present in the quoted text. (The paper does report related numeric reasoning results on DROP and other benchmarks, where GPT-3 improves with few‑shot but remains below specialized symbolic systems.)",
            "probing_or_intervention_results": "No probing, ablation, or targeted intervention results specifically diagnosing how GPT‑3 performs arithmetic are reported in the provided text. The paper includes broader analyses (e.g., scaling trends, data contamination checks) but does not present mechanistic probing for arithmetic (no neuron/attention probing, no circuit edits, no controlled ablations for arithmetic).",
            "limitations_and_failure_modes": "The paper emphasizes several limitations relevant to arithmetic: (1) ambiguity whether improvements reflect memorization vs. genuine algorithmic reasoning; (2) certain reasoning and numeracy tasks (e.g., DROP, some reading-comprehension datasets) remain substantially below SOTA, implying brittle numeric reasoning; (3) sensitivity to prompt formatting and number of in‑context examples (few‑shot helps but small models can degrade); (4) potential contamination of training data can inflate apparent capabilities on some benchmarks; (5) no evidence is provided for systematic generalization to arbitrarily large digit lengths or multi-step arithmetic.",
            "comparison_to_other_models": "The paper compares multiple GPT‑3-sized variants (125M up to 175B) and reports smooth scaling: arithmetic-like in‑context tasks improve with model size and with the number of examples in context. It does not provide detailed side‑by‑side arithmetic accuracy comparisons to other published models in the provided excerpt, nor mechanistic comparisons; related comparisons are made at a higher level for tasks like translation and closed-book QA.",
            "uuid": "e4698.0",
            "source_info": {
                "paper_title": "Language Models are Few-Shot Learners",
                "publication_date_yy_mm": "2020-05"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Language Models are Unsupervised Multitask Learners",
            "rating": 2
        },
        {
            "paper_title": "Scaling Laws for Neural Language Models",
            "rating": 2
        },
        {
            "paper_title": "Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer",
            "rating": 1
        }
    ],
    "cost": 0.009895999999999999,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Language Models are Few-Shot Learners</h1>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<h2>Abstract</h2>
<p>Recent work has demonstrated substantial gains on many NLP tasks and benchmarks by pre-training on a large corpus of text followed by fine-tuning on a specific task. While typically task-agnostic in architecture, this method still requires task-specific fine-tuning datasets of thousands or tens of thousands of examples. By contrast, humans can generally perform a new language task from only a few examples or from simple instructions - something which current NLP systems still largely struggle to do. Here we show that scaling up language models greatly improves task-agnostic, few-shot performance, sometimes even reaching competitiveness with prior state-of-the-art finetuning approaches. Specifically, we train GPT-3, an autoregressive language model with 175 billion parameters, 10x more than any previous non-sparse language model, and test its performance in the few-shot setting. For all tasks, GPT-3 is applied without any gradient updates or fine-tuning, with tasks and few-shot demonstrations specified purely via text interaction with the model. GPT-3 achieves strong performance on many NLP datasets, including translation, question-answering, and cloze tasks, as well as several tasks that require on-the-fly reasoning or domain adaptation, such as unscrambling words, using a novel word in a sentence, or performing 3-digit arithmetic. At the same time, we also identify some datasets where GPT-3's few-shot learning still struggles, as well as some datasets where GPT-3 faces methodological issues related to training on large web corpora. Finally, we find that GPT-3 can generate samples of news articles which human evaluators have difficulty distinguishing from articles written by humans. We discuss broader societal impacts of this finding and of GPT-3 in general.</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<h1>Contents</h1>
<p>1 Introduction ..... 3
2 Approach ..... 6
2.1 Model and Architectures ..... 8
2.2 Training Dataset ..... 8
2.3 Training Process ..... 9
2.4 Evaluation ..... 10
3 Results ..... 10
3.1 Language Modeling, Cloze, and Completion Tasks ..... 11
3.2 Closed Book Question Answering ..... 13
3.3 Translation ..... 14
3.4 Winograd-Style Tasks ..... 16
3.5 Common Sense Reasoning ..... 17
3.6 Reading Comprehension ..... 18
3.7 SuperGLUE ..... 18
3.8 NLI ..... 20
3.9 Synthetic and Qualitative Tasks ..... 21
4 Measuring and Preventing Memorization Of Benchmarks ..... 29
5 Limitations ..... 33
6 Broader Impacts ..... 34
6.1 Misuse of Language Models ..... 35
6.2 Fairness, Bias, and Representation ..... 36
6.3 Energy Usage ..... 39
7 Related Work ..... 39
8 Conclusion ..... 40
A Details of Common Crawl Filtering ..... 43
B Details of Model Training ..... 43
C Details of Test Set Contamination Studies ..... 43
D Total Compute Used to Train Language Models ..... 46
E Human Quality Assessment of Synthetic News Articles ..... 46
F Additional Samples from GPT-3 ..... 48
G Details of Task Phrasing and Specifications ..... 50
H Results on All Tasks for All Model Sizes ..... 63</p>
<h1>1 Introduction</h1>
<p>Recent years have featured a trend towards pre-trained language representations in NLP systems, applied in increasingly flexible and task-agnostic ways for downstream transfer. First, single-layer representations were learned using word vectors [MCCD13, PSM14] and fed to task-specific architectures, then RNNs with multiple layers of representations and contextual state were used to form stronger representations [DL15, MBXS17, PNZiY18] (though still applied to task-specific architectures), and more recently pre-trained recurrent or transformer language models [VSP ${ }^{+} 17$ ] have been directly fine-tuned, entirely removing the need for task-specific architectures [RNSS18, DCLT18, HR18].
This last paradigm has led to substantial progress on many challenging NLP tasks such as reading comprehension, question answering, textual entailment, and many others, and has continued to advance based on new architectures and algorithms [RSR ${ }^{+} 19$, LOG $^{+} 19$, YDY $^{+} 19$, LCG $^{+} 19$ ]. However, a major limitation to this approach is that while the architecture is task-agnostic, there is still a need for task-specific datasets and task-specific fine-tuning: to achieve strong performance on a desired task typically requires fine-tuning on a dataset of thousands to hundreds of thousands of examples specific to that task. Removing this limitation would be desirable, for several reasons.
First, from a practical perspective, the need for a large dataset of labeled examples for every new task limits the applicability of language models. There exists a very wide range of possible useful language tasks, encompassing anything from correcting grammar, to generating examples of an abstract concept, to critiquing a short story. For many of these tasks it is difficult to collect a large supervised training dataset, especially when the process must be repeated for every new task.
Second, the potential to exploit spurious correlations in training data fundamentally grows with the expressiveness of the model and the narrowness of the training distribution. This can create problems for the pre-training plus fine-tuning paradigm, where models are designed to be large to absorb information during pre-training, but are then fine-tuned on very narrow task distributions. For instance [HLW +20 ] observe that larger models do not necessarily generalize better out-of-distribution. There is evidence that suggests that the generalization achieved under this paradigm can be poor because the model is overly specific to the training distribution and does not generalize well outside it [YdC +19 , MPL19]. Thus, the performance of fine-tuned models on specific benchmarks, even when it is nominally at human-level, may exaggerate actual performance on the underlying task [GSL +18 , NK19].
Third, humans do not require large supervised datasets to learn most language tasks - a brief directive in natural language (e.g. "please tell me if this sentence describes something happy or something sad") or at most a tiny number of demonstrations (e.g. "here are two examples of people acting brave; please give a third example of bravery") is often
<img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 1.1: Language model meta-learning. During unsupervised pre-training, a language model develops a broad set of skills and pattern recognition abilities. It then uses these abilities at inference time to rapidly adapt to or recognize the desired task. We use the term "in-context learning" to describe the inner loop of this process, which occurs within the forward-pass upon each sequence. The sequences in this diagram are not intended to be representative of the data a model would see during pre-training, but are intended to show that there are sometimes repeated sub-tasks embedded within a single sequence.</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 1.2: Larger models make increasingly efficient use of in-context information. We show in-context learning performance on a simple task requiring the model to remove random symbols from a word, both with and without a natural language task description (see Sec. 3.9.2). The steeper "in-context learning curves" for large models demonstrate improved ability to learn a task from contextual information. We see qualitatively similar behavior across a wide range of tasks.
sufficient to enable a human to perform a new task to at least a reasonable degree of competence. Aside from pointing to a conceptual limitation in our current NLP techniques, this adaptability has practical advantages - it allows humans to seamlessly mix together or switch between many tasks and skills, for example performing addition during a lengthy dialogue. To be broadly useful, we would someday like our NLP systems to have this same fluidity and generality.
One potential route towards addressing these issues is meta-learning ${ }^{1}$ - which in the context of language models means the model develops a broad set of skills and pattern recognition abilities at training time, and then uses those abilities at inference time to rapidly adapt to or recognize the desired task (illustrated in Figure 1.1). Recent work [RWC ${ }^{+}$19] attempts to do this via what we call "in-context learning", using the text input of a pretrained language model as a form of task specification: the model is conditioned on a natural language instruction and/or a few demonstrations of the task and is then expected to complete further instances of the task simply by predicting what comes next.
While it has shown some initial promise, this approach still achieves results far inferior to fine-tuning - for example [RWC ${ }^{+}$19] achieves only $4 \%$ on Natural Questions, and even its 55 F1 CoQa result is now more than 35 points behind the state of the art. Meta-learning clearly requires substantial improvement in order to be viable as a practical method of solving language tasks.
Another recent trend in language modeling may offer a way forward. In recent years the capacity of transformer language models has increased substantially, from 100 million parameters [RNSS18], to 300 million parameters [DCLT18], to 1.5 billion parameters [RWC ${ }^{+}$19], to 8 billion parameters [SPP ${ }^{+}$19], 11 billion parameters [RSR ${ }^{+}$19], and finally 17 billion parameters [Tur20]. Each increase has brought improvements in text synthesis and/or downstream NLP tasks, and there is evidence suggesting that log loss, which correlates well with many downstream tasks, follows a smooth trend of improvement with scale [ $\mathrm{KMH}^{+}$20]. Since in-context learning involves absorbing many skills and tasks within the parameters of the model, it is plausible that in-context learning abilities might show similarly strong gains with scale.</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 1.3: Aggregate performance for all 42 accuracy-denominated benchmarks While zero-shot performance improves steadily with model size, few-shot performance increases more rapidly, demonstrating that larger models are more proficient at in-context learning. See Figure 3.8 for a more detailed analysis on SuperGLUE, a standard NLP benchmark suite.</p>
<p>In this paper, we test this hypothesis by training a 175 billion parameter autoregressive language model, which we call GPT-3, and measuring its in-context learning abilities. Specifically, we evaluate GPT-3 on over two dozen NLP datasets, as well as several novel tasks designed to test rapid adaptation to tasks unlikely to be directly contained in the training set. For each task, we evaluate GPT-3 under 3 conditions: (a) "few-shot learning", or in-context learning where we allow as many demonstrations as will fit into the model's context window (typically 10 to 100), (b) "one-shot learning", where we allow only one demonstration, and (c) "zero-shot" learning, where no demonstrations are allowed and only an instruction in natural language is given to the model. GPT-3 could also in principle be evaluated in the traditional fine-tuning setting, but we leave this to future work.</p>
<p>Figure 1.2 illustrates the conditions we study, and shows few-shot learning of a simple task requiring the model to remove extraneous symbols from a word. Model performance improves with the addition of a natural language task description, and with the number of examples in the model's context, $K$. Few-shot learning also improves dramatically with model size. Though the results in this case are particularly striking, the general trends with both model size and number of examples in-context hold for most tasks we study. We emphasize that these "learning" curves involve no gradient updates or fine-tuning, just increasing numbers of demonstrations given as conditioning.
Broadly, on NLP tasks GPT-3 achieves promising results in the zero-shot and one-shot settings, and in the the few-shot setting is sometimes competitive with or even occasionally surpasses state-of-the-art (despite state-of-the-art being held by fine-tuned models). For example, GPT-3 achieves 81.5 F1 on CoQA in the zero-shot setting, 84.0 F1 on CoQA in the one-shot setting, 85.0 F1 in the few-shot setting. Similarly, GPT-3 achieves $64.3 \%$ accuracy on TriviaQA in the zero-shot setting, $68.0 \%$ in the one-shot setting, and $71.2 \%$ in the few-shot setting, the last of which is state-of-the-art relative to fine-tuned models operating in the same closed-book setting.
GPT-3 also displays one-shot and few-shot proficiency at tasks designed to test rapid adaption or on-the-fly reasoning, which include unscrambling words, performing arithmetic, and using novel words in a sentence after seeing them defined only once. We also show that in the few-shot setting, GPT-3 can generate synthetic news articles which human evaluators have difficulty distinguishing from human-generated articles.
At the same time, we also find some tasks on which few-shot performance struggles, even at the scale of GPT-3. This includes natural language inference tasks like the ANLI dataset, and some reading comprehension datasets like RACE or QuAC. By presenting a broad characterization of GPT-3's strengths and weaknesses, including these limitations, we hope to stimulate study of few-shot learning in language models and draw attention to where progress is most needed.
A heuristic sense of the overall results can be seen in Figure 1.3, which aggregates the various tasks (though it should not be seen as a rigorous or meaningful benchmark in itself).</p>
<p>We also undertake a systematic study of "data contamination" - a growing problem when training high capacity models on datasets such as Common Crawl, which can potentially include content from test datasets simply because such content often exists on the web. In this paper we develop systematic tools to measure data contamination and quantify its distorting effects. Although we find that data contamination has a minimal effect on GPT-3's performance on most datasets, we do identify a few datasets where it could be inflating results, and we either do not report results on these datasets or we note them with an asterisk, depending on the severity.</p>
<p>In addition to all the above, we also train a series of smaller models (ranging from 125 million parameters to 13 billion parameters) in order to compare their performance to GPT-3 in the zero, one and few-shot settings. Broadly, for most tasks we find relatively smooth scaling with model capacity in all three settings; one notable pattern is that the gap between zero-, one-, and few-shot performance often grows with model capacity, perhaps suggesting that larger models are more proficient meta-learners.</p>
<p>Finally, given the broad spectrum of capabilities displayed by GPT-3, we discuss concerns about bias, fairness, and broader societal impacts, and attempt a preliminary analysis of GPT-3's characteristics in this regard.</p>
<p>The remainder of this paper is organized as follows. In Section 2, we describe our approach and methods for training GPT-3 and evaluating it. Section 3 presents results on the full range of tasks in the zero-, one- and few-shot settings. Section 4 addresses questions of data contamination (train-test overlap). Section 5 discusses limitations of GPT-3. Section 6 discusses broader impacts. Section 7 reviews related work and Section 8 concludes.</p>
<h1>2 Approach</h1>
<p>Our basic pre-training approach, including model, data, and training, is similar to the process described in [RWC ${ }^{+}$19], with relatively straightforward scaling up of the model size, dataset size and diversity, and length of training. Our use of in-context learning is also similar to [RWC ${ }^{+}$19], but in this work we systematically explore different settings for learning within the context. Therefore, we start this section by explicitly defining and contrasting the different settings that we will be evaluating GPT-3 on or could in principle evaluate GPT-3 on. These settings can be seen as lying on a spectrum of how much task-specific data they tend to rely on. Specifically, we can identify at least four points on this spectrum (see Figure 2.1 for an illustration):</p>
<ul>
<li>Fine-Tuning (FT) has been the most common approach in recent years, and involves updating the weights of a pre-trained model by training on a supervised dataset specific to the desired task. Typically thousands to hundreds of thousands of labeled examples are used. The main advantage of fine-tuning is strong performance on many benchmarks. The main disadvantages are the need for a new large dataset for every task, the potential for poor generalization out-of-distribution [MPL19], and the potential to exploit spurious features of the training data [GSL +18 , NK19], potentially resulting in an unfair comparison with human performance. In this work we do not fine-tune GPT-3 because our focus is on task-agnostic performance, but GPT-3 can be fine-tuned in principle and this is a promising direction for future work.</li>
<li>Few-Shot (FS) is the term we will use in this work to refer to the setting where the model is given a few demonstrations of the task at inference time as conditioning [ $\mathrm{RWC}^{+}$19], but no weight updates are allowed. As shown in Figure 2.1, for a typical dataset an example has a context and a desired completion (for example an English sentence and the French translation), and few-shot works by giving $K$ examples of context and completion, and then one final example of context, with the model expected to provide the completion. We typically set $K$ in the range of 10 to 100 as this is how many examples can fit in the model's context window $\left(n_{\text {ctx }}=2048\right)$. The main advantages of few-shot are a major reduction in the need for task-specific data and reduced potential to learn an overly narrow distribution from a large but narrow fine-tuning dataset. The main disadvantage is that results from this method have so far been much worse than state-of-the-art fine-tuned models. Also, a small amount of task specific data is still required. As indicated by the name, few-shot learning as described here for language models is related to few-shot learning as used in other contexts in ML [HYC01, VBL +16$]$ - both involve learning based on a broad distribution of tasks (in this case implicit in the pre-training data) and then rapidly adapting to a new task.</li>
<li>One-Shot (1S) is the same as few-shot except that only one demonstration is allowed, in addition to a natural language description of the task, as shown in Figure 1. The reason to distinguish one-shot from few-shot and zero-shot (below) is that it most closely matches the way in which some tasks are communicated to humans. For example, when asking humans to generate a dataset on a human worker service (for example Mechanical Turk), it is common to give one demonstration of the task. By contrast it is sometimes difficult to communicate the content or format of a task if no examples are given.</li>
</ul>
<p><img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 2.1: Zero-shot, one-shot and few-shot, contrasted with traditional fine-tuning. The panels above show four methods for performing a task with a language model - fine-tuning is the traditional method, whereas zero-, one-, and few-shot, which we study in this work, require the model to perform the task with only forward passes at test time. We typically present the model with a few dozen examples in the few shot setting. Exact phrasings for all task descriptions, examples and prompts can be found in Appendix G.</p>
<ul>
<li>Zero-Shot (0S) is the same as one-shot except that no demonstrations are allowed, and the model is only given a natural language instruction describing the task. This method provides maximum convenience, potential for robustness, and avoidance of spurious correlations (unless they occur very broadly across the large corpus of pre-training data), but is also the most challenging setting. In some cases it may even be difficult for humans to understand the format of the task without prior examples, so this setting is in some cases "unfairly hard". For example, if someone is asked to "make a table of world records for the 200 m dash", this request can be ambiguous, as it may not be clear exactly what format the table should have or what should be included (and even with careful clarification, understanding precisely what is desired can be difficult). Nevertheless, for at least some settings zero-shot is closest to how humans perform tasks - for example, in the translation example in Figure 2.1, a human would likely know what to do from just the text instruction.</li>
</ul>
<p>Figure 2.1 shows the four methods using the example of translating English to French. In this paper we focus on zero-shot, one-shot and few-shot, with the aim of comparing them not as competing alternatives, but as different problem settings which offer a varying trade-off between performance on specific benchmarks and sample efficiency. We especially highlight the few-shot results as many of them are only slightly behind state-of-the-art fine-tuned models. Ultimately, however, one-shot, or even sometimes zero-shot, seem like the fairest comparisons to human performance, and are important targets for future work.
Sections 2.1-2.3 below give details on our models, training data, and training process respectively. Section 2.4 discusses the details of how we do few-shot, one-shot, and zero-shot evaluations.</p>
<table>
<thead>
<tr>
<th>Model Name</th>
<th>$n_{\text {params }}$</th>
<th>$n_{\text {layers }}$</th>
<th>$d_{\text {model }}$</th>
<th>$n_{\text {heads }}$</th>
<th>$d_{\text {head }}$</th>
<th>Batch Size</th>
<th>Learning Rate</th>
</tr>
</thead>
<tbody>
<tr>
<td>GPT-3 Small</td>
<td>125M</td>
<td>12</td>
<td>768</td>
<td>12</td>
<td>64</td>
<td>0.5M</td>
<td>$6.0 \times 10^{-4}$</td>
</tr>
<tr>
<td>GPT-3 Medium</td>
<td>350M</td>
<td>24</td>
<td>1024</td>
<td>16</td>
<td>64</td>
<td>0.5M</td>
<td>$3.0 \times 10^{-4}$</td>
</tr>
<tr>
<td>GPT-3 Large</td>
<td>760M</td>
<td>24</td>
<td>1536</td>
<td>16</td>
<td>96</td>
<td>0.5M</td>
<td>$2.5 \times 10^{-4}$</td>
</tr>
<tr>
<td>GPT-3 XL</td>
<td>1.3B</td>
<td>24</td>
<td>2048</td>
<td>24</td>
<td>128</td>
<td>1M</td>
<td>$2.0 \times 10^{-4}$</td>
</tr>
<tr>
<td>GPT-3 2.7B</td>
<td>2.7B</td>
<td>32</td>
<td>2560</td>
<td>32</td>
<td>80</td>
<td>1M</td>
<td>$1.6 \times 10^{-4}$</td>
</tr>
<tr>
<td>GPT-3 6.7B</td>
<td>6.7B</td>
<td>32</td>
<td>4096</td>
<td>32</td>
<td>128</td>
<td>2M</td>
<td>$1.2 \times 10^{-4}$</td>
</tr>
<tr>
<td>GPT-3 13B</td>
<td>13.0B</td>
<td>40</td>
<td>5140</td>
<td>40</td>
<td>128</td>
<td>2M</td>
<td>$1.0 \times 10^{-4}$</td>
</tr>
<tr>
<td>GPT-3 175B or "GPT-3"</td>
<td>175.0B</td>
<td>96</td>
<td>12288</td>
<td>96</td>
<td>128</td>
<td>3.2M</td>
<td>$0.6 \times 10^{-4}$</td>
</tr>
</tbody>
</table>
<p>Table 2.1: Sizes, architectures, and learning hyper-parameters (batch size in tokens and learning rate) of the models which we trained. All models were trained for a total of 300 billion tokens.</p>
<h1>2.1 Model and Architectures</h1>
<p>We use the same model and architecture as GPT-2 [RWC ${ }^{+}$19], including the modified initialization, pre-normalization, and reversible tokenization described therein, with the exception that we use alternating dense and locally banded sparse attention patterns in the layers of the transformer, similar to the Sparse Transformer [CGRS19]. To study the dependence of ML performance on model size, we train 8 different sizes of model, ranging over three orders of magnitude from 125 million parameters to 175 billion parameters, with the last being the model we call GPT-3. Previous work [ $\mathrm{KMH}^{+}$20] suggests that with enough training data, scaling of validation loss should be approximately a smooth power law as a function of size; training models of many different sizes allows us to test this hypothesis both for validation loss and for downstream language tasks.</p>
<p>Table 2.1 shows the sizes and architectures of our 8 models. Here $n_{\text {params }}$ is the total number of trainable parameters, $n_{\text {layers }}$ is the total number of layers, $d_{\text {model }}$ is the number of units in each bottleneck layer (we always have the feedforward layer four times the size of the bottleneck layer, $d_{\text {ff }}=4 * d_{\text {model }}$ ), and $d_{\text {head }}$ is the dimension of each attention head. All models use a context window of $n_{\mathrm{ctx}}=2048$ tokens. We partition the model across GPUs along both the depth and width dimension in order to minimize data-transfer between nodes. The precise architectural parameters for each model are chosen based on computational efficiency and load-balancing in the layout of models across GPU's. Previous work [ $\mathrm{KMH}^{+}$20] suggests that validation loss is not strongly sensitive to these parameters within a reasonably broad range.</p>
<h3>2.2 Training Dataset</h3>
<p>Datasets for language models have rapidly expanded, culminating in the Common Crawl dataset ${ }^{2}$ [RSR ${ }^{+}$19] constituting nearly a trillion words. This size of dataset is sufficient to train our largest models without ever updating on the same sequence twice. However, we have found that unfiltered or lightly filtered versions of Common Crawl tend to have lower quality than more curated datasets. Therefore, we took 3 steps to improve the average quality of our datasets: (1) we downloaded and filtered a version of CommonCrawl based on similarity to a range of high-quality reference corpora, (2) we performed fuzzy deduplication at the document level, within and across datasets, to prevent redundancy and preserve the integrity of our held-out validation set as an accurate measure of overfitting, and (3) we also added known high-quality reference corpora to the training mix to augment CommonCrawl and increase its diversity.
Details of the first two points (processing of Common Crawl) are described in Appendix A. For the third, we added several curated high-quality datasets, including an expanded version of the WebText dataset [RWC ${ }^{+}$19], collected by scraping links over a longer period of time, and first described in [ $\mathrm{KMH}^{+}$20], two internet-based books corpora (Books1 and Books2) and English-language Wikipedia.
Table 2.2 shows the final mixture of datasets that we used in training. The CommonCrawl data was downloaded from 41 shards of monthly CommonCrawl covering 2016 to 2019, constituting 45TB of compressed plaintext before filtering and 570 GB after filtering, roughly equivalent to 400 billion byte-pair-encoded tokens. Note that during training, datasets are not sampled in proportion to their size, but rather datasets we view as higher-quality are sampled more frequently, such that CommonCrawl and Books2 datasets are sampled less than once during training, but the other datasets are sampled 2-3 times. This essentially accepts a small amount of overfitting in exchange for higher quality training data.</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>Figure 2.2: Total compute used during training. Based on the analysis in Scaling Laws For Neural Language Models [ $\mathrm{KMH}^{+}$20] we train much larger models on many fewer tokens than is typical. As a consequence, although GPT-3 3B is almost 10x larger than RoBERTa-Large ( 355 M params), both models took roughly 50 petaflop/s-days of compute during pre-training. Methodology for these calculations can be found in Appendix D.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Dataset</th>
<th style="text-align: center;">Quantity <br> (tokens)</th>
<th style="text-align: center;">Weight in <br> training mix</th>
<th style="text-align: center;">Epochs elapsed when <br> training for 300B tokens</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Common Crawl (filtered)</td>
<td style="text-align: center;">410 billion</td>
<td style="text-align: center;">$60 \%$</td>
<td style="text-align: center;">0.44</td>
</tr>
<tr>
<td style="text-align: left;">WebText2</td>
<td style="text-align: center;">19 billion</td>
<td style="text-align: center;">$22 \%$</td>
<td style="text-align: center;">2.9</td>
</tr>
<tr>
<td style="text-align: left;">Books1</td>
<td style="text-align: center;">12 billion</td>
<td style="text-align: center;">$8 \%$</td>
<td style="text-align: center;">1.9</td>
</tr>
<tr>
<td style="text-align: left;">Books2</td>
<td style="text-align: center;">55 billion</td>
<td style="text-align: center;">$8 \%$</td>
<td style="text-align: center;">0.43</td>
</tr>
<tr>
<td style="text-align: left;">Wikipedia</td>
<td style="text-align: center;">3 billion</td>
<td style="text-align: center;">$3 \%$</td>
<td style="text-align: center;">3.4</td>
</tr>
</tbody>
</table>
<p>Table 2.2: Datasets used to train GPT-3. "Weight in training mix" refers to the fraction of examples during training that are drawn from a given dataset, which we intentionally do not make proportional to the size of the dataset. As a result, when we train for 300 billion tokens, some datasets are seen up to 3.4 times during training while other datasets are seen less than once.</p>
<p>A major methodological concern with language models pretrained on a broad swath of internet data, particularly large models with the capacity to memorize vast amounts of content, is potential contamination of downstream tasks by having their test or development sets inadvertently seen during pre-training. To reduce such contamination, we searched for and attempted to remove any overlaps with the development and test sets of all benchmarks studied in this paper. Unfortunately, a bug in the filtering caused us to ignore some overlaps, and due to the cost of training it was not feasible to retrain the model. In Section 4 we characterize the impact of the remaining overlaps, and in future work we will more aggressively remove data contamination.</p>
<h1>2.3 Training Process</h1>
<p>As found in [ $\mathrm{KMH}^{+}$20, MKAT18], larger models can typically use a larger batch size, but require a smaller learning rate. We measure the gradient noise scale during training and use it to guide our choice of batch size [MKAT18]. Table 2.1 shows the parameter settings we used. To train the larger models without running out of memory, we use a mixture of model parallelism within each matrix multiply and model parallelism across the layers of the network. All models were trained on V100 GPU's on part of a high-bandwidth cluster provided by Microsoft. Details of the training process and hyperparameter settings are described in Appendix B.</p>
<h1>2.4 Evaluation</h1>
<p>For few-shot learning, we evaluate each example in the evaluation set by randomly drawing $K$ examples from that task's training set as conditioning, delimited by 1 or 2 newlines depending on the task. For LAMBADA and Storycloze there is no supervised training set available so we draw conditioning examples from the development set and evaluate on the test set. For Winograd (the original, not SuperGLUE version) there is only one dataset, so we draw conditioning examples directly from it.
$K$ can be any value from 0 to the maximum amount allowed by the model's context window, which is $n_{\text {ctx }}=2048$ for all models and typically fits 10 to 100 examples. Larger values of $K$ are usually but not always better, so when a separate development and test set are available, we experiment with a few values of $K$ on the development set and then run the best value on the test set. For some tasks (see Appendix G) we also use a natural language prompt in addition to (or for $K=0$, instead of) demonstrations.
On tasks that involve choosing one correct completion from several options (multiple choice), we provide $K$ examples of context plus correct completion, followed by one example of context only, and compare the LM likelihood of each completion. For most tasks we compare the per-token likelihood (to normalize for length), however on a small number of datasets (ARC, OpenBookQA, and RACE) we gain additional benefit as measured on the development set by normalizing by the unconditional probability of each completion, by computing $\frac{P(\text { completion }|\text { context })}{P(\text { completion }|\text { answer } \text {, context })} \text {, where }$ answer_context is the string "Answer: " or "A: " and is used to prompt that the completion should be an answer but is otherwise generic.
On tasks that involve binary classification, we give the options more semantically meaningful names (e.g. "True" or "False" rather than 0 or 1 ) and then treat the task like multiple choice; we also sometimes frame the task similar to what is done by [RSR+19] (see Appendix G) for details.
On tasks with free-form completion, we use beam search with the same parameters as [RSR+19]: a beam width of 4 and a length penalty of $\alpha=0.6$. We score the model using F1 similarity score, BLEU, or exact match, depending on what is standard for the dataset at hand.
Final results are reported on the test set when publicly available, for each model size and learning setting (zero-, one-, and few-shot). When the test set is private, our model is often too large to fit on the test server, so we report results on the development set. We do submit to the test server on a small number of datasets (SuperGLUE, TriviaQA, PiQa) where we were able to make submission work, and we submit only the 200B few-shot results, and report development set results for everything else.</p>
<h2>3 Results</h2>
<p>In Figure 3.1 we display training curves for the 8 models described in Section 2. For this graph we also include 6 additional extra-small models with as few as 100,000 parameters. As observed in [ $\mathrm{KMH}^{+}$20], language modeling performance follows a power-law when making efficient use of training compute. After extending this trend by two more orders of magnitude, we observe only a slight (if any) departure from the power-law. One might worry that these improvements in cross-entropy loss come only from modeling spurious details of our training corpus. However, we will see in the following sections that improvements in cross-entropy loss lead to consistent performance gains across a broad spectrum of natural language tasks.
Below, we evaluate the 8 models described in Section 2 (the 175 billion parameter parameter GPT-3 and 7 smaller models) on a wide range of datasets. We group the datasets into 9 categories representing roughly similar tasks.
In Section 3.1 we evaluate on traditional language modeling tasks and tasks that are similar to language modeling, such as Cloze tasks and sentence/paragraph completion tasks. In Section 3.2 we evaluate on "closed book" question answering tasks: tasks which require using the information stored in the model's parameters to answer general knowledge questions. In Section 3.3 we evaluate the model's ability to translate between languages (especially one-shot and few-shot). In Section 3.4 we evaluate the model's performance on Winograd Schema-like tasks. In Section 3.5 we evaluate on datasets that involve commonsense reasoning or question answering. In Section 3.6 we evaluate on reading comprehension tasks, in Section 3.7 we evaluate on the SuperGLUE benchmark suite, and in 3.8 we briefly explore NLI. Finally, in Section 3.9, we invent some additional tasks designed especially to probe in-context learning abilities these tasks focus on on-the-fly reasoning, adaptation skills, or open-ended text synthesis. We evaluate all tasks in the few-shot, one-shot, and zero-shot settings.</p>
<p><img alt="img-6.jpeg" src="img-6.jpeg" /></p>
<p>Figure 3.1: Smooth scaling of performance with compute. Performance (measured in terms of cross-entropy validation loss) follows a power-law trend with the amount of compute used for training. The power-law behavior observed in $\left[\mathrm{KMH}^{+} 20\right]$ continues for an additional two orders of magnitude with only small deviations from the predicted curve. For this figure, we exclude embedding parameters from compute and parameter counts.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Setting</th>
<th style="text-align: left;">PTB</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">SOTA (Zero-Shot)</td>
<td style="text-align: left;">$35.8^{a}$</td>
</tr>
<tr>
<td style="text-align: left;">GPT-3 Zero-Shot</td>
<td style="text-align: left;">$\mathbf{2 0 . 5}$</td>
</tr>
</tbody>
</table>
<p>Table 3.1: Zero-shot results on PTB language modeling dataset. Many other common language modeling datasets are omitted because they are derived from Wikipedia or other sources which are included in GPT-3's training data. ${ }^{a}\left[\mathrm{RWC}^{+} 19\right]$</p>
<h1>3.1 Language Modeling, Cloze, and Completion Tasks</h1>
<p>In this section we test GPT-3's performance on the traditional task of language modeling, as well as related tasks that involve predicting a single word of interest, completing a sentence or paragraph, or choosing between possible completions of a piece of text.</p>
<h3>3.1.1 Language Modeling</h3>
<p>We calculate zero-shot perplexity on the Penn Tree Bank (PTB) [MKM ${ }^{+} 94$ ] dataset measured in [RWC ${ }^{+} 19$ ]. We omit the 4 Wikipedia-related tasks in that work because they are entirely contained in our training data, and we also omit the one-billion word benchmark due to a high fraction of the dataset being contained in our training set. PTB escapes these issues due to predating the modern internet. Our largest model sets a new SOTA on PTB by a substantial margin of 15 points, achieving a perplexity of 20.50 . Note that since PTB is a traditional language modeling dataset it does not have a clear separation of examples to define one-shot or few-shot evaluation around, so we measure only zero-shot.</p>
<h3>3.1.2 LAMBADA</h3>
<p>The LAMBADA dataset $\left[\mathrm{PKL}^{+} 16\right]$ tests the modeling of long-range dependencies in text - the model is asked to predict the last word of sentences which require reading a paragraph of context. It has recently been suggested that the continued scaling of language models is yielding diminishing returns on this difficult benchmark. [BHT $^{+} 20$ ] reflect on the small $1.5 \%$ improvement achieved by a doubling of model size between two recent state of the art results ([SPP $\left.{ }^{+} 19\right]$</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Setting</th>
<th style="text-align: center;">LAMBADA <br> (acc)</th>
<th style="text-align: center;">LAMBADA <br> (ppl)</th>
<th style="text-align: center;">StoryCloze <br> (acc)</th>
<th style="text-align: center;">HellaSwag <br> (acc)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">SOTA</td>
<td style="text-align: center;">$68.0^{a}$</td>
<td style="text-align: center;">$8.63^{b}$</td>
<td style="text-align: center;">$\mathbf{9 1 . 8}^{c}$</td>
<td style="text-align: center;">$\mathbf{8 5 . 6}^{d}$</td>
</tr>
<tr>
<td style="text-align: left;">GPT-3 Zero-Shot</td>
<td style="text-align: center;">$\mathbf{7 6 . 2}$</td>
<td style="text-align: center;">$\mathbf{3 . 0 0}$</td>
<td style="text-align: center;">83.2</td>
<td style="text-align: center;">78.9</td>
</tr>
<tr>
<td style="text-align: left;">GPT-3 One-Shot</td>
<td style="text-align: center;">$\mathbf{7 2 . 5}$</td>
<td style="text-align: center;">$\mathbf{3 . 3 5}$</td>
<td style="text-align: center;">84.7</td>
<td style="text-align: center;">78.1</td>
</tr>
<tr>
<td style="text-align: left;">GPT-3 Few-Shot</td>
<td style="text-align: center;">$\mathbf{8 6 . 4}$</td>
<td style="text-align: center;">$\mathbf{1 . 9 2}$</td>
<td style="text-align: center;">87.7</td>
<td style="text-align: center;">79.3</td>
</tr>
</tbody>
</table>
<p>Table 3.2: Performance on cloze and completion tasks. GPT-3 significantly improves SOTA on LAMBADA while achieving respectable performance on two difficult completion prediction datasets. ${ }^{a}$ [Tur20] ${ }^{b}\left[\mathrm{RWC}^{+} 19\right]^{\text {c }}[\mathrm{LDL} 19]$ ${ }^{d}\left[\mathrm{LCH}^{+} 20\right]$
<img alt="img-7.jpeg" src="img-7.jpeg" /></p>
<p>Figure 3.2: On LAMBADA, the few-shot capability of language models results in a strong boost to accuracy. GPT-3 2.7B outperforms the SOTA 17B parameter Turing-NLG [Tur20] in this setting, and GPT-3 175B advances the state of the art by $18 \%$. Note zero-shot uses a different format from one-shot and few-shot as described in the text.
and [Tur20]) and argue that "continuing to expand hardware and data sizes by orders of magnitude is not the path forward". We find that path is still promising and in a zero-shot setting GPT-3 achieves $76 \%$ on LAMBADA, a gain of $8 \%$ over the previous state of the art.
LAMBADA is also a demonstration of the flexibility of few-shot learning as it provides a way to address a problem that classically occurs with this dataset. Although the completion in LAMBADA is always the last word in a sentence, a standard language model has no way of knowing this detail. It thus assigns probability not only to the correct ending but also to other valid continuations of the paragraph. This problem has been partially addressed in the past with stop-word filters [RWC ${ }^{+} 19$ ] (which ban "continuation" words). The few-shot setting instead allows us to "frame" the task as a cloze-test and allows the language model to infer from examples that a completion of exactly one word is desired. We use the following fill-in-the-blank format:</p>
<p>Alice was friends with Bob. Alice went to visit her friend $\qquad$ . $\rightarrow$ Bob
George bought some baseball equipment, a ball, a glove, and a $\qquad$ . $\rightarrow$
When presented with examples formatted this way, GPT-3 achieves $86.4 \%$ accuracy in the few-shot setting, an increase of over $18 \%$ from the previous state-of-the-art. We observe that few-shot performance improves strongly with model size. While this setting decreases the performance of the smallest model by almost $20 \%$, for GPT-3 it improves accuracy by $10 \%$. Finally, the fill-in-blank method is not effective one-shot, where it always performs worse than the zero-shot setting. Perhaps this is because all models still require several examples to recognize the pattern.</p>
<table>
<thead>
<tr>
<th>Setting</th>
<th>NaturalQS</th>
<th>WebQS</th>
<th>TriviaQA</th>
</tr>
</thead>
<tbody>
<tr>
<td>RAG (Fine-tuned, Open-Domain) [LPP+20]</td>
<td>$\mathbf{4 4 . 5}$</td>
<td>$\mathbf{4 5 . 5}$</td>
<td>$\mathbf{6 8 . 0}$</td>
</tr>
<tr>
<td>T5-11B+SSM (Fine-tuned, Closed-Book) [RRS20]</td>
<td>36.6</td>
<td>44.7</td>
<td>60.5</td>
</tr>
<tr>
<td>T5-11B (Fine-tuned, Closed-Book)</td>
<td>34.5</td>
<td>37.4</td>
<td>50.1</td>
</tr>
<tr>
<td>GPT-3 Zero-Shot</td>
<td>14.6</td>
<td>14.4</td>
<td>64.3</td>
</tr>
<tr>
<td>GPT-3 One-Shot</td>
<td>23.0</td>
<td>25.3</td>
<td>$\mathbf{6 8 . 0}$</td>
</tr>
<tr>
<td>GPT-3 Few-Shot</td>
<td>29.9</td>
<td>41.5</td>
<td>$\mathbf{7 1 . 2}$</td>
</tr>
</tbody>
</table>
<p>Table 3.3: Results on three Open-Domain QA tasks. GPT-3 is shown in the few-, one-, and zero-shot settings, as compared to prior SOTA results for closed book and open domain settings. TriviaQA few-shot result is evaluated on the wiki split test server.</p>
<p>One note of caution is that an analysis of test set contamination identified that a significant minority of the LAMBADA dataset appears to be present in our training data - however analysis performed in Section 4 suggests negligible impact on performance.</p>
<h1>3.1.3 HellaSwag</h1>
<p>The HellaSwag dataset $\left[\mathrm{ZHB}^{+}\right.$19] involves picking the best ending to a story or set of instructions. The examples were adversarially mined to be difficult for language models while remaining easy for humans (who achieve $95.6 \%$ accuracy). GPT-3 achieves $78.1 \%$ accuracy in the one-shot setting and $79.3 \%$ accuracy in the few-shot setting, outperforming the $75.4 \%$ accuracy of a fine-tuned 1.5B parameter language model [ZHR+19] but still a fair amount lower than the overall SOTA of $85.6 \%$ achieved by the fine-tuned multi-task model ALUM.</p>
<h3>3.1.4 StoryCloze</h3>
<p>We next evaluate GPT-3 on the StoryCloze 2016 dataset [MCH+16], which involves selecting the correct ending sentence for five-sentence long stories. Here GPT-3 achieves $83.2 \%$ in the zero-shot setting and $87.7 \%$ in the few-shot setting (with $K=70$ ). This is still $4.1 \%$ lower than the fine-tuned SOTA using a BERT based model [LDL19] but improves over previous zero-shot results by roughly $10 \%$.</p>
<h3>3.2 Closed Book Question Answering</h3>
<p>In this section we measure GPT-3's ability to answer questions about broad factual knowledge. Due to the immense amount of possible queries, this task has normally been approached by using an information retrieval system to find relevant text in combination with a model which learns to generate an answer given the question and the retrieved text. Since this setting allows a system to search for and condition on text which potentially contains the answer it is denoted "open-book". [RRS20] recently demonstrated that a large language model can perform surprisingly well directly answering the questions without conditioning on auxilliary information. They denote this more restrictive evaluation setting as "closed-book". Their work suggests that even higher-capacity models could perform even better and we test this hypothesis with GPT-3. We evaluate GPT-3 on the 3 datasets in [RRS20]: Natural Questions [KPR+19], WebQuestions [BCFL13], and TriviaQA [JCWZ17], using the same splits. Note that in addition to all results being in the closed-book setting, our use of few-shot, one-shot, and zero-shot evaluations represent an even stricter setting than previous closed-book QA work: in addition to external content not being allowed, fine-tuning on the Q\&amp;A dataset itself is also not permitted.</p>
<p>The results for GPT-3 are shown in Table 3.3. On TriviaQA, we achieve $64.3 \%$ in the zero-shot setting, $68.0 \%$ in the one-shot setting, and $71.2 \%$ in the few-shot setting. The zero-shot result already outperforms the fine-tuned T5-11B by $14.2 \%$, and also outperforms a version with Q\&amp;A tailored span prediction during pre-training by $3.8 \%$. The one-shot result improves by $3.7 \%$ and matches the SOTA for an open-domain QA system which not only fine-tunes but also makes use of a learned retrieval mechanism over a 15.3B parameter dense vector index of 21 M documents [LPP+20]. GPT-3's few-shot result further improves performance another $3.2 \%$ beyond this.
On WebQuestions (WebQs), GPT-3 achieves $14.4 \%$ in the zero-shot setting, $25.3 \%$ in the one-shot setting, and $41.5 \%$ in the few-shot setting. This compares to $37.4 \%$ for fine-tuned T5-11B, and $44.7 \%$ for fine-tuned T5-11B+SSM, which uses a Q\&amp;A-specific pre-training procedure. GPT-3 in the few-shot setting approaches the performance of state-of-the-art fine-tuned models. Notably, compared to TriviaQA, WebQS shows a much larger gain from zero-shot to few-shot (and indeed its zero-shot and one-shot performance are poor), perhaps suggesting that the WebQs questions</p>
<p><img alt="img-8.jpeg" src="img-8.jpeg" /></p>
<p>Figure 3.3: On TriviaQA GPT3's performance grows smoothly with model size, suggesting that language models continue to absorb knowledge as their capacity increases. One-shot and few-shot performance make significant gains over zero-shot behavior, matching and exceeding the performance of the SOTA fine-tuned open-domain model, RAG $[\mathrm{LPP}+20]$
and/or the style of their answers are out-of-distribution for GPT-3. Nevertheless, GPT-3 appears able to adapt to this distribution, recovering strong performance in the few-shot setting.
On Natural Questions (NQs) GPT-3 achieves $14.6 \%$ in the zero-shot setting, $23.0 \%$ in the one-shot setting, and $29.9 \%$ in the few-shot setting, compared to $36.6 \%$ for fine-tuned T5 11B+SSM. Similar to WebQS, the large gain from zero-shot to few-shot may suggest a distribution shift, and may also explain the less competitive performance compared to TriviaQA and WebQS. In particular, the questions in NQs tend towards very fine-grained knowledge on Wikipedia specifically which could be testing the limits of GPT-3's capacity and broad pretraining distribution.
Overall, on one of the three datasets GPT-3's one-shot matches the open-domain fine-tuning SOTA. On the other two datasets it approaches the performance of the closed-book SOTA despite not using fine-tuning. On all 3 datasets, we find that performance scales very smoothly with model size (Figure 3.3 and Appendix H Figure H.7), possibly reflecting the idea that model capacity translates directly to more 'knowledge' absorbed in the parameters of the model.</p>
<h1>3.3 Translation</h1>
<p>For GPT-2 a filter was used on a multilingual collection of documents to produce an English only dataset due to capacity concerns. Even with this filtering GPT-2 showed some evidence of multilingual capability and performed non-trivially when translating between French and English despite only training on 10 megabytes of remaining French text. Since we increase the capacity by over two orders of magnitude from GPT-2 to GPT-3, we also expand the scope of the training dataset to include more representation of other languages, though this remains an area for further improvement. As discussed in 2.2 the majority of our data is derived from raw Common Crawl with only quality-based filtering. Although GPT-3's training data is still primarily English ( $93 \%$ by word count), it also includes 7\% of text in other languages. These languages are documented in the supplemental material. In order to better understand translation capability, we also expand our analysis to include two additional commonly studied languages, German and Romanian.
Existing unsupervised machine translation approaches often combine pretraining on a pair of monolingual datasets with back-translation [SHB15] to bridge the two languages in a controlled way. By contrast, GPT-3 learns from a blend of training data that mixes many languages together in a natural way, combining them on a word, sentence, and document level. GPT-3 also uses a single training objective which is not customized or designed for any task in particular. However, our one / few-shot settings aren't strictly comparable to prior unsupervised work since they make use of a small amount of paired examples (1 or 64). This corresponds to up to a page or two of in-context training data.
Results are shown in Table 3.4. Zero-shot GPT-3, which only receives on a natural language description of the task, still underperforms recent unsupervised NMT results. However, providing only a single example demonstration for</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Setting</th>
<th style="text-align: center;">$\mathrm{En} \rightarrow \mathrm{Fr}$</th>
<th style="text-align: center;">$\mathrm{Fr} \rightarrow \mathrm{En}$</th>
<th style="text-align: center;">$\mathrm{En} \rightarrow \mathrm{De}$</th>
<th style="text-align: center;">$\mathrm{De} \rightarrow \mathrm{En}$</th>
<th style="text-align: center;">$\mathrm{En} \rightarrow \mathrm{Ro}$</th>
<th style="text-align: center;">$\mathrm{Ro} \rightarrow \mathrm{En}$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">SOTA (Supervised)</td>
<td style="text-align: center;">$\mathbf{4 5 . 6}^{a}$</td>
<td style="text-align: center;">$35.0^{b}$</td>
<td style="text-align: center;">$\mathbf{4 1 . 2}^{c}$</td>
<td style="text-align: center;">$40.2^{d}$</td>
<td style="text-align: center;">$\mathbf{3 8 . 5}^{e}$</td>
<td style="text-align: center;">$\mathbf{3 9 . 9}^{e}$</td>
</tr>
<tr>
<td style="text-align: left;">XLM [LC19]</td>
<td style="text-align: center;">33.4</td>
<td style="text-align: center;">33.3</td>
<td style="text-align: center;">26.4</td>
<td style="text-align: center;">34.3</td>
<td style="text-align: center;">33.3</td>
<td style="text-align: center;">31.8</td>
</tr>
<tr>
<td style="text-align: left;">MASS [STQ+19]</td>
<td style="text-align: center;">$\underline{37.5}$</td>
<td style="text-align: center;">34.9</td>
<td style="text-align: center;">28.3</td>
<td style="text-align: center;">35.2</td>
<td style="text-align: center;">$\underline{35.2}$</td>
<td style="text-align: center;">33.1</td>
</tr>
<tr>
<td style="text-align: left;">mBART [LGG+20]</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">$\underline{29.8}$</td>
<td style="text-align: center;">34.0</td>
<td style="text-align: center;">35.0</td>
<td style="text-align: center;">30.5</td>
</tr>
<tr>
<td style="text-align: left;">GPT-3 Zero-Shot</td>
<td style="text-align: center;">25.2</td>
<td style="text-align: center;">21.2</td>
<td style="text-align: center;">24.6</td>
<td style="text-align: center;">27.2</td>
<td style="text-align: center;">14.1</td>
<td style="text-align: center;">19.9</td>
</tr>
<tr>
<td style="text-align: left;">GPT-3 One-Shot</td>
<td style="text-align: center;">28.3</td>
<td style="text-align: center;">33.7</td>
<td style="text-align: center;">26.2</td>
<td style="text-align: center;">30.4</td>
<td style="text-align: center;">20.6</td>
<td style="text-align: center;">38.6</td>
</tr>
<tr>
<td style="text-align: left;">GPT-3 Few-Shot</td>
<td style="text-align: center;">32.6</td>
<td style="text-align: center;">$\underline{39.2}$</td>
<td style="text-align: center;">29.7</td>
<td style="text-align: center;">$\underline{40.6}$</td>
<td style="text-align: center;">21.0</td>
<td style="text-align: center;">$\underline{39.5}$</td>
</tr>
</tbody>
</table>
<p>Table 3.4: Few-shot GPT-3 outperforms previous unsupervised NMT work by 5 BLEU when translating into English reflecting its strength as an English LM. We report BLEU scores on the WMT'14 Fr↔️En, WMT'16 De↔️En, and WMT'16 Ro↔️En datasets as measured by multi-bleu.perl with XLM's tokenization in order to compare most closely with prior unsupervised NMT work. SacreBLEU ${ }^{f}$ [Pos18] results reported in Appendix H. Underline indicates an unsupervised or few-shot SOTA, bold indicates supervised SOTA with relative confidence. ${ }^{a}$ [EOAG18] ${ }^{b}$ [DHKH14] ${ }^{c}\left[\mathrm{WXH}^{+} 18\right]{ }^{d}[\mathrm{oR} 16]{ }^{e}\left[\mathrm{LGG}^{+} 20\right]{ }^{f}$ [SacreBLEU signature: BLEU+case.mixed+numrefs.1+smooth.exp+tok.intl+version.1.2.20]
<img alt="img-9.jpeg" src="img-9.jpeg" /></p>
<p>Figure 3.4: Few-shot translation performance on 6 language pairs as model capacity increases. There is a consistent trend of improvement across all datasets as the model scales, and as well as tendency for translation into English to be stronger than translation from English.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Setting</th>
<th style="text-align: center;">Winograd</th>
<th style="text-align: center;">Winogrande (XL)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Fine-tuned SOTA</td>
<td style="text-align: center;">$\mathbf{9 0 . 1}{ }^{a}$</td>
<td style="text-align: center;">$\mathbf{8 4 . 6}{ }^{b}$</td>
</tr>
<tr>
<td style="text-align: left;">GPT-3 Zero-Shot</td>
<td style="text-align: center;">$88.3^{*}$</td>
<td style="text-align: center;">70.2</td>
</tr>
<tr>
<td style="text-align: left;">GPT-3 One-Shot</td>
<td style="text-align: center;">$89.7^{*}$</td>
<td style="text-align: center;">73.2</td>
</tr>
<tr>
<td style="text-align: left;">GPT-3 Few-Shot</td>
<td style="text-align: center;">$88.6^{*}$</td>
<td style="text-align: center;">77.7</td>
</tr>
</tbody>
</table>
<p>Table 3.5: Results on the WSC273 version of Winograd schemas and the adversarial Winogrande dataset. See Section 4 for details on potential contamination of the Winograd test set. ${ }^{a}[$ SBBC19] ${ }^{b}\left[\mathrm{LYN}^{+} 20\right]$
<img alt="img-10.jpeg" src="img-10.jpeg" /></p>
<p>Figure 3.5: Zero-, one-, and few-shot performance on the adversarial Winogrande dataset as model capacity scales. Scaling is relatively smooth with the gains to few-shot learning increasing with model size, and few-shot GPT-3 175B is competitive with a fine-tuned RoBERTA-large.
each translation task improves performance by over 7 BLEU and nears competitive performance with prior work. GPT-3 in the full few-shot setting further improves another 4 BLEU resulting in similar average performance to prior unsupervised NMT work. GPT-3 has a noticeable skew in its performance depending on language direction. For the three input languages studied, GPT-3 significantly outperforms prior unsupervised NMT work when translating into English but underperforms when translating in the other direction. Performance on En-Ro is a noticeable outlier at over 10 BLEU worse than prior unsupervised NMT work. This could be a weakness due to reusing the byte-level BPE tokenizer of GPT-2 which was developed for an almost entirely English training dataset. For both Fr-En and De-En, few shot GPT-3 outperforms the best supervised result we could find but due to our unfamiliarity with the literature and the appearance that these are un-competitive benchmarks we do not suspect those results represent true state of the art. For Ro-En, few shot GPT-3 performs within 0.5 BLEU of the overall SOTA which is achieved by a combination of unsupervised pretraining, supervised finetuning on 608 K labeled examples, and backtranslation [LHCG19b].
Finally, across all language pairs and across all three settings (zero-, one-, and few-shot), there is a smooth trend of improvement with model capacity. This is shown in Figure 3.4 in the case of few-shot results, and scaling for all three settings is shown in Appendix H.</p>
<h1>3.4 Winograd-Style Tasks</h1>
<p>The Winograd Schemas Challenge [LDM12] is a classical task in NLP that involves determining which word a pronoun refers to, when the pronoun is grammatically ambiguous but semantically unambiguous to a human. Recently fine-tuned language models have achieved near-human performance on the original Winograd dataset, but more difficult versions</p>
<table>
<thead>
<tr>
<th>Setting</th>
<th>PIQA</th>
<th>ARC (Easy)</th>
<th>ARC (Challenge)</th>
<th>OpenBookQA</th>
</tr>
</thead>
<tbody>
<tr>
<td>Fine-tuned SOTA</td>
<td>79.4</td>
<td>$\mathbf{9 2 . 0}[\mathrm{KKS}+20]$</td>
<td>$\mathbf{7 8 . 5}[\mathrm{KKS}+20]$</td>
<td>$\mathbf{8 7 . 2}[\mathrm{KKS}+20]$</td>
</tr>
<tr>
<td>GPT-3 Zero-Shot</td>
<td>$\mathbf{8 0 . 5 *}$</td>
<td>68.8</td>
<td>51.4</td>
<td>57.6</td>
</tr>
<tr>
<td>GPT-3 One-Shot</td>
<td>$\mathbf{8 0 . 5 *}$</td>
<td>71.2</td>
<td>53.2</td>
<td>58.8</td>
</tr>
<tr>
<td>GPT-3 Few-Shot</td>
<td>$\mathbf{8 2 . 8 *}$</td>
<td>70.1</td>
<td>51.5</td>
<td>65.4</td>
</tr>
</tbody>
</table>
<p>Table 3.6: GPT-3 results on three commonsense reasoning tasks, PIQA, ARC, and OpenBookQA. GPT-3 Few-Shot PIQA result is evaluated on the test server. See Section 4 for details on potential contamination issues on the PIQA test set.
<img alt="img-11.jpeg" src="img-11.jpeg" /></p>
<p>Figure 3.6: GPT-3 results on PIQA in the zero-shot, one-shot, and few-shot settings. The largest model achieves a score on the development set in all three conditions that exceeds the best recorded score on the task.
such as the adversarially-mined Winogrande dataset [SBBC19] still significantly lag human performance. We test GPT-3's performance on both Winograd and Winogrande, as usual in the zero-, one-, and few-shot setting.
On Winograd we test GPT-3 on the original set of 273 Winograd schemas, using the same "partial evaluation" method described in [RWC +19$]$. Note that this setting differs slightly from the WSC task in the SuperGLUE benchmark, which is presented as binary classification and requires entity extraction to convert to the form described in this section. On Winograd GPT-3 achieves $88.3 \%, 89.7 \%$, and $88.6 \%$ in the zero-shot, one-shot, and few-shot settings, showing no clear in-context learning but in all cases achieving strong results just a few points below state-of-the-art and estimated human performance. We note that contamination analysis found some Winograd schemas in the training data but this appears to have only a small effect on results (see Section 4).
On the more difficult Winogrande dataset, we do find gains to in-context learning: GPT-3 achieves $70.2 \%$ in the zero-shot setting, $73.2 \%$ in the one-shot setting, and $77.7 \%$ in the few-shot setting. For comparison a fine-tuned RoBERTA model achieves $79 \%$, state-of-the-art is $84.6 \%$ achieved with a fine-tuned high capacity model (T5), and human performance on the task as reported by [SBBC19] is $94.0 \%$.</p>
<h1>3.5 Common Sense Reasoning</h1>
<p>Next we consider three datasets which attempt to capture physical or scientific reasoning, as distinct from sentence completion, reading comprehension, or broad knowledge question answering. The first, PhysicalQA (PIQA) [BZB +19$]$, asks common sense questions about how the physical world works and is intended as a probe of grounded understanding of the world. GPT-3 achieves $81.0 \%$ accuracy zero-shot, $80.5 \%$ accuracy one-shot, and $82.8 \%$ accuracy few-shot (the last measured on PIQA's test server). This compares favorably to the $79.4 \%$ accuracy prior state-of-the-art of a</p>
<table>
<thead>
<tr>
<th>Setting</th>
<th>CoQA</th>
<th>DROP</th>
<th>QuAC</th>
<th>SQuADv2</th>
<th>RACE-h</th>
<th>RACE-m</th>
</tr>
</thead>
<tbody>
<tr>
<td>Fine-tuned SOTA</td>
<td>$\mathbf{9 0 . 7}^{a}$</td>
<td>$\mathbf{8 9 . 1}^{b}$</td>
<td>$\mathbf{7 4 . 4}^{c}$</td>
<td>$\mathbf{9 3 . 0}^{d}$</td>
<td>$\mathbf{9 0 . 0}^{e}$</td>
<td>$\mathbf{9 3 . 1}^{e}$</td>
</tr>
<tr>
<td>GPT-3 Zero-Shot</td>
<td>81.5</td>
<td>23.6</td>
<td>41.5</td>
<td>59.5</td>
<td>45.5</td>
<td>58.4</td>
</tr>
<tr>
<td>GPT-3 One-Shot</td>
<td>84.0</td>
<td>34.3</td>
<td>43.3</td>
<td>65.4</td>
<td>45.9</td>
<td>57.4</td>
</tr>
<tr>
<td>GPT-3 Few-Shot</td>
<td>85.0</td>
<td>36.5</td>
<td>44.3</td>
<td>69.8</td>
<td>46.8</td>
<td>58.1</td>
</tr>
</tbody>
</table>
<p>Table 3.7: Results on reading comprehension tasks. All scores are F1 except results for RACE which report accuracy. ${ }^{a}\left[\mathrm{JZC}^{+}\right.$19] ${ }^{b}$ [JN20] ${ }^{c}$ [AI19] ${ }^{d}$ [QIA20] ${ }^{e}\left[\mathrm{SPP}^{+}\right.$19]
fine-tuned RoBERTa. PIQA shows relatively shallow scaling with model size and is still over $10 \%$ worse than human performance, but GPT-3's few-shot and even zero-shot result outperform the current state-of-the-art. Our analysis flagged PIQA for a potential data contamination issue (despite hidden test labels), and we therefore conservatively mark the result with an asterisk. See Section 4 for details.
$\operatorname{ARC}\left[\mathrm{CCE}^{+}\right.$18] is a dataset of multiple-choice questions collected from 3rd to 9th grade science exams. On the "Challenge" version of the dataset which has been filtered to questions which simple statistical or information retrieval methods are unable to correctly answer, GPT-3 achieves $51.4 \%$ accuracy in the zero-shot setting, $53.2 \%$ in the one-shot setting, and $51.5 \%$ in the few-shot setting. This is approaching the performance of a fine-tuned RoBERTa baseline (55.9\%) from UnifiedQA [KKS+20]. On the "Easy" version of the dataset (questions which either of the mentioned baseline approaches answered correctly), GPT-3 achieves $68.8 \%, 71.2 \%$, and $70.1 \%$ which slightly exceeds a fine-tuned RoBERTa baseline from [KKS+20]. However, both of these results are still much worse than the overall SOTAs achieved by the UnifiedQA which exceeds GPT-3's few-shot results by $27 \%$ on the challenge set and $22 \%$ on the easy set.
On OpenBookQA [MCKS18], GPT-3 improves significantly from zero to few shot settings but is still over 20 points short of the overall SOTA. GPT-3's few-shot performance is similar to a fine-tuned BERT Large baseline on the leaderboard.
Overall, in-context learning with GPT-3 shows mixed results on commonsense reasoning tasks, with only small and inconsistent gains observed in the one and few-shot learning settings for both PIQA and ARC, but a significant improvement is observed on OpenBookQA. GPT-3 sets SOTA on the new PIQA dataset in all evaluation settings.</p>
<h1>3.6 Reading Comprehension</h1>
<p>Next we evaluate GPT-3 on the task of reading comprehension. We use a suite of 5 datasets including abstractive, multiple choice, and span based answer formats in both dialog and single question settings. We observe a wide spread in GPT-3's performance across these datasets suggestive of varying capability with different answer formats. In general we observe GPT-3 is on par with initial baselines and early results trained using contextual representations on each respective dataset.
GPT-3 performs best (within 3 points of the human baseline) on CoQA [RCM19] a free-form conversational dataset and performs worst ( 13 F 1 below an ELMo baseline) on QuAC $\left[\mathrm{CHI}^{+}\right.$18] a dataset which requires modeling structured dialog acts and answer span selections of teacher-student interactions. On DROP [DWD ${ }^{+}$19], a dataset testing discrete reasoning and numeracy in the context of reading comprehension, GPT-3 in a few-shot setting outperforms the fine-tuned BERT baseline from the original paper but is still well below both human performance and state-of-the-art approaches which augment neural networks with symbolic systems [RLL+19]. On SQuAD 2.0 [RJL18], GPT-3 demonstrates its few-shot learning capabilities, improving by almost 10 F 1 (to 69.8 ) compared to a zero-shot setting. This allows it to slightly outperform the best fine-tuned result in the original paper. On RACE [LXL+17], a multiple choice dataset of middle school and high school english examinations, GPT-3 performs relatively weakly and is only competitive with the earliest work utilizing contextual representations and is still $45 \%$ behind SOTA.</p>
<h3>3.7 SuperGLUE</h3>
<p>In order to better aggregate results on NLP tasks and compare to popular models such as BERT and RoBERTa in a more systematic way, we also evaluate GPT-3 on a standardized collection of datasets, the SuperGLUE benchmark [WPN+19] [WPN+19] [CLC+19] [DMST19] [RBG11] [KCR+18] [ZLL+18] [DGM06] [BHDD+06] [GMDD07] [BDD+09] [PCC18] [PHR+18]. GPT-3's test-set performance on the SuperGLUE dataset is shown in Table 3.8. In the few-shot setting, we used 32 examples for all tasks, sampled randomly from the training set. For all tasks except WSC</p>
<p><img alt="img-12.jpeg" src="img-12.jpeg" /></p>
<p>Figure 3.7: GPT-3 results on CoQA reading comprehension task. GPT-3 175B achieves 85 F1 in the few-shot setting, only a few points behind measured human performance and state-of-the-art fine-tuned models. Zero-shot and one-shot performance is a few points behind, with the gains to few-shot being largest for bigger models.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: center;">SuperGLUE <br> Average</th>
<th style="text-align: center;">BoolQ <br> Accuracy</th>
<th style="text-align: center;">CB <br> Accuracy</th>
<th style="text-align: center;">CB <br> F1</th>
<th style="text-align: center;">COPA <br> Accuracy</th>
<th style="text-align: center;">RTE <br> Accuracy</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Fine-tuned SOTA</td>
<td style="text-align: center;">$\mathbf{8 9 . 0}$</td>
<td style="text-align: center;">$\mathbf{9 1 . 0}$</td>
<td style="text-align: center;">$\mathbf{9 6 . 9}$</td>
<td style="text-align: center;">$\mathbf{9 3 . 9}$</td>
<td style="text-align: center;">$\mathbf{9 4 . 8}$</td>
<td style="text-align: center;">$\mathbf{9 2 . 5}$</td>
</tr>
<tr>
<td style="text-align: left;">Fine-tuned BERT-Large</td>
<td style="text-align: center;">69.0</td>
<td style="text-align: center;">77.4</td>
<td style="text-align: center;">83.6</td>
<td style="text-align: center;">75.7</td>
<td style="text-align: center;">70.6</td>
<td style="text-align: center;">71.7</td>
</tr>
<tr>
<td style="text-align: left;">GPT-3 Few-Shot</td>
<td style="text-align: center;">71.8</td>
<td style="text-align: center;">76.4</td>
<td style="text-align: center;">75.6</td>
<td style="text-align: center;">52.0</td>
<td style="text-align: center;">92.0</td>
<td style="text-align: center;">69.0</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;">WiC <br> Accuracy</td>
<td style="text-align: center;">WSC <br> Accuracy</td>
<td style="text-align: center;">MultiRC <br> Accuracy</td>
<td style="text-align: center;">MultiRC <br> F1a</td>
<td style="text-align: center;">ReCoRD <br> Accuracy</td>
<td style="text-align: center;">ReCoRD <br> F1</td>
</tr>
<tr>
<td style="text-align: left;">Fine-tuned SOTA</td>
<td style="text-align: center;">$\mathbf{7 6 . 1}$</td>
<td style="text-align: center;">$\mathbf{9 3 . 8}$</td>
<td style="text-align: center;">$\mathbf{6 2 . 3}$</td>
<td style="text-align: center;">$\mathbf{8 8 . 2}$</td>
<td style="text-align: center;">$\mathbf{9 2 . 5}$</td>
<td style="text-align: center;">$\mathbf{9 3 . 3}$</td>
</tr>
<tr>
<td style="text-align: left;">Fine-tuned BERT-Large</td>
<td style="text-align: center;">69.6</td>
<td style="text-align: center;">64.6</td>
<td style="text-align: center;">24.1</td>
<td style="text-align: center;">70.0</td>
<td style="text-align: center;">71.3</td>
<td style="text-align: center;">72.0</td>
</tr>
<tr>
<td style="text-align: left;">GPT-3 Few-Shot</td>
<td style="text-align: center;">49.4</td>
<td style="text-align: center;">80.1</td>
<td style="text-align: center;">30.5</td>
<td style="text-align: center;">75.4</td>
<td style="text-align: center;">90.2</td>
<td style="text-align: center;">91.1</td>
</tr>
</tbody>
</table>
<p>Table 3.8: Performance of GPT-3 on SuperGLUE compared to fine-tuned baselines and SOTA. All results are reported on the test set. GPT-3 few-shot is given a total of 32 examples within the context of each task and performs no gradient updates.</p>
<p><img alt="img-13.jpeg" src="img-13.jpeg" /></p>
<p>Figure 3.8: Performance on SuperGLUE increases with model size and number of examples in context. A value of $K=32$ means that our model was shown 32 examples per task, for 256 examples total divided across the 8 tasks in SuperGLUE. We report GPT-3 values on the dev set, so our numbers are not directly comparable to the dotted reference lines (our test set results are in Table 3.8). The BERT-Large reference model was fine-tuned on the SuperGLUE training set (125K examples), whereas BERT++ was first fine-tuned on MultiNLI (392K examples) and SWAG (113K examples) before further fine-tuning on the SuperGLUE training set (for a total of 630K fine-tuning examples). We find the difference in performance between the BERT-Large and BERT++ to be roughly equivalent to the difference between GPT-3 with one example per context versus eight examples per context.
and MultiRC, we sampled a new set of examples to use in the context for each problem. For WSC and MultiRC, we used the same set of randomly drawn examples from the training set as context for all of the problems we evaluated.
We observe a wide range in GPT-3's performance across tasks. On COPA and ReCoRD GPT-3 achieves near-SOTA performance in the one-shot and few-shot settings, with COPA falling only a couple points short and achieving second place on the leaderboard, where first place is held by a fine-tuned 11 billion parameter model (T5). On WSC, performance is still relatively strong, achieving $80.1 \%$ in the few-shot setting (note that GPT-3 achieves $88.6 \%$ on the original Winograd dataset as described in Section 3.4). On BoolQ, MultiRC, and RTE, performance is reasonable, roughly matching that of a fine-tuned BERT-Large. On CB, we see signs of life at $75.6 \%$ in the few-shot setting.
WiC is a notable weak spot with few-shot performance at $49.4 \%$ (at random chance). We tried a number of different phrasings and formulations for WiC (which involves determining if a word is being used with the same meaning in two sentences), none of which was able to achieve strong performance. This hints at a phenomenon that will become clearer in the next section (which discusses the ANLI benchmark) - GPT-3 appears to be weak in the few-shot or one-shot setting at some tasks that involve comparing two sentences or snippets, for example whether a word is used the same way in two sentences (WiC), whether one sentence is a paraphrase of another, or whether one sentence implies another. This could also explain the comparatively low scores for RTE and CB, which also follow this format. Despite these weaknesses, GPT-3 still outperforms a fine-tuned BERT-large on four of eight tasks and on two tasks GPT-3 is close to the state-of-the-art held by a fine-tuned 11 billion parameter model.</p>
<p>Finally, we note that the few-shot SuperGLUE score steadily improves with both model size and with number of examples in the context showing increasing benefits from in-context learning (Figure 3.8). We scale $K$ up to 32 examples per task, after which point additional examples will not reliably fit into our context. When sweeping over values of $K$, we find that GPT-3 requires less than eight total examples per task to outperform a fine-tuned BERT-Large on overall SuperGLUE score.</p>
<h1>3.8 NLI</h1>
<p>Natural Language Inference (NLI) [Fyo00] concerns the ability to understand the relationship between two sentences. In practice, this task is usually structured as a two or three class classification problem where the model classifies</p>
<p><img alt="img-14.jpeg" src="img-14.jpeg" /></p>
<p>Figure 3.9: Performance of GPT-3 on ANLI Round 3. Results are on the dev-set, which has only 1500 examples and therefore has high variance (we estimate a standard deviation of $1.2 \%$ ). We find that smaller models hover around random chance, while few-shot GPT-3 175B closes almost half the gap from random chance to SOTA. Results for ANLI rounds 1 and 2 are shown in the appendix.
whether the second sentence logically follows from the first, contradicts the first sentence, or is possibly true (neutral). SuperGLUE includes an NLI dataset, RTE, which evaluates the binary version of the task. On RTE, only the largest version of GPT-3 performs convincingly better than random ( $56 \%$ ) in any evaluation setting, but in a few-shot setting GPT-3 performs similarly to a single-task fine-tuned BERT Large. We also evaluate on the recently introduced Adversarial Natural Language Inference (ANLI) dataset [NWD ${ }^{+19}$ ]. ANLI is a difficult dataset employing a series of adversarially mined natural language inference questions in three rounds (R1, R2, and R3). Similar to RTE, all of our models smaller than GPT-3 perform at almost exactly random chance on ANLI, even in the few-shot setting ( $\sim 33 \%$ ), whereas GPT-3 itself shows signs of life on Round 3. Results for ANLI R3 are highlighted in Figure 3.9 and full results for all rounds can be found in Appendix H. These results on both RTE and ANLI suggest that NLI is still a very difficult task for language models and they are only just beginning to show signs of progress.</p>
<h1>3.9 Synthetic and Qualitative Tasks</h1>
<p>One way to probe GPT-3's range of abilities in the few-shot (or zero- and one-shot) setting is to give it tasks which require it to perform simple on-the-fly computational reasoning, recognize a novel pattern that is unlikely to have occurred in training, or adapt quickly to an unusual task. We devise several tasks to test this class of abilities. First, we test GPT-3's ability to perform arithmetic. Second, we create several tasks that involve rearranging or unscrambling the letters in a word, tasks which are unlikely to have been exactly seen during training. Third, we test GPT-3's ability to solve SAT-style analogy problems few-shot. Finally, we test GPT-3 on several qualitative tasks, including using new words in a sentence, correcting English grammar, and news article generation. We will release the synthetic datasets with the hope of stimulating further study of test-time behavior of language models.</p>
<h3>3.9.1 Arithmetic</h3>
<p>To test GPT-3's ability to perform simple arithmetic operations without task-specific training, we developed a small battery of 10 tests that involve asking GPT-3 a simple arithmetic problem in natural language:</p>
<ul>
<li>2 digit addition (2D+) - The model is asked to add two integers sampled uniformly from $[0,100)$, phrased in the form of a question, e.g. "Q: What is 48 plus 76 ? A: 124 ."</li>
<li>2 digit subtraction (2D-) - The model is asked to subtract two integers sampled uniformly from $[0,100)$; the answer may be negative. Example: "Q: What is 34 minus 53 ? A: -19".</li>
<li>3 digit addition (3D+) - Same as 2 digit addition, except numbers are uniformly sampled from $[0,1000)$.</li>
</ul>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{2}$ https://commoncrawl.org/the-data/&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>