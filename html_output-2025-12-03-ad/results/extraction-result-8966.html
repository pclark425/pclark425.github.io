<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-8966 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-8966</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-8966</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-158.html">extraction-schema-158</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for representing or converting graphs into text for language model training, including details of the representation, the type of graph, the conversion process, downstream tasks, performance metrics, comparisons to other methods, and any reported advantages, disadvantages, or failure cases.</div>
                <p><strong>Paper ID:</strong> paper-52cb05d721688cb766c6e282e9d55c3b8e3dc0cf</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/52cb05d721688cb766c6e282e9d55c3b8e3dc0cf" target="_blank">TaPas: Weakly Supervised Table Parsing via Pre-training</a></p>
                <p><strong>Paper Venue:</strong> Annual Meeting of the Association for Computational Linguistics</p>
                <p><strong>Paper TL;DR:</strong> TaPas is presented, an approach to question answering over tables without generating logical forms that outperforms or rivals semantic parsing models by improving state-of-the-art accuracy on SQA and performing on par with the state of theart on WikiSQL and WikiTQ, but with a simpler model architecture.</p>
                <p><strong>Paper Abstract:</strong> Answering natural language questions over tables is usually seen as a semantic parsing task. To alleviate the collection cost of full logical forms, one popular approach focuses on weak supervision consisting of denotations instead of logical forms. However, training semantic parsers from weak supervision poses difficulties, and in addition, the generated logical forms are only used as an intermediate step prior to retrieving the denotation. In this paper, we present TaPas, an approach to question answering over tables without generating logical forms. TaPas trains from weak supervision, and predicts the denotation by selecting table cells and optionally applying a corresponding aggregation operator to such selection. TaPas extends BERT’s architecture to encode tables as input, initializes from an effective joint pre-training of text segments and tables crawled from Wikipedia, and is trained end-to-end. We experiment with three different semantic parsing datasets, and find that TaPas outperforms or rivals semantic parsing models by improving state-of-the-art accuracy on SQA from 55.1 to 67.2 and performing on par with the state-of-the-art on WikiSQL and WikiTQ, but with a simpler model architecture. We additionally find that transfer learning, which is trivial in our setting, from WikiSQL to WikiTQ, yields 48.7 accuracy, 4.2 points above the state-of-the-art.</p>
                <p><strong>Cost:</strong> 0.012</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e8966.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e8966.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for representing or converting graphs into text for language model training, including details of the representation, the type of graph, the conversion process, downstream tasks, performance metrics, comparisons to other methods, and any reported advantages, disadvantages, or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>TAPAS table-flattening</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>TAPAS: Flattened table serialization with table-aware positional embeddings</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>TAPAS represents tables as a flattened sequence of word-piece tokens concatenated after the question, augmented with table-aware positional embeddings (position ID, segment ID, column/row ID, numeric rank ID, previous-answer flag). It is trained with masked language model pre-training on text-table pairs and fine-tuned end-to-end for question answering by predicting cell selections and optional aggregation operators.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>Flattened table serialization with table-aware positional embeddings</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Flatten each table into a sequence of word-piece tokens (concatenate question tokens first, then table header and cell tokens). Augment token embeddings with additional learned embeddings encoding: global token position (Position ID), segment (question vs table), column ID, row ID, numeric rank within a column (Rank ID), and a previous-answer marker for conversational rounds. Apply whole-cell masking during pre-training and feed the combined token+table-aware embeddings into a BERT-style encoder.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>Tabular data (semi-structured tables: WikiTables and Infoboxes; horizontal tables with header rows)</td>
                        </tr>
                        <tr>
                            <td><strong>conversion_method</strong></td>
                            <td>Tokenize question and table into word-pieces; start with first word of each column name and cell then add words turn-wise until a fixed word-piece budget (e.g., 128); transpose Infoboxes into single-row tables; concatenate question tokens, separator token, then flattened table tokens; apply whole-cell masking for table cells during masked-LM pre-training.</td>
                        </tr>
                        <tr>
                            <td><strong>downstream_task</strong></td>
                            <td>Weakly-supervised question answering over tables / semantic parsing (denotation prediction), including conversational QA (SQA), WikiSQL, and WikiTQ</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Denotation accuracy (weak supervision): WIKISQL dev 85.1% / test 83.6% (close to SOTA 83.9%); TAPAS (fully supervised) WIKISQL test 86.4%; SQA average question accuracy 67.2% (sequence accuracy 40.4%, improving SOTA from 55.1 to 67.2); WIKI TQ trained from original data 42.6%, pretraining on WikiSQL or SQA improves to 48.7% and 48.8% respectively.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_others</strong></td>
                            <td>Compared to graph- or program-based approaches, TAPAS uses a single encoder and no auto-regressive decoding, and benefits from pre-training on millions of tables. It outperforms or matches other methods on benchmarks: rivals discrete-hard-EM SQL approaches on WikiSQL and substantially outperforms a GNN-based table approach (Müller et al., 2019) on SQA (TAPAS ALL 67.2% vs Müller et al. 55.1%). Ablations show table pre-training and column/row embeddings are most important.</td>
                        </tr>
                        <tr>
                            <td><strong>advantages</strong></td>
                            <td>Simple single-encoder architecture (no autoregressive program generation); supports aggregation operators (COUNT, SUM, AVERAGE) via a differentiable soft-execution layer; benefits from large-scale table+text pre-training; handles conversational signals via previous-answer embedding; trivial transfer learning across table QA datasets; strong empirical gains on SQA and competitive results on WikiSQL and WikiTQ.</td>
                        </tr>
                        <tr>
                            <td><strong>disadvantages</strong></td>
                            <td>Limited to single tables that fit the model's token budget (typically 512 tokens); representation flattens tabular structure into a sequence and thus requires additional embeddings to recover row/column information; expressivity limited to selecting a subset of cells plus a single aggregation (cannot represent multiple-aggregation programs or complex compositional queries outside this form).</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>Reported failure modes include: ambiguous questions or missing/wrong table labels (~12% of analyzed WIKI TQ errors); complex temporal comparisons not captured by model (~10%); gold denotation textual values not present in table (16%); tables too large to fit in sequence budget (10%); model selecting no cells (13%); aggregator operations outside model capability (e.g., difference between scalars) (2%); ~37% uncategorized. Pre-training also predicts numbers less accurately than words (masked-LM number accuracy 53.9% vs words 74.1% on held-out).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'TaPas: Weakly Supervised Table Parsing via Pre-training', 'publication_date_yy_mm': '2020-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8966.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e8966.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for representing or converting graphs into text for language model training, including details of the representation, the type of graph, the conversion process, downstream tasks, performance metrics, comparisons to other methods, and any reported advantages, disadvantages, or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Table-to-text rendering (Chen et al. 2019)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Rendering tables into natural language to use pre-trained BERT (as in Chen et al., 2019)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Reported in related work as an approach that converts a table into natural-language text so that an off-the-shelf pre-trained language model (BERT) can process the table as plain text, enabling downstream tasks such as table-based fact verification.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Tabfact: A large-scale dataset for table-based fact verification.</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>Table-to-natural-language rendering</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Convert table cells/headers/rows into natural-language sentences or text sequences (rendered textual descriptions), then feed the rendered text into a pre-trained language model like BERT to leverage its textual priors.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>Tabular data (tables used for fact verification and table QA)</td>
                        </tr>
                        <tr>
                            <td><strong>conversion_method</strong></td>
                            <td>Render rows/columns/cell entries into natural-language phrases or sentences (exact rendering scheme not detailed in this paper; referenced as prior work), then tokenize with standard BERT tokenizer and process as text.</td>
                        </tr>
                        <tr>
                            <td><strong>downstream_task</strong></td>
                            <td>Table-based fact verification and other table-aware QA tasks (use case cited: TabFact data and fact verification)</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>No numerical performance metrics for this approach are provided in this paper (only cited as related work).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_others</strong></td>
                            <td>Mentioned as an alternative to adding table-aware embeddings: Chen et al. experimented with rendering a table into natural language so BERT can handle it; TAPAS instead augments BERT with table-aware positional embeddings and pre-trains directly on text-table pairs. No direct empirical head-to-head comparison numbers provided in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>advantages</strong></td>
                            <td>Allows reuse of off-the-shelf text pre-trained models without architectural changes; conceptually simple (convert table into text).</td>
                        </tr>
                        <tr>
                            <td><strong>disadvantages</strong></td>
                            <td>Rendering may be lossy or require careful template design; may not capture fine-grained row/column structure unless rendering includes explicit markers; this paper reports no concrete gains and uses table-aware embeddings instead.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>Not analyzed in this paper; the authors note prior work experimented with rendering but advocate for direct table-aware pre-training instead due to scalability/coverage considerations.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'TaPas: Weakly Supervised Table Parsing via Pre-training', 'publication_date_yy_mm': '2020-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8966.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e8966.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of methods for representing or converting graphs into text for language model training, including details of the representation, the type of graph, the conversion process, downstream tasks, performance metrics, comparisons to other methods, and any reported advantages, disadvantages, or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>GNN table representation (Müller et al. 2019)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Graph-based table representation using a Graph Neural Network for table QA</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Müller et al. represent the table and question as a graph and apply a Graph Neural Network to reason over table structure for conversational question answering, selecting relevant table cells but (as reported) not predicting aggregation operators.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Answering conversational questions on structured data without logical forms.</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>Table+question Graph Neural Network (GNN) encoding</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Construct a graph whose nodes represent table elements (cells, headers, possibly question tokens) with edges encoding relations (e.g., cell-header, adjacent cells), and apply a Graph Neural Network to produce contextualized node embeddings used to select answer cells.</td>
                        </tr>
                        <tr>
                            <td><strong>graph_type</strong></td>
                            <td>Tabular data represented as graphs (cells, headers, possibly conversational context nodes)</td>
                        </tr>
                        <tr>
                            <td><strong>conversion_method</strong></td>
                            <td>Map table structure into nodes and edges (explicit graph construction rather than linearization), then run message-passing GNN layers to propagate information across the graph; final node embeddings are used for cell-selection scoring.</td>
                        </tr>
                        <tr>
                            <td><strong>downstream_task</strong></td>
                            <td>Conversational question answering on tables (SQA-like tasks); cell selection for QA</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Reported in this paper (Table 5): Müller et al. (2019) SQA ALL accuracy 55.1%, SEQ 28.1%, Q1 67.2%, Q2 52.7%, Q3 46.8%. TAPAS substantially improves over these numbers (ALL 67.2%, SEQ 40.4%).</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_to_others</strong></td>
                            <td>This paper contrasts the GNN approach with TAPAS: Müller et al.'s model selects table cells but cannot predict aggregations; TAPAS achieves better accuracy and supports aggregation via its soft-execution mechanism and table-aware pre-training. Empirically TAPAS outperforms Müller et al. on SQA metrics reported in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>advantages</strong></td>
                            <td>Directly models table structure via graph edges and message passing, which can capture relational structure without flattening.</td>
                        </tr>
                        <tr>
                            <td><strong>disadvantages</strong></td>
                            <td>As implemented in Müller et al., the model could not predict aggregation operations (SUM, COUNT, AVERAGE) over selected cells, limiting coverage of certain question types; the architecture is less amenable to large-scale pre-training with masked-LM objectives compared to TAPAS's BERT-based encoder.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_cases</strong></td>
                            <td>Inability to produce aggregations; lower accuracy on SQA compared to TAPAS as reported in this paper. No further failure breakdown provided here.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'TaPas: Weakly Supervised Table Parsing via Pre-training', 'publication_date_yy_mm': '2020-04'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Answering conversational questions on structured data without logical forms. <em>(Rating: 2)</em></li>
                <li>Tabfact: A large-scale dataset for table-based fact verification. <em>(Rating: 2)</em></li>
                <li>Neural programmer: Inducing latent programs with gradient descent. <em>(Rating: 2)</em></li>
                <li>A comprehensive exploration on wikisql with table-aware word contextualization. <em>(Rating: 2)</em></li>
                <li>Neural enquirer: Learning to query tables in natural language. <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-8966",
    "paper_id": "paper-52cb05d721688cb766c6e282e9d55c3b8e3dc0cf",
    "extraction_schema_id": "extraction-schema-158",
    "extracted_data": [
        {
            "name_short": "TAPAS table-flattening",
            "name_full": "TAPAS: Flattened table serialization with table-aware positional embeddings",
            "brief_description": "TAPAS represents tables as a flattened sequence of word-piece tokens concatenated after the question, augmented with table-aware positional embeddings (position ID, segment ID, column/row ID, numeric rank ID, previous-answer flag). It is trained with masked language model pre-training on text-table pairs and fine-tuned end-to-end for question answering by predicting cell selections and optional aggregation operators.",
            "citation_title": "here",
            "mention_or_use": "use",
            "representation_name": "Flattened table serialization with table-aware positional embeddings",
            "representation_description": "Flatten each table into a sequence of word-piece tokens (concatenate question tokens first, then table header and cell tokens). Augment token embeddings with additional learned embeddings encoding: global token position (Position ID), segment (question vs table), column ID, row ID, numeric rank within a column (Rank ID), and a previous-answer marker for conversational rounds. Apply whole-cell masking during pre-training and feed the combined token+table-aware embeddings into a BERT-style encoder.",
            "graph_type": "Tabular data (semi-structured tables: WikiTables and Infoboxes; horizontal tables with header rows)",
            "conversion_method": "Tokenize question and table into word-pieces; start with first word of each column name and cell then add words turn-wise until a fixed word-piece budget (e.g., 128); transpose Infoboxes into single-row tables; concatenate question tokens, separator token, then flattened table tokens; apply whole-cell masking for table cells during masked-LM pre-training.",
            "downstream_task": "Weakly-supervised question answering over tables / semantic parsing (denotation prediction), including conversational QA (SQA), WikiSQL, and WikiTQ",
            "performance_metrics": "Denotation accuracy (weak supervision): WIKISQL dev 85.1% / test 83.6% (close to SOTA 83.9%); TAPAS (fully supervised) WIKISQL test 86.4%; SQA average question accuracy 67.2% (sequence accuracy 40.4%, improving SOTA from 55.1 to 67.2); WIKI TQ trained from original data 42.6%, pretraining on WikiSQL or SQA improves to 48.7% and 48.8% respectively.",
            "comparison_to_others": "Compared to graph- or program-based approaches, TAPAS uses a single encoder and no auto-regressive decoding, and benefits from pre-training on millions of tables. It outperforms or matches other methods on benchmarks: rivals discrete-hard-EM SQL approaches on WikiSQL and substantially outperforms a GNN-based table approach (Müller et al., 2019) on SQA (TAPAS ALL 67.2% vs Müller et al. 55.1%). Ablations show table pre-training and column/row embeddings are most important.",
            "advantages": "Simple single-encoder architecture (no autoregressive program generation); supports aggregation operators (COUNT, SUM, AVERAGE) via a differentiable soft-execution layer; benefits from large-scale table+text pre-training; handles conversational signals via previous-answer embedding; trivial transfer learning across table QA datasets; strong empirical gains on SQA and competitive results on WikiSQL and WikiTQ.",
            "disadvantages": "Limited to single tables that fit the model's token budget (typically 512 tokens); representation flattens tabular structure into a sequence and thus requires additional embeddings to recover row/column information; expressivity limited to selecting a subset of cells plus a single aggregation (cannot represent multiple-aggregation programs or complex compositional queries outside this form).",
            "failure_cases": "Reported failure modes include: ambiguous questions or missing/wrong table labels (~12% of analyzed WIKI TQ errors); complex temporal comparisons not captured by model (~10%); gold denotation textual values not present in table (16%); tables too large to fit in sequence budget (10%); model selecting no cells (13%); aggregator operations outside model capability (e.g., difference between scalars) (2%); ~37% uncategorized. Pre-training also predicts numbers less accurately than words (masked-LM number accuracy 53.9% vs words 74.1% on held-out).",
            "uuid": "e8966.0",
            "source_info": {
                "paper_title": "TaPas: Weakly Supervised Table Parsing via Pre-training",
                "publication_date_yy_mm": "2020-04"
            }
        },
        {
            "name_short": "Table-to-text rendering (Chen et al. 2019)",
            "name_full": "Rendering tables into natural language to use pre-trained BERT (as in Chen et al., 2019)",
            "brief_description": "Reported in related work as an approach that converts a table into natural-language text so that an off-the-shelf pre-trained language model (BERT) can process the table as plain text, enabling downstream tasks such as table-based fact verification.",
            "citation_title": "Tabfact: A large-scale dataset for table-based fact verification.",
            "mention_or_use": "mention",
            "representation_name": "Table-to-natural-language rendering",
            "representation_description": "Convert table cells/headers/rows into natural-language sentences or text sequences (rendered textual descriptions), then feed the rendered text into a pre-trained language model like BERT to leverage its textual priors.",
            "graph_type": "Tabular data (tables used for fact verification and table QA)",
            "conversion_method": "Render rows/columns/cell entries into natural-language phrases or sentences (exact rendering scheme not detailed in this paper; referenced as prior work), then tokenize with standard BERT tokenizer and process as text.",
            "downstream_task": "Table-based fact verification and other table-aware QA tasks (use case cited: TabFact data and fact verification)",
            "performance_metrics": "No numerical performance metrics for this approach are provided in this paper (only cited as related work).",
            "comparison_to_others": "Mentioned as an alternative to adding table-aware embeddings: Chen et al. experimented with rendering a table into natural language so BERT can handle it; TAPAS instead augments BERT with table-aware positional embeddings and pre-trains directly on text-table pairs. No direct empirical head-to-head comparison numbers provided in this paper.",
            "advantages": "Allows reuse of off-the-shelf text pre-trained models without architectural changes; conceptually simple (convert table into text).",
            "disadvantages": "Rendering may be lossy or require careful template design; may not capture fine-grained row/column structure unless rendering includes explicit markers; this paper reports no concrete gains and uses table-aware embeddings instead.",
            "failure_cases": "Not analyzed in this paper; the authors note prior work experimented with rendering but advocate for direct table-aware pre-training instead due to scalability/coverage considerations.",
            "uuid": "e8966.1",
            "source_info": {
                "paper_title": "TaPas: Weakly Supervised Table Parsing via Pre-training",
                "publication_date_yy_mm": "2020-04"
            }
        },
        {
            "name_short": "GNN table representation (Müller et al. 2019)",
            "name_full": "Graph-based table representation using a Graph Neural Network for table QA",
            "brief_description": "Müller et al. represent the table and question as a graph and apply a Graph Neural Network to reason over table structure for conversational question answering, selecting relevant table cells but (as reported) not predicting aggregation operators.",
            "citation_title": "Answering conversational questions on structured data without logical forms.",
            "mention_or_use": "mention",
            "representation_name": "Table+question Graph Neural Network (GNN) encoding",
            "representation_description": "Construct a graph whose nodes represent table elements (cells, headers, possibly question tokens) with edges encoding relations (e.g., cell-header, adjacent cells), and apply a Graph Neural Network to produce contextualized node embeddings used to select answer cells.",
            "graph_type": "Tabular data represented as graphs (cells, headers, possibly conversational context nodes)",
            "conversion_method": "Map table structure into nodes and edges (explicit graph construction rather than linearization), then run message-passing GNN layers to propagate information across the graph; final node embeddings are used for cell-selection scoring.",
            "downstream_task": "Conversational question answering on tables (SQA-like tasks); cell selection for QA",
            "performance_metrics": "Reported in this paper (Table 5): Müller et al. (2019) SQA ALL accuracy 55.1%, SEQ 28.1%, Q1 67.2%, Q2 52.7%, Q3 46.8%. TAPAS substantially improves over these numbers (ALL 67.2%, SEQ 40.4%).",
            "comparison_to_others": "This paper contrasts the GNN approach with TAPAS: Müller et al.'s model selects table cells but cannot predict aggregations; TAPAS achieves better accuracy and supports aggregation via its soft-execution mechanism and table-aware pre-training. Empirically TAPAS outperforms Müller et al. on SQA metrics reported in this paper.",
            "advantages": "Directly models table structure via graph edges and message passing, which can capture relational structure without flattening.",
            "disadvantages": "As implemented in Müller et al., the model could not predict aggregation operations (SUM, COUNT, AVERAGE) over selected cells, limiting coverage of certain question types; the architecture is less amenable to large-scale pre-training with masked-LM objectives compared to TAPAS's BERT-based encoder.",
            "failure_cases": "Inability to produce aggregations; lower accuracy on SQA compared to TAPAS as reported in this paper. No further failure breakdown provided here.",
            "uuid": "e8966.2",
            "source_info": {
                "paper_title": "TaPas: Weakly Supervised Table Parsing via Pre-training",
                "publication_date_yy_mm": "2020-04"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Answering conversational questions on structured data without logical forms.",
            "rating": 2
        },
        {
            "paper_title": "Tabfact: A large-scale dataset for table-based fact verification.",
            "rating": 2
        },
        {
            "paper_title": "Neural programmer: Inducing latent programs with gradient descent.",
            "rating": 2
        },
        {
            "paper_title": "A comprehensive exploration on wikisql with table-aware word contextualization.",
            "rating": 2
        },
        {
            "paper_title": "Neural enquirer: Learning to query tables in natural language.",
            "rating": 1
        }
    ],
    "cost": 0.01183725,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>TAPAS: Weakly Supervised Table Parsing via Pre-training</h1>
<p>Jonathan Herzig ${ }^{1,2}$, Paweł Krzysztof Nowak ${ }^{1}$, Thomas Müller ${ }^{1}$, Francesco Piccinno ${ }^{1}$, Julian Martin Eisenschlos ${ }^{1}$<br>${ }^{1}$ Google Research<br>${ }^{2}$ School of Computer Science, Tel-Aviv University<br>{jherzig, pawel now, thomasmueller, piccinno, eisen julian}@google.com</p>
<h4>Abstract</h4>
<p>Answering natural language questions over tables is usually seen as a semantic parsing task. To alleviate the collection cost of full logical forms, one popular approach focuses on weak supervision consisting of denotations instead of logical forms. However, training semantic parsers from weak supervision poses difficulties, and in addition, the generated logical forms are only used as an intermediate step prior to retrieving the denotation. In this paper, we present TAPAS, an approach to question answering over tables without generating logical forms. TAPAS trains from weak supervision, and predicts the denotation by selecting table cells and optionally applying a corresponding aggregation operator to such selection. TAPAS extends BERT's architecture to encode tables as input, initializes from an effective joint pre-training of text segments and tables crawled from Wikipedia, and is trained end-to-end. We experiment with three different semantic parsing datasets, and find that TAPAS outperforms or rivals semantic parsing models by improving state-of-the-art accuracy on SQA from 55.1 to 67.2 and performing on par with the state-of-the-art on WIKISQL and WIKITQ, but with a simpler model architecture. We additionally find that transfer learning, which is trivial in our setting, from WIKISQL to WIKITQ, yields 48.7 accuracy, 4.2 points above the state-of-the-art.</p>
<h2>1 Introduction</h2>
<p>Question answering from semi-structured tables is usually seen as a semantic parsing task where the question is translated to a logical form that can be executed against the table to retrieve the correct denotation (Pasupat and Liang, 2015; Zhong et al., 2017; Dasigi et al., 2019; Agarwal et al., 2019). Semantic parsers rely on supervised training data that pairs natural language questions with logical forms, but such data is expensive to annotate.</p>
<p>In recent years, many attempts aim to reduce
the burden of data collection for semantic parsing, including paraphrasing (Wang et al., 2015), human in the loop (Iyer et al., 2017; Lawrence and Riezler, 2018) and training on examples from other domains (Herzig and Berant, 2017; Su and Yan, 2017). One prominent data collection approach focuses on weak supervision where a training example consists of a question and its denotation instead of the full logical form (Clarke et al., 2010; Liang et al., 2011; Artzi and Zettlemoyer, 2013). Although appealing, training semantic parsers from this input is often difficult due to the abundance of spurious logical forms (Berant et al., 2013; Guu et al., 2017) and reward sparsity (Agarwal et al., 2019; Muhlgay et al., 2019).</p>
<p>In addition, semantic parsing applications only utilize the generated logical form as an intermediate step in retrieving the answer. Generating logical forms, however, introduces difficulties such as maintaining a logical formalism with sufficient expressivity, obeying decoding constraints (e.g. wellformedness), and the label bias problem (Andor et al., 2016; Lafferty et al., 2001).</p>
<p>In this paper we present TAPAS (for Table Parser), a weakly supervised question answering model that reasons over tables without generating logical forms. TAPAS predicts a minimal program by selecting a subset of the table cells and a possible aggregation operation to be executed on top of them. Consequently, TAPAS can learn operations from natural language, without the need to specify them in some formalism. This is implemented by extending BERT's architecture (Devlin et al., 2019) with additional embeddings that capture tabular structure, and with two classification layers for selecting cells and predicting a corresponding aggregation operator.</p>
<p>Importantly, we introduce a pre-training method for TAPAS, crucial for its success on the end task. We extend BERT's masked language model objective to structured data, and pre-train the model over</p>
<p>millions of tables and related text segments crawled from Wikipedia. During pre-training, the model masks some tokens from the text segment and from the table itself, where the objective is to predict the original masked token based on the textual and tabular context.</p>
<p>Finally, we present an end-to-end differentiable training recipe that allows TAPAS to train from weak supervision. For examples that only involve selecting a subset of the table cells, we directly train the model to select the gold subset. For examples that involve aggregation, the relevant cells and the aggregation operation are not known from the denotation. In this case, we calculate an expected soft scalar outcome over all aggregation operators given the current model, and train the model with a regression loss against the gold denotation.</p>
<p>In comparison to prior attempts to reason over tables without generating logical forms (Neelakantan et al., 2015; Yin et al., 2016; Müller et al., 2019), TAPAS achieves better accuracy, and holds several advantages: its architecture is simpler as it includes a single encoder with no auto-regressive decoding, it enjoys pre-training, tackles more question types such as those that involve aggregation, and directly handles a conversational setting.</p>
<p>We find that on three different semantic parsing datasets, TAPAS performs better or on par in comparison to other semantic parsing and question answering models. On the conversational SQA (Iyyer et al., 2017), TAPAS improves state-of-the-art accuracy from 55.1 to 67.2 , and achieves on par performance on WikiSQL (Zhong et al., 2017) and WikiTQ (Pasupat and Liang, 2015). Transfer learning, which is simple in TAPAS, from WikiSQL to WikiTQ achieves 48.7 accuracy, 4.2 points higher than state-of-the-art. Our code and pre-trained model are publicly available at https: //github.com/google-research/tapas.</p>
<h2>2 TAPAS Model</h2>
<p>Our model's architecture (Figure 1) is based on BERT's encoder with additional positional embeddings used to encode tabular structure (visualized in Figure 2). We flatten the table into a sequence of words, split words into word pieces (tokens) and concatenate the question tokens before the table tokens. We additionally add two classification layers for selecting table cells and aggregation operators that operate on the cells. We now describe these modifications and how inference is performed.
<img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: TAPAS model (bottom) with example model outputs for the question: "Total number of days for the top two". Cell prediction (top right) is given for the selected column's table cells in bold (zero for others) along with aggregation prediction (top left).</p>
<p>Additional embeddings We add a separator token between the question and the table, but unlike Hwang et al. (2019) not between cells or rows. Instead, the token embeddings are combined with table-aware positional embeddings before feeding them to the model. We use different kinds of positional embeddings:</p>
<ul>
<li>Position ID is the index of the token in the flattened sequence (same as in BERT).</li>
<li>Segment ID takes two possible values: 0 for the question, and 1 for the table header and cells.</li>
<li>Column / Row ID is the index of the column/row that this token appears in, or 0 if the token is a part of the question.</li>
<li>Rank ID if column values can be parsed as floats or dates, we sort them accordingly and assign an embedding based on their numeric rank ( 0 for not comparable, 1 for the smallest item, $i+1$ for an item with rank $i$ ). This can assist the model when processing questions that involve superlatives, as word pieces may not represent numbers informatively (Wallace et al., 2019).</li>
<li>Previous Answer given a conversational setup where the current question might refer to the previous question or its answers (e.g., question 5 in Figure 3), we add a special embedding that marks whether a cell token was the answer to the previous question ( 1 if the token's cell was an answer, or 0 otherwise).</li>
</ul>
<p>Cell selection This classification layer selects a subset of the table cells. Depending on the selected</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: Encoding of the question "query?" and a simple table using the special embeddings of TAPAS. The previous answer embeddings are omitted for brevity.</p>
<p>aggregation operator, these cells can be the final answer or the input used to compute the final answer. Cells are modelled as independent Bernoulli variables. First, we compute the logit for a token using a linear layer on top of its last hidden vector. Cell logits are then computed as the average over logits of tokens in that cell. The output of the layer is the probability ( p_s^{(c)} ) to select cell ( c ). We additionally found it useful to add an inductive bias to select cells within a single column. We achieve this by introducing a categorical variable to select the correct column. The model computes the logit for a given column by applying a new linear layer to the average embedding for cells appearing in that column. We add an additional column logit that corresponds to selecting no column or cells. We treat this as an extra column with no cells. The output of the layer is the probability ( p_{\text{col}}^{(c) \prime} ) to select column ( co ) computed using softmax over the column logits. We set cell probabilities ( p_s^{(c)} ) outside the selected column to 0.</p>
<p><strong>Aggregation operator prediction</strong> Semantic parsing tasks require discrete reasoning over the table, such as summing numbers or counting cells. To handle these cases without producing logical forms, TAPAS outputs a subset of the table cells together with an optional <em>aggregation operator</em>. The aggregation operator describes an operation to be applied to the selected cells, such as SUM, COUNT, AVERAGE or NONE. The operator is selected by a linear layer followed by a softmax on top of the final hidden vector of the first token (the special [CLS] token). We denote this layer as ( p_a(op) ), where ( op ) is some aggregation operator.</p>
<p><strong>Inference</strong> We predict the most likely aggregation operator together with a subset of the cells (using the cell selection layer). To predict a discrete cell selection we select all table cells for which their probability is larger than 0.5. These predictions are then executed against the table to retrieve the answer, by applying the predicted aggregation over the selected cells.</p>
<h3>3 Pre-training</h3>
<p>Following the recent success of pre-training models on textual data for natural language understanding tasks, we wish to extend this procedure to structured data, as an initialization for our table parsing task. To this end, we pre-train TAPAS on a large number of tables from Wikipedia. This allows the model to learn many interesting correlations between text and the table, and between the cells of a column and their header.</p>
<p>We create pre-training inputs by extracting text-table pairs from Wikipedia. We extract 6.2M tables: 3.3M of class <em>Infobox</em><sup>1</sup> and 2.9M of class <em>WikiTable</em>. We consider tables with at most 500 cells. All of the end task datasets we experiment with only contain horizontal tables with a header row with column names. Therefore, we only extract Wiki tables of this form using the <th> tag to identify headers. We furthermore, transpose Infoboxes into a table with a single header and a single data row. The tables, created from Infoboxes, are arguably not very typical, but we found them to improve performance on the end tasks.</p>
<p>As a proxy for questions that appear in the end tasks, we extract the table caption, article title, article description, segment title and text of the segment the table occurs in as relevant text snippets. In this way we extract 21.3M snippets.</p>
<p>We convert the extracted text-table pairs to pre-training examples as follows: Following Devlin et al. (2019), we use a masked language model pre-training objective. We also experimented with adding a second objective of predicting whether</p>
<p><sup>1</sup> en.wikipedia.org/wiki/Help:Infobox</p>
<p>the table belongs to the text or is a random table but did not find this to improve the performance on the end tasks. This is aligned with Liu et al. (2019) that similarly did not benefit from a next sentence prediction task.</p>
<p>For pre-training to be efficient, we restrict our word piece sequence length to a certain budget (e.g., we use 128 in our final experiments). That is, the combined length of tokenized text and table cells has to fit into this budget. To achieve this, we randomly select a snippet of 8 to 16 word pieces from the associated text. To fit the table, we start by only adding the first word of each column name and cell. We then keep adding words turn-wise until we reach the word piece budget. For every table we generate 10 different snippets in this way.</p>
<p>We follow the masking procedure introduced by BERT. We use whole word masking ${ }^{2}$ for the text, and we find it beneficial to apply whole cell masking (masking all the word pieces of the cell if any of its pieces is masked) to the table as well.</p>
<p>We note that we additionally experimented with data augmentation, which shares a similar goal to pre-training. We generated synthetic pairs of questions and denotations over real tables via a grammar, and augmented these to the end tasks training data. As this did not improve end task performance significantly, we omit these results.</p>
<h2>4 Fine-tuning</h2>
<p>Overview We formally define table parsing in a weakly supervised setup as follows. Given a training set of $N$ examples $\left{\left(x_{i}, T_{i}, y_{i}\right)\right}<em i="i">{i=1}^{N}$, where $x</em>$ is a corresponding set of denotations, our goal is to learn a model that maps a new utterance $x$ to a program $z$, such that when $z$ is executed against the corresponding table $T$, it yields the correct denotation $y$. The program $z$ comprises a subset of the table cells and an optional aggregation operator. The table $T$ maps a table cell to its value.}$ is an utterance, $T_{i}$ is a table and $y_{i</p>
<p>As a pre-processing step described in Section 5.1, we translate the set of denotations $y$ for each example to a tuple $(C, s)$ of cell coordinates $C$ and a scalar $s$, which is only populated when $y$ is a single scalar. We then guide training according to the content of $(C, s)$. For cell selection examples, for which $s$ is not populated, we train the model to select the cells in $C$. For scalar answer examples,</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup>where $s$ is populated but $C$ is empty, we train the model to predict an aggregation over the table cells that amounts to $s$. We now describe each of these cases in detail.</p>
<p>Cell selection In this case $y$ is mapped to a subset of the table cell coordinates $C$ (e.g., question 1 in Figure 3). For this type of examples, we use a hierarchical model that first selects a single column and then cells from within that column only.</p>
<p>We directly train the model to select the column col which has the highest number of cells in $C$. For our datasets cells $C$ are contained in a single column and so this restriction on the model provides a useful inductive bias. If $C$ is empty we select the additional empty column corresponding to empty cell selection. The model is then trained to select cells $C \cap$ col and not select $(T \backslash C) \cap$ col. The loss is composed of three components: (1) the average binary cross-entropy loss over column selections:</p>
<p>$$
\mathcal{J}<em _mathrm_co="\mathrm{co">{\text {columns }}=\frac{1}{|\mathrm{Cols}|} \sum</em>\right)
$$} \in \mathrm{Cols}} \mathrm{CE}\left(p_{\mathrm{col}}^{(\mathrm{co})}, \mathbb{1}_{\mathrm{co}=\mathrm{col}</p>
<p>where the set of columns Cols includes the additional empty column, $\mathrm{CE}(\cdot)$ is the cross entropy loss, $\mathbb{1}$ is the indicator function. (2) the average binary cross-entropy loss over column cell selections:</p>
<p>$$
\mathcal{J}<em _in="\in" _operatorname_Cells="\operatorname{Cells" c="c">{\text {cells }}=\frac{1}{|\operatorname{Cells}(\mathrm{col})|} \sum</em>\right)
$$}(\mathrm{col})} \operatorname{CE}\left(p_{\mathrm{s}}^{(c)}, \mathbb{1}_{c \in C</p>
<p>where Cells $(\mathrm{col})$ is the set of cells in the chosen column. (3) As for cell selection examples no aggregation occurs, we define the aggregation supervision to be NONE (assigned to $o p_{0}$ ), and the aggregation loss is:</p>
<p>$$
\mathcal{J}<em _mathrm_a="\mathrm{a">{\text {aggr }}=-\log p</em>\right)
$$}}\left(o p_{0</p>
<p>The total loss is then $\mathcal{J}<em _columns="{columns" _text="\text">{\mathrm{CS}}=\mathcal{J}</em>}}+\mathcal{J<em _aggr="{aggr" _text="\text">{\text {cells }}+$ $\alpha \mathcal{J}</em>$, where $\alpha$ is a scaling hyperparameter.}</p>
<p>Scalar answer In this case $y$ is a single scalar $s$ which does not appear in the table (i.e. $C=\emptyset$, e.g., question 2 in Figure 3). This usually corresponds to examples that involve an aggregation over one or more table cells. In this work we handle aggregation operators that correspond to SQL, namely COUNT, AVERAGE and SUM, however our model is not restricted to these.</p>
<p>For these examples, the table cells that should be selected and the aggregation operator type are not known, as these cannot be directly inferred from</p>
<p>Table</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Rank</th>
<th style="text-align: left;">Name</th>
<th style="text-align: center;">No. of <br> reigns</th>
<th style="text-align: center;">Conditional <br> days</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: left;">Lou Thesz</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">3,749</td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: left;">Ric Flair</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">3,103</td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: left;">Harley Race</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">1,799</td>
</tr>
<tr>
<td style="text-align: center;">4</td>
<td style="text-align: left;">Dory Funk Jr.</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1,563</td>
</tr>
<tr>
<td style="text-align: center;">5</td>
<td style="text-align: left;">Dan Severn</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1,559</td>
</tr>
<tr>
<td style="text-align: center;">6</td>
<td style="text-align: left;">Gene Kiniski</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1,131</td>
</tr>
</tbody>
</table>
<p>Example questions</p>
<table>
<thead>
<tr>
<th style="text-align: center;">5</th>
<th style="text-align: center;">Question</th>
<th style="text-align: center;">Answer</th>
<th style="text-align: center;">Example Type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Which wrestler had the most number of reigns?</td>
<td style="text-align: center;">Ric Flair</td>
<td style="text-align: center;">Cell selection</td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;">Average time as champion for top 2 wrestlers?</td>
<td style="text-align: center;">AVG(3749,3103)=3426</td>
<td style="text-align: center;">Scalar answer</td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: center;">How many world champions are there with only one reign?</td>
<td style="text-align: center;">COUNT(Dory Funk Jr., <br> Gene Kiniski)=2</td>
<td style="text-align: center;">Ambiguous answer</td>
</tr>
<tr>
<td style="text-align: center;">4</td>
<td style="text-align: center;">What is the number of reigns for Harley Race?</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">Ambiguous answer</td>
</tr>
<tr>
<td style="text-align: center;">5</td>
<td style="text-align: center;">Which of the following wrestlers were ranked in the bottom 3?</td>
<td style="text-align: center;">(Dory Funk Jr., Dan Severn, Gene Kiniski)</td>
<td style="text-align: center;">Cell selection</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Out of these, who had more than one reign?</td>
<td style="text-align: center;">Dan Severn</td>
<td style="text-align: center;">Cell selection</td>
</tr>
</tbody>
</table>
<p>Figure 3: A table (left) with corresponding example questions (right). The last example is conversational.
the scalar answer $s$. To train the model given this form of supervision one could search offline (Dua et al., 2019; Andor et al., 2019) or online (Berant et al., 2013; Liang et al., 2018) for programs (table cells and aggregation) that execute to $s$. In our table parsing setting, the number of spurious programs that execute to the gold scalar answer can grow quickly with the number of table cells (e.g., when $s=5$, each COUNT over any five cells is potentially correct). As with this approach learning can easily fail, we avoid it.</p>
<p>Instead, we make use of a training recipe where no search for correct programs is needed. Our approach results in an end-to-end differentiable training, similar in spirit to Neelakantan et al. (2015). We implement a fully differentiable layer that latently learns the weights for the aggregation prediction layer $p_{\mathrm{a}}(\cdot)$, without explicit supervision for the aggregation type.</p>
<p>Specifically, we recognize that the result of executing each of the supported aggregation operators is a scalar. We then implement a soft differentiable estimation for each operator (Table 1), given the token selection probabilities and the table values: compute $(o p, p_{\mathrm{s}}, T)$. Given the results for all aggregation operators we then calculate the expected result according to the current model:</p>
<p>$$
s_{\text {pred }}=\sum_{i=1} \hat{p}<em i="i">{\mathrm{a}}\left(o p</em>, T\right)
$$}\right) \cdot \operatorname{compute}\left(o p_{i}, p_{\mathrm{s}</p>
<p>where $\hat{p}<em i="i">{\mathrm{a}}\left(o p</em>$ is a probability distribution normalized over aggregation operators excluding NONE.}\right)=\frac{p_{\mathrm{s}}\left(o p_{i}\right)}{\sum_{i=1} p_{\mathrm{s}}\left(o p_{i}\right)</p>
<p>We then calculate the scalar answer loss with Huber loss (Huber, 1964) given by:</p>
<p>$$
\mathcal{J}_{\text {scalar }}=\left{\begin{array}{lr}
0.5 \cdot a^{2} &amp; a \leq \delta \
\delta \cdot a-0.5 \cdot \delta^{2} &amp; \text { otherwise }
\end{array}\right.
$$</p>
<table>
<thead>
<tr>
<th style="text-align: left;">$o p$</th>
<th style="text-align: center;">compute $\left(o p, p_{\mathrm{s}}, T\right)$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">COUNT</td>
<td style="text-align: center;">$\sum_{c \in T} p_{\mathrm{s}}^{(c)}$</td>
</tr>
<tr>
<td style="text-align: left;">SUM</td>
<td style="text-align: center;">$\sum_{c \in T} p_{\mathrm{s}}^{(c)} \cdot T[c]$</td>
</tr>
<tr>
<td style="text-align: left;">AVERAGE</td>
<td style="text-align: center;">compute $\left(\operatorname{SUM}<em _mathrm_s="\mathrm{s">{( } p</em>, T\right)$}</td>
</tr>
</tbody>
</table>
<p>Table 1: Aggregation operators soft implementation. AVERAGE approximation is discussed in Appendix D. Note that probabilities $p_{\mathrm{s}}^{(c)}$ outside of the column selected by the model are set to 0 .
where $a=\left|s_{\text {pred }}-s\right|$, and $\delta$ is a hyperparameter. Like Neelakantan et al. (2015), we find this loss is more stable than the squared loss. In addition, since a scalar answer implies some aggregation operation, we also define an aggregation loss that penalizes the model for assigning probability mass to the NONE class:</p>
<p>$$
\mathcal{J}<em i="1">{\text {aggr }}=-\log \left(\sum</em>\right)\right)
$$} p_{\mathrm{a}}\left(o p_{i</p>
<p>The total loss is then $\mathcal{J}<em _aggr="{aggr" _text="\text">{\mathrm{SA}}=\mathcal{J}</em>}}+\beta \mathcal{J<em _scalar="{scalar" _text="\text">{\text {scalar }}$, where $\beta$ is a scaling hyperparameter. As for some examples $\mathcal{J}</em>}}$ can be very large, which leads to unstable model updates, we introduce a cutoff hyperparameter. Then, for a training example where $\mathcal{J<em _mathrm_s="\mathrm{s">{\text {scalar }}&gt;$ cutoff, we set $\mathcal{J}=0$ to ignore the example entirely, as we noticed this behaviour correlates with outliers. In addition, as computation done during training is continuous, while that being done during inference is discrete, we further add a temperature that scales token logits such that $p</em>$ would output values closer to binary ones.}</p>
<p>Ambiguous answer A scalar answer $s$ that also appears in the table (thus $C \neq \emptyset$ ) is ambiguous, as in some cases the question implies aggregation (question 3 in Figure 3), while in other cases a table</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;">WIKISQL</th>
<th style="text-align: left;">WIKI TQ</th>
<th style="text-align: left;">SQA</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Logical Form</td>
<td style="text-align: left;">$\checkmark$</td>
<td style="text-align: left;">$\boldsymbol{x}$</td>
<td style="text-align: left;">$\boldsymbol{x}$</td>
</tr>
<tr>
<td style="text-align: left;">Conversational</td>
<td style="text-align: left;">$\boldsymbol{x}$</td>
<td style="text-align: left;">$\boldsymbol{x}$</td>
<td style="text-align: left;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: left;">Aggregation</td>
<td style="text-align: left;">$\checkmark$</td>
<td style="text-align: left;">$\checkmark$</td>
<td style="text-align: left;">$\boldsymbol{x}$</td>
</tr>
<tr>
<td style="text-align: left;">Examples</td>
<td style="text-align: left;">80654</td>
<td style="text-align: left;">22033</td>
<td style="text-align: left;">17553</td>
</tr>
<tr>
<td style="text-align: left;">Tables</td>
<td style="text-align: left;">24241</td>
<td style="text-align: left;">2108</td>
<td style="text-align: left;">982</td>
</tr>
</tbody>
</table>
<p>Table 2: Dataset statistics.
cell should be predicted (question 4 in Figure 3). Thus, in this case we dynamically let the model choose the supervision (cell selection or scalar answer) according to its current policy. Concretely, we set the supervision to be of cell selection if $p_{\mathrm{a}}\left(o p_{0}\right) \geq S$, where $0&lt;S&lt;1$ is a threshold hyperparameter, and the scalar answer supervision otherwise. This follows hard EM (Min et al., 2019), as for spurious programs we pick the most probable one according to the current model.</p>
<h2>5 Experiments</h2>
<h3>5.1 Datasets</h3>
<p>We experiment with the following semantic parsing datasets that reason over single tables (see Table 2).</p>
<p>WIKI TQ (Pasupat and Liang, 2015) This dataset consists of complex questions on Wikipedia tables. Crowd workers were asked, given a table, to compose a series of complex questions that include comparisons, superlatives, aggregation or arithmetic operation. The questions were then verified by other crowd workers.</p>
<p>SQA (Iyyer et al., 2017) This dataset was constructed by asking crowd workers to decompose a subset of highly compositional questions from WIKI TQ, where each resulting decomposed question can be answered by one or more table cells. The final set consists of 6,066 question sequences (2.9 question per sequence on average).</p>
<p>WIKISQL (Zhong et al., 2017) This dataset focuses on translating text to SQL. It was constructed by asking crowd workers to paraphrase a templatebased question in natural language. Two other crowd workers were asked to verify the quality of the proposed paraphrases.</p>
<p>As our model predicts cell selection or scalar answers, we convert the denotations for each dataset to 〈question, cell coordinates, scalar answer〉 triples. SQA already provides this information
(gold cells for each question). For WIKISQL and WIKI TQ, we only use the denotations. Therefore, we derive cell coordinates by matching the denotations against the table contents. We fill scalar answer information if the denotation contains a single element that can be interpreted as a float, otherwise we set its value to NaN . We drop examples if there is no scalar answer and the denotation can not be found in the table, or if some denotation matches multiple cells.</p>
<h3>5.2 Experimental Setup</h3>
<p>We apply the standard BERT tokenizer on questions, table cells and headers, using the same vocabulary of 32 k word pieces. Numbers and dates are parsed in a similar way as in the Neural Programmer (Neelakantan et al., 2017).</p>
<p>The official evaluation script of WIKI TQ and SQA is used to report the denotation accuracy for these datasets. For WIKISQL, we generate the reference answer, aggregation operator and cell coordinates from the reference SQL provided using our own SQL implementation running on the JSON tables. However, we find that the answer produced by the official WIKISQL evaluation script is incorrect for approx. $2 \%$ of the examples. Throughout this paper we report accuracies against our reference answers, but we explain the differences and also provide accuracies compared to the official reference answers in Appendix A.</p>
<p>We start pre-training from BERT-Large (see Appendix B for hyper-parameters). We find it beneficial to start the pre-training from a pre-trained standard text BERT model (while randomly initializing our additional embeddings), as this enhances convergence on the held-out set.</p>
<p>We run both pre-training and fine-tuning on a setup of 32 Cloud TPU v3 cores with maximum sequence length 512. In this setup pre-training takes around 3 days and fine-tuning around 10 hours for WIKISQL and WIKI TQ and 20 hours for SQA (with the batch sizes from table 12). The resource requirements of our model are essentially the same as BERT-large ${ }^{3}$.</p>
<p>For fine-tuning, we choose hyper-parameters using a black box Bayesian optimizer similar to Google Vizier (Golovin et al., 2017) for WIKISQL and WIKI TQ. For SQA we use grid-search. We discuss the details in Appendix B.</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: center;">Dev</th>
<th style="text-align: center;">Test</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Liang et al. (2018)</td>
<td style="text-align: center;">71.8</td>
<td style="text-align: center;">72.4</td>
</tr>
<tr>
<td style="text-align: left;">Agarwal et al. (2019)</td>
<td style="text-align: center;">74.9</td>
<td style="text-align: center;">74.8</td>
</tr>
<tr>
<td style="text-align: left;">Wang et al. (2019)</td>
<td style="text-align: center;">79.4</td>
<td style="text-align: center;">79.3</td>
</tr>
<tr>
<td style="text-align: left;">Min et al. (2019)</td>
<td style="text-align: center;">84.4</td>
<td style="text-align: center;">$\mathbf{8 3 . 9}$</td>
</tr>
<tr>
<td style="text-align: left;">TAPAS</td>
<td style="text-align: center;">$\mathbf{8 5 . 1}$</td>
<td style="text-align: center;">83.6</td>
</tr>
<tr>
<td style="text-align: left;">TAPAS (fully-supervised)</td>
<td style="text-align: center;">88.0</td>
<td style="text-align: center;">86.4</td>
</tr>
</tbody>
</table>
<p>Table 3: WiKiSQL denotation accuracy ${ }^{4}$.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: center;">Test</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Pasupat and Liang (2015)</td>
<td style="text-align: center;">37.1</td>
</tr>
<tr>
<td style="text-align: left;">Neelakantan et al. (2017)</td>
<td style="text-align: center;">34.2</td>
</tr>
<tr>
<td style="text-align: left;">Haug et al. (2018)</td>
<td style="text-align: center;">34.8</td>
</tr>
<tr>
<td style="text-align: left;">Zhang et al. (2017)</td>
<td style="text-align: center;">43.7</td>
</tr>
<tr>
<td style="text-align: left;">Liang et al. (2018)</td>
<td style="text-align: center;">43.1</td>
</tr>
<tr>
<td style="text-align: left;">Dasigi et al. (2019)</td>
<td style="text-align: center;">43.9</td>
</tr>
<tr>
<td style="text-align: left;">Agarwal et al. (2019)</td>
<td style="text-align: center;">44.1</td>
</tr>
<tr>
<td style="text-align: left;">Wang et al. (2019)</td>
<td style="text-align: center;">44.5</td>
</tr>
<tr>
<td style="text-align: left;">TAPAS</td>
<td style="text-align: center;">42.6</td>
</tr>
<tr>
<td style="text-align: left;">TAPAS (pre-trained on WiKiSQL)</td>
<td style="text-align: center;">48.7</td>
</tr>
<tr>
<td style="text-align: left;">TAPAS (pre-trained on SQA)</td>
<td style="text-align: center;">48.8</td>
</tr>
</tbody>
</table>
<p>Table 4: WIKI TQ denotation accuracy.</p>
<h3>5.3 Results</h3>
<p>All results report the denotation accuracy for models trained from weak supervision. We follow Niven and Kao (2019) and report the median for 5 independent runs, as BERT-based models can degenerate. We present our results for WiKiSQL and WiKiTQ in Tables 3 and 4 respectively. Table 3 shows that TAPAS, trained in the weakly supervised setting, achieves close to state-of-the-art performance for WiKiSQL ( 83.6 vs 83.9 (Min et al., 2019)). If given the gold aggregation operators and selected cell as supervision (extracted from the reference SQL), which accounts as full supervision to TAPAS, the model achieves 86.4 . Unlike the full SQL queries, this supervision can be annotated by non-experts.</p>
<p>For WIKI TQ the model trained only from the original training data reaches 42.6 which surpass similar approaches (Neelakantan et al., 2015). When we pre-train the model on WIKISQL or SQA (which is straight-forward in our setup, as we do not rely on a logical formalism), TAPAS achieves 48.7 and 48.8 , respectively.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: right;">ALL</th>
<th style="text-align: right;">SEQ</th>
<th style="text-align: right;">Q1</th>
<th style="text-align: right;">Q2</th>
<th style="text-align: right;">Q3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Pasupat and Liang (2015)</td>
<td style="text-align: right;">33.2</td>
<td style="text-align: right;">7.7</td>
<td style="text-align: right;">51.4</td>
<td style="text-align: right;">22.2</td>
<td style="text-align: right;">22.3</td>
</tr>
<tr>
<td style="text-align: left;">Neelakantan et al. (2017)</td>
<td style="text-align: right;">40.2</td>
<td style="text-align: right;">11.8</td>
<td style="text-align: right;">60.0</td>
<td style="text-align: right;">35.9</td>
<td style="text-align: right;">25.5</td>
</tr>
<tr>
<td style="text-align: left;">Iyyer et al. (2017)</td>
<td style="text-align: right;">44.7</td>
<td style="text-align: right;">12.8</td>
<td style="text-align: right;">70.4</td>
<td style="text-align: right;">41.1</td>
<td style="text-align: right;">23.6</td>
</tr>
<tr>
<td style="text-align: left;">Sun et al. (2018)</td>
<td style="text-align: right;">45.6</td>
<td style="text-align: right;">13.2</td>
<td style="text-align: right;">70.3</td>
<td style="text-align: right;">42.6</td>
<td style="text-align: right;">24.8</td>
</tr>
<tr>
<td style="text-align: left;">Müller et al. (2019)</td>
<td style="text-align: right;">55.1</td>
<td style="text-align: right;">28.1</td>
<td style="text-align: right;">67.2</td>
<td style="text-align: right;">52.7</td>
<td style="text-align: right;">46.8</td>
</tr>
<tr>
<td style="text-align: left;">TAPAS</td>
<td style="text-align: right;">$\mathbf{6 7 . 2}$</td>
<td style="text-align: right;">$\mathbf{4 0 . 4}$</td>
<td style="text-align: right;">$\mathbf{7 8 . 2}$</td>
<td style="text-align: right;">$\mathbf{6 6 . 0}$</td>
<td style="text-align: right;">$\mathbf{5 9 . 7}$</td>
</tr>
</tbody>
</table>
<p>Table 5: SQA test results. ALL is the average question accuracy, SEQ the sequence accuracy, and QX, the accuracy of the X'th question in a sequence.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: center;">SQA (SEQ)</th>
<th style="text-align: center;">WIKISQL</th>
<th style="text-align: center;">WIKI TQ</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">all</td>
<td style="text-align: center;">39.0</td>
<td style="text-align: center;">84.7</td>
<td style="text-align: center;">29.0</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">-pos</td>
<td style="text-align: center;">36.7</td>
<td style="text-align: center;">-2.3</td>
<td style="text-align: center;">82.9</td>
<td style="text-align: center;">-1.8</td>
<td style="text-align: center;">25.3</td>
</tr>
<tr>
<td style="text-align: left;">-ranks</td>
<td style="text-align: center;">34.4</td>
<td style="text-align: center;">-4.6</td>
<td style="text-align: center;">84.1</td>
<td style="text-align: center;">-0.6</td>
<td style="text-align: center;">30.7</td>
</tr>
<tr>
<td style="text-align: left;">-[cols,rows]</td>
<td style="text-align: center;">19.6</td>
<td style="text-align: center;">-19.4</td>
<td style="text-align: center;">74.1</td>
<td style="text-align: center;">-10.6</td>
<td style="text-align: center;">17.3</td>
</tr>
<tr>
<td style="text-align: left;">-table pre-training</td>
<td style="text-align: center;">26.5</td>
<td style="text-align: center;">-12.5</td>
<td style="text-align: center;">80.8</td>
<td style="text-align: center;">-3.9</td>
<td style="text-align: center;">17.9</td>
</tr>
<tr>
<td style="text-align: left;">-aggregation</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">82.6</td>
<td style="text-align: center;">-2.1</td>
<td style="text-align: center;">23.1</td>
<td style="text-align: center;">-5.9</td>
</tr>
</tbody>
</table>
<p>Table 6: Dev accuracy with different embeddings removed from the full model: positional (pos), numeric ranks (ranks), column (cols) and row (rows). The model without table pre-training was initialized from the original BERT model pre-trained on text only. The model without aggregation is only trained with the cell selection loss.</p>
<p>For SQA, Table 5 shows that TAPAS leads to substantial improvements on all metrics: Improving all metrics by at least 11 points, sequence accuracy from 28.1 to 40.4 and average question accuracy from 55.1 to 67.2 .</p>
<p>Model ablations Table 6 shows an ablation study on our different embeddings. To this end we pretrain and fine-tune models with different features. As pre-training is expensive we limit it to 200,000 steps. For all datasets we see that pre-training on tables and column and row embeddings are the most important. Positional and rank embeddings are also improving the quality but to a lesser extent.</p>
<p>We additionally find that when removing the scalar answer and aggregation losses (i.e., setting $\mathcal{J}_{\mathrm{SA}=0}$ ) from TAPAS, accuracy drops for both datasets. For WIKI TQ, we observe a substantial drop in performance from 29.0 to 23.1 when removing aggregation. For WiKiSQL performance drops from 84.7 to 82.6 . The relatively small decrease for WiKiSQL can be explained by the fact that most examples do not need aggregation to be answered. In principle, $17 \%$ of the examples of</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>the dev set have an aggregation (SUM, AVERAGE or COUNT), however, for all types we find that for more than $98 \%$ of the examples the aggregation is only applied to one or no cells. In the case of SUM and AVERAGE, this means that most examples can be answered by selecting one or no cells from the table. For COUNT the model without aggregation operators achieves 28.2 accuracy (by selecting 0 or 1 from the table) vs. 66.5 for the model with aggregation. Note that 0 and 1 are often found in a special index column. These properties of WIKISQL make it challenging for the model to decide whether to apply aggregation or not. For WIKI TQ on the other hand, we observe a substantial drop in performance from 29.0 to 23.1 when removing aggregation.</p>
<p>Qualitative Analysis on WIKI TQ We manually analyze 200 dev set predictions made by TAPAS on WIKI TQ. For correct predictions via an aggregation, we inspect the selected cells to see if they match the ground truth. We find that $96 \%$ of the correct aggregation predictions where also correct in terms of the cells selected. We further find that $14 \%$ of the correct aggregation predictions had only one cell, and could potentially be achieved by cell selection, with no aggregation.</p>
<p>We also perform an error analysis and identify the following exclusive salient phenomena: (i) $12 \%$ are ambiguous ("Name at least two labels that released the group's albums."), have wrong labels or missing information ; (ii) $10 \%$ of the cases require complex temporal comparisons which could also not be parsed with a rich formalism such as SQL ("what country had the most cities founded in the 1830's?") ; (iii) in $16 \%$ of the cases the gold denotation has a textual value that does not appear in the table, thus it could not be predicted without performing string operations over cell values ; (iv) on $10 \%$, the table is too big to fit in 512 tokens ; (v) on $13 \%$ of the cases TAPAS selected no cells, which suggests introducing penalties for this behaviour ; (vi) on $2 \%$ of the cases, the answer is the difference between scalars, so it is outside of the model capabilities ("how long did anne churchill/spencer live?") ; (vii) the other $37 \%$ of the cases could not be classified to a particular phenomenon.</p>
<p>Pre-training Analysis In order to understand what TAPAS learns during pre-training we analyze its performance on 10,000 held-out examples. We split the data such that the tables in the held-out</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: center;">all</th>
<th style="text-align: center;">text</th>
<th style="text-align: center;">header</th>
<th style="text-align: center;">cell</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">all</td>
<td style="text-align: center;">71.4</td>
<td style="text-align: center;">68.8</td>
<td style="text-align: center;">96.6</td>
<td style="text-align: center;">63.4</td>
</tr>
<tr>
<td style="text-align: left;">word</td>
<td style="text-align: center;">74.1</td>
<td style="text-align: center;">69.7</td>
<td style="text-align: center;">96.9</td>
<td style="text-align: center;">66.6</td>
</tr>
<tr>
<td style="text-align: left;">number</td>
<td style="text-align: center;">53.9</td>
<td style="text-align: center;">51.7</td>
<td style="text-align: center;">83.6</td>
<td style="text-align: center;">53.2</td>
</tr>
</tbody>
</table>
<p>Table 7: Mask LM accuracy on held-out data, when the target word piece is located in the text, table header, cell or anywhere (all) and the target is anything, a word or number.
data do not occur in the training data. Table 7 shows the accuracy of masked word pieces of different types and in different locations. We find that average accuracy across position is relatively high (71.4). Predicting tokens in the header of the table is easiest (96.6), probably because many Wikipedia articles use instances of the same kind of table. Predicting word pieces in cells is a bit harder (63.4) than predicting pieces in the text (68.8). The biggest differences can be observed when comparing predicting words (74.1) and numbers (53.9). This is expected since numbers are very specific and often hard to generalize. The soft-accuracy metric and example (Appendix C) demonstrate, however, that the model is relatively good at predicting numbers that are at least close to the target.</p>
<p>Limitations TAPAS handles single tables as context, which are able to fit in memory. Thus, our model would fail to capture very large tables, or databases that contain multiple tables. In this case, the table(s) could be compressed or filtered, such that only relevant content would be encoded, which we leave for future work.</p>
<p>In addition, although TAPAS can parse compositional structures (e.g., question 2 in Figure 3), its expressivity is limited to a form of an aggregation over a subset of table cells. Thus, structures with multiple aggregations such as "number of actors with an average rating higher than 4" could not be handled correctly. Despite this limitation, TAPAS succeeds in parsing three different datasets, and we did not encounter this kind of errors in Section 5.3. This suggests that the majority of examples in semantic parsing datasets are limited in their compositionality.</p>
<h2>6 Related Work</h2>
<p>Semantic parsing models are mostly trained to produce gold logical forms using an encoder-decoder approach (Jia and Liang, 2016; Dong and Lapata,</p>
<p>2016). To reduce the burden in collecting full logical forms, models are typically trained from weak supervision in the form of denotations. These are used to guide the search for correct logical forms (Clarke et al., 2010; Liang et al., 2011).</p>
<p>Other works suggested end-to-end differentiable models that train from weak supervision, but do not explicitly generate logical forms. Neelakantan et al. (2015) proposed a complex model that sequentially predicts symbolic operations over table segments that are all explicitly predefined by the authors, while Yin et al. (2016) proposed a similar model where the operations themselves are learned during training. Müller et al. (2019) proposed a model that selects table cells, where the table and question are represented as a Graph Neural Network, however their model can not predict aggregations over table cells. Cho et al. (2018) proposed a supervised model that predicts the relevant rows, column and aggregation operation sequentially. In our work, we propose a model that follow this line of work, with a simpler architecture than past models (as the model is a single encoder that performs computation for many operations implicitly) and more coverage (as we support aggregation operators over selected cells).</p>
<p>Finally, pre-training methods have been designed with different training objectives, including language modeling (Dai and Le, 2015; Peters et al., 2018; Radford et al., 2018) and masked language modeling (Devlin et al., 2019; Lample and Conneau, 2019). These methods dramatically boost the performance of natural language understanding models (Peters et al., 2018, inter alia). Recently, several works extended BERT for visual question answering, by pre-training over text-image pairs while masking different regions in the image (Tan and Bansal, 2019; Lu et al., 2019). As for tables, Chen et al. (2019) experimented with rendering a table into natural language so that it can be handled with a pre-trained BERT model. In our work we extend masked language modeling for table representations, by masking table cells or text segments.</p>
<h2>7 Conclusion</h2>
<p>In this paper we presented TAPAS, a model for question answering over tables that avoids generating logical forms. We showed that TAPAS effectively pre-trains over large scale data of text-table pairs and successfully restores masked words and table cells. We additionally showed that the model
can fine-tune on semantic parsing datasets, only using weak supervision, with an end-to-end differentiable recipe. Results show that TAPAS achieves better or competitive results in comparison to state-of-the-art semantic parsers.</p>
<p>In future work we aim to extend the model to represent a database with multiple tables as context, and to effectively handle large tables.</p>
<h2>Acknowledgments</h2>
<p>We would like to thank Yasemin Altun, Srini Narayanan, Slav Petrov, William Cohen, Massimo Nicosia, Syrine Krichene, Jordan Boyd-Graber and the anonymous reviewers for their constructive feedback, useful comments and suggestions. This work was completed in partial fulfillment for the PhD degree of the first author, which was also supported by a Google PhD fellowship.</p>
<h2>References</h2>
<p>R. Agarwal, C. Liang, D. Schuurmans, and M. Norouzi. 2019. Learning to generalize from sparse and underspecified rewards. arXiv preprint arXiv:1902.07198.
D. Andor, C. Alberti, D. Weiss, A. Severyn, A. Presta, K. Ganchev, S. Petrov, and M. Collins. 2016. Globally normalized transition-based neural networks. arXiv preprint arXiv:1603.06042.</p>
<p>Daniel Andor, Luheng He, Kenton Lee, and Emily Pitler. 2019. Giving bert a calculator: Finding operations and arguments with reading comprehension. arXiv preprint arXiv:1909.00109.
Y. Artzi and L. Zettlemoyer. 2013. Weakly supervised learning of semantic parsers for mapping instructions to actions. Transactions of the Association for Computational Linguistics (TACL), 1:49-62.
J. Berant, A. Chou, R. Frostig, and P. Liang. 2013. Semantic parsing on Freebase from question-answer pairs. In Empirical Methods in Natural Language Processing (EMNLP).</p>
<p>Wenhu Chen, Hongmin Wang, Jianshu Chen, Yunkai Zhang, Hong Wang, Shiyang Li, Xiyou Zhou, and William Yang Wang. 2019. Tabfact: A large-scale dataset for table-based fact verification. ArXiv, abs/1909.02164.</p>
<p>Minseok Cho, Reinald Kim Amplayo, Seung won Hwang, and Jonghyuck Park. 2018. Adversarial tableqa: Attention supervision for question answering on tables. In $A C M L$.
J. Clarke, D. Goldwasser, M. Chang, and D. Roth. 2010. Driving semantic parsing from the world's response. In Computational Natural Language Learning (CoNLL), pages 18-27.</p>
<p>A. M. Dai and Q. V. Le. 2015. Semi-supervised sequence learning. In Advances in Neural Information Processing Systems (NeurIPS).</p>
<p>Pradeep Dasigi, Matt Gardner, Shikhar Murty, Luke Zettlemoyer, and Eduard Hovy. 2019. Iterative search for weakly supervised semantic parsing. In Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long and Short Papers), pages 26692680.</p>
<p>Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2019. BERT: Pre-training of deep bidirectional transformers for language understanding. In Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long and Short Papers), pages 4171-4186, Minneapolis, Minnesota. Association for Computational Linguistics.
L. Dong and M. Lapata. 2016. Language to logical form with neural attention. In Association for Computational Linguistics (ACL).
D. Dua, Y. Wang, P. Dasigi, G. Stanovsky, S. Singh, and M. Gardner. 2019. DROP: A reading comprehension benchmark requiring discrete reasoning over paragraphs. In North American Association for Computational Linguistics (NAACL).</p>
<p>Daniel Golovin, Benjamin Solnik, Subhodeep Moitra, Greg Kochanski, John Elliot Karro, and D. Sculley, editors. 2017. Google Vizier: A Service for BlackBox Optimization.
K. Guu, P. Pasupat, E. Z. Liu, and P. Liang. 2017. From language to programs: Bridging reinforcement learning and maximum marginal likelihood. In Association for Computational Linguistics (ACL).
T. Haug, O. Ganea, and P. Grnarova. 2018. Neural multi-step reasoning for question answering on semistructured tables. In European Conference on Information Retrieval.
J. Herzig and J. Berant. 2017. Neural semantic parsing over multiple knowledge-bases. In Association for Computational Linguistics (ACL).
P. J. Huber. 1964. Robust estimation of a location parameter. The Annals of Mathematical Statistics, 35(1):73-101.</p>
<p>Wonseok Hwang, Jinyeung Yim, Seunghyun Park, and Minjoon Seo. 2019. A comprehensive exploration on wikisql with table-aware word contextualization. arXiv preprint arXiv:1902.01069.
S. Iyer, I. Konstas, A. Cheung, J. Krishnamurthy, and L. Zettlemoyer. 2017. Learning a neural semantic parser from user feedback. In Association for Computational Linguistics (ACL).
M. Iyyer, W. Yih, and M. Chang. 2017. Search-based neural structured learning for sequential question answering. In Association for Computational Linguistics (ACL).
R. Jia and P. Liang. 2016. Data recombination for neural semantic parsing. In Association for Computational Linguistics (ACL).
J. Lafferty, A. McCallum, and F. Pereira. 2001. Conditional random fields: Probabilistic models for segmenting and labeling data. In International Conference on Machine Learning (ICML), pages 282-289.</p>
<p>Guillaume Lample and Alexis Conneau. 2019. Crosslingual language model pretraining. arXiv preprint arXiv:1901.07291.</p>
<p>Carolin Lawrence and Stefan Riezler. 2018. Improving a neural semantic parser by counterfactual learning from human bandit feedback. In Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 1820-1830, Melbourne, Australia. Association for Computational Linguistics.
C. Liang, M. Norouzi, J. Berant, Q. Le, and N. Lao. 2018. Memory augmented policy optimization for program synthesis with generalization. In Advances in Neural Information Processing Systems (NeurIPS).
P. Liang, M. I. Jordan, and D. Klein. 2011. Learning dependency-based compositional semantics. In Association for Computational Linguistics (ACL), pages 590-599.</p>
<p>Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Danqi Chen, Omer Levy, Mike Lewis, Luke Zettlemoyer, and Veselin Stoyanov. 2019. Roberta: A robustly optimized BERT pretraining approach. CoRR, abs/1907.11692.</p>
<p>Jiasen Lu, Dhruv Batra, Devi Parikh, and Stefan Lee. 2019. Vilbert: Pretraining task-agnostic visiolinguistic representations for vision-and-language tasks. arXiv preprint arXiv:1908.02265.</p>
<p>Sewon Min, Danqi Chen, Hannaneh Hajishirzi, and Luke Zettlemoyer. 2019. A discrete hard EM approach for weakly supervised question answering. In Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing and the 9th International Joint Conference on Natural Language Processing (EMNLP-IJCNLP), pages 28512864, Hong Kong, China. Association for Computational Linguistics.
D. Muhlgay, J. Herzig, and J. Berant. 2019. Valuebased search in execution space for mapping instructions to programs. In North American Association for Computational Linguistics (NAACL).</p>
<p>Thomas Müller, Francesco Piccinno, Massimo Nicosia, Peter Shaw, and Yasemin Altun. 2019. Answering conversational questions on structured data without logical forms. arXiv preprint arXiv:1908.11787.</p>
<p>A. Neelakantan, Q. V. Le, M. Abadi, A. McCallum, and D. Amodei. 2017. Learning a natural language interface with neural programmer. In International Conference on Learning Representations (ICLR).</p>
<p>Arvind Neelakantan, Quoc V. Le, and Ilya Sutskever. 2015. Neural programmer: Inducing latent programs with gradient descent. CoRR, abs/1511.04834.</p>
<p>Timothy Niven and Hung-Yu Kao. 2019. Probing neural network comprehension of natural language arguments. In Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics, pages 4658-4664, Florence, Italy. Association for Computational Linguistics.</p>
<p>Panupong Pasupat and Percy Liang. 2015. Compositional semantic parsing on semi-structured tables. In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers), pages 1470-1480, Beijing, China. Association for Computational Linguistics.
M. E. Peters, M. Neumann, M. Iyyer, M. Gardner, C. Clark, K. Lee, and L. Zettlemoyer. 2018. Deep contextualized word representations. In North American Association for Computational Linguistics (NAACL).
A. Radford, K. Narasimhan, T. Salimans, and I. Sutskever. 2018. Improving language understanding by generative pre-training. Technical report, OpenAI.
Y. Su and X. Yan. 2017. Cross-domain semantic parsing via paraphrasing. In Empirical Methods in Natural Language Processing (EMNLP).</p>
<p>Yibo Sun, Duyu Tang, Nan Duan, Jingjing Xu, Xiaocheng Feng, and Bing Qin. 2018. Knowledgeaware conversational semantic parsing over web tables. arXiv preprint arXiv:1809.04271.</p>
<p>Hao Tan and Mohit Bansal. 2019. Lxmert: Learning cross-modality encoder representations from transformers. In Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing.</p>
<p>Eric Wallace, Yizhong Wang, Sujian Li, Sameer Singh, and Matt Gardner. 2019. Do nlp models know numbers? probing numeracy in embeddings. arXiv preprint arXiv:1909.07940.</p>
<p>Bailin Wang, Ivan Titov, and Mirella Lapata. 2019. Learning semantic parsers from denotations with latent structured alignments and abstract programs. In Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing and the 9th International Joint Conference on Natural Language Processing (EMNLP-IJCNLP), pages 37723783, Hong Kong, China. Association for Computational Linguistics.
Y. Wang, J. Berant, and P. Liang. 2015. Building a semantic parser overnight. In Association for Computational Linguistics (ACL).</p>
<p>Pengcheng Yin, Zhengdong Lu, Hang Li, and Kao Ben. 2016. Neural enquirer: Learning to query tables in natural language. In Proceedings of the Workshop on Human-Computer Question Answering, pages 29-35, San Diego, California. Association for Computational Linguistics.
Y. Zhang, P. Pasupat, and P. Liang. 2017. Macro grammars and holistic triggering for efficient semantic parsing. In Empirical Methods in Natural Language Processing (EMNLP).</p>
<p>Victor Zhong, Caiming Xiong, and Richard Socher. 2017. Seq2sql: Generating structured queries from natural language using reinforcement learning. CoRR, abs/1709.00103.</p>
<h2>A WIKISQL Execution Errors</h2>
<p>In some tables, WIKISQL contains "REAL" numbers stored in "TEXT" format. This leads to incorrect results for some of the comparison and aggregation examples. These errors in the WIKISQL execution accuracy penalize systems that do their own execution (rather then producing an SQL query). Table 8 shows two examples where our result derivation and the one used by WIKISQL differ because the numbers in the "Crowd" (col5) column are not represented as numbers in the respective SQL table. Table 9 and 10 contain accuracies compared against the official and our answers.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: center;">WIKISQL</th>
<th style="text-align: center;">TAPAS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">TAPAS (no answer loss)</td>
<td style="text-align: center;">81.2</td>
<td style="text-align: center;">82.5</td>
</tr>
<tr>
<td style="text-align: left;">TAPAS</td>
<td style="text-align: center;">83.9</td>
<td style="text-align: center;">85.1</td>
</tr>
<tr>
<td style="text-align: left;">TAPAS (supervised)</td>
<td style="text-align: center;">86.6</td>
<td style="text-align: center;">88.0</td>
</tr>
</tbody>
</table>
<p>Table 9: WiKiSQL development denotation accuracy.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: center;">WIKISQL</th>
<th style="text-align: center;">TAPAS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">TAPAS (no answer loss)</td>
<td style="text-align: center;">80.1</td>
<td style="text-align: center;">81.2</td>
</tr>
<tr>
<td style="text-align: left;">TAPAS</td>
<td style="text-align: center;">82.4</td>
<td style="text-align: center;">83.6</td>
</tr>
<tr>
<td style="text-align: left;">TAPAS (supervised)</td>
<td style="text-align: center;">85.2</td>
<td style="text-align: center;">86.4</td>
</tr>
</tbody>
</table>
<p>Table 10: WiKiSQL test denotation accuracy.</p>
<h2>B Hyperparameters</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">Parameter</th>
<th style="text-align: center;">Values</th>
<th style="text-align: left;">Scale</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Learning rate</td>
<td style="text-align: center;">$(1 \mathrm{e}-5,3 \mathrm{e}-3)$</td>
<td style="text-align: left;">Log</td>
</tr>
<tr>
<td style="text-align: left;">Warmup ratio</td>
<td style="text-align: center;">$(0.0,0.2)$</td>
<td style="text-align: left;">Linear</td>
</tr>
<tr>
<td style="text-align: left;">Temperature</td>
<td style="text-align: center;">$(0.1,1)$</td>
<td style="text-align: left;">Linear</td>
</tr>
<tr>
<td style="text-align: left;">Answer loss cutoff</td>
<td style="text-align: center;">$(0.1,10,000)$</td>
<td style="text-align: left;">Log</td>
</tr>
<tr>
<td style="text-align: left;">Huber loss delta</td>
<td style="text-align: center;">$(0.1,10,000)$</td>
<td style="text-align: left;">Log</td>
</tr>
<tr>
<td style="text-align: left;">Cell selection preference</td>
<td style="text-align: center;">$(0,1)$</td>
<td style="text-align: left;">Linear</td>
</tr>
<tr>
<td style="text-align: left;">Reset cell selection weights</td>
<td style="text-align: center;">$[0,1]$</td>
<td style="text-align: left;">Discrete</td>
</tr>
</tbody>
</table>
<p>Table 11: Hyper-parameters for WiKiSQL and WiKITQ. Values are constrained to either a range $(a, b)$ or a list $[a, b, c, \ldots]$.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Parameter</th>
<th style="text-align: center;">PRETRAIN</th>
<th style="text-align: center;">SQA</th>
<th style="text-align: center;">WIKISQL</th>
<th style="text-align: center;">WIKITQ</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Training Steps</td>
<td style="text-align: center;">$1,000,000$</td>
<td style="text-align: center;">200,000</td>
<td style="text-align: center;">50,000</td>
<td style="text-align: center;">50,000</td>
</tr>
<tr>
<td style="text-align: left;">Learning rate</td>
<td style="text-align: center;">$5 \mathrm{e}-5$</td>
<td style="text-align: center;">$1.25 \mathrm{e}-5$</td>
<td style="text-align: center;">$6.17164 \mathrm{e}-5$</td>
<td style="text-align: center;">$1.93581 \mathrm{e}-5$</td>
</tr>
<tr>
<td style="text-align: left;">Warmup ratio</td>
<td style="text-align: center;">0.01</td>
<td style="text-align: center;">0.2</td>
<td style="text-align: center;">0.142400</td>
<td style="text-align: center;">0.128960</td>
</tr>
<tr>
<td style="text-align: left;">Temperature</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">1.0</td>
<td style="text-align: center;">0.107515</td>
<td style="text-align: center;">0.0352513</td>
</tr>
<tr>
<td style="text-align: left;">Answer loss cutoff</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">0.185567</td>
<td style="text-align: center;">0.664694</td>
</tr>
<tr>
<td style="text-align: left;">Huber loss delta</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">1265.74</td>
<td style="text-align: center;">0.121194</td>
</tr>
<tr>
<td style="text-align: left;">Cell selection preference</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">0.611754</td>
<td style="text-align: center;">0.207951</td>
</tr>
<tr>
<td style="text-align: left;">Batch size</td>
<td style="text-align: center;">512</td>
<td style="text-align: center;">128</td>
<td style="text-align: center;">512</td>
<td style="text-align: center;">512</td>
</tr>
<tr>
<td style="text-align: left;">Gradient clipping</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">10</td>
</tr>
<tr>
<td style="text-align: left;">Select one column</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: left;">Reset cell selection weights</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>Table 12: Optimal hyper-parameters found for pretraining (PRETRAIN), SQA, WiKiSQL and WiKiTQ.</p>
<h2>C Pre-training Example</h2>
<p>In order to better understand how well the model predicts numbers, we relax our accuracy measure to a soft form of accuracy:</p>
<p>$$
\operatorname{acc}(x, y)= \begin{cases}1 &amp; \text { if } x=y \ 0 &amp; \text { if } x \text { or } y \text { is not a number } \ 1.0-\frac{|x-y|}{\max (x, y)} &amp; \text { else }\end{cases}
$$</p>
<p>With this soft metric we get an overall accuracy of 74.5 (instead of 71.4 ) and an accuracy of 80.5 (instead of 53.9) for numbers. Showing that the model is pretty good at guessing numbers that are at least close to the target. The following example demonstrates this:</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Team</th>
<th style="text-align: center;">Pld</th>
<th style="text-align: center;">W</th>
<th style="text-align: center;">D</th>
<th style="text-align: center;">L</th>
<th style="text-align: center;">PF</th>
<th style="text-align: center;">PA</th>
<th style="text-align: center;">PD</th>
<th style="text-align: center;">Pts</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">South Korea</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">33</td>
<td style="text-align: center;">22</td>
<td style="text-align: center;">11</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td style="text-align: left;">Spain</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">$\langle\mathbf{1}\rangle$</td>
<td style="text-align: center;">$\langle\mathbf{0}\rangle$</td>
<td style="text-align: center;">31</td>
<td style="text-align: center;">24</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td style="text-align: left;">Zimbabwe</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">22</td>
<td style="text-align: center;">$\langle\mathbf{4 3 , 4 0}\rangle$</td>
<td style="text-align: center;">$-\langle\mathbf{1 9 , 1 8}\rangle$</td>
<td style="text-align: center;">2</td>
</tr>
</tbody>
</table>
<p>Table 13: Table example from the Wikipedia page describing the 1997 Rugby World Cup Sevens. $\langle\mathrm{x}\rangle$ marks a correct prediction and $\langle\mathrm{x}, \mathrm{y}\rangle$ an incorrect prediction.</p>
<p>In the example, the model correctly restores the Draw (D) and Loss (L) numbers for Spain. It fails to restore the Points For (PF) and Points Against (PA) for Zimbabwe, but gives close estimates. Note that the model also does not produce completely consistent results for each row we should have $\mathrm{PA}+\mathrm{PD}=\mathrm{PF}$ and the column sums of PF and PA should equal.</p>
<h2>D The average of stochastic sets</h2>
<p>Our approach to estimate aggregates of cells in the table operates directly on latent conditionally independent Bernoulli variables $G_{c} \sim \operatorname{Bern}\left(p_{c}\right)$ that indicate whether each cell is included in the aggregation and a latent categorical variable that indicates the chosen aggregation operation op: AVERAGE,</p>
<table>
<thead>
<tr>
<th style="text-align: left;">col0</th>
<th style="text-align: left;">col1</th>
<th style="text-align: left;">col2</th>
<th style="text-align: left;">col3</th>
<th style="text-align: left;">col4</th>
<th style="text-align: left;">col5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Home team</td>
<td style="text-align: left;">Home team score</td>
<td style="text-align: left;">Away team</td>
<td style="text-align: left;">Away team score</td>
<td style="text-align: left;">Venue</td>
<td style="text-align: left;">Crowd</td>
</tr>
<tr>
<td style="text-align: left;">geelong</td>
<td style="text-align: left;">18.17 (125)</td>
<td style="text-align: left;">hawthorn</td>
<td style="text-align: left;">6.7 (43)</td>
<td style="text-align: left;">corio oval</td>
<td style="text-align: left;">9,000</td>
</tr>
<tr>
<td style="text-align: left;">footscray</td>
<td style="text-align: left;">8.18 (66)</td>
<td style="text-align: left;">south melbourne</td>
<td style="text-align: left;">11.18 (84)</td>
<td style="text-align: left;">western oval</td>
<td style="text-align: left;">12,500</td>
</tr>
<tr>
<td style="text-align: left;">fitzroy</td>
<td style="text-align: left;">11.5 (71)</td>
<td style="text-align: left;">richmond</td>
<td style="text-align: left;">8.12 (60)</td>
<td style="text-align: left;">brunswick street oval</td>
<td style="text-align: left;">14,000</td>
</tr>
<tr>
<td style="text-align: left;">north melbourne</td>
<td style="text-align: left;">6.12 (48)</td>
<td style="text-align: left;">essendon</td>
<td style="text-align: left;">14.11 (95)</td>
<td style="text-align: left;">arden street oval</td>
<td style="text-align: left;">8,000</td>
</tr>
<tr>
<td style="text-align: left;">st kilda</td>
<td style="text-align: left;">14.7 (91)</td>
<td style="text-align: left;">collingwood</td>
<td style="text-align: left;">17.13 (115)</td>
<td style="text-align: left;">junction oval</td>
<td style="text-align: left;">16,000</td>
</tr>
<tr>
<td style="text-align: left;">melbourne</td>
<td style="text-align: left;">12.11 (83)</td>
<td style="text-align: left;">carlton</td>
<td style="text-align: left;">11.11 (77)</td>
<td style="text-align: left;">mcg</td>
<td style="text-align: left;">31,481</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: left;">Question</th>
<th style="text-align: left;">What was the away team's score when the crowd at Arden Street Oval was larger than 31,481?</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">SQL Query</td>
<td style="text-align: left;">SELECT col3 AS result FROM table_2_10767641_15</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">WHERE col5 &gt; 31481.0 AND col4 = "arden street oval"</td>
</tr>
<tr>
<td style="text-align: left;">WIKISQL answer</td>
<td style="text-align: left;">["14.11 (95)"]</td>
</tr>
<tr>
<td style="text-align: left;">Our answer</td>
<td style="text-align: left;">[]</td>
</tr>
<tr>
<td style="text-align: left;">Question</td>
<td style="text-align: left;">What was the sum of the crowds at Western Oval?</td>
</tr>
<tr>
<td style="text-align: left;">SQL Query</td>
<td style="text-align: left;">SELECT SUM(col5) AS result FROM table_2_10767641_15</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">WHERE col4 = "western oval"</td>
</tr>
<tr>
<td style="text-align: left;">WIKISQL answer</td>
<td style="text-align: left;">$[12.0]$</td>
</tr>
<tr>
<td style="text-align: left;">Our answer</td>
<td style="text-align: left;">$[12500.0]$</td>
</tr>
</tbody>
</table>
<p>Table 8: Table "2-10767641-15" from WIKISQL. "col 6" was removed. The "Crowd" column is of type "REAL" but the cell values are actually stored as "TEXT". Below we have two questions from the training set with the answer that is produced by the WIKISQL evaluation script and the answer we derive.</p>
<p>SUM or COUNT. Given $G_{c}$ and the table values $T$ we can define a random subset $S \subseteq T$ where $p_{c}=P(c \in S)$ for each cell $c \in T$.</p>
<p>The expected value of $\operatorname{COUNT}(S)=\sum_{c} G_{c}$ can be computed as $\sum_{c} p_{c}$ and $\operatorname{SUM}(S)=\sum_{c} G_{c} T_{c}$ as $\sum_{c} p_{c} T_{c}$ as described in Table 1. For the average however, this is not straight-forward. We will see in what follows that the quotient of the expected sum and the count, which equals the weighed average of $T$ by $p_{c}$ in general is not the true expected value, which can be written as:</p>
<p>$$
\mathbb{E}\left[\frac{\sum G_{c} T_{c}}{\sum G_{c}}\right]
$$</p>
<p>This quantity differs from the weighted average, a key difference being that the weighted average is not sensitive to constants scaling all the output probabilities, which could in theory find optima where all the $p_{c}$ are below 0.5 for example. By the linearity of the expectation we can write:
$\sum_{c} T_{c} \mathbb{E}\left[\frac{G_{c}}{\sum_{j} G_{j}}\right]=\sum_{c} T_{c} p_{c} \mathbb{E}\left[\frac{1}{1+\sum_{j \neq c} G_{j}}\right]$
So it comes down to computing that quantity $Q_{c}=\mathbb{E}\left[\frac{1}{X_{c}}\right]=\mathbb{E}\left[\frac{1}{1+\sum_{j \neq c} G_{j}}\right]$. The key observation is that this is the expectation of a reciprocal
of a Poisson Binomial Distribution ${ }^{5}$ (a sum of Bernoulli variables) in the special case where one of the probabilities is 1 .</p>
<p>By using the Jensen inequality we get a lower bound on $Q_{c}$ as $\frac{1}{\mathbb{E}\left[X_{c}\right]}=\frac{1}{1+\sum_{j \neq c} p_{j}}$. Note that if instead we used $\frac{1}{\sum_{j} p_{j}}$ then we recover the weighted average, which is strictly bigger than the lower bound and in general not an upper or lower bound. We can get better approximations by computing the Taylor expansion using the moments ${ }^{6}$ of $X_{c}$ of order $k$ :</p>
<p>$$
\begin{aligned}
&amp; Q_{c}=\mathbb{E}\left[\frac{1}{X_{c}}\right] \simeq \frac{1}{\mathbb{E}\left[X_{c}\right]}+\frac{\operatorname{var}\left[X_{c}\right]}{\mathbb{E}\left[X_{c}\right]^{3}}+\cdots+ \
&amp;(-1)^{k} \frac{\mathbb{E}\left[\left(X_{c}-\mathbb{E}\left[X_{c}\right]\right)^{k}\right]}{\mathbb{E}\left[X_{c}\right]^{k+1}}
\end{aligned}
$$</p>
<p>where $\operatorname{var}\left[X_{c}\right]=\sum_{j \neq c} p_{j}\left(1-p_{j}\right)$.
The full form for the zero and second order Taylor approximations are:</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>$$
\begin{aligned}
\operatorname{AVERAGE}<em c="c">{0}(T, p) &amp; =\sum</em> \
\operatorname{AVERAGE}} T_{c} \frac{p_{c}}{1+\sum_{j \neq c} p_{j}<em c="c">{2}(T, p) &amp; =\sum</em> \
\text { with } \epsilon_{c} &amp; =\frac{\sum_{j \neq c} p_{j}\left(1-p_{j}\right)}{\left(1+\sum_{j \neq c} p_{j}\right)^{2}}
\end{aligned}
$$} T_{c} \frac{p_{c}\left(1+\epsilon_{c}\right)}{1+\sum_{j \neq c} p_{j}</p>
<p>The approximations are then easy to write in any tensor computation language and will be differentiable. In this work we experimented with the zero and second order approximations and found small improvements over the weighted average baseline. It's worth noting that in the dataset the proportion of average examples is very low. We expect this method to be more relevant in the more general setting.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{5}$ wikipedia.org/Poisson_binomial_distribution
${ }^{6}$ wikipedia.org/Taylor_expansions_for_the_moments&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>